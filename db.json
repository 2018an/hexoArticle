{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","path":"js/jquery-3.6.4.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/JVM运行时区域详解/index.md","hash":"d09c7aa4f334dc20327296eee8fa781202e6aae7","modified":1760405242827},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"06889bee30e4c39479467021da434d3a6a0990fc","modified":1760348213590},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"a93d7b3990e45bc7247eecf01888f71674887a63","modified":1760348213701},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1760348213710},{"_id":"node_modules/hexo-theme-landscape/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1760348213713},{"_id":"node_modules/hexo-theme-landscape/languages/de-DE.yml","hash":"d29d1c4256b7ed9df42f511c2ff0a23ad5fd6c1f","modified":1760348213706},{"_id":"node_modules/hexo-theme-landscape/languages/en-GB.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1760348213715},{"_id":"node_modules/hexo-theme-landscape/languages/en-US.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1760348213717},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1760348213729},{"_id":"node_modules/hexo-theme-landscape/languages/es-ES.yml","hash":"7008a8fc91f18d2a735864817b8ebda30c7a2c66","modified":1760348213725},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1760348213721},{"_id":"node_modules/hexo-theme-landscape/languages/fr-FR.yml","hash":"8d09dbdab00a30a2870b56f7c0a7ca7deafa7b88","modified":1760348213731},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1760348213734},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1760348213740},{"_id":"node_modules/hexo-theme-landscape/languages/hu-HU.yml","hash":"712d18664898fa21ba38d4973e90ef41a324ea25","modified":1760348213736},{"_id":"node_modules/hexo-theme-landscape/languages/it-IT.yml","hash":"2cb6dc2fab9bd2dbe1c8bb869a9e8bf85a564fdd","modified":1760348213742},{"_id":"node_modules/hexo-theme-landscape/languages/ko-KR.yml","hash":"19209ad8f9d4057e8df808937f950eb265e1db69","modified":1760348213755},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1760348213751},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1760348213745},{"_id":"node_modules/hexo-theme-landscape/languages/mn-MN.yml","hash":"b9e5f3e7c0c2f779cf2cfded6db847b5941637ca","modified":1760348213762},{"_id":"node_modules/hexo-theme-landscape/languages/ja-JP.yml","hash":"08481267e0c112e1f6855620f2837ec4c4a98bbd","modified":1760348213749},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1760348213759},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1760348213764},{"_id":"node_modules/hexo-theme-landscape/languages/nl-NL.yml","hash":"5ebbc30021f05d99938f96dfff280392df7f91f0","modified":1760348213766},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1760348213773},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1760348213768},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1760348213779},{"_id":"node_modules/hexo-theme-landscape/languages/ru-RU.yml","hash":"360d11a28bb768afb1dd15f63fa7fd3a8cc547ee","modified":1760348213781},{"_id":"node_modules/hexo-theme-landscape/languages/th.yml","hash":"84a55b00aa01f03982be294e43c33a20e6d32862","modified":1760348213787},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1760348213781},{"_id":"node_modules/hexo-theme-landscape/languages/pt-PT.yml","hash":"0f852b6b228e6ea59aa3540574bb89b233f2a098","modified":1760348213777},{"_id":"node_modules/hexo-theme-landscape/languages/th-TH.yml","hash":"ebfdba9bc4842c829473c1e6e4544344f182724d","modified":1760348213784},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1760348213794},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1760348213792},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1760348213795},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1760348213376},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"57281fc3812c877ec2d8e89ec87ede57b9789d4c","modified":1760348213438},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1760348213327},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1760348213463},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1760348213469},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1760348213445},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1760348213493},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1760348213553},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"1b89d0caba03a66a43d9c290a5e94fa438a89210","modified":1760348213226},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1760348213245},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"e9d4678e14be5e3cd5e34d783e5af6d6626092f5","modified":1760348213340},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"0039146b8ccbdf9b9f8bee58fc6c238f0e9921fc","modified":1760348213277},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1760348213417},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"0e94f5722d4c44d3cc91be2f4fd30b9ab503b868","modified":1760348213424},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1760348213410},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"6a5033d189554c9a6d42e2ef7952ae5c9742648e","modified":1760348213431},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1760348213393},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1760348213450},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1760348213477},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1760348213368},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1760348213474},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1760348213306},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1760348213488},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1760348213498},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1760348213609},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"ca28281423ae57d76b6c1eb91cd845fd4e518bd6","modified":1760348213615},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"e55a1d92954ed20f6887f92dc727bb995a010a43","modified":1760348213697},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1760348213585},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1760348213165},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1760348213354},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1760348213400},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1760348213459},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1760348213502},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1760348213385},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1760348213622},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1760348213483},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"f608400a08cf137ab15ec1f44bac551950afe879","modified":1760348213627},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1760348213631},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"268d2989acb06e2ddd06cc36a6918c6cd865476b","modified":1760348213648},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1760348213635},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"9cc3b2927d814f2f6e8e188f9d3657b94f4c6ef3","modified":1760348213658},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1760348213675},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1760348213685},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1760348213689},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1760347974637},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1760348213693},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1760348213642},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1760348213667},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1760348213074},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1760348213581},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1760348213571},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"6497b70356271fd6f9f1dc862353be844c457a53","modified":1760348213596},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1760348213547},{"_id":"public/2025/10/13/hello-world/index.html","hash":"7291040313e1ca1b0b6b3b8b722c2c60a374f936","modified":1760405336376},{"_id":"public/JVM运行时区域详解/index.html","hash":"7acd6b3a7572586937db21235742e2bc7a49e6fb","modified":1760405336376},{"_id":"public/archives/index.html","hash":"056ce3c18bd83f698bf5ce42ccfbd17d4f364d97","modified":1760405336376},{"_id":"public/archives/2025/index.html","hash":"05cd60f4be241663e1da811cd0df3fc1ae6960c8","modified":1760405336376},{"_id":"public/archives/2025/10/index.html","hash":"dc2b7a197575c85f1bcfcec996ba01fb37c6a98c","modified":1760405336376},{"_id":"public/index.html","hash":"ef839251e0d1142b261cfa07bc7990829a631661","modified":1760405336376},{"_id":"public/css/style.css","hash":"ecc329be740a220cc188ff49b02da4847cb7ee5e","modified":1760405336376},{"_id":"public/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1760405336376},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1760405336376},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1760405336376},{"_id":"public/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1760405336376},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1760405336376},{"_id":"source/_posts/JVM运行时区域详解.md","hash":"6c2c5d2e02f53637f6bce1506f6ce1796afb63c8","modified":1760406935709},{"_id":"source/_posts/i++是线程安全的吗？.md","hash":"b862b3174da2f632b5a321542394ae782e2b0da0","modified":1760406935695},{"_id":"source/_posts/Java多线程join使用及原理.md","hash":"9c05bf7eba3ba207bd98939a5d4e59c6587ca118","modified":1760406935701},{"_id":"source/_posts/Java多线程可以分组还能这样玩.md","hash":"a8992b56f4d0489d367b0ea1b0665e2b9fc4a3ea","modified":1760407033614},{"_id":"source/_posts/Java虚拟机对锁优化所做的努力.md","hash":"88efb2893cd015457604561755542df196668495","modified":1760424212328},{"_id":"source/_posts/sleep( ) 和 wait( ) 的这 5 个区别，你知道几个？.md","hash":"41788403a43f8392a9705fe354d626e993993fae","modified":1760424259316},{"_id":"source/_posts/出场率比较高的一道多线程安全面试题.md","hash":"aec12b525685733fbc25d31791ebe22c2a5b75fd","modified":1760426193114},{"_id":"source/_posts/多线程 Thread.yield 方法到底有什么用？.md","hash":"a15709a422cde4115ed497c2cb13d07d2c53dd4f","modified":1760426193106},{"_id":"source/_posts/Synchronized 有几种用法？.md","hash":"29c97dae23af60ec7df767af8d97fb2ef8aab112","modified":1760424476978},{"_id":"source/_posts/Synchronized 与 ReentrantLock 的区别！.md","hash":"8cf48f2e083af934020705687041cf630519c853","modified":1760424434742},{"_id":"source/_posts/sleep( )和wait( )的这5个区别，你知道几个？.md","hash":"f7ec390176c6bc56b0b1369315f64875d67f8a55","modified":1760424368080},{"_id":"source/_posts/多线程 start 和 run 方法到底有什么区别？.md","hash":"55eb7ddf1c427d6632871a447e9fb24fd93cb44c","modified":1760426193062},{"_id":"source/_posts/多线程通信的三大法器，你真的会用吗？.md","hash":"29790bb8ae7c1414342a3cd917ae4ca4937ad928","modified":1760426193091},{"_id":"source/_posts/到底什么是重入锁，拜托，一次搞清楚！.md","hash":"bf979c0c50cbfff9693ac76ae73bea464544c8e6","modified":1760426193078},{"_id":"source/_posts/一文搞懂 Java 线程中断.md","hash":"4647b38ae62f2e1402b9c07dab0ed8bee9e1f60d","modified":1760424518453},{"_id":"source/_posts/并行任务执行神器 Fork & Join 实战.md","hash":"3681e1d709f612bf7b85b08ac0bcfb660a1ce16f","modified":1760426193121},{"_id":"source/_posts/教你如何监控 Java 线程池运行状态.md","hash":"f3462f4e7bd8cf4d1adaea35dbda9e79249a3a4b","modified":1760426193084},{"_id":"source/_posts/线程休眠只会用Thread.sleep？那就弱爆了！.md","hash":"5996ac01b25e28ae090add4732c34f827b07a4e3","modified":1760426193099},{"_id":"source/_posts/基础/Java 中的基本数据类型转换详解.md","hash":"407f87fad33c077eeafc2e750f08aae9f9601527","modified":1760427371251},{"_id":"source/_posts/面试官问线程安全的List，看完再也不怕了！.md","hash":"6d2eb852ca68c3fe79d8312088ceb4d1ac9477eb","modified":1760426193070},{"_id":"source/_posts/基础/10 个深恶痛绝的 Java 异常.md","hash":"9262bb1af7eea09d326f54f91bb794232f169a66","modified":1760426281143},{"_id":"source/_posts/基础/Java Jar包压缩、解压使用指南.md","hash":"edc7e05c1e278aee64c447ebbfec67f5763c92f4","modified":1760426568380},{"_id":"source/_posts/基础/Java Base64 编码解码方案总结.md","hash":"9a8dfb176e27f1ae97974ef2eaa4b5a8c47af1a9","modified":1760427082846},{"_id":"source/_posts/基础/switch多值匹配骚操作，带你涨姿势！.md","hash":"6db8e810d4aacc8396b8cd54151ee6b15735e391","modified":1760427371225},{"_id":"source/_posts/基础/StringBuffer 和 StringBuilder 的 3 个区别.md","hash":"f8bd874bae6e806199b9eda05d7d6c11b7ed99da","modified":1760427371238},{"_id":"source/_posts/基础/switch case 支持的 6 种数据类型！.md","hash":"30b9a9ed36127a0f5e35132855ad121ee14de055","modified":1760427371246},{"_id":"source/_posts/基础/你真的搞懂 transient  关键字了吗？.md","hash":"3ced00a3236c541a9a4de0abf5e5d64a2dac461e","modified":1760427371257},{"_id":"source/_posts/基础/Java 父类强制转换子类原则.md","hash":"3e3279e8fed78a08f5b450a6416de049140da2a3","modified":1760427371232},{"_id":"source/_posts/基础/你真的搞懂 transient 关键字了吗？.md","hash":"90d0359640f393af4070e1632757b0d702bce2c4","modified":1760427371269},{"_id":"source/_posts/基础/关于 Java 序列化你不知道的 5 件事.md","hash":"fa3a94708688225a77d0896ca57808413b9eb7c4","modified":1760427371275},{"_id":"source/_posts/基础/一张图搞清楚Java异常机制.md","hash":"bc081129086cabeb8401faf3e153a45d2d5cfbc7","modified":1760427371263},{"_id":"source/_posts/基础/关于Java序列化你应该知道的一切.md","hash":"842d887a7ccbc1fc77db0598f189e9e42acad2a2","modified":1760427165030},{"_id":"source/_posts/基础/通用唯一标识码 UUID 的介绍及使用。.md","hash":"464105c3d15b77a63397f077547090ec6ff6a391","modified":1760427082871},{"_id":"source/_posts/基础/坑爹的 Java 可变参数，把我整得够惨。.md","hash":"db11206ef7beb1e2855bcd50d97b520decad0928","modified":1760427165043},{"_id":"source/_posts/基础/深入浅出 Java 中的包装类.md","hash":"c8042030b0565088a2135d3aabbf55b4bfba443c","modified":1760426616602},{"_id":"source/_posts/基础/常见的 3 种 Class 级别的错误.md","hash":"4f8c04d473e8d6b36df7e4590f2f6792840f8c6c","modified":1760427082852},{"_id":"source/_posts/基础/字符串拼接 + 和 concat 的区别.md","hash":"ec8d51d89656c519b37f3af4248bf22b25c4bcb0","modified":1760427165036}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2025-10-13T09:36:44.695Z","updated":"2025-10-13T09:32:54.637Z","comments":1,"layout":"post","photos":[],"_id":"cmgpvvv4a0001ggd423pyht6o","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"JVM运行时区域详解","date":"2025-10-14T01:30:25.000Z","_content":"\n我们知道的JVM内存区域有：堆和栈，这是一种泛的分法，也是按运行时区域的一种分法，堆是所有线程共享的一块区域，而栈是线程隔离的，每个线程互不共享。\n\n### 线程不共享区域\n\n每个线程的数据区域包括程序计数器、虚拟机栈和本地方法栈，它们都是在新线程创建时才创建的。\n\n\n##### 程序计数器（Program Counter Rerister）\n\n程序计数器区域一块内存较小的区域，它用于存储线程的每个执行指令，每个线程都有自己的程序计数器，此区域不会有内存溢出的情况。\n\n##### 虚拟机栈（VM Stack）\n\n虚拟机栈描述的是Java方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\n\n##### 本地方法栈（Native Method Stack）\n\n本地方法栈用于支持本地方法（native标识的方法，即非Java语言实现的方法）。 　\n\n虚拟机栈和本地方法栈，当线程请求分配的栈容量超过JVM允许的最大容量时抛出StackOverflowError异常。\n\n线程不共享区域如下图绿色背景所示。\n\n![image](https://www.programcreek.com/wp-content/uploads/2013/04/JVM-runtime-data-area.jpg)\n\n### 线程共享区域\n\n线程共享区域包含：堆和方法区。\n\n##### 堆（Heap）\n\n堆是最常处理的区域，它存储在JVM启动时创建的数组和对象，JVM垃圾收集也主要是在堆上面工作。\n\n如果实际所需的堆超过了自动内存管理系统能提供的最大容量时抛出OutOfMemoryError异常。\n\n##### 方法区（Method Area）\n\n方法区是可供各条线程共享的运行时内存区域。存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法。\n\n当创建类和接口时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大内存空间后就会抛出OutOfMemoryError\n\n##### 运行时常量池（Runtime Constant Pool）\n\n运行时常量池是方法区的一部分，每一个运行时常量池都分配在JVM的方法区中，在类和接口被加载到JVM后，对应的运行时常量池就被创建。运行时常量池是每一个类或接口的常量池（Constant_Pool）的运行时表现形式，它包括了若干种常量：编译器可知的数值字面量到必须运行期解析后才能获得的方法或字段的引用。\n\n如果方法区的内存空间不能满足内存分配请求，那Java虚拟机将抛出一个OutOfMemoryError异常。\n\n![image](https://www.programcreek.com/wp-content/uploads/2013/04/JVM-Stack.png)\n\n栈包含Frames，当调用方法时，Frame被推送到堆栈。一个Frame包含局部变量数组、操作数栈、常量池引用。\n","source":"_posts/JVM运行时区域详解.md","raw":"---\ntitle: JVM运行时区域详解\ndate: 2025-10-14 09:30:25\ntags: JVM\n---\n\n我们知道的JVM内存区域有：堆和栈，这是一种泛的分法，也是按运行时区域的一种分法，堆是所有线程共享的一块区域，而栈是线程隔离的，每个线程互不共享。\n\n### 线程不共享区域\n\n每个线程的数据区域包括程序计数器、虚拟机栈和本地方法栈，它们都是在新线程创建时才创建的。\n\n\n##### 程序计数器（Program Counter Rerister）\n\n程序计数器区域一块内存较小的区域，它用于存储线程的每个执行指令，每个线程都有自己的程序计数器，此区域不会有内存溢出的情况。\n\n##### 虚拟机栈（VM Stack）\n\n虚拟机栈描述的是Java方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\n\n##### 本地方法栈（Native Method Stack）\n\n本地方法栈用于支持本地方法（native标识的方法，即非Java语言实现的方法）。 　\n\n虚拟机栈和本地方法栈，当线程请求分配的栈容量超过JVM允许的最大容量时抛出StackOverflowError异常。\n\n线程不共享区域如下图绿色背景所示。\n\n![image](https://www.programcreek.com/wp-content/uploads/2013/04/JVM-runtime-data-area.jpg)\n\n### 线程共享区域\n\n线程共享区域包含：堆和方法区。\n\n##### 堆（Heap）\n\n堆是最常处理的区域，它存储在JVM启动时创建的数组和对象，JVM垃圾收集也主要是在堆上面工作。\n\n如果实际所需的堆超过了自动内存管理系统能提供的最大容量时抛出OutOfMemoryError异常。\n\n##### 方法区（Method Area）\n\n方法区是可供各条线程共享的运行时内存区域。存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法。\n\n当创建类和接口时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大内存空间后就会抛出OutOfMemoryError\n\n##### 运行时常量池（Runtime Constant Pool）\n\n运行时常量池是方法区的一部分，每一个运行时常量池都分配在JVM的方法区中，在类和接口被加载到JVM后，对应的运行时常量池就被创建。运行时常量池是每一个类或接口的常量池（Constant_Pool）的运行时表现形式，它包括了若干种常量：编译器可知的数值字面量到必须运行期解析后才能获得的方法或字段的引用。\n\n如果方法区的内存空间不能满足内存分配请求，那Java虚拟机将抛出一个OutOfMemoryError异常。\n\n![image](https://www.programcreek.com/wp-content/uploads/2013/04/JVM-Stack.png)\n\n栈包含Frames，当调用方法时，Frame被推送到堆栈。一个Frame包含局部变量数组、操作数栈、常量池引用。\n","slug":"JVM运行时区域详解","published":1,"updated":"2025-10-14T01:55:35.709Z","_id":"cmgpvylr20000gkd4h4x9hmcv","comments":1,"layout":"post","photos":[],"content":"<p>我们知道的JVM内存区域有：堆和栈，这是一种泛的分法，也是按运行时区域的一种分法，堆是所有线程共享的一块区域，而栈是线程隔离的，每个线程互不共享。</p>\n<h3 id=\"线程不共享区域\"><a href=\"#线程不共享区域\" class=\"headerlink\" title=\"线程不共享区域\"></a>线程不共享区域</h3><p>每个线程的数据区域包括程序计数器、虚拟机栈和本地方法栈，它们都是在新线程创建时才创建的。</p>\n<h5 id=\"程序计数器（Program-Counter-Rerister）\"><a href=\"#程序计数器（Program-Counter-Rerister）\" class=\"headerlink\" title=\"程序计数器（Program Counter Rerister）\"></a>程序计数器（Program Counter Rerister）</h5><p>程序计数器区域一块内存较小的区域，它用于存储线程的每个执行指令，每个线程都有自己的程序计数器，此区域不会有内存溢出的情况。</p>\n<h5 id=\"虚拟机栈（VM-Stack）\"><a href=\"#虚拟机栈（VM-Stack）\" class=\"headerlink\" title=\"虚拟机栈（VM Stack）\"></a>虚拟机栈（VM Stack）</h5><p>虚拟机栈描述的是Java方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>\n<h5 id=\"本地方法栈（Native-Method-Stack）\"><a href=\"#本地方法栈（Native-Method-Stack）\" class=\"headerlink\" title=\"本地方法栈（Native Method Stack）\"></a>本地方法栈（Native Method Stack）</h5><p>本地方法栈用于支持本地方法（native标识的方法，即非Java语言实现的方法）。 　</p>\n<p>虚拟机栈和本地方法栈，当线程请求分配的栈容量超过JVM允许的最大容量时抛出StackOverflowError异常。</p>\n<p>线程不共享区域如下图绿色背景所示。</p>\n<p><img src=\"https://www.programcreek.com/wp-content/uploads/2013/04/JVM-runtime-data-area.jpg\" alt=\"image\"></p>\n<h3 id=\"线程共享区域\"><a href=\"#线程共享区域\" class=\"headerlink\" title=\"线程共享区域\"></a>线程共享区域</h3><p>线程共享区域包含：堆和方法区。</p>\n<h5 id=\"堆（Heap）\"><a href=\"#堆（Heap）\" class=\"headerlink\" title=\"堆（Heap）\"></a>堆（Heap）</h5><p>堆是最常处理的区域，它存储在JVM启动时创建的数组和对象，JVM垃圾收集也主要是在堆上面工作。</p>\n<p>如果实际所需的堆超过了自动内存管理系统能提供的最大容量时抛出OutOfMemoryError异常。</p>\n<h5 id=\"方法区（Method-Area）\"><a href=\"#方法区（Method-Area）\" class=\"headerlink\" title=\"方法区（Method Area）\"></a>方法区（Method Area）</h5><p>方法区是可供各条线程共享的运行时内存区域。存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法。</p>\n<p>当创建类和接口时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大内存空间后就会抛出OutOfMemoryError</p>\n<h5 id=\"运行时常量池（Runtime-Constant-Pool）\"><a href=\"#运行时常量池（Runtime-Constant-Pool）\" class=\"headerlink\" title=\"运行时常量池（Runtime Constant Pool）\"></a>运行时常量池（Runtime Constant Pool）</h5><p>运行时常量池是方法区的一部分，每一个运行时常量池都分配在JVM的方法区中，在类和接口被加载到JVM后，对应的运行时常量池就被创建。运行时常量池是每一个类或接口的常量池（Constant_Pool）的运行时表现形式，它包括了若干种常量：编译器可知的数值字面量到必须运行期解析后才能获得的方法或字段的引用。</p>\n<p>如果方法区的内存空间不能满足内存分配请求，那Java虚拟机将抛出一个OutOfMemoryError异常。</p>\n<p><img src=\"https://www.programcreek.com/wp-content/uploads/2013/04/JVM-Stack.png\" alt=\"image\"></p>\n<p>栈包含Frames，当调用方法时，Frame被推送到堆栈。一个Frame包含局部变量数组、操作数栈、常量池引用。</p>\n","excerpt":"","more":"<p>我们知道的JVM内存区域有：堆和栈，这是一种泛的分法，也是按运行时区域的一种分法，堆是所有线程共享的一块区域，而栈是线程隔离的，每个线程互不共享。</p>\n<h3 id=\"线程不共享区域\"><a href=\"#线程不共享区域\" class=\"headerlink\" title=\"线程不共享区域\"></a>线程不共享区域</h3><p>每个线程的数据区域包括程序计数器、虚拟机栈和本地方法栈，它们都是在新线程创建时才创建的。</p>\n<h5 id=\"程序计数器（Program-Counter-Rerister）\"><a href=\"#程序计数器（Program-Counter-Rerister）\" class=\"headerlink\" title=\"程序计数器（Program Counter Rerister）\"></a>程序计数器（Program Counter Rerister）</h5><p>程序计数器区域一块内存较小的区域，它用于存储线程的每个执行指令，每个线程都有自己的程序计数器，此区域不会有内存溢出的情况。</p>\n<h5 id=\"虚拟机栈（VM-Stack）\"><a href=\"#虚拟机栈（VM-Stack）\" class=\"headerlink\" title=\"虚拟机栈（VM Stack）\"></a>虚拟机栈（VM Stack）</h5><p>虚拟机栈描述的是Java方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>\n<h5 id=\"本地方法栈（Native-Method-Stack）\"><a href=\"#本地方法栈（Native-Method-Stack）\" class=\"headerlink\" title=\"本地方法栈（Native Method Stack）\"></a>本地方法栈（Native Method Stack）</h5><p>本地方法栈用于支持本地方法（native标识的方法，即非Java语言实现的方法）。 　</p>\n<p>虚拟机栈和本地方法栈，当线程请求分配的栈容量超过JVM允许的最大容量时抛出StackOverflowError异常。</p>\n<p>线程不共享区域如下图绿色背景所示。</p>\n<p><img src=\"https://www.programcreek.com/wp-content/uploads/2013/04/JVM-runtime-data-area.jpg\" alt=\"image\"></p>\n<h3 id=\"线程共享区域\"><a href=\"#线程共享区域\" class=\"headerlink\" title=\"线程共享区域\"></a>线程共享区域</h3><p>线程共享区域包含：堆和方法区。</p>\n<h5 id=\"堆（Heap）\"><a href=\"#堆（Heap）\" class=\"headerlink\" title=\"堆（Heap）\"></a>堆（Heap）</h5><p>堆是最常处理的区域，它存储在JVM启动时创建的数组和对象，JVM垃圾收集也主要是在堆上面工作。</p>\n<p>如果实际所需的堆超过了自动内存管理系统能提供的最大容量时抛出OutOfMemoryError异常。</p>\n<h5 id=\"方法区（Method-Area）\"><a href=\"#方法区（Method-Area）\" class=\"headerlink\" title=\"方法区（Method Area）\"></a>方法区（Method Area）</h5><p>方法区是可供各条线程共享的运行时内存区域。存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法。</p>\n<p>当创建类和接口时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大内存空间后就会抛出OutOfMemoryError</p>\n<h5 id=\"运行时常量池（Runtime-Constant-Pool）\"><a href=\"#运行时常量池（Runtime-Constant-Pool）\" class=\"headerlink\" title=\"运行时常量池（Runtime Constant Pool）\"></a>运行时常量池（Runtime Constant Pool）</h5><p>运行时常量池是方法区的一部分，每一个运行时常量池都分配在JVM的方法区中，在类和接口被加载到JVM后，对应的运行时常量池就被创建。运行时常量池是每一个类或接口的常量池（Constant_Pool）的运行时表现形式，它包括了若干种常量：编译器可知的数值字面量到必须运行期解析后才能获得的方法或字段的引用。</p>\n<p>如果方法区的内存空间不能满足内存分配请求，那Java虚拟机将抛出一个OutOfMemoryError异常。</p>\n<p><img src=\"https://www.programcreek.com/wp-content/uploads/2013/04/JVM-Stack.png\" alt=\"image\"></p>\n<p>栈包含Frames，当调用方法时，Frame被推送到堆栈。一个Frame包含局部变量数组、操作数栈、常量池引用。</p>\n"},{"title":"i++是线程安全的吗?","date":"2025-10-14T01:33:33.000Z","_content":"\n![](http://img.javastack.cn/18-6-8/12258861.jpg)\n\n**i++ 是线程安全的吗？**\n\n相信很多中高级的 Java 面试者都遇到过这个问题，很多对这个不是很清楚的肯定是一脸蒙逼。内心肯定还在质疑，i++ 居然还有线程安全问题？只能说自己了解的不够多，自己的水平有限。\n\n先来看下面的示例来验证下 i++ 到底是不是线程安全的。\n\n**1000个线程，每个线程对共享变量 count 进行 1000 次 ++ 操作。**\n\n```\nstatic int count = 0;\n\nstatic CountDownLatch cdl = new CountDownLatch(1000);\n\n/**\n* \n*/\npublic static void main(String[] args) throws Exception {\n\tCountRunnable countRunnable = new CountRunnable();\n\tfor (int i = 0; i < 1000; i++) {\n\t\tnew Thread(countRunnable).start();\n\t}\n\tcdl.await();\n\tSystem.out.println(count);\n}\n\nstatic class CountRunnable implements Runnable {\n\n\tprivate void count() {\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tcount++;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tcount();\n\t\tcdl.countDown();\n\t}\n\n}\n```\n\n上面的例子我们期望的结果应该是 1000000，但运行 N 遍，你会发现总是不为 1000000，至少你现在知道了 i++ 操作它不是线程安全的了。\n\n先来看 JMM 模型中对共享变量的读写原理吧。\n\n![](http://img.javastack.cn/18-6-8/60972585.jpg)\n\n每个线程都有自己的工作内存，每个线程需要对共享变量操作时必须先把共享变量从主内存 load 到自己的工作内存，等完成对共享变量的操作时再 save 到主内存。\n\n问题就出在这了，如果一个线程运算完后还没刷到主内存，此时这个共享变量的值被另外一个线程从主内存读取到了，这个时候读取的数据就是脏数据了，它会覆盖其他线程计算完的值。。。\n\n**这也是经典的内存不可见问题，那么把 count 加上 volatile 让内存可见是否能解决这个问题呢？** 答案是：不能。因为 volatile 只能保证可见性，不能保证原子性。多个线程同时读取这个共享变量的值，就算保证其他线程修改的可见性，也不能保证线程之间读取到同样的值然后相互覆盖对方的值的情况。\n\n关于多线程的几种关键概念请翻阅《[多线程之原子性、可见性、有序性详解](https://mp.weixin.qq.com/s/DWaxnysIQ8NSWN1NME_HvA)》这篇文章。\n\n#### 解决方案\n\n说了这么多，对于 i++ 这种线程不安全问题有没有其他解决方案呢？当然有，请参考以下几种解决方案。\n\n1、对 i++ 操作的方法加同步锁，同时只能有一个线程执行 i++ 操作；\n\n2、使用支持原子性操作的类，如 `java.util.concurrent.atomic.AtomicInteger`，它使用的是 CAS 算法，效率优于第 1 种；\n\n如果对你有帮助，点个赞分享下给个鼓励吧！\n","source":"_posts/i++是线程安全的吗？.md","raw":"---\ntitle: i++是线程安全的吗?\ndate: 2025-10-14 09:33:33\ntags: 多线程\n---\n\n![](http://img.javastack.cn/18-6-8/12258861.jpg)\n\n**i++ 是线程安全的吗？**\n\n相信很多中高级的 Java 面试者都遇到过这个问题，很多对这个不是很清楚的肯定是一脸蒙逼。内心肯定还在质疑，i++ 居然还有线程安全问题？只能说自己了解的不够多，自己的水平有限。\n\n先来看下面的示例来验证下 i++ 到底是不是线程安全的。\n\n**1000个线程，每个线程对共享变量 count 进行 1000 次 ++ 操作。**\n\n```\nstatic int count = 0;\n\nstatic CountDownLatch cdl = new CountDownLatch(1000);\n\n/**\n* \n*/\npublic static void main(String[] args) throws Exception {\n\tCountRunnable countRunnable = new CountRunnable();\n\tfor (int i = 0; i < 1000; i++) {\n\t\tnew Thread(countRunnable).start();\n\t}\n\tcdl.await();\n\tSystem.out.println(count);\n}\n\nstatic class CountRunnable implements Runnable {\n\n\tprivate void count() {\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tcount++;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tcount();\n\t\tcdl.countDown();\n\t}\n\n}\n```\n\n上面的例子我们期望的结果应该是 1000000，但运行 N 遍，你会发现总是不为 1000000，至少你现在知道了 i++ 操作它不是线程安全的了。\n\n先来看 JMM 模型中对共享变量的读写原理吧。\n\n![](http://img.javastack.cn/18-6-8/60972585.jpg)\n\n每个线程都有自己的工作内存，每个线程需要对共享变量操作时必须先把共享变量从主内存 load 到自己的工作内存，等完成对共享变量的操作时再 save 到主内存。\n\n问题就出在这了，如果一个线程运算完后还没刷到主内存，此时这个共享变量的值被另外一个线程从主内存读取到了，这个时候读取的数据就是脏数据了，它会覆盖其他线程计算完的值。。。\n\n**这也是经典的内存不可见问题，那么把 count 加上 volatile 让内存可见是否能解决这个问题呢？** 答案是：不能。因为 volatile 只能保证可见性，不能保证原子性。多个线程同时读取这个共享变量的值，就算保证其他线程修改的可见性，也不能保证线程之间读取到同样的值然后相互覆盖对方的值的情况。\n\n关于多线程的几种关键概念请翻阅《[多线程之原子性、可见性、有序性详解](https://mp.weixin.qq.com/s/DWaxnysIQ8NSWN1NME_HvA)》这篇文章。\n\n#### 解决方案\n\n说了这么多，对于 i++ 这种线程不安全问题有没有其他解决方案呢？当然有，请参考以下几种解决方案。\n\n1、对 i++ 操作的方法加同步锁，同时只能有一个线程执行 i++ 操作；\n\n2、使用支持原子性操作的类，如 `java.util.concurrent.atomic.AtomicInteger`，它使用的是 CAS 算法，效率优于第 1 种；\n\n如果对你有帮助，点个赞分享下给个鼓励吧！\n","slug":"i++是线程安全的吗？","published":1,"updated":"2025-10-14T01:55:35.695Z","_id":"cmgpw6zh90000fwd47fbh55qf","comments":1,"layout":"post","photos":[],"content":"<p><img src=\"http://img.javastack.cn/18-6-8/12258861.jpg\"></p>\n<p><strong>i++ 是线程安全的吗？</strong></p>\n<p>相信很多中高级的 Java 面试者都遇到过这个问题，很多对这个不是很清楚的肯定是一脸蒙逼。内心肯定还在质疑，i++ 居然还有线程安全问题？只能说自己了解的不够多，自己的水平有限。</p>\n<p>先来看下面的示例来验证下 i++ 到底是不是线程安全的。</p>\n<p><strong>1000个线程，每个线程对共享变量 count 进行 1000 次 ++ 操作。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int count = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">static CountDownLatch cdl = new CountDownLatch(1000);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* </span><br><span class=\"line\">*/</span><br><span class=\"line\">public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\tCountRunnable countRunnable = new CountRunnable();</span><br><span class=\"line\">\tfor (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">\t\tnew Thread(countRunnable).start();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcdl.await();</span><br><span class=\"line\">\tSystem.out.println(count);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static class CountRunnable implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate void count() &#123;</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">\t\t\tcount++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void run() &#123;</span><br><span class=\"line\">\t\tcount();</span><br><span class=\"line\">\t\tcdl.countDown();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子我们期望的结果应该是 1000000，但运行 N 遍，你会发现总是不为 1000000，至少你现在知道了 i++ 操作它不是线程安全的了。</p>\n<p>先来看 JMM 模型中对共享变量的读写原理吧。</p>\n<p><img src=\"http://img.javastack.cn/18-6-8/60972585.jpg\"></p>\n<p>每个线程都有自己的工作内存，每个线程需要对共享变量操作时必须先把共享变量从主内存 load 到自己的工作内存，等完成对共享变量的操作时再 save 到主内存。</p>\n<p>问题就出在这了，如果一个线程运算完后还没刷到主内存，此时这个共享变量的值被另外一个线程从主内存读取到了，这个时候读取的数据就是脏数据了，它会覆盖其他线程计算完的值。。。</p>\n<p><strong>这也是经典的内存不可见问题，那么把 count 加上 volatile 让内存可见是否能解决这个问题呢？</strong> 答案是：不能。因为 volatile 只能保证可见性，不能保证原子性。多个线程同时读取这个共享变量的值，就算保证其他线程修改的可见性，也不能保证线程之间读取到同样的值然后相互覆盖对方的值的情况。</p>\n<p>关于多线程的几种关键概念请翻阅《<a href=\"https://mp.weixin.qq.com/s/DWaxnysIQ8NSWN1NME_HvA\">多线程之原子性、可见性、有序性详解</a>》这篇文章。</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>说了这么多，对于 i++ 这种线程不安全问题有没有其他解决方案呢？当然有，请参考以下几种解决方案。</p>\n<p>1、对 i++ 操作的方法加同步锁，同时只能有一个线程执行 i++ 操作；</p>\n<p>2、使用支持原子性操作的类，如 <code>java.util.concurrent.atomic.AtomicInteger</code>，它使用的是 CAS 算法，效率优于第 1 种；</p>\n<p>如果对你有帮助，点个赞分享下给个鼓励吧！</p>\n","excerpt":"","more":"<p><img src=\"http://img.javastack.cn/18-6-8/12258861.jpg\"></p>\n<p><strong>i++ 是线程安全的吗？</strong></p>\n<p>相信很多中高级的 Java 面试者都遇到过这个问题，很多对这个不是很清楚的肯定是一脸蒙逼。内心肯定还在质疑，i++ 居然还有线程安全问题？只能说自己了解的不够多，自己的水平有限。</p>\n<p>先来看下面的示例来验证下 i++ 到底是不是线程安全的。</p>\n<p><strong>1000个线程，每个线程对共享变量 count 进行 1000 次 ++ 操作。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int count = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">static CountDownLatch cdl = new CountDownLatch(1000);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* </span><br><span class=\"line\">*/</span><br><span class=\"line\">public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\tCountRunnable countRunnable = new CountRunnable();</span><br><span class=\"line\">\tfor (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">\t\tnew Thread(countRunnable).start();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcdl.await();</span><br><span class=\"line\">\tSystem.out.println(count);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static class CountRunnable implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate void count() &#123;</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">\t\t\tcount++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void run() &#123;</span><br><span class=\"line\">\t\tcount();</span><br><span class=\"line\">\t\tcdl.countDown();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子我们期望的结果应该是 1000000，但运行 N 遍，你会发现总是不为 1000000，至少你现在知道了 i++ 操作它不是线程安全的了。</p>\n<p>先来看 JMM 模型中对共享变量的读写原理吧。</p>\n<p><img src=\"http://img.javastack.cn/18-6-8/60972585.jpg\"></p>\n<p>每个线程都有自己的工作内存，每个线程需要对共享变量操作时必须先把共享变量从主内存 load 到自己的工作内存，等完成对共享变量的操作时再 save 到主内存。</p>\n<p>问题就出在这了，如果一个线程运算完后还没刷到主内存，此时这个共享变量的值被另外一个线程从主内存读取到了，这个时候读取的数据就是脏数据了，它会覆盖其他线程计算完的值。。。</p>\n<p><strong>这也是经典的内存不可见问题，那么把 count 加上 volatile 让内存可见是否能解决这个问题呢？</strong> 答案是：不能。因为 volatile 只能保证可见性，不能保证原子性。多个线程同时读取这个共享变量的值，就算保证其他线程修改的可见性，也不能保证线程之间读取到同样的值然后相互覆盖对方的值的情况。</p>\n<p>关于多线程的几种关键概念请翻阅《<a href=\"https://mp.weixin.qq.com/s/DWaxnysIQ8NSWN1NME_HvA\">多线程之原子性、可见性、有序性详解</a>》这篇文章。</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>说了这么多，对于 i++ 这种线程不安全问题有没有其他解决方案呢？当然有，请参考以下几种解决方案。</p>\n<p>1、对 i++ 操作的方法加同步锁，同时只能有一个线程执行 i++ 操作；</p>\n<p>2、使用支持原子性操作的类，如 <code>java.util.concurrent.atomic.AtomicInteger</code>，它使用的是 CAS 算法，效率优于第 1 种；</p>\n<p>如果对你有帮助，点个赞分享下给个鼓励吧！</p>\n"},{"title":"Java多线程可以分组还能这样玩","date":"2025-10-14T01:56:28.000Z","_content":"\n\n但如果线程很多的情况下，你知道如何对它们进行分组吗？\n\n和 Dubbo 的服务分组一样，Java 可以对相同性质的线程进行分组。\n\n来看下线程类 Thread 的所有构造方法。\n\n![](http://qianniu.javastack.cn/18-6-3/9061041.jpg)\n\n如图所示，带有 ThreadGroup 的所有线程构造方法都可以定义线程组的。\n\n线程组使用 java.lang.ThreadGroup 类定义，它有两个构造方法，第二个构造方法允许线程组有父类线程组，也就是说一个线程组可以多个子线程组。\n\n```\njava.lang.ThreadGroup#ThreadGroup(java.lang.String)\njava.lang.ThreadGroup#ThreadGroup(java.lang.ThreadGroup, java.lang.String)\n```\n\n![](http://qianniu.javastack.cn/18-6-4/38415499.jpg)\n\n线程组中比较有用的几个方法。\n\n> // 获取当前线程组内的运行线程数\n> java.lang.ThreadGroup#activeCount\n>\n> // 中断线程组内的所有线程\n> java.lang.ThreadGroup#interrupt\n>\n> // 使用 System.out 打印出所有线程信息\n> java.lang.ThreadGroup#list()\n\n我们来简单使用下线程组吧！\n\n```\n/**\n * \n */\npublic static void main(String[] args) {\n\tRunnable runnable = () -> {\n\t\tSystem.out.println(\"Java技术线程线程组名称：\" + Thread.currentThread().getThreadGroup());\n\t\tSystem.out.println(\"Java技术线程线程名称：\" + Thread.currentThread().getName());\n\t\ttry {\n\t\t\tThread.sleep(3000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t};\n\n\tThreadGroup userGroup = new ThreadGroup(\"user\");\n    userGroup.setMaxPriority(Thread.MIN_PRIORITY);\n    \n\tThread userTask1 = new Thread(userGroup, runnable, \"user-task1\");\n\tThread userTask2 = new Thread(userGroup, runnable, \"user-task2\");\n\n\tuserTask1.start();\n\tuserTask2.start();\n\n\tSystem.out.println(\"Java技术线程线程组活跃线程数：\" + userGroup.activeCount());\n\tuserGroup.list();\n\n}\n```\n\n程序输出以下结果。\n\n```\nJava技术线程线程组名称：java.lang.ThreadGroup[name=user,maxpri=1]\nJava技术线程线程名称：user-task1\nJava技术线程线程组活跃线程数：2\nJava技术线程线程组名称：java.lang.ThreadGroup[name=user,maxpri=1]\nJava技术线程线程名称：user-task2\njava.lang.ThreadGroup[name=user,maxpri=1]\n    Thread[user-task1,1,user]\n    Thread[user-task2,1,user]\n```\n\n根据示例代码和程序输出结果应该对线程组有了一个大概的了解吧。\n\n线程组还能统一设置组内所有线程的最高优先级，线程单独设置的优先级不会高于线程组设置的最大优先级。\n\n另外，线程组中有一个 stop 方法用来终止组内所有的线程，但这个方法和 Thread 中的 stop 方法一样会带来很多问题，所以它们两个现在都已经被废弃了，官方也是不建议使用了，建议使用线程中断功能进行优雅终止线程。\n\n---\n\n","source":"_posts/Java多线程可以分组还能这样玩.md","raw":"---\ntitle: Java多线程可以分组还能这样玩\ndate: 2025-10-14 09:56:28\ntags: 多线程\n---\n\n\n但如果线程很多的情况下，你知道如何对它们进行分组吗？\n\n和 Dubbo 的服务分组一样，Java 可以对相同性质的线程进行分组。\n\n来看下线程类 Thread 的所有构造方法。\n\n![](http://qianniu.javastack.cn/18-6-3/9061041.jpg)\n\n如图所示，带有 ThreadGroup 的所有线程构造方法都可以定义线程组的。\n\n线程组使用 java.lang.ThreadGroup 类定义，它有两个构造方法，第二个构造方法允许线程组有父类线程组，也就是说一个线程组可以多个子线程组。\n\n```\njava.lang.ThreadGroup#ThreadGroup(java.lang.String)\njava.lang.ThreadGroup#ThreadGroup(java.lang.ThreadGroup, java.lang.String)\n```\n\n![](http://qianniu.javastack.cn/18-6-4/38415499.jpg)\n\n线程组中比较有用的几个方法。\n\n> // 获取当前线程组内的运行线程数\n> java.lang.ThreadGroup#activeCount\n>\n> // 中断线程组内的所有线程\n> java.lang.ThreadGroup#interrupt\n>\n> // 使用 System.out 打印出所有线程信息\n> java.lang.ThreadGroup#list()\n\n我们来简单使用下线程组吧！\n\n```\n/**\n * \n */\npublic static void main(String[] args) {\n\tRunnable runnable = () -> {\n\t\tSystem.out.println(\"Java技术线程线程组名称：\" + Thread.currentThread().getThreadGroup());\n\t\tSystem.out.println(\"Java技术线程线程名称：\" + Thread.currentThread().getName());\n\t\ttry {\n\t\t\tThread.sleep(3000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t};\n\n\tThreadGroup userGroup = new ThreadGroup(\"user\");\n    userGroup.setMaxPriority(Thread.MIN_PRIORITY);\n    \n\tThread userTask1 = new Thread(userGroup, runnable, \"user-task1\");\n\tThread userTask2 = new Thread(userGroup, runnable, \"user-task2\");\n\n\tuserTask1.start();\n\tuserTask2.start();\n\n\tSystem.out.println(\"Java技术线程线程组活跃线程数：\" + userGroup.activeCount());\n\tuserGroup.list();\n\n}\n```\n\n程序输出以下结果。\n\n```\nJava技术线程线程组名称：java.lang.ThreadGroup[name=user,maxpri=1]\nJava技术线程线程名称：user-task1\nJava技术线程线程组活跃线程数：2\nJava技术线程线程组名称：java.lang.ThreadGroup[name=user,maxpri=1]\nJava技术线程线程名称：user-task2\njava.lang.ThreadGroup[name=user,maxpri=1]\n    Thread[user-task1,1,user]\n    Thread[user-task2,1,user]\n```\n\n根据示例代码和程序输出结果应该对线程组有了一个大概的了解吧。\n\n线程组还能统一设置组内所有线程的最高优先级，线程单独设置的优先级不会高于线程组设置的最大优先级。\n\n另外，线程组中有一个 stop 方法用来终止组内所有的线程，但这个方法和 Thread 中的 stop 方法一样会带来很多问题，所以它们两个现在都已经被废弃了，官方也是不建议使用了，建议使用线程中断功能进行优雅终止线程。\n\n---\n\n","slug":"Java多线程可以分组还能这样玩","published":1,"updated":"2025-10-14T01:57:13.614Z","comments":1,"layout":"post","photos":[],"_id":"cmgq71di10000q0d4cabj5o4u","content":"<p>但如果线程很多的情况下，你知道如何对它们进行分组吗？</p>\n<p>和 Dubbo 的服务分组一样，Java 可以对相同性质的线程进行分组。</p>\n<p>来看下线程类 Thread 的所有构造方法。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-6-3/9061041.jpg\"></p>\n<p>如图所示，带有 ThreadGroup 的所有线程构造方法都可以定义线程组的。</p>\n<p>线程组使用 java.lang.ThreadGroup 类定义，它有两个构造方法，第二个构造方法允许线程组有父类线程组，也就是说一个线程组可以多个子线程组。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.ThreadGroup#ThreadGroup(java.lang.String)</span><br><span class=\"line\">java.lang.ThreadGroup#ThreadGroup(java.lang.ThreadGroup, java.lang.String)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://qianniu.javastack.cn/18-6-4/38415499.jpg\"></p>\n<p>线程组中比较有用的几个方法。</p>\n<blockquote>\n<p>&#x2F;&#x2F; 获取当前线程组内的运行线程数<br>java.lang.ThreadGroup#activeCount</p>\n<p>&#x2F;&#x2F; 中断线程组内的所有线程<br>java.lang.ThreadGroup#interrupt</p>\n<p>&#x2F;&#x2F; 使用 System.out 打印出所有线程信息<br>java.lang.ThreadGroup#list()</p>\n</blockquote>\n<p>我们来简单使用下线程组吧！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\tRunnable runnable = () -&gt; &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;Java技术线程线程组名称：&quot; + Thread.currentThread().getThreadGroup());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;Java技术线程线程名称：&quot; + Thread.currentThread().getName());</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tThread.sleep(3000);</span><br><span class=\"line\">\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tThreadGroup userGroup = new ThreadGroup(&quot;user&quot;);</span><br><span class=\"line\">    userGroup.setMaxPriority(Thread.MIN_PRIORITY);</span><br><span class=\"line\">    </span><br><span class=\"line\">\tThread userTask1 = new Thread(userGroup, runnable, &quot;user-task1&quot;);</span><br><span class=\"line\">\tThread userTask2 = new Thread(userGroup, runnable, &quot;user-task2&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tuserTask1.start();</span><br><span class=\"line\">\tuserTask2.start();</span><br><span class=\"line\"></span><br><span class=\"line\">\tSystem.out.println(&quot;Java技术线程线程组活跃线程数：&quot; + userGroup.activeCount());</span><br><span class=\"line\">\tuserGroup.list();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>程序输出以下结果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Java技术线程线程组名称：java.lang.ThreadGroup[name=user,maxpri=1]</span><br><span class=\"line\">Java技术线程线程名称：user-task1</span><br><span class=\"line\">Java技术线程线程组活跃线程数：2</span><br><span class=\"line\">Java技术线程线程组名称：java.lang.ThreadGroup[name=user,maxpri=1]</span><br><span class=\"line\">Java技术线程线程名称：user-task2</span><br><span class=\"line\">java.lang.ThreadGroup[name=user,maxpri=1]</span><br><span class=\"line\">    Thread[user-task1,1,user]</span><br><span class=\"line\">    Thread[user-task2,1,user]</span><br></pre></td></tr></table></figure>\n\n<p>根据示例代码和程序输出结果应该对线程组有了一个大概的了解吧。</p>\n<p>线程组还能统一设置组内所有线程的最高优先级，线程单独设置的优先级不会高于线程组设置的最大优先级。</p>\n<p>另外，线程组中有一个 stop 方法用来终止组内所有的线程，但这个方法和 Thread 中的 stop 方法一样会带来很多问题，所以它们两个现在都已经被废弃了，官方也是不建议使用了，建议使用线程中断功能进行优雅终止线程。</p>\n<hr>\n","excerpt":"","more":"<p>但如果线程很多的情况下，你知道如何对它们进行分组吗？</p>\n<p>和 Dubbo 的服务分组一样，Java 可以对相同性质的线程进行分组。</p>\n<p>来看下线程类 Thread 的所有构造方法。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-6-3/9061041.jpg\"></p>\n<p>如图所示，带有 ThreadGroup 的所有线程构造方法都可以定义线程组的。</p>\n<p>线程组使用 java.lang.ThreadGroup 类定义，它有两个构造方法，第二个构造方法允许线程组有父类线程组，也就是说一个线程组可以多个子线程组。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.ThreadGroup#ThreadGroup(java.lang.String)</span><br><span class=\"line\">java.lang.ThreadGroup#ThreadGroup(java.lang.ThreadGroup, java.lang.String)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://qianniu.javastack.cn/18-6-4/38415499.jpg\"></p>\n<p>线程组中比较有用的几个方法。</p>\n<blockquote>\n<p>&#x2F;&#x2F; 获取当前线程组内的运行线程数<br>java.lang.ThreadGroup#activeCount</p>\n<p>&#x2F;&#x2F; 中断线程组内的所有线程<br>java.lang.ThreadGroup#interrupt</p>\n<p>&#x2F;&#x2F; 使用 System.out 打印出所有线程信息<br>java.lang.ThreadGroup#list()</p>\n</blockquote>\n<p>我们来简单使用下线程组吧！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\tRunnable runnable = () -&gt; &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;Java技术线程线程组名称：&quot; + Thread.currentThread().getThreadGroup());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;Java技术线程线程名称：&quot; + Thread.currentThread().getName());</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tThread.sleep(3000);</span><br><span class=\"line\">\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tThreadGroup userGroup = new ThreadGroup(&quot;user&quot;);</span><br><span class=\"line\">    userGroup.setMaxPriority(Thread.MIN_PRIORITY);</span><br><span class=\"line\">    </span><br><span class=\"line\">\tThread userTask1 = new Thread(userGroup, runnable, &quot;user-task1&quot;);</span><br><span class=\"line\">\tThread userTask2 = new Thread(userGroup, runnable, &quot;user-task2&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tuserTask1.start();</span><br><span class=\"line\">\tuserTask2.start();</span><br><span class=\"line\"></span><br><span class=\"line\">\tSystem.out.println(&quot;Java技术线程线程组活跃线程数：&quot; + userGroup.activeCount());</span><br><span class=\"line\">\tuserGroup.list();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>程序输出以下结果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Java技术线程线程组名称：java.lang.ThreadGroup[name=user,maxpri=1]</span><br><span class=\"line\">Java技术线程线程名称：user-task1</span><br><span class=\"line\">Java技术线程线程组活跃线程数：2</span><br><span class=\"line\">Java技术线程线程组名称：java.lang.ThreadGroup[name=user,maxpri=1]</span><br><span class=\"line\">Java技术线程线程名称：user-task2</span><br><span class=\"line\">java.lang.ThreadGroup[name=user,maxpri=1]</span><br><span class=\"line\">    Thread[user-task1,1,user]</span><br><span class=\"line\">    Thread[user-task2,1,user]</span><br></pre></td></tr></table></figure>\n\n<p>根据示例代码和程序输出结果应该对线程组有了一个大概的了解吧。</p>\n<p>线程组还能统一设置组内所有线程的最高优先级，线程单独设置的优先级不会高于线程组设置的最大优先级。</p>\n<p>另外，线程组中有一个 stop 方法用来终止组内所有的线程，但这个方法和 Thread 中的 stop 方法一样会带来很多问题，所以它们两个现在都已经被废弃了，官方也是不建议使用了，建议使用线程中断功能进行优雅终止线程。</p>\n<hr>\n"},{"title":"Java多线程join使用及原理","date":"2025-10-14T01:53:44.000Z","_content":"\n## join()\n\njoin()是线程类`Thread`的方法，官方的说明是：\n\n> Waits for this thread to die.\n\n等待这个线程结束，也就是说当前线程等待这个线程结束后再继续执行，下面来看这个示例就明白了。\n\n## 示例\n\n```\npublic static void main(String[] args) throws Exception {\n\tSystem.out.println(\"start\");\n\n\tThread t = new Thread(() -> {\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tSystem.out.println(i);\n\t\t\ttry {\n\t\t\t\tThread.sleep(500);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t});\n\tt.start();\n\tt.join();\n\n\tSystem.out.println(\"end\");\n}\n```\n\n结果输出：\n\n\n```\nstart\n0\n1\n2\n3\n4\nend\n```\n\n线程t开始后，接着加入t.join()方法，t线程里面程序在主线程end输出之前全部执行完了，说明t.join()阻塞了主线程直到t线程执行完毕。\n\n如果没有t.join()，end可能会在0~5之间输出。\n\n\n## join()原理\n\n下面是join()的源码：\n\n```\npublic final synchronized void join(long millis)\n    throws InterruptedException {\n    long base = System.currentTimeMillis();\n    long now = 0;\n\n    if (millis < 0) {\n        throw new IllegalArgumentException(\"timeout value is negative\");\n    }\n\n    if (millis == 0) {\n        while (isAlive()) {\n            wait(0);\n        }\n    } else {\n        while (isAlive()) {\n            long delay = millis - now;\n            if (delay <= 0) {\n                break;\n            }\n            wait(delay);\n            now = System.currentTimeMillis() - base;\n        }\n    }\n}\n```\n\n可以看出它是利用wait方法来实现的，上面的例子当main方法主线程调用线程t的时候，main方法获取到了t的对象锁，而t调用自身wait方法进行阻塞，只要当t结束或者到时间后才会退出，接着唤醒主线程继续执行。millis为主线程等待t线程最长执行多久，0为永久直到t线程执行结束。","source":"_posts/Java多线程join使用及原理.md","raw":"---\ntitle: Java多线程join使用及原理\ndate: 2025-10-14 09:53:44\ntags: 多线程\n---\n\n## join()\n\njoin()是线程类`Thread`的方法，官方的说明是：\n\n> Waits for this thread to die.\n\n等待这个线程结束，也就是说当前线程等待这个线程结束后再继续执行，下面来看这个示例就明白了。\n\n## 示例\n\n```\npublic static void main(String[] args) throws Exception {\n\tSystem.out.println(\"start\");\n\n\tThread t = new Thread(() -> {\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tSystem.out.println(i);\n\t\t\ttry {\n\t\t\t\tThread.sleep(500);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t});\n\tt.start();\n\tt.join();\n\n\tSystem.out.println(\"end\");\n}\n```\n\n结果输出：\n\n\n```\nstart\n0\n1\n2\n3\n4\nend\n```\n\n线程t开始后，接着加入t.join()方法，t线程里面程序在主线程end输出之前全部执行完了，说明t.join()阻塞了主线程直到t线程执行完毕。\n\n如果没有t.join()，end可能会在0~5之间输出。\n\n\n## join()原理\n\n下面是join()的源码：\n\n```\npublic final synchronized void join(long millis)\n    throws InterruptedException {\n    long base = System.currentTimeMillis();\n    long now = 0;\n\n    if (millis < 0) {\n        throw new IllegalArgumentException(\"timeout value is negative\");\n    }\n\n    if (millis == 0) {\n        while (isAlive()) {\n            wait(0);\n        }\n    } else {\n        while (isAlive()) {\n            long delay = millis - now;\n            if (delay <= 0) {\n                break;\n            }\n            wait(delay);\n            now = System.currentTimeMillis() - base;\n        }\n    }\n}\n```\n\n可以看出它是利用wait方法来实现的，上面的例子当main方法主线程调用线程t的时候，main方法获取到了t的对象锁，而t调用自身wait方法进行阻塞，只要当t结束或者到时间后才会退出，接着唤醒主线程继续执行。millis为主线程等待t线程最长执行多久，0为永久直到t线程执行结束。","slug":"Java多线程join使用及原理","published":1,"updated":"2025-10-14T01:55:35.701Z","comments":1,"layout":"post","photos":[],"_id":"cmgq71di40001q0d4153zg5sm","content":"<h2 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join()\"></a>join()</h2><p>join()是线程类<code>Thread</code>的方法，官方的说明是：</p>\n<blockquote>\n<p>Waits for this thread to die.</p>\n</blockquote>\n<p>等待这个线程结束，也就是说当前线程等待这个线程结束后再继续执行，下面来看这个示例就明白了。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\tSystem.out.println(&quot;start&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tThread t = new Thread(() -&gt; &#123;</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(i);</span><br><span class=\"line\">\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\tThread.sleep(500);</span><br><span class=\"line\">\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tt.start();</span><br><span class=\"line\">\tt.join();</span><br><span class=\"line\"></span><br><span class=\"line\">\tSystem.out.println(&quot;end&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start</span><br><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>线程t开始后，接着加入t.join()方法，t线程里面程序在主线程end输出之前全部执行完了，说明t.join()阻塞了主线程直到t线程执行完毕。</p>\n<p>如果没有t.join()，end可能会在0~5之间输出。</p>\n<h2 id=\"join-原理\"><a href=\"#join-原理\" class=\"headerlink\" title=\"join()原理\"></a>join()原理</h2><p>下面是join()的源码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final synchronized void join(long millis)</span><br><span class=\"line\">    throws InterruptedException &#123;</span><br><span class=\"line\">    long base = System.currentTimeMillis();</span><br><span class=\"line\">    long now = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (millis &lt; 0) &#123;</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (millis == 0) &#123;</span><br><span class=\"line\">        while (isAlive()) &#123;</span><br><span class=\"line\">            wait(0);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        while (isAlive()) &#123;</span><br><span class=\"line\">            long delay = millis - now;</span><br><span class=\"line\">            if (delay &lt;= 0) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            wait(delay);</span><br><span class=\"line\">            now = System.currentTimeMillis() - base;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出它是利用wait方法来实现的，上面的例子当main方法主线程调用线程t的时候，main方法获取到了t的对象锁，而t调用自身wait方法进行阻塞，只要当t结束或者到时间后才会退出，接着唤醒主线程继续执行。millis为主线程等待t线程最长执行多久，0为永久直到t线程执行结束。</p>\n","excerpt":"","more":"<h2 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join()\"></a>join()</h2><p>join()是线程类<code>Thread</code>的方法，官方的说明是：</p>\n<blockquote>\n<p>Waits for this thread to die.</p>\n</blockquote>\n<p>等待这个线程结束，也就是说当前线程等待这个线程结束后再继续执行，下面来看这个示例就明白了。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\tSystem.out.println(&quot;start&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tThread t = new Thread(() -&gt; &#123;</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; 5; i++) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(i);</span><br><span class=\"line\">\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\tThread.sleep(500);</span><br><span class=\"line\">\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tt.start();</span><br><span class=\"line\">\tt.join();</span><br><span class=\"line\"></span><br><span class=\"line\">\tSystem.out.println(&quot;end&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start</span><br><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>线程t开始后，接着加入t.join()方法，t线程里面程序在主线程end输出之前全部执行完了，说明t.join()阻塞了主线程直到t线程执行完毕。</p>\n<p>如果没有t.join()，end可能会在0~5之间输出。</p>\n<h2 id=\"join-原理\"><a href=\"#join-原理\" class=\"headerlink\" title=\"join()原理\"></a>join()原理</h2><p>下面是join()的源码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final synchronized void join(long millis)</span><br><span class=\"line\">    throws InterruptedException &#123;</span><br><span class=\"line\">    long base = System.currentTimeMillis();</span><br><span class=\"line\">    long now = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (millis &lt; 0) &#123;</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (millis == 0) &#123;</span><br><span class=\"line\">        while (isAlive()) &#123;</span><br><span class=\"line\">            wait(0);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        while (isAlive()) &#123;</span><br><span class=\"line\">            long delay = millis - now;</span><br><span class=\"line\">            if (delay &lt;= 0) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            wait(delay);</span><br><span class=\"line\">            now = System.currentTimeMillis() - base;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出它是利用wait方法来实现的，上面的例子当main方法主线程调用线程t的时候，main方法获取到了t的对象锁，而t调用自身wait方法进行阻塞，只要当t结束或者到时间后才会退出，接着唤醒主线程继续执行。millis为主线程等待t线程最长执行多久，0为永久直到t线程执行结束。</p>\n"},{"title":"Java虚拟机对锁优化所做的努力","date":"2025-10-14T06:42:34.000Z","_content":"\n![](http://img.javastack.cn/18-6-10/54034705.jpg)\n\n作为一款公用平台，JDK 本身也为并发程序的性能绞尽脑汁，在 JDK 内部也想尽一切办法提供并发时的系统吞吐量。这里，我将向大家简单介绍几种 JDK 内部的 \"锁\" 优化策略。\n\n### 1、 锁偏向\n\n锁偏向是一种针对加锁操作的优化手段。\n\n如果一个线程获得了锁，那么锁就进入偏向模式。当这个线程再次请求锁时，无须再做任何同步操作。这样就节省了大量有关锁申请的操作，从而提高了程序性能。因此，对于几乎没有锁竞争的场合，偏向锁有比较红啊的优化效果，因为连续多次极有可能是同一个线程请求相同的锁。而对于锁竞争比较激烈的场合，其效果不佳。因为在竞争激烈的场合，最有可能的情况是每次都是不同的线程来请求相同的锁。\n\n### 2、 轻量级锁\n\n如果偏向锁失败，即上一个请求的锁的线程和这个线程不是同一个。偏向锁失败意味者不能避免做同步操作。此时，虚拟机并不会立即挂起线程。他会使用一种成为轻量级锁的优化手段。 轻量级锁的操作也很方便，它只是简单地将对象头部作为指针，指向蚩尤锁的线程堆栈的内部，来判断一个线程是否持有对象锁。 如果线程获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁失败，则表示其他线程抢先争夺了锁，那么当前线程的锁请求就会膨胀为重量级锁。\n\n### 3、 自选锁\n\n锁膨胀后，虚拟机为了避免线程真实地在操作系统层面挂起，虚拟机还会在做最后的努力–自选锁。由于当前线程暂时无法获得锁，但是什么时候可以获得锁是一个未知数。也许在CPU几个时钟周期后，就可以得到锁。如果这样，简单粗暴的挂起线程可能是一种得不偿失的操作，因此系统会进行一次赌注：它会假设在不久的将来，线程可以得到这把锁。因此虚拟机让当前线程做个空循环，在经过若干次循环后，如果可以得到锁，那么就顺利进入临界区。如果还不能得到锁，才会真实地将线程在操作系统层面挂起。\n\n### 4、 锁消除\n\n锁消除是一种更彻底的锁优化。Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。通过锁消除，可以节省毫无意义的请求锁时间。\n\n下面这种这种情况，我们使用vector， 而vector内部使用了synchronize请求锁。\n\n\n```\npublic String []  createStrings(){\n    Vector<String>  v= new Vector<String>();\n    for(int i=0;i<100;i++){\n        v.add(Integer.toString(i));\n    }\n    return v.toArray(new String[]{});\n}\n```\n\n由于V只在函数 createStrnigs 中使用，因此它只是一个单纯的局部变量。局部变量是在线程栈上分配的，属于线程私有额数据，因此不可能被其他线程访问。所以，在这种情况下，Vector内部所有加锁同步都是没有必要的。如果虚拟机检测到这种情况，就会将这些无用的锁操作去除。\n\n锁消除涉及的一项关键技术为逃逸分析。所谓逃逸分析就是观察某一个变量是否会逃出某一个作用域。在本例中，变量v显然没有逃出createString 函数之外。以此为基础，虚拟机才可以大胆的将v内部的加锁操作去除。如果createStrings 返回的不是String数组，而是v本身，那么就认为变量v逃逸出了当前函数，也就是说v有可能被其他线程访问。如是这样，虚拟机就不能消除v中的锁操作。\n\n逃逸分析必须在 -server 模式下进行，可以使用 -XX:DoEscapeAnalysis 参数打开逃逸分析，使用 -XX:+EliminateLocks 参数可以打开锁消除。\n\n本文摘自《Java高并发程序设计》一书。\n\n","source":"_posts/Java虚拟机对锁优化所做的努力.md","raw":"---\ntitle: Java虚拟机对锁优化所做的努力\ndate: 2025-10-14 14:42:34\ntags: 多线程\n---\n\n![](http://img.javastack.cn/18-6-10/54034705.jpg)\n\n作为一款公用平台，JDK 本身也为并发程序的性能绞尽脑汁，在 JDK 内部也想尽一切办法提供并发时的系统吞吐量。这里，我将向大家简单介绍几种 JDK 内部的 \"锁\" 优化策略。\n\n### 1、 锁偏向\n\n锁偏向是一种针对加锁操作的优化手段。\n\n如果一个线程获得了锁，那么锁就进入偏向模式。当这个线程再次请求锁时，无须再做任何同步操作。这样就节省了大量有关锁申请的操作，从而提高了程序性能。因此，对于几乎没有锁竞争的场合，偏向锁有比较红啊的优化效果，因为连续多次极有可能是同一个线程请求相同的锁。而对于锁竞争比较激烈的场合，其效果不佳。因为在竞争激烈的场合，最有可能的情况是每次都是不同的线程来请求相同的锁。\n\n### 2、 轻量级锁\n\n如果偏向锁失败，即上一个请求的锁的线程和这个线程不是同一个。偏向锁失败意味者不能避免做同步操作。此时，虚拟机并不会立即挂起线程。他会使用一种成为轻量级锁的优化手段。 轻量级锁的操作也很方便，它只是简单地将对象头部作为指针，指向蚩尤锁的线程堆栈的内部，来判断一个线程是否持有对象锁。 如果线程获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁失败，则表示其他线程抢先争夺了锁，那么当前线程的锁请求就会膨胀为重量级锁。\n\n### 3、 自选锁\n\n锁膨胀后，虚拟机为了避免线程真实地在操作系统层面挂起，虚拟机还会在做最后的努力–自选锁。由于当前线程暂时无法获得锁，但是什么时候可以获得锁是一个未知数。也许在CPU几个时钟周期后，就可以得到锁。如果这样，简单粗暴的挂起线程可能是一种得不偿失的操作，因此系统会进行一次赌注：它会假设在不久的将来，线程可以得到这把锁。因此虚拟机让当前线程做个空循环，在经过若干次循环后，如果可以得到锁，那么就顺利进入临界区。如果还不能得到锁，才会真实地将线程在操作系统层面挂起。\n\n### 4、 锁消除\n\n锁消除是一种更彻底的锁优化。Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。通过锁消除，可以节省毫无意义的请求锁时间。\n\n下面这种这种情况，我们使用vector， 而vector内部使用了synchronize请求锁。\n\n\n```\npublic String []  createStrings(){\n    Vector<String>  v= new Vector<String>();\n    for(int i=0;i<100;i++){\n        v.add(Integer.toString(i));\n    }\n    return v.toArray(new String[]{});\n}\n```\n\n由于V只在函数 createStrnigs 中使用，因此它只是一个单纯的局部变量。局部变量是在线程栈上分配的，属于线程私有额数据，因此不可能被其他线程访问。所以，在这种情况下，Vector内部所有加锁同步都是没有必要的。如果虚拟机检测到这种情况，就会将这些无用的锁操作去除。\n\n锁消除涉及的一项关键技术为逃逸分析。所谓逃逸分析就是观察某一个变量是否会逃出某一个作用域。在本例中，变量v显然没有逃出createString 函数之外。以此为基础，虚拟机才可以大胆的将v内部的加锁操作去除。如果createStrings 返回的不是String数组，而是v本身，那么就认为变量v逃逸出了当前函数，也就是说v有可能被其他线程访问。如是这样，虚拟机就不能消除v中的锁操作。\n\n逃逸分析必须在 -server 模式下进行，可以使用 -XX:DoEscapeAnalysis 参数打开逃逸分析，使用 -XX:+EliminateLocks 参数可以打开锁消除。\n\n本文摘自《Java高并发程序设计》一书。\n\n","slug":"Java虚拟机对锁优化所做的努力","published":1,"updated":"2025-10-14T06:43:32.328Z","comments":1,"layout":"post","photos":[],"_id":"cmgq75p9n0000hod4636j43vr","content":"<p><img src=\"http://img.javastack.cn/18-6-10/54034705.jpg\"></p>\n<p>作为一款公用平台，JDK 本身也为并发程序的性能绞尽脑汁，在 JDK 内部也想尽一切办法提供并发时的系统吞吐量。这里，我将向大家简单介绍几种 JDK 内部的 “锁” 优化策略。</p>\n<h3 id=\"1、-锁偏向\"><a href=\"#1、-锁偏向\" class=\"headerlink\" title=\"1、 锁偏向\"></a>1、 锁偏向</h3><p>锁偏向是一种针对加锁操作的优化手段。</p>\n<p>如果一个线程获得了锁，那么锁就进入偏向模式。当这个线程再次请求锁时，无须再做任何同步操作。这样就节省了大量有关锁申请的操作，从而提高了程序性能。因此，对于几乎没有锁竞争的场合，偏向锁有比较红啊的优化效果，因为连续多次极有可能是同一个线程请求相同的锁。而对于锁竞争比较激烈的场合，其效果不佳。因为在竞争激烈的场合，最有可能的情况是每次都是不同的线程来请求相同的锁。</p>\n<h3 id=\"2、-轻量级锁\"><a href=\"#2、-轻量级锁\" class=\"headerlink\" title=\"2、 轻量级锁\"></a>2、 轻量级锁</h3><p>如果偏向锁失败，即上一个请求的锁的线程和这个线程不是同一个。偏向锁失败意味者不能避免做同步操作。此时，虚拟机并不会立即挂起线程。他会使用一种成为轻量级锁的优化手段。 轻量级锁的操作也很方便，它只是简单地将对象头部作为指针，指向蚩尤锁的线程堆栈的内部，来判断一个线程是否持有对象锁。 如果线程获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁失败，则表示其他线程抢先争夺了锁，那么当前线程的锁请求就会膨胀为重量级锁。</p>\n<h3 id=\"3、-自选锁\"><a href=\"#3、-自选锁\" class=\"headerlink\" title=\"3、 自选锁\"></a>3、 自选锁</h3><p>锁膨胀后，虚拟机为了避免线程真实地在操作系统层面挂起，虚拟机还会在做最后的努力–自选锁。由于当前线程暂时无法获得锁，但是什么时候可以获得锁是一个未知数。也许在CPU几个时钟周期后，就可以得到锁。如果这样，简单粗暴的挂起线程可能是一种得不偿失的操作，因此系统会进行一次赌注：它会假设在不久的将来，线程可以得到这把锁。因此虚拟机让当前线程做个空循环，在经过若干次循环后，如果可以得到锁，那么就顺利进入临界区。如果还不能得到锁，才会真实地将线程在操作系统层面挂起。</p>\n<h3 id=\"4、-锁消除\"><a href=\"#4、-锁消除\" class=\"headerlink\" title=\"4、 锁消除\"></a>4、 锁消除</h3><p>锁消除是一种更彻底的锁优化。Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。通过锁消除，可以节省毫无意义的请求锁时间。</p>\n<p>下面这种这种情况，我们使用vector， 而vector内部使用了synchronize请求锁。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String []  createStrings()&#123;</span><br><span class=\"line\">    Vector&lt;String&gt;  v= new Vector&lt;String&gt;();</span><br><span class=\"line\">    for(int i=0;i&lt;100;i++)&#123;</span><br><span class=\"line\">        v.add(Integer.toString(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return v.toArray(new String[]&#123;&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于V只在函数 createStrnigs 中使用，因此它只是一个单纯的局部变量。局部变量是在线程栈上分配的，属于线程私有额数据，因此不可能被其他线程访问。所以，在这种情况下，Vector内部所有加锁同步都是没有必要的。如果虚拟机检测到这种情况，就会将这些无用的锁操作去除。</p>\n<p>锁消除涉及的一项关键技术为逃逸分析。所谓逃逸分析就是观察某一个变量是否会逃出某一个作用域。在本例中，变量v显然没有逃出createString 函数之外。以此为基础，虚拟机才可以大胆的将v内部的加锁操作去除。如果createStrings 返回的不是String数组，而是v本身，那么就认为变量v逃逸出了当前函数，也就是说v有可能被其他线程访问。如是这样，虚拟机就不能消除v中的锁操作。</p>\n<p>逃逸分析必须在 -server 模式下进行，可以使用 -XX:DoEscapeAnalysis 参数打开逃逸分析，使用 -XX:+EliminateLocks 参数可以打开锁消除。</p>\n<p>本文摘自《Java高并发程序设计》一书。</p>\n","excerpt":"","more":"<p><img src=\"http://img.javastack.cn/18-6-10/54034705.jpg\"></p>\n<p>作为一款公用平台，JDK 本身也为并发程序的性能绞尽脑汁，在 JDK 内部也想尽一切办法提供并发时的系统吞吐量。这里，我将向大家简单介绍几种 JDK 内部的 “锁” 优化策略。</p>\n<h3 id=\"1、-锁偏向\"><a href=\"#1、-锁偏向\" class=\"headerlink\" title=\"1、 锁偏向\"></a>1、 锁偏向</h3><p>锁偏向是一种针对加锁操作的优化手段。</p>\n<p>如果一个线程获得了锁，那么锁就进入偏向模式。当这个线程再次请求锁时，无须再做任何同步操作。这样就节省了大量有关锁申请的操作，从而提高了程序性能。因此，对于几乎没有锁竞争的场合，偏向锁有比较红啊的优化效果，因为连续多次极有可能是同一个线程请求相同的锁。而对于锁竞争比较激烈的场合，其效果不佳。因为在竞争激烈的场合，最有可能的情况是每次都是不同的线程来请求相同的锁。</p>\n<h3 id=\"2、-轻量级锁\"><a href=\"#2、-轻量级锁\" class=\"headerlink\" title=\"2、 轻量级锁\"></a>2、 轻量级锁</h3><p>如果偏向锁失败，即上一个请求的锁的线程和这个线程不是同一个。偏向锁失败意味者不能避免做同步操作。此时，虚拟机并不会立即挂起线程。他会使用一种成为轻量级锁的优化手段。 轻量级锁的操作也很方便，它只是简单地将对象头部作为指针，指向蚩尤锁的线程堆栈的内部，来判断一个线程是否持有对象锁。 如果线程获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁失败，则表示其他线程抢先争夺了锁，那么当前线程的锁请求就会膨胀为重量级锁。</p>\n<h3 id=\"3、-自选锁\"><a href=\"#3、-自选锁\" class=\"headerlink\" title=\"3、 自选锁\"></a>3、 自选锁</h3><p>锁膨胀后，虚拟机为了避免线程真实地在操作系统层面挂起，虚拟机还会在做最后的努力–自选锁。由于当前线程暂时无法获得锁，但是什么时候可以获得锁是一个未知数。也许在CPU几个时钟周期后，就可以得到锁。如果这样，简单粗暴的挂起线程可能是一种得不偿失的操作，因此系统会进行一次赌注：它会假设在不久的将来，线程可以得到这把锁。因此虚拟机让当前线程做个空循环，在经过若干次循环后，如果可以得到锁，那么就顺利进入临界区。如果还不能得到锁，才会真实地将线程在操作系统层面挂起。</p>\n<h3 id=\"4、-锁消除\"><a href=\"#4、-锁消除\" class=\"headerlink\" title=\"4、 锁消除\"></a>4、 锁消除</h3><p>锁消除是一种更彻底的锁优化。Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。通过锁消除，可以节省毫无意义的请求锁时间。</p>\n<p>下面这种这种情况，我们使用vector， 而vector内部使用了synchronize请求锁。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String []  createStrings()&#123;</span><br><span class=\"line\">    Vector&lt;String&gt;  v= new Vector&lt;String&gt;();</span><br><span class=\"line\">    for(int i=0;i&lt;100;i++)&#123;</span><br><span class=\"line\">        v.add(Integer.toString(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return v.toArray(new String[]&#123;&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于V只在函数 createStrnigs 中使用，因此它只是一个单纯的局部变量。局部变量是在线程栈上分配的，属于线程私有额数据，因此不可能被其他线程访问。所以，在这种情况下，Vector内部所有加锁同步都是没有必要的。如果虚拟机检测到这种情况，就会将这些无用的锁操作去除。</p>\n<p>锁消除涉及的一项关键技术为逃逸分析。所谓逃逸分析就是观察某一个变量是否会逃出某一个作用域。在本例中，变量v显然没有逃出createString 函数之外。以此为基础，虚拟机才可以大胆的将v内部的加锁操作去除。如果createStrings 返回的不是String数组，而是v本身，那么就认为变量v逃逸出了当前函数，也就是说v有可能被其他线程访问。如是这样，虚拟机就不能消除v中的锁操作。</p>\n<p>逃逸分析必须在 -server 模式下进行，可以使用 -XX:DoEscapeAnalysis 参数打开逃逸分析，使用 -XX:+EliminateLocks 参数可以打开锁消除。</p>\n<p>本文摘自《Java高并发程序设计》一书。</p>\n"},{"title":"sleep( )和wait( )的这5个区别，你知道几个？","date":"2025-10-14T06:42:34.000Z","_content":"\nsleep(休眠) 和 wait(等待) 方法是 Java 多线程中常用的两个方法，它们有什么区别及一些该注意的地方有哪些呢？下面给大家一一分解。\n\n在之前的文章《[Java多线程神器：join使用及原理](https://mp.weixin.qq.com/s/at8NynjnYvqkFw61kn3Apg)》介绍了，它其实用的是 wait 实现的线程等待。\n\n#### 区别1：使用限制\n\n使用 sleep 方法可以让让当前线程休眠，时间一到当前线程继续往下执行，在任何地方都能使用，但需要捕获 InterruptedException 异常。\n\n```\ntry {\n\tThread.sleep(3000L);\n} catch (InterruptedException e) {\n\te.printStackTrace();\n}\n```\n\n而使用 wait 方法则必须放在 synchronized 块里面，同样需要捕获 InterruptedException 异常，并且需要获取对象的锁。\n\n```\nsynchronized (lock){\n    try {\n        lock.wait();\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n而且 wait 还需要额外的方法 notify/ notifyAll 进行唤醒，它们同样需要放在 synchronized 块里面，且获取对象的锁。。\n\n\n```\nsynchronized (lock) {\n    // 随机唤醒\n    lock.notify();\n    \n    // 唤醒全部\n    lock.notifyAll();\n}\n```\n\n当然也可以使用带时间的 wait(long millis) 方法，时间一到，无需其他线程唤醒，也会重新竞争获取对象的锁继续执行。\n\n#### 区别2：使用场景\n\nsleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。\n\n#### 区别3：所属类\n\nsleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。\n\n> java.lang.Thread#sleep\n\n```\npublic static native void sleep(long millis) throws InterruptedException;\n```\n\n> java.lang.Object#wait\n\n```\npublic final native void wait(long timeout) throws InterruptedException;\n```\n\n**为什么要这样设计呢？**\n\n因为 sleep 是让当前线程休眠，不涉及到对象类，也不需要获得对象的锁，所以是线程类的方法。wait 是让获得对象锁的线程实现等待，前提是要楚获得对象的锁，所以是类的方法。\n\n#### 区别4：释放锁\n\n\n```\nObject lock = new Object();\nsynchronized (lock) {\n    try {\n        lock.wait(3000L);\n        Thread.sleep(2000L);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n如上代码所示，wait 可以释放当前线程对 lock 对象锁的持有，而 sleep 则不会。\n\n#### 区别5：线程切换\n\nsleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。\n\n@程序猿 你们还知道别的吗？欢迎留言！\n","source":"_posts/sleep( )和wait( )的这5个区别，你知道几个？.md","raw":"---\ntitle: sleep( )和wait( )的这5个区别，你知道几个？\ndate: 2025-10-14 14:42:34\ntags: 多线程\n---\n\nsleep(休眠) 和 wait(等待) 方法是 Java 多线程中常用的两个方法，它们有什么区别及一些该注意的地方有哪些呢？下面给大家一一分解。\n\n在之前的文章《[Java多线程神器：join使用及原理](https://mp.weixin.qq.com/s/at8NynjnYvqkFw61kn3Apg)》介绍了，它其实用的是 wait 实现的线程等待。\n\n#### 区别1：使用限制\n\n使用 sleep 方法可以让让当前线程休眠，时间一到当前线程继续往下执行，在任何地方都能使用，但需要捕获 InterruptedException 异常。\n\n```\ntry {\n\tThread.sleep(3000L);\n} catch (InterruptedException e) {\n\te.printStackTrace();\n}\n```\n\n而使用 wait 方法则必须放在 synchronized 块里面，同样需要捕获 InterruptedException 异常，并且需要获取对象的锁。\n\n```\nsynchronized (lock){\n    try {\n        lock.wait();\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n而且 wait 还需要额外的方法 notify/ notifyAll 进行唤醒，它们同样需要放在 synchronized 块里面，且获取对象的锁。。\n\n\n```\nsynchronized (lock) {\n    // 随机唤醒\n    lock.notify();\n    \n    // 唤醒全部\n    lock.notifyAll();\n}\n```\n\n当然也可以使用带时间的 wait(long millis) 方法，时间一到，无需其他线程唤醒，也会重新竞争获取对象的锁继续执行。\n\n#### 区别2：使用场景\n\nsleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。\n\n#### 区别3：所属类\n\nsleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。\n\n> java.lang.Thread#sleep\n\n```\npublic static native void sleep(long millis) throws InterruptedException;\n```\n\n> java.lang.Object#wait\n\n```\npublic final native void wait(long timeout) throws InterruptedException;\n```\n\n**为什么要这样设计呢？**\n\n因为 sleep 是让当前线程休眠，不涉及到对象类，也不需要获得对象的锁，所以是线程类的方法。wait 是让获得对象锁的线程实现等待，前提是要楚获得对象的锁，所以是类的方法。\n\n#### 区别4：释放锁\n\n\n```\nObject lock = new Object();\nsynchronized (lock) {\n    try {\n        lock.wait(3000L);\n        Thread.sleep(2000L);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n如上代码所示，wait 可以释放当前线程对 lock 对象锁的持有，而 sleep 则不会。\n\n#### 区别5：线程切换\n\nsleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。\n\n@程序猿 你们还知道别的吗？欢迎留言！\n","slug":"sleep( )和wait( )的这5个区别，你知道几个？","published":1,"updated":"2025-10-14T06:46:08.080Z","_id":"cmgq77o5h0004hod493qxdop2","comments":1,"layout":"post","photos":[],"content":"<p>sleep(休眠) 和 wait(等待) 方法是 Java 多线程中常用的两个方法，它们有什么区别及一些该注意的地方有哪些呢？下面给大家一一分解。</p>\n<p>在之前的文章《<a href=\"https://mp.weixin.qq.com/s/at8NynjnYvqkFw61kn3Apg\">Java多线程神器：join使用及原理</a>》介绍了，它其实用的是 wait 实现的线程等待。</p>\n<h4 id=\"区别1：使用限制\"><a href=\"#区别1：使用限制\" class=\"headerlink\" title=\"区别1：使用限制\"></a>区别1：使用限制</h4><p>使用 sleep 方法可以让让当前线程休眠，时间一到当前线程继续往下执行，在任何地方都能使用，但需要捕获 InterruptedException 异常。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">\tThread.sleep(3000L);</span><br><span class=\"line\">&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\te.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而使用 wait 方法则必须放在 synchronized 块里面，同样需要捕获 InterruptedException 异常，并且需要获取对象的锁。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized (lock)&#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        lock.wait();</span><br><span class=\"line\">    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而且 wait 还需要额外的方法 notify&#x2F; notifyAll 进行唤醒，它们同样需要放在 synchronized 块里面，且获取对象的锁。。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized (lock) &#123;</span><br><span class=\"line\">    // 随机唤醒</span><br><span class=\"line\">    lock.notify();</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 唤醒全部</span><br><span class=\"line\">    lock.notifyAll();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然也可以使用带时间的 wait(long millis) 方法，时间一到，无需其他线程唤醒，也会重新竞争获取对象的锁继续执行。</p>\n<h4 id=\"区别2：使用场景\"><a href=\"#区别2：使用场景\" class=\"headerlink\" title=\"区别2：使用场景\"></a>区别2：使用场景</h4><p>sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。</p>\n<h4 id=\"区别3：所属类\"><a href=\"#区别3：所属类\" class=\"headerlink\" title=\"区别3：所属类\"></a>区别3：所属类</h4><p>sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。</p>\n<blockquote>\n<p>java.lang.Thread#sleep</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static native void sleep(long millis) throws InterruptedException;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>java.lang.Object#wait</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final native void wait(long timeout) throws InterruptedException;</span><br></pre></td></tr></table></figure>\n\n<p><strong>为什么要这样设计呢？</strong></p>\n<p>因为 sleep 是让当前线程休眠，不涉及到对象类，也不需要获得对象的锁，所以是线程类的方法。wait 是让获得对象锁的线程实现等待，前提是要楚获得对象的锁，所以是类的方法。</p>\n<h4 id=\"区别4：释放锁\"><a href=\"#区别4：释放锁\" class=\"headerlink\" title=\"区别4：释放锁\"></a>区别4：释放锁</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object lock = new Object();</span><br><span class=\"line\">synchronized (lock) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        lock.wait(3000L);</span><br><span class=\"line\">        Thread.sleep(2000L);</span><br><span class=\"line\">    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如上代码所示，wait 可以释放当前线程对 lock 对象锁的持有，而 sleep 则不会。</p>\n<h4 id=\"区别5：线程切换\"><a href=\"#区别5：线程切换\" class=\"headerlink\" title=\"区别5：线程切换\"></a>区别5：线程切换</h4><p>sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。</p>\n<p>@程序猿 你们还知道别的吗？欢迎留言！</p>\n","excerpt":"","more":"<p>sleep(休眠) 和 wait(等待) 方法是 Java 多线程中常用的两个方法，它们有什么区别及一些该注意的地方有哪些呢？下面给大家一一分解。</p>\n<p>在之前的文章《<a href=\"https://mp.weixin.qq.com/s/at8NynjnYvqkFw61kn3Apg\">Java多线程神器：join使用及原理</a>》介绍了，它其实用的是 wait 实现的线程等待。</p>\n<h4 id=\"区别1：使用限制\"><a href=\"#区别1：使用限制\" class=\"headerlink\" title=\"区别1：使用限制\"></a>区别1：使用限制</h4><p>使用 sleep 方法可以让让当前线程休眠，时间一到当前线程继续往下执行，在任何地方都能使用，但需要捕获 InterruptedException 异常。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">\tThread.sleep(3000L);</span><br><span class=\"line\">&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\te.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而使用 wait 方法则必须放在 synchronized 块里面，同样需要捕获 InterruptedException 异常，并且需要获取对象的锁。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized (lock)&#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        lock.wait();</span><br><span class=\"line\">    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而且 wait 还需要额外的方法 notify&#x2F; notifyAll 进行唤醒，它们同样需要放在 synchronized 块里面，且获取对象的锁。。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized (lock) &#123;</span><br><span class=\"line\">    // 随机唤醒</span><br><span class=\"line\">    lock.notify();</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 唤醒全部</span><br><span class=\"line\">    lock.notifyAll();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然也可以使用带时间的 wait(long millis) 方法，时间一到，无需其他线程唤醒，也会重新竞争获取对象的锁继续执行。</p>\n<h4 id=\"区别2：使用场景\"><a href=\"#区别2：使用场景\" class=\"headerlink\" title=\"区别2：使用场景\"></a>区别2：使用场景</h4><p>sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。</p>\n<h4 id=\"区别3：所属类\"><a href=\"#区别3：所属类\" class=\"headerlink\" title=\"区别3：所属类\"></a>区别3：所属类</h4><p>sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。</p>\n<blockquote>\n<p>java.lang.Thread#sleep</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static native void sleep(long millis) throws InterruptedException;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>java.lang.Object#wait</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final native void wait(long timeout) throws InterruptedException;</span><br></pre></td></tr></table></figure>\n\n<p><strong>为什么要这样设计呢？</strong></p>\n<p>因为 sleep 是让当前线程休眠，不涉及到对象类，也不需要获得对象的锁，所以是线程类的方法。wait 是让获得对象锁的线程实现等待，前提是要楚获得对象的锁，所以是类的方法。</p>\n<h4 id=\"区别4：释放锁\"><a href=\"#区别4：释放锁\" class=\"headerlink\" title=\"区别4：释放锁\"></a>区别4：释放锁</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object lock = new Object();</span><br><span class=\"line\">synchronized (lock) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        lock.wait(3000L);</span><br><span class=\"line\">        Thread.sleep(2000L);</span><br><span class=\"line\">    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如上代码所示，wait 可以释放当前线程对 lock 对象锁的持有，而 sleep 则不会。</p>\n<h4 id=\"区别5：线程切换\"><a href=\"#区别5：线程切换\" class=\"headerlink\" title=\"区别5：线程切换\"></a>区别5：线程切换</h4><p>sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。</p>\n<p>@程序猿 你们还知道别的吗？欢迎留言！</p>\n"},{"title":"一文搞懂 Java 线程中断","date":"2025-10-14T06:42:34.000Z","_content":"\n```\ntry {\n\tThread.sleep(3000);\n} catch (InterruptedException e) {\n\te.printStackTrace();\n}\n```\n\n此时线程被打断后，代码会继续运行或者抛出异常结束运行，这并不是我们需要的中断线程的作用。\n\n#### 到底是什么是线程中断？\n\n线程中断即线程运行过程中被其他线程给打断了，它与 stop 最大的区别是：stop 是由系统强制终止线程，而线程中断则是给目标线程发送一个中断信号，如果目标线程没有接收线程中断的信号并结束线程，线程则不会终止，具体是否退出或者执行其他逻辑由目标线程决定。\n\n我们来看下线程中断最重要的 3 个方法，它们都是来自 Thread 类！\n\n**1、java.lang.Thread#interrupt**\n\n中断目标线程，给目标线程发一个中断信号，线程被打上中断标记。\n\n**2、java.lang.Thread#isInterrupted()**\n\n判断目标线程是否被中断，不会清除中断标记。\n\n**3、java.lang.Thread#interrupted**\n\n判断目标线程是否被中断，会清除中断标记。\n\n#### 线程中断实战\n\n我们来实例演示下线程中断如何用！\n\n**示例1（中断失败）**\n\n```\n/**\n * \n */\nprivate static void test1() {\n\tThread thread = new Thread(() -> {\n\t\twhile (true) {\n\t\t\tThread.yield();\n\t\t}\n\t});\n\tthread.start();\n\tthread.interrupt();\n}\n```\n\n请问示例1中的线程会被中断吗？答案：不会，因为虽然给线程发出了中断信号，但程序中并没有响应中断信号的逻辑，所以程序不会有任何反应。\n\n**示例2：（中断成功）**\n\n```\n/**\n * \n */\nprivate static void test2() {\n\tThread thread = new Thread(() -> {\n\t\twhile (true) {\n\t\t\tThread.yield();\n\n\t\t\t// 响应中断\n\t\t\tif (Thread.currentThread().isInterrupted()) {\n\t\t\t\tSystem.out.println(\"Java技术线程被中断，程序退出。\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t});\n\tthread.start();\n\tthread.interrupt();\n}\n```\n\n我们给示例2加上了响应中断的逻辑，程序接收到中断信号打印出信息后返回退出。\n\n**示例3（中断失败）**\n\n```\n/**\n * \n */\nprivate static void test3() throws InterruptedException {\n\tThread thread = new Thread(() -> {\n\t\twhile (true) {\n\t\t\t// 响应中断\n\t\t\tif (Thread.currentThread().isInterrupted()) {\n\t\t\t\tSystem.out.println(\"Java技术线程被中断，程序退出。\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tThread.sleep(3000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tSystem.out.println(\"Java技术线程休眠被中断，程序退出。\");\n\t\t\t}\n\t\t}\n\t});\n\tthread.start();\n\tThread.sleep(2000);\n\tthread.interrupt();\n}\n```\n\n示例3 sleep() 方法被中断，并输出了 `Java技术线程休眠被中断，程序退出。` 程序继续运行……为什么呢？\n\n来看 sleep 的源码：\n\n![](http://img.javastack.cn/18-6-1/1779530.jpg)\n\n可以看出 sleep() 方法被中断后会清除中断标记，所以循环会继续运行。。\n\n**示例4（中断成功）**\n\n```\n/**\n * \n */\nprivate static void test4() throws InterruptedException {\n\tThread thread = new Thread(() -> {\n\t\twhile (true) {\n\t\t\t// 响应中断\n\t\t\tif (Thread.currentThread().isInterrupted()) {\n\t\t\t\tSystem.out.println(\"Java技术线程被中断，程序退出。\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tThread.sleep(3000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tSystem.out.println(\"Java技术线程休眠被中断，程序退出。\");\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t}\n\t\t}\n\t});\n\tthread.start();\n\tThread.sleep(2000);\n\tthread.interrupt();\n}\n```\n\n示例4全部信息输出并正常退出，只是在 sleep() 方法被中断并清除标记后手动重新中断当前线程，然后程序接收中断信号返回退出。\n\n通过以上 4 个中断示例，相信对 Java 线程中断的概念有了全面的了解。\n\n\n","source":"_posts/一文搞懂 Java 线程中断.md","raw":"---\ntitle: 一文搞懂 Java 线程中断\ndate: 2025-10-14 14:42:34\ntags: 多线程\n---\n\n```\ntry {\n\tThread.sleep(3000);\n} catch (InterruptedException e) {\n\te.printStackTrace();\n}\n```\n\n此时线程被打断后，代码会继续运行或者抛出异常结束运行，这并不是我们需要的中断线程的作用。\n\n#### 到底是什么是线程中断？\n\n线程中断即线程运行过程中被其他线程给打断了，它与 stop 最大的区别是：stop 是由系统强制终止线程，而线程中断则是给目标线程发送一个中断信号，如果目标线程没有接收线程中断的信号并结束线程，线程则不会终止，具体是否退出或者执行其他逻辑由目标线程决定。\n\n我们来看下线程中断最重要的 3 个方法，它们都是来自 Thread 类！\n\n**1、java.lang.Thread#interrupt**\n\n中断目标线程，给目标线程发一个中断信号，线程被打上中断标记。\n\n**2、java.lang.Thread#isInterrupted()**\n\n判断目标线程是否被中断，不会清除中断标记。\n\n**3、java.lang.Thread#interrupted**\n\n判断目标线程是否被中断，会清除中断标记。\n\n#### 线程中断实战\n\n我们来实例演示下线程中断如何用！\n\n**示例1（中断失败）**\n\n```\n/**\n * \n */\nprivate static void test1() {\n\tThread thread = new Thread(() -> {\n\t\twhile (true) {\n\t\t\tThread.yield();\n\t\t}\n\t});\n\tthread.start();\n\tthread.interrupt();\n}\n```\n\n请问示例1中的线程会被中断吗？答案：不会，因为虽然给线程发出了中断信号，但程序中并没有响应中断信号的逻辑，所以程序不会有任何反应。\n\n**示例2：（中断成功）**\n\n```\n/**\n * \n */\nprivate static void test2() {\n\tThread thread = new Thread(() -> {\n\t\twhile (true) {\n\t\t\tThread.yield();\n\n\t\t\t// 响应中断\n\t\t\tif (Thread.currentThread().isInterrupted()) {\n\t\t\t\tSystem.out.println(\"Java技术线程被中断，程序退出。\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t});\n\tthread.start();\n\tthread.interrupt();\n}\n```\n\n我们给示例2加上了响应中断的逻辑，程序接收到中断信号打印出信息后返回退出。\n\n**示例3（中断失败）**\n\n```\n/**\n * \n */\nprivate static void test3() throws InterruptedException {\n\tThread thread = new Thread(() -> {\n\t\twhile (true) {\n\t\t\t// 响应中断\n\t\t\tif (Thread.currentThread().isInterrupted()) {\n\t\t\t\tSystem.out.println(\"Java技术线程被中断，程序退出。\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tThread.sleep(3000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tSystem.out.println(\"Java技术线程休眠被中断，程序退出。\");\n\t\t\t}\n\t\t}\n\t});\n\tthread.start();\n\tThread.sleep(2000);\n\tthread.interrupt();\n}\n```\n\n示例3 sleep() 方法被中断，并输出了 `Java技术线程休眠被中断，程序退出。` 程序继续运行……为什么呢？\n\n来看 sleep 的源码：\n\n![](http://img.javastack.cn/18-6-1/1779530.jpg)\n\n可以看出 sleep() 方法被中断后会清除中断标记，所以循环会继续运行。。\n\n**示例4（中断成功）**\n\n```\n/**\n * \n */\nprivate static void test4() throws InterruptedException {\n\tThread thread = new Thread(() -> {\n\t\twhile (true) {\n\t\t\t// 响应中断\n\t\t\tif (Thread.currentThread().isInterrupted()) {\n\t\t\t\tSystem.out.println(\"Java技术线程被中断，程序退出。\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tThread.sleep(3000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tSystem.out.println(\"Java技术线程休眠被中断，程序退出。\");\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t}\n\t\t}\n\t});\n\tthread.start();\n\tThread.sleep(2000);\n\tthread.interrupt();\n}\n```\n\n示例4全部信息输出并正常退出，只是在 sleep() 方法被中断并清除标记后手动重新中断当前线程，然后程序接收中断信号返回退出。\n\n通过以上 4 个中断示例，相信对 Java 线程中断的概念有了全面的了解。\n\n\n","slug":"一文搞懂 Java 线程中断","published":1,"updated":"2025-10-14T06:48:38.453Z","_id":"cmgq7875e0006hod4gl402g0s","comments":1,"layout":"post","photos":[],"content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">\tThread.sleep(3000);</span><br><span class=\"line\">&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\te.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时线程被打断后，代码会继续运行或者抛出异常结束运行，这并不是我们需要的中断线程的作用。</p>\n<h4 id=\"到底是什么是线程中断？\"><a href=\"#到底是什么是线程中断？\" class=\"headerlink\" title=\"到底是什么是线程中断？\"></a>到底是什么是线程中断？</h4><p>线程中断即线程运行过程中被其他线程给打断了，它与 stop 最大的区别是：stop 是由系统强制终止线程，而线程中断则是给目标线程发送一个中断信号，如果目标线程没有接收线程中断的信号并结束线程，线程则不会终止，具体是否退出或者执行其他逻辑由目标线程决定。</p>\n<p>我们来看下线程中断最重要的 3 个方法，它们都是来自 Thread 类！</p>\n<p><strong>1、java.lang.Thread#interrupt</strong></p>\n<p>中断目标线程，给目标线程发一个中断信号，线程被打上中断标记。</p>\n<p><strong>2、java.lang.Thread#isInterrupted()</strong></p>\n<p>判断目标线程是否被中断，不会清除中断标记。</p>\n<p><strong>3、java.lang.Thread#interrupted</strong></p>\n<p>判断目标线程是否被中断，会清除中断标记。</p>\n<h4 id=\"线程中断实战\"><a href=\"#线程中断实战\" class=\"headerlink\" title=\"线程中断实战\"></a>线程中断实战</h4><p>我们来实例演示下线程中断如何用！</p>\n<p><strong>示例1（中断失败）</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">private static void test1() &#123;</span><br><span class=\"line\">\tThread thread = new Thread(() -&gt; &#123;</span><br><span class=\"line\">\t\twhile (true) &#123;</span><br><span class=\"line\">\t\t\tThread.yield();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tthread.start();</span><br><span class=\"line\">\tthread.interrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请问示例1中的线程会被中断吗？答案：不会，因为虽然给线程发出了中断信号，但程序中并没有响应中断信号的逻辑，所以程序不会有任何反应。</p>\n<p><strong>示例2：（中断成功）</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">private static void test2() &#123;</span><br><span class=\"line\">\tThread thread = new Thread(() -&gt; &#123;</span><br><span class=\"line\">\t\twhile (true) &#123;</span><br><span class=\"line\">\t\t\tThread.yield();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t// 响应中断</span><br><span class=\"line\">\t\t\tif (Thread.currentThread().isInterrupted()) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;Java技术线程被中断，程序退出。&quot;);</span><br><span class=\"line\">\t\t\t\treturn;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tthread.start();</span><br><span class=\"line\">\tthread.interrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们给示例2加上了响应中断的逻辑，程序接收到中断信号打印出信息后返回退出。</p>\n<p><strong>示例3（中断失败）</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">private static void test3() throws InterruptedException &#123;</span><br><span class=\"line\">\tThread thread = new Thread(() -&gt; &#123;</span><br><span class=\"line\">\t\twhile (true) &#123;</span><br><span class=\"line\">\t\t\t// 响应中断</span><br><span class=\"line\">\t\t\tif (Thread.currentThread().isInterrupted()) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;Java技术线程被中断，程序退出。&quot;);</span><br><span class=\"line\">\t\t\t\treturn;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\tThread.sleep(3000);</span><br><span class=\"line\">\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;Java技术线程休眠被中断，程序退出。&quot;);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tthread.start();</span><br><span class=\"line\">\tThread.sleep(2000);</span><br><span class=\"line\">\tthread.interrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>示例3 sleep() 方法被中断，并输出了 <code>Java技术线程休眠被中断，程序退出。</code> 程序继续运行……为什么呢？</p>\n<p>来看 sleep 的源码：</p>\n<p><img src=\"http://img.javastack.cn/18-6-1/1779530.jpg\"></p>\n<p>可以看出 sleep() 方法被中断后会清除中断标记，所以循环会继续运行。。</p>\n<p><strong>示例4（中断成功）</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">private static void test4() throws InterruptedException &#123;</span><br><span class=\"line\">\tThread thread = new Thread(() -&gt; &#123;</span><br><span class=\"line\">\t\twhile (true) &#123;</span><br><span class=\"line\">\t\t\t// 响应中断</span><br><span class=\"line\">\t\t\tif (Thread.currentThread().isInterrupted()) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;Java技术线程被中断，程序退出。&quot;);</span><br><span class=\"line\">\t\t\t\treturn;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\tThread.sleep(3000);</span><br><span class=\"line\">\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;Java技术线程休眠被中断，程序退出。&quot;);</span><br><span class=\"line\">\t\t\t\tThread.currentThread().interrupt();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tthread.start();</span><br><span class=\"line\">\tThread.sleep(2000);</span><br><span class=\"line\">\tthread.interrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>示例4全部信息输出并正常退出，只是在 sleep() 方法被中断并清除标记后手动重新中断当前线程，然后程序接收中断信号返回退出。</p>\n<p>通过以上 4 个中断示例，相信对 Java 线程中断的概念有了全面的了解。</p>\n","excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">\tThread.sleep(3000);</span><br><span class=\"line\">&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\te.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时线程被打断后，代码会继续运行或者抛出异常结束运行，这并不是我们需要的中断线程的作用。</p>\n<h4 id=\"到底是什么是线程中断？\"><a href=\"#到底是什么是线程中断？\" class=\"headerlink\" title=\"到底是什么是线程中断？\"></a>到底是什么是线程中断？</h4><p>线程中断即线程运行过程中被其他线程给打断了，它与 stop 最大的区别是：stop 是由系统强制终止线程，而线程中断则是给目标线程发送一个中断信号，如果目标线程没有接收线程中断的信号并结束线程，线程则不会终止，具体是否退出或者执行其他逻辑由目标线程决定。</p>\n<p>我们来看下线程中断最重要的 3 个方法，它们都是来自 Thread 类！</p>\n<p><strong>1、java.lang.Thread#interrupt</strong></p>\n<p>中断目标线程，给目标线程发一个中断信号，线程被打上中断标记。</p>\n<p><strong>2、java.lang.Thread#isInterrupted()</strong></p>\n<p>判断目标线程是否被中断，不会清除中断标记。</p>\n<p><strong>3、java.lang.Thread#interrupted</strong></p>\n<p>判断目标线程是否被中断，会清除中断标记。</p>\n<h4 id=\"线程中断实战\"><a href=\"#线程中断实战\" class=\"headerlink\" title=\"线程中断实战\"></a>线程中断实战</h4><p>我们来实例演示下线程中断如何用！</p>\n<p><strong>示例1（中断失败）</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">private static void test1() &#123;</span><br><span class=\"line\">\tThread thread = new Thread(() -&gt; &#123;</span><br><span class=\"line\">\t\twhile (true) &#123;</span><br><span class=\"line\">\t\t\tThread.yield();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tthread.start();</span><br><span class=\"line\">\tthread.interrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请问示例1中的线程会被中断吗？答案：不会，因为虽然给线程发出了中断信号，但程序中并没有响应中断信号的逻辑，所以程序不会有任何反应。</p>\n<p><strong>示例2：（中断成功）</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">private static void test2() &#123;</span><br><span class=\"line\">\tThread thread = new Thread(() -&gt; &#123;</span><br><span class=\"line\">\t\twhile (true) &#123;</span><br><span class=\"line\">\t\t\tThread.yield();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t// 响应中断</span><br><span class=\"line\">\t\t\tif (Thread.currentThread().isInterrupted()) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;Java技术线程被中断，程序退出。&quot;);</span><br><span class=\"line\">\t\t\t\treturn;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tthread.start();</span><br><span class=\"line\">\tthread.interrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们给示例2加上了响应中断的逻辑，程序接收到中断信号打印出信息后返回退出。</p>\n<p><strong>示例3（中断失败）</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">private static void test3() throws InterruptedException &#123;</span><br><span class=\"line\">\tThread thread = new Thread(() -&gt; &#123;</span><br><span class=\"line\">\t\twhile (true) &#123;</span><br><span class=\"line\">\t\t\t// 响应中断</span><br><span class=\"line\">\t\t\tif (Thread.currentThread().isInterrupted()) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;Java技术线程被中断，程序退出。&quot;);</span><br><span class=\"line\">\t\t\t\treturn;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\tThread.sleep(3000);</span><br><span class=\"line\">\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;Java技术线程休眠被中断，程序退出。&quot;);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tthread.start();</span><br><span class=\"line\">\tThread.sleep(2000);</span><br><span class=\"line\">\tthread.interrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>示例3 sleep() 方法被中断，并输出了 <code>Java技术线程休眠被中断，程序退出。</code> 程序继续运行……为什么呢？</p>\n<p>来看 sleep 的源码：</p>\n<p><img src=\"http://img.javastack.cn/18-6-1/1779530.jpg\"></p>\n<p>可以看出 sleep() 方法被中断后会清除中断标记，所以循环会继续运行。。</p>\n<p><strong>示例4（中断成功）</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">private static void test4() throws InterruptedException &#123;</span><br><span class=\"line\">\tThread thread = new Thread(() -&gt; &#123;</span><br><span class=\"line\">\t\twhile (true) &#123;</span><br><span class=\"line\">\t\t\t// 响应中断</span><br><span class=\"line\">\t\t\tif (Thread.currentThread().isInterrupted()) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;Java技术线程被中断，程序退出。&quot;);</span><br><span class=\"line\">\t\t\t\treturn;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\tThread.sleep(3000);</span><br><span class=\"line\">\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(&quot;Java技术线程休眠被中断，程序退出。&quot;);</span><br><span class=\"line\">\t\t\t\tThread.currentThread().interrupt();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tthread.start();</span><br><span class=\"line\">\tThread.sleep(2000);</span><br><span class=\"line\">\tthread.interrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>示例4全部信息输出并正常退出，只是在 sleep() 方法被中断并清除标记后手动重新中断当前线程，然后程序接收中断信号返回退出。</p>\n<p>通过以上 4 个中断示例，相信对 Java 线程中断的概念有了全面的了解。</p>\n"},{"title":"Synchronized 与 ReentrantLock 的区别！","date":"2025-10-14T06:42:34.000Z","_content":"**可重入性：**\n\n从名字上理解，ReenTrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程没进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。\n\n\n**锁的实现：**\n\nSynchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。\n\n\n**性能的区别：**\n\n在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。\n\n\n**功能区别：**\n\n便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。\n\n锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized\n\n\n**ReenTrantLock独有的能力：**\n\n1.ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。\n\n2.ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。\n\n3.ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。\n\n\n**ReenTrantLock实现的原理：**\n\n在网上看到相关的源码分析，本来这块应该是本文的核心，但是感觉比较复杂就不一一详解了，简单来说，ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。\n\n\n**什么情况下使用ReenTrantLock：**\n\n答案是，如果你需要实现ReenTrantLock的三个独有功能时。\n\n\n最后，大家也可以关注，栈长将继续分享更多 Java 系列干货，在公众号后台回复：Java，可以获取栈长已经整理好的历史 Java 系列干货文章。\n\n觉得有用，转发分享下朋友圈给更多的人看吧，另外，给个好看，谢谢老板~","source":"_posts/Synchronized 与 ReentrantLock 的区别！.md","raw":"---\ntitle: Synchronized 与 ReentrantLock 的区别！\ndate: 2025-10-14 14:42:34\ntags: 多线程\n---\n**可重入性：**\n\n从名字上理解，ReenTrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程没进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。\n\n\n**锁的实现：**\n\nSynchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。\n\n\n**性能的区别：**\n\n在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。\n\n\n**功能区别：**\n\n便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。\n\n锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized\n\n\n**ReenTrantLock独有的能力：**\n\n1.ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。\n\n2.ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。\n\n3.ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。\n\n\n**ReenTrantLock实现的原理：**\n\n在网上看到相关的源码分析，本来这块应该是本文的核心，但是感觉比较复杂就不一一详解了，简单来说，ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。\n\n\n**什么情况下使用ReenTrantLock：**\n\n答案是，如果你需要实现ReenTrantLock的三个独有功能时。\n\n\n最后，大家也可以关注，栈长将继续分享更多 Java 系列干货，在公众号后台回复：Java，可以获取栈长已经整理好的历史 Java 系列干货文章。\n\n觉得有用，转发分享下朋友圈给更多的人看吧，另外，给个好看，谢谢老板~","slug":"Synchronized 与 ReentrantLock 的区别！","published":1,"updated":"2025-10-14T06:47:14.742Z","_id":"cmgq7875g0007hod478l16wia","comments":1,"layout":"post","photos":[],"content":"<p><strong>可重入性：</strong></p>\n<p>从名字上理解，ReenTrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程没进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>\n<p><strong>锁的实现：</strong></p>\n<p>Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。</p>\n<p><strong>性能的区别：</strong></p>\n<p>在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。</p>\n<p><strong>功能区别：</strong></p>\n<p>便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。</p>\n<p>锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized</p>\n<p><strong>ReenTrantLock独有的能力：</strong></p>\n<p>1.ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</p>\n<p>2.ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</p>\n<p>3.ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。</p>\n<p><strong>ReenTrantLock实现的原理：</strong></p>\n<p>在网上看到相关的源码分析，本来这块应该是本文的核心，但是感觉比较复杂就不一一详解了，简单来说，ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。</p>\n<p><strong>什么情况下使用ReenTrantLock：</strong></p>\n<p>答案是，如果你需要实现ReenTrantLock的三个独有功能时。</p>\n<p>最后，大家也可以关注，栈长将继续分享更多 Java 系列干货，在公众号后台回复：Java，可以获取栈长已经整理好的历史 Java 系列干货文章。</p>\n<p>觉得有用，转发分享下朋友圈给更多的人看吧，另外，给个好看，谢谢老板~</p>\n","excerpt":"","more":"<p><strong>可重入性：</strong></p>\n<p>从名字上理解，ReenTrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程没进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>\n<p><strong>锁的实现：</strong></p>\n<p>Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。</p>\n<p><strong>性能的区别：</strong></p>\n<p>在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。</p>\n<p><strong>功能区别：</strong></p>\n<p>便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。</p>\n<p>锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized</p>\n<p><strong>ReenTrantLock独有的能力：</strong></p>\n<p>1.ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</p>\n<p>2.ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</p>\n<p>3.ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。</p>\n<p><strong>ReenTrantLock实现的原理：</strong></p>\n<p>在网上看到相关的源码分析，本来这块应该是本文的核心，但是感觉比较复杂就不一一详解了，简单来说，ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。</p>\n<p><strong>什么情况下使用ReenTrantLock：</strong></p>\n<p>答案是，如果你需要实现ReenTrantLock的三个独有功能时。</p>\n<p>最后，大家也可以关注，栈长将继续分享更多 Java 系列干货，在公众号后台回复：Java，可以获取栈长已经整理好的历史 Java 系列干货文章。</p>\n<p>觉得有用，转发分享下朋友圈给更多的人看吧，另外，给个好看，谢谢老板~</p>\n"},{"title":"出场率比较高的一道多线程安全面试题","date":"2025-10-14T06:42:34.000Z","_content":"\n工作一两年的应该都知道 ArrayList 是线程不安全的，要使用线程安全的就使用 Vector，这也是各种 Java 面试宝典里面所提及的，可能很多工作好几年的程序员都停留在这个知识面上。\n\n先说说为什么 ArrayList 是线程不安全的吧，来看以下的代码。\n\n```\n/**\n * \n */\npublic class TestArrayList {\n\n\tprivate static List<Integer> list = new ArrayList<>();\n\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\ttestList();\n\t\t\tlist.clear();\n\t\t}\n\t}\n\n\tprivate static void testList() throws InterruptedException {\n\t\tRunnable runnable = () -> {\n\t\t\tfor (int i = 0; i < 10000; i++) {\n\t\t\t\tlist.add(i);\n\t\t\t}\n\t\t};\n\n\t\tThread t1 = new Thread(runnable);\n\t\tThread t2 = new Thread(runnable);\n\t\tThread t3 = new Thread(runnable);\n\n\t\tt1.start();\n\t\tt2.start();\n\t\tt3.start();\n\n\t\tt1.join();\n\t\tt2.join();\n\t\tt3.join();\n\n\t\tSystem.out.println(list.size());\n\t}\n\n}\n```\n\n这是它的输出结果，我们期望的结果应该都是：30000，然后并不是，这就是传说中的多线程并发问题了。\n\n```\nException in thread \"Thread-1\" java.lang.ArrayIndexOutOfBoundsException: 15786\n\tat java.base/java.util.ArrayList.add(ArrayList.java:468)\n\tat java.base/java.util.ArrayList.add(ArrayList.java:480)\n\tat com.test.thread.TestArrayList.lambda$testList$0(TestArrayList.java:23)\n\tat java.base/java.lang.Thread.run(Thread.java:844)\n20332\n16100\n14941\n23749\n15631\n22118\n27417\n30000\n28691\n27843\n```\n\n#### 现象分析\n\n从以上结果可以总结出 ArrayList 在并发情况下会出现的几种现象。\n\n**1、发生 ArrayIndexOutOfBoundsException 异常；**\n\n```\nprivate void add(E e, Object[] elementData, int s) {\n    if (s == elementData.length)\n        elementData = grow();\n    elementData[s] = e;\n    size = s + 1;\n}\n```\n\n定位到异常所在源代码，毫无疑问，问题是出现在多线程并发访问下，由于没有同步锁的保护，造成了 ArrayList 扩容不一致的问题。\n\n\n**2、程序正常运行，输出了少于实际容量的大小；**\n\n这个也是多线程并发赋值时，对同一个数组索引位置进行了赋值，所以出现少于预期大小的情况。\n\n**3、程序正常运行，输出了预期容量的大小；**\n\n这是正常运行结果，未发生多线程安全问题，但这是不确定性的，不是每次都会达到正常预期的。\n\n#### 解决方案\n\n既然这样，那么在高并发情况下，使用什么样的列表集合保护线程安全呢？回到文章最开始的地方，使用 Vector，还有别的吗？当然有，篇幅有限，请各位看官期待后续文章。\n\n另外，像 HashMap, HashSet 等都有类似多线程安全问题，在多线程并发环境下避免使用这种集合。\n\n","source":"_posts/出场率比较高的一道多线程安全面试题.md","raw":"---\ntitle: 出场率比较高的一道多线程安全面试题\ndate: 2025-10-14 14:42:34\ntags: 多线程\n---\n\n工作一两年的应该都知道 ArrayList 是线程不安全的，要使用线程安全的就使用 Vector，这也是各种 Java 面试宝典里面所提及的，可能很多工作好几年的程序员都停留在这个知识面上。\n\n先说说为什么 ArrayList 是线程不安全的吧，来看以下的代码。\n\n```\n/**\n * \n */\npublic class TestArrayList {\n\n\tprivate static List<Integer> list = new ArrayList<>();\n\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\ttestList();\n\t\t\tlist.clear();\n\t\t}\n\t}\n\n\tprivate static void testList() throws InterruptedException {\n\t\tRunnable runnable = () -> {\n\t\t\tfor (int i = 0; i < 10000; i++) {\n\t\t\t\tlist.add(i);\n\t\t\t}\n\t\t};\n\n\t\tThread t1 = new Thread(runnable);\n\t\tThread t2 = new Thread(runnable);\n\t\tThread t3 = new Thread(runnable);\n\n\t\tt1.start();\n\t\tt2.start();\n\t\tt3.start();\n\n\t\tt1.join();\n\t\tt2.join();\n\t\tt3.join();\n\n\t\tSystem.out.println(list.size());\n\t}\n\n}\n```\n\n这是它的输出结果，我们期望的结果应该都是：30000，然后并不是，这就是传说中的多线程并发问题了。\n\n```\nException in thread \"Thread-1\" java.lang.ArrayIndexOutOfBoundsException: 15786\n\tat java.base/java.util.ArrayList.add(ArrayList.java:468)\n\tat java.base/java.util.ArrayList.add(ArrayList.java:480)\n\tat com.test.thread.TestArrayList.lambda$testList$0(TestArrayList.java:23)\n\tat java.base/java.lang.Thread.run(Thread.java:844)\n20332\n16100\n14941\n23749\n15631\n22118\n27417\n30000\n28691\n27843\n```\n\n#### 现象分析\n\n从以上结果可以总结出 ArrayList 在并发情况下会出现的几种现象。\n\n**1、发生 ArrayIndexOutOfBoundsException 异常；**\n\n```\nprivate void add(E e, Object[] elementData, int s) {\n    if (s == elementData.length)\n        elementData = grow();\n    elementData[s] = e;\n    size = s + 1;\n}\n```\n\n定位到异常所在源代码，毫无疑问，问题是出现在多线程并发访问下，由于没有同步锁的保护，造成了 ArrayList 扩容不一致的问题。\n\n\n**2、程序正常运行，输出了少于实际容量的大小；**\n\n这个也是多线程并发赋值时，对同一个数组索引位置进行了赋值，所以出现少于预期大小的情况。\n\n**3、程序正常运行，输出了预期容量的大小；**\n\n这是正常运行结果，未发生多线程安全问题，但这是不确定性的，不是每次都会达到正常预期的。\n\n#### 解决方案\n\n既然这样，那么在高并发情况下，使用什么样的列表集合保护线程安全呢？回到文章最开始的地方，使用 Vector，还有别的吗？当然有，篇幅有限，请各位看官期待后续文章。\n\n另外，像 HashMap, HashSet 等都有类似多线程安全问题，在多线程并发环境下避免使用这种集合。\n\n","slug":"出场率比较高的一道多线程安全面试题","published":1,"updated":"2025-10-14T07:16:33.114Z","_id":"cmgq787670008hod415h76bh3","comments":1,"layout":"post","photos":[],"content":"<p>工作一两年的应该都知道 ArrayList 是线程不安全的，要使用线程安全的就使用 Vector，这也是各种 Java 面试宝典里面所提及的，可能很多工作好几年的程序员都停留在这个知识面上。</p>\n<p>先说说为什么 ArrayList 是线程不安全的吧，来看以下的代码。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">public class TestArrayList &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">\t\t\ttestList();</span><br><span class=\"line\">\t\t\tlist.clear();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static void testList() throws InterruptedException &#123;</span><br><span class=\"line\">\t\tRunnable runnable = () -&gt; &#123;</span><br><span class=\"line\">\t\t\tfor (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class=\"line\">\t\t\t\tlist.add(i);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tThread t1 = new Thread(runnable);</span><br><span class=\"line\">\t\tThread t2 = new Thread(runnable);</span><br><span class=\"line\">\t\tThread t3 = new Thread(runnable);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tt1.start();</span><br><span class=\"line\">\t\tt2.start();</span><br><span class=\"line\">\t\tt3.start();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tt1.join();</span><br><span class=\"line\">\t\tt2.join();</span><br><span class=\"line\">\t\tt3.join();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(list.size());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是它的输出结果，我们期望的结果应该都是：30000，然后并不是，这就是传说中的多线程并发问题了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;Thread-1&quot; java.lang.ArrayIndexOutOfBoundsException: 15786</span><br><span class=\"line\">\tat java.base/java.util.ArrayList.add(ArrayList.java:468)</span><br><span class=\"line\">\tat java.base/java.util.ArrayList.add(ArrayList.java:480)</span><br><span class=\"line\">\tat com.test.thread.TestArrayList.lambda$testList$0(TestArrayList.java:23)</span><br><span class=\"line\">\tat java.base/java.lang.Thread.run(Thread.java:844)</span><br><span class=\"line\">20332</span><br><span class=\"line\">16100</span><br><span class=\"line\">14941</span><br><span class=\"line\">23749</span><br><span class=\"line\">15631</span><br><span class=\"line\">22118</span><br><span class=\"line\">27417</span><br><span class=\"line\">30000</span><br><span class=\"line\">28691</span><br><span class=\"line\">27843</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"现象分析\"><a href=\"#现象分析\" class=\"headerlink\" title=\"现象分析\"></a>现象分析</h4><p>从以上结果可以总结出 ArrayList 在并发情况下会出现的几种现象。</p>\n<p><strong>1、发生 ArrayIndexOutOfBoundsException 异常；</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void add(E e, Object[] elementData, int s) &#123;</span><br><span class=\"line\">    if (s == elementData.length)</span><br><span class=\"line\">        elementData = grow();</span><br><span class=\"line\">    elementData[s] = e;</span><br><span class=\"line\">    size = s + 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定位到异常所在源代码，毫无疑问，问题是出现在多线程并发访问下，由于没有同步锁的保护，造成了 ArrayList 扩容不一致的问题。</p>\n<p><strong>2、程序正常运行，输出了少于实际容量的大小；</strong></p>\n<p>这个也是多线程并发赋值时，对同一个数组索引位置进行了赋值，所以出现少于预期大小的情况。</p>\n<p><strong>3、程序正常运行，输出了预期容量的大小；</strong></p>\n<p>这是正常运行结果，未发生多线程安全问题，但这是不确定性的，不是每次都会达到正常预期的。</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>既然这样，那么在高并发情况下，使用什么样的列表集合保护线程安全呢？回到文章最开始的地方，使用 Vector，还有别的吗？当然有，篇幅有限，请各位看官期待后续文章。</p>\n<p>另外，像 HashMap, HashSet 等都有类似多线程安全问题，在多线程并发环境下避免使用这种集合。</p>\n","excerpt":"","more":"<p>工作一两年的应该都知道 ArrayList 是线程不安全的，要使用线程安全的就使用 Vector，这也是各种 Java 面试宝典里面所提及的，可能很多工作好几年的程序员都停留在这个知识面上。</p>\n<p>先说说为什么 ArrayList 是线程不安全的吧，来看以下的代码。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">public class TestArrayList &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">\t\t\ttestList();</span><br><span class=\"line\">\t\t\tlist.clear();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static void testList() throws InterruptedException &#123;</span><br><span class=\"line\">\t\tRunnable runnable = () -&gt; &#123;</span><br><span class=\"line\">\t\t\tfor (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class=\"line\">\t\t\t\tlist.add(i);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tThread t1 = new Thread(runnable);</span><br><span class=\"line\">\t\tThread t2 = new Thread(runnable);</span><br><span class=\"line\">\t\tThread t3 = new Thread(runnable);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tt1.start();</span><br><span class=\"line\">\t\tt2.start();</span><br><span class=\"line\">\t\tt3.start();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tt1.join();</span><br><span class=\"line\">\t\tt2.join();</span><br><span class=\"line\">\t\tt3.join();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(list.size());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是它的输出结果，我们期望的结果应该都是：30000，然后并不是，这就是传说中的多线程并发问题了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;Thread-1&quot; java.lang.ArrayIndexOutOfBoundsException: 15786</span><br><span class=\"line\">\tat java.base/java.util.ArrayList.add(ArrayList.java:468)</span><br><span class=\"line\">\tat java.base/java.util.ArrayList.add(ArrayList.java:480)</span><br><span class=\"line\">\tat com.test.thread.TestArrayList.lambda$testList$0(TestArrayList.java:23)</span><br><span class=\"line\">\tat java.base/java.lang.Thread.run(Thread.java:844)</span><br><span class=\"line\">20332</span><br><span class=\"line\">16100</span><br><span class=\"line\">14941</span><br><span class=\"line\">23749</span><br><span class=\"line\">15631</span><br><span class=\"line\">22118</span><br><span class=\"line\">27417</span><br><span class=\"line\">30000</span><br><span class=\"line\">28691</span><br><span class=\"line\">27843</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"现象分析\"><a href=\"#现象分析\" class=\"headerlink\" title=\"现象分析\"></a>现象分析</h4><p>从以上结果可以总结出 ArrayList 在并发情况下会出现的几种现象。</p>\n<p><strong>1、发生 ArrayIndexOutOfBoundsException 异常；</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void add(E e, Object[] elementData, int s) &#123;</span><br><span class=\"line\">    if (s == elementData.length)</span><br><span class=\"line\">        elementData = grow();</span><br><span class=\"line\">    elementData[s] = e;</span><br><span class=\"line\">    size = s + 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定位到异常所在源代码，毫无疑问，问题是出现在多线程并发访问下，由于没有同步锁的保护，造成了 ArrayList 扩容不一致的问题。</p>\n<p><strong>2、程序正常运行，输出了少于实际容量的大小；</strong></p>\n<p>这个也是多线程并发赋值时，对同一个数组索引位置进行了赋值，所以出现少于预期大小的情况。</p>\n<p><strong>3、程序正常运行，输出了预期容量的大小；</strong></p>\n<p>这是正常运行结果，未发生多线程安全问题，但这是不确定性的，不是每次都会达到正常预期的。</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>既然这样，那么在高并发情况下，使用什么样的列表集合保护线程安全呢？回到文章最开始的地方，使用 Vector，还有别的吗？当然有，篇幅有限，请各位看官期待后续文章。</p>\n<p>另外，像 HashMap, HashSet 等都有类似多线程安全问题，在多线程并发环境下避免使用这种集合。</p>\n"},{"title":"到底什么是重入锁，拜托，一次搞清楚！","date":"2025-10-14T06:42:34.000Z","_content":"\n\n#### 什么是重入锁\n\n> java.util.concurrent.locks.ReentrantLock\n\n这个是 JDK @since 1.5 添加的一种颗粒度更小的锁，它完全可以替代 synchronized 关键字来实现它的所有功能，而且 ReentrantLock 锁的灵活度要远远大于 synchronized 关键字。\n\n![](http://img.javastack.cn/ReentrantLock.png)\n\n从类结构图看出，ReentrantLock 实现了 Lock 接口，ReentrantLock 只是 Lock 接口的一个实现而已。\n\n> java.util.concurrent.locks.Lock\n\n它们都是 java.util.concurrent 包里面的内容（俗称 JUC、并发包），也都是 JDK 1.5 开始加入的。\n\n#### 为什么叫重入锁呢？\n\nReentrantLock，我们把它拆开来看就明了了。\n\nRe-Entrant-Lock：即表示可重新反复进入的锁，但仅限于当前线程；\n\n```\npublic void m() {\n    lock.lock();\n    lock.lock();\n    try {\n      // ... method body\n    } finally {\n      lock.unlock()\n      lock.unlock()\n    }\n}\n```\n\n如示例代码所示，当前线程可以反复加锁，但也需要释放同样加锁次数的锁，即重入了多少次，就要释放多少次，不然也会导入锁不被释放。\n\n试想一下，如果不设计成可重入锁，那自己如果反复给自己加锁，不是会把自己加死锁了吗？所以，到现在，重入锁的概念大概应该清楚了吧？\n\n#### 重入锁最重要的几个方法\n\n这几个方法都是 Lock 接口中定义的：\n\n![](http://img.javastack.cn/Lock.png)\n\n**1）lock()**\n\n获取锁，有以下三种情况：\n\n- 锁空闲：直接获取锁并返回，同时设置锁持有者数量为：1；\n- 当前线程持有锁：直接获取锁并返回，同时锁持有者数量递增1；\n- 其他线程持有锁：当前线程会休眠等待，直至获取锁为止；\n\n**2）lockInterruptibly()**\n\n获取锁，逻辑和 lock() 方法一样，但这个方法在获取锁过程中能响应中断。\n\n**3）tryLock()**\n\n从关键字字面理解，这是在尝试获取锁，获取成功返回：true，获取失败返回：false, 这个方法不会等待，有以下三种情况：\n\n- 锁空闲：直接获取锁并返回：true，同时设置锁持有者数量为：1；\n- 当前线程持有锁：直接获取锁并返回：true，同时锁持有者数量递增1；\n- 其他线程持有锁：获取锁失败，返回：false；\n\n**4）tryLock(long timeout, TimeUnit unit)**\n\n逻辑和 tryLock() 差不多，只是这个方法是带时间的。\n\n**5）unlock()**\n\n释放锁，每次锁持有者数量递减 1，直到 0 为止。所以，现在知道为什么 lock 多少次，就要对应 unlock 多少次了吧。\n\n**6）newCondition**\n\n返回一个这个锁的 Condition 实例，可以实现 synchronized 关键字类似 wait/ notify 实现多线程通信的功能，不过这个比 wait/ notify 要更灵活，更强大！\n\n#### 重入锁大概的用法\n\n```\nclass X {\n\n  private final ReentrantLock lock = new ReentrantLock();\n  \n  // ...\n\n  public void m() {\n    lock.lock();  // block until condition holds\n    try {\n      // ... method body\n    } finally {\n      lock.unlock()\n    }\n  }\n  \n}}\n```\n\n看见没有，加锁和释放锁都在方法里面进行，可以自由控制，比 synchronized 更灵活，更方便。但要注意的是，释放锁操作必须在 finally 里面，不然如果出现异常导致锁不能被正常释放，进而会卡死后续所有访问该锁的线程。\n\n#### synchronized 是重入锁吗？\n\n那么问题来了，synchronized 是重入锁吗？\n\n你可能会说不是，因为 ReentrantLock 既然是重入锁，根据推理，相反，那 synchronized 肯定就不是重入锁，那你就错了。\n\n答案是：yes，为什么？看下面的例子：\n\n```\npublic synchronized void operation(){\n    add();\n}\n\npublic synchronized void add(){\n\n}\n```\n\noperation 方法调用了 add 方法，两个方法都是用 synchronized 修饰的，add()  方法可以成功获取当前线程 operation() 方法已经获取到的锁，说明 synchronized 就是可重入锁。\n\n面试常问的Synchronized的几种用法推荐看下这篇文章：[Synchronized 有几种用法？](https://mp.weixin.qq.com/s/9h6VjHAmLA3twD6Y-FqfwA)。\n\n#### 总结\n\n今天，重入锁就大概写到这里了，其实重入锁就是一种颗粒度更小的锁，控制更方便，更强大，栈长只是简单介绍一下重入锁的基本概念及用法，但远不止这么简单，还有很多，一篇也难也详尽，够写好多篇了。\n\n大家也可以关注，栈长将继续分享更多重入锁的高级的概念及工作中的实战用法，请关注后续文章，或者在公众号后台回复：多线程，栈长已经整理好了许多 Java 多线程系列文章，都是接地气干货。\n\n觉得有用，转发分享下朋友圈给更多的人看吧，另外，给个好看，谢谢老板~\n\n本文原创首发于（id:javastack），转载请原样保留本信息。\n","source":"_posts/到底什么是重入锁，拜托，一次搞清楚！.md","raw":"---\ntitle: 到底什么是重入锁，拜托，一次搞清楚！\ndate: 2025-10-14 14:42:34\ntags: 多线程\n---\n\n\n#### 什么是重入锁\n\n> java.util.concurrent.locks.ReentrantLock\n\n这个是 JDK @since 1.5 添加的一种颗粒度更小的锁，它完全可以替代 synchronized 关键字来实现它的所有功能，而且 ReentrantLock 锁的灵活度要远远大于 synchronized 关键字。\n\n![](http://img.javastack.cn/ReentrantLock.png)\n\n从类结构图看出，ReentrantLock 实现了 Lock 接口，ReentrantLock 只是 Lock 接口的一个实现而已。\n\n> java.util.concurrent.locks.Lock\n\n它们都是 java.util.concurrent 包里面的内容（俗称 JUC、并发包），也都是 JDK 1.5 开始加入的。\n\n#### 为什么叫重入锁呢？\n\nReentrantLock，我们把它拆开来看就明了了。\n\nRe-Entrant-Lock：即表示可重新反复进入的锁，但仅限于当前线程；\n\n```\npublic void m() {\n    lock.lock();\n    lock.lock();\n    try {\n      // ... method body\n    } finally {\n      lock.unlock()\n      lock.unlock()\n    }\n}\n```\n\n如示例代码所示，当前线程可以反复加锁，但也需要释放同样加锁次数的锁，即重入了多少次，就要释放多少次，不然也会导入锁不被释放。\n\n试想一下，如果不设计成可重入锁，那自己如果反复给自己加锁，不是会把自己加死锁了吗？所以，到现在，重入锁的概念大概应该清楚了吧？\n\n#### 重入锁最重要的几个方法\n\n这几个方法都是 Lock 接口中定义的：\n\n![](http://img.javastack.cn/Lock.png)\n\n**1）lock()**\n\n获取锁，有以下三种情况：\n\n- 锁空闲：直接获取锁并返回，同时设置锁持有者数量为：1；\n- 当前线程持有锁：直接获取锁并返回，同时锁持有者数量递增1；\n- 其他线程持有锁：当前线程会休眠等待，直至获取锁为止；\n\n**2）lockInterruptibly()**\n\n获取锁，逻辑和 lock() 方法一样，但这个方法在获取锁过程中能响应中断。\n\n**3）tryLock()**\n\n从关键字字面理解，这是在尝试获取锁，获取成功返回：true，获取失败返回：false, 这个方法不会等待，有以下三种情况：\n\n- 锁空闲：直接获取锁并返回：true，同时设置锁持有者数量为：1；\n- 当前线程持有锁：直接获取锁并返回：true，同时锁持有者数量递增1；\n- 其他线程持有锁：获取锁失败，返回：false；\n\n**4）tryLock(long timeout, TimeUnit unit)**\n\n逻辑和 tryLock() 差不多，只是这个方法是带时间的。\n\n**5）unlock()**\n\n释放锁，每次锁持有者数量递减 1，直到 0 为止。所以，现在知道为什么 lock 多少次，就要对应 unlock 多少次了吧。\n\n**6）newCondition**\n\n返回一个这个锁的 Condition 实例，可以实现 synchronized 关键字类似 wait/ notify 实现多线程通信的功能，不过这个比 wait/ notify 要更灵活，更强大！\n\n#### 重入锁大概的用法\n\n```\nclass X {\n\n  private final ReentrantLock lock = new ReentrantLock();\n  \n  // ...\n\n  public void m() {\n    lock.lock();  // block until condition holds\n    try {\n      // ... method body\n    } finally {\n      lock.unlock()\n    }\n  }\n  \n}}\n```\n\n看见没有，加锁和释放锁都在方法里面进行，可以自由控制，比 synchronized 更灵活，更方便。但要注意的是，释放锁操作必须在 finally 里面，不然如果出现异常导致锁不能被正常释放，进而会卡死后续所有访问该锁的线程。\n\n#### synchronized 是重入锁吗？\n\n那么问题来了，synchronized 是重入锁吗？\n\n你可能会说不是，因为 ReentrantLock 既然是重入锁，根据推理，相反，那 synchronized 肯定就不是重入锁，那你就错了。\n\n答案是：yes，为什么？看下面的例子：\n\n```\npublic synchronized void operation(){\n    add();\n}\n\npublic synchronized void add(){\n\n}\n```\n\noperation 方法调用了 add 方法，两个方法都是用 synchronized 修饰的，add()  方法可以成功获取当前线程 operation() 方法已经获取到的锁，说明 synchronized 就是可重入锁。\n\n面试常问的Synchronized的几种用法推荐看下这篇文章：[Synchronized 有几种用法？](https://mp.weixin.qq.com/s/9h6VjHAmLA3twD6Y-FqfwA)。\n\n#### 总结\n\n今天，重入锁就大概写到这里了，其实重入锁就是一种颗粒度更小的锁，控制更方便，更强大，栈长只是简单介绍一下重入锁的基本概念及用法，但远不止这么简单，还有很多，一篇也难也详尽，够写好多篇了。\n\n大家也可以关注，栈长将继续分享更多重入锁的高级的概念及工作中的实战用法，请关注后续文章，或者在公众号后台回复：多线程，栈长已经整理好了许多 Java 多线程系列文章，都是接地气干货。\n\n觉得有用，转发分享下朋友圈给更多的人看吧，另外，给个好看，谢谢老板~\n\n本文原创首发于（id:javastack），转载请原样保留本信息。\n","slug":"到底什么是重入锁，拜托，一次搞清楚！","published":1,"updated":"2025-10-14T07:16:33.078Z","_id":"cmgq787690009hod44qzt4rjk","comments":1,"layout":"post","photos":[],"content":"<h4 id=\"什么是重入锁\"><a href=\"#什么是重入锁\" class=\"headerlink\" title=\"什么是重入锁\"></a>什么是重入锁</h4><blockquote>\n<p>java.util.concurrent.locks.ReentrantLock</p>\n</blockquote>\n<p>这个是 JDK @since 1.5 添加的一种颗粒度更小的锁，它完全可以替代 synchronized 关键字来实现它的所有功能，而且 ReentrantLock 锁的灵活度要远远大于 synchronized 关键字。</p>\n<p><img src=\"http://img.javastack.cn/ReentrantLock.png\"></p>\n<p>从类结构图看出，ReentrantLock 实现了 Lock 接口，ReentrantLock 只是 Lock 接口的一个实现而已。</p>\n<blockquote>\n<p>java.util.concurrent.locks.Lock</p>\n</blockquote>\n<p>它们都是 java.util.concurrent 包里面的内容（俗称 JUC、并发包），也都是 JDK 1.5 开始加入的。</p>\n<h4 id=\"为什么叫重入锁呢？\"><a href=\"#为什么叫重入锁呢？\" class=\"headerlink\" title=\"为什么叫重入锁呢？\"></a>为什么叫重入锁呢？</h4><p>ReentrantLock，我们把它拆开来看就明了了。</p>\n<p>Re-Entrant-Lock：即表示可重新反复进入的锁，但仅限于当前线程；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void m() &#123;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      // ... method body</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">      lock.unlock()</span><br><span class=\"line\">      lock.unlock()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如示例代码所示，当前线程可以反复加锁，但也需要释放同样加锁次数的锁，即重入了多少次，就要释放多少次，不然也会导入锁不被释放。</p>\n<p>试想一下，如果不设计成可重入锁，那自己如果反复给自己加锁，不是会把自己加死锁了吗？所以，到现在，重入锁的概念大概应该清楚了吧？</p>\n<h4 id=\"重入锁最重要的几个方法\"><a href=\"#重入锁最重要的几个方法\" class=\"headerlink\" title=\"重入锁最重要的几个方法\"></a>重入锁最重要的几个方法</h4><p>这几个方法都是 Lock 接口中定义的：</p>\n<p><img src=\"http://img.javastack.cn/Lock.png\"></p>\n<p><strong>1）lock()</strong></p>\n<p>获取锁，有以下三种情况：</p>\n<ul>\n<li>锁空闲：直接获取锁并返回，同时设置锁持有者数量为：1；</li>\n<li>当前线程持有锁：直接获取锁并返回，同时锁持有者数量递增1；</li>\n<li>其他线程持有锁：当前线程会休眠等待，直至获取锁为止；</li>\n</ul>\n<p><strong>2）lockInterruptibly()</strong></p>\n<p>获取锁，逻辑和 lock() 方法一样，但这个方法在获取锁过程中能响应中断。</p>\n<p><strong>3）tryLock()</strong></p>\n<p>从关键字字面理解，这是在尝试获取锁，获取成功返回：true，获取失败返回：false, 这个方法不会等待，有以下三种情况：</p>\n<ul>\n<li>锁空闲：直接获取锁并返回：true，同时设置锁持有者数量为：1；</li>\n<li>当前线程持有锁：直接获取锁并返回：true，同时锁持有者数量递增1；</li>\n<li>其他线程持有锁：获取锁失败，返回：false；</li>\n</ul>\n<p><strong>4）tryLock(long timeout, TimeUnit unit)</strong></p>\n<p>逻辑和 tryLock() 差不多，只是这个方法是带时间的。</p>\n<p><strong>5）unlock()</strong></p>\n<p>释放锁，每次锁持有者数量递减 1，直到 0 为止。所以，现在知道为什么 lock 多少次，就要对应 unlock 多少次了吧。</p>\n<p><strong>6）newCondition</strong></p>\n<p>返回一个这个锁的 Condition 实例，可以实现 synchronized 关键字类似 wait&#x2F; notify 实现多线程通信的功能，不过这个比 wait&#x2F; notify 要更灵活，更强大！</p>\n<h4 id=\"重入锁大概的用法\"><a href=\"#重入锁大概的用法\" class=\"headerlink\" title=\"重入锁大概的用法\"></a>重入锁大概的用法</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class X &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  private final ReentrantLock lock = new ReentrantLock();</span><br><span class=\"line\">  </span><br><span class=\"line\">  // ...</span><br><span class=\"line\"></span><br><span class=\"line\">  public void m() &#123;</span><br><span class=\"line\">    lock.lock();  // block until condition holds</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      // ... method body</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">      lock.unlock()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看见没有，加锁和释放锁都在方法里面进行，可以自由控制，比 synchronized 更灵活，更方便。但要注意的是，释放锁操作必须在 finally 里面，不然如果出现异常导致锁不能被正常释放，进而会卡死后续所有访问该锁的线程。</p>\n<h4 id=\"synchronized-是重入锁吗？\"><a href=\"#synchronized-是重入锁吗？\" class=\"headerlink\" title=\"synchronized 是重入锁吗？\"></a>synchronized 是重入锁吗？</h4><p>那么问题来了，synchronized 是重入锁吗？</p>\n<p>你可能会说不是，因为 ReentrantLock 既然是重入锁，根据推理，相反，那 synchronized 肯定就不是重入锁，那你就错了。</p>\n<p>答案是：yes，为什么？看下面的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public synchronized void operation()&#123;</span><br><span class=\"line\">    add();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public synchronized void add()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>operation 方法调用了 add 方法，两个方法都是用 synchronized 修饰的，add()  方法可以成功获取当前线程 operation() 方法已经获取到的锁，说明 synchronized 就是可重入锁。</p>\n<p>面试常问的Synchronized的几种用法推荐看下这篇文章：<a href=\"https://mp.weixin.qq.com/s/9h6VjHAmLA3twD6Y-FqfwA\">Synchronized 有几种用法？</a>。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>今天，重入锁就大概写到这里了，其实重入锁就是一种颗粒度更小的锁，控制更方便，更强大，栈长只是简单介绍一下重入锁的基本概念及用法，但远不止这么简单，还有很多，一篇也难也详尽，够写好多篇了。</p>\n<p>大家也可以关注，栈长将继续分享更多重入锁的高级的概念及工作中的实战用法，请关注后续文章，或者在公众号后台回复：多线程，栈长已经整理好了许多 Java 多线程系列文章，都是接地气干货。</p>\n<p>觉得有用，转发分享下朋友圈给更多的人看吧，另外，给个好看，谢谢老板~</p>\n<p>本文原创首发于（id:javastack），转载请原样保留本信息。</p>\n","excerpt":"","more":"<h4 id=\"什么是重入锁\"><a href=\"#什么是重入锁\" class=\"headerlink\" title=\"什么是重入锁\"></a>什么是重入锁</h4><blockquote>\n<p>java.util.concurrent.locks.ReentrantLock</p>\n</blockquote>\n<p>这个是 JDK @since 1.5 添加的一种颗粒度更小的锁，它完全可以替代 synchronized 关键字来实现它的所有功能，而且 ReentrantLock 锁的灵活度要远远大于 synchronized 关键字。</p>\n<p><img src=\"http://img.javastack.cn/ReentrantLock.png\"></p>\n<p>从类结构图看出，ReentrantLock 实现了 Lock 接口，ReentrantLock 只是 Lock 接口的一个实现而已。</p>\n<blockquote>\n<p>java.util.concurrent.locks.Lock</p>\n</blockquote>\n<p>它们都是 java.util.concurrent 包里面的内容（俗称 JUC、并发包），也都是 JDK 1.5 开始加入的。</p>\n<h4 id=\"为什么叫重入锁呢？\"><a href=\"#为什么叫重入锁呢？\" class=\"headerlink\" title=\"为什么叫重入锁呢？\"></a>为什么叫重入锁呢？</h4><p>ReentrantLock，我们把它拆开来看就明了了。</p>\n<p>Re-Entrant-Lock：即表示可重新反复进入的锁，但仅限于当前线程；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void m() &#123;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      // ... method body</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">      lock.unlock()</span><br><span class=\"line\">      lock.unlock()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如示例代码所示，当前线程可以反复加锁，但也需要释放同样加锁次数的锁，即重入了多少次，就要释放多少次，不然也会导入锁不被释放。</p>\n<p>试想一下，如果不设计成可重入锁，那自己如果反复给自己加锁，不是会把自己加死锁了吗？所以，到现在，重入锁的概念大概应该清楚了吧？</p>\n<h4 id=\"重入锁最重要的几个方法\"><a href=\"#重入锁最重要的几个方法\" class=\"headerlink\" title=\"重入锁最重要的几个方法\"></a>重入锁最重要的几个方法</h4><p>这几个方法都是 Lock 接口中定义的：</p>\n<p><img src=\"http://img.javastack.cn/Lock.png\"></p>\n<p><strong>1）lock()</strong></p>\n<p>获取锁，有以下三种情况：</p>\n<ul>\n<li>锁空闲：直接获取锁并返回，同时设置锁持有者数量为：1；</li>\n<li>当前线程持有锁：直接获取锁并返回，同时锁持有者数量递增1；</li>\n<li>其他线程持有锁：当前线程会休眠等待，直至获取锁为止；</li>\n</ul>\n<p><strong>2）lockInterruptibly()</strong></p>\n<p>获取锁，逻辑和 lock() 方法一样，但这个方法在获取锁过程中能响应中断。</p>\n<p><strong>3）tryLock()</strong></p>\n<p>从关键字字面理解，这是在尝试获取锁，获取成功返回：true，获取失败返回：false, 这个方法不会等待，有以下三种情况：</p>\n<ul>\n<li>锁空闲：直接获取锁并返回：true，同时设置锁持有者数量为：1；</li>\n<li>当前线程持有锁：直接获取锁并返回：true，同时锁持有者数量递增1；</li>\n<li>其他线程持有锁：获取锁失败，返回：false；</li>\n</ul>\n<p><strong>4）tryLock(long timeout, TimeUnit unit)</strong></p>\n<p>逻辑和 tryLock() 差不多，只是这个方法是带时间的。</p>\n<p><strong>5）unlock()</strong></p>\n<p>释放锁，每次锁持有者数量递减 1，直到 0 为止。所以，现在知道为什么 lock 多少次，就要对应 unlock 多少次了吧。</p>\n<p><strong>6）newCondition</strong></p>\n<p>返回一个这个锁的 Condition 实例，可以实现 synchronized 关键字类似 wait&#x2F; notify 实现多线程通信的功能，不过这个比 wait&#x2F; notify 要更灵活，更强大！</p>\n<h4 id=\"重入锁大概的用法\"><a href=\"#重入锁大概的用法\" class=\"headerlink\" title=\"重入锁大概的用法\"></a>重入锁大概的用法</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class X &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  private final ReentrantLock lock = new ReentrantLock();</span><br><span class=\"line\">  </span><br><span class=\"line\">  // ...</span><br><span class=\"line\"></span><br><span class=\"line\">  public void m() &#123;</span><br><span class=\"line\">    lock.lock();  // block until condition holds</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      // ... method body</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">      lock.unlock()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看见没有，加锁和释放锁都在方法里面进行，可以自由控制，比 synchronized 更灵活，更方便。但要注意的是，释放锁操作必须在 finally 里面，不然如果出现异常导致锁不能被正常释放，进而会卡死后续所有访问该锁的线程。</p>\n<h4 id=\"synchronized-是重入锁吗？\"><a href=\"#synchronized-是重入锁吗？\" class=\"headerlink\" title=\"synchronized 是重入锁吗？\"></a>synchronized 是重入锁吗？</h4><p>那么问题来了，synchronized 是重入锁吗？</p>\n<p>你可能会说不是，因为 ReentrantLock 既然是重入锁，根据推理，相反，那 synchronized 肯定就不是重入锁，那你就错了。</p>\n<p>答案是：yes，为什么？看下面的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public synchronized void operation()&#123;</span><br><span class=\"line\">    add();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public synchronized void add()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>operation 方法调用了 add 方法，两个方法都是用 synchronized 修饰的，add()  方法可以成功获取当前线程 operation() 方法已经获取到的锁，说明 synchronized 就是可重入锁。</p>\n<p>面试常问的Synchronized的几种用法推荐看下这篇文章：<a href=\"https://mp.weixin.qq.com/s/9h6VjHAmLA3twD6Y-FqfwA\">Synchronized 有几种用法？</a>。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>今天，重入锁就大概写到这里了，其实重入锁就是一种颗粒度更小的锁，控制更方便，更强大，栈长只是简单介绍一下重入锁的基本概念及用法，但远不止这么简单，还有很多，一篇也难也详尽，够写好多篇了。</p>\n<p>大家也可以关注，栈长将继续分享更多重入锁的高级的概念及工作中的实战用法，请关注后续文章，或者在公众号后台回复：多线程，栈长已经整理好了许多 Java 多线程系列文章，都是接地气干货。</p>\n<p>觉得有用，转发分享下朋友圈给更多的人看吧，另外，给个好看，谢谢老板~</p>\n<p>本文原创首发于（id:javastack），转载请原样保留本信息。</p>\n"},{"title":"多线程 start 和 run 方法到底有什么区别？","date":"2025-10-14T06:42:34.000Z","_content":"\n**首先要知道实现多线程最基本的两种方式：**\n\n1、继承 `java.lang.Thread` 类；\n\n2、实现 `java.lang.Runnable`接口；\n\n其中 Thread 类也是实现了 Runnable 接口，而 Runnable 接口定义了唯一的一个 run() 方法，所以基于 Thread 和 Runnable 创建多线程都需要实现 run() 方法，是多线程真正运行的主方法。\n\n```\n@FunctionalInterface\npublic interface Runnable {\n    public abstract void run();\n}\n```\n\n而 start() 方法则是 Thread 类的方法，用来异步启动一个线程，然后主线程立刻返回。该启动的线程不会马上运行，会放到等待队列中等待 CPU 调度，只有线程真正被 CPU 调度时才会调用 run() 方法执行。\n\n所以 start() 方法只是标识线程为就绪状态的一个附加方法，以下 start() 方法的源码，其中 start0() 是一个本地 native 方法。\n\n```\npublic synchronized void start() {\n    if (threadStatus != 0)\n        throw new IllegalThreadStateException();\n\n    group.add(this);\n\n    boolean started = false;\n    try {\n        start0();\n        started = true;\n    } finally {\n        try {\n            if (!started) {\n                group.threadStartFailed(this);\n            }\n        } catch (Throwable ignore) {\n            /* do nothing. If start0 threw a Throwable then\n              it will be passed up the call stack */\n        }\n    }\n}\n```\n\n请注意，start() 方法被标识为 synchronized 的，即为了防止被多次启动的一个同步操作。\n\n**那么你会问了，为什么要有两个方法，直接用一个 run() 方法不就行了吗！？** 还真不行，如果直接调用 run() 方法，那就等于调用了一个普通的同步方法，达不到多线程运行的异步执行，来看下面的例子。\n\n```\n/**\n * \n */\npublic static void main(String[] args) {\n\tThread thread = new Thread(() -> {\n\t\ttry {\n\t\t\tThread.sleep(3000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(\"Java技术\");\n\t});\n\n\tlong start = System.currentTimeMillis();\n\tthread.start();\n\tSystem.out.println(System.currentTimeMillis() - start);\n\n\tstart = System.currentTimeMillis();\n\tthread.run();\n\tSystem.out.println(System.currentTimeMillis() - start);\n}\n\n```\n\n程序输出：\n\n```\n0\nJava技术\n3000\nJava技术\n```\n\n从程序输出结果可以看出，启动 start 方法前后只用了 0 毫秒，而启动 run 方法则阻塞了 3000 毫秒等程序执行完再继续执行，这就是同步与异步的一个最重要的区别。\n\n看完这篇，你应该对 start 和 run 方法有了一个大概的掌握吧，再也不怕面试官问你这两个的区别了吧！\n\n动手转发给更多的朋友吧！\n\n\n","source":"_posts/多线程 start 和 run 方法到底有什么区别？.md","raw":"---\ntitle: 多线程 start 和 run 方法到底有什么区别？\ndate: 2025-10-14 14:42:34\ntags: 多线程\n---\n\n**首先要知道实现多线程最基本的两种方式：**\n\n1、继承 `java.lang.Thread` 类；\n\n2、实现 `java.lang.Runnable`接口；\n\n其中 Thread 类也是实现了 Runnable 接口，而 Runnable 接口定义了唯一的一个 run() 方法，所以基于 Thread 和 Runnable 创建多线程都需要实现 run() 方法，是多线程真正运行的主方法。\n\n```\n@FunctionalInterface\npublic interface Runnable {\n    public abstract void run();\n}\n```\n\n而 start() 方法则是 Thread 类的方法，用来异步启动一个线程，然后主线程立刻返回。该启动的线程不会马上运行，会放到等待队列中等待 CPU 调度，只有线程真正被 CPU 调度时才会调用 run() 方法执行。\n\n所以 start() 方法只是标识线程为就绪状态的一个附加方法，以下 start() 方法的源码，其中 start0() 是一个本地 native 方法。\n\n```\npublic synchronized void start() {\n    if (threadStatus != 0)\n        throw new IllegalThreadStateException();\n\n    group.add(this);\n\n    boolean started = false;\n    try {\n        start0();\n        started = true;\n    } finally {\n        try {\n            if (!started) {\n                group.threadStartFailed(this);\n            }\n        } catch (Throwable ignore) {\n            /* do nothing. If start0 threw a Throwable then\n              it will be passed up the call stack */\n        }\n    }\n}\n```\n\n请注意，start() 方法被标识为 synchronized 的，即为了防止被多次启动的一个同步操作。\n\n**那么你会问了，为什么要有两个方法，直接用一个 run() 方法不就行了吗！？** 还真不行，如果直接调用 run() 方法，那就等于调用了一个普通的同步方法，达不到多线程运行的异步执行，来看下面的例子。\n\n```\n/**\n * \n */\npublic static void main(String[] args) {\n\tThread thread = new Thread(() -> {\n\t\ttry {\n\t\t\tThread.sleep(3000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(\"Java技术\");\n\t});\n\n\tlong start = System.currentTimeMillis();\n\tthread.start();\n\tSystem.out.println(System.currentTimeMillis() - start);\n\n\tstart = System.currentTimeMillis();\n\tthread.run();\n\tSystem.out.println(System.currentTimeMillis() - start);\n}\n\n```\n\n程序输出：\n\n```\n0\nJava技术\n3000\nJava技术\n```\n\n从程序输出结果可以看出，启动 start 方法前后只用了 0 毫秒，而启动 run 方法则阻塞了 3000 毫秒等程序执行完再继续执行，这就是同步与异步的一个最重要的区别。\n\n看完这篇，你应该对 start 和 run 方法有了一个大概的掌握吧，再也不怕面试官问你这两个的区别了吧！\n\n动手转发给更多的朋友吧！\n\n\n","slug":"多线程 start 和 run 方法到底有什么区别？","published":1,"updated":"2025-10-14T07:16:33.062Z","_id":"cmgq7876m000ahod4h9kugyu3","comments":1,"layout":"post","photos":[],"content":"<p><strong>首先要知道实现多线程最基本的两种方式：</strong></p>\n<p>1、继承 <code>java.lang.Thread</code> 类；</p>\n<p>2、实现 <code>java.lang.Runnable</code>接口；</p>\n<p>其中 Thread 类也是实现了 Runnable 接口，而 Runnable 接口定义了唯一的一个 run() 方法，所以基于 Thread 和 Runnable 创建多线程都需要实现 run() 方法，是多线程真正运行的主方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\">public interface Runnable &#123;</span><br><span class=\"line\">    public abstract void run();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而 start() 方法则是 Thread 类的方法，用来异步启动一个线程，然后主线程立刻返回。该启动的线程不会马上运行，会放到等待队列中等待 CPU 调度，只有线程真正被 CPU 调度时才会调用 run() 方法执行。</p>\n<p>所以 start() 方法只是标识线程为就绪状态的一个附加方法，以下 start() 方法的源码，其中 start0() 是一个本地 native 方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public synchronized void start() &#123;</span><br><span class=\"line\">    if (threadStatus != 0)</span><br><span class=\"line\">        throw new IllegalThreadStateException();</span><br><span class=\"line\"></span><br><span class=\"line\">    group.add(this);</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean started = false;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        start0();</span><br><span class=\"line\">        started = true;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            if (!started) &#123;</span><br><span class=\"line\">                group.threadStartFailed(this);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (Throwable ignore) &#123;</span><br><span class=\"line\">            /* do nothing. If start0 threw a Throwable then</span><br><span class=\"line\">              it will be passed up the call stack */</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意，start() 方法被标识为 synchronized 的，即为了防止被多次启动的一个同步操作。</p>\n<p><strong>那么你会问了，为什么要有两个方法，直接用一个 run() 方法不就行了吗！？</strong> 还真不行，如果直接调用 run() 方法，那就等于调用了一个普通的同步方法，达不到多线程运行的异步执行，来看下面的例子。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\tThread thread = new Thread(() -&gt; &#123;</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tThread.sleep(3000);</span><br><span class=\"line\">\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;Java技术&quot;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tlong start = System.currentTimeMillis();</span><br><span class=\"line\">\tthread.start();</span><br><span class=\"line\">\tSystem.out.println(System.currentTimeMillis() - start);</span><br><span class=\"line\"></span><br><span class=\"line\">\tstart = System.currentTimeMillis();</span><br><span class=\"line\">\tthread.run();</span><br><span class=\"line\">\tSystem.out.println(System.currentTimeMillis() - start);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>程序输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">Java技术</span><br><span class=\"line\">3000</span><br><span class=\"line\">Java技术</span><br></pre></td></tr></table></figure>\n\n<p>从程序输出结果可以看出，启动 start 方法前后只用了 0 毫秒，而启动 run 方法则阻塞了 3000 毫秒等程序执行完再继续执行，这就是同步与异步的一个最重要的区别。</p>\n<p>看完这篇，你应该对 start 和 run 方法有了一个大概的掌握吧，再也不怕面试官问你这两个的区别了吧！</p>\n<p>动手转发给更多的朋友吧！</p>\n","excerpt":"","more":"<p><strong>首先要知道实现多线程最基本的两种方式：</strong></p>\n<p>1、继承 <code>java.lang.Thread</code> 类；</p>\n<p>2、实现 <code>java.lang.Runnable</code>接口；</p>\n<p>其中 Thread 类也是实现了 Runnable 接口，而 Runnable 接口定义了唯一的一个 run() 方法，所以基于 Thread 和 Runnable 创建多线程都需要实现 run() 方法，是多线程真正运行的主方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\">public interface Runnable &#123;</span><br><span class=\"line\">    public abstract void run();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而 start() 方法则是 Thread 类的方法，用来异步启动一个线程，然后主线程立刻返回。该启动的线程不会马上运行，会放到等待队列中等待 CPU 调度，只有线程真正被 CPU 调度时才会调用 run() 方法执行。</p>\n<p>所以 start() 方法只是标识线程为就绪状态的一个附加方法，以下 start() 方法的源码，其中 start0() 是一个本地 native 方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public synchronized void start() &#123;</span><br><span class=\"line\">    if (threadStatus != 0)</span><br><span class=\"line\">        throw new IllegalThreadStateException();</span><br><span class=\"line\"></span><br><span class=\"line\">    group.add(this);</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean started = false;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        start0();</span><br><span class=\"line\">        started = true;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            if (!started) &#123;</span><br><span class=\"line\">                group.threadStartFailed(this);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (Throwable ignore) &#123;</span><br><span class=\"line\">            /* do nothing. If start0 threw a Throwable then</span><br><span class=\"line\">              it will be passed up the call stack */</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意，start() 方法被标识为 synchronized 的，即为了防止被多次启动的一个同步操作。</p>\n<p><strong>那么你会问了，为什么要有两个方法，直接用一个 run() 方法不就行了吗！？</strong> 还真不行，如果直接调用 run() 方法，那就等于调用了一个普通的同步方法，达不到多线程运行的异步执行，来看下面的例子。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\tThread thread = new Thread(() -&gt; &#123;</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tThread.sleep(3000);</span><br><span class=\"line\">\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;Java技术&quot;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tlong start = System.currentTimeMillis();</span><br><span class=\"line\">\tthread.start();</span><br><span class=\"line\">\tSystem.out.println(System.currentTimeMillis() - start);</span><br><span class=\"line\"></span><br><span class=\"line\">\tstart = System.currentTimeMillis();</span><br><span class=\"line\">\tthread.run();</span><br><span class=\"line\">\tSystem.out.println(System.currentTimeMillis() - start);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>程序输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">Java技术</span><br><span class=\"line\">3000</span><br><span class=\"line\">Java技术</span><br></pre></td></tr></table></figure>\n\n<p>从程序输出结果可以看出，启动 start 方法前后只用了 0 毫秒，而启动 run 方法则阻塞了 3000 毫秒等程序执行完再继续执行，这就是同步与异步的一个最重要的区别。</p>\n<p>看完这篇，你应该对 start 和 run 方法有了一个大概的掌握吧，再也不怕面试官问你这两个的区别了吧！</p>\n<p>动手转发给更多的朋友吧！</p>\n"},{"title":"教你如何监控 Java 线程池运行状态","date":"2025-10-14T06:42:34.000Z","_content":"\n\n\n如果你想监控某一个线程池的执行状态，线程池执行类 `ThreadPoolExecutor ` 也给出了相关的 API, 能实时获取线程池的当前活动线程数、正在排队中的线程数、已经执行完成的线程数、总线程数等。\n\n> 总线程数 = 排队线程数 + 活动线程数 +  执行完成的线程数。\n\n下面给出一个线程池使用示例，及教你获取线程池状态。\n\n\n```\nprivate static ExecutorService es = new ThreadPoolExecutor(50, 100, 0L, TimeUnit.MILLISECONDS,\n\t\t\tnew LinkedBlockingQueue<Runnable>(100000));\n\npublic static void main(String[] args) throws Exception {\n\tfor (int i = 0; i < 100000; i++) {\n\t\tes.execute(() -> {\n\t\t\tSystem.out.print(1);\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t});\n\t}\n\n\tThreadPoolExecutor tpe = ((ThreadPoolExecutor) es);\n\n\twhile (true) {\n\t\tSystem.out.println();\n\n\t\tint queueSize = tpe.getQueue().size();\n\t\tSystem.out.println(\"当前排队线程数：\" + queueSize);\n\n\t\tint activeCount = tpe.getActiveCount();\n\t\tSystem.out.println(\"当前活动线程数：\" + activeCount);\n\n\t\tlong completedTaskCount = tpe.getCompletedTaskCount();\n\t\tSystem.out.println(\"执行完成线程数：\" + completedTaskCount);\n\n\t\tlong taskCount = tpe.getTaskCount();\n\t\tSystem.out.println(\"总线程数：\" + taskCount);\n\n\t\tThread.sleep(3000);\n\t}\n\n}\n```\n\n线程池提交了 100000 个任务，但同时只有 50 个线程在执行工作，我们每陋 3 秒来获取当前线程池的运行状态。\n\n第一次程序输出：\n\n```\n当前排队线程数：99950\n当前活动线程数：50\n执行完成线程数：0\n总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000\n```\n\n第二次程序输出：\n\n```\n当前排队线程数：99800\n当前活动线程数：50\n执行完成线程数：150\n总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000\n```\n\n活动线程数和总线程数是不变的，排队中的线程数和执行完成的线程数不断在变化，直到所有任务执行完毕，最后输出：\n\n```\n当前排队线程数：0\n当前活动线程数：0\n执行完成线程数：100000\n总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000\n```\n\n这样，你了解了这些 API 的使用方法，你想监控线程池的状态就非常方便了。\n\n","source":"_posts/教你如何监控 Java 线程池运行状态.md","raw":"---\ntitle: 教你如何监控 Java 线程池运行状态\ndate: 2025-10-14 14:42:34\ntags: 多线程\n---\n\n\n\n如果你想监控某一个线程池的执行状态，线程池执行类 `ThreadPoolExecutor ` 也给出了相关的 API, 能实时获取线程池的当前活动线程数、正在排队中的线程数、已经执行完成的线程数、总线程数等。\n\n> 总线程数 = 排队线程数 + 活动线程数 +  执行完成的线程数。\n\n下面给出一个线程池使用示例，及教你获取线程池状态。\n\n\n```\nprivate static ExecutorService es = new ThreadPoolExecutor(50, 100, 0L, TimeUnit.MILLISECONDS,\n\t\t\tnew LinkedBlockingQueue<Runnable>(100000));\n\npublic static void main(String[] args) throws Exception {\n\tfor (int i = 0; i < 100000; i++) {\n\t\tes.execute(() -> {\n\t\t\tSystem.out.print(1);\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t});\n\t}\n\n\tThreadPoolExecutor tpe = ((ThreadPoolExecutor) es);\n\n\twhile (true) {\n\t\tSystem.out.println();\n\n\t\tint queueSize = tpe.getQueue().size();\n\t\tSystem.out.println(\"当前排队线程数：\" + queueSize);\n\n\t\tint activeCount = tpe.getActiveCount();\n\t\tSystem.out.println(\"当前活动线程数：\" + activeCount);\n\n\t\tlong completedTaskCount = tpe.getCompletedTaskCount();\n\t\tSystem.out.println(\"执行完成线程数：\" + completedTaskCount);\n\n\t\tlong taskCount = tpe.getTaskCount();\n\t\tSystem.out.println(\"总线程数：\" + taskCount);\n\n\t\tThread.sleep(3000);\n\t}\n\n}\n```\n\n线程池提交了 100000 个任务，但同时只有 50 个线程在执行工作，我们每陋 3 秒来获取当前线程池的运行状态。\n\n第一次程序输出：\n\n```\n当前排队线程数：99950\n当前活动线程数：50\n执行完成线程数：0\n总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000\n```\n\n第二次程序输出：\n\n```\n当前排队线程数：99800\n当前活动线程数：50\n执行完成线程数：150\n总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000\n```\n\n活动线程数和总线程数是不变的，排队中的线程数和执行完成的线程数不断在变化，直到所有任务执行完毕，最后输出：\n\n```\n当前排队线程数：0\n当前活动线程数：0\n执行完成线程数：100000\n总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000\n```\n\n这样，你了解了这些 API 的使用方法，你想监控线程池的状态就非常方便了。\n\n","slug":"教你如何监控 Java 线程池运行状态","published":1,"updated":"2025-10-14T07:16:33.084Z","_id":"cmgq78772000bhod458d1c2xw","comments":1,"layout":"post","photos":[],"content":"<p>如果你想监控某一个线程池的执行状态，线程池执行类 <code>ThreadPoolExecutor </code> 也给出了相关的 API, 能实时获取线程池的当前活动线程数、正在排队中的线程数、已经执行完成的线程数、总线程数等。</p>\n<blockquote>\n<p>总线程数 &#x3D; 排队线程数 + 活动线程数 +  执行完成的线程数。</p>\n</blockquote>\n<p>下面给出一个线程池使用示例，及教你获取线程池状态。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static ExecutorService es = new ThreadPoolExecutor(50, 100, 0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">\t\t\tnew LinkedBlockingQueue&lt;Runnable&gt;(100000));</span><br><span class=\"line\"></span><br><span class=\"line\">public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\tfor (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class=\"line\">\t\tes.execute(() -&gt; &#123;</span><br><span class=\"line\">\t\t\tSystem.out.print(1);</span><br><span class=\"line\">\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\tThread.sleep(1000);</span><br><span class=\"line\">\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tThreadPoolExecutor tpe = ((ThreadPoolExecutor) es);</span><br><span class=\"line\"></span><br><span class=\"line\">\twhile (true) &#123;</span><br><span class=\"line\">\t\tSystem.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tint queueSize = tpe.getQueue().size();</span><br><span class=\"line\">\t\tSystem.out.println(&quot;当前排队线程数：&quot; + queueSize);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tint activeCount = tpe.getActiveCount();</span><br><span class=\"line\">\t\tSystem.out.println(&quot;当前活动线程数：&quot; + activeCount);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tlong completedTaskCount = tpe.getCompletedTaskCount();</span><br><span class=\"line\">\t\tSystem.out.println(&quot;执行完成线程数：&quot; + completedTaskCount);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tlong taskCount = tpe.getTaskCount();</span><br><span class=\"line\">\t\tSystem.out.println(&quot;总线程数：&quot; + taskCount);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tThread.sleep(3000);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>线程池提交了 100000 个任务，但同时只有 50 个线程在执行工作，我们每陋 3 秒来获取当前线程池的运行状态。</p>\n<p>第一次程序输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当前排队线程数：99950</span><br><span class=\"line\">当前活动线程数：50</span><br><span class=\"line\">执行完成线程数：0</span><br><span class=\"line\">总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000</span><br></pre></td></tr></table></figure>\n\n<p>第二次程序输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当前排队线程数：99800</span><br><span class=\"line\">当前活动线程数：50</span><br><span class=\"line\">执行完成线程数：150</span><br><span class=\"line\">总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000</span><br></pre></td></tr></table></figure>\n\n<p>活动线程数和总线程数是不变的，排队中的线程数和执行完成的线程数不断在变化，直到所有任务执行完毕，最后输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当前排队线程数：0</span><br><span class=\"line\">当前活动线程数：0</span><br><span class=\"line\">执行完成线程数：100000</span><br><span class=\"line\">总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000</span><br></pre></td></tr></table></figure>\n\n<p>这样，你了解了这些 API 的使用方法，你想监控线程池的状态就非常方便了。</p>\n","excerpt":"","more":"<p>如果你想监控某一个线程池的执行状态，线程池执行类 <code>ThreadPoolExecutor </code> 也给出了相关的 API, 能实时获取线程池的当前活动线程数、正在排队中的线程数、已经执行完成的线程数、总线程数等。</p>\n<blockquote>\n<p>总线程数 &#x3D; 排队线程数 + 活动线程数 +  执行完成的线程数。</p>\n</blockquote>\n<p>下面给出一个线程池使用示例，及教你获取线程池状态。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static ExecutorService es = new ThreadPoolExecutor(50, 100, 0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">\t\t\tnew LinkedBlockingQueue&lt;Runnable&gt;(100000));</span><br><span class=\"line\"></span><br><span class=\"line\">public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\tfor (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class=\"line\">\t\tes.execute(() -&gt; &#123;</span><br><span class=\"line\">\t\t\tSystem.out.print(1);</span><br><span class=\"line\">\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\tThread.sleep(1000);</span><br><span class=\"line\">\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tThreadPoolExecutor tpe = ((ThreadPoolExecutor) es);</span><br><span class=\"line\"></span><br><span class=\"line\">\twhile (true) &#123;</span><br><span class=\"line\">\t\tSystem.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tint queueSize = tpe.getQueue().size();</span><br><span class=\"line\">\t\tSystem.out.println(&quot;当前排队线程数：&quot; + queueSize);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tint activeCount = tpe.getActiveCount();</span><br><span class=\"line\">\t\tSystem.out.println(&quot;当前活动线程数：&quot; + activeCount);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tlong completedTaskCount = tpe.getCompletedTaskCount();</span><br><span class=\"line\">\t\tSystem.out.println(&quot;执行完成线程数：&quot; + completedTaskCount);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tlong taskCount = tpe.getTaskCount();</span><br><span class=\"line\">\t\tSystem.out.println(&quot;总线程数：&quot; + taskCount);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tThread.sleep(3000);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>线程池提交了 100000 个任务，但同时只有 50 个线程在执行工作，我们每陋 3 秒来获取当前线程池的运行状态。</p>\n<p>第一次程序输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当前排队线程数：99950</span><br><span class=\"line\">当前活动线程数：50</span><br><span class=\"line\">执行完成线程数：0</span><br><span class=\"line\">总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000</span><br></pre></td></tr></table></figure>\n\n<p>第二次程序输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当前排队线程数：99800</span><br><span class=\"line\">当前活动线程数：50</span><br><span class=\"line\">执行完成线程数：150</span><br><span class=\"line\">总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000</span><br></pre></td></tr></table></figure>\n\n<p>活动线程数和总线程数是不变的，排队中的线程数和执行完成的线程数不断在变化，直到所有任务执行完毕，最后输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当前排队线程数：0</span><br><span class=\"line\">当前活动线程数：0</span><br><span class=\"line\">执行完成线程数：100000</span><br><span class=\"line\">总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000</span><br></pre></td></tr></table></figure>\n\n<p>这样，你了解了这些 API 的使用方法，你想监控线程池的状态就非常方便了。</p>\n"},{"title":"多线程 Thread.yield 方法到底有什么用？","date":"2025-10-14T06:42:34.000Z","_content":"\n## 概念\n\n我们知道 start() 方法是启动线程，让线程变成就绪状态等待 CPU 调度后执行。\n\n那 yield() 方法是干什么用的呢？来看下源码。\n\n```\n/**\n * A hint to the scheduler that the current thread is willing to yield\n * its current use of a processor. The scheduler is free to ignore this\n * hint.\n *\n * <p> Yield is a heuristic attempt to improve relative progression\n * between threads that would otherwise over-utilise a CPU. Its use\n * should be combined with detailed profiling and benchmarking to\n * ensure that it actually has the desired effect.\n *\n * <p> It is rarely appropriate to use this method. It may be useful\n * for debugging or testing purposes, where it may help to reproduce\n * bugs due to race conditions. It may also be useful when designing\n * concurrency control constructs such as the ones in the\n * {@link java.util.concurrent.locks} package.\n */\npublic static native void yield();\n```\n\nyield 即 \"谦让\"，也是 Thread 类的方法。它让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。它可能会获取到，也有可能被其他线程获取到。\n\n## 实战\n\n下面是一个使用示例。\n\n```\n/**\n * \n */\npublic static void main(String[] args) {\n\tRunnable runnable = () -> {\n\t\tfor (int i = 0; i <= 100; i++) {\n\t\t\tSystem.out.println(Thread.currentThread().getName() + \"-----\" + i);\n\t\t\tif (i % 20 == 0) {\n\t\t\t\tThread.yield();\n\t\t\t}\n\t\t}\n\t};\n\tnew Thread(runnable, \"栈长\").start();\n    new Thread(runnable, \"小蜜\").start();\n}\n```\n\n这个示例每当执行完 20 个之后就让出 CPU，每次谦让后就会马上获取到调度权继续执行。\n\n**运行以上程序，可以有以下两种结果。**\n\n结果1：栈长让出了 CPU 资源，小蜜成功上位。\n\n```\n栈长-----29\n栈长-----30\n小蜜-----26\n栈长-----31\n```\n\n结果2：栈长让出了 CPU 资源，栈长继续运行。\n\n```\n栈长-----28\n栈长-----29\n栈长-----30\n栈长-----31\n```\n\n而如果我们把两个线程加上线程优先级，那输出的结果又不一样。\n\n```\nthread1.setPriority(Thread.MIN_PRIORITY);\nthread2.setPriority(Thread.MAX_PRIORITY);\n```\n\n因为给小蜜加了最高优先权，栈长加了最低优先权，即使栈长先启动，那小蜜还是有很大的概率比栈长先会输出完的，大家可以试一下。\n\n## yield 和 sleep 的异同\n\n1）yield, sleep 都能暂停当前线程，sleep 可以指定具体休眠的时间，而 yield 则依赖 CPU 的时间片划分。\n\n2）yield, sleep 两个在暂停过程中，如已经持有锁，则都不会释放锁资源。\n\n3）yield 不能被中断，而 sleep 则可以接受中断。\n\n## 总结 \n\n栈长没用过 yield，感觉没什么鸟用。\n\n如果一定要用它的话，一句话解释就是：yield 方法可以很好的控制多线程，如执行某项复杂的任务时，如果担心占用资源过多，可以在完成某个重要的工作后使用 yield 方法让掉当前 CPU 的调度权，等下次获取到再继续执行，这样不但能完成自己的重要工作，也能给其他线程一些运行的机会，避免一个线程长时间占有 CPU 资源。\n\n\n\n","source":"_posts/多线程 Thread.yield 方法到底有什么用？.md","raw":"---\ntitle: 多线程 Thread.yield 方法到底有什么用？\ndate: 2025-10-14 14:42:34\ntags: 多线程\n---\n\n## 概念\n\n我们知道 start() 方法是启动线程，让线程变成就绪状态等待 CPU 调度后执行。\n\n那 yield() 方法是干什么用的呢？来看下源码。\n\n```\n/**\n * A hint to the scheduler that the current thread is willing to yield\n * its current use of a processor. The scheduler is free to ignore this\n * hint.\n *\n * <p> Yield is a heuristic attempt to improve relative progression\n * between threads that would otherwise over-utilise a CPU. Its use\n * should be combined with detailed profiling and benchmarking to\n * ensure that it actually has the desired effect.\n *\n * <p> It is rarely appropriate to use this method. It may be useful\n * for debugging or testing purposes, where it may help to reproduce\n * bugs due to race conditions. It may also be useful when designing\n * concurrency control constructs such as the ones in the\n * {@link java.util.concurrent.locks} package.\n */\npublic static native void yield();\n```\n\nyield 即 \"谦让\"，也是 Thread 类的方法。它让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。它可能会获取到，也有可能被其他线程获取到。\n\n## 实战\n\n下面是一个使用示例。\n\n```\n/**\n * \n */\npublic static void main(String[] args) {\n\tRunnable runnable = () -> {\n\t\tfor (int i = 0; i <= 100; i++) {\n\t\t\tSystem.out.println(Thread.currentThread().getName() + \"-----\" + i);\n\t\t\tif (i % 20 == 0) {\n\t\t\t\tThread.yield();\n\t\t\t}\n\t\t}\n\t};\n\tnew Thread(runnable, \"栈长\").start();\n    new Thread(runnable, \"小蜜\").start();\n}\n```\n\n这个示例每当执行完 20 个之后就让出 CPU，每次谦让后就会马上获取到调度权继续执行。\n\n**运行以上程序，可以有以下两种结果。**\n\n结果1：栈长让出了 CPU 资源，小蜜成功上位。\n\n```\n栈长-----29\n栈长-----30\n小蜜-----26\n栈长-----31\n```\n\n结果2：栈长让出了 CPU 资源，栈长继续运行。\n\n```\n栈长-----28\n栈长-----29\n栈长-----30\n栈长-----31\n```\n\n而如果我们把两个线程加上线程优先级，那输出的结果又不一样。\n\n```\nthread1.setPriority(Thread.MIN_PRIORITY);\nthread2.setPriority(Thread.MAX_PRIORITY);\n```\n\n因为给小蜜加了最高优先权，栈长加了最低优先权，即使栈长先启动，那小蜜还是有很大的概率比栈长先会输出完的，大家可以试一下。\n\n## yield 和 sleep 的异同\n\n1）yield, sleep 都能暂停当前线程，sleep 可以指定具体休眠的时间，而 yield 则依赖 CPU 的时间片划分。\n\n2）yield, sleep 两个在暂停过程中，如已经持有锁，则都不会释放锁资源。\n\n3）yield 不能被中断，而 sleep 则可以接受中断。\n\n## 总结 \n\n栈长没用过 yield，感觉没什么鸟用。\n\n如果一定要用它的话，一句话解释就是：yield 方法可以很好的控制多线程，如执行某项复杂的任务时，如果担心占用资源过多，可以在完成某个重要的工作后使用 yield 方法让掉当前 CPU 的调度权，等下次获取到再继续执行，这样不但能完成自己的重要工作，也能给其他线程一些运行的机会，避免一个线程长时间占有 CPU 资源。\n\n\n\n","slug":"多线程 Thread.yield 方法到底有什么用？","published":1,"updated":"2025-10-14T07:16:33.106Z","_id":"cmgq78773000chod4e34z6o5q","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>我们知道 start() 方法是启动线程，让线程变成就绪状态等待 CPU 调度后执行。</p>\n<p>那 yield() 方法是干什么用的呢？来看下源码。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * A hint to the scheduler that the current thread is willing to yield</span><br><span class=\"line\"> * its current use of a processor. The scheduler is free to ignore this</span><br><span class=\"line\"> * hint.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * &lt;p&gt; Yield is a heuristic attempt to improve relative progression</span><br><span class=\"line\"> * between threads that would otherwise over-utilise a CPU. Its use</span><br><span class=\"line\"> * should be combined with detailed profiling and benchmarking to</span><br><span class=\"line\"> * ensure that it actually has the desired effect.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * &lt;p&gt; It is rarely appropriate to use this method. It may be useful</span><br><span class=\"line\"> * for debugging or testing purposes, where it may help to reproduce</span><br><span class=\"line\"> * bugs due to race conditions. It may also be useful when designing</span><br><span class=\"line\"> * concurrency control constructs such as the ones in the</span><br><span class=\"line\"> * &#123;@link java.util.concurrent.locks&#125; package.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static native void yield();</span><br></pre></td></tr></table></figure>\n\n<p>yield 即 “谦让”，也是 Thread 类的方法。它让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。它可能会获取到，也有可能被其他线程获取到。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><p>下面是一个使用示例。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\tRunnable runnable = () -&gt; &#123;</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt;= 100; i++) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot;-----&quot; + i);</span><br><span class=\"line\">\t\t\tif (i % 20 == 0) &#123;</span><br><span class=\"line\">\t\t\t\tThread.yield();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tnew Thread(runnable, &quot;栈长&quot;).start();</span><br><span class=\"line\">    new Thread(runnable, &quot;小蜜&quot;).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个示例每当执行完 20 个之后就让出 CPU，每次谦让后就会马上获取到调度权继续执行。</p>\n<p><strong>运行以上程序，可以有以下两种结果。</strong></p>\n<p>结果1：栈长让出了 CPU 资源，小蜜成功上位。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">栈长-----29</span><br><span class=\"line\">栈长-----30</span><br><span class=\"line\">小蜜-----26</span><br><span class=\"line\">栈长-----31</span><br></pre></td></tr></table></figure>\n\n<p>结果2：栈长让出了 CPU 资源，栈长继续运行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">栈长-----28</span><br><span class=\"line\">栈长-----29</span><br><span class=\"line\">栈长-----30</span><br><span class=\"line\">栈长-----31</span><br></pre></td></tr></table></figure>\n\n<p>而如果我们把两个线程加上线程优先级，那输出的结果又不一样。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">thread1.setPriority(Thread.MIN_PRIORITY);</span><br><span class=\"line\">thread2.setPriority(Thread.MAX_PRIORITY);</span><br></pre></td></tr></table></figure>\n\n<p>因为给小蜜加了最高优先权，栈长加了最低优先权，即使栈长先启动，那小蜜还是有很大的概率比栈长先会输出完的，大家可以试一下。</p>\n<h2 id=\"yield-和-sleep-的异同\"><a href=\"#yield-和-sleep-的异同\" class=\"headerlink\" title=\"yield 和 sleep 的异同\"></a>yield 和 sleep 的异同</h2><p>1）yield, sleep 都能暂停当前线程，sleep 可以指定具体休眠的时间，而 yield 则依赖 CPU 的时间片划分。</p>\n<p>2）yield, sleep 两个在暂停过程中，如已经持有锁，则都不会释放锁资源。</p>\n<p>3）yield 不能被中断，而 sleep 则可以接受中断。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>栈长没用过 yield，感觉没什么鸟用。</p>\n<p>如果一定要用它的话，一句话解释就是：yield 方法可以很好的控制多线程，如执行某项复杂的任务时，如果担心占用资源过多，可以在完成某个重要的工作后使用 yield 方法让掉当前 CPU 的调度权，等下次获取到再继续执行，这样不但能完成自己的重要工作，也能给其他线程一些运行的机会，避免一个线程长时间占有 CPU 资源。</p>\n","excerpt":"","more":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>我们知道 start() 方法是启动线程，让线程变成就绪状态等待 CPU 调度后执行。</p>\n<p>那 yield() 方法是干什么用的呢？来看下源码。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * A hint to the scheduler that the current thread is willing to yield</span><br><span class=\"line\"> * its current use of a processor. The scheduler is free to ignore this</span><br><span class=\"line\"> * hint.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * &lt;p&gt; Yield is a heuristic attempt to improve relative progression</span><br><span class=\"line\"> * between threads that would otherwise over-utilise a CPU. Its use</span><br><span class=\"line\"> * should be combined with detailed profiling and benchmarking to</span><br><span class=\"line\"> * ensure that it actually has the desired effect.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * &lt;p&gt; It is rarely appropriate to use this method. It may be useful</span><br><span class=\"line\"> * for debugging or testing purposes, where it may help to reproduce</span><br><span class=\"line\"> * bugs due to race conditions. It may also be useful when designing</span><br><span class=\"line\"> * concurrency control constructs such as the ones in the</span><br><span class=\"line\"> * &#123;@link java.util.concurrent.locks&#125; package.</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static native void yield();</span><br></pre></td></tr></table></figure>\n\n<p>yield 即 “谦让”，也是 Thread 类的方法。它让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。它可能会获取到，也有可能被其他线程获取到。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><p>下面是一个使用示例。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\tRunnable runnable = () -&gt; &#123;</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt;= 100; i++) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot;-----&quot; + i);</span><br><span class=\"line\">\t\t\tif (i % 20 == 0) &#123;</span><br><span class=\"line\">\t\t\t\tThread.yield();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tnew Thread(runnable, &quot;栈长&quot;).start();</span><br><span class=\"line\">    new Thread(runnable, &quot;小蜜&quot;).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个示例每当执行完 20 个之后就让出 CPU，每次谦让后就会马上获取到调度权继续执行。</p>\n<p><strong>运行以上程序，可以有以下两种结果。</strong></p>\n<p>结果1：栈长让出了 CPU 资源，小蜜成功上位。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">栈长-----29</span><br><span class=\"line\">栈长-----30</span><br><span class=\"line\">小蜜-----26</span><br><span class=\"line\">栈长-----31</span><br></pre></td></tr></table></figure>\n\n<p>结果2：栈长让出了 CPU 资源，栈长继续运行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">栈长-----28</span><br><span class=\"line\">栈长-----29</span><br><span class=\"line\">栈长-----30</span><br><span class=\"line\">栈长-----31</span><br></pre></td></tr></table></figure>\n\n<p>而如果我们把两个线程加上线程优先级，那输出的结果又不一样。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">thread1.setPriority(Thread.MIN_PRIORITY);</span><br><span class=\"line\">thread2.setPriority(Thread.MAX_PRIORITY);</span><br></pre></td></tr></table></figure>\n\n<p>因为给小蜜加了最高优先权，栈长加了最低优先权，即使栈长先启动，那小蜜还是有很大的概率比栈长先会输出完的，大家可以试一下。</p>\n<h2 id=\"yield-和-sleep-的异同\"><a href=\"#yield-和-sleep-的异同\" class=\"headerlink\" title=\"yield 和 sleep 的异同\"></a>yield 和 sleep 的异同</h2><p>1）yield, sleep 都能暂停当前线程，sleep 可以指定具体休眠的时间，而 yield 则依赖 CPU 的时间片划分。</p>\n<p>2）yield, sleep 两个在暂停过程中，如已经持有锁，则都不会释放锁资源。</p>\n<p>3）yield 不能被中断，而 sleep 则可以接受中断。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>栈长没用过 yield，感觉没什么鸟用。</p>\n<p>如果一定要用它的话，一句话解释就是：yield 方法可以很好的控制多线程，如执行某项复杂的任务时，如果担心占用资源过多，可以在完成某个重要的工作后使用 yield 方法让掉当前 CPU 的调度权，等下次获取到再继续执行，这样不但能完成自己的重要工作，也能给其他线程一些运行的机会，避免一个线程长时间占有 CPU 资源。</p>\n"},{"title":"面试官问线程安全的List，看完再也不怕了！","date":"2025-10-14T06:42:34.000Z","_content":"\n最近在Java技术知识星球里面有球友问到了线程安全的 List：\n\n![](http://img.javastack.cn/20190927184141.png)\n\n扫码查看答案或加入知识星球\n\n栈长在之前的文章《[出场率比较高的一道多线程安全面试题](https://mp.weixin.qq.com/s/oA-uEbzNYA4KYwLtRWXRVw)》里面讲过 ArrayList 的不安全性。\n\n那么面试官会问你，既然 ArrayList 是线程不安全的，怎么保证它的线程安全性呢？或者有什么替代方案？\n\n往下看，看我如何碾压他！\n\n大部分人会脱口而出：用Vector，这样只会让面试官鄙视！除了Vector，你还会别的吗？\n\n你至少还得说得上这种：\n\n> java.util.Collections.SynchronizedList\n\n它能把所有 List 接口的实现类转换成线程安全的List，比 Vector 有更好的扩展性和兼容性，SynchronizedList的构造方法如下：\n\n```\nfinal List<E> list;\n\nSynchronizedList(List<E> list) {\n    super(list);\n    this.list = list;\n}\n```\n\nSynchronizedList的部分方法源码如下：\n\n```\npublic E get(int index) {\n    synchronized (mutex) {return list.get(index);}\n}\npublic E set(int index, E element) {\n    synchronized (mutex) {return list.set(index, element);}\n}\npublic void add(int index, E element) {\n    synchronized (mutex) {list.add(index, element);}\n}\npublic E remove(int index) {\n    synchronized (mutex) {return list.remove(index);}\n}\n```\n\n很可惜，它所有方法都是带同步对象锁的，和 Vector 一样，它不是性能最优的。即使你能说到这里，面试官还会继续往下追问，比如在读多写少的情况，SynchronizedList这种集合性能非常差，还有没有更合适的方案？\n\n介绍两个并发包里面的并发集合类：\n\n> java.util.concurrent.CopyOnWriteArrayList\n> java.util.concurrent.CopyOnWriteArraySet\n\nCopyOnWrite集合类也就这两个，Java 1.5 开始加入，你要能说得上这两个才能让面试官信服。\n\n#### CopyOnWriteArrayList\n\nCopyOnWrite（简称：COW）：即复制再写入，就是在添加元素的时候，先把原 List 列表复制一份，再添加新的元素。\n\n\n先来看下它的 add 方法源码：\n\n```\npublic boolean add(E e) {\n    // 加锁\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        // 获取原始集合\n        Object[] elements = getArray();\n        int len = elements.length;\n        \n        // 复制一个新集合\n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n        newElements[len] = e;\n        \n        // 替换原始集合为新集合\n        setArray(newElements);\n        return true;\n    } finally {\n        // 释放锁\n        lock.unlock();\n    }\n}\n```\n\n添加元素时，先加锁，再进行复制替换操作，最后再释放锁。\n\n再来看下它的 get 方法源码：\n\n```\nprivate E get(Object[] a, int index) {\n    return (E) a[index];\n}\n\npublic E get(int index) {\n    return get(getArray(), index);\n}\n```\n\n可以看到，获取元素并没有加锁。\n\n这样做的好处是，在高并发情况下，读取元素时就不用加锁，写数据时才加锁，大大提升了读取性能。\n\n#### CopyOnWriteArraySet\n\nCopyOnWriteArraySet逻辑就更简单了，就是使用 CopyOnWriteArrayList 的 addIfAbsent 方法来去重的，添加元素的时候判断对象是否已经存在，不存在才添加进集合。\n\n```\n/**\n * Appends the element, if not present.\n *\n * @param e element to be added to this list, if absent\n * @return {@code true} if the element was added\n */\npublic boolean addIfAbsent(E e) {\n    Object[] snapshot = getArray();\n    return indexOf(e, snapshot, 0, snapshot.length) >= 0 ? false :\n        addIfAbsent(e, snapshot);\n}\n```\n\n这两种并发集合，虽然牛逼，但只适合于读多写少的情况，如果写多读少，使用这个就没意义了，因为每次写操作都要进行集合内存复制，性能开销很大，如果集合较大，很容易造成内存溢出。\n\n#### 总结\n\n下次面试官问你线程安全的 List，你可以从 Vector > SynchronizedList > CopyOnWriteArrayList 这样的顺序依次说上来，这样才有带入感，也能体现你对知识点的掌握程度。\n\n看完有没有收获呢？下次面试应该能秒杀面试官了吧！\n\n","source":"_posts/面试官问线程安全的List，看完再也不怕了！.md","raw":"---\ntitle: 面试官问线程安全的List，看完再也不怕了！\ndate: 2025-10-14 14:42:34\ntags: 多线程\n---\n\n最近在Java技术知识星球里面有球友问到了线程安全的 List：\n\n![](http://img.javastack.cn/20190927184141.png)\n\n扫码查看答案或加入知识星球\n\n栈长在之前的文章《[出场率比较高的一道多线程安全面试题](https://mp.weixin.qq.com/s/oA-uEbzNYA4KYwLtRWXRVw)》里面讲过 ArrayList 的不安全性。\n\n那么面试官会问你，既然 ArrayList 是线程不安全的，怎么保证它的线程安全性呢？或者有什么替代方案？\n\n往下看，看我如何碾压他！\n\n大部分人会脱口而出：用Vector，这样只会让面试官鄙视！除了Vector，你还会别的吗？\n\n你至少还得说得上这种：\n\n> java.util.Collections.SynchronizedList\n\n它能把所有 List 接口的实现类转换成线程安全的List，比 Vector 有更好的扩展性和兼容性，SynchronizedList的构造方法如下：\n\n```\nfinal List<E> list;\n\nSynchronizedList(List<E> list) {\n    super(list);\n    this.list = list;\n}\n```\n\nSynchronizedList的部分方法源码如下：\n\n```\npublic E get(int index) {\n    synchronized (mutex) {return list.get(index);}\n}\npublic E set(int index, E element) {\n    synchronized (mutex) {return list.set(index, element);}\n}\npublic void add(int index, E element) {\n    synchronized (mutex) {list.add(index, element);}\n}\npublic E remove(int index) {\n    synchronized (mutex) {return list.remove(index);}\n}\n```\n\n很可惜，它所有方法都是带同步对象锁的，和 Vector 一样，它不是性能最优的。即使你能说到这里，面试官还会继续往下追问，比如在读多写少的情况，SynchronizedList这种集合性能非常差，还有没有更合适的方案？\n\n介绍两个并发包里面的并发集合类：\n\n> java.util.concurrent.CopyOnWriteArrayList\n> java.util.concurrent.CopyOnWriteArraySet\n\nCopyOnWrite集合类也就这两个，Java 1.5 开始加入，你要能说得上这两个才能让面试官信服。\n\n#### CopyOnWriteArrayList\n\nCopyOnWrite（简称：COW）：即复制再写入，就是在添加元素的时候，先把原 List 列表复制一份，再添加新的元素。\n\n\n先来看下它的 add 方法源码：\n\n```\npublic boolean add(E e) {\n    // 加锁\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        // 获取原始集合\n        Object[] elements = getArray();\n        int len = elements.length;\n        \n        // 复制一个新集合\n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n        newElements[len] = e;\n        \n        // 替换原始集合为新集合\n        setArray(newElements);\n        return true;\n    } finally {\n        // 释放锁\n        lock.unlock();\n    }\n}\n```\n\n添加元素时，先加锁，再进行复制替换操作，最后再释放锁。\n\n再来看下它的 get 方法源码：\n\n```\nprivate E get(Object[] a, int index) {\n    return (E) a[index];\n}\n\npublic E get(int index) {\n    return get(getArray(), index);\n}\n```\n\n可以看到，获取元素并没有加锁。\n\n这样做的好处是，在高并发情况下，读取元素时就不用加锁，写数据时才加锁，大大提升了读取性能。\n\n#### CopyOnWriteArraySet\n\nCopyOnWriteArraySet逻辑就更简单了，就是使用 CopyOnWriteArrayList 的 addIfAbsent 方法来去重的，添加元素的时候判断对象是否已经存在，不存在才添加进集合。\n\n```\n/**\n * Appends the element, if not present.\n *\n * @param e element to be added to this list, if absent\n * @return {@code true} if the element was added\n */\npublic boolean addIfAbsent(E e) {\n    Object[] snapshot = getArray();\n    return indexOf(e, snapshot, 0, snapshot.length) >= 0 ? false :\n        addIfAbsent(e, snapshot);\n}\n```\n\n这两种并发集合，虽然牛逼，但只适合于读多写少的情况，如果写多读少，使用这个就没意义了，因为每次写操作都要进行集合内存复制，性能开销很大，如果集合较大，很容易造成内存溢出。\n\n#### 总结\n\n下次面试官问你线程安全的 List，你可以从 Vector > SynchronizedList > CopyOnWriteArrayList 这样的顺序依次说上来，这样才有带入感，也能体现你对知识点的掌握程度。\n\n看完有没有收获呢？下次面试应该能秒杀面试官了吧！\n\n","slug":"面试官问线程安全的List，看完再也不怕了！","published":1,"updated":"2025-10-14T07:16:33.070Z","_id":"cmgq78777000dhod41nzsbryh","comments":1,"layout":"post","photos":[],"content":"<p>最近在Java技术知识星球里面有球友问到了线程安全的 List：</p>\n<p><img src=\"http://img.javastack.cn/20190927184141.png\"></p>\n<p>扫码查看答案或加入知识星球</p>\n<p>栈长在之前的文章《<a href=\"https://mp.weixin.qq.com/s/oA-uEbzNYA4KYwLtRWXRVw\">出场率比较高的一道多线程安全面试题</a>》里面讲过 ArrayList 的不安全性。</p>\n<p>那么面试官会问你，既然 ArrayList 是线程不安全的，怎么保证它的线程安全性呢？或者有什么替代方案？</p>\n<p>往下看，看我如何碾压他！</p>\n<p>大部分人会脱口而出：用Vector，这样只会让面试官鄙视！除了Vector，你还会别的吗？</p>\n<p>你至少还得说得上这种：</p>\n<blockquote>\n<p>java.util.Collections.SynchronizedList</p>\n</blockquote>\n<p>它能把所有 List 接口的实现类转换成线程安全的List，比 Vector 有更好的扩展性和兼容性，SynchronizedList的构造方法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final List&lt;E&gt; list;</span><br><span class=\"line\"></span><br><span class=\"line\">SynchronizedList(List&lt;E&gt; list) &#123;</span><br><span class=\"line\">    super(list);</span><br><span class=\"line\">    this.list = list;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>SynchronizedList的部分方法源码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public E get(int index) &#123;</span><br><span class=\"line\">    synchronized (mutex) &#123;return list.get(index);&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public E set(int index, E element) &#123;</span><br><span class=\"line\">    synchronized (mutex) &#123;return list.set(index, element);&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public void add(int index, E element) &#123;</span><br><span class=\"line\">    synchronized (mutex) &#123;list.add(index, element);&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public E remove(int index) &#123;</span><br><span class=\"line\">    synchronized (mutex) &#123;return list.remove(index);&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很可惜，它所有方法都是带同步对象锁的，和 Vector 一样，它不是性能最优的。即使你能说到这里，面试官还会继续往下追问，比如在读多写少的情况，SynchronizedList这种集合性能非常差，还有没有更合适的方案？</p>\n<p>介绍两个并发包里面的并发集合类：</p>\n<blockquote>\n<p>java.util.concurrent.CopyOnWriteArrayList<br>java.util.concurrent.CopyOnWriteArraySet</p>\n</blockquote>\n<p>CopyOnWrite集合类也就这两个，Java 1.5 开始加入，你要能说得上这两个才能让面试官信服。</p>\n<h4 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h4><p>CopyOnWrite（简称：COW）：即复制再写入，就是在添加元素的时候，先把原 List 列表复制一份，再添加新的元素。</p>\n<p>先来看下它的 add 方法源码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean add(E e) &#123;</span><br><span class=\"line\">    // 加锁</span><br><span class=\"line\">    final ReentrantLock lock = this.lock;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        // 获取原始集合</span><br><span class=\"line\">        Object[] elements = getArray();</span><br><span class=\"line\">        int len = elements.length;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 复制一个新集合</span><br><span class=\"line\">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class=\"line\">        newElements[len] = e;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 替换原始集合为新集合</span><br><span class=\"line\">        setArray(newElements);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        // 释放锁</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>添加元素时，先加锁，再进行复制替换操作，最后再释放锁。</p>\n<p>再来看下它的 get 方法源码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private E get(Object[] a, int index) &#123;</span><br><span class=\"line\">    return (E) a[index];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public E get(int index) &#123;</span><br><span class=\"line\">    return get(getArray(), index);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，获取元素并没有加锁。</p>\n<p>这样做的好处是，在高并发情况下，读取元素时就不用加锁，写数据时才加锁，大大提升了读取性能。</p>\n<h4 id=\"CopyOnWriteArraySet\"><a href=\"#CopyOnWriteArraySet\" class=\"headerlink\" title=\"CopyOnWriteArraySet\"></a>CopyOnWriteArraySet</h4><p>CopyOnWriteArraySet逻辑就更简单了，就是使用 CopyOnWriteArrayList 的 addIfAbsent 方法来去重的，添加元素的时候判断对象是否已经存在，不存在才添加进集合。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Appends the element, if not present.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param e element to be added to this list, if absent</span><br><span class=\"line\"> * @return &#123;@code true&#125; if the element was added</span><br><span class=\"line\"> */</span><br><span class=\"line\">public boolean addIfAbsent(E e) &#123;</span><br><span class=\"line\">    Object[] snapshot = getArray();</span><br><span class=\"line\">    return indexOf(e, snapshot, 0, snapshot.length) &gt;= 0 ? false :</span><br><span class=\"line\">        addIfAbsent(e, snapshot);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两种并发集合，虽然牛逼，但只适合于读多写少的情况，如果写多读少，使用这个就没意义了，因为每次写操作都要进行集合内存复制，性能开销很大，如果集合较大，很容易造成内存溢出。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>下次面试官问你线程安全的 List，你可以从 Vector &gt; SynchronizedList &gt; CopyOnWriteArrayList 这样的顺序依次说上来，这样才有带入感，也能体现你对知识点的掌握程度。</p>\n<p>看完有没有收获呢？下次面试应该能秒杀面试官了吧！</p>\n","excerpt":"","more":"<p>最近在Java技术知识星球里面有球友问到了线程安全的 List：</p>\n<p><img src=\"http://img.javastack.cn/20190927184141.png\"></p>\n<p>扫码查看答案或加入知识星球</p>\n<p>栈长在之前的文章《<a href=\"https://mp.weixin.qq.com/s/oA-uEbzNYA4KYwLtRWXRVw\">出场率比较高的一道多线程安全面试题</a>》里面讲过 ArrayList 的不安全性。</p>\n<p>那么面试官会问你，既然 ArrayList 是线程不安全的，怎么保证它的线程安全性呢？或者有什么替代方案？</p>\n<p>往下看，看我如何碾压他！</p>\n<p>大部分人会脱口而出：用Vector，这样只会让面试官鄙视！除了Vector，你还会别的吗？</p>\n<p>你至少还得说得上这种：</p>\n<blockquote>\n<p>java.util.Collections.SynchronizedList</p>\n</blockquote>\n<p>它能把所有 List 接口的实现类转换成线程安全的List，比 Vector 有更好的扩展性和兼容性，SynchronizedList的构造方法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final List&lt;E&gt; list;</span><br><span class=\"line\"></span><br><span class=\"line\">SynchronizedList(List&lt;E&gt; list) &#123;</span><br><span class=\"line\">    super(list);</span><br><span class=\"line\">    this.list = list;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>SynchronizedList的部分方法源码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public E get(int index) &#123;</span><br><span class=\"line\">    synchronized (mutex) &#123;return list.get(index);&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public E set(int index, E element) &#123;</span><br><span class=\"line\">    synchronized (mutex) &#123;return list.set(index, element);&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public void add(int index, E element) &#123;</span><br><span class=\"line\">    synchronized (mutex) &#123;list.add(index, element);&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public E remove(int index) &#123;</span><br><span class=\"line\">    synchronized (mutex) &#123;return list.remove(index);&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很可惜，它所有方法都是带同步对象锁的，和 Vector 一样，它不是性能最优的。即使你能说到这里，面试官还会继续往下追问，比如在读多写少的情况，SynchronizedList这种集合性能非常差，还有没有更合适的方案？</p>\n<p>介绍两个并发包里面的并发集合类：</p>\n<blockquote>\n<p>java.util.concurrent.CopyOnWriteArrayList<br>java.util.concurrent.CopyOnWriteArraySet</p>\n</blockquote>\n<p>CopyOnWrite集合类也就这两个，Java 1.5 开始加入，你要能说得上这两个才能让面试官信服。</p>\n<h4 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h4><p>CopyOnWrite（简称：COW）：即复制再写入，就是在添加元素的时候，先把原 List 列表复制一份，再添加新的元素。</p>\n<p>先来看下它的 add 方法源码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean add(E e) &#123;</span><br><span class=\"line\">    // 加锁</span><br><span class=\"line\">    final ReentrantLock lock = this.lock;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        // 获取原始集合</span><br><span class=\"line\">        Object[] elements = getArray();</span><br><span class=\"line\">        int len = elements.length;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 复制一个新集合</span><br><span class=\"line\">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class=\"line\">        newElements[len] = e;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 替换原始集合为新集合</span><br><span class=\"line\">        setArray(newElements);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        // 释放锁</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>添加元素时，先加锁，再进行复制替换操作，最后再释放锁。</p>\n<p>再来看下它的 get 方法源码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private E get(Object[] a, int index) &#123;</span><br><span class=\"line\">    return (E) a[index];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public E get(int index) &#123;</span><br><span class=\"line\">    return get(getArray(), index);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，获取元素并没有加锁。</p>\n<p>这样做的好处是，在高并发情况下，读取元素时就不用加锁，写数据时才加锁，大大提升了读取性能。</p>\n<h4 id=\"CopyOnWriteArraySet\"><a href=\"#CopyOnWriteArraySet\" class=\"headerlink\" title=\"CopyOnWriteArraySet\"></a>CopyOnWriteArraySet</h4><p>CopyOnWriteArraySet逻辑就更简单了，就是使用 CopyOnWriteArrayList 的 addIfAbsent 方法来去重的，添加元素的时候判断对象是否已经存在，不存在才添加进集合。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Appends the element, if not present.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param e element to be added to this list, if absent</span><br><span class=\"line\"> * @return &#123;@code true&#125; if the element was added</span><br><span class=\"line\"> */</span><br><span class=\"line\">public boolean addIfAbsent(E e) &#123;</span><br><span class=\"line\">    Object[] snapshot = getArray();</span><br><span class=\"line\">    return indexOf(e, snapshot, 0, snapshot.length) &gt;= 0 ? false :</span><br><span class=\"line\">        addIfAbsent(e, snapshot);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两种并发集合，虽然牛逼，但只适合于读多写少的情况，如果写多读少，使用这个就没意义了，因为每次写操作都要进行集合内存复制，性能开销很大，如果集合较大，很容易造成内存溢出。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>下次面试官问你线程安全的 List，你可以从 Vector &gt; SynchronizedList &gt; CopyOnWriteArrayList 这样的顺序依次说上来，这样才有带入感，也能体现你对知识点的掌握程度。</p>\n<p>看完有没有收获呢？下次面试应该能秒杀面试官了吧！</p>\n"},{"title":"线程休眠只会用Thread.sleep？那就弱爆了！","date":"2025-10-14T06:42:34.000Z","_content":"\n线程休眠是 Java 开发经常会用到的一个手段，就是让当前线程睡一会儿，睡醒之后再继续运行。\n\n咱大多数程序员，多线程虽然学得不好，但线程休眠，无人不知，无人不晓，也都会用，不就是用 Thread.sleep 方法嘛！而且还将它用到那么绝，之前不是还有人写过休眠排序算法和休眠取时间的算法，再来回味下这么脑洞大开的两个算法：\n\n- [休眠排序算法](https://mp.weixin.qq.com/s/Or3q3souk1GGVNB2qvEY2Q)\n- [休眠取时间算法](https://mp.weixin.qq.com/s/Or3q3souk1GGVNB2qvEY2Q)\n\n笑过之后，当然，这不是咋今天要讲的主题，栈长今天要讲的是如何更优雅的让线程休眠。\n\n**来看下面的休眠程序：**\n\n```\nThread.sleep(87000000);\n```\n\n你知道休眠多久吗？\n\n醉了……\n\n**再把上面的稍微改装下：**\n\n```\nThread.sleep(24 * 60 * 60 * 1000 + 10 * 60 * 1000);\n```\n\n现在你估计大概能知道休眠多久了，但还是很茫然，很无助，不写注释，谁知道休眠多久？单位还是毫秒。。\n\n其实就是休眠 24 小时 10 分钟，何必整这么麻烦呢？\n\n**优雅又简单的方式来了：**\n\n```\nTimeUnit.DAYS.sleep(1);\nTimeUnit.MINUTES.sleep(10);\n\n或者 \n\nTimeUnit.HOURS.sleep(24);\nTimeUnit.MINUTES.sleep(10);\n```\n\n使用 `java.util.concurrent.TimeUnit` 类就可以优雅的搞定，不需要过多的单位运算及修饰，是不是很优雅，很简单？\n\n上面演示了 HOURS、MINUTES，还有更多的枚举可以用。\n\n**来看下 TimeUnit 的详细方法和枚举值：**\n\n![](http://img.javastack.cn/TimeUnit.png)\n\n其实 TimeUnit 还可以用来做时间单位转换，TimeUnit 提供了各种丰富的时间单位转换方法。\n\n我们随便来看一个枚举值：\n\n```\nMINUTES {\n    public long toNanos(long d)   { return x(d, C4/C0, MAX/(C4/C0)); }\n    public long toMicros(long d)  { return x(d, C4/C1, MAX/(C4/C1)); }\n    public long toMillis(long d)  { return x(d, C4/C2, MAX/(C4/C2)); }\n    public long toSeconds(long d) { return x(d, C4/C3, MAX/(C4/C3)); }\n    public long toMinutes(long d) { return d; }\n    public long toHours(long d)   { return d/(C5/C4); }\n    public long toDays(long d)    { return d/(C6/C4); }\n    public long convert(long d, TimeUnit u) { return u.toMinutes(d); }\n    int excessNanos(long d, long m) { return 0; }\n}\n```\n\n可以很方便的把分钟转换成各种单位的值。\n\n**再来看一下 TimeUnit 休眠的原理：**\n\n```\npublic void sleep(long timeout) throws InterruptedException {\n    if (timeout > 0) {\n        long ms = toMillis(timeout);\n        int ns = excessNanos(timeout, ms);\n        Thread.sleep(ms, ns);\n    }\n}\n```\n\n其实 TimeUnit 的休眠就是调用了 Thread.sleep 休眠方法，哈哈，只是把 Thread.sleep 封装了，这样，用起来很简单方便，也提高了可读性。\n\n\n","source":"_posts/线程休眠只会用Thread.sleep？那就弱爆了！.md","raw":"---\ntitle: 线程休眠只会用Thread.sleep？那就弱爆了！\ndate: 2025-10-14 14:42:34\ntags: 多线程\n---\n\n线程休眠是 Java 开发经常会用到的一个手段，就是让当前线程睡一会儿，睡醒之后再继续运行。\n\n咱大多数程序员，多线程虽然学得不好，但线程休眠，无人不知，无人不晓，也都会用，不就是用 Thread.sleep 方法嘛！而且还将它用到那么绝，之前不是还有人写过休眠排序算法和休眠取时间的算法，再来回味下这么脑洞大开的两个算法：\n\n- [休眠排序算法](https://mp.weixin.qq.com/s/Or3q3souk1GGVNB2qvEY2Q)\n- [休眠取时间算法](https://mp.weixin.qq.com/s/Or3q3souk1GGVNB2qvEY2Q)\n\n笑过之后，当然，这不是咋今天要讲的主题，栈长今天要讲的是如何更优雅的让线程休眠。\n\n**来看下面的休眠程序：**\n\n```\nThread.sleep(87000000);\n```\n\n你知道休眠多久吗？\n\n醉了……\n\n**再把上面的稍微改装下：**\n\n```\nThread.sleep(24 * 60 * 60 * 1000 + 10 * 60 * 1000);\n```\n\n现在你估计大概能知道休眠多久了，但还是很茫然，很无助，不写注释，谁知道休眠多久？单位还是毫秒。。\n\n其实就是休眠 24 小时 10 分钟，何必整这么麻烦呢？\n\n**优雅又简单的方式来了：**\n\n```\nTimeUnit.DAYS.sleep(1);\nTimeUnit.MINUTES.sleep(10);\n\n或者 \n\nTimeUnit.HOURS.sleep(24);\nTimeUnit.MINUTES.sleep(10);\n```\n\n使用 `java.util.concurrent.TimeUnit` 类就可以优雅的搞定，不需要过多的单位运算及修饰，是不是很优雅，很简单？\n\n上面演示了 HOURS、MINUTES，还有更多的枚举可以用。\n\n**来看下 TimeUnit 的详细方法和枚举值：**\n\n![](http://img.javastack.cn/TimeUnit.png)\n\n其实 TimeUnit 还可以用来做时间单位转换，TimeUnit 提供了各种丰富的时间单位转换方法。\n\n我们随便来看一个枚举值：\n\n```\nMINUTES {\n    public long toNanos(long d)   { return x(d, C4/C0, MAX/(C4/C0)); }\n    public long toMicros(long d)  { return x(d, C4/C1, MAX/(C4/C1)); }\n    public long toMillis(long d)  { return x(d, C4/C2, MAX/(C4/C2)); }\n    public long toSeconds(long d) { return x(d, C4/C3, MAX/(C4/C3)); }\n    public long toMinutes(long d) { return d; }\n    public long toHours(long d)   { return d/(C5/C4); }\n    public long toDays(long d)    { return d/(C6/C4); }\n    public long convert(long d, TimeUnit u) { return u.toMinutes(d); }\n    int excessNanos(long d, long m) { return 0; }\n}\n```\n\n可以很方便的把分钟转换成各种单位的值。\n\n**再来看一下 TimeUnit 休眠的原理：**\n\n```\npublic void sleep(long timeout) throws InterruptedException {\n    if (timeout > 0) {\n        long ms = toMillis(timeout);\n        int ns = excessNanos(timeout, ms);\n        Thread.sleep(ms, ns);\n    }\n}\n```\n\n其实 TimeUnit 的休眠就是调用了 Thread.sleep 休眠方法，哈哈，只是把 Thread.sleep 封装了，这样，用起来很简单方便，也提高了可读性。\n\n\n","slug":"线程休眠只会用Thread.sleep？那就弱爆了！","published":1,"updated":"2025-10-14T07:16:33.099Z","_id":"cmgq787ar000ehod43l7ufwp1","comments":1,"layout":"post","photos":[],"content":"<p>线程休眠是 Java 开发经常会用到的一个手段，就是让当前线程睡一会儿，睡醒之后再继续运行。</p>\n<p>咱大多数程序员，多线程虽然学得不好，但线程休眠，无人不知，无人不晓，也都会用，不就是用 Thread.sleep 方法嘛！而且还将它用到那么绝，之前不是还有人写过休眠排序算法和休眠取时间的算法，再来回味下这么脑洞大开的两个算法：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/Or3q3souk1GGVNB2qvEY2Q\">休眠排序算法</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Or3q3souk1GGVNB2qvEY2Q\">休眠取时间算法</a></li>\n</ul>\n<p>笑过之后，当然，这不是咋今天要讲的主题，栈长今天要讲的是如何更优雅的让线程休眠。</p>\n<p><strong>来看下面的休眠程序：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread.sleep(87000000);</span><br></pre></td></tr></table></figure>\n\n<p>你知道休眠多久吗？</p>\n<p>醉了……</p>\n<p><strong>再把上面的稍微改装下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread.sleep(24 * 60 * 60 * 1000 + 10 * 60 * 1000);</span><br></pre></td></tr></table></figure>\n\n<p>现在你估计大概能知道休眠多久了，但还是很茫然，很无助，不写注释，谁知道休眠多久？单位还是毫秒。。</p>\n<p>其实就是休眠 24 小时 10 分钟，何必整这么麻烦呢？</p>\n<p><strong>优雅又简单的方式来了：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TimeUnit.DAYS.sleep(1);</span><br><span class=\"line\">TimeUnit.MINUTES.sleep(10);</span><br><span class=\"line\"></span><br><span class=\"line\">或者 </span><br><span class=\"line\"></span><br><span class=\"line\">TimeUnit.HOURS.sleep(24);</span><br><span class=\"line\">TimeUnit.MINUTES.sleep(10);</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>java.util.concurrent.TimeUnit</code> 类就可以优雅的搞定，不需要过多的单位运算及修饰，是不是很优雅，很简单？</p>\n<p>上面演示了 HOURS、MINUTES，还有更多的枚举可以用。</p>\n<p><strong>来看下 TimeUnit 的详细方法和枚举值：</strong></p>\n<p><img src=\"http://img.javastack.cn/TimeUnit.png\"></p>\n<p>其实 TimeUnit 还可以用来做时间单位转换，TimeUnit 提供了各种丰富的时间单位转换方法。</p>\n<p>我们随便来看一个枚举值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MINUTES &#123;</span><br><span class=\"line\">    public long toNanos(long d)   &#123; return x(d, C4/C0, MAX/(C4/C0)); &#125;</span><br><span class=\"line\">    public long toMicros(long d)  &#123; return x(d, C4/C1, MAX/(C4/C1)); &#125;</span><br><span class=\"line\">    public long toMillis(long d)  &#123; return x(d, C4/C2, MAX/(C4/C2)); &#125;</span><br><span class=\"line\">    public long toSeconds(long d) &#123; return x(d, C4/C3, MAX/(C4/C3)); &#125;</span><br><span class=\"line\">    public long toMinutes(long d) &#123; return d; &#125;</span><br><span class=\"line\">    public long toHours(long d)   &#123; return d/(C5/C4); &#125;</span><br><span class=\"line\">    public long toDays(long d)    &#123; return d/(C6/C4); &#125;</span><br><span class=\"line\">    public long convert(long d, TimeUnit u) &#123; return u.toMinutes(d); &#125;</span><br><span class=\"line\">    int excessNanos(long d, long m) &#123; return 0; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以很方便的把分钟转换成各种单位的值。</p>\n<p><strong>再来看一下 TimeUnit 休眠的原理：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void sleep(long timeout) throws InterruptedException &#123;</span><br><span class=\"line\">    if (timeout &gt; 0) &#123;</span><br><span class=\"line\">        long ms = toMillis(timeout);</span><br><span class=\"line\">        int ns = excessNanos(timeout, ms);</span><br><span class=\"line\">        Thread.sleep(ms, ns);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实 TimeUnit 的休眠就是调用了 Thread.sleep 休眠方法，哈哈，只是把 Thread.sleep 封装了，这样，用起来很简单方便，也提高了可读性。</p>\n","excerpt":"","more":"<p>线程休眠是 Java 开发经常会用到的一个手段，就是让当前线程睡一会儿，睡醒之后再继续运行。</p>\n<p>咱大多数程序员，多线程虽然学得不好，但线程休眠，无人不知，无人不晓，也都会用，不就是用 Thread.sleep 方法嘛！而且还将它用到那么绝，之前不是还有人写过休眠排序算法和休眠取时间的算法，再来回味下这么脑洞大开的两个算法：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/Or3q3souk1GGVNB2qvEY2Q\">休眠排序算法</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Or3q3souk1GGVNB2qvEY2Q\">休眠取时间算法</a></li>\n</ul>\n<p>笑过之后，当然，这不是咋今天要讲的主题，栈长今天要讲的是如何更优雅的让线程休眠。</p>\n<p><strong>来看下面的休眠程序：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread.sleep(87000000);</span><br></pre></td></tr></table></figure>\n\n<p>你知道休眠多久吗？</p>\n<p>醉了……</p>\n<p><strong>再把上面的稍微改装下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread.sleep(24 * 60 * 60 * 1000 + 10 * 60 * 1000);</span><br></pre></td></tr></table></figure>\n\n<p>现在你估计大概能知道休眠多久了，但还是很茫然，很无助，不写注释，谁知道休眠多久？单位还是毫秒。。</p>\n<p>其实就是休眠 24 小时 10 分钟，何必整这么麻烦呢？</p>\n<p><strong>优雅又简单的方式来了：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TimeUnit.DAYS.sleep(1);</span><br><span class=\"line\">TimeUnit.MINUTES.sleep(10);</span><br><span class=\"line\"></span><br><span class=\"line\">或者 </span><br><span class=\"line\"></span><br><span class=\"line\">TimeUnit.HOURS.sleep(24);</span><br><span class=\"line\">TimeUnit.MINUTES.sleep(10);</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>java.util.concurrent.TimeUnit</code> 类就可以优雅的搞定，不需要过多的单位运算及修饰，是不是很优雅，很简单？</p>\n<p>上面演示了 HOURS、MINUTES，还有更多的枚举可以用。</p>\n<p><strong>来看下 TimeUnit 的详细方法和枚举值：</strong></p>\n<p><img src=\"http://img.javastack.cn/TimeUnit.png\"></p>\n<p>其实 TimeUnit 还可以用来做时间单位转换，TimeUnit 提供了各种丰富的时间单位转换方法。</p>\n<p>我们随便来看一个枚举值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MINUTES &#123;</span><br><span class=\"line\">    public long toNanos(long d)   &#123; return x(d, C4/C0, MAX/(C4/C0)); &#125;</span><br><span class=\"line\">    public long toMicros(long d)  &#123; return x(d, C4/C1, MAX/(C4/C1)); &#125;</span><br><span class=\"line\">    public long toMillis(long d)  &#123; return x(d, C4/C2, MAX/(C4/C2)); &#125;</span><br><span class=\"line\">    public long toSeconds(long d) &#123; return x(d, C4/C3, MAX/(C4/C3)); &#125;</span><br><span class=\"line\">    public long toMinutes(long d) &#123; return d; &#125;</span><br><span class=\"line\">    public long toHours(long d)   &#123; return d/(C5/C4); &#125;</span><br><span class=\"line\">    public long toDays(long d)    &#123; return d/(C6/C4); &#125;</span><br><span class=\"line\">    public long convert(long d, TimeUnit u) &#123; return u.toMinutes(d); &#125;</span><br><span class=\"line\">    int excessNanos(long d, long m) &#123; return 0; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以很方便的把分钟转换成各种单位的值。</p>\n<p><strong>再来看一下 TimeUnit 休眠的原理：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void sleep(long timeout) throws InterruptedException &#123;</span><br><span class=\"line\">    if (timeout &gt; 0) &#123;</span><br><span class=\"line\">        long ms = toMillis(timeout);</span><br><span class=\"line\">        int ns = excessNanos(timeout, ms);</span><br><span class=\"line\">        Thread.sleep(ms, ns);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实 TimeUnit 的休眠就是调用了 Thread.sleep 休眠方法，哈哈，只是把 Thread.sleep 封装了，这样，用起来很简单方便，也提高了可读性。</p>\n"},{"title":"Synchronized 有几种用法？","date":"2025-10-14T06:42:34.000Z","_content":"\n我们都知道 Synchronized 是线程安全同步用的，大部分程序可能只会用到同步方法上面。其实 Synchronized 可以用到更多的场合，栈长列举了以下几个用法。\n\n## **1、同步普通方法**\n\n这个也是我们用得最多的，只要涉及线程安全，上来就给方法来个同步锁。这种方法使用虽然最简单，但是只能作用在单例上面，如果不是单例，同步方法锁将失效。\n\n```\n/**\n * 用在普通方法\n */\nprivate synchronized void synchronizedMethod() {\n\tSystem.out.println(\"synchronizedMethod\");\n\ttry {\n\t\tThread.sleep(2000);\n\t} catch (InterruptedException e) {\n\t\te.printStackTrace();\n\t}\n}\n```\n\n此时，同一个实例只有一个线程能获取锁进入这个方法。\n\n\n## 2、同步静态方法\n\n同步静态方法，不管你有多少个类实例，同时只有一个线程能获取锁进入这个方法。\n\n```\n/**\n * 用在静态方法\n */\nprivate synchronized static void synchronizedStaticMethod() {\n\tSystem.out.println(\"synchronizedStaticMethod\");\n\ttry {\n\t\tThread.sleep(2000);\n\t} catch (InterruptedException e) {\n\t\te.printStackTrace();\n\t}\n}\n```\n\n同步静态方法是类级别的锁，一旦任何一个线程进入这个方法，其他所有线程将无法访问这个类的任何同步类锁的方法。\n\n## 3、同步类\n\n下面提供了两种同步类的方法，锁住效果和同步静态方法一样，都是类级别的锁，同时只有一个线程能访问带有同步类锁的方法。\n\n```\n/**\n * 用在类\n */\nprivate void synchronizedClass() {\n\tsynchronized (TestSynchronized.class) {\n\t\tSystem.out.println(\"synchronizedClass\");\n\t\ttry {\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\n/**\n * 用在类\n */\nprivate void synchronizedGetClass() {\n\tsynchronized (this.getClass()) {\n\t\tSystem.out.println(\"synchronizedGetClass\");\n\t\ttry {\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n这里的两种用法是同步块的用法，这里表示只有获取到这个类锁才能进入这个代码块。\n\n## 4、同步this实例\n\n这也是同步块的用法，表示锁住整个当前对象实例，只有获取到这个实例的锁才能进入这个方法。\n\n```\n/**\n * 用在this\n */\nprivate void synchronizedThis() {\n\tsynchronized (this) {\n\t\tSystem.out.println(\"synchronizedThis\");\n\t\ttry {\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n用法和同步普通方法锁一样，都是锁住整个当前实例。\n\n## 5、同步对象实例\n\n这也是同步块的用法，和上面的锁住当前实例一样，这里表示锁住整个 LOCK 对象实例，只有获取到这个 LOCK 实例的锁才能进入这个方法。\n\n```\n/**\n * 用在对象\n */\nprivate void synchronizedInstance() {\n\tsynchronized (LOCK) {\n\t\tSystem.out.println(\"synchronizedInstance\");\n\t\ttry {\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n另外，类锁与实例锁不相互阻塞，但相同的类锁，相同的当前实例锁，相同的对象锁会相互阻塞。\n\n关于 Synchronized 的几种用法栈长就介绍到这里了，如果你还知道其他的用法，欢迎留言。\n\n\n","source":"_posts/Synchronized 有几种用法？.md","raw":"---\ntitle: Synchronized 有几种用法？\ndate: 2025-10-14 14:42:34\ntags: 多线程\n---\n\n我们都知道 Synchronized 是线程安全同步用的，大部分程序可能只会用到同步方法上面。其实 Synchronized 可以用到更多的场合，栈长列举了以下几个用法。\n\n## **1、同步普通方法**\n\n这个也是我们用得最多的，只要涉及线程安全，上来就给方法来个同步锁。这种方法使用虽然最简单，但是只能作用在单例上面，如果不是单例，同步方法锁将失效。\n\n```\n/**\n * 用在普通方法\n */\nprivate synchronized void synchronizedMethod() {\n\tSystem.out.println(\"synchronizedMethod\");\n\ttry {\n\t\tThread.sleep(2000);\n\t} catch (InterruptedException e) {\n\t\te.printStackTrace();\n\t}\n}\n```\n\n此时，同一个实例只有一个线程能获取锁进入这个方法。\n\n\n## 2、同步静态方法\n\n同步静态方法，不管你有多少个类实例，同时只有一个线程能获取锁进入这个方法。\n\n```\n/**\n * 用在静态方法\n */\nprivate synchronized static void synchronizedStaticMethod() {\n\tSystem.out.println(\"synchronizedStaticMethod\");\n\ttry {\n\t\tThread.sleep(2000);\n\t} catch (InterruptedException e) {\n\t\te.printStackTrace();\n\t}\n}\n```\n\n同步静态方法是类级别的锁，一旦任何一个线程进入这个方法，其他所有线程将无法访问这个类的任何同步类锁的方法。\n\n## 3、同步类\n\n下面提供了两种同步类的方法，锁住效果和同步静态方法一样，都是类级别的锁，同时只有一个线程能访问带有同步类锁的方法。\n\n```\n/**\n * 用在类\n */\nprivate void synchronizedClass() {\n\tsynchronized (TestSynchronized.class) {\n\t\tSystem.out.println(\"synchronizedClass\");\n\t\ttry {\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\n/**\n * 用在类\n */\nprivate void synchronizedGetClass() {\n\tsynchronized (this.getClass()) {\n\t\tSystem.out.println(\"synchronizedGetClass\");\n\t\ttry {\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n这里的两种用法是同步块的用法，这里表示只有获取到这个类锁才能进入这个代码块。\n\n## 4、同步this实例\n\n这也是同步块的用法，表示锁住整个当前对象实例，只有获取到这个实例的锁才能进入这个方法。\n\n```\n/**\n * 用在this\n */\nprivate void synchronizedThis() {\n\tsynchronized (this) {\n\t\tSystem.out.println(\"synchronizedThis\");\n\t\ttry {\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n用法和同步普通方法锁一样，都是锁住整个当前实例。\n\n## 5、同步对象实例\n\n这也是同步块的用法，和上面的锁住当前实例一样，这里表示锁住整个 LOCK 对象实例，只有获取到这个 LOCK 实例的锁才能进入这个方法。\n\n```\n/**\n * 用在对象\n */\nprivate void synchronizedInstance() {\n\tsynchronized (LOCK) {\n\t\tSystem.out.println(\"synchronizedInstance\");\n\t\ttry {\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n另外，类锁与实例锁不相互阻塞，但相同的类锁，相同的当前实例锁，相同的对象锁会相互阻塞。\n\n关于 Synchronized 的几种用法栈长就介绍到这里了，如果你还知道其他的用法，欢迎留言。\n\n\n","slug":"Synchronized 有几种用法？","published":1,"updated":"2025-10-14T06:47:56.978Z","_id":"cmgq7a42b000ghod4bwh1enbm","comments":1,"layout":"post","photos":[],"content":"<p>我们都知道 Synchronized 是线程安全同步用的，大部分程序可能只会用到同步方法上面。其实 Synchronized 可以用到更多的场合，栈长列举了以下几个用法。</p>\n<h2 id=\"1、同步普通方法\"><a href=\"#1、同步普通方法\" class=\"headerlink\" title=\"1、同步普通方法\"></a><strong>1、同步普通方法</strong></h2><p>这个也是我们用得最多的，只要涉及线程安全，上来就给方法来个同步锁。这种方法使用虽然最简单，但是只能作用在单例上面，如果不是单例，同步方法锁将失效。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 用在普通方法</span><br><span class=\"line\"> */</span><br><span class=\"line\">private synchronized void synchronizedMethod() &#123;</span><br><span class=\"line\">\tSystem.out.println(&quot;synchronizedMethod&quot;);</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\tThread.sleep(2000);</span><br><span class=\"line\">\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时，同一个实例只有一个线程能获取锁进入这个方法。</p>\n<h2 id=\"2、同步静态方法\"><a href=\"#2、同步静态方法\" class=\"headerlink\" title=\"2、同步静态方法\"></a>2、同步静态方法</h2><p>同步静态方法，不管你有多少个类实例，同时只有一个线程能获取锁进入这个方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 用在静态方法</span><br><span class=\"line\"> */</span><br><span class=\"line\">private synchronized static void synchronizedStaticMethod() &#123;</span><br><span class=\"line\">\tSystem.out.println(&quot;synchronizedStaticMethod&quot;);</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\tThread.sleep(2000);</span><br><span class=\"line\">\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同步静态方法是类级别的锁，一旦任何一个线程进入这个方法，其他所有线程将无法访问这个类的任何同步类锁的方法。</p>\n<h2 id=\"3、同步类\"><a href=\"#3、同步类\" class=\"headerlink\" title=\"3、同步类\"></a>3、同步类</h2><p>下面提供了两种同步类的方法，锁住效果和同步静态方法一样，都是类级别的锁，同时只有一个线程能访问带有同步类锁的方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 用在类</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void synchronizedClass() &#123;</span><br><span class=\"line\">\tsynchronized (TestSynchronized.class) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;synchronizedClass&quot;);</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tThread.sleep(2000);</span><br><span class=\"line\">\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 用在类</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void synchronizedGetClass() &#123;</span><br><span class=\"line\">\tsynchronized (this.getClass()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;synchronizedGetClass&quot;);</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tThread.sleep(2000);</span><br><span class=\"line\">\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的两种用法是同步块的用法，这里表示只有获取到这个类锁才能进入这个代码块。</p>\n<h2 id=\"4、同步this实例\"><a href=\"#4、同步this实例\" class=\"headerlink\" title=\"4、同步this实例\"></a>4、同步this实例</h2><p>这也是同步块的用法，表示锁住整个当前对象实例，只有获取到这个实例的锁才能进入这个方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 用在this</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void synchronizedThis() &#123;</span><br><span class=\"line\">\tsynchronized (this) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;synchronizedThis&quot;);</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tThread.sleep(2000);</span><br><span class=\"line\">\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用法和同步普通方法锁一样，都是锁住整个当前实例。</p>\n<h2 id=\"5、同步对象实例\"><a href=\"#5、同步对象实例\" class=\"headerlink\" title=\"5、同步对象实例\"></a>5、同步对象实例</h2><p>这也是同步块的用法，和上面的锁住当前实例一样，这里表示锁住整个 LOCK 对象实例，只有获取到这个 LOCK 实例的锁才能进入这个方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 用在对象</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void synchronizedInstance() &#123;</span><br><span class=\"line\">\tsynchronized (LOCK) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;synchronizedInstance&quot;);</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tThread.sleep(2000);</span><br><span class=\"line\">\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外，类锁与实例锁不相互阻塞，但相同的类锁，相同的当前实例锁，相同的对象锁会相互阻塞。</p>\n<p>关于 Synchronized 的几种用法栈长就介绍到这里了，如果你还知道其他的用法，欢迎留言。</p>\n","excerpt":"","more":"<p>我们都知道 Synchronized 是线程安全同步用的，大部分程序可能只会用到同步方法上面。其实 Synchronized 可以用到更多的场合，栈长列举了以下几个用法。</p>\n<h2 id=\"1、同步普通方法\"><a href=\"#1、同步普通方法\" class=\"headerlink\" title=\"1、同步普通方法\"></a><strong>1、同步普通方法</strong></h2><p>这个也是我们用得最多的，只要涉及线程安全，上来就给方法来个同步锁。这种方法使用虽然最简单，但是只能作用在单例上面，如果不是单例，同步方法锁将失效。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 用在普通方法</span><br><span class=\"line\"> */</span><br><span class=\"line\">private synchronized void synchronizedMethod() &#123;</span><br><span class=\"line\">\tSystem.out.println(&quot;synchronizedMethod&quot;);</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\tThread.sleep(2000);</span><br><span class=\"line\">\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时，同一个实例只有一个线程能获取锁进入这个方法。</p>\n<h2 id=\"2、同步静态方法\"><a href=\"#2、同步静态方法\" class=\"headerlink\" title=\"2、同步静态方法\"></a>2、同步静态方法</h2><p>同步静态方法，不管你有多少个类实例，同时只有一个线程能获取锁进入这个方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 用在静态方法</span><br><span class=\"line\"> */</span><br><span class=\"line\">private synchronized static void synchronizedStaticMethod() &#123;</span><br><span class=\"line\">\tSystem.out.println(&quot;synchronizedStaticMethod&quot;);</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\tThread.sleep(2000);</span><br><span class=\"line\">\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同步静态方法是类级别的锁，一旦任何一个线程进入这个方法，其他所有线程将无法访问这个类的任何同步类锁的方法。</p>\n<h2 id=\"3、同步类\"><a href=\"#3、同步类\" class=\"headerlink\" title=\"3、同步类\"></a>3、同步类</h2><p>下面提供了两种同步类的方法，锁住效果和同步静态方法一样，都是类级别的锁，同时只有一个线程能访问带有同步类锁的方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 用在类</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void synchronizedClass() &#123;</span><br><span class=\"line\">\tsynchronized (TestSynchronized.class) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;synchronizedClass&quot;);</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tThread.sleep(2000);</span><br><span class=\"line\">\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 用在类</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void synchronizedGetClass() &#123;</span><br><span class=\"line\">\tsynchronized (this.getClass()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;synchronizedGetClass&quot;);</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tThread.sleep(2000);</span><br><span class=\"line\">\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的两种用法是同步块的用法，这里表示只有获取到这个类锁才能进入这个代码块。</p>\n<h2 id=\"4、同步this实例\"><a href=\"#4、同步this实例\" class=\"headerlink\" title=\"4、同步this实例\"></a>4、同步this实例</h2><p>这也是同步块的用法，表示锁住整个当前对象实例，只有获取到这个实例的锁才能进入这个方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 用在this</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void synchronizedThis() &#123;</span><br><span class=\"line\">\tsynchronized (this) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;synchronizedThis&quot;);</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tThread.sleep(2000);</span><br><span class=\"line\">\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用法和同步普通方法锁一样，都是锁住整个当前实例。</p>\n<h2 id=\"5、同步对象实例\"><a href=\"#5、同步对象实例\" class=\"headerlink\" title=\"5、同步对象实例\"></a>5、同步对象实例</h2><p>这也是同步块的用法，和上面的锁住当前实例一样，这里表示锁住整个 LOCK 对象实例，只有获取到这个 LOCK 实例的锁才能进入这个方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 用在对象</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void synchronizedInstance() &#123;</span><br><span class=\"line\">\tsynchronized (LOCK) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;synchronizedInstance&quot;);</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tThread.sleep(2000);</span><br><span class=\"line\">\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外，类锁与实例锁不相互阻塞，但相同的类锁，相同的当前实例锁，相同的对象锁会相互阻塞。</p>\n<p>关于 Synchronized 的几种用法栈长就介绍到这里了，如果你还知道其他的用法，欢迎留言。</p>\n"},{"title":"多线程通信的三大法器，你真的会用吗？","date":"2025-10-14T06:42:34.000Z","_content":"\nwait, notify, notifyAll 是多线程之间通信最重要的 3 个方法，今天，栈长给大家普及一下它们的知识要点及应用实战。\n\n## 定义\n\nwait：让持有该对象锁的线程等待；\n\nnotify: 唤醒任何一个持有该对象锁的线程；\n\nnotify: 唤醒所有持有该对象锁的线程；\n\n它们 3 个的关系是，调用对象的 wait 方法使线程暂停运行，通过 notify/ notifyAll 方法唤醒调用 wait 暂时的线程。\n\n**然而，它们并不是 Thread 类中的方法，而是 Object 类中的，为什么呢！？** 因为每个对象都有监视锁，线程要操作某个对象当然是要获取某个对象的锁了，而不是线程的锁。\n\n![](http://qianniu.javastack.cn/18-6-1/82637503.jpg)\n\n如图所示，wait 带时间表示最大超时时间，过了时间还不唤醒就会自动唤醒线程重新竞争对象锁。\n\n## 几个重要的点\n\n1、调用对象的 wait, notify, notifyAll 方法需要拥有对象的监视器锁，即它们只能在同步方法（块）中使用；\n\n2、调用 wait 方法会使用线程暂停并让出 CPU 资源，同时释放持有的对象的锁；\n\n3、多线程使用 notify 容易发生死锁，一般使用 notifyAll；\n\n4、关于 wait 和 sleep 的详细区别请翻阅 《[多线程 sleep 和 wait 的 5 个区别](https://mp.weixin.qq.com/s/gvaksKy2ss90bsybCnajpQ)》这篇文章。\n\n## 实战\n\n```\n/**\n * \n */\npublic static void main(String[] args) {\n\tObject lock = new Object();\n\tThread t1 = new Thread(() -> {\n\t\tsynchronized (lock) {\n\t\t\tfor (int i = 0; i < 20; i++) {\n\t\t\t\tSystem.out.print(i);\n\t\t\t\tif (i == 10) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlock.wait();\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tThread t2 = new Thread(() -> {\n\t\tsynchronized (lock) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(5000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.print(\"Java技术\");\n\t\t\tlock.notifyAll();\n\t\t}\n\t});\n\n\tt1.start();\n\tt2.start();\n}\n```\n\n上面的例子结合 wait/ notifyAll 来演示了它们的相互作用。\n\n线程 t1 首先输出 `012345678910`，5秒后继续输出 `Java技术111213141516171819`。\n\n","source":"_posts/多线程通信的三大法器，你真的会用吗？.md","raw":"---\ntitle: 多线程通信的三大法器，你真的会用吗？\ndate: 2025-10-14 14:42:34\ntags: 多线程\n---\n\nwait, notify, notifyAll 是多线程之间通信最重要的 3 个方法，今天，栈长给大家普及一下它们的知识要点及应用实战。\n\n## 定义\n\nwait：让持有该对象锁的线程等待；\n\nnotify: 唤醒任何一个持有该对象锁的线程；\n\nnotify: 唤醒所有持有该对象锁的线程；\n\n它们 3 个的关系是，调用对象的 wait 方法使线程暂停运行，通过 notify/ notifyAll 方法唤醒调用 wait 暂时的线程。\n\n**然而，它们并不是 Thread 类中的方法，而是 Object 类中的，为什么呢！？** 因为每个对象都有监视锁，线程要操作某个对象当然是要获取某个对象的锁了，而不是线程的锁。\n\n![](http://qianniu.javastack.cn/18-6-1/82637503.jpg)\n\n如图所示，wait 带时间表示最大超时时间，过了时间还不唤醒就会自动唤醒线程重新竞争对象锁。\n\n## 几个重要的点\n\n1、调用对象的 wait, notify, notifyAll 方法需要拥有对象的监视器锁，即它们只能在同步方法（块）中使用；\n\n2、调用 wait 方法会使用线程暂停并让出 CPU 资源，同时释放持有的对象的锁；\n\n3、多线程使用 notify 容易发生死锁，一般使用 notifyAll；\n\n4、关于 wait 和 sleep 的详细区别请翻阅 《[多线程 sleep 和 wait 的 5 个区别](https://mp.weixin.qq.com/s/gvaksKy2ss90bsybCnajpQ)》这篇文章。\n\n## 实战\n\n```\n/**\n * \n */\npublic static void main(String[] args) {\n\tObject lock = new Object();\n\tThread t1 = new Thread(() -> {\n\t\tsynchronized (lock) {\n\t\t\tfor (int i = 0; i < 20; i++) {\n\t\t\t\tSystem.out.print(i);\n\t\t\t\tif (i == 10) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlock.wait();\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tThread t2 = new Thread(() -> {\n\t\tsynchronized (lock) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(5000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.print(\"Java技术\");\n\t\t\tlock.notifyAll();\n\t\t}\n\t});\n\n\tt1.start();\n\tt2.start();\n}\n```\n\n上面的例子结合 wait/ notifyAll 来演示了它们的相互作用。\n\n线程 t1 首先输出 `012345678910`，5秒后继续输出 `Java技术111213141516171819`。\n\n","slug":"多线程通信的三大法器，你真的会用吗？","published":1,"updated":"2025-10-14T07:16:33.091Z","_id":"cmgq8aw87000nhod4c4uhfhb2","comments":1,"layout":"post","photos":[],"content":"<p>wait, notify, notifyAll 是多线程之间通信最重要的 3 个方法，今天，栈长给大家普及一下它们的知识要点及应用实战。</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>wait：让持有该对象锁的线程等待；</p>\n<p>notify: 唤醒任何一个持有该对象锁的线程；</p>\n<p>notify: 唤醒所有持有该对象锁的线程；</p>\n<p>它们 3 个的关系是，调用对象的 wait 方法使线程暂停运行，通过 notify&#x2F; notifyAll 方法唤醒调用 wait 暂时的线程。</p>\n<p><strong>然而，它们并不是 Thread 类中的方法，而是 Object 类中的，为什么呢！？</strong> 因为每个对象都有监视锁，线程要操作某个对象当然是要获取某个对象的锁了，而不是线程的锁。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-6-1/82637503.jpg\"></p>\n<p>如图所示，wait 带时间表示最大超时时间，过了时间还不唤醒就会自动唤醒线程重新竞争对象锁。</p>\n<h2 id=\"几个重要的点\"><a href=\"#几个重要的点\" class=\"headerlink\" title=\"几个重要的点\"></a>几个重要的点</h2><p>1、调用对象的 wait, notify, notifyAll 方法需要拥有对象的监视器锁，即它们只能在同步方法（块）中使用；</p>\n<p>2、调用 wait 方法会使用线程暂停并让出 CPU 资源，同时释放持有的对象的锁；</p>\n<p>3、多线程使用 notify 容易发生死锁，一般使用 notifyAll；</p>\n<p>4、关于 wait 和 sleep 的详细区别请翻阅 《<a href=\"https://mp.weixin.qq.com/s/gvaksKy2ss90bsybCnajpQ\">多线程 sleep 和 wait 的 5 个区别</a>》这篇文章。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\tObject lock = new Object();</span><br><span class=\"line\">\tThread t1 = new Thread(() -&gt; &#123;</span><br><span class=\"line\">\t\tsynchronized (lock) &#123;</span><br><span class=\"line\">\t\t\tfor (int i = 0; i &lt; 20; i++) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.print(i);</span><br><span class=\"line\">\t\t\t\tif (i == 10) &#123;</span><br><span class=\"line\">\t\t\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\t\t\tlock.wait();</span><br><span class=\"line\">\t\t\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tThread t2 = new Thread(() -&gt; &#123;</span><br><span class=\"line\">\t\tsynchronized (lock) &#123;</span><br><span class=\"line\">\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\tThread.sleep(5000);</span><br><span class=\"line\">\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tSystem.out.print(&quot;Java技术&quot;);</span><br><span class=\"line\">\t\t\tlock.notifyAll();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tt1.start();</span><br><span class=\"line\">\tt2.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子结合 wait&#x2F; notifyAll 来演示了它们的相互作用。</p>\n<p>线程 t1 首先输出 <code>012345678910</code>，5秒后继续输出 <code>Java技术111213141516171819</code>。</p>\n","excerpt":"","more":"<p>wait, notify, notifyAll 是多线程之间通信最重要的 3 个方法，今天，栈长给大家普及一下它们的知识要点及应用实战。</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>wait：让持有该对象锁的线程等待；</p>\n<p>notify: 唤醒任何一个持有该对象锁的线程；</p>\n<p>notify: 唤醒所有持有该对象锁的线程；</p>\n<p>它们 3 个的关系是，调用对象的 wait 方法使线程暂停运行，通过 notify&#x2F; notifyAll 方法唤醒调用 wait 暂时的线程。</p>\n<p><strong>然而，它们并不是 Thread 类中的方法，而是 Object 类中的，为什么呢！？</strong> 因为每个对象都有监视锁，线程要操作某个对象当然是要获取某个对象的锁了，而不是线程的锁。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-6-1/82637503.jpg\"></p>\n<p>如图所示，wait 带时间表示最大超时时间，过了时间还不唤醒就会自动唤醒线程重新竞争对象锁。</p>\n<h2 id=\"几个重要的点\"><a href=\"#几个重要的点\" class=\"headerlink\" title=\"几个重要的点\"></a>几个重要的点</h2><p>1、调用对象的 wait, notify, notifyAll 方法需要拥有对象的监视器锁，即它们只能在同步方法（块）中使用；</p>\n<p>2、调用 wait 方法会使用线程暂停并让出 CPU 资源，同时释放持有的对象的锁；</p>\n<p>3、多线程使用 notify 容易发生死锁，一般使用 notifyAll；</p>\n<p>4、关于 wait 和 sleep 的详细区别请翻阅 《<a href=\"https://mp.weixin.qq.com/s/gvaksKy2ss90bsybCnajpQ\">多线程 sleep 和 wait 的 5 个区别</a>》这篇文章。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\tObject lock = new Object();</span><br><span class=\"line\">\tThread t1 = new Thread(() -&gt; &#123;</span><br><span class=\"line\">\t\tsynchronized (lock) &#123;</span><br><span class=\"line\">\t\t\tfor (int i = 0; i &lt; 20; i++) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.print(i);</span><br><span class=\"line\">\t\t\t\tif (i == 10) &#123;</span><br><span class=\"line\">\t\t\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\t\t\tlock.wait();</span><br><span class=\"line\">\t\t\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tThread t2 = new Thread(() -&gt; &#123;</span><br><span class=\"line\">\t\tsynchronized (lock) &#123;</span><br><span class=\"line\">\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\tThread.sleep(5000);</span><br><span class=\"line\">\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tSystem.out.print(&quot;Java技术&quot;);</span><br><span class=\"line\">\t\t\tlock.notifyAll();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tt1.start();</span><br><span class=\"line\">\tt2.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子结合 wait&#x2F; notifyAll 来演示了它们的相互作用。</p>\n<p>线程 t1 首先输出 <code>012345678910</code>，5秒后继续输出 <code>Java技术111213141516171819</code>。</p>\n"},{"title":"并行任务执行神器 Fork & Join 实战","date":"2025-10-14T06:42:34.000Z","_content":"\n#### Fork/Join是什么？\n\nFork/Join框架是Java7提供的并行执行任务框架，思想是将大任务分解成小任务，然后小任务又可以继续分解，然后每个小任务分别计算出结果再合并起来，最后将汇总的结果作为大任务结果。其思想和MapReduce的思想非常类似。对于任务的分割，要求各个子任务之间相互独立，能够并行独立地执行任务，互相之间不影响。\n\n**Fork/Join的运行流程图如下：**\n\n![image](https://res.infoq.com/articles/fork-join-introduction/zh/resources/21.png)\n\n我们可以通过Fork/Join单词字面上的意思去理解这个框架。Fork是叉子分叉的意思，即将大任务分解成并行的小任务，Join是连接结合的意思，即将所有并行的小任务的执行结果汇总起来。\n\n![image](http://java.boot.by/ocpjp7-upgrade/images/040501.gif)\n\n#### 工作窃取算法\n\nForkJoin采用了工作窃取（work-stealing）算法，若一个工作线程的任务队列为空没有任务执行时，便从其他工作线程中获取任务主动执行。为了实现工作窃取，在工作线程中维护了双端队列，窃取任务线程从队尾获取任务，被窃取任务线程从队头获取任务。这种机制充分利用线程进行并行计算，减少了线程竞争。但是当队列中只存在一个任务了时，两个线程去取反而会造成资源浪费。\n\n**工作窃取的运行流程图如下：**\n\n![image](https://res.infoq.com/articles/fork-join-introduction/zh/resources/image3.png)\n\n#### Fork/Join核心类\n\nFork/Join框架主要由子任务、任务调度两部分组成，类层次图如下。\n\n![image](http://img.blog.csdn.net/20160720172854109)\n\n- **ForkJoinPool**\n\nForkJoinPool是ForkJoin框架中的任务调度器，和ThreadPoolExecutor一样实现了自己的线程池，提供了三种调度子任务的方法：\n\n1. execute：异步执行指定任务，无返回结果；\n1. invoke、invokeAll：异步执行指定任务，等待完成才返回结果；\n1. submit：异步执行指定任务，并立即返回一个Future对象；\n\n- **ForkJoinTask**\n\nFork/Join框架中的实际的执行任务类，有以下两种实现，一般继承这两种实现类即可。\n\n1. RecursiveAction：用于无结果返回的子任务；\n1. RecursiveTask：用于有结果返回的子任务；\n\n#### Fork/Join框架实战\n\n下面实现一个Fork/Join小例子，从1+2+...10亿，每个任务只能处理1000个数相加，超过1000个的自动分解成小任务并行处理；并展示了通过不使用Fork/Join和使用时的时间损耗对比。\n\n```\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.RecursiveTask;\n\npublic class ForkJoinTask extends RecursiveTask<Long> {\n\n\tprivate static final long MAX = 1000000000L;\n\tprivate static final long THRESHOLD = 1000L;\n\tprivate long start;\n\tprivate long end;\n\n\tpublic ForkJoinTask(long start, long end) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttest();\n\t\tSystem.out.println(\"--------------------\");\n\t\ttestForkJoin();\n\t}\n\n\tprivate static void test() {\n\t\tSystem.out.println(\"test\");\n\t\tlong start = System.currentTimeMillis();\n\t\tLong sum = 0L;\n\t\tfor (long i = 0L; i <= MAX; i++) {\n\t\t\tsum += i;\n\t\t}\n\t\tSystem.out.println(sum);\n\t\tSystem.out.println(System.currentTimeMillis() - start + \"ms\");\n\t}\n\n\tprivate static void testForkJoin() {\n\t\tSystem.out.println(\"testForkJoin\");\n\t\tlong start = System.currentTimeMillis();\n\t\tForkJoinPool forkJoinPool = new ForkJoinPool();\n\t\tLong sum = forkJoinPool.invoke(new ForkJoinTask(1, MAX));\n\t\tSystem.out.println(sum);\n\t\tSystem.out.println(System.currentTimeMillis() - start + \"ms\");\n\t}\n\n\t@Override\n\tprotected Long compute() {\n\t\tlong sum = 0;\n\t\tif (end - start <= THRESHOLD) {\n\t\t\tfor (long i = start; i <= end; i++) {\n\t\t\t\tsum += i;\n\t\t\t}\n\t\t\treturn sum;\n\t\t} else {\n\t\t\tlong mid = (start + end) / 2;\n\n\t\t\tForkJoinTask task1 = new ForkJoinTask(start, mid);\n\t\t\ttask1.fork();\n\n\t\t\tForkJoinTask task2 = new ForkJoinTask(mid + 1, end);\n\t\t\ttask2.fork();\n\n\t\t\treturn task1.join() + task2.join();\n\t\t}\n\t}\n\n}\n```\n\n这里需要计算结果，所以任务继承的是RecursiveTask类。ForkJoinTask需要实现compute方法，在这个方法里首先需要判断任务是否小于等于阈值1000，如果是就直接执行任务。否则分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成孙任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会阻塞并等待子任务执行完并得到其结果。\n\n程序输出：\n\n```\ntest\n500000000500000000\n4992ms\n--------------------\ntestForkJoin\n500000000500000000\n508ms\n```\n从结果看出，并行的时间损耗明显要少于串行的，这就是并行任务的好处。\n\n尽管如此，在使用Fork/Join时也得注意，不要盲目使用。\n\n1. 如果任务拆解的很深，系统内的线程数量堆积，导致系统性能性能严重下降；\n1. 如果函数的调用栈很深，会导致栈内存溢出；","source":"_posts/并行任务执行神器 Fork & Join 实战.md","raw":"---\ntitle: 并行任务执行神器 Fork & Join 实战\ndate: 2025-10-14 14:42:34\ntags: 多线程\n---\n\n#### Fork/Join是什么？\n\nFork/Join框架是Java7提供的并行执行任务框架，思想是将大任务分解成小任务，然后小任务又可以继续分解，然后每个小任务分别计算出结果再合并起来，最后将汇总的结果作为大任务结果。其思想和MapReduce的思想非常类似。对于任务的分割，要求各个子任务之间相互独立，能够并行独立地执行任务，互相之间不影响。\n\n**Fork/Join的运行流程图如下：**\n\n![image](https://res.infoq.com/articles/fork-join-introduction/zh/resources/21.png)\n\n我们可以通过Fork/Join单词字面上的意思去理解这个框架。Fork是叉子分叉的意思，即将大任务分解成并行的小任务，Join是连接结合的意思，即将所有并行的小任务的执行结果汇总起来。\n\n![image](http://java.boot.by/ocpjp7-upgrade/images/040501.gif)\n\n#### 工作窃取算法\n\nForkJoin采用了工作窃取（work-stealing）算法，若一个工作线程的任务队列为空没有任务执行时，便从其他工作线程中获取任务主动执行。为了实现工作窃取，在工作线程中维护了双端队列，窃取任务线程从队尾获取任务，被窃取任务线程从队头获取任务。这种机制充分利用线程进行并行计算，减少了线程竞争。但是当队列中只存在一个任务了时，两个线程去取反而会造成资源浪费。\n\n**工作窃取的运行流程图如下：**\n\n![image](https://res.infoq.com/articles/fork-join-introduction/zh/resources/image3.png)\n\n#### Fork/Join核心类\n\nFork/Join框架主要由子任务、任务调度两部分组成，类层次图如下。\n\n![image](http://img.blog.csdn.net/20160720172854109)\n\n- **ForkJoinPool**\n\nForkJoinPool是ForkJoin框架中的任务调度器，和ThreadPoolExecutor一样实现了自己的线程池，提供了三种调度子任务的方法：\n\n1. execute：异步执行指定任务，无返回结果；\n1. invoke、invokeAll：异步执行指定任务，等待完成才返回结果；\n1. submit：异步执行指定任务，并立即返回一个Future对象；\n\n- **ForkJoinTask**\n\nFork/Join框架中的实际的执行任务类，有以下两种实现，一般继承这两种实现类即可。\n\n1. RecursiveAction：用于无结果返回的子任务；\n1. RecursiveTask：用于有结果返回的子任务；\n\n#### Fork/Join框架实战\n\n下面实现一个Fork/Join小例子，从1+2+...10亿，每个任务只能处理1000个数相加，超过1000个的自动分解成小任务并行处理；并展示了通过不使用Fork/Join和使用时的时间损耗对比。\n\n```\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.RecursiveTask;\n\npublic class ForkJoinTask extends RecursiveTask<Long> {\n\n\tprivate static final long MAX = 1000000000L;\n\tprivate static final long THRESHOLD = 1000L;\n\tprivate long start;\n\tprivate long end;\n\n\tpublic ForkJoinTask(long start, long end) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttest();\n\t\tSystem.out.println(\"--------------------\");\n\t\ttestForkJoin();\n\t}\n\n\tprivate static void test() {\n\t\tSystem.out.println(\"test\");\n\t\tlong start = System.currentTimeMillis();\n\t\tLong sum = 0L;\n\t\tfor (long i = 0L; i <= MAX; i++) {\n\t\t\tsum += i;\n\t\t}\n\t\tSystem.out.println(sum);\n\t\tSystem.out.println(System.currentTimeMillis() - start + \"ms\");\n\t}\n\n\tprivate static void testForkJoin() {\n\t\tSystem.out.println(\"testForkJoin\");\n\t\tlong start = System.currentTimeMillis();\n\t\tForkJoinPool forkJoinPool = new ForkJoinPool();\n\t\tLong sum = forkJoinPool.invoke(new ForkJoinTask(1, MAX));\n\t\tSystem.out.println(sum);\n\t\tSystem.out.println(System.currentTimeMillis() - start + \"ms\");\n\t}\n\n\t@Override\n\tprotected Long compute() {\n\t\tlong sum = 0;\n\t\tif (end - start <= THRESHOLD) {\n\t\t\tfor (long i = start; i <= end; i++) {\n\t\t\t\tsum += i;\n\t\t\t}\n\t\t\treturn sum;\n\t\t} else {\n\t\t\tlong mid = (start + end) / 2;\n\n\t\t\tForkJoinTask task1 = new ForkJoinTask(start, mid);\n\t\t\ttask1.fork();\n\n\t\t\tForkJoinTask task2 = new ForkJoinTask(mid + 1, end);\n\t\t\ttask2.fork();\n\n\t\t\treturn task1.join() + task2.join();\n\t\t}\n\t}\n\n}\n```\n\n这里需要计算结果，所以任务继承的是RecursiveTask类。ForkJoinTask需要实现compute方法，在这个方法里首先需要判断任务是否小于等于阈值1000，如果是就直接执行任务。否则分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成孙任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会阻塞并等待子任务执行完并得到其结果。\n\n程序输出：\n\n```\ntest\n500000000500000000\n4992ms\n--------------------\ntestForkJoin\n500000000500000000\n508ms\n```\n从结果看出，并行的时间损耗明显要少于串行的，这就是并行任务的好处。\n\n尽管如此，在使用Fork/Join时也得注意，不要盲目使用。\n\n1. 如果任务拆解的很深，系统内的线程数量堆积，导致系统性能性能严重下降；\n1. 如果函数的调用栈很深，会导致栈内存溢出；","slug":"并行任务执行神器 Fork & Join 实战","published":1,"updated":"2025-10-14T07:16:33.121Z","_id":"cmgq8aw8o000shod4ag8h7k29","comments":1,"layout":"post","photos":[],"content":"<h4 id=\"Fork-Join是什么？\"><a href=\"#Fork-Join是什么？\" class=\"headerlink\" title=\"Fork&#x2F;Join是什么？\"></a>Fork&#x2F;Join是什么？</h4><p>Fork&#x2F;Join框架是Java7提供的并行执行任务框架，思想是将大任务分解成小任务，然后小任务又可以继续分解，然后每个小任务分别计算出结果再合并起来，最后将汇总的结果作为大任务结果。其思想和MapReduce的思想非常类似。对于任务的分割，要求各个子任务之间相互独立，能够并行独立地执行任务，互相之间不影响。</p>\n<p><strong>Fork&#x2F;Join的运行流程图如下：</strong></p>\n<p><img src=\"https://res.infoq.com/articles/fork-join-introduction/zh/resources/21.png\" alt=\"image\"></p>\n<p>我们可以通过Fork&#x2F;Join单词字面上的意思去理解这个框架。Fork是叉子分叉的意思，即将大任务分解成并行的小任务，Join是连接结合的意思，即将所有并行的小任务的执行结果汇总起来。</p>\n<p><img src=\"http://java.boot.by/ocpjp7-upgrade/images/040501.gif\" alt=\"image\"></p>\n<h4 id=\"工作窃取算法\"><a href=\"#工作窃取算法\" class=\"headerlink\" title=\"工作窃取算法\"></a>工作窃取算法</h4><p>ForkJoin采用了工作窃取（work-stealing）算法，若一个工作线程的任务队列为空没有任务执行时，便从其他工作线程中获取任务主动执行。为了实现工作窃取，在工作线程中维护了双端队列，窃取任务线程从队尾获取任务，被窃取任务线程从队头获取任务。这种机制充分利用线程进行并行计算，减少了线程竞争。但是当队列中只存在一个任务了时，两个线程去取反而会造成资源浪费。</p>\n<p><strong>工作窃取的运行流程图如下：</strong></p>\n<p><img src=\"https://res.infoq.com/articles/fork-join-introduction/zh/resources/image3.png\" alt=\"image\"></p>\n<h4 id=\"Fork-Join核心类\"><a href=\"#Fork-Join核心类\" class=\"headerlink\" title=\"Fork&#x2F;Join核心类\"></a>Fork&#x2F;Join核心类</h4><p>Fork&#x2F;Join框架主要由子任务、任务调度两部分组成，类层次图如下。</p>\n<p><img src=\"http://img.blog.csdn.net/20160720172854109\" alt=\"image\"></p>\n<ul>\n<li><strong>ForkJoinPool</strong></li>\n</ul>\n<p>ForkJoinPool是ForkJoin框架中的任务调度器，和ThreadPoolExecutor一样实现了自己的线程池，提供了三种调度子任务的方法：</p>\n<ol>\n<li>execute：异步执行指定任务，无返回结果；</li>\n<li>invoke、invokeAll：异步执行指定任务，等待完成才返回结果；</li>\n<li>submit：异步执行指定任务，并立即返回一个Future对象；</li>\n</ol>\n<ul>\n<li><strong>ForkJoinTask</strong></li>\n</ul>\n<p>Fork&#x2F;Join框架中的实际的执行任务类，有以下两种实现，一般继承这两种实现类即可。</p>\n<ol>\n<li>RecursiveAction：用于无结果返回的子任务；</li>\n<li>RecursiveTask：用于有结果返回的子任务；</li>\n</ol>\n<h4 id=\"Fork-Join框架实战\"><a href=\"#Fork-Join框架实战\" class=\"headerlink\" title=\"Fork&#x2F;Join框架实战\"></a>Fork&#x2F;Join框架实战</h4><p>下面实现一个Fork&#x2F;Join小例子，从1+2+…10亿，每个任务只能处理1000个数相加，超过1000个的自动分解成小任务并行处理；并展示了通过不使用Fork&#x2F;Join和使用时的时间损耗对比。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.concurrent.ForkJoinPool;</span><br><span class=\"line\">import java.util.concurrent.RecursiveTask;</span><br><span class=\"line\"></span><br><span class=\"line\">public class ForkJoinTask extends RecursiveTask&lt;Long&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static final long MAX = 1000000000L;</span><br><span class=\"line\">\tprivate static final long THRESHOLD = 1000L;</span><br><span class=\"line\">\tprivate long start;</span><br><span class=\"line\">\tprivate long end;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic ForkJoinTask(long start, long end) &#123;</span><br><span class=\"line\">\t\tthis.start = start;</span><br><span class=\"line\">\t\tthis.end = end;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\ttest();</span><br><span class=\"line\">\t\tSystem.out.println(&quot;--------------------&quot;);</span><br><span class=\"line\">\t\ttestForkJoin();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static void test() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;test&quot;);</span><br><span class=\"line\">\t\tlong start = System.currentTimeMillis();</span><br><span class=\"line\">\t\tLong sum = 0L;</span><br><span class=\"line\">\t\tfor (long i = 0L; i &lt;= MAX; i++) &#123;</span><br><span class=\"line\">\t\t\tsum += i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tSystem.out.println(sum);</span><br><span class=\"line\">\t\tSystem.out.println(System.currentTimeMillis() - start + &quot;ms&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static void testForkJoin() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;testForkJoin&quot;);</span><br><span class=\"line\">\t\tlong start = System.currentTimeMillis();</span><br><span class=\"line\">\t\tForkJoinPool forkJoinPool = new ForkJoinPool();</span><br><span class=\"line\">\t\tLong sum = forkJoinPool.invoke(new ForkJoinTask(1, MAX));</span><br><span class=\"line\">\t\tSystem.out.println(sum);</span><br><span class=\"line\">\t\tSystem.out.println(System.currentTimeMillis() - start + &quot;ms&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected Long compute() &#123;</span><br><span class=\"line\">\t\tlong sum = 0;</span><br><span class=\"line\">\t\tif (end - start &lt;= THRESHOLD) &#123;</span><br><span class=\"line\">\t\t\tfor (long i = start; i &lt;= end; i++) &#123;</span><br><span class=\"line\">\t\t\t\tsum += i;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn sum;</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tlong mid = (start + end) / 2;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tForkJoinTask task1 = new ForkJoinTask(start, mid);</span><br><span class=\"line\">\t\t\ttask1.fork();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tForkJoinTask task2 = new ForkJoinTask(mid + 1, end);</span><br><span class=\"line\">\t\t\ttask2.fork();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\treturn task1.join() + task2.join();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要计算结果，所以任务继承的是RecursiveTask类。ForkJoinTask需要实现compute方法，在这个方法里首先需要判断任务是否小于等于阈值1000，如果是就直接执行任务。否则分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成孙任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会阻塞并等待子任务执行完并得到其结果。</p>\n<p>程序输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test</span><br><span class=\"line\">500000000500000000</span><br><span class=\"line\">4992ms</span><br><span class=\"line\">--------------------</span><br><span class=\"line\">testForkJoin</span><br><span class=\"line\">500000000500000000</span><br><span class=\"line\">508ms</span><br></pre></td></tr></table></figure>\n<p>从结果看出，并行的时间损耗明显要少于串行的，这就是并行任务的好处。</p>\n<p>尽管如此，在使用Fork&#x2F;Join时也得注意，不要盲目使用。</p>\n<ol>\n<li>如果任务拆解的很深，系统内的线程数量堆积，导致系统性能性能严重下降；</li>\n<li>如果函数的调用栈很深，会导致栈内存溢出；</li>\n</ol>\n","excerpt":"","more":"<h4 id=\"Fork-Join是什么？\"><a href=\"#Fork-Join是什么？\" class=\"headerlink\" title=\"Fork&#x2F;Join是什么？\"></a>Fork&#x2F;Join是什么？</h4><p>Fork&#x2F;Join框架是Java7提供的并行执行任务框架，思想是将大任务分解成小任务，然后小任务又可以继续分解，然后每个小任务分别计算出结果再合并起来，最后将汇总的结果作为大任务结果。其思想和MapReduce的思想非常类似。对于任务的分割，要求各个子任务之间相互独立，能够并行独立地执行任务，互相之间不影响。</p>\n<p><strong>Fork&#x2F;Join的运行流程图如下：</strong></p>\n<p><img src=\"https://res.infoq.com/articles/fork-join-introduction/zh/resources/21.png\" alt=\"image\"></p>\n<p>我们可以通过Fork&#x2F;Join单词字面上的意思去理解这个框架。Fork是叉子分叉的意思，即将大任务分解成并行的小任务，Join是连接结合的意思，即将所有并行的小任务的执行结果汇总起来。</p>\n<p><img src=\"http://java.boot.by/ocpjp7-upgrade/images/040501.gif\" alt=\"image\"></p>\n<h4 id=\"工作窃取算法\"><a href=\"#工作窃取算法\" class=\"headerlink\" title=\"工作窃取算法\"></a>工作窃取算法</h4><p>ForkJoin采用了工作窃取（work-stealing）算法，若一个工作线程的任务队列为空没有任务执行时，便从其他工作线程中获取任务主动执行。为了实现工作窃取，在工作线程中维护了双端队列，窃取任务线程从队尾获取任务，被窃取任务线程从队头获取任务。这种机制充分利用线程进行并行计算，减少了线程竞争。但是当队列中只存在一个任务了时，两个线程去取反而会造成资源浪费。</p>\n<p><strong>工作窃取的运行流程图如下：</strong></p>\n<p><img src=\"https://res.infoq.com/articles/fork-join-introduction/zh/resources/image3.png\" alt=\"image\"></p>\n<h4 id=\"Fork-Join核心类\"><a href=\"#Fork-Join核心类\" class=\"headerlink\" title=\"Fork&#x2F;Join核心类\"></a>Fork&#x2F;Join核心类</h4><p>Fork&#x2F;Join框架主要由子任务、任务调度两部分组成，类层次图如下。</p>\n<p><img src=\"http://img.blog.csdn.net/20160720172854109\" alt=\"image\"></p>\n<ul>\n<li><strong>ForkJoinPool</strong></li>\n</ul>\n<p>ForkJoinPool是ForkJoin框架中的任务调度器，和ThreadPoolExecutor一样实现了自己的线程池，提供了三种调度子任务的方法：</p>\n<ol>\n<li>execute：异步执行指定任务，无返回结果；</li>\n<li>invoke、invokeAll：异步执行指定任务，等待完成才返回结果；</li>\n<li>submit：异步执行指定任务，并立即返回一个Future对象；</li>\n</ol>\n<ul>\n<li><strong>ForkJoinTask</strong></li>\n</ul>\n<p>Fork&#x2F;Join框架中的实际的执行任务类，有以下两种实现，一般继承这两种实现类即可。</p>\n<ol>\n<li>RecursiveAction：用于无结果返回的子任务；</li>\n<li>RecursiveTask：用于有结果返回的子任务；</li>\n</ol>\n<h4 id=\"Fork-Join框架实战\"><a href=\"#Fork-Join框架实战\" class=\"headerlink\" title=\"Fork&#x2F;Join框架实战\"></a>Fork&#x2F;Join框架实战</h4><p>下面实现一个Fork&#x2F;Join小例子，从1+2+…10亿，每个任务只能处理1000个数相加，超过1000个的自动分解成小任务并行处理；并展示了通过不使用Fork&#x2F;Join和使用时的时间损耗对比。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.concurrent.ForkJoinPool;</span><br><span class=\"line\">import java.util.concurrent.RecursiveTask;</span><br><span class=\"line\"></span><br><span class=\"line\">public class ForkJoinTask extends RecursiveTask&lt;Long&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static final long MAX = 1000000000L;</span><br><span class=\"line\">\tprivate static final long THRESHOLD = 1000L;</span><br><span class=\"line\">\tprivate long start;</span><br><span class=\"line\">\tprivate long end;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic ForkJoinTask(long start, long end) &#123;</span><br><span class=\"line\">\t\tthis.start = start;</span><br><span class=\"line\">\t\tthis.end = end;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\ttest();</span><br><span class=\"line\">\t\tSystem.out.println(&quot;--------------------&quot;);</span><br><span class=\"line\">\t\ttestForkJoin();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static void test() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;test&quot;);</span><br><span class=\"line\">\t\tlong start = System.currentTimeMillis();</span><br><span class=\"line\">\t\tLong sum = 0L;</span><br><span class=\"line\">\t\tfor (long i = 0L; i &lt;= MAX; i++) &#123;</span><br><span class=\"line\">\t\t\tsum += i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tSystem.out.println(sum);</span><br><span class=\"line\">\t\tSystem.out.println(System.currentTimeMillis() - start + &quot;ms&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static void testForkJoin() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;testForkJoin&quot;);</span><br><span class=\"line\">\t\tlong start = System.currentTimeMillis();</span><br><span class=\"line\">\t\tForkJoinPool forkJoinPool = new ForkJoinPool();</span><br><span class=\"line\">\t\tLong sum = forkJoinPool.invoke(new ForkJoinTask(1, MAX));</span><br><span class=\"line\">\t\tSystem.out.println(sum);</span><br><span class=\"line\">\t\tSystem.out.println(System.currentTimeMillis() - start + &quot;ms&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tprotected Long compute() &#123;</span><br><span class=\"line\">\t\tlong sum = 0;</span><br><span class=\"line\">\t\tif (end - start &lt;= THRESHOLD) &#123;</span><br><span class=\"line\">\t\t\tfor (long i = start; i &lt;= end; i++) &#123;</span><br><span class=\"line\">\t\t\t\tsum += i;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\treturn sum;</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tlong mid = (start + end) / 2;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tForkJoinTask task1 = new ForkJoinTask(start, mid);</span><br><span class=\"line\">\t\t\ttask1.fork();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tForkJoinTask task2 = new ForkJoinTask(mid + 1, end);</span><br><span class=\"line\">\t\t\ttask2.fork();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\treturn task1.join() + task2.join();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要计算结果，所以任务继承的是RecursiveTask类。ForkJoinTask需要实现compute方法，在这个方法里首先需要判断任务是否小于等于阈值1000，如果是就直接执行任务。否则分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成孙任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会阻塞并等待子任务执行完并得到其结果。</p>\n<p>程序输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test</span><br><span class=\"line\">500000000500000000</span><br><span class=\"line\">4992ms</span><br><span class=\"line\">--------------------</span><br><span class=\"line\">testForkJoin</span><br><span class=\"line\">500000000500000000</span><br><span class=\"line\">508ms</span><br></pre></td></tr></table></figure>\n<p>从结果看出，并行的时间损耗明显要少于串行的，这就是并行任务的好处。</p>\n<p>尽管如此，在使用Fork&#x2F;Join时也得注意，不要盲目使用。</p>\n<ol>\n<li>如果任务拆解的很深，系统内的线程数量堆积，导致系统性能性能严重下降；</li>\n<li>如果函数的调用栈很深，会导致栈内存溢出；</li>\n</ol>\n"},{"title":"一张图搞清楚Java异常机制","date":"2025-10-14T06:42:34.000Z","_content":"\n下面是Java异常类的组织结构，红色区域的异常类表示是程序需要显示捕捉或者抛出的。\n\n![image](https://www.programcreek.com/wp-content/uploads/2009/02/Exception-Hierarchy-Diagram.jpeg)\n\n### Throwable\nThrowable是Java异常的顶级类，所有的异常都继承于这个类。\n\nError，Exception是异常类的两个大分类。\n\n### Error\n\nError是非程序异常，即程序不能捕获的异常，一般是编译或者系统性的错误，如OutOfMemorry内存溢出异常等。\n\n### Exception\nException是程序异常类，由程序内部产生。Exception又分为运行时异常、非运行时异常。\n\n#### 运行时异常\n\n运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过，运行时异常可处理或者不处理。运行时异常一般常出来定义系统的自定义异常，业务根据自定义异常做出不同的处理。\n\n常见的运行时异常如NullPointException、ArrayIndexOutOfBoundsException等。\n\n#### 非运行时异常\n\n非运行时异常是程序必须进行处理的异常，捕获或者抛出，如果不处理程序就不能编译通过。如常见的IOException、ClassNotFoundException等。\n\n","source":"_posts/基础/一张图搞清楚Java异常机制.md","raw":"---\ntitle: 一张图搞清楚Java异常机制\ndate: 2025-10-14 14:42:34\ntags: 基础\n---\n\n下面是Java异常类的组织结构，红色区域的异常类表示是程序需要显示捕捉或者抛出的。\n\n![image](https://www.programcreek.com/wp-content/uploads/2009/02/Exception-Hierarchy-Diagram.jpeg)\n\n### Throwable\nThrowable是Java异常的顶级类，所有的异常都继承于这个类。\n\nError，Exception是异常类的两个大分类。\n\n### Error\n\nError是非程序异常，即程序不能捕获的异常，一般是编译或者系统性的错误，如OutOfMemorry内存溢出异常等。\n\n### Exception\nException是程序异常类，由程序内部产生。Exception又分为运行时异常、非运行时异常。\n\n#### 运行时异常\n\n运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过，运行时异常可处理或者不处理。运行时异常一般常出来定义系统的自定义异常，业务根据自定义异常做出不同的处理。\n\n常见的运行时异常如NullPointException、ArrayIndexOutOfBoundsException等。\n\n#### 非运行时异常\n\n非运行时异常是程序必须进行处理的异常，捕获或者抛出，如果不处理程序就不能编译通过。如常见的IOException、ClassNotFoundException等。\n\n","slug":"基础/一张图搞清楚Java异常机制","published":1,"updated":"2025-10-14T07:36:11.263Z","_id":"cmgq8bke2000uhod410v04i8t","comments":1,"layout":"post","photos":[],"content":"<p>下面是Java异常类的组织结构，红色区域的异常类表示是程序需要显示捕捉或者抛出的。</p>\n<p><img src=\"https://www.programcreek.com/wp-content/uploads/2009/02/Exception-Hierarchy-Diagram.jpeg\" alt=\"image\"></p>\n<h3 id=\"Throwable\"><a href=\"#Throwable\" class=\"headerlink\" title=\"Throwable\"></a>Throwable</h3><p>Throwable是Java异常的顶级类，所有的异常都继承于这个类。</p>\n<p>Error，Exception是异常类的两个大分类。</p>\n<h3 id=\"Error\"><a href=\"#Error\" class=\"headerlink\" title=\"Error\"></a>Error</h3><p>Error是非程序异常，即程序不能捕获的异常，一般是编译或者系统性的错误，如OutOfMemorry内存溢出异常等。</p>\n<h3 id=\"Exception\"><a href=\"#Exception\" class=\"headerlink\" title=\"Exception\"></a>Exception</h3><p>Exception是程序异常类，由程序内部产生。Exception又分为运行时异常、非运行时异常。</p>\n<h4 id=\"运行时异常\"><a href=\"#运行时异常\" class=\"headerlink\" title=\"运行时异常\"></a>运行时异常</h4><p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过，运行时异常可处理或者不处理。运行时异常一般常出来定义系统的自定义异常，业务根据自定义异常做出不同的处理。</p>\n<p>常见的运行时异常如NullPointException、ArrayIndexOutOfBoundsException等。</p>\n<h4 id=\"非运行时异常\"><a href=\"#非运行时异常\" class=\"headerlink\" title=\"非运行时异常\"></a>非运行时异常</h4><p>非运行时异常是程序必须进行处理的异常，捕获或者抛出，如果不处理程序就不能编译通过。如常见的IOException、ClassNotFoundException等。</p>\n","excerpt":"","more":"<p>下面是Java异常类的组织结构，红色区域的异常类表示是程序需要显示捕捉或者抛出的。</p>\n<p><img src=\"https://www.programcreek.com/wp-content/uploads/2009/02/Exception-Hierarchy-Diagram.jpeg\" alt=\"image\"></p>\n<h3 id=\"Throwable\"><a href=\"#Throwable\" class=\"headerlink\" title=\"Throwable\"></a>Throwable</h3><p>Throwable是Java异常的顶级类，所有的异常都继承于这个类。</p>\n<p>Error，Exception是异常类的两个大分类。</p>\n<h3 id=\"Error\"><a href=\"#Error\" class=\"headerlink\" title=\"Error\"></a>Error</h3><p>Error是非程序异常，即程序不能捕获的异常，一般是编译或者系统性的错误，如OutOfMemorry内存溢出异常等。</p>\n<h3 id=\"Exception\"><a href=\"#Exception\" class=\"headerlink\" title=\"Exception\"></a>Exception</h3><p>Exception是程序异常类，由程序内部产生。Exception又分为运行时异常、非运行时异常。</p>\n<h4 id=\"运行时异常\"><a href=\"#运行时异常\" class=\"headerlink\" title=\"运行时异常\"></a>运行时异常</h4><p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过，运行时异常可处理或者不处理。运行时异常一般常出来定义系统的自定义异常，业务根据自定义异常做出不同的处理。</p>\n<p>常见的运行时异常如NullPointException、ArrayIndexOutOfBoundsException等。</p>\n<h4 id=\"非运行时异常\"><a href=\"#非运行时异常\" class=\"headerlink\" title=\"非运行时异常\"></a>非运行时异常</h4><p>非运行时异常是程序必须进行处理的异常，捕获或者抛出，如果不处理程序就不能编译通过。如常见的IOException、ClassNotFoundException等。</p>\n"},{"title":"Java 父类强制转换子类原则","date":"2025-10-14T06:42:34.000Z","_content":"\n![image](http://img.javastack.cn/17-12-20/25802617.jpg)\n\n最近，微信群友在讨论子类父类的转换问题，其实不难，给大家用实例来说明一下就很明了了。\n\n我们知道Java中子类转换成父类是没有任何问题的，那父类可以转换成子类吗？\n\n来看下面这段程序：\n\n```\npublic class TestObjectConvert {\n\n\tpublic static void main(String[] args) {\n\t\ttest1();\n\t\ttest2();\n\t}\n\n\tprivate static void test1() {\n\t\tFruit fruit1 = new Fruit();\n\t\tApple apple1 = new Apple();\n\t\tapple1 = (Apple) fruit1; // java.lang.ClassCastException\n\t}\n\n\tprivate static void test2() {\n\t\tFruit fruit1 = new Apple();\n\t\tApple apple1 = new Apple();\n\t\tapple1 = (Apple) fruit1;\n\t}\n\n\tstatic class Fruit {\n\n\t}\n\n\tstatic class Apple extends Fruit {\n\n\t}\n\n}\n```\n\n结果是：\n\n```\ntest1：报类转异常；\ntest2：转换正常。\n```\n\n**所以，想让父类强制转换成子类，不是没有可能，除非父类是子类构造出来的实例，不然是不能强转的。**\n\n为什么呢？\n\n如上代码，如果父类实例出来的对象是Orange，Orange当然不能强制转成Apple，所以说父类只有该子类对应的实例才能强转。\n\n\n","source":"_posts/基础/Java 父类强制转换子类原则.md","raw":"---\ntitle: Java 父类强制转换子类原则\ndate: 2025-10-14 14:42:34\ntags: 基础\n---\n\n![image](http://img.javastack.cn/17-12-20/25802617.jpg)\n\n最近，微信群友在讨论子类父类的转换问题，其实不难，给大家用实例来说明一下就很明了了。\n\n我们知道Java中子类转换成父类是没有任何问题的，那父类可以转换成子类吗？\n\n来看下面这段程序：\n\n```\npublic class TestObjectConvert {\n\n\tpublic static void main(String[] args) {\n\t\ttest1();\n\t\ttest2();\n\t}\n\n\tprivate static void test1() {\n\t\tFruit fruit1 = new Fruit();\n\t\tApple apple1 = new Apple();\n\t\tapple1 = (Apple) fruit1; // java.lang.ClassCastException\n\t}\n\n\tprivate static void test2() {\n\t\tFruit fruit1 = new Apple();\n\t\tApple apple1 = new Apple();\n\t\tapple1 = (Apple) fruit1;\n\t}\n\n\tstatic class Fruit {\n\n\t}\n\n\tstatic class Apple extends Fruit {\n\n\t}\n\n}\n```\n\n结果是：\n\n```\ntest1：报类转异常；\ntest2：转换正常。\n```\n\n**所以，想让父类强制转换成子类，不是没有可能，除非父类是子类构造出来的实例，不然是不能强转的。**\n\n为什么呢？\n\n如上代码，如果父类实例出来的对象是Orange，Orange当然不能强制转成Apple，所以说父类只有该子类对应的实例才能强转。\n\n\n","slug":"基础/Java 父类强制转换子类原则","published":1,"updated":"2025-10-14T07:36:11.232Z","_id":"cmgq8bkei000vhod4akdc1nju","comments":1,"layout":"post","photos":[],"content":"<p><img src=\"http://img.javastack.cn/17-12-20/25802617.jpg\" alt=\"image\"></p>\n<p>最近，微信群友在讨论子类父类的转换问题，其实不难，给大家用实例来说明一下就很明了了。</p>\n<p>我们知道Java中子类转换成父类是没有任何问题的，那父类可以转换成子类吗？</p>\n<p>来看下面这段程序：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestObjectConvert &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\ttest1();</span><br><span class=\"line\">\t\ttest2();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static void test1() &#123;</span><br><span class=\"line\">\t\tFruit fruit1 = new Fruit();</span><br><span class=\"line\">\t\tApple apple1 = new Apple();</span><br><span class=\"line\">\t\tapple1 = (Apple) fruit1; // java.lang.ClassCastException</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static void test2() &#123;</span><br><span class=\"line\">\t\tFruit fruit1 = new Apple();</span><br><span class=\"line\">\t\tApple apple1 = new Apple();</span><br><span class=\"line\">\t\tapple1 = (Apple) fruit1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstatic class Fruit &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstatic class Apple extends Fruit &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test1：报类转异常；</span><br><span class=\"line\">test2：转换正常。</span><br></pre></td></tr></table></figure>\n\n<p><strong>所以，想让父类强制转换成子类，不是没有可能，除非父类是子类构造出来的实例，不然是不能强转的。</strong></p>\n<p>为什么呢？</p>\n<p>如上代码，如果父类实例出来的对象是Orange，Orange当然不能强制转成Apple，所以说父类只有该子类对应的实例才能强转。</p>\n","excerpt":"","more":"<p><img src=\"http://img.javastack.cn/17-12-20/25802617.jpg\" alt=\"image\"></p>\n<p>最近，微信群友在讨论子类父类的转换问题，其实不难，给大家用实例来说明一下就很明了了。</p>\n<p>我们知道Java中子类转换成父类是没有任何问题的，那父类可以转换成子类吗？</p>\n<p>来看下面这段程序：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestObjectConvert &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\ttest1();</span><br><span class=\"line\">\t\ttest2();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static void test1() &#123;</span><br><span class=\"line\">\t\tFruit fruit1 = new Fruit();</span><br><span class=\"line\">\t\tApple apple1 = new Apple();</span><br><span class=\"line\">\t\tapple1 = (Apple) fruit1; // java.lang.ClassCastException</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static void test2() &#123;</span><br><span class=\"line\">\t\tFruit fruit1 = new Apple();</span><br><span class=\"line\">\t\tApple apple1 = new Apple();</span><br><span class=\"line\">\t\tapple1 = (Apple) fruit1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstatic class Fruit &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstatic class Apple extends Fruit &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test1：报类转异常；</span><br><span class=\"line\">test2：转换正常。</span><br></pre></td></tr></table></figure>\n\n<p><strong>所以，想让父类强制转换成子类，不是没有可能，除非父类是子类构造出来的实例，不然是不能强转的。</strong></p>\n<p>为什么呢？</p>\n<p>如上代码，如果父类实例出来的对象是Orange，Orange当然不能强制转成Apple，所以说父类只有该子类对应的实例才能强转。</p>\n"},{"title":"Java 中的基本数据类型转换详解","date":"2025-10-14T06:42:34.000Z","_content":"\n![](http://img.javastack.cn/18-4-3/88886519.jpg)\n\n说基本数据类型转换之前，先了解下 Java 中的 8 种基本数据类型，以及它们的占内存的容量大小和表示的范围，如下图所示。\n\n![](http://img.javastack.cn/18-4-3/32808656.jpg)\n\n之前分享过《[深入浅出 Java 中的包装类](https://mp.weixin.qq.com/s/uoNVT9IoRQmWnmy8w22UUQ)》，现在重新温故了下原始数据类型，现在来解释下它们之间的转换关系。\n\n#### 自动类型转换\n\n自动类型转换是指：数字表示范围小的数据类型可以自动转换成范围大的数据类型。\n\n如：\n\n```\nlong l = 100;\n\nint i = 200;\nlong ll = i;\n```\n\n具体自动转换如如下图所示。\n\n![](http://img.javastack.cn/18-4-3/42423859.jpg)\n\n实线表示自动转换时不会造成数据丢失，虚线则可能会出现数据丢失问题。\n\n**自动转换也要小心数据溢出问题，看下面的例子。**\n\n```\nint count = 100000000;\nint price = 1999;\nlong totalPrice = count * price;\n```\n\n编译没任何问题，但结果却输出的是负数，这是因为两个 int 相乘得到的结果是 int, 相乘的结果超出了 int 的代表范围。这种情况，一般把第一个数据转换成范围大的数据类型再和其他的数据进行运算。\n\n```\nint count = 100000000;\nint price = 1999;\nlong totalPrice = (long) count * price;\n```\n\n另外，向下转换时可以直接将 int 常量字面量赋值给 byte、short、char 等数据类型，而不需要强制转换，只要该常量值不超过该类型的表示范围都能自动转换。\n\n#### 强制类型转换\n\n强制类型转换我们再清楚不过了，即强制显示的把一个数据类型转换为另外一种数据类型。\n\n如：\n\n```\nshort s = 199;\nint i = s;// 199\n\ndouble d = 10.24;\nlong ll = (long) d;// 10\n```\n\n以上的转换结果都在我们的预期之内，属于正常的转换和丢失精度的情况，下面的例子就一样属于数据溢出的情况。\n\n```\nint ii = 300;\nbyte b = (byte)ii;\n```\n\n300 已经超出了 byte 类型表示的范围，所以会转换成一个毫无意义的数字。\n\n#### 类型提升\n\n所谓类型提升就是指在多种不同数据类型的表达式中，类型会自动向范围表示大的值的数据类型提升。\n\n把上面的溢出的例子再改下。\n\n```\nlong count = 100000000;\nint price = 1999;\nlong totalPrice = price * count;\n```\n\nprice 为 int 型，count 为 long 型，运算结果为 long 型，运算结果正常，没有出现溢出的情况。\n\n","source":"_posts/基础/Java 中的基本数据类型转换详解.md","raw":"---\ntitle: Java 中的基本数据类型转换详解\ndate: 2025-10-14 14:42:34\ntags: 基础\n---\n\n![](http://img.javastack.cn/18-4-3/88886519.jpg)\n\n说基本数据类型转换之前，先了解下 Java 中的 8 种基本数据类型，以及它们的占内存的容量大小和表示的范围，如下图所示。\n\n![](http://img.javastack.cn/18-4-3/32808656.jpg)\n\n之前分享过《[深入浅出 Java 中的包装类](https://mp.weixin.qq.com/s/uoNVT9IoRQmWnmy8w22UUQ)》，现在重新温故了下原始数据类型，现在来解释下它们之间的转换关系。\n\n#### 自动类型转换\n\n自动类型转换是指：数字表示范围小的数据类型可以自动转换成范围大的数据类型。\n\n如：\n\n```\nlong l = 100;\n\nint i = 200;\nlong ll = i;\n```\n\n具体自动转换如如下图所示。\n\n![](http://img.javastack.cn/18-4-3/42423859.jpg)\n\n实线表示自动转换时不会造成数据丢失，虚线则可能会出现数据丢失问题。\n\n**自动转换也要小心数据溢出问题，看下面的例子。**\n\n```\nint count = 100000000;\nint price = 1999;\nlong totalPrice = count * price;\n```\n\n编译没任何问题，但结果却输出的是负数，这是因为两个 int 相乘得到的结果是 int, 相乘的结果超出了 int 的代表范围。这种情况，一般把第一个数据转换成范围大的数据类型再和其他的数据进行运算。\n\n```\nint count = 100000000;\nint price = 1999;\nlong totalPrice = (long) count * price;\n```\n\n另外，向下转换时可以直接将 int 常量字面量赋值给 byte、short、char 等数据类型，而不需要强制转换，只要该常量值不超过该类型的表示范围都能自动转换。\n\n#### 强制类型转换\n\n强制类型转换我们再清楚不过了，即强制显示的把一个数据类型转换为另外一种数据类型。\n\n如：\n\n```\nshort s = 199;\nint i = s;// 199\n\ndouble d = 10.24;\nlong ll = (long) d;// 10\n```\n\n以上的转换结果都在我们的预期之内，属于正常的转换和丢失精度的情况，下面的例子就一样属于数据溢出的情况。\n\n```\nint ii = 300;\nbyte b = (byte)ii;\n```\n\n300 已经超出了 byte 类型表示的范围，所以会转换成一个毫无意义的数字。\n\n#### 类型提升\n\n所谓类型提升就是指在多种不同数据类型的表达式中，类型会自动向范围表示大的值的数据类型提升。\n\n把上面的溢出的例子再改下。\n\n```\nlong count = 100000000;\nint price = 1999;\nlong totalPrice = price * count;\n```\n\nprice 为 int 型，count 为 long 型，运算结果为 long 型，运算结果正常，没有出现溢出的情况。\n\n","slug":"基础/Java 中的基本数据类型转换详解","published":1,"updated":"2025-10-14T07:36:11.251Z","_id":"cmgq8bkel000whod41xx22jg0","comments":1,"layout":"post","photos":[],"content":"<p><img src=\"http://img.javastack.cn/18-4-3/88886519.jpg\"></p>\n<p>说基本数据类型转换之前，先了解下 Java 中的 8 种基本数据类型，以及它们的占内存的容量大小和表示的范围，如下图所示。</p>\n<p><img src=\"http://img.javastack.cn/18-4-3/32808656.jpg\"></p>\n<p>之前分享过《<a href=\"https://mp.weixin.qq.com/s/uoNVT9IoRQmWnmy8w22UUQ\">深入浅出 Java 中的包装类</a>》，现在重新温故了下原始数据类型，现在来解释下它们之间的转换关系。</p>\n<h4 id=\"自动类型转换\"><a href=\"#自动类型转换\" class=\"headerlink\" title=\"自动类型转换\"></a>自动类型转换</h4><p>自动类型转换是指：数字表示范围小的数据类型可以自动转换成范围大的数据类型。</p>\n<p>如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long l = 100;</span><br><span class=\"line\"></span><br><span class=\"line\">int i = 200;</span><br><span class=\"line\">long ll = i;</span><br></pre></td></tr></table></figure>\n\n<p>具体自动转换如如下图所示。</p>\n<p><img src=\"http://img.javastack.cn/18-4-3/42423859.jpg\"></p>\n<p>实线表示自动转换时不会造成数据丢失，虚线则可能会出现数据丢失问题。</p>\n<p><strong>自动转换也要小心数据溢出问题，看下面的例子。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int count = 100000000;</span><br><span class=\"line\">int price = 1999;</span><br><span class=\"line\">long totalPrice = count * price;</span><br></pre></td></tr></table></figure>\n\n<p>编译没任何问题，但结果却输出的是负数，这是因为两个 int 相乘得到的结果是 int, 相乘的结果超出了 int 的代表范围。这种情况，一般把第一个数据转换成范围大的数据类型再和其他的数据进行运算。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int count = 100000000;</span><br><span class=\"line\">int price = 1999;</span><br><span class=\"line\">long totalPrice = (long) count * price;</span><br></pre></td></tr></table></figure>\n\n<p>另外，向下转换时可以直接将 int 常量字面量赋值给 byte、short、char 等数据类型，而不需要强制转换，只要该常量值不超过该类型的表示范围都能自动转换。</p>\n<h4 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h4><p>强制类型转换我们再清楚不过了，即强制显示的把一个数据类型转换为另外一种数据类型。</p>\n<p>如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">short s = 199;</span><br><span class=\"line\">int i = s;// 199</span><br><span class=\"line\"></span><br><span class=\"line\">double d = 10.24;</span><br><span class=\"line\">long ll = (long) d;// 10</span><br></pre></td></tr></table></figure>\n\n<p>以上的转换结果都在我们的预期之内，属于正常的转换和丢失精度的情况，下面的例子就一样属于数据溢出的情况。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ii = 300;</span><br><span class=\"line\">byte b = (byte)ii;</span><br></pre></td></tr></table></figure>\n\n<p>300 已经超出了 byte 类型表示的范围，所以会转换成一个毫无意义的数字。</p>\n<h4 id=\"类型提升\"><a href=\"#类型提升\" class=\"headerlink\" title=\"类型提升\"></a>类型提升</h4><p>所谓类型提升就是指在多种不同数据类型的表达式中，类型会自动向范围表示大的值的数据类型提升。</p>\n<p>把上面的溢出的例子再改下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long count = 100000000;</span><br><span class=\"line\">int price = 1999;</span><br><span class=\"line\">long totalPrice = price * count;</span><br></pre></td></tr></table></figure>\n\n<p>price 为 int 型，count 为 long 型，运算结果为 long 型，运算结果正常，没有出现溢出的情况。</p>\n","excerpt":"","more":"<p><img src=\"http://img.javastack.cn/18-4-3/88886519.jpg\"></p>\n<p>说基本数据类型转换之前，先了解下 Java 中的 8 种基本数据类型，以及它们的占内存的容量大小和表示的范围，如下图所示。</p>\n<p><img src=\"http://img.javastack.cn/18-4-3/32808656.jpg\"></p>\n<p>之前分享过《<a href=\"https://mp.weixin.qq.com/s/uoNVT9IoRQmWnmy8w22UUQ\">深入浅出 Java 中的包装类</a>》，现在重新温故了下原始数据类型，现在来解释下它们之间的转换关系。</p>\n<h4 id=\"自动类型转换\"><a href=\"#自动类型转换\" class=\"headerlink\" title=\"自动类型转换\"></a>自动类型转换</h4><p>自动类型转换是指：数字表示范围小的数据类型可以自动转换成范围大的数据类型。</p>\n<p>如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long l = 100;</span><br><span class=\"line\"></span><br><span class=\"line\">int i = 200;</span><br><span class=\"line\">long ll = i;</span><br></pre></td></tr></table></figure>\n\n<p>具体自动转换如如下图所示。</p>\n<p><img src=\"http://img.javastack.cn/18-4-3/42423859.jpg\"></p>\n<p>实线表示自动转换时不会造成数据丢失，虚线则可能会出现数据丢失问题。</p>\n<p><strong>自动转换也要小心数据溢出问题，看下面的例子。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int count = 100000000;</span><br><span class=\"line\">int price = 1999;</span><br><span class=\"line\">long totalPrice = count * price;</span><br></pre></td></tr></table></figure>\n\n<p>编译没任何问题，但结果却输出的是负数，这是因为两个 int 相乘得到的结果是 int, 相乘的结果超出了 int 的代表范围。这种情况，一般把第一个数据转换成范围大的数据类型再和其他的数据进行运算。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int count = 100000000;</span><br><span class=\"line\">int price = 1999;</span><br><span class=\"line\">long totalPrice = (long) count * price;</span><br></pre></td></tr></table></figure>\n\n<p>另外，向下转换时可以直接将 int 常量字面量赋值给 byte、short、char 等数据类型，而不需要强制转换，只要该常量值不超过该类型的表示范围都能自动转换。</p>\n<h4 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h4><p>强制类型转换我们再清楚不过了，即强制显示的把一个数据类型转换为另外一种数据类型。</p>\n<p>如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">short s = 199;</span><br><span class=\"line\">int i = s;// 199</span><br><span class=\"line\"></span><br><span class=\"line\">double d = 10.24;</span><br><span class=\"line\">long ll = (long) d;// 10</span><br></pre></td></tr></table></figure>\n\n<p>以上的转换结果都在我们的预期之内，属于正常的转换和丢失精度的情况，下面的例子就一样属于数据溢出的情况。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int ii = 300;</span><br><span class=\"line\">byte b = (byte)ii;</span><br></pre></td></tr></table></figure>\n\n<p>300 已经超出了 byte 类型表示的范围，所以会转换成一个毫无意义的数字。</p>\n<h4 id=\"类型提升\"><a href=\"#类型提升\" class=\"headerlink\" title=\"类型提升\"></a>类型提升</h4><p>所谓类型提升就是指在多种不同数据类型的表达式中，类型会自动向范围表示大的值的数据类型提升。</p>\n<p>把上面的溢出的例子再改下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long count = 100000000;</span><br><span class=\"line\">int price = 1999;</span><br><span class=\"line\">long totalPrice = price * count;</span><br></pre></td></tr></table></figure>\n\n<p>price 为 int 型，count 为 long 型，运算结果为 long 型，运算结果正常，没有出现溢出的情况。</p>\n"},{"title":"关于Java序列化你应该知道的一切","date":"2025-10-14T06:42:34.000Z","_content":"\n## 什么是序列化\n\n我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。\n\nJava序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。\n\n## 怎么序列化一个对象？\n\n要序列化一个对象，这个对象所在类就必须实现Java序列化的接口：java.io.Serializable。\n\n##### 1、类添加序列化接口\n```\nimport java.io.Serializable;\n\npublic class User implements Serializable{\n\n    private static final long serialVersionUID = -8475669200846811112L;\n\n    private String username;\n    private String address;\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"username='\" + username + '\\'' +\n                \", address='\" + address + '\\'' +\n                '}';\n    }\n    \n}\n```\n\n##### 2、序列化/反序列化\n\n可以借助commons-lang3工具包里面的类实现对象的序列化及反序列化，你没有必要自己写。\n\n```\nimport org.apache.commons.lang3.SerializationUtils;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        User user = new User();\n        user.setUsername(\"Java\");\n        user.setAddress(\"China\");\n        byte[] bytes = SerializationUtils.serialize(user);\n\n        User u = SerializationUtils.deserialize(bytes);\n        System.out.println(u);\n\n    }\n\n}\n```\n输出：\n```\nUser{username='Java', address='China'}\n```\n上例通过序列化对象字节到内存然后反序列化，当然里面也提供了序列化磁盘然后再反序列化的方法，原理都是一样的，只是目标地不一样。\n\n## 序列化注意事项\n\n- 序列化对象必须实现序列化接口。\n\n- 序列化对象里面的属性是对象的话也要实现序列化接口。\n\n- 类的对象序列化后，类的序列化ID不能轻易修改，不然反序列化会失败。\n\n- 类的对象序列化后，类的属性有增加或者删除不会影响序列化，只是值会丢失。\n\n- 如果父类序列化了，子类会继承父类的序列化，子类无需添加序列化接口。\n\n- 如果父类没有序列化，子类序列化了，子类中的属性能正常序列化，但父类的属性会丢失，不能序列化。\n\n- 用Java序列化的二进制字节数据只能由Java反序列化，不能被其他语言反序列化。如果要进行前后端或者不同语言之间的交互一般需要将对象转变成Json/Xml通用格式的数据，再恢复原来的对象。\n\n","source":"_posts/基础/关于Java序列化你应该知道的一切.md","raw":"---\ntitle: 关于Java序列化你应该知道的一切\ndate: 2025-10-14 14:42:34\ntags: 基础\n---\n\n## 什么是序列化\n\n我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。\n\nJava序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。\n\n## 怎么序列化一个对象？\n\n要序列化一个对象，这个对象所在类就必须实现Java序列化的接口：java.io.Serializable。\n\n##### 1、类添加序列化接口\n```\nimport java.io.Serializable;\n\npublic class User implements Serializable{\n\n    private static final long serialVersionUID = -8475669200846811112L;\n\n    private String username;\n    private String address;\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"username='\" + username + '\\'' +\n                \", address='\" + address + '\\'' +\n                '}';\n    }\n    \n}\n```\n\n##### 2、序列化/反序列化\n\n可以借助commons-lang3工具包里面的类实现对象的序列化及反序列化，你没有必要自己写。\n\n```\nimport org.apache.commons.lang3.SerializationUtils;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        User user = new User();\n        user.setUsername(\"Java\");\n        user.setAddress(\"China\");\n        byte[] bytes = SerializationUtils.serialize(user);\n\n        User u = SerializationUtils.deserialize(bytes);\n        System.out.println(u);\n\n    }\n\n}\n```\n输出：\n```\nUser{username='Java', address='China'}\n```\n上例通过序列化对象字节到内存然后反序列化，当然里面也提供了序列化磁盘然后再反序列化的方法，原理都是一样的，只是目标地不一样。\n\n## 序列化注意事项\n\n- 序列化对象必须实现序列化接口。\n\n- 序列化对象里面的属性是对象的话也要实现序列化接口。\n\n- 类的对象序列化后，类的序列化ID不能轻易修改，不然反序列化会失败。\n\n- 类的对象序列化后，类的属性有增加或者删除不会影响序列化，只是值会丢失。\n\n- 如果父类序列化了，子类会继承父类的序列化，子类无需添加序列化接口。\n\n- 如果父类没有序列化，子类序列化了，子类中的属性能正常序列化，但父类的属性会丢失，不能序列化。\n\n- 用Java序列化的二进制字节数据只能由Java反序列化，不能被其他语言反序列化。如果要进行前后端或者不同语言之间的交互一般需要将对象转变成Json/Xml通用格式的数据，再恢复原来的对象。\n\n","slug":"基础/关于Java序列化你应该知道的一切","published":1,"updated":"2025-10-14T07:32:45.030Z","_id":"cmgq8bkey000xhod4gyix6y97","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"什么是序列化\"><a href=\"#什么是序列化\" class=\"headerlink\" title=\"什么是序列化\"></a>什么是序列化</h2><p>我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。</p>\n<p>Java序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。</p>\n<h2 id=\"怎么序列化一个对象？\"><a href=\"#怎么序列化一个对象？\" class=\"headerlink\" title=\"怎么序列化一个对象？\"></a>怎么序列化一个对象？</h2><p>要序列化一个对象，这个对象所在类就必须实现Java序列化的接口：java.io.Serializable。</p>\n<h5 id=\"1、类添加序列化接口\"><a href=\"#1、类添加序列化接口\" class=\"headerlink\" title=\"1、类添加序列化接口\"></a>1、类添加序列化接口</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\">public class User implements Serializable&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final long serialVersionUID = -8475669200846811112L;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String username;</span><br><span class=\"line\">    private String address;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getUsername() &#123;</span><br><span class=\"line\">        return username;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUsername(String username) &#123;</span><br><span class=\"line\">        this.username = username;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getAddress() &#123;</span><br><span class=\"line\">        return address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAddress(String address) &#123;</span><br><span class=\"line\">        this.address = address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return &quot;User&#123;&quot; +</span><br><span class=\"line\">                &quot;username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; +</span><br><span class=\"line\">                &quot;, address=&#x27;&quot; + address + &#x27;\\&#x27;&#x27; +</span><br><span class=\"line\">                &#x27;&#125;&#x27;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2、序列化-反序列化\"><a href=\"#2、序列化-反序列化\" class=\"headerlink\" title=\"2、序列化&#x2F;反序列化\"></a>2、序列化&#x2F;反序列化</h5><p>可以借助commons-lang3工具包里面的类实现对象的序列化及反序列化，你没有必要自己写。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.apache.commons.lang3.SerializationUtils;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Test &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        User user = new User();</span><br><span class=\"line\">        user.setUsername(&quot;Java&quot;);</span><br><span class=\"line\">        user.setAddress(&quot;China&quot;);</span><br><span class=\"line\">        byte[] bytes = SerializationUtils.serialize(user);</span><br><span class=\"line\"></span><br><span class=\"line\">        User u = SerializationUtils.deserialize(bytes);</span><br><span class=\"line\">        System.out.println(u);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User&#123;username=&#x27;Java&#x27;, address=&#x27;China&#x27;&#125;</span><br></pre></td></tr></table></figure>\n<p>上例通过序列化对象字节到内存然后反序列化，当然里面也提供了序列化磁盘然后再反序列化的方法，原理都是一样的，只是目标地不一样。</p>\n<h2 id=\"序列化注意事项\"><a href=\"#序列化注意事项\" class=\"headerlink\" title=\"序列化注意事项\"></a>序列化注意事项</h2><ul>\n<li><p>序列化对象必须实现序列化接口。</p>\n</li>\n<li><p>序列化对象里面的属性是对象的话也要实现序列化接口。</p>\n</li>\n<li><p>类的对象序列化后，类的序列化ID不能轻易修改，不然反序列化会失败。</p>\n</li>\n<li><p>类的对象序列化后，类的属性有增加或者删除不会影响序列化，只是值会丢失。</p>\n</li>\n<li><p>如果父类序列化了，子类会继承父类的序列化，子类无需添加序列化接口。</p>\n</li>\n<li><p>如果父类没有序列化，子类序列化了，子类中的属性能正常序列化，但父类的属性会丢失，不能序列化。</p>\n</li>\n<li><p>用Java序列化的二进制字节数据只能由Java反序列化，不能被其他语言反序列化。如果要进行前后端或者不同语言之间的交互一般需要将对象转变成Json&#x2F;Xml通用格式的数据，再恢复原来的对象。</p>\n</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"什么是序列化\"><a href=\"#什么是序列化\" class=\"headerlink\" title=\"什么是序列化\"></a>什么是序列化</h2><p>我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。</p>\n<p>Java序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。</p>\n<h2 id=\"怎么序列化一个对象？\"><a href=\"#怎么序列化一个对象？\" class=\"headerlink\" title=\"怎么序列化一个对象？\"></a>怎么序列化一个对象？</h2><p>要序列化一个对象，这个对象所在类就必须实现Java序列化的接口：java.io.Serializable。</p>\n<h5 id=\"1、类添加序列化接口\"><a href=\"#1、类添加序列化接口\" class=\"headerlink\" title=\"1、类添加序列化接口\"></a>1、类添加序列化接口</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\">public class User implements Serializable&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final long serialVersionUID = -8475669200846811112L;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String username;</span><br><span class=\"line\">    private String address;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getUsername() &#123;</span><br><span class=\"line\">        return username;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setUsername(String username) &#123;</span><br><span class=\"line\">        this.username = username;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getAddress() &#123;</span><br><span class=\"line\">        return address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAddress(String address) &#123;</span><br><span class=\"line\">        this.address = address;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return &quot;User&#123;&quot; +</span><br><span class=\"line\">                &quot;username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; +</span><br><span class=\"line\">                &quot;, address=&#x27;&quot; + address + &#x27;\\&#x27;&#x27; +</span><br><span class=\"line\">                &#x27;&#125;&#x27;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2、序列化-反序列化\"><a href=\"#2、序列化-反序列化\" class=\"headerlink\" title=\"2、序列化&#x2F;反序列化\"></a>2、序列化&#x2F;反序列化</h5><p>可以借助commons-lang3工具包里面的类实现对象的序列化及反序列化，你没有必要自己写。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.apache.commons.lang3.SerializationUtils;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Test &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        User user = new User();</span><br><span class=\"line\">        user.setUsername(&quot;Java&quot;);</span><br><span class=\"line\">        user.setAddress(&quot;China&quot;);</span><br><span class=\"line\">        byte[] bytes = SerializationUtils.serialize(user);</span><br><span class=\"line\"></span><br><span class=\"line\">        User u = SerializationUtils.deserialize(bytes);</span><br><span class=\"line\">        System.out.println(u);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">User&#123;username=&#x27;Java&#x27;, address=&#x27;China&#x27;&#125;</span><br></pre></td></tr></table></figure>\n<p>上例通过序列化对象字节到内存然后反序列化，当然里面也提供了序列化磁盘然后再反序列化的方法，原理都是一样的，只是目标地不一样。</p>\n<h2 id=\"序列化注意事项\"><a href=\"#序列化注意事项\" class=\"headerlink\" title=\"序列化注意事项\"></a>序列化注意事项</h2><ul>\n<li><p>序列化对象必须实现序列化接口。</p>\n</li>\n<li><p>序列化对象里面的属性是对象的话也要实现序列化接口。</p>\n</li>\n<li><p>类的对象序列化后，类的序列化ID不能轻易修改，不然反序列化会失败。</p>\n</li>\n<li><p>类的对象序列化后，类的属性有增加或者删除不会影响序列化，只是值会丢失。</p>\n</li>\n<li><p>如果父类序列化了，子类会继承父类的序列化，子类无需添加序列化接口。</p>\n</li>\n<li><p>如果父类没有序列化，子类序列化了，子类中的属性能正常序列化，但父类的属性会丢失，不能序列化。</p>\n</li>\n<li><p>用Java序列化的二进制字节数据只能由Java反序列化，不能被其他语言反序列化。如果要进行前后端或者不同语言之间的交互一般需要将对象转变成Json&#x2F;Xml通用格式的数据，再恢复原来的对象。</p>\n</li>\n</ul>\n"},{"title":"常见的 3 种 Class 级别的错误","date":"2025-10-14T06:42:34.000Z","_content":"\n## ClassNotFoundException\n\n很明显，这个错误是`找不到类异常`，即在当前classpath路径下找不到这个类。\n\nClassNotFoundException继承了Exception，是必须捕获的异常，所以这个异常一般发生在显示加载类的时候，如下面两种方式显示来加载类并要捕获异常。\n\n```\npublic static void main(String[] args) {\n    try {\n        Class.forName(\"com.User\");\n    } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n    }\n\n    try {\n        Test.class.getClassLoader().loadClass(\"com.User\");\n    } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n    }\n\n}\n```\n当无法找到对应的类时都会抛出ClassNotFoundException异常。\n\n```\njava.lang.ClassNotFoundException: com.User\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\tat com.test.user.Test.main(Test.java:15)\n```\n\n## NoClassDefFoundError\n\n这是虚拟机隐式加载类出现的异常。\n\n这个异常继承了Error类，一般发生在引用的类不存在，即类、方法或者属性引用了某个类或者接口，如果目标引用不存在就会抛出这个异常。\n\n```\nimport org.jdom2.input.DOMBuilder;\npublic class MyDomBuilder extends DOMBuilder{\n\n}\n```\n```\npublic static void main(String[] args) {\n    MyDomBuilder builder = new MyDomBuilder();\n}\n```\nMyDomBuilder继承了DOMBuilder，如果把DOMBuilder所属的jar包范围设置为provided，即运行时找不到DOMBuilder类就会报错。\n```\nException in thread \"main\" java.lang.NoClassDefFoundError: org/jdom2/input/DOMBuilder\n\tat java.lang.ClassLoader.defineClass1(Native Method)\n\tat java.lang.ClassLoader.defineClass(ClassLoader.java:763)\n\tat java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\n\tat java.net.URLClassLoader.defineClass(URLClassLoader.java:467)\n\tat java.net.URLClassLoader.access$100(URLClassLoader.java:73)\n\tat java.net.URLClassLoader$1.run(URLClassLoader.java:368)\n\tat java.net.URLClassLoader$1.run(URLClassLoader.java:362)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:361)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\tat com.test.user.Test.main(Test.java:8)\nCaused by: java.lang.ClassNotFoundException: org.jdom2.input.DOMBuilder\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\t... 13 more\n```\n先报出ClassNotFoundException，然后引发NoClassDefFoundError。\n\n所以，以上两个错误都要确保加载类或者引用类都要在classpath路径下。\n\n## ClassCastException\n\n类转换异常，这个错误一般发生在一个对象强制转换类型的时候，如将一个String强制转换成Integer就会报这个错。\n\n这个异常继承了运行时异常RuntimeException，不需要捕获的异常。为了避免报这个错，在转换之间可以先用instanceof判断下是不是该类的引用再转换。如果是集合类型，最好指定集合里面的泛型。\n\n\n```\npublic static void main(String[] args) {\n    Object str = \"123\";\n    Integer i = (Integer)str;\n}\n```\n\n字符串\"123\"强制转换成Integer，然后报错。\n\n```\nException in thread \"main\" java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer\n\tat com.test.user.Test.main(Test.java:9)\n```\n\n","source":"_posts/基础/常见的 3 种 Class 级别的错误.md","raw":"---\ntitle: 常见的 3 种 Class 级别的错误\ndate: 2025-10-14 14:42:34\ntags: 基础\n---\n\n## ClassNotFoundException\n\n很明显，这个错误是`找不到类异常`，即在当前classpath路径下找不到这个类。\n\nClassNotFoundException继承了Exception，是必须捕获的异常，所以这个异常一般发生在显示加载类的时候，如下面两种方式显示来加载类并要捕获异常。\n\n```\npublic static void main(String[] args) {\n    try {\n        Class.forName(\"com.User\");\n    } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n    }\n\n    try {\n        Test.class.getClassLoader().loadClass(\"com.User\");\n    } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n    }\n\n}\n```\n当无法找到对应的类时都会抛出ClassNotFoundException异常。\n\n```\njava.lang.ClassNotFoundException: com.User\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\tat com.test.user.Test.main(Test.java:15)\n```\n\n## NoClassDefFoundError\n\n这是虚拟机隐式加载类出现的异常。\n\n这个异常继承了Error类，一般发生在引用的类不存在，即类、方法或者属性引用了某个类或者接口，如果目标引用不存在就会抛出这个异常。\n\n```\nimport org.jdom2.input.DOMBuilder;\npublic class MyDomBuilder extends DOMBuilder{\n\n}\n```\n```\npublic static void main(String[] args) {\n    MyDomBuilder builder = new MyDomBuilder();\n}\n```\nMyDomBuilder继承了DOMBuilder，如果把DOMBuilder所属的jar包范围设置为provided，即运行时找不到DOMBuilder类就会报错。\n```\nException in thread \"main\" java.lang.NoClassDefFoundError: org/jdom2/input/DOMBuilder\n\tat java.lang.ClassLoader.defineClass1(Native Method)\n\tat java.lang.ClassLoader.defineClass(ClassLoader.java:763)\n\tat java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\n\tat java.net.URLClassLoader.defineClass(URLClassLoader.java:467)\n\tat java.net.URLClassLoader.access$100(URLClassLoader.java:73)\n\tat java.net.URLClassLoader$1.run(URLClassLoader.java:368)\n\tat java.net.URLClassLoader$1.run(URLClassLoader.java:362)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:361)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\tat com.test.user.Test.main(Test.java:8)\nCaused by: java.lang.ClassNotFoundException: org.jdom2.input.DOMBuilder\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\t... 13 more\n```\n先报出ClassNotFoundException，然后引发NoClassDefFoundError。\n\n所以，以上两个错误都要确保加载类或者引用类都要在classpath路径下。\n\n## ClassCastException\n\n类转换异常，这个错误一般发生在一个对象强制转换类型的时候，如将一个String强制转换成Integer就会报这个错。\n\n这个异常继承了运行时异常RuntimeException，不需要捕获的异常。为了避免报这个错，在转换之间可以先用instanceof判断下是不是该类的引用再转换。如果是集合类型，最好指定集合里面的泛型。\n\n\n```\npublic static void main(String[] args) {\n    Object str = \"123\";\n    Integer i = (Integer)str;\n}\n```\n\n字符串\"123\"强制转换成Integer，然后报错。\n\n```\nException in thread \"main\" java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer\n\tat com.test.user.Test.main(Test.java:9)\n```\n\n","slug":"基础/常见的 3 种 Class 级别的错误","published":1,"updated":"2025-10-14T07:31:22.852Z","_id":"cmgq8bkfu000zhod47t9hd57e","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"ClassNotFoundException\"><a href=\"#ClassNotFoundException\" class=\"headerlink\" title=\"ClassNotFoundException\"></a>ClassNotFoundException</h2><p>很明显，这个错误是<code>找不到类异常</code>，即在当前classpath路径下找不到这个类。</p>\n<p>ClassNotFoundException继承了Exception，是必须捕获的异常，所以这个异常一般发生在显示加载类的时候，如下面两种方式显示来加载类并要捕获异常。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        Class.forName(&quot;com.User&quot;);</span><br><span class=\"line\">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        Test.class.getClassLoader().loadClass(&quot;com.User&quot;);</span><br><span class=\"line\">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当无法找到对应的类时都会抛出ClassNotFoundException异常。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.ClassNotFoundException: com.User</span><br><span class=\"line\">\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class=\"line\">\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class=\"line\">\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)</span><br><span class=\"line\">\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class=\"line\">\tat com.test.user.Test.main(Test.java:15)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"NoClassDefFoundError\"><a href=\"#NoClassDefFoundError\" class=\"headerlink\" title=\"NoClassDefFoundError\"></a>NoClassDefFoundError</h2><p>这是虚拟机隐式加载类出现的异常。</p>\n<p>这个异常继承了Error类，一般发生在引用的类不存在，即类、方法或者属性引用了某个类或者接口，如果目标引用不存在就会抛出这个异常。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.jdom2.input.DOMBuilder;</span><br><span class=\"line\">public class MyDomBuilder extends DOMBuilder&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    MyDomBuilder builder = new MyDomBuilder();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MyDomBuilder继承了DOMBuilder，如果把DOMBuilder所属的jar包范围设置为provided，即运行时找不到DOMBuilder类就会报错。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org/jdom2/input/DOMBuilder</span><br><span class=\"line\">\tat java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class=\"line\">\tat java.lang.ClassLoader.defineClass(ClassLoader.java:763)</span><br><span class=\"line\">\tat java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)</span><br><span class=\"line\">\tat java.net.URLClassLoader.defineClass(URLClassLoader.java:467)</span><br><span class=\"line\">\tat java.net.URLClassLoader.access$100(URLClassLoader.java:73)</span><br><span class=\"line\">\tat java.net.URLClassLoader$1.run(URLClassLoader.java:368)</span><br><span class=\"line\">\tat java.net.URLClassLoader$1.run(URLClassLoader.java:362)</span><br><span class=\"line\">\tat java.security.AccessController.doPrivileged(Native Method)</span><br><span class=\"line\">\tat java.net.URLClassLoader.findClass(URLClassLoader.java:361)</span><br><span class=\"line\">\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class=\"line\">\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)</span><br><span class=\"line\">\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class=\"line\">\tat com.test.user.Test.main(Test.java:8)</span><br><span class=\"line\">Caused by: java.lang.ClassNotFoundException: org.jdom2.input.DOMBuilder</span><br><span class=\"line\">\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class=\"line\">\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class=\"line\">\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)</span><br><span class=\"line\">\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class=\"line\">\t... 13 more</span><br></pre></td></tr></table></figure>\n<p>先报出ClassNotFoundException，然后引发NoClassDefFoundError。</p>\n<p>所以，以上两个错误都要确保加载类或者引用类都要在classpath路径下。</p>\n<h2 id=\"ClassCastException\"><a href=\"#ClassCastException\" class=\"headerlink\" title=\"ClassCastException\"></a>ClassCastException</h2><p>类转换异常，这个错误一般发生在一个对象强制转换类型的时候，如将一个String强制转换成Integer就会报这个错。</p>\n<p>这个异常继承了运行时异常RuntimeException，不需要捕获的异常。为了避免报这个错，在转换之间可以先用instanceof判断下是不是该类的引用再转换。如果是集合类型，最好指定集合里面的泛型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    Object str = &quot;123&quot;;</span><br><span class=\"line\">    Integer i = (Integer)str;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>字符串”123”强制转换成Integer，然后报错。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer</span><br><span class=\"line\">\tat com.test.user.Test.main(Test.java:9)</span><br></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h2 id=\"ClassNotFoundException\"><a href=\"#ClassNotFoundException\" class=\"headerlink\" title=\"ClassNotFoundException\"></a>ClassNotFoundException</h2><p>很明显，这个错误是<code>找不到类异常</code>，即在当前classpath路径下找不到这个类。</p>\n<p>ClassNotFoundException继承了Exception，是必须捕获的异常，所以这个异常一般发生在显示加载类的时候，如下面两种方式显示来加载类并要捕获异常。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        Class.forName(&quot;com.User&quot;);</span><br><span class=\"line\">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        Test.class.getClassLoader().loadClass(&quot;com.User&quot;);</span><br><span class=\"line\">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当无法找到对应的类时都会抛出ClassNotFoundException异常。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.ClassNotFoundException: com.User</span><br><span class=\"line\">\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class=\"line\">\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class=\"line\">\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)</span><br><span class=\"line\">\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class=\"line\">\tat com.test.user.Test.main(Test.java:15)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"NoClassDefFoundError\"><a href=\"#NoClassDefFoundError\" class=\"headerlink\" title=\"NoClassDefFoundError\"></a>NoClassDefFoundError</h2><p>这是虚拟机隐式加载类出现的异常。</p>\n<p>这个异常继承了Error类，一般发生在引用的类不存在，即类、方法或者属性引用了某个类或者接口，如果目标引用不存在就会抛出这个异常。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.jdom2.input.DOMBuilder;</span><br><span class=\"line\">public class MyDomBuilder extends DOMBuilder&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    MyDomBuilder builder = new MyDomBuilder();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MyDomBuilder继承了DOMBuilder，如果把DOMBuilder所属的jar包范围设置为provided，即运行时找不到DOMBuilder类就会报错。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org/jdom2/input/DOMBuilder</span><br><span class=\"line\">\tat java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class=\"line\">\tat java.lang.ClassLoader.defineClass(ClassLoader.java:763)</span><br><span class=\"line\">\tat java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)</span><br><span class=\"line\">\tat java.net.URLClassLoader.defineClass(URLClassLoader.java:467)</span><br><span class=\"line\">\tat java.net.URLClassLoader.access$100(URLClassLoader.java:73)</span><br><span class=\"line\">\tat java.net.URLClassLoader$1.run(URLClassLoader.java:368)</span><br><span class=\"line\">\tat java.net.URLClassLoader$1.run(URLClassLoader.java:362)</span><br><span class=\"line\">\tat java.security.AccessController.doPrivileged(Native Method)</span><br><span class=\"line\">\tat java.net.URLClassLoader.findClass(URLClassLoader.java:361)</span><br><span class=\"line\">\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class=\"line\">\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)</span><br><span class=\"line\">\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class=\"line\">\tat com.test.user.Test.main(Test.java:8)</span><br><span class=\"line\">Caused by: java.lang.ClassNotFoundException: org.jdom2.input.DOMBuilder</span><br><span class=\"line\">\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class=\"line\">\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class=\"line\">\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)</span><br><span class=\"line\">\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class=\"line\">\t... 13 more</span><br></pre></td></tr></table></figure>\n<p>先报出ClassNotFoundException，然后引发NoClassDefFoundError。</p>\n<p>所以，以上两个错误都要确保加载类或者引用类都要在classpath路径下。</p>\n<h2 id=\"ClassCastException\"><a href=\"#ClassCastException\" class=\"headerlink\" title=\"ClassCastException\"></a>ClassCastException</h2><p>类转换异常，这个错误一般发生在一个对象强制转换类型的时候，如将一个String强制转换成Integer就会报这个错。</p>\n<p>这个异常继承了运行时异常RuntimeException，不需要捕获的异常。为了避免报这个错，在转换之间可以先用instanceof判断下是不是该类的引用再转换。如果是集合类型，最好指定集合里面的泛型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    Object str = &quot;123&quot;;</span><br><span class=\"line\">    Integer i = (Integer)str;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>字符串”123”强制转换成Integer，然后报错。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer</span><br><span class=\"line\">\tat com.test.user.Test.main(Test.java:9)</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Java Base64 编码解码方案总结","date":"2025-10-14T06:42:34.000Z","_content":"\nBase64是一种能将任意Binary资料用64种字元组合成字串的方法，而这个Binary资料和字串资料彼此之间是可以互相转换的，十分方便。在实际应用上，Base64除了能将Binary资料可视化之外，也常用来表示字串加密过后的内容。如果要使用Java 程式语言来实作Base64的编码与解码功能，可以参考本篇文章的作法。\n\n#### 早期作法\n\n早期在Java上做Base64的编码与解码，会使用到JDK里sun.misc套件下的BASE64Encoder和BASE64Decoder这两个类别，用法如下：\n\n```\nfinal BASE64Encoder encoder = new BASE64Encoder();\nfinal BASE64Decoder decoder = new BASE64Decoder();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = encoder.encode(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(decoder.decodeBuffer(encodedText), \"UTF-8\"));\n\nfinal BASE64Encoder encoder = new BASE64Encoder();\nfinal BASE64Decoder decoder = new BASE64Decoder();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = encoder.encode(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(decoder.decodeBuffer(encodedText), \"UTF-8\"));\n```\n\n\n从以上程式可以发现，在Java用Base64一点都不难，不用几行程式码就解决了！只是这个sun.mis c套件所提供的Base64功能，编码和解码的效率并不太好，而且在以后的Java版本可能就不被支援了，完全不建议使用。\n\n#### Apache Commons Codec作法\n\nApache Commons Codec有提供Base64的编码与解码功能，会使用到org.apache.commons.codec.binary套件下的Base64类别，用法如下：\n\n```\nfinal Base64 base64 = new Base64();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = base64.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(base64.decode(encodedText), \"UTF-8\"));\n\nfinal Base64 base64 = new Base64();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = base64.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(base64.decode(encodedText), \"UTF-8\"));\n```\n\n以上的程式码看起来又比早期用sun.mis c套件还要更精简，效能实际执行起来也快了不少。缺点是需要引用Apache Commons Codec，很麻烦。\n\n#### Java 8之后的作法\n\nJava 8的java.util套件中，新增了Base64的类别，可以用来处理Base64的编码与解码，用法如下：\n\n```\nfinal Base64.Decoder decoder = Base64.getDecoder();\nfinal Base64.Encoder encoder = Base64.getEncoder();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = encoder.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(decoder.decode(encodedText), \"UTF-8\"));\n\nfinal Base64.Decoder decoder = Base64.getDecoder();\nfinal Base64.Encoder encoder = Base64.getEncoder();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = encoder.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(decoder.decode(encodedText), \"UTF-8\"));\n```\n\n\n与sun.mis c套件和Apache Commons Codec所提供的Base64编解码器来比较的话，Java 8提供的Base64拥有更好的效能。实际测试编码与解码速度的话，Java 8提供的Base64，要比sun.mis c套件提供的还要快至少11倍，比Apache Commons Codec提供的还要快至少3倍。**因此在Java上若要使用Base64，这个Java 8底下的java .util套件所提供的Base64类别绝对是首选！**\n\n","source":"_posts/基础/Java Base64 编码解码方案总结.md","raw":"---\ntitle: Java Base64 编码解码方案总结\ndate: 2025-10-14 14:42:34\ntags: 基础\n---\n\nBase64是一种能将任意Binary资料用64种字元组合成字串的方法，而这个Binary资料和字串资料彼此之间是可以互相转换的，十分方便。在实际应用上，Base64除了能将Binary资料可视化之外，也常用来表示字串加密过后的内容。如果要使用Java 程式语言来实作Base64的编码与解码功能，可以参考本篇文章的作法。\n\n#### 早期作法\n\n早期在Java上做Base64的编码与解码，会使用到JDK里sun.misc套件下的BASE64Encoder和BASE64Decoder这两个类别，用法如下：\n\n```\nfinal BASE64Encoder encoder = new BASE64Encoder();\nfinal BASE64Decoder decoder = new BASE64Decoder();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = encoder.encode(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(decoder.decodeBuffer(encodedText), \"UTF-8\"));\n\nfinal BASE64Encoder encoder = new BASE64Encoder();\nfinal BASE64Decoder decoder = new BASE64Decoder();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = encoder.encode(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(decoder.decodeBuffer(encodedText), \"UTF-8\"));\n```\n\n\n从以上程式可以发现，在Java用Base64一点都不难，不用几行程式码就解决了！只是这个sun.mis c套件所提供的Base64功能，编码和解码的效率并不太好，而且在以后的Java版本可能就不被支援了，完全不建议使用。\n\n#### Apache Commons Codec作法\n\nApache Commons Codec有提供Base64的编码与解码功能，会使用到org.apache.commons.codec.binary套件下的Base64类别，用法如下：\n\n```\nfinal Base64 base64 = new Base64();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = base64.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(base64.decode(encodedText), \"UTF-8\"));\n\nfinal Base64 base64 = new Base64();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = base64.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(base64.decode(encodedText), \"UTF-8\"));\n```\n\n以上的程式码看起来又比早期用sun.mis c套件还要更精简，效能实际执行起来也快了不少。缺点是需要引用Apache Commons Codec，很麻烦。\n\n#### Java 8之后的作法\n\nJava 8的java.util套件中，新增了Base64的类别，可以用来处理Base64的编码与解码，用法如下：\n\n```\nfinal Base64.Decoder decoder = Base64.getDecoder();\nfinal Base64.Encoder encoder = Base64.getEncoder();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = encoder.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(decoder.decode(encodedText), \"UTF-8\"));\n\nfinal Base64.Decoder decoder = Base64.getDecoder();\nfinal Base64.Encoder encoder = Base64.getEncoder();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = encoder.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(decoder.decode(encodedText), \"UTF-8\"));\n```\n\n\n与sun.mis c套件和Apache Commons Codec所提供的Base64编解码器来比较的话，Java 8提供的Base64拥有更好的效能。实际测试编码与解码速度的话，Java 8提供的Base64，要比sun.mis c套件提供的还要快至少11倍，比Apache Commons Codec提供的还要快至少3倍。**因此在Java上若要使用Base64，这个Java 8底下的java .util套件所提供的Base64类别绝对是首选！**\n\n","slug":"基础/Java Base64 编码解码方案总结","published":1,"updated":"2025-10-14T07:31:22.846Z","_id":"cmgq8bkfv0010hod406pr5mr0","comments":1,"layout":"post","photos":[],"content":"<p>Base64是一种能将任意Binary资料用64种字元组合成字串的方法，而这个Binary资料和字串资料彼此之间是可以互相转换的，十分方便。在实际应用上，Base64除了能将Binary资料可视化之外，也常用来表示字串加密过后的内容。如果要使用Java 程式语言来实作Base64的编码与解码功能，可以参考本篇文章的作法。</p>\n<h4 id=\"早期作法\"><a href=\"#早期作法\" class=\"headerlink\" title=\"早期作法\"></a>早期作法</h4><p>早期在Java上做Base64的编码与解码，会使用到JDK里sun.misc套件下的BASE64Encoder和BASE64Decoder这两个类别，用法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final BASE64Encoder encoder = new BASE64Encoder();</span><br><span class=\"line\">final BASE64Decoder decoder = new BASE64Decoder();</span><br><span class=\"line\">final String text = &quot;Java技术&quot;;</span><br><span class=\"line\">final byte[] textByte = text.getBytes(&quot;UTF-8&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">//编码</span><br><span class=\"line\">final String encodedText = encoder.encode(textByte);</span><br><span class=\"line\">System.out.println(encodedText);</span><br><span class=\"line\"></span><br><span class=\"line\">//解码</span><br><span class=\"line\">System.out.println(new String(decoder.decodeBuffer(encodedText), &quot;UTF-8&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">final BASE64Encoder encoder = new BASE64Encoder();</span><br><span class=\"line\">final BASE64Decoder decoder = new BASE64Decoder();</span><br><span class=\"line\">final String text = &quot;Java技术&quot;;</span><br><span class=\"line\">final byte[] textByte = text.getBytes(&quot;UTF-8&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">//编码</span><br><span class=\"line\">final String encodedText = encoder.encode(textByte);</span><br><span class=\"line\">System.out.println(encodedText);</span><br><span class=\"line\"></span><br><span class=\"line\">//解码</span><br><span class=\"line\">System.out.println(new String(decoder.decodeBuffer(encodedText), &quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure>\n\n\n<p>从以上程式可以发现，在Java用Base64一点都不难，不用几行程式码就解决了！只是这个sun.mis c套件所提供的Base64功能，编码和解码的效率并不太好，而且在以后的Java版本可能就不被支援了，完全不建议使用。</p>\n<h4 id=\"Apache-Commons-Codec作法\"><a href=\"#Apache-Commons-Codec作法\" class=\"headerlink\" title=\"Apache Commons Codec作法\"></a>Apache Commons Codec作法</h4><p>Apache Commons Codec有提供Base64的编码与解码功能，会使用到org.apache.commons.codec.binary套件下的Base64类别，用法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final Base64 base64 = new Base64();</span><br><span class=\"line\">final String text = &quot;Java技术&quot;;</span><br><span class=\"line\">final byte[] textByte = text.getBytes(&quot;UTF-8&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">//编码</span><br><span class=\"line\">final String encodedText = base64.encodeToString(textByte);</span><br><span class=\"line\">System.out.println(encodedText);</span><br><span class=\"line\"></span><br><span class=\"line\">//解码</span><br><span class=\"line\">System.out.println(new String(base64.decode(encodedText), &quot;UTF-8&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">final Base64 base64 = new Base64();</span><br><span class=\"line\">final String text = &quot;Java技术&quot;;</span><br><span class=\"line\">final byte[] textByte = text.getBytes(&quot;UTF-8&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">//编码</span><br><span class=\"line\">final String encodedText = base64.encodeToString(textByte);</span><br><span class=\"line\">System.out.println(encodedText);</span><br><span class=\"line\"></span><br><span class=\"line\">//解码</span><br><span class=\"line\">System.out.println(new String(base64.decode(encodedText), &quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure>\n\n<p>以上的程式码看起来又比早期用sun.mis c套件还要更精简，效能实际执行起来也快了不少。缺点是需要引用Apache Commons Codec，很麻烦。</p>\n<h4 id=\"Java-8之后的作法\"><a href=\"#Java-8之后的作法\" class=\"headerlink\" title=\"Java 8之后的作法\"></a>Java 8之后的作法</h4><p>Java 8的java.util套件中，新增了Base64的类别，可以用来处理Base64的编码与解码，用法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final Base64.Decoder decoder = Base64.getDecoder();</span><br><span class=\"line\">final Base64.Encoder encoder = Base64.getEncoder();</span><br><span class=\"line\">final String text = &quot;Java技术&quot;;</span><br><span class=\"line\">final byte[] textByte = text.getBytes(&quot;UTF-8&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">//编码</span><br><span class=\"line\">final String encodedText = encoder.encodeToString(textByte);</span><br><span class=\"line\">System.out.println(encodedText);</span><br><span class=\"line\"></span><br><span class=\"line\">//解码</span><br><span class=\"line\">System.out.println(new String(decoder.decode(encodedText), &quot;UTF-8&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">final Base64.Decoder decoder = Base64.getDecoder();</span><br><span class=\"line\">final Base64.Encoder encoder = Base64.getEncoder();</span><br><span class=\"line\">final String text = &quot;Java技术&quot;;</span><br><span class=\"line\">final byte[] textByte = text.getBytes(&quot;UTF-8&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">//编码</span><br><span class=\"line\">final String encodedText = encoder.encodeToString(textByte);</span><br><span class=\"line\">System.out.println(encodedText);</span><br><span class=\"line\"></span><br><span class=\"line\">//解码</span><br><span class=\"line\">System.out.println(new String(decoder.decode(encodedText), &quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure>\n\n\n<p>与sun.mis c套件和Apache Commons Codec所提供的Base64编解码器来比较的话，Java 8提供的Base64拥有更好的效能。实际测试编码与解码速度的话，Java 8提供的Base64，要比sun.mis c套件提供的还要快至少11倍，比Apache Commons Codec提供的还要快至少3倍。<strong>因此在Java上若要使用Base64，这个Java 8底下的java .util套件所提供的Base64类别绝对是首选！</strong></p>\n","excerpt":"","more":"<p>Base64是一种能将任意Binary资料用64种字元组合成字串的方法，而这个Binary资料和字串资料彼此之间是可以互相转换的，十分方便。在实际应用上，Base64除了能将Binary资料可视化之外，也常用来表示字串加密过后的内容。如果要使用Java 程式语言来实作Base64的编码与解码功能，可以参考本篇文章的作法。</p>\n<h4 id=\"早期作法\"><a href=\"#早期作法\" class=\"headerlink\" title=\"早期作法\"></a>早期作法</h4><p>早期在Java上做Base64的编码与解码，会使用到JDK里sun.misc套件下的BASE64Encoder和BASE64Decoder这两个类别，用法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final BASE64Encoder encoder = new BASE64Encoder();</span><br><span class=\"line\">final BASE64Decoder decoder = new BASE64Decoder();</span><br><span class=\"line\">final String text = &quot;Java技术&quot;;</span><br><span class=\"line\">final byte[] textByte = text.getBytes(&quot;UTF-8&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">//编码</span><br><span class=\"line\">final String encodedText = encoder.encode(textByte);</span><br><span class=\"line\">System.out.println(encodedText);</span><br><span class=\"line\"></span><br><span class=\"line\">//解码</span><br><span class=\"line\">System.out.println(new String(decoder.decodeBuffer(encodedText), &quot;UTF-8&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">final BASE64Encoder encoder = new BASE64Encoder();</span><br><span class=\"line\">final BASE64Decoder decoder = new BASE64Decoder();</span><br><span class=\"line\">final String text = &quot;Java技术&quot;;</span><br><span class=\"line\">final byte[] textByte = text.getBytes(&quot;UTF-8&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">//编码</span><br><span class=\"line\">final String encodedText = encoder.encode(textByte);</span><br><span class=\"line\">System.out.println(encodedText);</span><br><span class=\"line\"></span><br><span class=\"line\">//解码</span><br><span class=\"line\">System.out.println(new String(decoder.decodeBuffer(encodedText), &quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure>\n\n\n<p>从以上程式可以发现，在Java用Base64一点都不难，不用几行程式码就解决了！只是这个sun.mis c套件所提供的Base64功能，编码和解码的效率并不太好，而且在以后的Java版本可能就不被支援了，完全不建议使用。</p>\n<h4 id=\"Apache-Commons-Codec作法\"><a href=\"#Apache-Commons-Codec作法\" class=\"headerlink\" title=\"Apache Commons Codec作法\"></a>Apache Commons Codec作法</h4><p>Apache Commons Codec有提供Base64的编码与解码功能，会使用到org.apache.commons.codec.binary套件下的Base64类别，用法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final Base64 base64 = new Base64();</span><br><span class=\"line\">final String text = &quot;Java技术&quot;;</span><br><span class=\"line\">final byte[] textByte = text.getBytes(&quot;UTF-8&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">//编码</span><br><span class=\"line\">final String encodedText = base64.encodeToString(textByte);</span><br><span class=\"line\">System.out.println(encodedText);</span><br><span class=\"line\"></span><br><span class=\"line\">//解码</span><br><span class=\"line\">System.out.println(new String(base64.decode(encodedText), &quot;UTF-8&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">final Base64 base64 = new Base64();</span><br><span class=\"line\">final String text = &quot;Java技术&quot;;</span><br><span class=\"line\">final byte[] textByte = text.getBytes(&quot;UTF-8&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">//编码</span><br><span class=\"line\">final String encodedText = base64.encodeToString(textByte);</span><br><span class=\"line\">System.out.println(encodedText);</span><br><span class=\"line\"></span><br><span class=\"line\">//解码</span><br><span class=\"line\">System.out.println(new String(base64.decode(encodedText), &quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure>\n\n<p>以上的程式码看起来又比早期用sun.mis c套件还要更精简，效能实际执行起来也快了不少。缺点是需要引用Apache Commons Codec，很麻烦。</p>\n<h4 id=\"Java-8之后的作法\"><a href=\"#Java-8之后的作法\" class=\"headerlink\" title=\"Java 8之后的作法\"></a>Java 8之后的作法</h4><p>Java 8的java.util套件中，新增了Base64的类别，可以用来处理Base64的编码与解码，用法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final Base64.Decoder decoder = Base64.getDecoder();</span><br><span class=\"line\">final Base64.Encoder encoder = Base64.getEncoder();</span><br><span class=\"line\">final String text = &quot;Java技术&quot;;</span><br><span class=\"line\">final byte[] textByte = text.getBytes(&quot;UTF-8&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">//编码</span><br><span class=\"line\">final String encodedText = encoder.encodeToString(textByte);</span><br><span class=\"line\">System.out.println(encodedText);</span><br><span class=\"line\"></span><br><span class=\"line\">//解码</span><br><span class=\"line\">System.out.println(new String(decoder.decode(encodedText), &quot;UTF-8&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">final Base64.Decoder decoder = Base64.getDecoder();</span><br><span class=\"line\">final Base64.Encoder encoder = Base64.getEncoder();</span><br><span class=\"line\">final String text = &quot;Java技术&quot;;</span><br><span class=\"line\">final byte[] textByte = text.getBytes(&quot;UTF-8&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">//编码</span><br><span class=\"line\">final String encodedText = encoder.encodeToString(textByte);</span><br><span class=\"line\">System.out.println(encodedText);</span><br><span class=\"line\"></span><br><span class=\"line\">//解码</span><br><span class=\"line\">System.out.println(new String(decoder.decode(encodedText), &quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure>\n\n\n<p>与sun.mis c套件和Apache Commons Codec所提供的Base64编解码器来比较的话，Java 8提供的Base64拥有更好的效能。实际测试编码与解码速度的话，Java 8提供的Base64，要比sun.mis c套件提供的还要快至少11倍，比Apache Commons Codec提供的还要快至少3倍。<strong>因此在Java上若要使用Base64，这个Java 8底下的java .util套件所提供的Base64类别绝对是首选！</strong></p>\n"},{"title":"switch多值匹配骚操作，带你涨姿势！","date":"2025-10-14T06:42:34.000Z","_content":"\n我们都知道 `switch` 用来走流程分支，大多情况下用来匹配单个值，如下面的例子所示：\n\n```\n/**\n * @from \n * @author 栈长\n */\nprivate static void test(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"1\");\n            break;\n        case 2:\n            System.out.println(\"1\");\n            break;\n        case 3:\n            System.out.println(\"1\");\n            break;\n        case 4:\n            System.out.println(\"1\");\n            break;\n        case 5:\n            System.out.println(\"1\");\n            break;\n        case 6:\n            System.out.println(\"0\");\n            break;\n        case 7:\n            System.out.println(\"0\");\n            break;\n        default:\n            System.out.println(\"-1\");\n    }\n}\n```\n\n相关阅读：[switch case 支持的 6 种数据类型](https://mp.weixin.qq.com/s/QuchavZfEexwAgUS5qgB_Q)。\n\n大概的意思就是，周一到周五输出：1，周六到周日输出：0，默认输出-1。\n\n这样写，很多重复的逻辑，冗余了。\n\n也许这个例子不是很合适，用 if/ else 更恰当，但这只是个例子，实际开发中肯定会有某几个 case 匹配同一段逻辑的情况。\n\n那么，如何让多个 case 匹配同一段逻辑呢？\n\n如下面例子所示：\n\n```\n/**\n * @from \n * @author 栈长\n */\nprivate static void test(int value) {\n    switch (value) {\n        case 1: case 2: case 3: case 4: case 5:\n            System.out.println(\"1\");\n            break;\n        case 6: case 7:\n            System.out.println(\"0\");\n            break;\n        default:\n            System.out.println(\"-1\");\n    }\n}\n```\n\n把相同逻辑的 case 放一起，最后一个 case 写逻辑就行了。\n\n格式化后就是这样了：\n\n```\n/**\n * @from \n * @author 栈长\n */\nprivate static void test(int value) {\n    switch (value) {\n        case 1: \n        case 2: \n        case 3: \n        case 4: \n        case 5:\n            System.out.println(\"1\");\n            break;\n        case 6: \n        case 7:\n            System.out.println(\"0\");\n            break;\n        default:\n            System.out.println(\"-1\");\n    }\n}\n```\n\n是不是很骚？\n\n其实这不是最合适的最好的写法，在 Java 12 中还可以更骚。\n\n在 Java 12 中可以用逗号来分开多个值，还能用 `lambda` 表达式，甚至还能省略 break，使用 `switch` 更方便。\n\n","source":"_posts/基础/switch多值匹配骚操作，带你涨姿势！.md","raw":"---\ntitle: switch多值匹配骚操作，带你涨姿势！\ndate: 2025-10-14 14:42:34\ntags: 基础\n---\n\n我们都知道 `switch` 用来走流程分支，大多情况下用来匹配单个值，如下面的例子所示：\n\n```\n/**\n * @from \n * @author 栈长\n */\nprivate static void test(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"1\");\n            break;\n        case 2:\n            System.out.println(\"1\");\n            break;\n        case 3:\n            System.out.println(\"1\");\n            break;\n        case 4:\n            System.out.println(\"1\");\n            break;\n        case 5:\n            System.out.println(\"1\");\n            break;\n        case 6:\n            System.out.println(\"0\");\n            break;\n        case 7:\n            System.out.println(\"0\");\n            break;\n        default:\n            System.out.println(\"-1\");\n    }\n}\n```\n\n相关阅读：[switch case 支持的 6 种数据类型](https://mp.weixin.qq.com/s/QuchavZfEexwAgUS5qgB_Q)。\n\n大概的意思就是，周一到周五输出：1，周六到周日输出：0，默认输出-1。\n\n这样写，很多重复的逻辑，冗余了。\n\n也许这个例子不是很合适，用 if/ else 更恰当，但这只是个例子，实际开发中肯定会有某几个 case 匹配同一段逻辑的情况。\n\n那么，如何让多个 case 匹配同一段逻辑呢？\n\n如下面例子所示：\n\n```\n/**\n * @from \n * @author 栈长\n */\nprivate static void test(int value) {\n    switch (value) {\n        case 1: case 2: case 3: case 4: case 5:\n            System.out.println(\"1\");\n            break;\n        case 6: case 7:\n            System.out.println(\"0\");\n            break;\n        default:\n            System.out.println(\"-1\");\n    }\n}\n```\n\n把相同逻辑的 case 放一起，最后一个 case 写逻辑就行了。\n\n格式化后就是这样了：\n\n```\n/**\n * @from \n * @author 栈长\n */\nprivate static void test(int value) {\n    switch (value) {\n        case 1: \n        case 2: \n        case 3: \n        case 4: \n        case 5:\n            System.out.println(\"1\");\n            break;\n        case 6: \n        case 7:\n            System.out.println(\"0\");\n            break;\n        default:\n            System.out.println(\"-1\");\n    }\n}\n```\n\n是不是很骚？\n\n其实这不是最合适的最好的写法，在 Java 12 中还可以更骚。\n\n在 Java 12 中可以用逗号来分开多个值，还能用 `lambda` 表达式，甚至还能省略 break，使用 `switch` 更方便。\n\n","slug":"基础/switch多值匹配骚操作，带你涨姿势！","published":1,"updated":"2025-10-14T07:36:11.225Z","_id":"cmgq8bkgq0011hod40xjg5kez","comments":1,"layout":"post","photos":[],"content":"<p>我们都知道 <code>switch</code> 用来走流程分支，大多情况下用来匹配单个值，如下面的例子所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @from </span><br><span class=\"line\"> * @author 栈长</span><br><span class=\"line\"> */</span><br><span class=\"line\">private static void test(int value) &#123;</span><br><span class=\"line\">    switch (value) &#123;</span><br><span class=\"line\">        case 1:</span><br><span class=\"line\">            System.out.println(&quot;1&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 2:</span><br><span class=\"line\">            System.out.println(&quot;1&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 3:</span><br><span class=\"line\">            System.out.println(&quot;1&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 4:</span><br><span class=\"line\">            System.out.println(&quot;1&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 5:</span><br><span class=\"line\">            System.out.println(&quot;1&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 6:</span><br><span class=\"line\">            System.out.println(&quot;0&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 7:</span><br><span class=\"line\">            System.out.println(&quot;0&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            System.out.println(&quot;-1&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相关阅读：<a href=\"https://mp.weixin.qq.com/s/QuchavZfEexwAgUS5qgB_Q\">switch case 支持的 6 种数据类型</a>。</p>\n<p>大概的意思就是，周一到周五输出：1，周六到周日输出：0，默认输出-1。</p>\n<p>这样写，很多重复的逻辑，冗余了。</p>\n<p>也许这个例子不是很合适，用 if&#x2F; else 更恰当，但这只是个例子，实际开发中肯定会有某几个 case 匹配同一段逻辑的情况。</p>\n<p>那么，如何让多个 case 匹配同一段逻辑呢？</p>\n<p>如下面例子所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @from </span><br><span class=\"line\"> * @author 栈长</span><br><span class=\"line\"> */</span><br><span class=\"line\">private static void test(int value) &#123;</span><br><span class=\"line\">    switch (value) &#123;</span><br><span class=\"line\">        case 1: case 2: case 3: case 4: case 5:</span><br><span class=\"line\">            System.out.println(&quot;1&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 6: case 7:</span><br><span class=\"line\">            System.out.println(&quot;0&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            System.out.println(&quot;-1&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把相同逻辑的 case 放一起，最后一个 case 写逻辑就行了。</p>\n<p>格式化后就是这样了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @from </span><br><span class=\"line\"> * @author 栈长</span><br><span class=\"line\"> */</span><br><span class=\"line\">private static void test(int value) &#123;</span><br><span class=\"line\">    switch (value) &#123;</span><br><span class=\"line\">        case 1: </span><br><span class=\"line\">        case 2: </span><br><span class=\"line\">        case 3: </span><br><span class=\"line\">        case 4: </span><br><span class=\"line\">        case 5:</span><br><span class=\"line\">            System.out.println(&quot;1&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 6: </span><br><span class=\"line\">        case 7:</span><br><span class=\"line\">            System.out.println(&quot;0&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            System.out.println(&quot;-1&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>是不是很骚？</p>\n<p>其实这不是最合适的最好的写法，在 Java 12 中还可以更骚。</p>\n<p>在 Java 12 中可以用逗号来分开多个值，还能用 <code>lambda</code> 表达式，甚至还能省略 break，使用 <code>switch</code> 更方便。</p>\n","excerpt":"","more":"<p>我们都知道 <code>switch</code> 用来走流程分支，大多情况下用来匹配单个值，如下面的例子所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @from </span><br><span class=\"line\"> * @author 栈长</span><br><span class=\"line\"> */</span><br><span class=\"line\">private static void test(int value) &#123;</span><br><span class=\"line\">    switch (value) &#123;</span><br><span class=\"line\">        case 1:</span><br><span class=\"line\">            System.out.println(&quot;1&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 2:</span><br><span class=\"line\">            System.out.println(&quot;1&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 3:</span><br><span class=\"line\">            System.out.println(&quot;1&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 4:</span><br><span class=\"line\">            System.out.println(&quot;1&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 5:</span><br><span class=\"line\">            System.out.println(&quot;1&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 6:</span><br><span class=\"line\">            System.out.println(&quot;0&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 7:</span><br><span class=\"line\">            System.out.println(&quot;0&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            System.out.println(&quot;-1&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相关阅读：<a href=\"https://mp.weixin.qq.com/s/QuchavZfEexwAgUS5qgB_Q\">switch case 支持的 6 种数据类型</a>。</p>\n<p>大概的意思就是，周一到周五输出：1，周六到周日输出：0，默认输出-1。</p>\n<p>这样写，很多重复的逻辑，冗余了。</p>\n<p>也许这个例子不是很合适，用 if&#x2F; else 更恰当，但这只是个例子，实际开发中肯定会有某几个 case 匹配同一段逻辑的情况。</p>\n<p>那么，如何让多个 case 匹配同一段逻辑呢？</p>\n<p>如下面例子所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @from </span><br><span class=\"line\"> * @author 栈长</span><br><span class=\"line\"> */</span><br><span class=\"line\">private static void test(int value) &#123;</span><br><span class=\"line\">    switch (value) &#123;</span><br><span class=\"line\">        case 1: case 2: case 3: case 4: case 5:</span><br><span class=\"line\">            System.out.println(&quot;1&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 6: case 7:</span><br><span class=\"line\">            System.out.println(&quot;0&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            System.out.println(&quot;-1&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把相同逻辑的 case 放一起，最后一个 case 写逻辑就行了。</p>\n<p>格式化后就是这样了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @from </span><br><span class=\"line\"> * @author 栈长</span><br><span class=\"line\"> */</span><br><span class=\"line\">private static void test(int value) &#123;</span><br><span class=\"line\">    switch (value) &#123;</span><br><span class=\"line\">        case 1: </span><br><span class=\"line\">        case 2: </span><br><span class=\"line\">        case 3: </span><br><span class=\"line\">        case 4: </span><br><span class=\"line\">        case 5:</span><br><span class=\"line\">            System.out.println(&quot;1&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case 6: </span><br><span class=\"line\">        case 7:</span><br><span class=\"line\">            System.out.println(&quot;0&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            System.out.println(&quot;-1&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>是不是很骚？</p>\n<p>其实这不是最合适的最好的写法，在 Java 12 中还可以更骚。</p>\n<p>在 Java 12 中可以用逗号来分开多个值，还能用 <code>lambda</code> 表达式，甚至还能省略 break，使用 <code>switch</code> 更方便。</p>\n"},{"title":"字符串拼接 + 和 concat 的区别","date":"2025-10-14T06:42:34.000Z","_content":"\n+和concat都可以用来拼接字符串，但在使用上有什么区别呢，先来看看这个例子。\n\n```\npublic static void main(String[] args) {\n\t// example1\n\tString str1 = \"s1\";\n\tSystem.out.println(str1 + 100);//s1100\n\tSystem.out.println(100 + str1);//100s1\n\n\tString str2 = \"s2\";\n\tstr2 = str2.concat(\"a\").concat(\"bc\");\n\tSystem.out.println(str2);//s2abc\n\n\t// example2\n\tString str3 = \"s3\";\n\tSystem.out.println(str3 + null);//s3null\n\tSystem.out.println(null + str3);//nulls3\n\n\tString str4 = null;\n\tSystem.out.println(str4.concat(\"a\"));//NullPointerException\n\tSystem.out.println(\"a\".concat(str4));//NullPointerException\n}\n```\n\nconcat源码：\n\n```\npublic String concat(String str) {\n    int otherLen = str.length();\n    if (otherLen == 0) {\n        return this;\n    }\n    int len = value.length;\n    char buf[] = Arrays.copyOf(value, len + otherLen);\n    str.getChars(buf, len);\n    return new String(buf, true);\n}\n```\n\n看下生成的字节码：\n\n\n#### 所以可以得出以下结论：\n\n1. +可以是字符串或者数字及其他基本类型数据，而concat只能接收字符串。\n\n2. +左右可以为null，concat为会空指针。\n\n3. 如果拼接空字符串，concat会稍快，在速度上两者可以忽略不计，如果拼接更多字符串建议用StringBuilder。\n\n4. 从字节码来看+号编译后就是使用了StringBuiler来拼接，所以一行+++的语句就会创建一个StringBuilder，多条+++语句就会创建多个，所以为什么建议用StringBuilder的原因。\n\n","source":"_posts/基础/字符串拼接 + 和 concat 的区别.md","raw":"---\ntitle: 字符串拼接 + 和 concat 的区别\ndate: 2025-10-14 14:42:34\ntags: 基础\n---\n\n+和concat都可以用来拼接字符串，但在使用上有什么区别呢，先来看看这个例子。\n\n```\npublic static void main(String[] args) {\n\t// example1\n\tString str1 = \"s1\";\n\tSystem.out.println(str1 + 100);//s1100\n\tSystem.out.println(100 + str1);//100s1\n\n\tString str2 = \"s2\";\n\tstr2 = str2.concat(\"a\").concat(\"bc\");\n\tSystem.out.println(str2);//s2abc\n\n\t// example2\n\tString str3 = \"s3\";\n\tSystem.out.println(str3 + null);//s3null\n\tSystem.out.println(null + str3);//nulls3\n\n\tString str4 = null;\n\tSystem.out.println(str4.concat(\"a\"));//NullPointerException\n\tSystem.out.println(\"a\".concat(str4));//NullPointerException\n}\n```\n\nconcat源码：\n\n```\npublic String concat(String str) {\n    int otherLen = str.length();\n    if (otherLen == 0) {\n        return this;\n    }\n    int len = value.length;\n    char buf[] = Arrays.copyOf(value, len + otherLen);\n    str.getChars(buf, len);\n    return new String(buf, true);\n}\n```\n\n看下生成的字节码：\n\n\n#### 所以可以得出以下结论：\n\n1. +可以是字符串或者数字及其他基本类型数据，而concat只能接收字符串。\n\n2. +左右可以为null，concat为会空指针。\n\n3. 如果拼接空字符串，concat会稍快，在速度上两者可以忽略不计，如果拼接更多字符串建议用StringBuilder。\n\n4. 从字节码来看+号编译后就是使用了StringBuiler来拼接，所以一行+++的语句就会创建一个StringBuilder，多条+++语句就会创建多个，所以为什么建议用StringBuilder的原因。\n\n","slug":"基础/字符串拼接 + 和 concat 的区别","published":1,"updated":"2025-10-14T07:32:45.036Z","_id":"cmgq8bkh70012hod41pw81tig","comments":1,"layout":"post","photos":[],"content":"<p>+和concat都可以用来拼接字符串，但在使用上有什么区别呢，先来看看这个例子。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\t// example1</span><br><span class=\"line\">\tString str1 = &quot;s1&quot;;</span><br><span class=\"line\">\tSystem.out.println(str1 + 100);//s1100</span><br><span class=\"line\">\tSystem.out.println(100 + str1);//100s1</span><br><span class=\"line\"></span><br><span class=\"line\">\tString str2 = &quot;s2&quot;;</span><br><span class=\"line\">\tstr2 = str2.concat(&quot;a&quot;).concat(&quot;bc&quot;);</span><br><span class=\"line\">\tSystem.out.println(str2);//s2abc</span><br><span class=\"line\"></span><br><span class=\"line\">\t// example2</span><br><span class=\"line\">\tString str3 = &quot;s3&quot;;</span><br><span class=\"line\">\tSystem.out.println(str3 + null);//s3null</span><br><span class=\"line\">\tSystem.out.println(null + str3);//nulls3</span><br><span class=\"line\"></span><br><span class=\"line\">\tString str4 = null;</span><br><span class=\"line\">\tSystem.out.println(str4.concat(&quot;a&quot;));//NullPointerException</span><br><span class=\"line\">\tSystem.out.println(&quot;a&quot;.concat(str4));//NullPointerException</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>concat源码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String concat(String str) &#123;</span><br><span class=\"line\">    int otherLen = str.length();</span><br><span class=\"line\">    if (otherLen == 0) &#123;</span><br><span class=\"line\">        return this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int len = value.length;</span><br><span class=\"line\">    char buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class=\"line\">    str.getChars(buf, len);</span><br><span class=\"line\">    return new String(buf, true);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看下生成的字节码：</p>\n<h4 id=\"所以可以得出以下结论：\"><a href=\"#所以可以得出以下结论：\" class=\"headerlink\" title=\"所以可以得出以下结论：\"></a>所以可以得出以下结论：</h4><ol>\n<li><p>+可以是字符串或者数字及其他基本类型数据，而concat只能接收字符串。</p>\n</li>\n<li><p>+左右可以为null，concat为会空指针。</p>\n</li>\n<li><p>如果拼接空字符串，concat会稍快，在速度上两者可以忽略不计，如果拼接更多字符串建议用StringBuilder。</p>\n</li>\n<li><p>从字节码来看+号编译后就是使用了StringBuiler来拼接，所以一行+++的语句就会创建一个StringBuilder，多条+++语句就会创建多个，所以为什么建议用StringBuilder的原因。</p>\n</li>\n</ol>\n","excerpt":"","more":"<p>+和concat都可以用来拼接字符串，但在使用上有什么区别呢，先来看看这个例子。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\t// example1</span><br><span class=\"line\">\tString str1 = &quot;s1&quot;;</span><br><span class=\"line\">\tSystem.out.println(str1 + 100);//s1100</span><br><span class=\"line\">\tSystem.out.println(100 + str1);//100s1</span><br><span class=\"line\"></span><br><span class=\"line\">\tString str2 = &quot;s2&quot;;</span><br><span class=\"line\">\tstr2 = str2.concat(&quot;a&quot;).concat(&quot;bc&quot;);</span><br><span class=\"line\">\tSystem.out.println(str2);//s2abc</span><br><span class=\"line\"></span><br><span class=\"line\">\t// example2</span><br><span class=\"line\">\tString str3 = &quot;s3&quot;;</span><br><span class=\"line\">\tSystem.out.println(str3 + null);//s3null</span><br><span class=\"line\">\tSystem.out.println(null + str3);//nulls3</span><br><span class=\"line\"></span><br><span class=\"line\">\tString str4 = null;</span><br><span class=\"line\">\tSystem.out.println(str4.concat(&quot;a&quot;));//NullPointerException</span><br><span class=\"line\">\tSystem.out.println(&quot;a&quot;.concat(str4));//NullPointerException</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>concat源码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String concat(String str) &#123;</span><br><span class=\"line\">    int otherLen = str.length();</span><br><span class=\"line\">    if (otherLen == 0) &#123;</span><br><span class=\"line\">        return this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int len = value.length;</span><br><span class=\"line\">    char buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class=\"line\">    str.getChars(buf, len);</span><br><span class=\"line\">    return new String(buf, true);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看下生成的字节码：</p>\n<h4 id=\"所以可以得出以下结论：\"><a href=\"#所以可以得出以下结论：\" class=\"headerlink\" title=\"所以可以得出以下结论：\"></a>所以可以得出以下结论：</h4><ol>\n<li><p>+可以是字符串或者数字及其他基本类型数据，而concat只能接收字符串。</p>\n</li>\n<li><p>+左右可以为null，concat为会空指针。</p>\n</li>\n<li><p>如果拼接空字符串，concat会稍快，在速度上两者可以忽略不计，如果拼接更多字符串建议用StringBuilder。</p>\n</li>\n<li><p>从字节码来看+号编译后就是使用了StringBuiler来拼接，所以一行+++的语句就会创建一个StringBuilder，多条+++语句就会创建多个，所以为什么建议用StringBuilder的原因。</p>\n</li>\n</ol>\n"},{"title":"通用唯一标识码 UUID 的介绍及使用。","date":"2025-10-14T06:42:34.000Z","_content":"\n#### 什么是UUID？\n\nUUID全称：Universally Unique Identifier，即通用唯一识别码。\n\nUUID是由一组32位数的16进制数字所构成，是故UUID理论上的总数为16^32 = 2^128，约等于3.4 x 10^38。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。\n\nUUID的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的32个字符，如：550e8400-e29b-41d4-a716-446655440000。\n\n#### UUID的作用\n\nUUID的是让分布式系统中的所有元素都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。如此一来，每个人都可以创建不与其它人冲突的UUID。在这样的情况下，就不需考虑数据库创建时的名称重复问题。目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID），而其他重要的应用，则有Linux ext2/ext3文件系统、LUKS加密分区、GNOME、KDE、Mac OS X等等。\n\n#### UUID的组成\n\nUUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。\n\n**UUID由以下几部分的组合：**\n\n- 当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。\n\n- 时钟序列。\n\n- 全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。\n\nUUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。\n\n#### UUID的生成\n\n```\npublic static void main(String[] args) throws Exception {\n\tSystem.out.println(UUID.randomUUID());\n}\n```\n\n> 批量生成UUID网站：http://www.uuid.online/","source":"_posts/基础/通用唯一标识码 UUID 的介绍及使用。.md","raw":"---\ntitle: 通用唯一标识码 UUID 的介绍及使用。\ndate: 2025-10-14 14:42:34\ntags: 基础\n---\n\n#### 什么是UUID？\n\nUUID全称：Universally Unique Identifier，即通用唯一识别码。\n\nUUID是由一组32位数的16进制数字所构成，是故UUID理论上的总数为16^32 = 2^128，约等于3.4 x 10^38。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。\n\nUUID的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的32个字符，如：550e8400-e29b-41d4-a716-446655440000。\n\n#### UUID的作用\n\nUUID的是让分布式系统中的所有元素都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。如此一来，每个人都可以创建不与其它人冲突的UUID。在这样的情况下，就不需考虑数据库创建时的名称重复问题。目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID），而其他重要的应用，则有Linux ext2/ext3文件系统、LUKS加密分区、GNOME、KDE、Mac OS X等等。\n\n#### UUID的组成\n\nUUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。\n\n**UUID由以下几部分的组合：**\n\n- 当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。\n\n- 时钟序列。\n\n- 全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。\n\nUUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。\n\n#### UUID的生成\n\n```\npublic static void main(String[] args) throws Exception {\n\tSystem.out.println(UUID.randomUUID());\n}\n```\n\n> 批量生成UUID网站：http://www.uuid.online/","slug":"基础/通用唯一标识码 UUID 的介绍及使用。","published":1,"updated":"2025-10-14T07:31:22.871Z","_id":"cmgq8bkhm0013hod4gnih79f8","comments":1,"layout":"post","photos":[],"content":"<h4 id=\"什么是UUID？\"><a href=\"#什么是UUID？\" class=\"headerlink\" title=\"什么是UUID？\"></a>什么是UUID？</h4><p>UUID全称：Universally Unique Identifier，即通用唯一识别码。</p>\n<p>UUID是由一组32位数的16进制数字所构成，是故UUID理论上的总数为16^32 &#x3D; 2^128，约等于3.4 x 10^38。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。</p>\n<p>UUID的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的32个字符，如：550e8400-e29b-41d4-a716-446655440000。</p>\n<h4 id=\"UUID的作用\"><a href=\"#UUID的作用\" class=\"headerlink\" title=\"UUID的作用\"></a>UUID的作用</h4><p>UUID的是让分布式系统中的所有元素都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。如此一来，每个人都可以创建不与其它人冲突的UUID。在这样的情况下，就不需考虑数据库创建时的名称重复问题。目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID），而其他重要的应用，则有Linux ext2&#x2F;ext3文件系统、LUKS加密分区、GNOME、KDE、Mac OS X等等。</p>\n<h4 id=\"UUID的组成\"><a href=\"#UUID的组成\" class=\"headerlink\" title=\"UUID的组成\"></a>UUID的组成</h4><p>UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。</p>\n<p><strong>UUID由以下几部分的组合：</strong></p>\n<ul>\n<li><p>当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。</p>\n</li>\n<li><p>时钟序列。</p>\n</li>\n<li><p>全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。</p>\n</li>\n</ul>\n<p>UUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。</p>\n<h4 id=\"UUID的生成\"><a href=\"#UUID的生成\" class=\"headerlink\" title=\"UUID的生成\"></a>UUID的生成</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\tSystem.out.println(UUID.randomUUID());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>批量生成UUID网站：<a href=\"http://www.uuid.online/\">http://www.uuid.online/</a></p>\n</blockquote>\n","excerpt":"","more":"<h4 id=\"什么是UUID？\"><a href=\"#什么是UUID？\" class=\"headerlink\" title=\"什么是UUID？\"></a>什么是UUID？</h4><p>UUID全称：Universally Unique Identifier，即通用唯一识别码。</p>\n<p>UUID是由一组32位数的16进制数字所构成，是故UUID理论上的总数为16^32 &#x3D; 2^128，约等于3.4 x 10^38。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。</p>\n<p>UUID的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的32个字符，如：550e8400-e29b-41d4-a716-446655440000。</p>\n<h4 id=\"UUID的作用\"><a href=\"#UUID的作用\" class=\"headerlink\" title=\"UUID的作用\"></a>UUID的作用</h4><p>UUID的是让分布式系统中的所有元素都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。如此一来，每个人都可以创建不与其它人冲突的UUID。在这样的情况下，就不需考虑数据库创建时的名称重复问题。目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID），而其他重要的应用，则有Linux ext2&#x2F;ext3文件系统、LUKS加密分区、GNOME、KDE、Mac OS X等等。</p>\n<h4 id=\"UUID的组成\"><a href=\"#UUID的组成\" class=\"headerlink\" title=\"UUID的组成\"></a>UUID的组成</h4><p>UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。</p>\n<p><strong>UUID由以下几部分的组合：</strong></p>\n<ul>\n<li><p>当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。</p>\n</li>\n<li><p>时钟序列。</p>\n</li>\n<li><p>全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。</p>\n</li>\n</ul>\n<p>UUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。</p>\n<h4 id=\"UUID的生成\"><a href=\"#UUID的生成\" class=\"headerlink\" title=\"UUID的生成\"></a>UUID的生成</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">\tSystem.out.println(UUID.randomUUID());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>批量生成UUID网站：<a href=\"http://www.uuid.online/\">http://www.uuid.online/</a></p>\n</blockquote>\n"},{"title":"关于 Java 序列化你不知道的 5 件事","date":"2025-10-14T06:42:34.000Z","_content":"\n### 关于本系列\n\n大约一年前，一个负责管理应用程序所有用户设置的开发人员，决定将用户设置存储在一个 Hashtable中，然后将这个 Hashtable 序列化到磁盘，以便持久化。当用户更改设置时，便重新将 Hashtable 写到磁盘。\n\n这是一个优雅的、开放式的设置系统，但是，当团队决定从 Hashtable 迁移到 Java Collections 库中的HashMap 时，这个系统便面临崩溃。\n\nHashtable 和 HashMap 在磁盘上的格式是不相同、不兼容的。除非对每个持久化的用户设置运行某种类型的数据转换实用程序（极其庞大的任务），否则以后似乎只能一直用Hashtable 作为应用程序的存储格式。\n\n团队感到陷入僵局，但这只是因为他们不知道关于 Java 序列化的一个重要事实：Java 序列化允许随着时间的推移而改变类型。当我向他们展示如何自动进行序列化替换后，他们终于按计划完成了向 HashMap 的转变。\n\n本文是本系列的第一篇文章，这个系列专门揭示关于 Java 平台的一些有用的小知识 — 这些小知识不易理解，但对于解决 Java 编程挑战迟早有用。\n\n将 Java 对象序列化 API 作为开端是一个不错的选择，因为它从一开始就存在于 JDK 1.1 中。本文介绍的关于序列化的 5 件事情将说服您重新审视那些标准 Java API。\n\n### Java 序列化简介\n\nJava 对象序列化是 JDK 1.1 中引入的一组开创性特性之一，用于作为一种将 Java 对象的状态转换为字节数组，以便存储或传输的机制，以后，仍可以将字节数组转换回 Java 对象原有的状态。\n\n实际上，序列化的思想是 “冻结” 对象状态，传输对象状态（写到磁盘、通过网络传输等等），然后 “解冻” 状态，重新获得可用的 Java 对象。所有这些事情的发生有点像是魔术，这要归功于 ObjectInputStream/ObjectOutputStream 类、完全保真的元数据以及程序员愿意用Serializable 标识接口标记他们的类，从而 “参与” 这个过程。\n\n清单 1 显示一个实现 Serializable 的 Person 类。\n\n**清单 1. Serializable Person**\n\n\n```\npackage com.tedneward;\n\npublic class Person\n    implements java.io.Serializable\n{\n    public Person(String fn, String ln, int a)\n    {\n        this.firstName = fn; this.lastName = ln; this.age = a;\n    }\n\n    public String getFirstName() { return firstName; }\n    public String getLastName() { return lastName; }\n    public int getAge() { return age; }\n    public Person getSpouse() { return spouse; }\n\n    public void setFirstName(String value) { firstName = value; }\n    public void setLastName(String value) { lastName = value; }\n    public void setAge(int value) { age = value; }\n    public void setSpouse(Person value) { spouse = value; }\n\n    public String toString()\n    {\n        return \"[Person: firstName=\" + firstName + \n            \" lastName=\" + lastName +\n            \" age=\" + age +\n            \" spouse=\" + spouse.getFirstName() +\n            \"]\";\n    }    \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n\n}\n```\n\n将 Person 序列化后，很容易将对象状态写到磁盘，然后重新读出它，下面的 JUnit 4 单元测试对此做了演示。\n\n**清单 2. 对 Person 进行反序列化**\n\n\n```\npublic class SerTest\n{\n    @Test public void serializeToDisk()\n    {\n        try\n        {\n            com.tedneward.Person ted = new com.tedneward.Person(\"Ted\", \"Neward\", 39);\n            com.tedneward.Person charl = new com.tedneward.Person(\"Charlotte\",\n                \"Neward\", 38);\n\n            ted.setSpouse(charl); charl.setSpouse(ted);\n\n            FileOutputStream fos = new FileOutputStream(\"tempdata.ser\");\n            ObjectOutputStream oos = new ObjectOutputStream(fos);\n            oos.writeObject(ted);\n            oos.close();\n        }\n        catch (Exception ex)\n        {\n            fail(\"Exception thrown during test: \" + ex.toString());\n        }\n\n        try\n        {\n            FileInputStream fis = new FileInputStream(\"tempdata.ser\");\n            ObjectInputStream ois = new ObjectInputStream(fis);\n            com.tedneward.Person ted = (com.tedneward.Person) ois.readObject();\n            ois.close();\n\n            assertEquals(ted.getFirstName(）， \"Ted\");\n            assertEquals(ted.getSpouse().getFirstName(）， \"Charlotte\");\n\n            // Clean up the file\n            new File(\"tempdata.ser\").delete();\n        }\n        catch (Exception ex)\n        {\n            fail(\"Exception thrown during test: \" + ex.toString());\n        }\n    }\n}\n```\n\n到现在为止，还没有看到什么新鲜的或令人兴奋的事情，但是这是一个很好的出发点。我们将使用 Person 来发现您可能不 知道的关于 Java 对象序列化 的 5 件事。\n\n#### 1. 序列化允许重构\n\n序列化允许一定数量的类变种，甚至重构之后也是如此，ObjectInputStream 仍可以很好地将其读出来。\nJava Object Serialization 规范可以自动管理的关键任务是：\n\n- 将新字段添加到类中\n\n- 将字段从 static 改为非 static\n\n- 将字段从 transient 改为非 transient\n\n取决于所需的向后兼容程度，转换字段形式（从非 static 转换为 static 或从非 transient 转换为 transient）或者删除字段需要额外的消息传递。\n\n**重构序列化类**\n\n既然已经知道序列化允许重构，我们来看看当把新字段添加到 Person 类中时，会发生什么事情。\n\n如清单 3 所示，PersonV2 在原先 Person 类的基础上引入一个表示性别的新字段。\n\n**清单 3. 将新字段添加到序列化的 Person 中**\n\n\n```\nenum Gender\n{\n    MALE, FEMALE\n}\n\npublic class Person\n    implements java.io.Serializable\n{\n    public Person(String fn, String ln, int a, Gender g)\n    {\n        this.firstName = fn; this.lastName = ln; this.age = a; this.gender = g;\n    }\n\n    public String getFirstName() { return firstName; }\n    public String getLastName() { return lastName; }\n    public Gender getGender() { return gender; }\n    public int getAge() { return age; }\n    public Person getSpouse() { return spouse; }\n\n    public void setFirstName(String value) { firstName = value; }\n    public void setLastName(String value) { lastName = value; }\n    public void setGender(Gender value) { gender = value; }\n    public void setAge(int value) { age = value; }\n    public void setSpouse(Person value) { spouse = value; }\n\n    public String toString()\n    {\n        return \"[Person: firstName=\" + firstName + \n            \" lastName=\" + lastName +\n            \" gender=\" + gender +\n            \" age=\" + age +\n            \" spouse=\" + spouse.getFirstName() +\n            \"]\";\n    }    \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n    private Gender gender;\n}\n```\n\n序列化使用一个 hash，该 hash 是根据给定源文件中几乎所有东西 — 方法名称、字段名称、字段类型、访问修改方法等 — 计算出来的，序列化将该 hash 值与序列化流中的 hash 值相比较。\n\n为了使 Java 运行时相信两种类型实际上是一样的，第二版和随后版本的 Person 必须与第一版有相同的序列化版本 hash（存储为 private static final serialVersionUID 字段）。\n\n因此，我们需要 serialVersionUID 字段，它是通过对原始（或 V1）版本的 Person 类运行 JDK serialver命令计算出的。\n\n一旦有了 Person 的 serialVersionUID，不仅可以从原始对象 Person 的序列化数据创建 PersonV2 对象（当出现新字段时，新字段被设为缺省值，最常见的是“null”），还可以反过来做：即从 PersonV2 的数据通过反序列化得到 Person，这毫不奇怪。\n\n#### 2. 序列化并不安全\n\n让 Java 开发人员诧异并感到不快的是，序列化二进制格式完全编写在文档中，并且完全可逆。实际上，只需将二进制序列化流的内容转储到控制台，就足以看清类是什么样子，以及它包含什么内容。\n\n这对于安全性有着不良影响。例如，当通过 RMI 进行远程方法调用时，通过连接发送的对象中的任何 private 字段几乎都是以明文的方式出现在套接字流中，这显然容易招致哪怕最简单的安全问题。\n\n幸运的是，序列化允许 “hook” 序列化过程，并在序列化之前和反序列化之后保护（或模糊化）字段数据。可以通过在 Serializable 对象上提供一个 writeObject 方法来做到这一点。\n\n**模糊化序列化数据**\n\n假设 Person 类中的敏感数据是 age 字段。毕竟，女士忌谈年龄。 我们可以在序列化之前模糊化该数据，将数位循环左移一位，然后在反序列化之后复位。（您可以开发更安全的算法，当前这个算法只是作为一个例子。）\n\n为了 “hook” 序列化过程，我们将在 Person 上实现一个 writeObject 方法；为了 “hook” 反序列化过程，我们将在同一个类上实现一个readObject 方法。重要的是这两个方法的细节要正确 — 如果访问修改方法、参数或名称不同于清单 4 中的内容，那么代码将不被察觉地失败，Person 的 age 将暴露。\n\n**清单 4. 模糊化序列化数据**\n\n\n```\npublic class Person\n    implements java.io.Serializable\n{\n    public Person(String fn, String ln, int a)\n    {\n        this.firstName = fn; this.lastName = ln; this.age = a;\n    }\n\n    public String getFirstName() { return firstName; }\n    public String getLastName() { return lastName; }\n    public int getAge() { return age; }\n    public Person getSpouse() { return spouse; }\n\n    public void setFirstName(String value) { firstName = value; }\n    public void setLastName(String value) { lastName = value; }\n    public void setAge(int value) { age = value; }\n    public void setSpouse(Person value) { spouse = value; }\n\n    private void writeObject(java.io.ObjectOutputStream stream)\n        throws java.io.IOException\n    {\n        // \"Encrypt\"/obscure the sensitive data\n        age = age << 2;\n        stream.defaultWriteObject();\n    }\n\n    private void readObject(java.io.ObjectInputStream stream)\n        throws java.io.IOException, ClassNotFoundException\n    {\n        stream.defaultReadObject();\n\n        // \"Decrypt\"/de-obscure the sensitive data\n        age = age << 2;\n    }\n\n    public String toString()\n    {\n        return \"[Person: firstName=\" + firstName + \n            \" lastName=\" + lastName +\n            \" age=\" + age +\n            \" spouse=\" + (spouse!=null ? spouse.getFirstName() : \"[null]\") +\n            \"]\";\n    }      \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n}\n```\n\n如果需要查看被模糊化的数据，总是可以查看序列化数据流/文件。而且，由于该格式被完全文档化，即使不能访问类本身，也仍可以读取序列化流中的内容。\n\n#### 3. 序列化的数据可以被签名和密封\n\n上一个技巧假设您想模糊化序列化数据，而不是对其加密或者确保它不被修改。当然，通过使用 writeObject 和 readObject 可以实现密码加密和签名管理，但其实还有更好的方式。\n\n如果需要对整个对象进行加密和签名，最简单的是将它放在一个 javax.crypto.SealedObject 和/或 java.security.SignedObject 包装器中。两者都是可序列化的，所以将对象包装在 SealedObject 中可以围绕原对象创建一种“包装盒”。必须有对称密钥才能解密，而且密钥必须单独管理。同样，也可以将 SignedObject 用于数据验证，并且对称密钥也必须单独管理。\n\n结合使用这两种对象，便可以轻松地对序列化数据进行密封和签名，而不必强调关于数字签名验证或加密的细节。很简洁，是吧？\n\n#### 4. 序列化允许将代理放在流中\n\n很多情况下，类中包含一个核心数据元素，通过它可以派生或找到类中的其他字段。在此情况下，没有必要序列化整个对象。可以将字段标记为 transient，但是每当有方法访问一个字段时，类仍然必须显式地产生代码来检查它是否被初始化。\n\n如果首要问题是序列化，那么最好指定一个 flyweight 或代理放在流中。为原始 Person 提供一个 writeReplace 方法，可以序列化不同类型的对象来代替它。类似地，如果反序列化期间发现一个 readResolve 方法，那么将调用该方法，将替代对象提供给调用者。\n\n**打包和解包代理**\n\nwriteReplace 和 readResolve 方法使 Person 类可以将它的所有数据（或其中的核心数据）打包到一个 PersonProxy 中，将它放入到一个流中，然后在反序列化时再进行解包。\n\n**清单 5. 你完整了我，我代替了你**\n\n\n```\nclass PersonProxy\n    implements java.io.Serializable\n{\n    public PersonProxy(Person orig)\n    {\n        data = orig.getFirstName() + \",\" + orig.getLastName() + \",\" + orig.getAge();\n        if (orig.getSpouse() != null)\n        {\n            Person spouse = orig.getSpouse();\n            data = data + \",\" + spouse.getFirstName() + \",\" + spouse.getLastName() + \",\"  \n              + spouse.getAge();\n        }\n    }\n\n    public String data;\n    private Object readResolve()\n        throws java.io.ObjectStreamException\n    {\n        String[] pieces = data.split(\",\");\n        Person result = new Person(pieces[0], pieces[1], Integer.parseInt(pieces[2]));\n        if (pieces.length > 3)\n        {\n            result.setSpouse(new Person(pieces[3], pieces[4], Integer.parseInt\n              (pieces[5])));\n            result.getSpouse().setSpouse(result);\n        }\n        return result;\n    }\n}\n\npublic class Person\n    implements java.io.Serializable\n{\n    public Person(String fn, String ln, int a)\n    {\n        this.firstName = fn; this.lastName = ln; this.age = a;\n    }\n\n    public String getFirstName() { return firstName; }\n    public String getLastName() { return lastName; }\n    public int getAge() { return age; }\n    public Person getSpouse() { return spouse; }\n\n    private Object writeReplace()\n        throws java.io.ObjectStreamException\n    {\n        return new PersonProxy(this);\n    }\n\n    public void setFirstName(String value) { firstName = value; }\n    public void setLastName(String value) { lastName = value; }\n    public void setAge(int value) { age = value; }\n    public void setSpouse(Person value) { spouse = value; }   \n\n    public String toString()\n    {\n        return \"[Person: firstName=\" + firstName + \n            \" lastName=\" + lastName +\n            \" age=\" + age +\n            \" spouse=\" + spouse.getFirstName() +\n            \"]\";\n    }    \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n}\n```\n\n注意，PersonProxy 必须跟踪 Person 的所有数据。这通常意味着代理需要是 Person 的一个内部类，以便能访问 private 字段。有时候，代理还需要追踪其他对象引用并手动序列化它们，例如 Person 的 spouse。\n\n这种技巧是少数几种不需要读/写平衡的技巧之一。例如，一个类被重构成另一种类型后的版本可以提供一个 readResolve 方法，以便静默地将被序列化的对象转换成新类型。类似地，它可以采用 writeReplace 方法将旧类序列化成新版本。\n\n#### 5. 信任，但要验证\n\n认为序列化流中的数据总是与最初写到流中的数据一致，这没有问题。但是，正如一位美国前总统所说的，“信任，但要验证”。\n对于序列化的对象，这意味着验证字段，以确保在反序列化之后它们仍具有正确的值，“以防万一”。\n\n为此，可以实现 ObjectInputValidation接口，并覆盖 validateObject() 方法。如果调用该方法时发现某处有错误，则抛出一个 InvalidObjectException。\n\n### 结束语\n\nJava 对象序列化比大多数 Java 开发人员想象的更灵活，这使我们有更多的机会解决棘手的情况。\n\n幸运的是，像这样的编程妙招在 JVM 中随处可见。关键是要知道它们，在遇到难题的时候能用上它们。\n\n来源：www.topthink.com/topic/11361.html","source":"_posts/基础/关于 Java 序列化你不知道的 5 件事.md","raw":"---\ntitle: 关于 Java 序列化你不知道的 5 件事\ndate: 2025-10-14 14:42:34\ntags: 基础\n---\n\n### 关于本系列\n\n大约一年前，一个负责管理应用程序所有用户设置的开发人员，决定将用户设置存储在一个 Hashtable中，然后将这个 Hashtable 序列化到磁盘，以便持久化。当用户更改设置时，便重新将 Hashtable 写到磁盘。\n\n这是一个优雅的、开放式的设置系统，但是，当团队决定从 Hashtable 迁移到 Java Collections 库中的HashMap 时，这个系统便面临崩溃。\n\nHashtable 和 HashMap 在磁盘上的格式是不相同、不兼容的。除非对每个持久化的用户设置运行某种类型的数据转换实用程序（极其庞大的任务），否则以后似乎只能一直用Hashtable 作为应用程序的存储格式。\n\n团队感到陷入僵局，但这只是因为他们不知道关于 Java 序列化的一个重要事实：Java 序列化允许随着时间的推移而改变类型。当我向他们展示如何自动进行序列化替换后，他们终于按计划完成了向 HashMap 的转变。\n\n本文是本系列的第一篇文章，这个系列专门揭示关于 Java 平台的一些有用的小知识 — 这些小知识不易理解，但对于解决 Java 编程挑战迟早有用。\n\n将 Java 对象序列化 API 作为开端是一个不错的选择，因为它从一开始就存在于 JDK 1.1 中。本文介绍的关于序列化的 5 件事情将说服您重新审视那些标准 Java API。\n\n### Java 序列化简介\n\nJava 对象序列化是 JDK 1.1 中引入的一组开创性特性之一，用于作为一种将 Java 对象的状态转换为字节数组，以便存储或传输的机制，以后，仍可以将字节数组转换回 Java 对象原有的状态。\n\n实际上，序列化的思想是 “冻结” 对象状态，传输对象状态（写到磁盘、通过网络传输等等），然后 “解冻” 状态，重新获得可用的 Java 对象。所有这些事情的发生有点像是魔术，这要归功于 ObjectInputStream/ObjectOutputStream 类、完全保真的元数据以及程序员愿意用Serializable 标识接口标记他们的类，从而 “参与” 这个过程。\n\n清单 1 显示一个实现 Serializable 的 Person 类。\n\n**清单 1. Serializable Person**\n\n\n```\npackage com.tedneward;\n\npublic class Person\n    implements java.io.Serializable\n{\n    public Person(String fn, String ln, int a)\n    {\n        this.firstName = fn; this.lastName = ln; this.age = a;\n    }\n\n    public String getFirstName() { return firstName; }\n    public String getLastName() { return lastName; }\n    public int getAge() { return age; }\n    public Person getSpouse() { return spouse; }\n\n    public void setFirstName(String value) { firstName = value; }\n    public void setLastName(String value) { lastName = value; }\n    public void setAge(int value) { age = value; }\n    public void setSpouse(Person value) { spouse = value; }\n\n    public String toString()\n    {\n        return \"[Person: firstName=\" + firstName + \n            \" lastName=\" + lastName +\n            \" age=\" + age +\n            \" spouse=\" + spouse.getFirstName() +\n            \"]\";\n    }    \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n\n}\n```\n\n将 Person 序列化后，很容易将对象状态写到磁盘，然后重新读出它，下面的 JUnit 4 单元测试对此做了演示。\n\n**清单 2. 对 Person 进行反序列化**\n\n\n```\npublic class SerTest\n{\n    @Test public void serializeToDisk()\n    {\n        try\n        {\n            com.tedneward.Person ted = new com.tedneward.Person(\"Ted\", \"Neward\", 39);\n            com.tedneward.Person charl = new com.tedneward.Person(\"Charlotte\",\n                \"Neward\", 38);\n\n            ted.setSpouse(charl); charl.setSpouse(ted);\n\n            FileOutputStream fos = new FileOutputStream(\"tempdata.ser\");\n            ObjectOutputStream oos = new ObjectOutputStream(fos);\n            oos.writeObject(ted);\n            oos.close();\n        }\n        catch (Exception ex)\n        {\n            fail(\"Exception thrown during test: \" + ex.toString());\n        }\n\n        try\n        {\n            FileInputStream fis = new FileInputStream(\"tempdata.ser\");\n            ObjectInputStream ois = new ObjectInputStream(fis);\n            com.tedneward.Person ted = (com.tedneward.Person) ois.readObject();\n            ois.close();\n\n            assertEquals(ted.getFirstName(）， \"Ted\");\n            assertEquals(ted.getSpouse().getFirstName(）， \"Charlotte\");\n\n            // Clean up the file\n            new File(\"tempdata.ser\").delete();\n        }\n        catch (Exception ex)\n        {\n            fail(\"Exception thrown during test: \" + ex.toString());\n        }\n    }\n}\n```\n\n到现在为止，还没有看到什么新鲜的或令人兴奋的事情，但是这是一个很好的出发点。我们将使用 Person 来发现您可能不 知道的关于 Java 对象序列化 的 5 件事。\n\n#### 1. 序列化允许重构\n\n序列化允许一定数量的类变种，甚至重构之后也是如此，ObjectInputStream 仍可以很好地将其读出来。\nJava Object Serialization 规范可以自动管理的关键任务是：\n\n- 将新字段添加到类中\n\n- 将字段从 static 改为非 static\n\n- 将字段从 transient 改为非 transient\n\n取决于所需的向后兼容程度，转换字段形式（从非 static 转换为 static 或从非 transient 转换为 transient）或者删除字段需要额外的消息传递。\n\n**重构序列化类**\n\n既然已经知道序列化允许重构，我们来看看当把新字段添加到 Person 类中时，会发生什么事情。\n\n如清单 3 所示，PersonV2 在原先 Person 类的基础上引入一个表示性别的新字段。\n\n**清单 3. 将新字段添加到序列化的 Person 中**\n\n\n```\nenum Gender\n{\n    MALE, FEMALE\n}\n\npublic class Person\n    implements java.io.Serializable\n{\n    public Person(String fn, String ln, int a, Gender g)\n    {\n        this.firstName = fn; this.lastName = ln; this.age = a; this.gender = g;\n    }\n\n    public String getFirstName() { return firstName; }\n    public String getLastName() { return lastName; }\n    public Gender getGender() { return gender; }\n    public int getAge() { return age; }\n    public Person getSpouse() { return spouse; }\n\n    public void setFirstName(String value) { firstName = value; }\n    public void setLastName(String value) { lastName = value; }\n    public void setGender(Gender value) { gender = value; }\n    public void setAge(int value) { age = value; }\n    public void setSpouse(Person value) { spouse = value; }\n\n    public String toString()\n    {\n        return \"[Person: firstName=\" + firstName + \n            \" lastName=\" + lastName +\n            \" gender=\" + gender +\n            \" age=\" + age +\n            \" spouse=\" + spouse.getFirstName() +\n            \"]\";\n    }    \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n    private Gender gender;\n}\n```\n\n序列化使用一个 hash，该 hash 是根据给定源文件中几乎所有东西 — 方法名称、字段名称、字段类型、访问修改方法等 — 计算出来的，序列化将该 hash 值与序列化流中的 hash 值相比较。\n\n为了使 Java 运行时相信两种类型实际上是一样的，第二版和随后版本的 Person 必须与第一版有相同的序列化版本 hash（存储为 private static final serialVersionUID 字段）。\n\n因此，我们需要 serialVersionUID 字段，它是通过对原始（或 V1）版本的 Person 类运行 JDK serialver命令计算出的。\n\n一旦有了 Person 的 serialVersionUID，不仅可以从原始对象 Person 的序列化数据创建 PersonV2 对象（当出现新字段时，新字段被设为缺省值，最常见的是“null”），还可以反过来做：即从 PersonV2 的数据通过反序列化得到 Person，这毫不奇怪。\n\n#### 2. 序列化并不安全\n\n让 Java 开发人员诧异并感到不快的是，序列化二进制格式完全编写在文档中，并且完全可逆。实际上，只需将二进制序列化流的内容转储到控制台，就足以看清类是什么样子，以及它包含什么内容。\n\n这对于安全性有着不良影响。例如，当通过 RMI 进行远程方法调用时，通过连接发送的对象中的任何 private 字段几乎都是以明文的方式出现在套接字流中，这显然容易招致哪怕最简单的安全问题。\n\n幸运的是，序列化允许 “hook” 序列化过程，并在序列化之前和反序列化之后保护（或模糊化）字段数据。可以通过在 Serializable 对象上提供一个 writeObject 方法来做到这一点。\n\n**模糊化序列化数据**\n\n假设 Person 类中的敏感数据是 age 字段。毕竟，女士忌谈年龄。 我们可以在序列化之前模糊化该数据，将数位循环左移一位，然后在反序列化之后复位。（您可以开发更安全的算法，当前这个算法只是作为一个例子。）\n\n为了 “hook” 序列化过程，我们将在 Person 上实现一个 writeObject 方法；为了 “hook” 反序列化过程，我们将在同一个类上实现一个readObject 方法。重要的是这两个方法的细节要正确 — 如果访问修改方法、参数或名称不同于清单 4 中的内容，那么代码将不被察觉地失败，Person 的 age 将暴露。\n\n**清单 4. 模糊化序列化数据**\n\n\n```\npublic class Person\n    implements java.io.Serializable\n{\n    public Person(String fn, String ln, int a)\n    {\n        this.firstName = fn; this.lastName = ln; this.age = a;\n    }\n\n    public String getFirstName() { return firstName; }\n    public String getLastName() { return lastName; }\n    public int getAge() { return age; }\n    public Person getSpouse() { return spouse; }\n\n    public void setFirstName(String value) { firstName = value; }\n    public void setLastName(String value) { lastName = value; }\n    public void setAge(int value) { age = value; }\n    public void setSpouse(Person value) { spouse = value; }\n\n    private void writeObject(java.io.ObjectOutputStream stream)\n        throws java.io.IOException\n    {\n        // \"Encrypt\"/obscure the sensitive data\n        age = age << 2;\n        stream.defaultWriteObject();\n    }\n\n    private void readObject(java.io.ObjectInputStream stream)\n        throws java.io.IOException, ClassNotFoundException\n    {\n        stream.defaultReadObject();\n\n        // \"Decrypt\"/de-obscure the sensitive data\n        age = age << 2;\n    }\n\n    public String toString()\n    {\n        return \"[Person: firstName=\" + firstName + \n            \" lastName=\" + lastName +\n            \" age=\" + age +\n            \" spouse=\" + (spouse!=null ? spouse.getFirstName() : \"[null]\") +\n            \"]\";\n    }      \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n}\n```\n\n如果需要查看被模糊化的数据，总是可以查看序列化数据流/文件。而且，由于该格式被完全文档化，即使不能访问类本身，也仍可以读取序列化流中的内容。\n\n#### 3. 序列化的数据可以被签名和密封\n\n上一个技巧假设您想模糊化序列化数据，而不是对其加密或者确保它不被修改。当然，通过使用 writeObject 和 readObject 可以实现密码加密和签名管理，但其实还有更好的方式。\n\n如果需要对整个对象进行加密和签名，最简单的是将它放在一个 javax.crypto.SealedObject 和/或 java.security.SignedObject 包装器中。两者都是可序列化的，所以将对象包装在 SealedObject 中可以围绕原对象创建一种“包装盒”。必须有对称密钥才能解密，而且密钥必须单独管理。同样，也可以将 SignedObject 用于数据验证，并且对称密钥也必须单独管理。\n\n结合使用这两种对象，便可以轻松地对序列化数据进行密封和签名，而不必强调关于数字签名验证或加密的细节。很简洁，是吧？\n\n#### 4. 序列化允许将代理放在流中\n\n很多情况下，类中包含一个核心数据元素，通过它可以派生或找到类中的其他字段。在此情况下，没有必要序列化整个对象。可以将字段标记为 transient，但是每当有方法访问一个字段时，类仍然必须显式地产生代码来检查它是否被初始化。\n\n如果首要问题是序列化，那么最好指定一个 flyweight 或代理放在流中。为原始 Person 提供一个 writeReplace 方法，可以序列化不同类型的对象来代替它。类似地，如果反序列化期间发现一个 readResolve 方法，那么将调用该方法，将替代对象提供给调用者。\n\n**打包和解包代理**\n\nwriteReplace 和 readResolve 方法使 Person 类可以将它的所有数据（或其中的核心数据）打包到一个 PersonProxy 中，将它放入到一个流中，然后在反序列化时再进行解包。\n\n**清单 5. 你完整了我，我代替了你**\n\n\n```\nclass PersonProxy\n    implements java.io.Serializable\n{\n    public PersonProxy(Person orig)\n    {\n        data = orig.getFirstName() + \",\" + orig.getLastName() + \",\" + orig.getAge();\n        if (orig.getSpouse() != null)\n        {\n            Person spouse = orig.getSpouse();\n            data = data + \",\" + spouse.getFirstName() + \",\" + spouse.getLastName() + \",\"  \n              + spouse.getAge();\n        }\n    }\n\n    public String data;\n    private Object readResolve()\n        throws java.io.ObjectStreamException\n    {\n        String[] pieces = data.split(\",\");\n        Person result = new Person(pieces[0], pieces[1], Integer.parseInt(pieces[2]));\n        if (pieces.length > 3)\n        {\n            result.setSpouse(new Person(pieces[3], pieces[4], Integer.parseInt\n              (pieces[5])));\n            result.getSpouse().setSpouse(result);\n        }\n        return result;\n    }\n}\n\npublic class Person\n    implements java.io.Serializable\n{\n    public Person(String fn, String ln, int a)\n    {\n        this.firstName = fn; this.lastName = ln; this.age = a;\n    }\n\n    public String getFirstName() { return firstName; }\n    public String getLastName() { return lastName; }\n    public int getAge() { return age; }\n    public Person getSpouse() { return spouse; }\n\n    private Object writeReplace()\n        throws java.io.ObjectStreamException\n    {\n        return new PersonProxy(this);\n    }\n\n    public void setFirstName(String value) { firstName = value; }\n    public void setLastName(String value) { lastName = value; }\n    public void setAge(int value) { age = value; }\n    public void setSpouse(Person value) { spouse = value; }   \n\n    public String toString()\n    {\n        return \"[Person: firstName=\" + firstName + \n            \" lastName=\" + lastName +\n            \" age=\" + age +\n            \" spouse=\" + spouse.getFirstName() +\n            \"]\";\n    }    \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n}\n```\n\n注意，PersonProxy 必须跟踪 Person 的所有数据。这通常意味着代理需要是 Person 的一个内部类，以便能访问 private 字段。有时候，代理还需要追踪其他对象引用并手动序列化它们，例如 Person 的 spouse。\n\n这种技巧是少数几种不需要读/写平衡的技巧之一。例如，一个类被重构成另一种类型后的版本可以提供一个 readResolve 方法，以便静默地将被序列化的对象转换成新类型。类似地，它可以采用 writeReplace 方法将旧类序列化成新版本。\n\n#### 5. 信任，但要验证\n\n认为序列化流中的数据总是与最初写到流中的数据一致，这没有问题。但是，正如一位美国前总统所说的，“信任，但要验证”。\n对于序列化的对象，这意味着验证字段，以确保在反序列化之后它们仍具有正确的值，“以防万一”。\n\n为此，可以实现 ObjectInputValidation接口，并覆盖 validateObject() 方法。如果调用该方法时发现某处有错误，则抛出一个 InvalidObjectException。\n\n### 结束语\n\nJava 对象序列化比大多数 Java 开发人员想象的更灵活，这使我们有更多的机会解决棘手的情况。\n\n幸运的是，像这样的编程妙招在 JVM 中随处可见。关键是要知道它们，在遇到难题的时候能用上它们。\n\n来源：www.topthink.com/topic/11361.html","slug":"基础/关于 Java 序列化你不知道的 5 件事","published":1,"updated":"2025-10-14T07:36:11.275Z","_id":"cmgq8bkhn0014hod42736a9ia","comments":1,"layout":"post","photos":[],"content":"<h3 id=\"关于本系列\"><a href=\"#关于本系列\" class=\"headerlink\" title=\"关于本系列\"></a>关于本系列</h3><p>大约一年前，一个负责管理应用程序所有用户设置的开发人员，决定将用户设置存储在一个 Hashtable中，然后将这个 Hashtable 序列化到磁盘，以便持久化。当用户更改设置时，便重新将 Hashtable 写到磁盘。</p>\n<p>这是一个优雅的、开放式的设置系统，但是，当团队决定从 Hashtable 迁移到 Java Collections 库中的HashMap 时，这个系统便面临崩溃。</p>\n<p>Hashtable 和 HashMap 在磁盘上的格式是不相同、不兼容的。除非对每个持久化的用户设置运行某种类型的数据转换实用程序（极其庞大的任务），否则以后似乎只能一直用Hashtable 作为应用程序的存储格式。</p>\n<p>团队感到陷入僵局，但这只是因为他们不知道关于 Java 序列化的一个重要事实：Java 序列化允许随着时间的推移而改变类型。当我向他们展示如何自动进行序列化替换后，他们终于按计划完成了向 HashMap 的转变。</p>\n<p>本文是本系列的第一篇文章，这个系列专门揭示关于 Java 平台的一些有用的小知识 — 这些小知识不易理解，但对于解决 Java 编程挑战迟早有用。</p>\n<p>将 Java 对象序列化 API 作为开端是一个不错的选择，因为它从一开始就存在于 JDK 1.1 中。本文介绍的关于序列化的 5 件事情将说服您重新审视那些标准 Java API。</p>\n<h3 id=\"Java-序列化简介\"><a href=\"#Java-序列化简介\" class=\"headerlink\" title=\"Java 序列化简介\"></a>Java 序列化简介</h3><p>Java 对象序列化是 JDK 1.1 中引入的一组开创性特性之一，用于作为一种将 Java 对象的状态转换为字节数组，以便存储或传输的机制，以后，仍可以将字节数组转换回 Java 对象原有的状态。</p>\n<p>实际上，序列化的思想是 “冻结” 对象状态，传输对象状态（写到磁盘、通过网络传输等等），然后 “解冻” 状态，重新获得可用的 Java 对象。所有这些事情的发生有点像是魔术，这要归功于 ObjectInputStream&#x2F;ObjectOutputStream 类、完全保真的元数据以及程序员愿意用Serializable 标识接口标记他们的类，从而 “参与” 这个过程。</p>\n<p>清单 1 显示一个实现 Serializable 的 Person 类。</p>\n<p><strong>清单 1. Serializable Person</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tedneward;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Person</span><br><span class=\"line\">    implements java.io.Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public Person(String fn, String ln, int a)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        this.firstName = fn; this.lastName = ln; this.age = a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getFirstName() &#123; return firstName; &#125;</span><br><span class=\"line\">    public String getLastName() &#123; return lastName; &#125;</span><br><span class=\"line\">    public int getAge() &#123; return age; &#125;</span><br><span class=\"line\">    public Person getSpouse() &#123; return spouse; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setFirstName(String value) &#123; firstName = value; &#125;</span><br><span class=\"line\">    public void setLastName(String value) &#123; lastName = value; &#125;</span><br><span class=\"line\">    public void setAge(int value) &#123; age = value; &#125;</span><br><span class=\"line\">    public void setSpouse(Person value) &#123; spouse = value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String toString()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return &quot;[Person: firstName=&quot; + firstName + </span><br><span class=\"line\">            &quot; lastName=&quot; + lastName +</span><br><span class=\"line\">            &quot; age=&quot; + age +</span><br><span class=\"line\">            &quot; spouse=&quot; + spouse.getFirstName() +</span><br><span class=\"line\">            &quot;]&quot;;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">    private String firstName;</span><br><span class=\"line\">    private String lastName;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">    private Person spouse;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将 Person 序列化后，很容易将对象状态写到磁盘，然后重新读出它，下面的 JUnit 4 单元测试对此做了演示。</p>\n<p><strong>清单 2. 对 Person 进行反序列化</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SerTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    @Test public void serializeToDisk()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        try</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            com.tedneward.Person ted = new com.tedneward.Person(&quot;Ted&quot;, &quot;Neward&quot;, 39);</span><br><span class=\"line\">            com.tedneward.Person charl = new com.tedneward.Person(&quot;Charlotte&quot;,</span><br><span class=\"line\">                &quot;Neward&quot;, 38);</span><br><span class=\"line\"></span><br><span class=\"line\">            ted.setSpouse(charl); charl.setSpouse(ted);</span><br><span class=\"line\"></span><br><span class=\"line\">            FileOutputStream fos = new FileOutputStream(&quot;tempdata.ser&quot;);</span><br><span class=\"line\">            ObjectOutputStream oos = new ObjectOutputStream(fos);</span><br><span class=\"line\">            oos.writeObject(ted);</span><br><span class=\"line\">            oos.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        catch (Exception ex)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            fail(&quot;Exception thrown during test: &quot; + ex.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        try</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            FileInputStream fis = new FileInputStream(&quot;tempdata.ser&quot;);</span><br><span class=\"line\">            ObjectInputStream ois = new ObjectInputStream(fis);</span><br><span class=\"line\">            com.tedneward.Person ted = (com.tedneward.Person) ois.readObject();</span><br><span class=\"line\">            ois.close();</span><br><span class=\"line\"></span><br><span class=\"line\">            assertEquals(ted.getFirstName(）， &quot;Ted&quot;);</span><br><span class=\"line\">            assertEquals(ted.getSpouse().getFirstName(）， &quot;Charlotte&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">            // Clean up the file</span><br><span class=\"line\">            new File(&quot;tempdata.ser&quot;).delete();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        catch (Exception ex)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            fail(&quot;Exception thrown during test: &quot; + ex.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到现在为止，还没有看到什么新鲜的或令人兴奋的事情，但是这是一个很好的出发点。我们将使用 Person 来发现您可能不 知道的关于 Java 对象序列化 的 5 件事。</p>\n<h4 id=\"1-序列化允许重构\"><a href=\"#1-序列化允许重构\" class=\"headerlink\" title=\"1. 序列化允许重构\"></a>1. 序列化允许重构</h4><p>序列化允许一定数量的类变种，甚至重构之后也是如此，ObjectInputStream 仍可以很好地将其读出来。<br>Java Object Serialization 规范可以自动管理的关键任务是：</p>\n<ul>\n<li><p>将新字段添加到类中</p>\n</li>\n<li><p>将字段从 static 改为非 static</p>\n</li>\n<li><p>将字段从 transient 改为非 transient</p>\n</li>\n</ul>\n<p>取决于所需的向后兼容程度，转换字段形式（从非 static 转换为 static 或从非 transient 转换为 transient）或者删除字段需要额外的消息传递。</p>\n<p><strong>重构序列化类</strong></p>\n<p>既然已经知道序列化允许重构，我们来看看当把新字段添加到 Person 类中时，会发生什么事情。</p>\n<p>如清单 3 所示，PersonV2 在原先 Person 类的基础上引入一个表示性别的新字段。</p>\n<p><strong>清单 3. 将新字段添加到序列化的 Person 中</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Gender</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    MALE, FEMALE</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Person</span><br><span class=\"line\">    implements java.io.Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public Person(String fn, String ln, int a, Gender g)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        this.firstName = fn; this.lastName = ln; this.age = a; this.gender = g;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getFirstName() &#123; return firstName; &#125;</span><br><span class=\"line\">    public String getLastName() &#123; return lastName; &#125;</span><br><span class=\"line\">    public Gender getGender() &#123; return gender; &#125;</span><br><span class=\"line\">    public int getAge() &#123; return age; &#125;</span><br><span class=\"line\">    public Person getSpouse() &#123; return spouse; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setFirstName(String value) &#123; firstName = value; &#125;</span><br><span class=\"line\">    public void setLastName(String value) &#123; lastName = value; &#125;</span><br><span class=\"line\">    public void setGender(Gender value) &#123; gender = value; &#125;</span><br><span class=\"line\">    public void setAge(int value) &#123; age = value; &#125;</span><br><span class=\"line\">    public void setSpouse(Person value) &#123; spouse = value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String toString()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return &quot;[Person: firstName=&quot; + firstName + </span><br><span class=\"line\">            &quot; lastName=&quot; + lastName +</span><br><span class=\"line\">            &quot; gender=&quot; + gender +</span><br><span class=\"line\">            &quot; age=&quot; + age +</span><br><span class=\"line\">            &quot; spouse=&quot; + spouse.getFirstName() +</span><br><span class=\"line\">            &quot;]&quot;;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">    private String firstName;</span><br><span class=\"line\">    private String lastName;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">    private Person spouse;</span><br><span class=\"line\">    private Gender gender;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>序列化使用一个 hash，该 hash 是根据给定源文件中几乎所有东西 — 方法名称、字段名称、字段类型、访问修改方法等 — 计算出来的，序列化将该 hash 值与序列化流中的 hash 值相比较。</p>\n<p>为了使 Java 运行时相信两种类型实际上是一样的，第二版和随后版本的 Person 必须与第一版有相同的序列化版本 hash（存储为 private static final serialVersionUID 字段）。</p>\n<p>因此，我们需要 serialVersionUID 字段，它是通过对原始（或 V1）版本的 Person 类运行 JDK serialver命令计算出的。</p>\n<p>一旦有了 Person 的 serialVersionUID，不仅可以从原始对象 Person 的序列化数据创建 PersonV2 对象（当出现新字段时，新字段被设为缺省值，最常见的是“null”），还可以反过来做：即从 PersonV2 的数据通过反序列化得到 Person，这毫不奇怪。</p>\n<h4 id=\"2-序列化并不安全\"><a href=\"#2-序列化并不安全\" class=\"headerlink\" title=\"2. 序列化并不安全\"></a>2. 序列化并不安全</h4><p>让 Java 开发人员诧异并感到不快的是，序列化二进制格式完全编写在文档中，并且完全可逆。实际上，只需将二进制序列化流的内容转储到控制台，就足以看清类是什么样子，以及它包含什么内容。</p>\n<p>这对于安全性有着不良影响。例如，当通过 RMI 进行远程方法调用时，通过连接发送的对象中的任何 private 字段几乎都是以明文的方式出现在套接字流中，这显然容易招致哪怕最简单的安全问题。</p>\n<p>幸运的是，序列化允许 “hook” 序列化过程，并在序列化之前和反序列化之后保护（或模糊化）字段数据。可以通过在 Serializable 对象上提供一个 writeObject 方法来做到这一点。</p>\n<p><strong>模糊化序列化数据</strong></p>\n<p>假设 Person 类中的敏感数据是 age 字段。毕竟，女士忌谈年龄。 我们可以在序列化之前模糊化该数据，将数位循环左移一位，然后在反序列化之后复位。（您可以开发更安全的算法，当前这个算法只是作为一个例子。）</p>\n<p>为了 “hook” 序列化过程，我们将在 Person 上实现一个 writeObject 方法；为了 “hook” 反序列化过程，我们将在同一个类上实现一个readObject 方法。重要的是这两个方法的细节要正确 — 如果访问修改方法、参数或名称不同于清单 4 中的内容，那么代码将不被察觉地失败，Person 的 age 将暴露。</p>\n<p><strong>清单 4. 模糊化序列化数据</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Person</span><br><span class=\"line\">    implements java.io.Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public Person(String fn, String ln, int a)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        this.firstName = fn; this.lastName = ln; this.age = a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getFirstName() &#123; return firstName; &#125;</span><br><span class=\"line\">    public String getLastName() &#123; return lastName; &#125;</span><br><span class=\"line\">    public int getAge() &#123; return age; &#125;</span><br><span class=\"line\">    public Person getSpouse() &#123; return spouse; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setFirstName(String value) &#123; firstName = value; &#125;</span><br><span class=\"line\">    public void setLastName(String value) &#123; lastName = value; &#125;</span><br><span class=\"line\">    public void setAge(int value) &#123; age = value; &#125;</span><br><span class=\"line\">    public void setSpouse(Person value) &#123; spouse = value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void writeObject(java.io.ObjectOutputStream stream)</span><br><span class=\"line\">        throws java.io.IOException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // &quot;Encrypt&quot;/obscure the sensitive data</span><br><span class=\"line\">        age = age &lt;&lt; 2;</span><br><span class=\"line\">        stream.defaultWriteObject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void readObject(java.io.ObjectInputStream stream)</span><br><span class=\"line\">        throws java.io.IOException, ClassNotFoundException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        stream.defaultReadObject();</span><br><span class=\"line\"></span><br><span class=\"line\">        // &quot;Decrypt&quot;/de-obscure the sensitive data</span><br><span class=\"line\">        age = age &lt;&lt; 2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String toString()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return &quot;[Person: firstName=&quot; + firstName + </span><br><span class=\"line\">            &quot; lastName=&quot; + lastName +</span><br><span class=\"line\">            &quot; age=&quot; + age +</span><br><span class=\"line\">            &quot; spouse=&quot; + (spouse!=null ? spouse.getFirstName() : &quot;[null]&quot;) +</span><br><span class=\"line\">            &quot;]&quot;;</span><br><span class=\"line\">    &#125;      </span><br><span class=\"line\"></span><br><span class=\"line\">    private String firstName;</span><br><span class=\"line\">    private String lastName;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">    private Person spouse;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果需要查看被模糊化的数据，总是可以查看序列化数据流&#x2F;文件。而且，由于该格式被完全文档化，即使不能访问类本身，也仍可以读取序列化流中的内容。</p>\n<h4 id=\"3-序列化的数据可以被签名和密封\"><a href=\"#3-序列化的数据可以被签名和密封\" class=\"headerlink\" title=\"3. 序列化的数据可以被签名和密封\"></a>3. 序列化的数据可以被签名和密封</h4><p>上一个技巧假设您想模糊化序列化数据，而不是对其加密或者确保它不被修改。当然，通过使用 writeObject 和 readObject 可以实现密码加密和签名管理，但其实还有更好的方式。</p>\n<p>如果需要对整个对象进行加密和签名，最简单的是将它放在一个 javax.crypto.SealedObject 和&#x2F;或 java.security.SignedObject 包装器中。两者都是可序列化的，所以将对象包装在 SealedObject 中可以围绕原对象创建一种“包装盒”。必须有对称密钥才能解密，而且密钥必须单独管理。同样，也可以将 SignedObject 用于数据验证，并且对称密钥也必须单独管理。</p>\n<p>结合使用这两种对象，便可以轻松地对序列化数据进行密封和签名，而不必强调关于数字签名验证或加密的细节。很简洁，是吧？</p>\n<h4 id=\"4-序列化允许将代理放在流中\"><a href=\"#4-序列化允许将代理放在流中\" class=\"headerlink\" title=\"4. 序列化允许将代理放在流中\"></a>4. 序列化允许将代理放在流中</h4><p>很多情况下，类中包含一个核心数据元素，通过它可以派生或找到类中的其他字段。在此情况下，没有必要序列化整个对象。可以将字段标记为 transient，但是每当有方法访问一个字段时，类仍然必须显式地产生代码来检查它是否被初始化。</p>\n<p>如果首要问题是序列化，那么最好指定一个 flyweight 或代理放在流中。为原始 Person 提供一个 writeReplace 方法，可以序列化不同类型的对象来代替它。类似地，如果反序列化期间发现一个 readResolve 方法，那么将调用该方法，将替代对象提供给调用者。</p>\n<p><strong>打包和解包代理</strong></p>\n<p>writeReplace 和 readResolve 方法使 Person 类可以将它的所有数据（或其中的核心数据）打包到一个 PersonProxy 中，将它放入到一个流中，然后在反序列化时再进行解包。</p>\n<p><strong>清单 5. 你完整了我，我代替了你</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class PersonProxy</span><br><span class=\"line\">    implements java.io.Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public PersonProxy(Person orig)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        data = orig.getFirstName() + &quot;,&quot; + orig.getLastName() + &quot;,&quot; + orig.getAge();</span><br><span class=\"line\">        if (orig.getSpouse() != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Person spouse = orig.getSpouse();</span><br><span class=\"line\">            data = data + &quot;,&quot; + spouse.getFirstName() + &quot;,&quot; + spouse.getLastName() + &quot;,&quot;  </span><br><span class=\"line\">              + spouse.getAge();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String data;</span><br><span class=\"line\">    private Object readResolve()</span><br><span class=\"line\">        throws java.io.ObjectStreamException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        String[] pieces = data.split(&quot;,&quot;);</span><br><span class=\"line\">        Person result = new Person(pieces[0], pieces[1], Integer.parseInt(pieces[2]));</span><br><span class=\"line\">        if (pieces.length &gt; 3)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            result.setSpouse(new Person(pieces[3], pieces[4], Integer.parseInt</span><br><span class=\"line\">              (pieces[5])));</span><br><span class=\"line\">            result.getSpouse().setSpouse(result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Person</span><br><span class=\"line\">    implements java.io.Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public Person(String fn, String ln, int a)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        this.firstName = fn; this.lastName = ln; this.age = a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getFirstName() &#123; return firstName; &#125;</span><br><span class=\"line\">    public String getLastName() &#123; return lastName; &#125;</span><br><span class=\"line\">    public int getAge() &#123; return age; &#125;</span><br><span class=\"line\">    public Person getSpouse() &#123; return spouse; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Object writeReplace()</span><br><span class=\"line\">        throws java.io.ObjectStreamException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return new PersonProxy(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setFirstName(String value) &#123; firstName = value; &#125;</span><br><span class=\"line\">    public void setLastName(String value) &#123; lastName = value; &#125;</span><br><span class=\"line\">    public void setAge(int value) &#123; age = value; &#125;</span><br><span class=\"line\">    public void setSpouse(Person value) &#123; spouse = value; &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">    public String toString()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return &quot;[Person: firstName=&quot; + firstName + </span><br><span class=\"line\">            &quot; lastName=&quot; + lastName +</span><br><span class=\"line\">            &quot; age=&quot; + age +</span><br><span class=\"line\">            &quot; spouse=&quot; + spouse.getFirstName() +</span><br><span class=\"line\">            &quot;]&quot;;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">    private String firstName;</span><br><span class=\"line\">    private String lastName;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">    private Person spouse;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，PersonProxy 必须跟踪 Person 的所有数据。这通常意味着代理需要是 Person 的一个内部类，以便能访问 private 字段。有时候，代理还需要追踪其他对象引用并手动序列化它们，例如 Person 的 spouse。</p>\n<p>这种技巧是少数几种不需要读&#x2F;写平衡的技巧之一。例如，一个类被重构成另一种类型后的版本可以提供一个 readResolve 方法，以便静默地将被序列化的对象转换成新类型。类似地，它可以采用 writeReplace 方法将旧类序列化成新版本。</p>\n<h4 id=\"5-信任，但要验证\"><a href=\"#5-信任，但要验证\" class=\"headerlink\" title=\"5. 信任，但要验证\"></a>5. 信任，但要验证</h4><p>认为序列化流中的数据总是与最初写到流中的数据一致，这没有问题。但是，正如一位美国前总统所说的，“信任，但要验证”。<br>对于序列化的对象，这意味着验证字段，以确保在反序列化之后它们仍具有正确的值，“以防万一”。</p>\n<p>为此，可以实现 ObjectInputValidation接口，并覆盖 validateObject() 方法。如果调用该方法时发现某处有错误，则抛出一个 InvalidObjectException。</p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>Java 对象序列化比大多数 Java 开发人员想象的更灵活，这使我们有更多的机会解决棘手的情况。</p>\n<p>幸运的是，像这样的编程妙招在 JVM 中随处可见。关键是要知道它们，在遇到难题的时候能用上它们。</p>\n<p>来源：<a href=\"http://www.topthink.com/topic/11361.html\">www.topthink.com/topic/11361.html</a></p>\n","excerpt":"","more":"<h3 id=\"关于本系列\"><a href=\"#关于本系列\" class=\"headerlink\" title=\"关于本系列\"></a>关于本系列</h3><p>大约一年前，一个负责管理应用程序所有用户设置的开发人员，决定将用户设置存储在一个 Hashtable中，然后将这个 Hashtable 序列化到磁盘，以便持久化。当用户更改设置时，便重新将 Hashtable 写到磁盘。</p>\n<p>这是一个优雅的、开放式的设置系统，但是，当团队决定从 Hashtable 迁移到 Java Collections 库中的HashMap 时，这个系统便面临崩溃。</p>\n<p>Hashtable 和 HashMap 在磁盘上的格式是不相同、不兼容的。除非对每个持久化的用户设置运行某种类型的数据转换实用程序（极其庞大的任务），否则以后似乎只能一直用Hashtable 作为应用程序的存储格式。</p>\n<p>团队感到陷入僵局，但这只是因为他们不知道关于 Java 序列化的一个重要事实：Java 序列化允许随着时间的推移而改变类型。当我向他们展示如何自动进行序列化替换后，他们终于按计划完成了向 HashMap 的转变。</p>\n<p>本文是本系列的第一篇文章，这个系列专门揭示关于 Java 平台的一些有用的小知识 — 这些小知识不易理解，但对于解决 Java 编程挑战迟早有用。</p>\n<p>将 Java 对象序列化 API 作为开端是一个不错的选择，因为它从一开始就存在于 JDK 1.1 中。本文介绍的关于序列化的 5 件事情将说服您重新审视那些标准 Java API。</p>\n<h3 id=\"Java-序列化简介\"><a href=\"#Java-序列化简介\" class=\"headerlink\" title=\"Java 序列化简介\"></a>Java 序列化简介</h3><p>Java 对象序列化是 JDK 1.1 中引入的一组开创性特性之一，用于作为一种将 Java 对象的状态转换为字节数组，以便存储或传输的机制，以后，仍可以将字节数组转换回 Java 对象原有的状态。</p>\n<p>实际上，序列化的思想是 “冻结” 对象状态，传输对象状态（写到磁盘、通过网络传输等等），然后 “解冻” 状态，重新获得可用的 Java 对象。所有这些事情的发生有点像是魔术，这要归功于 ObjectInputStream&#x2F;ObjectOutputStream 类、完全保真的元数据以及程序员愿意用Serializable 标识接口标记他们的类，从而 “参与” 这个过程。</p>\n<p>清单 1 显示一个实现 Serializable 的 Person 类。</p>\n<p><strong>清单 1. Serializable Person</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tedneward;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Person</span><br><span class=\"line\">    implements java.io.Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public Person(String fn, String ln, int a)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        this.firstName = fn; this.lastName = ln; this.age = a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getFirstName() &#123; return firstName; &#125;</span><br><span class=\"line\">    public String getLastName() &#123; return lastName; &#125;</span><br><span class=\"line\">    public int getAge() &#123; return age; &#125;</span><br><span class=\"line\">    public Person getSpouse() &#123; return spouse; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setFirstName(String value) &#123; firstName = value; &#125;</span><br><span class=\"line\">    public void setLastName(String value) &#123; lastName = value; &#125;</span><br><span class=\"line\">    public void setAge(int value) &#123; age = value; &#125;</span><br><span class=\"line\">    public void setSpouse(Person value) &#123; spouse = value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String toString()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return &quot;[Person: firstName=&quot; + firstName + </span><br><span class=\"line\">            &quot; lastName=&quot; + lastName +</span><br><span class=\"line\">            &quot; age=&quot; + age +</span><br><span class=\"line\">            &quot; spouse=&quot; + spouse.getFirstName() +</span><br><span class=\"line\">            &quot;]&quot;;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">    private String firstName;</span><br><span class=\"line\">    private String lastName;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">    private Person spouse;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将 Person 序列化后，很容易将对象状态写到磁盘，然后重新读出它，下面的 JUnit 4 单元测试对此做了演示。</p>\n<p><strong>清单 2. 对 Person 进行反序列化</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SerTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    @Test public void serializeToDisk()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        try</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            com.tedneward.Person ted = new com.tedneward.Person(&quot;Ted&quot;, &quot;Neward&quot;, 39);</span><br><span class=\"line\">            com.tedneward.Person charl = new com.tedneward.Person(&quot;Charlotte&quot;,</span><br><span class=\"line\">                &quot;Neward&quot;, 38);</span><br><span class=\"line\"></span><br><span class=\"line\">            ted.setSpouse(charl); charl.setSpouse(ted);</span><br><span class=\"line\"></span><br><span class=\"line\">            FileOutputStream fos = new FileOutputStream(&quot;tempdata.ser&quot;);</span><br><span class=\"line\">            ObjectOutputStream oos = new ObjectOutputStream(fos);</span><br><span class=\"line\">            oos.writeObject(ted);</span><br><span class=\"line\">            oos.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        catch (Exception ex)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            fail(&quot;Exception thrown during test: &quot; + ex.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        try</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            FileInputStream fis = new FileInputStream(&quot;tempdata.ser&quot;);</span><br><span class=\"line\">            ObjectInputStream ois = new ObjectInputStream(fis);</span><br><span class=\"line\">            com.tedneward.Person ted = (com.tedneward.Person) ois.readObject();</span><br><span class=\"line\">            ois.close();</span><br><span class=\"line\"></span><br><span class=\"line\">            assertEquals(ted.getFirstName(）， &quot;Ted&quot;);</span><br><span class=\"line\">            assertEquals(ted.getSpouse().getFirstName(）， &quot;Charlotte&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">            // Clean up the file</span><br><span class=\"line\">            new File(&quot;tempdata.ser&quot;).delete();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        catch (Exception ex)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            fail(&quot;Exception thrown during test: &quot; + ex.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到现在为止，还没有看到什么新鲜的或令人兴奋的事情，但是这是一个很好的出发点。我们将使用 Person 来发现您可能不 知道的关于 Java 对象序列化 的 5 件事。</p>\n<h4 id=\"1-序列化允许重构\"><a href=\"#1-序列化允许重构\" class=\"headerlink\" title=\"1. 序列化允许重构\"></a>1. 序列化允许重构</h4><p>序列化允许一定数量的类变种，甚至重构之后也是如此，ObjectInputStream 仍可以很好地将其读出来。<br>Java Object Serialization 规范可以自动管理的关键任务是：</p>\n<ul>\n<li><p>将新字段添加到类中</p>\n</li>\n<li><p>将字段从 static 改为非 static</p>\n</li>\n<li><p>将字段从 transient 改为非 transient</p>\n</li>\n</ul>\n<p>取决于所需的向后兼容程度，转换字段形式（从非 static 转换为 static 或从非 transient 转换为 transient）或者删除字段需要额外的消息传递。</p>\n<p><strong>重构序列化类</strong></p>\n<p>既然已经知道序列化允许重构，我们来看看当把新字段添加到 Person 类中时，会发生什么事情。</p>\n<p>如清单 3 所示，PersonV2 在原先 Person 类的基础上引入一个表示性别的新字段。</p>\n<p><strong>清单 3. 将新字段添加到序列化的 Person 中</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Gender</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    MALE, FEMALE</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Person</span><br><span class=\"line\">    implements java.io.Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public Person(String fn, String ln, int a, Gender g)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        this.firstName = fn; this.lastName = ln; this.age = a; this.gender = g;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getFirstName() &#123; return firstName; &#125;</span><br><span class=\"line\">    public String getLastName() &#123; return lastName; &#125;</span><br><span class=\"line\">    public Gender getGender() &#123; return gender; &#125;</span><br><span class=\"line\">    public int getAge() &#123; return age; &#125;</span><br><span class=\"line\">    public Person getSpouse() &#123; return spouse; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setFirstName(String value) &#123; firstName = value; &#125;</span><br><span class=\"line\">    public void setLastName(String value) &#123; lastName = value; &#125;</span><br><span class=\"line\">    public void setGender(Gender value) &#123; gender = value; &#125;</span><br><span class=\"line\">    public void setAge(int value) &#123; age = value; &#125;</span><br><span class=\"line\">    public void setSpouse(Person value) &#123; spouse = value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String toString()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return &quot;[Person: firstName=&quot; + firstName + </span><br><span class=\"line\">            &quot; lastName=&quot; + lastName +</span><br><span class=\"line\">            &quot; gender=&quot; + gender +</span><br><span class=\"line\">            &quot; age=&quot; + age +</span><br><span class=\"line\">            &quot; spouse=&quot; + spouse.getFirstName() +</span><br><span class=\"line\">            &quot;]&quot;;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">    private String firstName;</span><br><span class=\"line\">    private String lastName;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">    private Person spouse;</span><br><span class=\"line\">    private Gender gender;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>序列化使用一个 hash，该 hash 是根据给定源文件中几乎所有东西 — 方法名称、字段名称、字段类型、访问修改方法等 — 计算出来的，序列化将该 hash 值与序列化流中的 hash 值相比较。</p>\n<p>为了使 Java 运行时相信两种类型实际上是一样的，第二版和随后版本的 Person 必须与第一版有相同的序列化版本 hash（存储为 private static final serialVersionUID 字段）。</p>\n<p>因此，我们需要 serialVersionUID 字段，它是通过对原始（或 V1）版本的 Person 类运行 JDK serialver命令计算出的。</p>\n<p>一旦有了 Person 的 serialVersionUID，不仅可以从原始对象 Person 的序列化数据创建 PersonV2 对象（当出现新字段时，新字段被设为缺省值，最常见的是“null”），还可以反过来做：即从 PersonV2 的数据通过反序列化得到 Person，这毫不奇怪。</p>\n<h4 id=\"2-序列化并不安全\"><a href=\"#2-序列化并不安全\" class=\"headerlink\" title=\"2. 序列化并不安全\"></a>2. 序列化并不安全</h4><p>让 Java 开发人员诧异并感到不快的是，序列化二进制格式完全编写在文档中，并且完全可逆。实际上，只需将二进制序列化流的内容转储到控制台，就足以看清类是什么样子，以及它包含什么内容。</p>\n<p>这对于安全性有着不良影响。例如，当通过 RMI 进行远程方法调用时，通过连接发送的对象中的任何 private 字段几乎都是以明文的方式出现在套接字流中，这显然容易招致哪怕最简单的安全问题。</p>\n<p>幸运的是，序列化允许 “hook” 序列化过程，并在序列化之前和反序列化之后保护（或模糊化）字段数据。可以通过在 Serializable 对象上提供一个 writeObject 方法来做到这一点。</p>\n<p><strong>模糊化序列化数据</strong></p>\n<p>假设 Person 类中的敏感数据是 age 字段。毕竟，女士忌谈年龄。 我们可以在序列化之前模糊化该数据，将数位循环左移一位，然后在反序列化之后复位。（您可以开发更安全的算法，当前这个算法只是作为一个例子。）</p>\n<p>为了 “hook” 序列化过程，我们将在 Person 上实现一个 writeObject 方法；为了 “hook” 反序列化过程，我们将在同一个类上实现一个readObject 方法。重要的是这两个方法的细节要正确 — 如果访问修改方法、参数或名称不同于清单 4 中的内容，那么代码将不被察觉地失败，Person 的 age 将暴露。</p>\n<p><strong>清单 4. 模糊化序列化数据</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Person</span><br><span class=\"line\">    implements java.io.Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public Person(String fn, String ln, int a)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        this.firstName = fn; this.lastName = ln; this.age = a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getFirstName() &#123; return firstName; &#125;</span><br><span class=\"line\">    public String getLastName() &#123; return lastName; &#125;</span><br><span class=\"line\">    public int getAge() &#123; return age; &#125;</span><br><span class=\"line\">    public Person getSpouse() &#123; return spouse; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setFirstName(String value) &#123; firstName = value; &#125;</span><br><span class=\"line\">    public void setLastName(String value) &#123; lastName = value; &#125;</span><br><span class=\"line\">    public void setAge(int value) &#123; age = value; &#125;</span><br><span class=\"line\">    public void setSpouse(Person value) &#123; spouse = value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void writeObject(java.io.ObjectOutputStream stream)</span><br><span class=\"line\">        throws java.io.IOException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // &quot;Encrypt&quot;/obscure the sensitive data</span><br><span class=\"line\">        age = age &lt;&lt; 2;</span><br><span class=\"line\">        stream.defaultWriteObject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void readObject(java.io.ObjectInputStream stream)</span><br><span class=\"line\">        throws java.io.IOException, ClassNotFoundException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        stream.defaultReadObject();</span><br><span class=\"line\"></span><br><span class=\"line\">        // &quot;Decrypt&quot;/de-obscure the sensitive data</span><br><span class=\"line\">        age = age &lt;&lt; 2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String toString()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return &quot;[Person: firstName=&quot; + firstName + </span><br><span class=\"line\">            &quot; lastName=&quot; + lastName +</span><br><span class=\"line\">            &quot; age=&quot; + age +</span><br><span class=\"line\">            &quot; spouse=&quot; + (spouse!=null ? spouse.getFirstName() : &quot;[null]&quot;) +</span><br><span class=\"line\">            &quot;]&quot;;</span><br><span class=\"line\">    &#125;      </span><br><span class=\"line\"></span><br><span class=\"line\">    private String firstName;</span><br><span class=\"line\">    private String lastName;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">    private Person spouse;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果需要查看被模糊化的数据，总是可以查看序列化数据流&#x2F;文件。而且，由于该格式被完全文档化，即使不能访问类本身，也仍可以读取序列化流中的内容。</p>\n<h4 id=\"3-序列化的数据可以被签名和密封\"><a href=\"#3-序列化的数据可以被签名和密封\" class=\"headerlink\" title=\"3. 序列化的数据可以被签名和密封\"></a>3. 序列化的数据可以被签名和密封</h4><p>上一个技巧假设您想模糊化序列化数据，而不是对其加密或者确保它不被修改。当然，通过使用 writeObject 和 readObject 可以实现密码加密和签名管理，但其实还有更好的方式。</p>\n<p>如果需要对整个对象进行加密和签名，最简单的是将它放在一个 javax.crypto.SealedObject 和&#x2F;或 java.security.SignedObject 包装器中。两者都是可序列化的，所以将对象包装在 SealedObject 中可以围绕原对象创建一种“包装盒”。必须有对称密钥才能解密，而且密钥必须单独管理。同样，也可以将 SignedObject 用于数据验证，并且对称密钥也必须单独管理。</p>\n<p>结合使用这两种对象，便可以轻松地对序列化数据进行密封和签名，而不必强调关于数字签名验证或加密的细节。很简洁，是吧？</p>\n<h4 id=\"4-序列化允许将代理放在流中\"><a href=\"#4-序列化允许将代理放在流中\" class=\"headerlink\" title=\"4. 序列化允许将代理放在流中\"></a>4. 序列化允许将代理放在流中</h4><p>很多情况下，类中包含一个核心数据元素，通过它可以派生或找到类中的其他字段。在此情况下，没有必要序列化整个对象。可以将字段标记为 transient，但是每当有方法访问一个字段时，类仍然必须显式地产生代码来检查它是否被初始化。</p>\n<p>如果首要问题是序列化，那么最好指定一个 flyweight 或代理放在流中。为原始 Person 提供一个 writeReplace 方法，可以序列化不同类型的对象来代替它。类似地，如果反序列化期间发现一个 readResolve 方法，那么将调用该方法，将替代对象提供给调用者。</p>\n<p><strong>打包和解包代理</strong></p>\n<p>writeReplace 和 readResolve 方法使 Person 类可以将它的所有数据（或其中的核心数据）打包到一个 PersonProxy 中，将它放入到一个流中，然后在反序列化时再进行解包。</p>\n<p><strong>清单 5. 你完整了我，我代替了你</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class PersonProxy</span><br><span class=\"line\">    implements java.io.Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public PersonProxy(Person orig)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        data = orig.getFirstName() + &quot;,&quot; + orig.getLastName() + &quot;,&quot; + orig.getAge();</span><br><span class=\"line\">        if (orig.getSpouse() != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Person spouse = orig.getSpouse();</span><br><span class=\"line\">            data = data + &quot;,&quot; + spouse.getFirstName() + &quot;,&quot; + spouse.getLastName() + &quot;,&quot;  </span><br><span class=\"line\">              + spouse.getAge();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String data;</span><br><span class=\"line\">    private Object readResolve()</span><br><span class=\"line\">        throws java.io.ObjectStreamException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        String[] pieces = data.split(&quot;,&quot;);</span><br><span class=\"line\">        Person result = new Person(pieces[0], pieces[1], Integer.parseInt(pieces[2]));</span><br><span class=\"line\">        if (pieces.length &gt; 3)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            result.setSpouse(new Person(pieces[3], pieces[4], Integer.parseInt</span><br><span class=\"line\">              (pieces[5])));</span><br><span class=\"line\">            result.getSpouse().setSpouse(result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Person</span><br><span class=\"line\">    implements java.io.Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public Person(String fn, String ln, int a)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        this.firstName = fn; this.lastName = ln; this.age = a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getFirstName() &#123; return firstName; &#125;</span><br><span class=\"line\">    public String getLastName() &#123; return lastName; &#125;</span><br><span class=\"line\">    public int getAge() &#123; return age; &#125;</span><br><span class=\"line\">    public Person getSpouse() &#123; return spouse; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Object writeReplace()</span><br><span class=\"line\">        throws java.io.ObjectStreamException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return new PersonProxy(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setFirstName(String value) &#123; firstName = value; &#125;</span><br><span class=\"line\">    public void setLastName(String value) &#123; lastName = value; &#125;</span><br><span class=\"line\">    public void setAge(int value) &#123; age = value; &#125;</span><br><span class=\"line\">    public void setSpouse(Person value) &#123; spouse = value; &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">    public String toString()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return &quot;[Person: firstName=&quot; + firstName + </span><br><span class=\"line\">            &quot; lastName=&quot; + lastName +</span><br><span class=\"line\">            &quot; age=&quot; + age +</span><br><span class=\"line\">            &quot; spouse=&quot; + spouse.getFirstName() +</span><br><span class=\"line\">            &quot;]&quot;;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">    private String firstName;</span><br><span class=\"line\">    private String lastName;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">    private Person spouse;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，PersonProxy 必须跟踪 Person 的所有数据。这通常意味着代理需要是 Person 的一个内部类，以便能访问 private 字段。有时候，代理还需要追踪其他对象引用并手动序列化它们，例如 Person 的 spouse。</p>\n<p>这种技巧是少数几种不需要读&#x2F;写平衡的技巧之一。例如，一个类被重构成另一种类型后的版本可以提供一个 readResolve 方法，以便静默地将被序列化的对象转换成新类型。类似地，它可以采用 writeReplace 方法将旧类序列化成新版本。</p>\n<h4 id=\"5-信任，但要验证\"><a href=\"#5-信任，但要验证\" class=\"headerlink\" title=\"5. 信任，但要验证\"></a>5. 信任，但要验证</h4><p>认为序列化流中的数据总是与最初写到流中的数据一致，这没有问题。但是，正如一位美国前总统所说的，“信任，但要验证”。<br>对于序列化的对象，这意味着验证字段，以确保在反序列化之后它们仍具有正确的值，“以防万一”。</p>\n<p>为此，可以实现 ObjectInputValidation接口，并覆盖 validateObject() 方法。如果调用该方法时发现某处有错误，则抛出一个 InvalidObjectException。</p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>Java 对象序列化比大多数 Java 开发人员想象的更灵活，这使我们有更多的机会解决棘手的情况。</p>\n<p>幸运的是，像这样的编程妙招在 JVM 中随处可见。关键是要知道它们，在遇到难题的时候能用上它们。</p>\n<p>来源：<a href=\"http://www.topthink.com/topic/11361.html\">www.topthink.com/topic/11361.html</a></p>\n"},{"title":"你真的搞懂 transient 关键字了吗？","date":"2025-10-14T06:42:34.000Z","_content":"\n## 先解释下什么是序列化\n\n我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。\n\nJava序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。\n\n更多序列化请参考：《[关于Java序列化你应该知道的一切](https://mp.weixin.qq.com/s/wHmK1kKyne6gCkIxt0NERQ)》这篇文章。\n\n## 什么是 transient？\n\n简单来说就是，被 transient 修饰的变量不能被序列化。\n\n**具体来看下面的示例1**\n\n```\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n/**\n * @author \n */\npublic class TransientTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser user = new User();\n\t\tuser.setUsername(\"Java技术\");\n\t\tuser.setId(\"javastack\");\n\n\t\tSystem.out.println(\"\\n序列化之前\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"d:/user.txt\"));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\n\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(\"d:/user.txt\"));\n\t\tuser = (User) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(\"\\n序列化之后\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t}\n}\n\n/**\n * @author \n */\nclass User implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\n序列化之前\nusername: Java技术\nid: javastack\n\n序列化之后\nusername: Java技术\nid: null\n```\n\n示例1在 id 字段上加了 transient 关键字修饰，反序列化出来之后值为 null，说明了被 transient 修饰的变量不能被序列化。\n\n## 静态变量能被序列化吗？\n\n这个话题也是最近栈长的Java技术vip群里面讨论的，大家对这个知识点比较模糊，我就写了这篇文章测试总结一下。\n\n![](http://img.javastack.cn/微信图片_20190214162351.png)\n\n> 如果你也想加入我们的Java技术vip群和各位大牛一起讨论技术，那点击[这个链接](https://mp.weixin.qq.com/s/iqCLAduVzDqt19L6D4FCUQ)了解加入吧。\n\n那么，到底静态变量能被序列化吗？废话少说，先动手测试下吧！\n\n示例2：\n\n```\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n/**\n * @author \n */\npublic class TransientStaticTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser2 user = new User2();\n\t\tUser2.username = \"Java技术1\";\n\t\tuser.setId(\"javastack\");\n\n\t\tSystem.out.println(\"\\n序列化之前\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"d:/user.txt\"));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\t\t\n\t\t// 在反序列化出来之前，改变静态变量的值\n\t\tUser2.username = \"Java技术2\";\n\n\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(\"d:/user.txt\"));\n\t\tuser = (User2) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(\"\\n序列化之后\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t}\n}\n\n/**\n * @author \n */\nclass User2 implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic static String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\n序列化之前\nusername: Java技术1\nid: javastack\n\n序列化之后\nusername: Java技术2\nid: null\n```\n\n示例2把 username 改为了 public static, 并在反序列化出来之前改变了静态变量的值，结果可以看出序列化之后的值并非序列化进去时的值。\n\n由以上结果分析可知，静态变量不能被序列化，示例2读取出来的是 username 在 JVM 内存中存储的值。\n\n## transient 真不能被序列化吗？\n\n继续来看示例3：\n\n```\nimport java.io.Externalizable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\n\n/**\n * @author \n */\npublic class ExternalizableTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser3 user = new User3();\n\t\tuser.setUsername(\"Java技术\");\n\t\tuser.setId(\"javastack\");\n\t\tObjectOutput objectOutput = new ObjectOutputStream(new FileOutputStream(new File(\"javastack\")));\n\t\tobjectOutput.writeObject(user);\n\n\t\tObjectInput objectInput = new ObjectInputStream(new FileInputStream(new File(\"javastack\")));\n\t\tuser = (User3) objectInput.readObject();\n\n\t\tSystem.out.println(user.getUsername());\n\t\tSystem.out.println(user.getId());\n\n\t\tobjectOutput.close();\n\t\tobjectInput.close();\n\t}\n\n}\n\n/**\n * @author \n */\nclass User3 implements Externalizable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic User3() {\n\n\t}\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\t@Override\n\tpublic void writeExternal(ObjectOutput objectOutput) throws IOException {\n\t\tobjectOutput.writeObject(id);\n\t}\n\n\t@Override\n\tpublic void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException {\n\t\tid = (String) objectInput.readObject();\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\nnull\njavastack\n```\n\n示例3的 id 被 transient 修改了，为什么还能序列化出来？那是因为 User3 实现了接口 Externalizable，而不是 Serializable。\n\n在 Java 中有两种实现序列化的方式，Serializable 和 Externalizable，可能大部分人只知道 Serializable 而不知道 Externalizable。\n\n这两种序列化方式的区别是：实现了 Serializable 接口是自动序列化的，实现 Externalizable 则需要手动序列化，通过 writeExternal 和 readExternal 方法手动进行，这也是为什么上面的 username 为 null 的原因了。\n\n## transient 关键字总结\n\n1）transient修饰的变量不能被序列化；\n\n2）transient只作用于实现 Serializable 接口；\n\n3）transient只能用来修饰普通成员变量字段；\n\n4）不管有没有 transient 修饰，静态变量都不能被序列化；\n\n\n\n","source":"_posts/基础/你真的搞懂 transient 关键字了吗？.md","raw":"---\ntitle: 你真的搞懂 transient 关键字了吗？\ndate: 2025-10-14 14:42:34\ntags: 基础\n---\n\n## 先解释下什么是序列化\n\n我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。\n\nJava序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。\n\n更多序列化请参考：《[关于Java序列化你应该知道的一切](https://mp.weixin.qq.com/s/wHmK1kKyne6gCkIxt0NERQ)》这篇文章。\n\n## 什么是 transient？\n\n简单来说就是，被 transient 修饰的变量不能被序列化。\n\n**具体来看下面的示例1**\n\n```\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n/**\n * @author \n */\npublic class TransientTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser user = new User();\n\t\tuser.setUsername(\"Java技术\");\n\t\tuser.setId(\"javastack\");\n\n\t\tSystem.out.println(\"\\n序列化之前\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"d:/user.txt\"));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\n\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(\"d:/user.txt\"));\n\t\tuser = (User) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(\"\\n序列化之后\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t}\n}\n\n/**\n * @author \n */\nclass User implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\n序列化之前\nusername: Java技术\nid: javastack\n\n序列化之后\nusername: Java技术\nid: null\n```\n\n示例1在 id 字段上加了 transient 关键字修饰，反序列化出来之后值为 null，说明了被 transient 修饰的变量不能被序列化。\n\n## 静态变量能被序列化吗？\n\n这个话题也是最近栈长的Java技术vip群里面讨论的，大家对这个知识点比较模糊，我就写了这篇文章测试总结一下。\n\n![](http://img.javastack.cn/微信图片_20190214162351.png)\n\n> 如果你也想加入我们的Java技术vip群和各位大牛一起讨论技术，那点击[这个链接](https://mp.weixin.qq.com/s/iqCLAduVzDqt19L6D4FCUQ)了解加入吧。\n\n那么，到底静态变量能被序列化吗？废话少说，先动手测试下吧！\n\n示例2：\n\n```\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n/**\n * @author \n */\npublic class TransientStaticTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser2 user = new User2();\n\t\tUser2.username = \"Java技术1\";\n\t\tuser.setId(\"javastack\");\n\n\t\tSystem.out.println(\"\\n序列化之前\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"d:/user.txt\"));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\t\t\n\t\t// 在反序列化出来之前，改变静态变量的值\n\t\tUser2.username = \"Java技术2\";\n\n\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(\"d:/user.txt\"));\n\t\tuser = (User2) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(\"\\n序列化之后\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t}\n}\n\n/**\n * @author \n */\nclass User2 implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic static String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\n序列化之前\nusername: Java技术1\nid: javastack\n\n序列化之后\nusername: Java技术2\nid: null\n```\n\n示例2把 username 改为了 public static, 并在反序列化出来之前改变了静态变量的值，结果可以看出序列化之后的值并非序列化进去时的值。\n\n由以上结果分析可知，静态变量不能被序列化，示例2读取出来的是 username 在 JVM 内存中存储的值。\n\n## transient 真不能被序列化吗？\n\n继续来看示例3：\n\n```\nimport java.io.Externalizable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\n\n/**\n * @author \n */\npublic class ExternalizableTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser3 user = new User3();\n\t\tuser.setUsername(\"Java技术\");\n\t\tuser.setId(\"javastack\");\n\t\tObjectOutput objectOutput = new ObjectOutputStream(new FileOutputStream(new File(\"javastack\")));\n\t\tobjectOutput.writeObject(user);\n\n\t\tObjectInput objectInput = new ObjectInputStream(new FileInputStream(new File(\"javastack\")));\n\t\tuser = (User3) objectInput.readObject();\n\n\t\tSystem.out.println(user.getUsername());\n\t\tSystem.out.println(user.getId());\n\n\t\tobjectOutput.close();\n\t\tobjectInput.close();\n\t}\n\n}\n\n/**\n * @author \n */\nclass User3 implements Externalizable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic User3() {\n\n\t}\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\t@Override\n\tpublic void writeExternal(ObjectOutput objectOutput) throws IOException {\n\t\tobjectOutput.writeObject(id);\n\t}\n\n\t@Override\n\tpublic void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException {\n\t\tid = (String) objectInput.readObject();\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\nnull\njavastack\n```\n\n示例3的 id 被 transient 修改了，为什么还能序列化出来？那是因为 User3 实现了接口 Externalizable，而不是 Serializable。\n\n在 Java 中有两种实现序列化的方式，Serializable 和 Externalizable，可能大部分人只知道 Serializable 而不知道 Externalizable。\n\n这两种序列化方式的区别是：实现了 Serializable 接口是自动序列化的，实现 Externalizable 则需要手动序列化，通过 writeExternal 和 readExternal 方法手动进行，这也是为什么上面的 username 为 null 的原因了。\n\n## transient 关键字总结\n\n1）transient修饰的变量不能被序列化；\n\n2）transient只作用于实现 Serializable 接口；\n\n3）transient只能用来修饰普通成员变量字段；\n\n4）不管有没有 transient 修饰，静态变量都不能被序列化；\n\n\n\n","slug":"基础/你真的搞懂 transient 关键字了吗？","published":1,"updated":"2025-10-14T07:36:11.269Z","_id":"cmgq8bkii0015hod44nj34jsx","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"先解释下什么是序列化\"><a href=\"#先解释下什么是序列化\" class=\"headerlink\" title=\"先解释下什么是序列化\"></a>先解释下什么是序列化</h2><p>我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。</p>\n<p>Java序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。</p>\n<p>更多序列化请参考：《<a href=\"https://mp.weixin.qq.com/s/wHmK1kKyne6gCkIxt0NERQ\">关于Java序列化你应该知道的一切</a>》这篇文章。</p>\n<h2 id=\"什么是-transient？\"><a href=\"#什么是-transient？\" class=\"headerlink\" title=\"什么是 transient？\"></a>什么是 transient？</h2><p>简单来说就是，被 transient 修饰的变量不能被序列化。</p>\n<p><strong>具体来看下面的示例1</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.FileInputStream;</span><br><span class=\"line\">import java.io.FileOutputStream;</span><br><span class=\"line\">import java.io.ObjectInputStream;</span><br><span class=\"line\">import java.io.ObjectOutputStream;</span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">public class TransientTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUser user = new User();</span><br><span class=\"line\">\t\tuser.setUsername(&quot;Java技术&quot;);</span><br><span class=\"line\">\t\tuser.setId(&quot;javastack&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;\\n序列化之前&quot;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;id: &quot; + user.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(&quot;d:/user.txt&quot;));</span><br><span class=\"line\">\t\tos.writeObject(user);</span><br><span class=\"line\">\t\tos.flush();</span><br><span class=\"line\">\t\tos.close();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(&quot;d:/user.txt&quot;));</span><br><span class=\"line\">\t\tuser = (User) is.readObject();</span><br><span class=\"line\">\t\tis.close();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;\\n序列化之后&quot;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;id: &quot; + user.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">class User implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static final long serialVersionUID = 1L;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate String username;</span><br><span class=\"line\">\tprivate transient String id;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getUsername() &#123;</span><br><span class=\"line\">\t\treturn username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setUsername(String username) &#123;</span><br><span class=\"line\">\t\tthis.username = username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getId() &#123;</span><br><span class=\"line\">\t\treturn id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setId(String id) &#123;</span><br><span class=\"line\">\t\tthis.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">序列化之前</span><br><span class=\"line\">username: Java技术</span><br><span class=\"line\">id: javastack</span><br><span class=\"line\"></span><br><span class=\"line\">序列化之后</span><br><span class=\"line\">username: Java技术</span><br><span class=\"line\">id: null</span><br></pre></td></tr></table></figure>\n\n<p>示例1在 id 字段上加了 transient 关键字修饰，反序列化出来之后值为 null，说明了被 transient 修饰的变量不能被序列化。</p>\n<h2 id=\"静态变量能被序列化吗？\"><a href=\"#静态变量能被序列化吗？\" class=\"headerlink\" title=\"静态变量能被序列化吗？\"></a>静态变量能被序列化吗？</h2><p>这个话题也是最近栈长的Java技术vip群里面讨论的，大家对这个知识点比较模糊，我就写了这篇文章测试总结一下。</p>\n<p><img src=\"http://img.javastack.cn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190214162351.png\"></p>\n<blockquote>\n<p>如果你也想加入我们的Java技术vip群和各位大牛一起讨论技术，那点击<a href=\"https://mp.weixin.qq.com/s/iqCLAduVzDqt19L6D4FCUQ\">这个链接</a>了解加入吧。</p>\n</blockquote>\n<p>那么，到底静态变量能被序列化吗？废话少说，先动手测试下吧！</p>\n<p>示例2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.FileInputStream;</span><br><span class=\"line\">import java.io.FileOutputStream;</span><br><span class=\"line\">import java.io.ObjectInputStream;</span><br><span class=\"line\">import java.io.ObjectOutputStream;</span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">public class TransientStaticTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUser2 user = new User2();</span><br><span class=\"line\">\t\tUser2.username = &quot;Java技术1&quot;;</span><br><span class=\"line\">\t\tuser.setId(&quot;javastack&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;\\n序列化之前&quot;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;id: &quot; + user.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(&quot;d:/user.txt&quot;));</span><br><span class=\"line\">\t\tos.writeObject(user);</span><br><span class=\"line\">\t\tos.flush();</span><br><span class=\"line\">\t\tos.close();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t// 在反序列化出来之前，改变静态变量的值</span><br><span class=\"line\">\t\tUser2.username = &quot;Java技术2&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(&quot;d:/user.txt&quot;));</span><br><span class=\"line\">\t\tuser = (User2) is.readObject();</span><br><span class=\"line\">\t\tis.close();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;\\n序列化之后&quot;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;id: &quot; + user.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">class User2 implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static final long serialVersionUID = 1L;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static String username;</span><br><span class=\"line\">\tprivate transient String id;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getUsername() &#123;</span><br><span class=\"line\">\t\treturn username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getId() &#123;</span><br><span class=\"line\">\t\treturn id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setId(String id) &#123;</span><br><span class=\"line\">\t\tthis.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">序列化之前</span><br><span class=\"line\">username: Java技术1</span><br><span class=\"line\">id: javastack</span><br><span class=\"line\"></span><br><span class=\"line\">序列化之后</span><br><span class=\"line\">username: Java技术2</span><br><span class=\"line\">id: null</span><br></pre></td></tr></table></figure>\n\n<p>示例2把 username 改为了 public static, 并在反序列化出来之前改变了静态变量的值，结果可以看出序列化之后的值并非序列化进去时的值。</p>\n<p>由以上结果分析可知，静态变量不能被序列化，示例2读取出来的是 username 在 JVM 内存中存储的值。</p>\n<h2 id=\"transient-真不能被序列化吗？\"><a href=\"#transient-真不能被序列化吗？\" class=\"headerlink\" title=\"transient 真不能被序列化吗？\"></a>transient 真不能被序列化吗？</h2><p>继续来看示例3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.Externalizable;</span><br><span class=\"line\">import java.io.File;</span><br><span class=\"line\">import java.io.FileInputStream;</span><br><span class=\"line\">import java.io.FileOutputStream;</span><br><span class=\"line\">import java.io.IOException;</span><br><span class=\"line\">import java.io.ObjectInput;</span><br><span class=\"line\">import java.io.ObjectInputStream;</span><br><span class=\"line\">import java.io.ObjectOutput;</span><br><span class=\"line\">import java.io.ObjectOutputStream;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">public class ExternalizableTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUser3 user = new User3();</span><br><span class=\"line\">\t\tuser.setUsername(&quot;Java技术&quot;);</span><br><span class=\"line\">\t\tuser.setId(&quot;javastack&quot;);</span><br><span class=\"line\">\t\tObjectOutput objectOutput = new ObjectOutputStream(new FileOutputStream(new File(&quot;javastack&quot;)));</span><br><span class=\"line\">\t\tobjectOutput.writeObject(user);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObjectInput objectInput = new ObjectInputStream(new FileInputStream(new File(&quot;javastack&quot;)));</span><br><span class=\"line\">\t\tuser = (User3) objectInput.readObject();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(user.getUsername());</span><br><span class=\"line\">\t\tSystem.out.println(user.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tobjectOutput.close();</span><br><span class=\"line\">\t\tobjectInput.close();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">class User3 implements Externalizable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static final long serialVersionUID = 1L;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic User3() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate String username;</span><br><span class=\"line\">\tprivate transient String id;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getUsername() &#123;</span><br><span class=\"line\">\t\treturn username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setUsername(String username) &#123;</span><br><span class=\"line\">\t\tthis.username = username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getId() &#123;</span><br><span class=\"line\">\t\treturn id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setId(String id) &#123;</span><br><span class=\"line\">\t\tthis.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void writeExternal(ObjectOutput objectOutput) throws IOException &#123;</span><br><span class=\"line\">\t\tobjectOutput.writeObject(id);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">\t\tid = (String) objectInput.readObject();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">null</span><br><span class=\"line\">javastack</span><br></pre></td></tr></table></figure>\n\n<p>示例3的 id 被 transient 修改了，为什么还能序列化出来？那是因为 User3 实现了接口 Externalizable，而不是 Serializable。</p>\n<p>在 Java 中有两种实现序列化的方式，Serializable 和 Externalizable，可能大部分人只知道 Serializable 而不知道 Externalizable。</p>\n<p>这两种序列化方式的区别是：实现了 Serializable 接口是自动序列化的，实现 Externalizable 则需要手动序列化，通过 writeExternal 和 readExternal 方法手动进行，这也是为什么上面的 username 为 null 的原因了。</p>\n<h2 id=\"transient-关键字总结\"><a href=\"#transient-关键字总结\" class=\"headerlink\" title=\"transient 关键字总结\"></a>transient 关键字总结</h2><p>1）transient修饰的变量不能被序列化；</p>\n<p>2）transient只作用于实现 Serializable 接口；</p>\n<p>3）transient只能用来修饰普通成员变量字段；</p>\n<p>4）不管有没有 transient 修饰，静态变量都不能被序列化；</p>\n","excerpt":"","more":"<h2 id=\"先解释下什么是序列化\"><a href=\"#先解释下什么是序列化\" class=\"headerlink\" title=\"先解释下什么是序列化\"></a>先解释下什么是序列化</h2><p>我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。</p>\n<p>Java序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。</p>\n<p>更多序列化请参考：《<a href=\"https://mp.weixin.qq.com/s/wHmK1kKyne6gCkIxt0NERQ\">关于Java序列化你应该知道的一切</a>》这篇文章。</p>\n<h2 id=\"什么是-transient？\"><a href=\"#什么是-transient？\" class=\"headerlink\" title=\"什么是 transient？\"></a>什么是 transient？</h2><p>简单来说就是，被 transient 修饰的变量不能被序列化。</p>\n<p><strong>具体来看下面的示例1</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.FileInputStream;</span><br><span class=\"line\">import java.io.FileOutputStream;</span><br><span class=\"line\">import java.io.ObjectInputStream;</span><br><span class=\"line\">import java.io.ObjectOutputStream;</span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">public class TransientTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUser user = new User();</span><br><span class=\"line\">\t\tuser.setUsername(&quot;Java技术&quot;);</span><br><span class=\"line\">\t\tuser.setId(&quot;javastack&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;\\n序列化之前&quot;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;id: &quot; + user.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(&quot;d:/user.txt&quot;));</span><br><span class=\"line\">\t\tos.writeObject(user);</span><br><span class=\"line\">\t\tos.flush();</span><br><span class=\"line\">\t\tos.close();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(&quot;d:/user.txt&quot;));</span><br><span class=\"line\">\t\tuser = (User) is.readObject();</span><br><span class=\"line\">\t\tis.close();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;\\n序列化之后&quot;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;id: &quot; + user.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">class User implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static final long serialVersionUID = 1L;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate String username;</span><br><span class=\"line\">\tprivate transient String id;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getUsername() &#123;</span><br><span class=\"line\">\t\treturn username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setUsername(String username) &#123;</span><br><span class=\"line\">\t\tthis.username = username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getId() &#123;</span><br><span class=\"line\">\t\treturn id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setId(String id) &#123;</span><br><span class=\"line\">\t\tthis.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">序列化之前</span><br><span class=\"line\">username: Java技术</span><br><span class=\"line\">id: javastack</span><br><span class=\"line\"></span><br><span class=\"line\">序列化之后</span><br><span class=\"line\">username: Java技术</span><br><span class=\"line\">id: null</span><br></pre></td></tr></table></figure>\n\n<p>示例1在 id 字段上加了 transient 关键字修饰，反序列化出来之后值为 null，说明了被 transient 修饰的变量不能被序列化。</p>\n<h2 id=\"静态变量能被序列化吗？\"><a href=\"#静态变量能被序列化吗？\" class=\"headerlink\" title=\"静态变量能被序列化吗？\"></a>静态变量能被序列化吗？</h2><p>这个话题也是最近栈长的Java技术vip群里面讨论的，大家对这个知识点比较模糊，我就写了这篇文章测试总结一下。</p>\n<p><img src=\"http://img.javastack.cn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190214162351.png\"></p>\n<blockquote>\n<p>如果你也想加入我们的Java技术vip群和各位大牛一起讨论技术，那点击<a href=\"https://mp.weixin.qq.com/s/iqCLAduVzDqt19L6D4FCUQ\">这个链接</a>了解加入吧。</p>\n</blockquote>\n<p>那么，到底静态变量能被序列化吗？废话少说，先动手测试下吧！</p>\n<p>示例2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.FileInputStream;</span><br><span class=\"line\">import java.io.FileOutputStream;</span><br><span class=\"line\">import java.io.ObjectInputStream;</span><br><span class=\"line\">import java.io.ObjectOutputStream;</span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">public class TransientStaticTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUser2 user = new User2();</span><br><span class=\"line\">\t\tUser2.username = &quot;Java技术1&quot;;</span><br><span class=\"line\">\t\tuser.setId(&quot;javastack&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;\\n序列化之前&quot;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;id: &quot; + user.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(&quot;d:/user.txt&quot;));</span><br><span class=\"line\">\t\tos.writeObject(user);</span><br><span class=\"line\">\t\tos.flush();</span><br><span class=\"line\">\t\tos.close();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t// 在反序列化出来之前，改变静态变量的值</span><br><span class=\"line\">\t\tUser2.username = &quot;Java技术2&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(&quot;d:/user.txt&quot;));</span><br><span class=\"line\">\t\tuser = (User2) is.readObject();</span><br><span class=\"line\">\t\tis.close();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;\\n序列化之后&quot;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;id: &quot; + user.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">class User2 implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static final long serialVersionUID = 1L;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static String username;</span><br><span class=\"line\">\tprivate transient String id;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getUsername() &#123;</span><br><span class=\"line\">\t\treturn username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getId() &#123;</span><br><span class=\"line\">\t\treturn id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setId(String id) &#123;</span><br><span class=\"line\">\t\tthis.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">序列化之前</span><br><span class=\"line\">username: Java技术1</span><br><span class=\"line\">id: javastack</span><br><span class=\"line\"></span><br><span class=\"line\">序列化之后</span><br><span class=\"line\">username: Java技术2</span><br><span class=\"line\">id: null</span><br></pre></td></tr></table></figure>\n\n<p>示例2把 username 改为了 public static, 并在反序列化出来之前改变了静态变量的值，结果可以看出序列化之后的值并非序列化进去时的值。</p>\n<p>由以上结果分析可知，静态变量不能被序列化，示例2读取出来的是 username 在 JVM 内存中存储的值。</p>\n<h2 id=\"transient-真不能被序列化吗？\"><a href=\"#transient-真不能被序列化吗？\" class=\"headerlink\" title=\"transient 真不能被序列化吗？\"></a>transient 真不能被序列化吗？</h2><p>继续来看示例3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.Externalizable;</span><br><span class=\"line\">import java.io.File;</span><br><span class=\"line\">import java.io.FileInputStream;</span><br><span class=\"line\">import java.io.FileOutputStream;</span><br><span class=\"line\">import java.io.IOException;</span><br><span class=\"line\">import java.io.ObjectInput;</span><br><span class=\"line\">import java.io.ObjectInputStream;</span><br><span class=\"line\">import java.io.ObjectOutput;</span><br><span class=\"line\">import java.io.ObjectOutputStream;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">public class ExternalizableTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUser3 user = new User3();</span><br><span class=\"line\">\t\tuser.setUsername(&quot;Java技术&quot;);</span><br><span class=\"line\">\t\tuser.setId(&quot;javastack&quot;);</span><br><span class=\"line\">\t\tObjectOutput objectOutput = new ObjectOutputStream(new FileOutputStream(new File(&quot;javastack&quot;)));</span><br><span class=\"line\">\t\tobjectOutput.writeObject(user);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObjectInput objectInput = new ObjectInputStream(new FileInputStream(new File(&quot;javastack&quot;)));</span><br><span class=\"line\">\t\tuser = (User3) objectInput.readObject();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(user.getUsername());</span><br><span class=\"line\">\t\tSystem.out.println(user.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tobjectOutput.close();</span><br><span class=\"line\">\t\tobjectInput.close();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">class User3 implements Externalizable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static final long serialVersionUID = 1L;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic User3() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate String username;</span><br><span class=\"line\">\tprivate transient String id;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getUsername() &#123;</span><br><span class=\"line\">\t\treturn username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setUsername(String username) &#123;</span><br><span class=\"line\">\t\tthis.username = username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getId() &#123;</span><br><span class=\"line\">\t\treturn id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setId(String id) &#123;</span><br><span class=\"line\">\t\tthis.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void writeExternal(ObjectOutput objectOutput) throws IOException &#123;</span><br><span class=\"line\">\t\tobjectOutput.writeObject(id);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">\t\tid = (String) objectInput.readObject();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">null</span><br><span class=\"line\">javastack</span><br></pre></td></tr></table></figure>\n\n<p>示例3的 id 被 transient 修改了，为什么还能序列化出来？那是因为 User3 实现了接口 Externalizable，而不是 Serializable。</p>\n<p>在 Java 中有两种实现序列化的方式，Serializable 和 Externalizable，可能大部分人只知道 Serializable 而不知道 Externalizable。</p>\n<p>这两种序列化方式的区别是：实现了 Serializable 接口是自动序列化的，实现 Externalizable 则需要手动序列化，通过 writeExternal 和 readExternal 方法手动进行，这也是为什么上面的 username 为 null 的原因了。</p>\n<h2 id=\"transient-关键字总结\"><a href=\"#transient-关键字总结\" class=\"headerlink\" title=\"transient 关键字总结\"></a>transient 关键字总结</h2><p>1）transient修饰的变量不能被序列化；</p>\n<p>2）transient只作用于实现 Serializable 接口；</p>\n<p>3）transient只能用来修饰普通成员变量字段；</p>\n<p>4）不管有没有 transient 修饰，静态变量都不能被序列化；</p>\n"},{"title":"坑爹的 Java 可变参数，把我整得够惨。","date":"2025-10-14T06:42:34.000Z","_content":"\n**什么是可变参数？**\n\n就是方法参数用 `Object... args` 三个点形式，一个参数可以接收多个参数。\n\n实际的代码就不帖了，来看这个示例吧：\n\n**示例1**\n\n```\npublic static void main(String[] args) {\n    test(\"name=%s&memo=%s\", \"Java技术\", \"666\");\n}\n\nprivate static void test(String text, Object... params) {\n    String result = String.format(text, params);\n    System.out.println(result);\n}\n```\n\n大家猜结果是什么？结果如我们想象：\n\n```\nname=Java技术&memo=666\n```\n\n**示例2**\n\n```\npublic static void main(String[] args) {\n    test(\"name=%s&memo=%s\", \"Java技术\");\n}\n\nprivate static void test(String text, Object... params) {\n    String result = String.format(text, params, \"666\");\n    System.out.println(result);\n}\n```\n\n我把 \"666\" 移到了子方法里面，放到了 format 最后，再来看下结果是什么。\n\n```\nname=[Ljava.lang.Object;@4cb2c100&memo=666\n```\n\n这并非是我想要的结果，把可变参数 params 数组对象地址作为值输出出来了，把我搞得够惨，最后我干掉了可变参数。。\n\nJDK里面很多有用到可变参数的，可实际开发中，并不建议使用可变参考，它带来的困扰和潜在的问题会远大于便利性，比如在方法重构、重写等也会带来很多问题。\n\n关于可变参数，也是有开发规范的，不能随便写。我找到了阿里巴巴的《Java开发手册》中关于可变参数的规约。\n\n> 相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object 。\n> \n> 说明：可变参数必须放置在参数列表的最后。 （ 提倡同学们尽量不用可变参数编程 ）\n> \n> 正例： public List<User> listUsers(String type, Long... ids) {...}\n\n获取这份阿里巴巴的Java开发手册最新PDF版，大家可以关注Java技术微信公众号，在后台回复：手册，即可获取。\n\n阿里巴巴也是不建议大家合作可变参数的，可知它带来的坑会有多坑。。\n\n","source":"_posts/基础/坑爹的 Java 可变参数，把我整得够惨。.md","raw":"---\ntitle: 坑爹的 Java 可变参数，把我整得够惨。\ndate: 2025-10-14 14:42:34\ntags: 基础\n---\n\n**什么是可变参数？**\n\n就是方法参数用 `Object... args` 三个点形式，一个参数可以接收多个参数。\n\n实际的代码就不帖了，来看这个示例吧：\n\n**示例1**\n\n```\npublic static void main(String[] args) {\n    test(\"name=%s&memo=%s\", \"Java技术\", \"666\");\n}\n\nprivate static void test(String text, Object... params) {\n    String result = String.format(text, params);\n    System.out.println(result);\n}\n```\n\n大家猜结果是什么？结果如我们想象：\n\n```\nname=Java技术&memo=666\n```\n\n**示例2**\n\n```\npublic static void main(String[] args) {\n    test(\"name=%s&memo=%s\", \"Java技术\");\n}\n\nprivate static void test(String text, Object... params) {\n    String result = String.format(text, params, \"666\");\n    System.out.println(result);\n}\n```\n\n我把 \"666\" 移到了子方法里面，放到了 format 最后，再来看下结果是什么。\n\n```\nname=[Ljava.lang.Object;@4cb2c100&memo=666\n```\n\n这并非是我想要的结果，把可变参数 params 数组对象地址作为值输出出来了，把我搞得够惨，最后我干掉了可变参数。。\n\nJDK里面很多有用到可变参数的，可实际开发中，并不建议使用可变参考，它带来的困扰和潜在的问题会远大于便利性，比如在方法重构、重写等也会带来很多问题。\n\n关于可变参数，也是有开发规范的，不能随便写。我找到了阿里巴巴的《Java开发手册》中关于可变参数的规约。\n\n> 相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object 。\n> \n> 说明：可变参数必须放置在参数列表的最后。 （ 提倡同学们尽量不用可变参数编程 ）\n> \n> 正例： public List<User> listUsers(String type, Long... ids) {...}\n\n获取这份阿里巴巴的Java开发手册最新PDF版，大家可以关注Java技术微信公众号，在后台回复：手册，即可获取。\n\n阿里巴巴也是不建议大家合作可变参数的，可知它带来的坑会有多坑。。\n\n","slug":"基础/坑爹的 Java 可变参数，把我整得够惨。","published":1,"updated":"2025-10-14T07:32:45.043Z","_id":"cmgq8bkij0016hod44lyqbqle","comments":1,"layout":"post","photos":[],"content":"<p><strong>什么是可变参数？</strong></p>\n<p>就是方法参数用 <code>Object... args</code> 三个点形式，一个参数可以接收多个参数。</p>\n<p>实际的代码就不帖了，来看这个示例吧：</p>\n<p><strong>示例1</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    test(&quot;name=%s&amp;memo=%s&quot;, &quot;Java技术&quot;, &quot;666&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static void test(String text, Object... params) &#123;</span><br><span class=\"line\">    String result = String.format(text, params);</span><br><span class=\"line\">    System.out.println(result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大家猜结果是什么？结果如我们想象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name=Java技术&amp;memo=666</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例2</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    test(&quot;name=%s&amp;memo=%s&quot;, &quot;Java技术&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static void test(String text, Object... params) &#123;</span><br><span class=\"line\">    String result = String.format(text, params, &quot;666&quot;);</span><br><span class=\"line\">    System.out.println(result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我把 “666” 移到了子方法里面，放到了 format 最后，再来看下结果是什么。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name=[Ljava.lang.Object;@4cb2c100&amp;memo=666</span><br></pre></td></tr></table></figure>\n\n<p>这并非是我想要的结果，把可变参数 params 数组对象地址作为值输出出来了，把我搞得够惨，最后我干掉了可变参数。。</p>\n<p>JDK里面很多有用到可变参数的，可实际开发中，并不建议使用可变参考，它带来的困扰和潜在的问题会远大于便利性，比如在方法重构、重写等也会带来很多问题。</p>\n<p>关于可变参数，也是有开发规范的，不能随便写。我找到了阿里巴巴的《Java开发手册》中关于可变参数的规约。</p>\n<blockquote>\n<p>相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object 。</p>\n<p>说明：可变参数必须放置在参数列表的最后。 （ 提倡同学们尽量不用可变参数编程 ）</p>\n<p>正例： public List<User> listUsers(String type, Long… ids) {…}</p>\n</blockquote>\n<p>获取这份阿里巴巴的Java开发手册最新PDF版，大家可以关注Java技术微信公众号，在后台回复：手册，即可获取。</p>\n<p>阿里巴巴也是不建议大家合作可变参数的，可知它带来的坑会有多坑。。</p>\n","excerpt":"","more":"<p><strong>什么是可变参数？</strong></p>\n<p>就是方法参数用 <code>Object... args</code> 三个点形式，一个参数可以接收多个参数。</p>\n<p>实际的代码就不帖了，来看这个示例吧：</p>\n<p><strong>示例1</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    test(&quot;name=%s&amp;memo=%s&quot;, &quot;Java技术&quot;, &quot;666&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static void test(String text, Object... params) &#123;</span><br><span class=\"line\">    String result = String.format(text, params);</span><br><span class=\"line\">    System.out.println(result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大家猜结果是什么？结果如我们想象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name=Java技术&amp;memo=666</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例2</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    test(&quot;name=%s&amp;memo=%s&quot;, &quot;Java技术&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private static void test(String text, Object... params) &#123;</span><br><span class=\"line\">    String result = String.format(text, params, &quot;666&quot;);</span><br><span class=\"line\">    System.out.println(result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我把 “666” 移到了子方法里面，放到了 format 最后，再来看下结果是什么。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name=[Ljava.lang.Object;@4cb2c100&amp;memo=666</span><br></pre></td></tr></table></figure>\n\n<p>这并非是我想要的结果，把可变参数 params 数组对象地址作为值输出出来了，把我搞得够惨，最后我干掉了可变参数。。</p>\n<p>JDK里面很多有用到可变参数的，可实际开发中，并不建议使用可变参考，它带来的困扰和潜在的问题会远大于便利性，比如在方法重构、重写等也会带来很多问题。</p>\n<p>关于可变参数，也是有开发规范的，不能随便写。我找到了阿里巴巴的《Java开发手册》中关于可变参数的规约。</p>\n<blockquote>\n<p>相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object 。</p>\n<p>说明：可变参数必须放置在参数列表的最后。 （ 提倡同学们尽量不用可变参数编程 ）</p>\n<p>正例： public List<User> listUsers(String type, Long… ids) {…}</p>\n</blockquote>\n<p>获取这份阿里巴巴的Java开发手册最新PDF版，大家可以关注Java技术微信公众号，在后台回复：手册，即可获取。</p>\n<p>阿里巴巴也是不建议大家合作可变参数的，可知它带来的坑会有多坑。。</p>\n"},{"title":"你真的搞懂 transient  关键字了吗？","date":"2025-10-14T06:42:34.000Z","_content":"\n## 先解释下什么是序列化\n\n我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。\n\nJava序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。\n\n更多序列化请参考：《[关于Java序列化你应该知道的一切](https://mp.weixin.qq.com/s/wHmK1kKyne6gCkIxt0NERQ)》这篇文章。\n\n## 什么是 transient？\n\n简单来说就是，被 transient 修饰的变量不能被序列化。\n\n**具体来看下面的示例1**\n\n```\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n/**\n * @author \n */\npublic class TransientTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser user = new User();\n\t\tuser.setUsername(\"Java技术\");\n\t\tuser.setId(\"javastack\");\n\n\t\tSystem.out.println(\"\\n序列化之前\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"d:/user.txt\"));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\n\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(\"d:/user.txt\"));\n\t\tuser = (User) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(\"\\n序列化之后\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t}\n}\n\n/**\n * @author \n */\nclass User implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\n序列化之前\nusername: Java技术\nid: javastack\n\n序列化之后\nusername: Java技术\nid: null\n```\n\n示例1在 id 字段上加了 transient 关键字修饰，反序列化出来之后值为 null，说明了被 transient 修饰的变量不能被序列化。\n\n## 静态变量能被序列化吗？\n\n这个话题也是最近栈长的Java技术vip群里面讨论的，大家对这个知识点比较模糊，我就写了这篇文章测试总结一下。\n\n![](http://img.javastack.cn/微信图片_20190214162351.png)\n\n> 如果你也想加入我们的Java技术vip群和各位大牛一起讨论技术，那点击[这个链接](https://mp.weixin.qq.com/s/iqCLAduVzDqt19L6D4FCUQ)了解加入吧。\n\n那么，到底静态变量能被序列化吗？废话少说，先动手测试下吧！\n\n示例2：\n\n```\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n/**\n * @author \n */\npublic class TransientStaticTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser2 user = new User2();\n\t\tUser2.username = \"Java技术1\";\n\t\tuser.setId(\"javastack\");\n\n\t\tSystem.out.println(\"\\n序列化之前\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"d:/user.txt\"));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\t\t\n\t\t// 在反序列化出来之前，改变静态变量的值\n\t\tUser2.username = \"Java技术2\";\n\n\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(\"d:/user.txt\"));\n\t\tuser = (User2) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(\"\\n序列化之后\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t}\n}\n\n/**\n * @author \n */\nclass User2 implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic static String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\n序列化之前\nusername: Java技术1\nid: javastack\n\n序列化之后\nusername: Java技术2\nid: null\n```\n\n示例2把 username 改为了 public static, 并在反序列化出来之前改变了静态变量的值，结果可以看出序列化之后的值并非序列化进去时的值。\n\n由以上结果分析可知，静态变量不能被序列化，示例2读取出来的是 username 在 JVM 内存中存储的值。\n\n## transient 真不能被序列化吗？\n\n继续来看示例3：\n\n```\nimport java.io.Externalizable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\n\n/**\n * @author \n */\npublic class ExternalizableTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser3 user = new User3();\n\t\tuser.setUsername(\"Java技术\");\n\t\tuser.setId(\"javastack\");\n\t\tObjectOutput objectOutput = new ObjectOutputStream(new FileOutputStream(new File(\"javastack\")));\n\t\tobjectOutput.writeObject(user);\n\n\t\tObjectInput objectInput = new ObjectInputStream(new FileInputStream(new File(\"javastack\")));\n\t\tuser = (User3) objectInput.readObject();\n\n\t\tSystem.out.println(user.getUsername());\n\t\tSystem.out.println(user.getId());\n\n\t\tobjectOutput.close();\n\t\tobjectInput.close();\n\t}\n\n}\n\n/**\n * @author \n */\nclass User3 implements Externalizable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic User3() {\n\n\t}\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\t@Override\n\tpublic void writeExternal(ObjectOutput objectOutput) throws IOException {\n\t\tobjectOutput.writeObject(id);\n\t}\n\n\t@Override\n\tpublic void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException {\n\t\tid = (String) objectInput.readObject();\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\nnull\njavastack\n```\n\n示例3的 id 被 transient 修改了，为什么还能序列化出来？那是因为 User3 实现了接口 Externalizable，而不是 Serializable。\n\n在 Java 中有两种实现序列化的方式，Serializable 和 Externalizable，可能大部分人只知道 Serializable 而不知道 Externalizable。\n\n这两种序列化方式的区别是：实现了 Serializable 接口是自动序列化的，实现 Externalizable 则需要手动序列化，通过 writeExternal 和 readExternal 方法手动进行，这也是为什么上面的 username 为 null 的原因了。\n\n## transient 关键字总结\n\n1）transient修饰的变量不能被序列化；\n\n2）transient只作用于实现 Serializable 接口；\n\n3）transient只能用来修饰普通成员变量字段；\n\n4）不管有没有 transient 修饰，静态变量都不能被序列化；\n\n\n\n","source":"_posts/基础/你真的搞懂 transient  关键字了吗？.md","raw":"---\ntitle: 你真的搞懂 transient  关键字了吗？\ndate: 2025-10-14 14:42:34\ntags: 基础\n---\n\n## 先解释下什么是序列化\n\n我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。\n\nJava序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。\n\n更多序列化请参考：《[关于Java序列化你应该知道的一切](https://mp.weixin.qq.com/s/wHmK1kKyne6gCkIxt0NERQ)》这篇文章。\n\n## 什么是 transient？\n\n简单来说就是，被 transient 修饰的变量不能被序列化。\n\n**具体来看下面的示例1**\n\n```\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n/**\n * @author \n */\npublic class TransientTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser user = new User();\n\t\tuser.setUsername(\"Java技术\");\n\t\tuser.setId(\"javastack\");\n\n\t\tSystem.out.println(\"\\n序列化之前\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"d:/user.txt\"));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\n\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(\"d:/user.txt\"));\n\t\tuser = (User) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(\"\\n序列化之后\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t}\n}\n\n/**\n * @author \n */\nclass User implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\n序列化之前\nusername: Java技术\nid: javastack\n\n序列化之后\nusername: Java技术\nid: null\n```\n\n示例1在 id 字段上加了 transient 关键字修饰，反序列化出来之后值为 null，说明了被 transient 修饰的变量不能被序列化。\n\n## 静态变量能被序列化吗？\n\n这个话题也是最近栈长的Java技术vip群里面讨论的，大家对这个知识点比较模糊，我就写了这篇文章测试总结一下。\n\n![](http://img.javastack.cn/微信图片_20190214162351.png)\n\n> 如果你也想加入我们的Java技术vip群和各位大牛一起讨论技术，那点击[这个链接](https://mp.weixin.qq.com/s/iqCLAduVzDqt19L6D4FCUQ)了解加入吧。\n\n那么，到底静态变量能被序列化吗？废话少说，先动手测试下吧！\n\n示例2：\n\n```\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n/**\n * @author \n */\npublic class TransientStaticTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser2 user = new User2();\n\t\tUser2.username = \"Java技术1\";\n\t\tuser.setId(\"javastack\");\n\n\t\tSystem.out.println(\"\\n序列化之前\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"d:/user.txt\"));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\t\t\n\t\t// 在反序列化出来之前，改变静态变量的值\n\t\tUser2.username = \"Java技术2\";\n\n\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(\"d:/user.txt\"));\n\t\tuser = (User2) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(\"\\n序列化之后\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t}\n}\n\n/**\n * @author \n */\nclass User2 implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic static String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\n序列化之前\nusername: Java技术1\nid: javastack\n\n序列化之后\nusername: Java技术2\nid: null\n```\n\n示例2把 username 改为了 public static, 并在反序列化出来之前改变了静态变量的值，结果可以看出序列化之后的值并非序列化进去时的值。\n\n由以上结果分析可知，静态变量不能被序列化，示例2读取出来的是 username 在 JVM 内存中存储的值。\n\n## transient 真不能被序列化吗？\n\n继续来看示例3：\n\n```\nimport java.io.Externalizable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\n\n/**\n * @author \n */\npublic class ExternalizableTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser3 user = new User3();\n\t\tuser.setUsername(\"Java技术\");\n\t\tuser.setId(\"javastack\");\n\t\tObjectOutput objectOutput = new ObjectOutputStream(new FileOutputStream(new File(\"javastack\")));\n\t\tobjectOutput.writeObject(user);\n\n\t\tObjectInput objectInput = new ObjectInputStream(new FileInputStream(new File(\"javastack\")));\n\t\tuser = (User3) objectInput.readObject();\n\n\t\tSystem.out.println(user.getUsername());\n\t\tSystem.out.println(user.getId());\n\n\t\tobjectOutput.close();\n\t\tobjectInput.close();\n\t}\n\n}\n\n/**\n * @author \n */\nclass User3 implements Externalizable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic User3() {\n\n\t}\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\t@Override\n\tpublic void writeExternal(ObjectOutput objectOutput) throws IOException {\n\t\tobjectOutput.writeObject(id);\n\t}\n\n\t@Override\n\tpublic void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException {\n\t\tid = (String) objectInput.readObject();\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\nnull\njavastack\n```\n\n示例3的 id 被 transient 修改了，为什么还能序列化出来？那是因为 User3 实现了接口 Externalizable，而不是 Serializable。\n\n在 Java 中有两种实现序列化的方式，Serializable 和 Externalizable，可能大部分人只知道 Serializable 而不知道 Externalizable。\n\n这两种序列化方式的区别是：实现了 Serializable 接口是自动序列化的，实现 Externalizable 则需要手动序列化，通过 writeExternal 和 readExternal 方法手动进行，这也是为什么上面的 username 为 null 的原因了。\n\n## transient 关键字总结\n\n1）transient修饰的变量不能被序列化；\n\n2）transient只作用于实现 Serializable 接口；\n\n3）transient只能用来修饰普通成员变量字段；\n\n4）不管有没有 transient 修饰，静态变量都不能被序列化；\n\n\n\n","slug":"基础/你真的搞懂 transient  关键字了吗？","published":1,"updated":"2025-10-14T07:36:11.257Z","_id":"cmgq8bkiw0017hod4276x724m","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"先解释下什么是序列化\"><a href=\"#先解释下什么是序列化\" class=\"headerlink\" title=\"先解释下什么是序列化\"></a>先解释下什么是序列化</h2><p>我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。</p>\n<p>Java序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。</p>\n<p>更多序列化请参考：《<a href=\"https://mp.weixin.qq.com/s/wHmK1kKyne6gCkIxt0NERQ\">关于Java序列化你应该知道的一切</a>》这篇文章。</p>\n<h2 id=\"什么是-transient？\"><a href=\"#什么是-transient？\" class=\"headerlink\" title=\"什么是 transient？\"></a>什么是 transient？</h2><p>简单来说就是，被 transient 修饰的变量不能被序列化。</p>\n<p><strong>具体来看下面的示例1</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.FileInputStream;</span><br><span class=\"line\">import java.io.FileOutputStream;</span><br><span class=\"line\">import java.io.ObjectInputStream;</span><br><span class=\"line\">import java.io.ObjectOutputStream;</span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">public class TransientTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUser user = new User();</span><br><span class=\"line\">\t\tuser.setUsername(&quot;Java技术&quot;);</span><br><span class=\"line\">\t\tuser.setId(&quot;javastack&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;\\n序列化之前&quot;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;id: &quot; + user.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(&quot;d:/user.txt&quot;));</span><br><span class=\"line\">\t\tos.writeObject(user);</span><br><span class=\"line\">\t\tos.flush();</span><br><span class=\"line\">\t\tos.close();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(&quot;d:/user.txt&quot;));</span><br><span class=\"line\">\t\tuser = (User) is.readObject();</span><br><span class=\"line\">\t\tis.close();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;\\n序列化之后&quot;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;id: &quot; + user.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">class User implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static final long serialVersionUID = 1L;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate String username;</span><br><span class=\"line\">\tprivate transient String id;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getUsername() &#123;</span><br><span class=\"line\">\t\treturn username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setUsername(String username) &#123;</span><br><span class=\"line\">\t\tthis.username = username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getId() &#123;</span><br><span class=\"line\">\t\treturn id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setId(String id) &#123;</span><br><span class=\"line\">\t\tthis.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">序列化之前</span><br><span class=\"line\">username: Java技术</span><br><span class=\"line\">id: javastack</span><br><span class=\"line\"></span><br><span class=\"line\">序列化之后</span><br><span class=\"line\">username: Java技术</span><br><span class=\"line\">id: null</span><br></pre></td></tr></table></figure>\n\n<p>示例1在 id 字段上加了 transient 关键字修饰，反序列化出来之后值为 null，说明了被 transient 修饰的变量不能被序列化。</p>\n<h2 id=\"静态变量能被序列化吗？\"><a href=\"#静态变量能被序列化吗？\" class=\"headerlink\" title=\"静态变量能被序列化吗？\"></a>静态变量能被序列化吗？</h2><p>这个话题也是最近栈长的Java技术vip群里面讨论的，大家对这个知识点比较模糊，我就写了这篇文章测试总结一下。</p>\n<p><img src=\"http://img.javastack.cn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190214162351.png\"></p>\n<blockquote>\n<p>如果你也想加入我们的Java技术vip群和各位大牛一起讨论技术，那点击<a href=\"https://mp.weixin.qq.com/s/iqCLAduVzDqt19L6D4FCUQ\">这个链接</a>了解加入吧。</p>\n</blockquote>\n<p>那么，到底静态变量能被序列化吗？废话少说，先动手测试下吧！</p>\n<p>示例2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.FileInputStream;</span><br><span class=\"line\">import java.io.FileOutputStream;</span><br><span class=\"line\">import java.io.ObjectInputStream;</span><br><span class=\"line\">import java.io.ObjectOutputStream;</span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">public class TransientStaticTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUser2 user = new User2();</span><br><span class=\"line\">\t\tUser2.username = &quot;Java技术1&quot;;</span><br><span class=\"line\">\t\tuser.setId(&quot;javastack&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;\\n序列化之前&quot;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;id: &quot; + user.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(&quot;d:/user.txt&quot;));</span><br><span class=\"line\">\t\tos.writeObject(user);</span><br><span class=\"line\">\t\tos.flush();</span><br><span class=\"line\">\t\tos.close();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t// 在反序列化出来之前，改变静态变量的值</span><br><span class=\"line\">\t\tUser2.username = &quot;Java技术2&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(&quot;d:/user.txt&quot;));</span><br><span class=\"line\">\t\tuser = (User2) is.readObject();</span><br><span class=\"line\">\t\tis.close();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;\\n序列化之后&quot;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;id: &quot; + user.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">class User2 implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static final long serialVersionUID = 1L;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static String username;</span><br><span class=\"line\">\tprivate transient String id;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getUsername() &#123;</span><br><span class=\"line\">\t\treturn username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getId() &#123;</span><br><span class=\"line\">\t\treturn id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setId(String id) &#123;</span><br><span class=\"line\">\t\tthis.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">序列化之前</span><br><span class=\"line\">username: Java技术1</span><br><span class=\"line\">id: javastack</span><br><span class=\"line\"></span><br><span class=\"line\">序列化之后</span><br><span class=\"line\">username: Java技术2</span><br><span class=\"line\">id: null</span><br></pre></td></tr></table></figure>\n\n<p>示例2把 username 改为了 public static, 并在反序列化出来之前改变了静态变量的值，结果可以看出序列化之后的值并非序列化进去时的值。</p>\n<p>由以上结果分析可知，静态变量不能被序列化，示例2读取出来的是 username 在 JVM 内存中存储的值。</p>\n<h2 id=\"transient-真不能被序列化吗？\"><a href=\"#transient-真不能被序列化吗？\" class=\"headerlink\" title=\"transient 真不能被序列化吗？\"></a>transient 真不能被序列化吗？</h2><p>继续来看示例3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.Externalizable;</span><br><span class=\"line\">import java.io.File;</span><br><span class=\"line\">import java.io.FileInputStream;</span><br><span class=\"line\">import java.io.FileOutputStream;</span><br><span class=\"line\">import java.io.IOException;</span><br><span class=\"line\">import java.io.ObjectInput;</span><br><span class=\"line\">import java.io.ObjectInputStream;</span><br><span class=\"line\">import java.io.ObjectOutput;</span><br><span class=\"line\">import java.io.ObjectOutputStream;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">public class ExternalizableTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUser3 user = new User3();</span><br><span class=\"line\">\t\tuser.setUsername(&quot;Java技术&quot;);</span><br><span class=\"line\">\t\tuser.setId(&quot;javastack&quot;);</span><br><span class=\"line\">\t\tObjectOutput objectOutput = new ObjectOutputStream(new FileOutputStream(new File(&quot;javastack&quot;)));</span><br><span class=\"line\">\t\tobjectOutput.writeObject(user);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObjectInput objectInput = new ObjectInputStream(new FileInputStream(new File(&quot;javastack&quot;)));</span><br><span class=\"line\">\t\tuser = (User3) objectInput.readObject();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(user.getUsername());</span><br><span class=\"line\">\t\tSystem.out.println(user.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tobjectOutput.close();</span><br><span class=\"line\">\t\tobjectInput.close();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">class User3 implements Externalizable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static final long serialVersionUID = 1L;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic User3() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate String username;</span><br><span class=\"line\">\tprivate transient String id;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getUsername() &#123;</span><br><span class=\"line\">\t\treturn username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setUsername(String username) &#123;</span><br><span class=\"line\">\t\tthis.username = username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getId() &#123;</span><br><span class=\"line\">\t\treturn id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setId(String id) &#123;</span><br><span class=\"line\">\t\tthis.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void writeExternal(ObjectOutput objectOutput) throws IOException &#123;</span><br><span class=\"line\">\t\tobjectOutput.writeObject(id);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">\t\tid = (String) objectInput.readObject();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">null</span><br><span class=\"line\">javastack</span><br></pre></td></tr></table></figure>\n\n<p>示例3的 id 被 transient 修改了，为什么还能序列化出来？那是因为 User3 实现了接口 Externalizable，而不是 Serializable。</p>\n<p>在 Java 中有两种实现序列化的方式，Serializable 和 Externalizable，可能大部分人只知道 Serializable 而不知道 Externalizable。</p>\n<p>这两种序列化方式的区别是：实现了 Serializable 接口是自动序列化的，实现 Externalizable 则需要手动序列化，通过 writeExternal 和 readExternal 方法手动进行，这也是为什么上面的 username 为 null 的原因了。</p>\n<h2 id=\"transient-关键字总结\"><a href=\"#transient-关键字总结\" class=\"headerlink\" title=\"transient 关键字总结\"></a>transient 关键字总结</h2><p>1）transient修饰的变量不能被序列化；</p>\n<p>2）transient只作用于实现 Serializable 接口；</p>\n<p>3）transient只能用来修饰普通成员变量字段；</p>\n<p>4）不管有没有 transient 修饰，静态变量都不能被序列化；</p>\n","excerpt":"","more":"<h2 id=\"先解释下什么是序列化\"><a href=\"#先解释下什么是序列化\" class=\"headerlink\" title=\"先解释下什么是序列化\"></a>先解释下什么是序列化</h2><p>我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。</p>\n<p>Java序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。</p>\n<p>更多序列化请参考：《<a href=\"https://mp.weixin.qq.com/s/wHmK1kKyne6gCkIxt0NERQ\">关于Java序列化你应该知道的一切</a>》这篇文章。</p>\n<h2 id=\"什么是-transient？\"><a href=\"#什么是-transient？\" class=\"headerlink\" title=\"什么是 transient？\"></a>什么是 transient？</h2><p>简单来说就是，被 transient 修饰的变量不能被序列化。</p>\n<p><strong>具体来看下面的示例1</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.FileInputStream;</span><br><span class=\"line\">import java.io.FileOutputStream;</span><br><span class=\"line\">import java.io.ObjectInputStream;</span><br><span class=\"line\">import java.io.ObjectOutputStream;</span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">public class TransientTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUser user = new User();</span><br><span class=\"line\">\t\tuser.setUsername(&quot;Java技术&quot;);</span><br><span class=\"line\">\t\tuser.setId(&quot;javastack&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;\\n序列化之前&quot;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;id: &quot; + user.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(&quot;d:/user.txt&quot;));</span><br><span class=\"line\">\t\tos.writeObject(user);</span><br><span class=\"line\">\t\tos.flush();</span><br><span class=\"line\">\t\tos.close();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(&quot;d:/user.txt&quot;));</span><br><span class=\"line\">\t\tuser = (User) is.readObject();</span><br><span class=\"line\">\t\tis.close();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;\\n序列化之后&quot;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;id: &quot; + user.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">class User implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static final long serialVersionUID = 1L;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate String username;</span><br><span class=\"line\">\tprivate transient String id;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getUsername() &#123;</span><br><span class=\"line\">\t\treturn username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setUsername(String username) &#123;</span><br><span class=\"line\">\t\tthis.username = username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getId() &#123;</span><br><span class=\"line\">\t\treturn id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setId(String id) &#123;</span><br><span class=\"line\">\t\tthis.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">序列化之前</span><br><span class=\"line\">username: Java技术</span><br><span class=\"line\">id: javastack</span><br><span class=\"line\"></span><br><span class=\"line\">序列化之后</span><br><span class=\"line\">username: Java技术</span><br><span class=\"line\">id: null</span><br></pre></td></tr></table></figure>\n\n<p>示例1在 id 字段上加了 transient 关键字修饰，反序列化出来之后值为 null，说明了被 transient 修饰的变量不能被序列化。</p>\n<h2 id=\"静态变量能被序列化吗？\"><a href=\"#静态变量能被序列化吗？\" class=\"headerlink\" title=\"静态变量能被序列化吗？\"></a>静态变量能被序列化吗？</h2><p>这个话题也是最近栈长的Java技术vip群里面讨论的，大家对这个知识点比较模糊，我就写了这篇文章测试总结一下。</p>\n<p><img src=\"http://img.javastack.cn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190214162351.png\"></p>\n<blockquote>\n<p>如果你也想加入我们的Java技术vip群和各位大牛一起讨论技术，那点击<a href=\"https://mp.weixin.qq.com/s/iqCLAduVzDqt19L6D4FCUQ\">这个链接</a>了解加入吧。</p>\n</blockquote>\n<p>那么，到底静态变量能被序列化吗？废话少说，先动手测试下吧！</p>\n<p>示例2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.FileInputStream;</span><br><span class=\"line\">import java.io.FileOutputStream;</span><br><span class=\"line\">import java.io.ObjectInputStream;</span><br><span class=\"line\">import java.io.ObjectOutputStream;</span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">public class TransientStaticTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUser2 user = new User2();</span><br><span class=\"line\">\t\tUser2.username = &quot;Java技术1&quot;;</span><br><span class=\"line\">\t\tuser.setId(&quot;javastack&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;\\n序列化之前&quot;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;id: &quot; + user.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(&quot;d:/user.txt&quot;));</span><br><span class=\"line\">\t\tos.writeObject(user);</span><br><span class=\"line\">\t\tos.flush();</span><br><span class=\"line\">\t\tos.close();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t// 在反序列化出来之前，改变静态变量的值</span><br><span class=\"line\">\t\tUser2.username = &quot;Java技术2&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(&quot;d:/user.txt&quot;));</span><br><span class=\"line\">\t\tuser = (User2) is.readObject();</span><br><span class=\"line\">\t\tis.close();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;\\n序列化之后&quot;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;id: &quot; + user.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">class User2 implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static final long serialVersionUID = 1L;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static String username;</span><br><span class=\"line\">\tprivate transient String id;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getUsername() &#123;</span><br><span class=\"line\">\t\treturn username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getId() &#123;</span><br><span class=\"line\">\t\treturn id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setId(String id) &#123;</span><br><span class=\"line\">\t\tthis.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">序列化之前</span><br><span class=\"line\">username: Java技术1</span><br><span class=\"line\">id: javastack</span><br><span class=\"line\"></span><br><span class=\"line\">序列化之后</span><br><span class=\"line\">username: Java技术2</span><br><span class=\"line\">id: null</span><br></pre></td></tr></table></figure>\n\n<p>示例2把 username 改为了 public static, 并在反序列化出来之前改变了静态变量的值，结果可以看出序列化之后的值并非序列化进去时的值。</p>\n<p>由以上结果分析可知，静态变量不能被序列化，示例2读取出来的是 username 在 JVM 内存中存储的值。</p>\n<h2 id=\"transient-真不能被序列化吗？\"><a href=\"#transient-真不能被序列化吗？\" class=\"headerlink\" title=\"transient 真不能被序列化吗？\"></a>transient 真不能被序列化吗？</h2><p>继续来看示例3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.Externalizable;</span><br><span class=\"line\">import java.io.File;</span><br><span class=\"line\">import java.io.FileInputStream;</span><br><span class=\"line\">import java.io.FileOutputStream;</span><br><span class=\"line\">import java.io.IOException;</span><br><span class=\"line\">import java.io.ObjectInput;</span><br><span class=\"line\">import java.io.ObjectInputStream;</span><br><span class=\"line\">import java.io.ObjectOutput;</span><br><span class=\"line\">import java.io.ObjectOutputStream;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">public class ExternalizableTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tUser3 user = new User3();</span><br><span class=\"line\">\t\tuser.setUsername(&quot;Java技术&quot;);</span><br><span class=\"line\">\t\tuser.setId(&quot;javastack&quot;);</span><br><span class=\"line\">\t\tObjectOutput objectOutput = new ObjectOutputStream(new FileOutputStream(new File(&quot;javastack&quot;)));</span><br><span class=\"line\">\t\tobjectOutput.writeObject(user);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tObjectInput objectInput = new ObjectInputStream(new FileInputStream(new File(&quot;javastack&quot;)));</span><br><span class=\"line\">\t\tuser = (User3) objectInput.readObject();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(user.getUsername());</span><br><span class=\"line\">\t\tSystem.out.println(user.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tobjectOutput.close();</span><br><span class=\"line\">\t\tobjectInput.close();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author </span><br><span class=\"line\"> */</span><br><span class=\"line\">class User3 implements Externalizable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static final long serialVersionUID = 1L;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic User3() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate String username;</span><br><span class=\"line\">\tprivate transient String id;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getUsername() &#123;</span><br><span class=\"line\">\t\treturn username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setUsername(String username) &#123;</span><br><span class=\"line\">\t\tthis.username = username;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getId() &#123;</span><br><span class=\"line\">\t\treturn id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setId(String id) &#123;</span><br><span class=\"line\">\t\tthis.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void writeExternal(ObjectOutput objectOutput) throws IOException &#123;</span><br><span class=\"line\">\t\tobjectOutput.writeObject(id);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">\t\tid = (String) objectInput.readObject();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">null</span><br><span class=\"line\">javastack</span><br></pre></td></tr></table></figure>\n\n<p>示例3的 id 被 transient 修改了，为什么还能序列化出来？那是因为 User3 实现了接口 Externalizable，而不是 Serializable。</p>\n<p>在 Java 中有两种实现序列化的方式，Serializable 和 Externalizable，可能大部分人只知道 Serializable 而不知道 Externalizable。</p>\n<p>这两种序列化方式的区别是：实现了 Serializable 接口是自动序列化的，实现 Externalizable 则需要手动序列化，通过 writeExternal 和 readExternal 方法手动进行，这也是为什么上面的 username 为 null 的原因了。</p>\n<h2 id=\"transient-关键字总结\"><a href=\"#transient-关键字总结\" class=\"headerlink\" title=\"transient 关键字总结\"></a>transient 关键字总结</h2><p>1）transient修饰的变量不能被序列化；</p>\n<p>2）transient只作用于实现 Serializable 接口；</p>\n<p>3）transient只能用来修饰普通成员变量字段；</p>\n<p>4）不管有没有 transient 修饰，静态变量都不能被序列化；</p>\n"},{"title":"switch case 支持的 6 种数据类型！","date":"2025-10-14T06:42:34.000Z","_content":"\n**Java 中 switch case 语句用来判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。**\n\n**语法格式如下：**\n\n```\nswitch(expression){\n    case value :\n       //语句\n       break; //可选\n    case value :\n       //语句\n       break; //可选\n    //你可以有任意数量的case语句\n    default : //可选\n       //语句\n}\n```\n\n**这里的 `expression` 都支持哪些类型呢？**\n\n- 基本数据类型：byte, short, char, int\n\n- 包装数据类型：Byte, Short, Character, Integer\n\n- 枚举类型：Enum\n\n- 字符串类型：String（Jdk 7+ 开始支持）\n\n基本数据类型和字符串很简单不用说，下面举一个使用包装类型和枚举的，其实也不难，注意只能用在 switch 块里面。\n\n```\n// 使用包装类型\nInteger value = 5;\nswitch (value) {\n\tcase 3:\n\t\tSystem.out.println(\"3\");\n\t\tbreak;\n\tcase 5:\n\t\tSystem.out.println(\"5\");\n\t\tbreak;\n\tdefault:\n\t\tSystem.out.println(\"default\");\n}\n\n// 使用枚举类型\nStatus status = Status.PROCESSING;\nswitch (status) {\n\tcase OPEN:\n\t\tSystem.out.println(\"open\");\n\t\tbreak;\n\tcase PROCESSING:\n\t\tSystem.out.println(\"processing\");\n\t\tbreak;\n\tcase CLOSE:\n\t\tSystem.out.println(\"close\");\n\t\tbreak;\n\tdefault:\n\t\tSystem.out.println(\"default\");\n}\n```\n\n以下为官网的介绍文档。\n> https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html\n\n包装类不懂的看这篇文章《[深入浅出 Java 中的包装类](https://mp.weixin.qq.com/s/uoNVT9IoRQmWnmy8w22UUQ)》。\n\n**使用 switch case 语句也有以下几点需要注意。**\n\n1. case 里面必须跟 break，不然程序会一个个 case 执行下去，直到最后一个 break 的 case 或者 default 出现。\n\n2. case 条件里面只能是常量或者字面常量。\n\n3. default 语句可有可无，最多只能有一个。\n\n有问题请留言，希望本文能对你有有所帮助！\n\n","source":"_posts/基础/switch case 支持的 6 种数据类型！.md","raw":"---\ntitle: switch case 支持的 6 种数据类型！\ndate: 2025-10-14 14:42:34\ntags: 基础\n---\n\n**Java 中 switch case 语句用来判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。**\n\n**语法格式如下：**\n\n```\nswitch(expression){\n    case value :\n       //语句\n       break; //可选\n    case value :\n       //语句\n       break; //可选\n    //你可以有任意数量的case语句\n    default : //可选\n       //语句\n}\n```\n\n**这里的 `expression` 都支持哪些类型呢？**\n\n- 基本数据类型：byte, short, char, int\n\n- 包装数据类型：Byte, Short, Character, Integer\n\n- 枚举类型：Enum\n\n- 字符串类型：String（Jdk 7+ 开始支持）\n\n基本数据类型和字符串很简单不用说，下面举一个使用包装类型和枚举的，其实也不难，注意只能用在 switch 块里面。\n\n```\n// 使用包装类型\nInteger value = 5;\nswitch (value) {\n\tcase 3:\n\t\tSystem.out.println(\"3\");\n\t\tbreak;\n\tcase 5:\n\t\tSystem.out.println(\"5\");\n\t\tbreak;\n\tdefault:\n\t\tSystem.out.println(\"default\");\n}\n\n// 使用枚举类型\nStatus status = Status.PROCESSING;\nswitch (status) {\n\tcase OPEN:\n\t\tSystem.out.println(\"open\");\n\t\tbreak;\n\tcase PROCESSING:\n\t\tSystem.out.println(\"processing\");\n\t\tbreak;\n\tcase CLOSE:\n\t\tSystem.out.println(\"close\");\n\t\tbreak;\n\tdefault:\n\t\tSystem.out.println(\"default\");\n}\n```\n\n以下为官网的介绍文档。\n> https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html\n\n包装类不懂的看这篇文章《[深入浅出 Java 中的包装类](https://mp.weixin.qq.com/s/uoNVT9IoRQmWnmy8w22UUQ)》。\n\n**使用 switch case 语句也有以下几点需要注意。**\n\n1. case 里面必须跟 break，不然程序会一个个 case 执行下去，直到最后一个 break 的 case 或者 default 出现。\n\n2. case 条件里面只能是常量或者字面常量。\n\n3. default 语句可有可无，最多只能有一个。\n\n有问题请留言，希望本文能对你有有所帮助！\n\n","slug":"基础/switch case 支持的 6 种数据类型！","published":1,"updated":"2025-10-14T07:36:11.246Z","_id":"cmgq8bkix0018hod4doqf7evy","comments":1,"layout":"post","photos":[],"content":"<p><strong>Java 中 switch case 语句用来判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</strong></p>\n<p><strong>语法格式如下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(expression)&#123;</span><br><span class=\"line\">    case value :</span><br><span class=\"line\">       //语句</span><br><span class=\"line\">       break; //可选</span><br><span class=\"line\">    case value :</span><br><span class=\"line\">       //语句</span><br><span class=\"line\">       break; //可选</span><br><span class=\"line\">    //你可以有任意数量的case语句</span><br><span class=\"line\">    default : //可选</span><br><span class=\"line\">       //语句</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>这里的 <code>expression</code> 都支持哪些类型呢？</strong></p>\n<ul>\n<li><p>基本数据类型：byte, short, char, int</p>\n</li>\n<li><p>包装数据类型：Byte, Short, Character, Integer</p>\n</li>\n<li><p>枚举类型：Enum</p>\n</li>\n<li><p>字符串类型：String（Jdk 7+ 开始支持）</p>\n</li>\n</ul>\n<p>基本数据类型和字符串很简单不用说，下面举一个使用包装类型和枚举的，其实也不难，注意只能用在 switch 块里面。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用包装类型</span><br><span class=\"line\">Integer value = 5;</span><br><span class=\"line\">switch (value) &#123;</span><br><span class=\"line\">\tcase 3:</span><br><span class=\"line\">\t\tSystem.out.println(&quot;3&quot;);</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\tcase 5:</span><br><span class=\"line\">\t\tSystem.out.println(&quot;5&quot;);</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\tdefault:</span><br><span class=\"line\">\t\tSystem.out.println(&quot;default&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用枚举类型</span><br><span class=\"line\">Status status = Status.PROCESSING;</span><br><span class=\"line\">switch (status) &#123;</span><br><span class=\"line\">\tcase OPEN:</span><br><span class=\"line\">\t\tSystem.out.println(&quot;open&quot;);</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\tcase PROCESSING:</span><br><span class=\"line\">\t\tSystem.out.println(&quot;processing&quot;);</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\tcase CLOSE:</span><br><span class=\"line\">\t\tSystem.out.println(&quot;close&quot;);</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\tdefault:</span><br><span class=\"line\">\t\tSystem.out.println(&quot;default&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以下为官网的介绍文档。</p>\n<blockquote>\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html\">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html</a></p>\n</blockquote>\n<p>包装类不懂的看这篇文章《<a href=\"https://mp.weixin.qq.com/s/uoNVT9IoRQmWnmy8w22UUQ\">深入浅出 Java 中的包装类</a>》。</p>\n<p><strong>使用 switch case 语句也有以下几点需要注意。</strong></p>\n<ol>\n<li><p>case 里面必须跟 break，不然程序会一个个 case 执行下去，直到最后一个 break 的 case 或者 default 出现。</p>\n</li>\n<li><p>case 条件里面只能是常量或者字面常量。</p>\n</li>\n<li><p>default 语句可有可无，最多只能有一个。</p>\n</li>\n</ol>\n<p>有问题请留言，希望本文能对你有有所帮助！</p>\n","excerpt":"","more":"<p><strong>Java 中 switch case 语句用来判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</strong></p>\n<p><strong>语法格式如下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(expression)&#123;</span><br><span class=\"line\">    case value :</span><br><span class=\"line\">       //语句</span><br><span class=\"line\">       break; //可选</span><br><span class=\"line\">    case value :</span><br><span class=\"line\">       //语句</span><br><span class=\"line\">       break; //可选</span><br><span class=\"line\">    //你可以有任意数量的case语句</span><br><span class=\"line\">    default : //可选</span><br><span class=\"line\">       //语句</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>这里的 <code>expression</code> 都支持哪些类型呢？</strong></p>\n<ul>\n<li><p>基本数据类型：byte, short, char, int</p>\n</li>\n<li><p>包装数据类型：Byte, Short, Character, Integer</p>\n</li>\n<li><p>枚举类型：Enum</p>\n</li>\n<li><p>字符串类型：String（Jdk 7+ 开始支持）</p>\n</li>\n</ul>\n<p>基本数据类型和字符串很简单不用说，下面举一个使用包装类型和枚举的，其实也不难，注意只能用在 switch 块里面。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用包装类型</span><br><span class=\"line\">Integer value = 5;</span><br><span class=\"line\">switch (value) &#123;</span><br><span class=\"line\">\tcase 3:</span><br><span class=\"line\">\t\tSystem.out.println(&quot;3&quot;);</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\tcase 5:</span><br><span class=\"line\">\t\tSystem.out.println(&quot;5&quot;);</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\tdefault:</span><br><span class=\"line\">\t\tSystem.out.println(&quot;default&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用枚举类型</span><br><span class=\"line\">Status status = Status.PROCESSING;</span><br><span class=\"line\">switch (status) &#123;</span><br><span class=\"line\">\tcase OPEN:</span><br><span class=\"line\">\t\tSystem.out.println(&quot;open&quot;);</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\tcase PROCESSING:</span><br><span class=\"line\">\t\tSystem.out.println(&quot;processing&quot;);</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\tcase CLOSE:</span><br><span class=\"line\">\t\tSystem.out.println(&quot;close&quot;);</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">\tdefault:</span><br><span class=\"line\">\t\tSystem.out.println(&quot;default&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以下为官网的介绍文档。</p>\n<blockquote>\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html\">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html</a></p>\n</blockquote>\n<p>包装类不懂的看这篇文章《<a href=\"https://mp.weixin.qq.com/s/uoNVT9IoRQmWnmy8w22UUQ\">深入浅出 Java 中的包装类</a>》。</p>\n<p><strong>使用 switch case 语句也有以下几点需要注意。</strong></p>\n<ol>\n<li><p>case 里面必须跟 break，不然程序会一个个 case 执行下去，直到最后一个 break 的 case 或者 default 出现。</p>\n</li>\n<li><p>case 条件里面只能是常量或者字面常量。</p>\n</li>\n<li><p>default 语句可有可无，最多只能有一个。</p>\n</li>\n</ol>\n<p>有问题请留言，希望本文能对你有有所帮助！</p>\n"},{"title":"StringBuffer 和 StringBuilder 的 3 个区别","date":"2025-10-14T06:42:34.000Z","_content":"\nStringBuffer 和 StringBuilder 它们都是可变的字符串，不过它们之间的区别是 Java 初中级面试出现几率十分高的一道题。这么简单的一道题，栈长在最近的面试过程中，却经常遇到很多求职者说反，搞不清使用场景的情况。\n\n今天，栈长我带大家彻底搞懂 StringBuffer 和 StringBuilder 的几个区别和它们的应用场景，如果你是大牛，请略过，如果你是菜鸟，或者对这两个不是很清楚，可以学习一下，也可以为年底的面试加油冲刺。\n\n先看看 StringBuffer 和 StringBuilder 的类结构吧：\n\n![](http://img.javastack.cn/18-12-29/23490736.jpg)\n\n其实很简单，就是继承了一个抽象的字符串父类：`AbstractStringBuilder`。下面我们再来看看它们的三个区别。\n\n## 区别1：线程安全\n\nStringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有公开方法都是 synchronized 修饰的，而 StringBuilder 并没有 StringBuilder 修饰。\n\n**StringBuffer 代码片段：**\n\n```\n@Override\npublic synchronized StringBuffer append(String str) {\n    toStringCache = null;\n    super.append(str);\n    return this;\n}\n```\n\n## 区别2：缓冲区\n\n**StringBuffer 代码片段：**\n\n```\nprivate transient char[] toStringCache;\n\n@Override\npublic synchronized String toString() {\n    if (toStringCache == null) {\n        toStringCache = Arrays.copyOfRange(value, 0, count);\n    }\n    return new String(toStringCache, true);\n}\n```\n\n**StringBuilder 代码片段：**\n\n```\n@Override\npublic String toString() {\n    // Create a copy, don't share the array\n    return new String(value, 0, count);\n}\n```\n\n可以看出，StringBuffer 每次获取 toString 都会直接使用缓存区的 toStringCache 值来构造一个字符串。\n\n而 StringBuilder 则每次都需要复制一次字符数组，再构造一个字符串。\n\n所以，缓存冲这也是对 StringBuffer 的一个优化吧，不过 StringBuffer 的这个toString 方法仍然是同步的。\n\n## 区别3：性能\n\n既然 StringBuffer 是线程安全的，它的所有公开方法都是同步的，StringBuilder 是没有对方法加锁同步的，所以毫无疑问，StringBuilder 的性能要远大于 StringBuffer。\n\n## 总结\n\n所以，StringBuffer 适用于用在多线程操作同一个 StringBuffer 的场景，如果是单线程场合 StringBuilder 更适合。\n\n以此送给正在面试或者即将去面试的 Java 程序猿们，如果对你有帮助，也欢迎分享给身边的朋友们，让大家少走弯路。\n\n","source":"_posts/基础/StringBuffer 和 StringBuilder 的 3 个区别.md","raw":"---\ntitle: StringBuffer 和 StringBuilder 的 3 个区别\ndate: 2025-10-14 14:42:34\ntags: 基础\n---\n\nStringBuffer 和 StringBuilder 它们都是可变的字符串，不过它们之间的区别是 Java 初中级面试出现几率十分高的一道题。这么简单的一道题，栈长在最近的面试过程中，却经常遇到很多求职者说反，搞不清使用场景的情况。\n\n今天，栈长我带大家彻底搞懂 StringBuffer 和 StringBuilder 的几个区别和它们的应用场景，如果你是大牛，请略过，如果你是菜鸟，或者对这两个不是很清楚，可以学习一下，也可以为年底的面试加油冲刺。\n\n先看看 StringBuffer 和 StringBuilder 的类结构吧：\n\n![](http://img.javastack.cn/18-12-29/23490736.jpg)\n\n其实很简单，就是继承了一个抽象的字符串父类：`AbstractStringBuilder`。下面我们再来看看它们的三个区别。\n\n## 区别1：线程安全\n\nStringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有公开方法都是 synchronized 修饰的，而 StringBuilder 并没有 StringBuilder 修饰。\n\n**StringBuffer 代码片段：**\n\n```\n@Override\npublic synchronized StringBuffer append(String str) {\n    toStringCache = null;\n    super.append(str);\n    return this;\n}\n```\n\n## 区别2：缓冲区\n\n**StringBuffer 代码片段：**\n\n```\nprivate transient char[] toStringCache;\n\n@Override\npublic synchronized String toString() {\n    if (toStringCache == null) {\n        toStringCache = Arrays.copyOfRange(value, 0, count);\n    }\n    return new String(toStringCache, true);\n}\n```\n\n**StringBuilder 代码片段：**\n\n```\n@Override\npublic String toString() {\n    // Create a copy, don't share the array\n    return new String(value, 0, count);\n}\n```\n\n可以看出，StringBuffer 每次获取 toString 都会直接使用缓存区的 toStringCache 值来构造一个字符串。\n\n而 StringBuilder 则每次都需要复制一次字符数组，再构造一个字符串。\n\n所以，缓存冲这也是对 StringBuffer 的一个优化吧，不过 StringBuffer 的这个toString 方法仍然是同步的。\n\n## 区别3：性能\n\n既然 StringBuffer 是线程安全的，它的所有公开方法都是同步的，StringBuilder 是没有对方法加锁同步的，所以毫无疑问，StringBuilder 的性能要远大于 StringBuffer。\n\n## 总结\n\n所以，StringBuffer 适用于用在多线程操作同一个 StringBuffer 的场景，如果是单线程场合 StringBuilder 更适合。\n\n以此送给正在面试或者即将去面试的 Java 程序猿们，如果对你有帮助，也欢迎分享给身边的朋友们，让大家少走弯路。\n\n","slug":"基础/StringBuffer 和 StringBuilder 的 3 个区别","published":1,"updated":"2025-10-14T07:36:11.238Z","_id":"cmgq8bkjf0019hod48yy124un","comments":1,"layout":"post","photos":[],"content":"<p>StringBuffer 和 StringBuilder 它们都是可变的字符串，不过它们之间的区别是 Java 初中级面试出现几率十分高的一道题。这么简单的一道题，栈长在最近的面试过程中，却经常遇到很多求职者说反，搞不清使用场景的情况。</p>\n<p>今天，栈长我带大家彻底搞懂 StringBuffer 和 StringBuilder 的几个区别和它们的应用场景，如果你是大牛，请略过，如果你是菜鸟，或者对这两个不是很清楚，可以学习一下，也可以为年底的面试加油冲刺。</p>\n<p>先看看 StringBuffer 和 StringBuilder 的类结构吧：</p>\n<p><img src=\"http://img.javastack.cn/18-12-29/23490736.jpg\"></p>\n<p>其实很简单，就是继承了一个抽象的字符串父类：<code>AbstractStringBuilder</code>。下面我们再来看看它们的三个区别。</p>\n<h2 id=\"区别1：线程安全\"><a href=\"#区别1：线程安全\" class=\"headerlink\" title=\"区别1：线程安全\"></a>区别1：线程安全</h2><p>StringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有公开方法都是 synchronized 修饰的，而 StringBuilder 并没有 StringBuilder 修饰。</p>\n<p><strong>StringBuffer 代码片段：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public synchronized StringBuffer append(String str) &#123;</span><br><span class=\"line\">    toStringCache = null;</span><br><span class=\"line\">    super.append(str);</span><br><span class=\"line\">    return this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"区别2：缓冲区\"><a href=\"#区别2：缓冲区\" class=\"headerlink\" title=\"区别2：缓冲区\"></a>区别2：缓冲区</h2><p><strong>StringBuffer 代码片段：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private transient char[] toStringCache;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">public synchronized String toString() &#123;</span><br><span class=\"line\">    if (toStringCache == null) &#123;</span><br><span class=\"line\">        toStringCache = Arrays.copyOfRange(value, 0, count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return new String(toStringCache, true);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>StringBuilder 代码片段：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public String toString() &#123;</span><br><span class=\"line\">    // Create a copy, don&#x27;t share the array</span><br><span class=\"line\">    return new String(value, 0, count);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，StringBuffer 每次获取 toString 都会直接使用缓存区的 toStringCache 值来构造一个字符串。</p>\n<p>而 StringBuilder 则每次都需要复制一次字符数组，再构造一个字符串。</p>\n<p>所以，缓存冲这也是对 StringBuffer 的一个优化吧，不过 StringBuffer 的这个toString 方法仍然是同步的。</p>\n<h2 id=\"区别3：性能\"><a href=\"#区别3：性能\" class=\"headerlink\" title=\"区别3：性能\"></a>区别3：性能</h2><p>既然 StringBuffer 是线程安全的，它的所有公开方法都是同步的，StringBuilder 是没有对方法加锁同步的，所以毫无疑问，StringBuilder 的性能要远大于 StringBuffer。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>所以，StringBuffer 适用于用在多线程操作同一个 StringBuffer 的场景，如果是单线程场合 StringBuilder 更适合。</p>\n<p>以此送给正在面试或者即将去面试的 Java 程序猿们，如果对你有帮助，也欢迎分享给身边的朋友们，让大家少走弯路。</p>\n","excerpt":"","more":"<p>StringBuffer 和 StringBuilder 它们都是可变的字符串，不过它们之间的区别是 Java 初中级面试出现几率十分高的一道题。这么简单的一道题，栈长在最近的面试过程中，却经常遇到很多求职者说反，搞不清使用场景的情况。</p>\n<p>今天，栈长我带大家彻底搞懂 StringBuffer 和 StringBuilder 的几个区别和它们的应用场景，如果你是大牛，请略过，如果你是菜鸟，或者对这两个不是很清楚，可以学习一下，也可以为年底的面试加油冲刺。</p>\n<p>先看看 StringBuffer 和 StringBuilder 的类结构吧：</p>\n<p><img src=\"http://img.javastack.cn/18-12-29/23490736.jpg\"></p>\n<p>其实很简单，就是继承了一个抽象的字符串父类：<code>AbstractStringBuilder</code>。下面我们再来看看它们的三个区别。</p>\n<h2 id=\"区别1：线程安全\"><a href=\"#区别1：线程安全\" class=\"headerlink\" title=\"区别1：线程安全\"></a>区别1：线程安全</h2><p>StringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有公开方法都是 synchronized 修饰的，而 StringBuilder 并没有 StringBuilder 修饰。</p>\n<p><strong>StringBuffer 代码片段：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public synchronized StringBuffer append(String str) &#123;</span><br><span class=\"line\">    toStringCache = null;</span><br><span class=\"line\">    super.append(str);</span><br><span class=\"line\">    return this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"区别2：缓冲区\"><a href=\"#区别2：缓冲区\" class=\"headerlink\" title=\"区别2：缓冲区\"></a>区别2：缓冲区</h2><p><strong>StringBuffer 代码片段：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private transient char[] toStringCache;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">public synchronized String toString() &#123;</span><br><span class=\"line\">    if (toStringCache == null) &#123;</span><br><span class=\"line\">        toStringCache = Arrays.copyOfRange(value, 0, count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return new String(toStringCache, true);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>StringBuilder 代码片段：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public String toString() &#123;</span><br><span class=\"line\">    // Create a copy, don&#x27;t share the array</span><br><span class=\"line\">    return new String(value, 0, count);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，StringBuffer 每次获取 toString 都会直接使用缓存区的 toStringCache 值来构造一个字符串。</p>\n<p>而 StringBuilder 则每次都需要复制一次字符数组，再构造一个字符串。</p>\n<p>所以，缓存冲这也是对 StringBuffer 的一个优化吧，不过 StringBuffer 的这个toString 方法仍然是同步的。</p>\n<h2 id=\"区别3：性能\"><a href=\"#区别3：性能\" class=\"headerlink\" title=\"区别3：性能\"></a>区别3：性能</h2><p>既然 StringBuffer 是线程安全的，它的所有公开方法都是同步的，StringBuilder 是没有对方法加锁同步的，所以毫无疑问，StringBuilder 的性能要远大于 StringBuffer。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>所以，StringBuffer 适用于用在多线程操作同一个 StringBuffer 的场景，如果是单线程场合 StringBuilder 更适合。</p>\n<p>以此送给正在面试或者即将去面试的 Java 程序猿们，如果对你有帮助，也欢迎分享给身边的朋友们，让大家少走弯路。</p>\n"},{"title":"10 个深恶痛绝的 Java 异常","date":"2025-10-14T06:42:34.000Z","_content":"\n异常是 Java 程序中经常遇到的问题，我想每一个 Java 程序员都讨厌异常，一 个异常就是一个 BUG，就要花很多时间来定位异常问题。\n\n> 什么是异常及异常的分类请看这篇文章：[一张图搞清楚 Java 异常机制](https://mp.weixin.qq.com/s/xbopgxZ5BEDdSvwO9ad9Xg)。\n\n今天，栈长来列一下 Java 中经常遇到的前 10 个异常，排名不分先后。\n\n## 1、NullPointerException\n\n空指针异常，操作一个 null 对象的方法或属性时会抛出这个异常。具体看这篇文章：[Java 避免空指针的 5 个案例](https://mp.weixin.qq.com/s/cmkKuhEZl1qx6TXPxvA5pw)。\n\n## 2、OutOfMemoryError\n\n内存异常异常，这不是程序能控制的，是指要分配的对象的内存超出了当前最大的堆内存，需要调整堆内存大小（-Xmx）以及优化程序。\n\n## 3、IOException\n\nIO，即：input, output，我们在读写磁盘文件、网络内容的时候经常会生的一种异常，这种异常是受检查异常，需要进行手工捕获。\n\n如文件读写会抛出 IOException：\n\n```\npublic int read() throws IOException\npublic void write(int b) throws IOException\n```\n\n## 4、FileNotFoundException\n\n文件找不到异常，如果文件不存在就会抛出这种异常。\n\n如定义输入输出文件流，文件不存在会报错：\n\n```\npublic FileInputStream(File file) throws FileNotFoundException\npublic FileOutputStream(File file) throws FileNotFoundException\n```\n\nFileNotFoundException 其实是 IOException 的子类，同样是受检查异常，需要进行手工捕获。\n\n## 5、ClassNotFoundException\n\n类找不到异常，Java开发中经常遇到，是不是很绝望？这是在加载类的时候抛出来的，即在类路径下不能加载指定的类。\n\n看一个示例：\n\n```\npublic static <T> Class<T> getExistingClass(ClassLoader classLoader, String className) {\n  try {\n     return (Class<T>) Class.forName(className, true, classLoader);\n  }\n  catch (ClassNotFoundException e) {\n     return null;\n  }\n}\n```\n\n它是受检查异常，需要进行手工捕获。\n\n## 6、ClassCastException\n\n类转换异常，将一个不是该类的实例转换成这个类就会抛出这个异常。\n\n如将一个数字强制转换成字符串就会报这个异常：\n\n```\nObject x = new Integer(0);\nSystem.out.println((String)x);\n```\n\n这是运行时异常，不需要手工捕获。\n\n## 7、NoSuchMethodException\n\n没有这个方法异常，一般发生在反射调用方法的时候，如：\n\n```\npublic Method getMethod(String name, Class<?>... parameterTypes)\n    throws NoSuchMethodException, SecurityException {\n    checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);\n    Method method = getMethod0(name, parameterTypes, true);\n    if (method == null) {\n        throw new NoSuchMethodException(getName() + \".\" + name + argumentTypesToString(parameterTypes));\n    }\n    return method;\n}\n```\n\n它是受检查异常，需要进行手工捕获。\n\n## 8、IndexOutOfBoundsException\n\n索引越界异常，当操作一个字符串或者数组的时候经常遇到的异常。\n\n![](http://qianniu.javastack.cn/18-12-12/80818264.jpg)\n\n如图所示，它是运行时异常，不需要手工捕获。\n\n## 9、ArithmeticException\n\n算术异常，发生在数字的算术运算时的异常，如一个数字除以 0 就会报这个错。\n\n```\ndouble n = 3 / 0;\n```\n\n这个异常虽然是运行时异常，可以手工捕获抛出自定义的异常，如：\n\n```\npublic static Timestamp from(Instant instant) {\n    try {\n        Timestamp stamp = new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);\n        stamp.nanos = instant.getNano();\n        return stamp;\n    } catch (ArithmeticException ex) {\n        throw new IllegalArgumentException(ex);\n    }\n}\n```\n\n## 10、SQLException\n\nSQL异常，发生在操作数据库时的异常。\n\n如下面的获取连接：\n\n```\npublic Connection getConnection() throws SQLException {\n    if (getUser() == null) {\n        return DriverManager.getConnection(url);\n    } else {\n        return DriverManager.getConnection(url, getUser(), getPassword());\n    }\n}\n```\n\n又或者是获取下一条记录的时候：\n\n```\nboolean next() throws SQLException;\n```\n\n它是受检查异常，需要进行手工捕获。\n\n栈长这里只列举了 10 个 Java 中最常见的基本异常，另外，栈长已经整理了 Java 系列核心知识点文章，关注Java技术微信公众号，在后台回复关键字：java，即可获取。\n\n话说你遇到的最多的是哪个呢？欢迎留言分享。\n\n> 本文原创首发于（id:javastack），关注公众号在后台回复 \"java\" 可获取更多，转载请原样保留本信息。\n","source":"_posts/基础/10 个深恶痛绝的 Java 异常.md","raw":"---\ntitle: 10 个深恶痛绝的 Java 异常\ndate: 2025-10-14 14:42:34\ntags: 基础\n---\n\n异常是 Java 程序中经常遇到的问题，我想每一个 Java 程序员都讨厌异常，一 个异常就是一个 BUG，就要花很多时间来定位异常问题。\n\n> 什么是异常及异常的分类请看这篇文章：[一张图搞清楚 Java 异常机制](https://mp.weixin.qq.com/s/xbopgxZ5BEDdSvwO9ad9Xg)。\n\n今天，栈长来列一下 Java 中经常遇到的前 10 个异常，排名不分先后。\n\n## 1、NullPointerException\n\n空指针异常，操作一个 null 对象的方法或属性时会抛出这个异常。具体看这篇文章：[Java 避免空指针的 5 个案例](https://mp.weixin.qq.com/s/cmkKuhEZl1qx6TXPxvA5pw)。\n\n## 2、OutOfMemoryError\n\n内存异常异常，这不是程序能控制的，是指要分配的对象的内存超出了当前最大的堆内存，需要调整堆内存大小（-Xmx）以及优化程序。\n\n## 3、IOException\n\nIO，即：input, output，我们在读写磁盘文件、网络内容的时候经常会生的一种异常，这种异常是受检查异常，需要进行手工捕获。\n\n如文件读写会抛出 IOException：\n\n```\npublic int read() throws IOException\npublic void write(int b) throws IOException\n```\n\n## 4、FileNotFoundException\n\n文件找不到异常，如果文件不存在就会抛出这种异常。\n\n如定义输入输出文件流，文件不存在会报错：\n\n```\npublic FileInputStream(File file) throws FileNotFoundException\npublic FileOutputStream(File file) throws FileNotFoundException\n```\n\nFileNotFoundException 其实是 IOException 的子类，同样是受检查异常，需要进行手工捕获。\n\n## 5、ClassNotFoundException\n\n类找不到异常，Java开发中经常遇到，是不是很绝望？这是在加载类的时候抛出来的，即在类路径下不能加载指定的类。\n\n看一个示例：\n\n```\npublic static <T> Class<T> getExistingClass(ClassLoader classLoader, String className) {\n  try {\n     return (Class<T>) Class.forName(className, true, classLoader);\n  }\n  catch (ClassNotFoundException e) {\n     return null;\n  }\n}\n```\n\n它是受检查异常，需要进行手工捕获。\n\n## 6、ClassCastException\n\n类转换异常，将一个不是该类的实例转换成这个类就会抛出这个异常。\n\n如将一个数字强制转换成字符串就会报这个异常：\n\n```\nObject x = new Integer(0);\nSystem.out.println((String)x);\n```\n\n这是运行时异常，不需要手工捕获。\n\n## 7、NoSuchMethodException\n\n没有这个方法异常，一般发生在反射调用方法的时候，如：\n\n```\npublic Method getMethod(String name, Class<?>... parameterTypes)\n    throws NoSuchMethodException, SecurityException {\n    checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);\n    Method method = getMethod0(name, parameterTypes, true);\n    if (method == null) {\n        throw new NoSuchMethodException(getName() + \".\" + name + argumentTypesToString(parameterTypes));\n    }\n    return method;\n}\n```\n\n它是受检查异常，需要进行手工捕获。\n\n## 8、IndexOutOfBoundsException\n\n索引越界异常，当操作一个字符串或者数组的时候经常遇到的异常。\n\n![](http://qianniu.javastack.cn/18-12-12/80818264.jpg)\n\n如图所示，它是运行时异常，不需要手工捕获。\n\n## 9、ArithmeticException\n\n算术异常，发生在数字的算术运算时的异常，如一个数字除以 0 就会报这个错。\n\n```\ndouble n = 3 / 0;\n```\n\n这个异常虽然是运行时异常，可以手工捕获抛出自定义的异常，如：\n\n```\npublic static Timestamp from(Instant instant) {\n    try {\n        Timestamp stamp = new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);\n        stamp.nanos = instant.getNano();\n        return stamp;\n    } catch (ArithmeticException ex) {\n        throw new IllegalArgumentException(ex);\n    }\n}\n```\n\n## 10、SQLException\n\nSQL异常，发生在操作数据库时的异常。\n\n如下面的获取连接：\n\n```\npublic Connection getConnection() throws SQLException {\n    if (getUser() == null) {\n        return DriverManager.getConnection(url);\n    } else {\n        return DriverManager.getConnection(url, getUser(), getPassword());\n    }\n}\n```\n\n又或者是获取下一条记录的时候：\n\n```\nboolean next() throws SQLException;\n```\n\n它是受检查异常，需要进行手工捕获。\n\n栈长这里只列举了 10 个 Java 中最常见的基本异常，另外，栈长已经整理了 Java 系列核心知识点文章，关注Java技术微信公众号，在后台回复关键字：java，即可获取。\n\n话说你遇到的最多的是哪个呢？欢迎留言分享。\n\n> 本文原创首发于（id:javastack），关注公众号在后台回复 \"java\" 可获取更多，转载请原样保留本信息。\n","slug":"基础/10 个深恶痛绝的 Java 异常","published":1,"updated":"2025-10-14T07:18:01.143Z","_id":"cmgq8cqtn001ahod48ylf4l9p","comments":1,"layout":"post","photos":[],"content":"<p>异常是 Java 程序中经常遇到的问题，我想每一个 Java 程序员都讨厌异常，一 个异常就是一个 BUG，就要花很多时间来定位异常问题。</p>\n<blockquote>\n<p>什么是异常及异常的分类请看这篇文章：<a href=\"https://mp.weixin.qq.com/s/xbopgxZ5BEDdSvwO9ad9Xg\">一张图搞清楚 Java 异常机制</a>。</p>\n</blockquote>\n<p>今天，栈长来列一下 Java 中经常遇到的前 10 个异常，排名不分先后。</p>\n<h2 id=\"1、NullPointerException\"><a href=\"#1、NullPointerException\" class=\"headerlink\" title=\"1、NullPointerException\"></a>1、NullPointerException</h2><p>空指针异常，操作一个 null 对象的方法或属性时会抛出这个异常。具体看这篇文章：<a href=\"https://mp.weixin.qq.com/s/cmkKuhEZl1qx6TXPxvA5pw\">Java 避免空指针的 5 个案例</a>。</p>\n<h2 id=\"2、OutOfMemoryError\"><a href=\"#2、OutOfMemoryError\" class=\"headerlink\" title=\"2、OutOfMemoryError\"></a>2、OutOfMemoryError</h2><p>内存异常异常，这不是程序能控制的，是指要分配的对象的内存超出了当前最大的堆内存，需要调整堆内存大小（-Xmx）以及优化程序。</p>\n<h2 id=\"3、IOException\"><a href=\"#3、IOException\" class=\"headerlink\" title=\"3、IOException\"></a>3、IOException</h2><p>IO，即：input, output，我们在读写磁盘文件、网络内容的时候经常会生的一种异常，这种异常是受检查异常，需要进行手工捕获。</p>\n<p>如文件读写会抛出 IOException：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int read() throws IOException</span><br><span class=\"line\">public void write(int b) throws IOException</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4、FileNotFoundException\"><a href=\"#4、FileNotFoundException\" class=\"headerlink\" title=\"4、FileNotFoundException\"></a>4、FileNotFoundException</h2><p>文件找不到异常，如果文件不存在就会抛出这种异常。</p>\n<p>如定义输入输出文件流，文件不存在会报错：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public FileInputStream(File file) throws FileNotFoundException</span><br><span class=\"line\">public FileOutputStream(File file) throws FileNotFoundException</span><br></pre></td></tr></table></figure>\n\n<p>FileNotFoundException 其实是 IOException 的子类，同样是受检查异常，需要进行手工捕获。</p>\n<h2 id=\"5、ClassNotFoundException\"><a href=\"#5、ClassNotFoundException\" class=\"headerlink\" title=\"5、ClassNotFoundException\"></a>5、ClassNotFoundException</h2><p>类找不到异常，Java开发中经常遇到，是不是很绝望？这是在加载类的时候抛出来的，即在类路径下不能加载指定的类。</p>\n<p>看一个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static &lt;T&gt; Class&lt;T&gt; getExistingClass(ClassLoader classLoader, String className) &#123;</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">     return (Class&lt;T&gt;) Class.forName(className, true, classLoader);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">     return null;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它是受检查异常，需要进行手工捕获。</p>\n<h2 id=\"6、ClassCastException\"><a href=\"#6、ClassCastException\" class=\"headerlink\" title=\"6、ClassCastException\"></a>6、ClassCastException</h2><p>类转换异常，将一个不是该类的实例转换成这个类就会抛出这个异常。</p>\n<p>如将一个数字强制转换成字符串就会报这个异常：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object x = new Integer(0);</span><br><span class=\"line\">System.out.println((String)x);</span><br></pre></td></tr></table></figure>\n\n<p>这是运行时异常，不需要手工捕获。</p>\n<h2 id=\"7、NoSuchMethodException\"><a href=\"#7、NoSuchMethodException\" class=\"headerlink\" title=\"7、NoSuchMethodException\"></a>7、NoSuchMethodException</h2><p>没有这个方法异常，一般发生在反射调用方法的时候，如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</span><br><span class=\"line\">    throws NoSuchMethodException, SecurityException &#123;</span><br><span class=\"line\">    checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);</span><br><span class=\"line\">    Method method = getMethod0(name, parameterTypes, true);</span><br><span class=\"line\">    if (method == null) &#123;</span><br><span class=\"line\">        throw new NoSuchMethodException(getName() + &quot;.&quot; + name + argumentTypesToString(parameterTypes));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return method;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它是受检查异常，需要进行手工捕获。</p>\n<h2 id=\"8、IndexOutOfBoundsException\"><a href=\"#8、IndexOutOfBoundsException\" class=\"headerlink\" title=\"8、IndexOutOfBoundsException\"></a>8、IndexOutOfBoundsException</h2><p>索引越界异常，当操作一个字符串或者数组的时候经常遇到的异常。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-12-12/80818264.jpg\"></p>\n<p>如图所示，它是运行时异常，不需要手工捕获。</p>\n<h2 id=\"9、ArithmeticException\"><a href=\"#9、ArithmeticException\" class=\"headerlink\" title=\"9、ArithmeticException\"></a>9、ArithmeticException</h2><p>算术异常，发生在数字的算术运算时的异常，如一个数字除以 0 就会报这个错。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double n = 3 / 0;</span><br></pre></td></tr></table></figure>\n\n<p>这个异常虽然是运行时异常，可以手工捕获抛出自定义的异常，如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Timestamp from(Instant instant) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        Timestamp stamp = new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);</span><br><span class=\"line\">        stamp.nanos = instant.getNano();</span><br><span class=\"line\">        return stamp;</span><br><span class=\"line\">    &#125; catch (ArithmeticException ex) &#123;</span><br><span class=\"line\">        throw new IllegalArgumentException(ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10、SQLException\"><a href=\"#10、SQLException\" class=\"headerlink\" title=\"10、SQLException\"></a>10、SQLException</h2><p>SQL异常，发生在操作数据库时的异常。</p>\n<p>如下面的获取连接：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Connection getConnection() throws SQLException &#123;</span><br><span class=\"line\">    if (getUser() == null) &#123;</span><br><span class=\"line\">        return DriverManager.getConnection(url);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return DriverManager.getConnection(url, getUser(), getPassword());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>又或者是获取下一条记录的时候：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">boolean next() throws SQLException;</span><br></pre></td></tr></table></figure>\n\n<p>它是受检查异常，需要进行手工捕获。</p>\n<p>栈长这里只列举了 10 个 Java 中最常见的基本异常，另外，栈长已经整理了 Java 系列核心知识点文章，关注Java技术微信公众号，在后台回复关键字：java，即可获取。</p>\n<p>话说你遇到的最多的是哪个呢？欢迎留言分享。</p>\n<blockquote>\n<p>本文原创首发于（id:javastack），关注公众号在后台回复 “java” 可获取更多，转载请原样保留本信息。</p>\n</blockquote>\n","excerpt":"","more":"<p>异常是 Java 程序中经常遇到的问题，我想每一个 Java 程序员都讨厌异常，一 个异常就是一个 BUG，就要花很多时间来定位异常问题。</p>\n<blockquote>\n<p>什么是异常及异常的分类请看这篇文章：<a href=\"https://mp.weixin.qq.com/s/xbopgxZ5BEDdSvwO9ad9Xg\">一张图搞清楚 Java 异常机制</a>。</p>\n</blockquote>\n<p>今天，栈长来列一下 Java 中经常遇到的前 10 个异常，排名不分先后。</p>\n<h2 id=\"1、NullPointerException\"><a href=\"#1、NullPointerException\" class=\"headerlink\" title=\"1、NullPointerException\"></a>1、NullPointerException</h2><p>空指针异常，操作一个 null 对象的方法或属性时会抛出这个异常。具体看这篇文章：<a href=\"https://mp.weixin.qq.com/s/cmkKuhEZl1qx6TXPxvA5pw\">Java 避免空指针的 5 个案例</a>。</p>\n<h2 id=\"2、OutOfMemoryError\"><a href=\"#2、OutOfMemoryError\" class=\"headerlink\" title=\"2、OutOfMemoryError\"></a>2、OutOfMemoryError</h2><p>内存异常异常，这不是程序能控制的，是指要分配的对象的内存超出了当前最大的堆内存，需要调整堆内存大小（-Xmx）以及优化程序。</p>\n<h2 id=\"3、IOException\"><a href=\"#3、IOException\" class=\"headerlink\" title=\"3、IOException\"></a>3、IOException</h2><p>IO，即：input, output，我们在读写磁盘文件、网络内容的时候经常会生的一种异常，这种异常是受检查异常，需要进行手工捕获。</p>\n<p>如文件读写会抛出 IOException：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int read() throws IOException</span><br><span class=\"line\">public void write(int b) throws IOException</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4、FileNotFoundException\"><a href=\"#4、FileNotFoundException\" class=\"headerlink\" title=\"4、FileNotFoundException\"></a>4、FileNotFoundException</h2><p>文件找不到异常，如果文件不存在就会抛出这种异常。</p>\n<p>如定义输入输出文件流，文件不存在会报错：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public FileInputStream(File file) throws FileNotFoundException</span><br><span class=\"line\">public FileOutputStream(File file) throws FileNotFoundException</span><br></pre></td></tr></table></figure>\n\n<p>FileNotFoundException 其实是 IOException 的子类，同样是受检查异常，需要进行手工捕获。</p>\n<h2 id=\"5、ClassNotFoundException\"><a href=\"#5、ClassNotFoundException\" class=\"headerlink\" title=\"5、ClassNotFoundException\"></a>5、ClassNotFoundException</h2><p>类找不到异常，Java开发中经常遇到，是不是很绝望？这是在加载类的时候抛出来的，即在类路径下不能加载指定的类。</p>\n<p>看一个示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static &lt;T&gt; Class&lt;T&gt; getExistingClass(ClassLoader classLoader, String className) &#123;</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">     return (Class&lt;T&gt;) Class.forName(className, true, classLoader);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">     return null;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它是受检查异常，需要进行手工捕获。</p>\n<h2 id=\"6、ClassCastException\"><a href=\"#6、ClassCastException\" class=\"headerlink\" title=\"6、ClassCastException\"></a>6、ClassCastException</h2><p>类转换异常，将一个不是该类的实例转换成这个类就会抛出这个异常。</p>\n<p>如将一个数字强制转换成字符串就会报这个异常：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object x = new Integer(0);</span><br><span class=\"line\">System.out.println((String)x);</span><br></pre></td></tr></table></figure>\n\n<p>这是运行时异常，不需要手工捕获。</p>\n<h2 id=\"7、NoSuchMethodException\"><a href=\"#7、NoSuchMethodException\" class=\"headerlink\" title=\"7、NoSuchMethodException\"></a>7、NoSuchMethodException</h2><p>没有这个方法异常，一般发生在反射调用方法的时候，如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</span><br><span class=\"line\">    throws NoSuchMethodException, SecurityException &#123;</span><br><span class=\"line\">    checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);</span><br><span class=\"line\">    Method method = getMethod0(name, parameterTypes, true);</span><br><span class=\"line\">    if (method == null) &#123;</span><br><span class=\"line\">        throw new NoSuchMethodException(getName() + &quot;.&quot; + name + argumentTypesToString(parameterTypes));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return method;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它是受检查异常，需要进行手工捕获。</p>\n<h2 id=\"8、IndexOutOfBoundsException\"><a href=\"#8、IndexOutOfBoundsException\" class=\"headerlink\" title=\"8、IndexOutOfBoundsException\"></a>8、IndexOutOfBoundsException</h2><p>索引越界异常，当操作一个字符串或者数组的时候经常遇到的异常。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-12-12/80818264.jpg\"></p>\n<p>如图所示，它是运行时异常，不需要手工捕获。</p>\n<h2 id=\"9、ArithmeticException\"><a href=\"#9、ArithmeticException\" class=\"headerlink\" title=\"9、ArithmeticException\"></a>9、ArithmeticException</h2><p>算术异常，发生在数字的算术运算时的异常，如一个数字除以 0 就会报这个错。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double n = 3 / 0;</span><br></pre></td></tr></table></figure>\n\n<p>这个异常虽然是运行时异常，可以手工捕获抛出自定义的异常，如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Timestamp from(Instant instant) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        Timestamp stamp = new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);</span><br><span class=\"line\">        stamp.nanos = instant.getNano();</span><br><span class=\"line\">        return stamp;</span><br><span class=\"line\">    &#125; catch (ArithmeticException ex) &#123;</span><br><span class=\"line\">        throw new IllegalArgumentException(ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10、SQLException\"><a href=\"#10、SQLException\" class=\"headerlink\" title=\"10、SQLException\"></a>10、SQLException</h2><p>SQL异常，发生在操作数据库时的异常。</p>\n<p>如下面的获取连接：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Connection getConnection() throws SQLException &#123;</span><br><span class=\"line\">    if (getUser() == null) &#123;</span><br><span class=\"line\">        return DriverManager.getConnection(url);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return DriverManager.getConnection(url, getUser(), getPassword());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>又或者是获取下一条记录的时候：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">boolean next() throws SQLException;</span><br></pre></td></tr></table></figure>\n\n<p>它是受检查异常，需要进行手工捕获。</p>\n<p>栈长这里只列举了 10 个 Java 中最常见的基本异常，另外，栈长已经整理了 Java 系列核心知识点文章，关注Java技术微信公众号，在后台回复关键字：java，即可获取。</p>\n<p>话说你遇到的最多的是哪个呢？欢迎留言分享。</p>\n<blockquote>\n<p>本文原创首发于（id:javastack），关注公众号在后台回复 “java” 可获取更多，转载请原样保留本信息。</p>\n</blockquote>\n"},{"title":"Java Jar包压缩、解压使用指南","date":"2025-10-14T06:42:34.000Z","_content":"\n![](http://img.javastack.cn/18-2-27/79692618.jpg)\n\n#### 什么是jar包\n\nJAR（Java Archive）是Java的归档文件，它是一种与平台无关的文件格式，它允许将许多文件组合成一个压缩文件。\n\n#### 如何打/解包\n\n使用jdk/bin/jar.exe工具，配置完环境变量后直接使得jar命令即可。\n\n#### jar命令格式\n\njar {c t x u f }[ v m e 0 M i ][-C 目录]文件名...\n \n{ctxu}，这四个参数必须选选其一。\n\n[v f m e 0 M i]，这几个是可选参数，文件名也是必须的。\n\n参数 | 说明\n---|---\n-c | 创建一个jar包\n-t | 显示jar中的内容列表\n-x | 解压jar包\n-u | 添加文件到jar包中\n-f | 指定jar包的文件名\n-v | 输出详细报告\n-m | 指定MANIFEST.MF文件\n-0 | 生成jar包时不压缩内容\n-M | 不生成清单文件MANIFEST.MF\n-i | 为指定的jar文件创建索引文件\n-C | 可在相应的目录下执行命令\n\n关于MANIFEST.MF定义：\n> https://baike.baidu.com/item/MANIFEST.MF\n\n#### 演示\n\n**往jar包添加文件**\n\n> jar uf xxx.jar BOOT-INF/classes/application.yml\n\n**解压jar包**\n\n> jar -xvf xxx.jar\n\n**打jar包，不生成清单文件，不压缩**\n\n> jar -cvfM0 xxx.jar BOOT-INF/ META-INF/ org/\n\n或者\n\n> jar -cvfM0 xxx.jar *\n\n如果要往线上jar包添加、更新部分文件到jar包，这些命令也许对你有用。\n","source":"_posts/基础/Java Jar包压缩、解压使用指南.md","raw":"---\ntitle: Java Jar包压缩、解压使用指南\ndate: 2025-10-14 14:42:34\ntags: 基础\n---\n\n![](http://img.javastack.cn/18-2-27/79692618.jpg)\n\n#### 什么是jar包\n\nJAR（Java Archive）是Java的归档文件，它是一种与平台无关的文件格式，它允许将许多文件组合成一个压缩文件。\n\n#### 如何打/解包\n\n使用jdk/bin/jar.exe工具，配置完环境变量后直接使得jar命令即可。\n\n#### jar命令格式\n\njar {c t x u f }[ v m e 0 M i ][-C 目录]文件名...\n \n{ctxu}，这四个参数必须选选其一。\n\n[v f m e 0 M i]，这几个是可选参数，文件名也是必须的。\n\n参数 | 说明\n---|---\n-c | 创建一个jar包\n-t | 显示jar中的内容列表\n-x | 解压jar包\n-u | 添加文件到jar包中\n-f | 指定jar包的文件名\n-v | 输出详细报告\n-m | 指定MANIFEST.MF文件\n-0 | 生成jar包时不压缩内容\n-M | 不生成清单文件MANIFEST.MF\n-i | 为指定的jar文件创建索引文件\n-C | 可在相应的目录下执行命令\n\n关于MANIFEST.MF定义：\n> https://baike.baidu.com/item/MANIFEST.MF\n\n#### 演示\n\n**往jar包添加文件**\n\n> jar uf xxx.jar BOOT-INF/classes/application.yml\n\n**解压jar包**\n\n> jar -xvf xxx.jar\n\n**打jar包，不生成清单文件，不压缩**\n\n> jar -cvfM0 xxx.jar BOOT-INF/ META-INF/ org/\n\n或者\n\n> jar -cvfM0 xxx.jar *\n\n如果要往线上jar包添加、更新部分文件到jar包，这些命令也许对你有用。\n","slug":"基础/Java Jar包压缩、解压使用指南","published":1,"updated":"2025-10-14T07:22:48.380Z","_id":"cmgq8ixsr0000x4d4g5dmh704","comments":1,"layout":"post","photos":[],"content":"<p><img src=\"http://img.javastack.cn/18-2-27/79692618.jpg\"></p>\n<h4 id=\"什么是jar包\"><a href=\"#什么是jar包\" class=\"headerlink\" title=\"什么是jar包\"></a>什么是jar包</h4><p>JAR（Java Archive）是Java的归档文件，它是一种与平台无关的文件格式，它允许将许多文件组合成一个压缩文件。</p>\n<h4 id=\"如何打-解包\"><a href=\"#如何打-解包\" class=\"headerlink\" title=\"如何打&#x2F;解包\"></a>如何打&#x2F;解包</h4><p>使用jdk&#x2F;bin&#x2F;jar.exe工具，配置完环境变量后直接使得jar命令即可。</p>\n<h4 id=\"jar命令格式\"><a href=\"#jar命令格式\" class=\"headerlink\" title=\"jar命令格式\"></a>jar命令格式</h4><p>jar {c t x u f }[ v m e 0 M i ][-C 目录]文件名…</p>\n<p>{ctxu}，这四个参数必须选选其一。</p>\n<p>[v f m e 0 M i]，这几个是可选参数，文件名也是必须的。</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-c</td>\n<td>创建一个jar包</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>显示jar中的内容列表</td>\n</tr>\n<tr>\n<td>-x</td>\n<td>解压jar包</td>\n</tr>\n<tr>\n<td>-u</td>\n<td>添加文件到jar包中</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>指定jar包的文件名</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>输出详细报告</td>\n</tr>\n<tr>\n<td>-m</td>\n<td>指定MANIFEST.MF文件</td>\n</tr>\n<tr>\n<td>-0</td>\n<td>生成jar包时不压缩内容</td>\n</tr>\n<tr>\n<td>-M</td>\n<td>不生成清单文件MANIFEST.MF</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>为指定的jar文件创建索引文件</td>\n</tr>\n<tr>\n<td>-C</td>\n<td>可在相应的目录下执行命令</td>\n</tr>\n</tbody></table>\n<p>关于MANIFEST.MF定义：</p>\n<blockquote>\n<p><a href=\"https://baike.baidu.com/item/MANIFEST.MF\">https://baike.baidu.com/item/MANIFEST.MF</a></p>\n</blockquote>\n<h4 id=\"演示\"><a href=\"#演示\" class=\"headerlink\" title=\"演示\"></a>演示</h4><p><strong>往jar包添加文件</strong></p>\n<blockquote>\n<p>jar uf xxx.jar BOOT-INF&#x2F;classes&#x2F;application.yml</p>\n</blockquote>\n<p><strong>解压jar包</strong></p>\n<blockquote>\n<p>jar -xvf xxx.jar</p>\n</blockquote>\n<p><strong>打jar包，不生成清单文件，不压缩</strong></p>\n<blockquote>\n<p>jar -cvfM0 xxx.jar BOOT-INF&#x2F; META-INF&#x2F; org&#x2F;</p>\n</blockquote>\n<p>或者</p>\n<blockquote>\n<p>jar -cvfM0 xxx.jar *</p>\n</blockquote>\n<p>如果要往线上jar包添加、更新部分文件到jar包，这些命令也许对你有用。</p>\n","excerpt":"","more":"<p><img src=\"http://img.javastack.cn/18-2-27/79692618.jpg\"></p>\n<h4 id=\"什么是jar包\"><a href=\"#什么是jar包\" class=\"headerlink\" title=\"什么是jar包\"></a>什么是jar包</h4><p>JAR（Java Archive）是Java的归档文件，它是一种与平台无关的文件格式，它允许将许多文件组合成一个压缩文件。</p>\n<h4 id=\"如何打-解包\"><a href=\"#如何打-解包\" class=\"headerlink\" title=\"如何打&#x2F;解包\"></a>如何打&#x2F;解包</h4><p>使用jdk&#x2F;bin&#x2F;jar.exe工具，配置完环境变量后直接使得jar命令即可。</p>\n<h4 id=\"jar命令格式\"><a href=\"#jar命令格式\" class=\"headerlink\" title=\"jar命令格式\"></a>jar命令格式</h4><p>jar {c t x u f }[ v m e 0 M i ][-C 目录]文件名…</p>\n<p>{ctxu}，这四个参数必须选选其一。</p>\n<p>[v f m e 0 M i]，这几个是可选参数，文件名也是必须的。</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-c</td>\n<td>创建一个jar包</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>显示jar中的内容列表</td>\n</tr>\n<tr>\n<td>-x</td>\n<td>解压jar包</td>\n</tr>\n<tr>\n<td>-u</td>\n<td>添加文件到jar包中</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>指定jar包的文件名</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>输出详细报告</td>\n</tr>\n<tr>\n<td>-m</td>\n<td>指定MANIFEST.MF文件</td>\n</tr>\n<tr>\n<td>-0</td>\n<td>生成jar包时不压缩内容</td>\n</tr>\n<tr>\n<td>-M</td>\n<td>不生成清单文件MANIFEST.MF</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>为指定的jar文件创建索引文件</td>\n</tr>\n<tr>\n<td>-C</td>\n<td>可在相应的目录下执行命令</td>\n</tr>\n</tbody></table>\n<p>关于MANIFEST.MF定义：</p>\n<blockquote>\n<p><a href=\"https://baike.baidu.com/item/MANIFEST.MF\">https://baike.baidu.com/item/MANIFEST.MF</a></p>\n</blockquote>\n<h4 id=\"演示\"><a href=\"#演示\" class=\"headerlink\" title=\"演示\"></a>演示</h4><p><strong>往jar包添加文件</strong></p>\n<blockquote>\n<p>jar uf xxx.jar BOOT-INF&#x2F;classes&#x2F;application.yml</p>\n</blockquote>\n<p><strong>解压jar包</strong></p>\n<blockquote>\n<p>jar -xvf xxx.jar</p>\n</blockquote>\n<p><strong>打jar包，不生成清单文件，不压缩</strong></p>\n<blockquote>\n<p>jar -cvfM0 xxx.jar BOOT-INF&#x2F; META-INF&#x2F; org&#x2F;</p>\n</blockquote>\n<p>或者</p>\n<blockquote>\n<p>jar -cvfM0 xxx.jar *</p>\n</blockquote>\n<p>如果要往线上jar包添加、更新部分文件到jar包，这些命令也许对你有用。</p>\n"},{"title":"深入浅出 Java 中的包装类","date":"2025-10-14T06:42:34.000Z","_content":"\n![](http://img.javastack.cn/18-6-5/61544442.jpg)\n\n#### 什么是包装类型\n\nJava 设计当初就提供了 8 种 基本数据类型及对应的 8 种包装数据类型。我们知道 Java 是一种面向对象编程的高级语言，所以包装类型正是为了解决基本数据类型无法面向对象编程所提供的。\n\n**下面是基本数据类型与对应的包装类型。**\n\n基本数据类型 | 包装类型\n---|---\nbyte | Byte\nboolean | Boolean\nshort | Short\nchar | Character\nint | Integer\nlong | Long\nfloat | Float\ndouble | Double\n\n**下面是包装类型的继承结构图。**\n\n![](http://img.javastack.cn/18-6-5/80489463.jpg)\n\n从以上图表可以对基本类型和包装类型有一个全面的了解。\n\n#### 包装类应用场景\n\n**1、集合类泛型只能是包装类；**\n\n```\n// 编译报错\nList<int> list1 = new ArrayList<>();\n\n// 正常\nList<Integer> list2 = new ArrayList<>();\n```\n\n**2、成员变量不能有默认值；**\n\n```\nprivate int status;\n```\n\n基本数据类型的成员变量都有默认值，如以上代码 status 默认值为 0，如果定义中 0 代表失败，那样就会有问题，这样只能使用包装类 Integer，它的默认值为 null,所以就不会有默认值影响。\n\n**3、方法参数允许定义空值；**\n\n```\nprivate static void test1(int status){\n\tSystem.out.println(status);\n}\n```\n\n看以上代码，方法参数定义的是基本数据类型 int，所以必须得传一个数字过来，不能传 null，很多场合我们希望是能传递 null 的，所以这种场合用包装类比较合适。\n\n还有更多应用场景就不一一例举了，欢迎留言共同探讨包装类的更多的应用场景。\n\n#### 自动装箱、拆箱\n\nJava 5 增加了自动装箱、拆箱机制，提供基本数据类型和包装类型的相互转换操作。\n\n\n**自动装箱**\n\n自动装箱即自动将基本数据类型转换成包装类型，在 Java 5 之前，要将基本数据类型转换成包装类型只能这样做，看下面的代码。\n\n```\nInteger i1 = new Integer(8);\n\nInteger i2 = Integer.valueOf(8);\n\n// 自动装箱\nInteger i3 = 8;\n```\n\n以上 3 种都可以进行转换，但在 Java 5 之前第 3 种方法是编译失败的，第 3 种方法也正是现在的自动装箱功能。另外，第一种构造器方法也不推荐使用了，已经标为废弃了。\n\n其实自动装箱的原理就是调用包装类的 valueOf 方法，如第 2 个方法中的 Integer.valueOf 方法。\n\n**自动拆箱**\n\n自动拆箱即自动将包装类型转换成基本数据类型，与自动装箱相反，有装就有拆，很好理解。\n\n```\n// 自动拆箱\nint i4 = i3;\n\nint i5 = i3.intValue();\n```\n\n继续上面的例子，把 i3 赋值给 i4 就是实现的自动拆箱功能，自动装箱的原理就是调用包装类的 xxValue 方法，如 i5 中的 Integer 的 intValue 方法。\n\n自动装箱、拆箱不只是体现在以上的例子，在方法接收参数、对象设置参数时都能自动装箱拆箱。\n\n**需要注意的是，关于 Integer，-128 ~ 127 会有缓存，对比这个范围的值的对象是一个坑，这个在阿里巴巴规范中也有提及。** 详细请参考《[IntegerCache的妙用和陷阱](https://mp.weixin.qq.com/s/PnVkrMzYeOiepPKjl4MKVA)》这篇文章。\n\n","source":"_posts/基础/深入浅出 Java 中的包装类.md","raw":"---\ntitle: 深入浅出 Java 中的包装类\ndate: 2025-10-14 14:42:34\ntags: 基础\n---\n\n![](http://img.javastack.cn/18-6-5/61544442.jpg)\n\n#### 什么是包装类型\n\nJava 设计当初就提供了 8 种 基本数据类型及对应的 8 种包装数据类型。我们知道 Java 是一种面向对象编程的高级语言，所以包装类型正是为了解决基本数据类型无法面向对象编程所提供的。\n\n**下面是基本数据类型与对应的包装类型。**\n\n基本数据类型 | 包装类型\n---|---\nbyte | Byte\nboolean | Boolean\nshort | Short\nchar | Character\nint | Integer\nlong | Long\nfloat | Float\ndouble | Double\n\n**下面是包装类型的继承结构图。**\n\n![](http://img.javastack.cn/18-6-5/80489463.jpg)\n\n从以上图表可以对基本类型和包装类型有一个全面的了解。\n\n#### 包装类应用场景\n\n**1、集合类泛型只能是包装类；**\n\n```\n// 编译报错\nList<int> list1 = new ArrayList<>();\n\n// 正常\nList<Integer> list2 = new ArrayList<>();\n```\n\n**2、成员变量不能有默认值；**\n\n```\nprivate int status;\n```\n\n基本数据类型的成员变量都有默认值，如以上代码 status 默认值为 0，如果定义中 0 代表失败，那样就会有问题，这样只能使用包装类 Integer，它的默认值为 null,所以就不会有默认值影响。\n\n**3、方法参数允许定义空值；**\n\n```\nprivate static void test1(int status){\n\tSystem.out.println(status);\n}\n```\n\n看以上代码，方法参数定义的是基本数据类型 int，所以必须得传一个数字过来，不能传 null，很多场合我们希望是能传递 null 的，所以这种场合用包装类比较合适。\n\n还有更多应用场景就不一一例举了，欢迎留言共同探讨包装类的更多的应用场景。\n\n#### 自动装箱、拆箱\n\nJava 5 增加了自动装箱、拆箱机制，提供基本数据类型和包装类型的相互转换操作。\n\n\n**自动装箱**\n\n自动装箱即自动将基本数据类型转换成包装类型，在 Java 5 之前，要将基本数据类型转换成包装类型只能这样做，看下面的代码。\n\n```\nInteger i1 = new Integer(8);\n\nInteger i2 = Integer.valueOf(8);\n\n// 自动装箱\nInteger i3 = 8;\n```\n\n以上 3 种都可以进行转换，但在 Java 5 之前第 3 种方法是编译失败的，第 3 种方法也正是现在的自动装箱功能。另外，第一种构造器方法也不推荐使用了，已经标为废弃了。\n\n其实自动装箱的原理就是调用包装类的 valueOf 方法，如第 2 个方法中的 Integer.valueOf 方法。\n\n**自动拆箱**\n\n自动拆箱即自动将包装类型转换成基本数据类型，与自动装箱相反，有装就有拆，很好理解。\n\n```\n// 自动拆箱\nint i4 = i3;\n\nint i5 = i3.intValue();\n```\n\n继续上面的例子，把 i3 赋值给 i4 就是实现的自动拆箱功能，自动装箱的原理就是调用包装类的 xxValue 方法，如 i5 中的 Integer 的 intValue 方法。\n\n自动装箱、拆箱不只是体现在以上的例子，在方法接收参数、对象设置参数时都能自动装箱拆箱。\n\n**需要注意的是，关于 Integer，-128 ~ 127 会有缓存，对比这个范围的值的对象是一个坑，这个在阿里巴巴规范中也有提及。** 详细请参考《[IntegerCache的妙用和陷阱](https://mp.weixin.qq.com/s/PnVkrMzYeOiepPKjl4MKVA)》这篇文章。\n\n","slug":"基础/深入浅出 Java 中的包装类","published":1,"updated":"2025-10-14T07:23:36.602Z","_id":"cmgq8jz0a0000qwd406ibh9xj","comments":1,"layout":"post","photos":[],"content":"<p><img src=\"http://img.javastack.cn/18-6-5/61544442.jpg\"></p>\n<h4 id=\"什么是包装类型\"><a href=\"#什么是包装类型\" class=\"headerlink\" title=\"什么是包装类型\"></a>什么是包装类型</h4><p>Java 设计当初就提供了 8 种 基本数据类型及对应的 8 种包装数据类型。我们知道 Java 是一种面向对象编程的高级语言，所以包装类型正是为了解决基本数据类型无法面向对象编程所提供的。</p>\n<p><strong>下面是基本数据类型与对应的包装类型。</strong></p>\n<table>\n<thead>\n<tr>\n<th>基本数据类型</th>\n<th>包装类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>byte</td>\n<td>Byte</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>Boolean</td>\n</tr>\n<tr>\n<td>short</td>\n<td>Short</td>\n</tr>\n<tr>\n<td>char</td>\n<td>Character</td>\n</tr>\n<tr>\n<td>int</td>\n<td>Integer</td>\n</tr>\n<tr>\n<td>long</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>float</td>\n<td>Float</td>\n</tr>\n<tr>\n<td>double</td>\n<td>Double</td>\n</tr>\n</tbody></table>\n<p><strong>下面是包装类型的继承结构图。</strong></p>\n<p><img src=\"http://img.javastack.cn/18-6-5/80489463.jpg\"></p>\n<p>从以上图表可以对基本类型和包装类型有一个全面的了解。</p>\n<h4 id=\"包装类应用场景\"><a href=\"#包装类应用场景\" class=\"headerlink\" title=\"包装类应用场景\"></a>包装类应用场景</h4><p><strong>1、集合类泛型只能是包装类；</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 编译报错</span><br><span class=\"line\">List&lt;int&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">// 正常</span><br><span class=\"line\">List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p><strong>2、成员变量不能有默认值；</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int status;</span><br></pre></td></tr></table></figure>\n\n<p>基本数据类型的成员变量都有默认值，如以上代码 status 默认值为 0，如果定义中 0 代表失败，那样就会有问题，这样只能使用包装类 Integer，它的默认值为 null,所以就不会有默认值影响。</p>\n<p><strong>3、方法参数允许定义空值；</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static void test1(int status)&#123;</span><br><span class=\"line\">\tSystem.out.println(status);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看以上代码，方法参数定义的是基本数据类型 int，所以必须得传一个数字过来，不能传 null，很多场合我们希望是能传递 null 的，所以这种场合用包装类比较合适。</p>\n<p>还有更多应用场景就不一一例举了，欢迎留言共同探讨包装类的更多的应用场景。</p>\n<h4 id=\"自动装箱、拆箱\"><a href=\"#自动装箱、拆箱\" class=\"headerlink\" title=\"自动装箱、拆箱\"></a>自动装箱、拆箱</h4><p>Java 5 增加了自动装箱、拆箱机制，提供基本数据类型和包装类型的相互转换操作。</p>\n<p><strong>自动装箱</strong></p>\n<p>自动装箱即自动将基本数据类型转换成包装类型，在 Java 5 之前，要将基本数据类型转换成包装类型只能这样做，看下面的代码。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i1 = new Integer(8);</span><br><span class=\"line\"></span><br><span class=\"line\">Integer i2 = Integer.valueOf(8);</span><br><span class=\"line\"></span><br><span class=\"line\">// 自动装箱</span><br><span class=\"line\">Integer i3 = 8;</span><br></pre></td></tr></table></figure>\n\n<p>以上 3 种都可以进行转换，但在 Java 5 之前第 3 种方法是编译失败的，第 3 种方法也正是现在的自动装箱功能。另外，第一种构造器方法也不推荐使用了，已经标为废弃了。</p>\n<p>其实自动装箱的原理就是调用包装类的 valueOf 方法，如第 2 个方法中的 Integer.valueOf 方法。</p>\n<p><strong>自动拆箱</strong></p>\n<p>自动拆箱即自动将包装类型转换成基本数据类型，与自动装箱相反，有装就有拆，很好理解。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 自动拆箱</span><br><span class=\"line\">int i4 = i3;</span><br><span class=\"line\"></span><br><span class=\"line\">int i5 = i3.intValue();</span><br></pre></td></tr></table></figure>\n\n<p>继续上面的例子，把 i3 赋值给 i4 就是实现的自动拆箱功能，自动装箱的原理就是调用包装类的 xxValue 方法，如 i5 中的 Integer 的 intValue 方法。</p>\n<p>自动装箱、拆箱不只是体现在以上的例子，在方法接收参数、对象设置参数时都能自动装箱拆箱。</p>\n<p><strong>需要注意的是，关于 Integer，-128 ~ 127 会有缓存，对比这个范围的值的对象是一个坑，这个在阿里巴巴规范中也有提及。</strong> 详细请参考《<a href=\"https://mp.weixin.qq.com/s/PnVkrMzYeOiepPKjl4MKVA\">IntegerCache的妙用和陷阱</a>》这篇文章。</p>\n","excerpt":"","more":"<p><img src=\"http://img.javastack.cn/18-6-5/61544442.jpg\"></p>\n<h4 id=\"什么是包装类型\"><a href=\"#什么是包装类型\" class=\"headerlink\" title=\"什么是包装类型\"></a>什么是包装类型</h4><p>Java 设计当初就提供了 8 种 基本数据类型及对应的 8 种包装数据类型。我们知道 Java 是一种面向对象编程的高级语言，所以包装类型正是为了解决基本数据类型无法面向对象编程所提供的。</p>\n<p><strong>下面是基本数据类型与对应的包装类型。</strong></p>\n<table>\n<thead>\n<tr>\n<th>基本数据类型</th>\n<th>包装类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>byte</td>\n<td>Byte</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>Boolean</td>\n</tr>\n<tr>\n<td>short</td>\n<td>Short</td>\n</tr>\n<tr>\n<td>char</td>\n<td>Character</td>\n</tr>\n<tr>\n<td>int</td>\n<td>Integer</td>\n</tr>\n<tr>\n<td>long</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>float</td>\n<td>Float</td>\n</tr>\n<tr>\n<td>double</td>\n<td>Double</td>\n</tr>\n</tbody></table>\n<p><strong>下面是包装类型的继承结构图。</strong></p>\n<p><img src=\"http://img.javastack.cn/18-6-5/80489463.jpg\"></p>\n<p>从以上图表可以对基本类型和包装类型有一个全面的了解。</p>\n<h4 id=\"包装类应用场景\"><a href=\"#包装类应用场景\" class=\"headerlink\" title=\"包装类应用场景\"></a>包装类应用场景</h4><p><strong>1、集合类泛型只能是包装类；</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 编译报错</span><br><span class=\"line\">List&lt;int&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">// 正常</span><br><span class=\"line\">List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p><strong>2、成员变量不能有默认值；</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int status;</span><br></pre></td></tr></table></figure>\n\n<p>基本数据类型的成员变量都有默认值，如以上代码 status 默认值为 0，如果定义中 0 代表失败，那样就会有问题，这样只能使用包装类 Integer，它的默认值为 null,所以就不会有默认值影响。</p>\n<p><strong>3、方法参数允许定义空值；</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static void test1(int status)&#123;</span><br><span class=\"line\">\tSystem.out.println(status);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看以上代码，方法参数定义的是基本数据类型 int，所以必须得传一个数字过来，不能传 null，很多场合我们希望是能传递 null 的，所以这种场合用包装类比较合适。</p>\n<p>还有更多应用场景就不一一例举了，欢迎留言共同探讨包装类的更多的应用场景。</p>\n<h4 id=\"自动装箱、拆箱\"><a href=\"#自动装箱、拆箱\" class=\"headerlink\" title=\"自动装箱、拆箱\"></a>自动装箱、拆箱</h4><p>Java 5 增加了自动装箱、拆箱机制，提供基本数据类型和包装类型的相互转换操作。</p>\n<p><strong>自动装箱</strong></p>\n<p>自动装箱即自动将基本数据类型转换成包装类型，在 Java 5 之前，要将基本数据类型转换成包装类型只能这样做，看下面的代码。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i1 = new Integer(8);</span><br><span class=\"line\"></span><br><span class=\"line\">Integer i2 = Integer.valueOf(8);</span><br><span class=\"line\"></span><br><span class=\"line\">// 自动装箱</span><br><span class=\"line\">Integer i3 = 8;</span><br></pre></td></tr></table></figure>\n\n<p>以上 3 种都可以进行转换，但在 Java 5 之前第 3 种方法是编译失败的，第 3 种方法也正是现在的自动装箱功能。另外，第一种构造器方法也不推荐使用了，已经标为废弃了。</p>\n<p>其实自动装箱的原理就是调用包装类的 valueOf 方法，如第 2 个方法中的 Integer.valueOf 方法。</p>\n<p><strong>自动拆箱</strong></p>\n<p>自动拆箱即自动将包装类型转换成基本数据类型，与自动装箱相反，有装就有拆，很好理解。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 自动拆箱</span><br><span class=\"line\">int i4 = i3;</span><br><span class=\"line\"></span><br><span class=\"line\">int i5 = i3.intValue();</span><br></pre></td></tr></table></figure>\n\n<p>继续上面的例子，把 i3 赋值给 i4 就是实现的自动拆箱功能，自动装箱的原理就是调用包装类的 xxValue 方法，如 i5 中的 Integer 的 intValue 方法。</p>\n<p>自动装箱、拆箱不只是体现在以上的例子，在方法接收参数、对象设置参数时都能自动装箱拆箱。</p>\n<p><strong>需要注意的是，关于 Integer，-128 ~ 127 会有缓存，对比这个范围的值的对象是一个坑，这个在阿里巴巴规范中也有提及。</strong> 详细请参考《<a href=\"https://mp.weixin.qq.com/s/PnVkrMzYeOiepPKjl4MKVA\">IntegerCache的妙用和陷阱</a>》这篇文章。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cmgpw6zh90000fwd47fbh55qf","tag_id":"cmgq71di60002q0d4aqgv8fx9","_id":"cmgq71dia0004q0d47znd5uyj"},{"post_id":"cmgq71di10000q0d4cabj5o4u","tag_id":"cmgq71di60002q0d4aqgv8fx9","_id":"cmgq71dia0005q0d48ik5cegz"},{"post_id":"cmgq71di40001q0d4153zg5sm","tag_id":"cmgq71di60002q0d4aqgv8fx9","_id":"cmgq71dib0007q0d45eea9q8a"},{"post_id":"cmgpvylr20000gkd4h4x9hmcv","tag_id":"cmgq71dia0006q0d47lvgaukz","_id":"cmgq71dib0008q0d4d7ndajg4"},{"post_id":"cmgq75p9n0000hod4636j43vr","tag_id":"cmgq71di60002q0d4aqgv8fx9","_id":"cmgq75p9s0002hod4090ab23p"},{"post_id":"cmgq77o5h0004hod493qxdop2","tag_id":"cmgq71di60002q0d4aqgv8fx9","_id":"cmgq77o5h0005hod4gwd7cl01"},{"post_id":"cmgq7875g0007hod478l16wia","tag_id":"cmgq71di60002q0d4aqgv8fx9","_id":"cmgq797gr000fhod458k4dl0s"},{"post_id":"cmgq7a42b000ghod4bwh1enbm","tag_id":"cmgq71di60002q0d4aqgv8fx9","_id":"cmgq7a42c000hhod480h2dah3"},{"post_id":"cmgq7875e0006hod4gl402g0s","tag_id":"cmgq71di60002q0d4aqgv8fx9","_id":"cmgq7amam000ihod46vsx2dv4"},{"post_id":"cmgq7876m000ahod4h9kugyu3","tag_id":"cmgq71di60002q0d4aqgv8fx9","_id":"cmgq8aw7c000jhod48xuyf3od"},{"post_id":"cmgq78777000dhod41nzsbryh","tag_id":"cmgq71di60002q0d4aqgv8fx9","_id":"cmgq8aw7d000khod43gy21m8r"},{"post_id":"cmgq78772000bhod458d1c2xw","tag_id":"cmgq71di60002q0d4aqgv8fx9","_id":"cmgq8aw7t000lhod4g5f99ji1"},{"post_id":"cmgq787690009hod44qzt4rjk","tag_id":"cmgq71di60002q0d4aqgv8fx9","_id":"cmgq8aw7u000mhod46wo3ct94"},{"post_id":"cmgq8aw87000nhod4c4uhfhb2","tag_id":"cmgq71di60002q0d4aqgv8fx9","_id":"cmgq8aw87000ohod446gt2iah"},{"post_id":"cmgq787ar000ehod43l7ufwp1","tag_id":"cmgq71di60002q0d4aqgv8fx9","_id":"cmgq8aw89000phod4c57e6dbi"},{"post_id":"cmgq78773000chod4e34z6o5q","tag_id":"cmgq71di60002q0d4aqgv8fx9","_id":"cmgq8aw89000qhod477df4ta3"},{"post_id":"cmgq787670008hod415h76bh3","tag_id":"cmgq71di60002q0d4aqgv8fx9","_id":"cmgq8aw8n000rhod4246dhioh"},{"post_id":"cmgq8aw8o000shod4ag8h7k29","tag_id":"cmgq71di60002q0d4aqgv8fx9","_id":"cmgq8aw8o000thod40fic86ag"},{"post_id":"cmgq8cqtn001ahod48ylf4l9p","tag_id":"cmgq8cs5y001bhod401fa8hum","_id":"cmgq8cs5y001chod46ygrhf48"},{"post_id":"cmgq8ixsr0000x4d4g5dmh704","tag_id":"cmgq8cs5y001bhod401fa8hum","_id":"cmgq8ixsu0001x4d4eo0ef3nm"},{"post_id":"cmgq8jz0a0000qwd406ibh9xj","tag_id":"cmgq8cs5y001bhod401fa8hum","_id":"cmgq8jz0c0001qwd4gxxy6wp2"},{"post_id":"cmgq8bkey000xhod4gyix6y97","tag_id":"cmgq8cs5y001bhod401fa8hum","_id":"cmgq8tyrc0000h8d4gcaoc2rg"},{"post_id":"cmgq8bkfv0010hod406pr5mr0","tag_id":"cmgq8cs5y001bhod401fa8hum","_id":"cmgq8tyrf0001h8d46l0v4uld"},{"post_id":"cmgq8bkgq0011hod40xjg5kez","tag_id":"cmgq8cs5y001bhod401fa8hum","_id":"cmgq8tyrf0002h8d4cs1ebit8"},{"post_id":"cmgq8bkfu000zhod47t9hd57e","tag_id":"cmgq8cs5y001bhod401fa8hum","_id":"cmgq8tyri0003h8d4eb8eaiwf"},{"post_id":"cmgq8bkei000vhod4akdc1nju","tag_id":"cmgq8cs5y001bhod401fa8hum","_id":"cmgq8tyri0004h8d45mse8css"},{"post_id":"cmgq8bkix0018hod4doqf7evy","tag_id":"cmgq8cs5y001bhod401fa8hum","_id":"cmgq8tys40005h8d4hgsf5rcm"},{"post_id":"cmgq8bkhm0013hod4gnih79f8","tag_id":"cmgq8cs5y001bhod401fa8hum","_id":"cmgq8tys50006h8d4aa2ta7ng"},{"post_id":"cmgq8bkjf0019hod48yy124un","tag_id":"cmgq8cs5y001bhod401fa8hum","_id":"cmgq8tys50007h8d4b78a5kt1"},{"post_id":"cmgq8bkiw0017hod4276x724m","tag_id":"cmgq8cs5y001bhod401fa8hum","_id":"cmgq8tysj0008h8d42ni6ecjo"},{"post_id":"cmgq8bkel000whod41xx22jg0","tag_id":"cmgq8cs5y001bhod401fa8hum","_id":"cmgq8tysk0009h8d48mykg70j"},{"post_id":"cmgq8bkh70012hod41pw81tig","tag_id":"cmgq8cs5y001bhod401fa8hum","_id":"cmgq8tysz000ah8d4a5g1dek2"},{"post_id":"cmgq8bke2000uhod410v04i8t","tag_id":"cmgq8cs5y001bhod401fa8hum","_id":"cmgq8tyt0000bh8d4e0e5eb5o"},{"post_id":"cmgq8bkii0015hod44nj34jsx","tag_id":"cmgq8cs5y001bhod401fa8hum","_id":"cmgq8tyt0000ch8d48fl6gcmz"},{"post_id":"cmgq8bkij0016hod44lyqbqle","tag_id":"cmgq8cs5y001bhod401fa8hum","_id":"cmgq8tytf000dh8d421nw9kcr"},{"post_id":"cmgq8bkhn0014hod42736a9ia","tag_id":"cmgq8cs5y001bhod401fa8hum","_id":"cmgq8tytg000eh8d4cahb7xb1"}],"Tag":[{"name":"JAVA","_id":"cmgpw0kww0001gkd4d0bfbccu"},{"name":"多线程","_id":"cmgq71di60002q0d4aqgv8fx9"},{"name":"JVM","_id":"cmgq71dia0006q0d47lvgaukz"},{"name":"基础","_id":"cmgq8cs5y001bhod401fa8hum"}]}}