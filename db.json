{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/heyan/source/logo - 副本.png","path":"logo - 副本.png","modified":0,"renderable":1},{"_id":"themes/heyan/source/logo.png","path":"logo.png","modified":0,"renderable":1},{"_id":"themes/heyan/source/police.png","path":"police.png","modified":0,"renderable":1},{"_id":"themes/heyan/source/logo1.png","path":"logo1.png","modified":0,"renderable":1},{"_id":"themes/heyan/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/heyan/source/css/markdown.styl","path":"css/markdown.styl","modified":0,"renderable":1},{"_id":"themes/heyan/source/css/prism.css","path":"css/prism.css","modified":0,"renderable":1},{"_id":"themes/heyan/source/favicon/about.txt","path":"favicon/about.txt","modified":0,"renderable":1},{"_id":"themes/heyan/source/favicon/android-chrome-192x192.png","path":"favicon/android-chrome-192x192.png","modified":0,"renderable":1},{"_id":"themes/heyan/source/favicon/android-chrome-512x512.png","path":"favicon/android-chrome-512x512.png","modified":0,"renderable":1},{"_id":"themes/heyan/source/favicon/favicon-16x16.png","path":"favicon/favicon-16x16.png","modified":0,"renderable":1},{"_id":"themes/heyan/source/favicon/apple-touch-icon.png","path":"favicon/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/heyan/source/favicon/favicon-32x32.png","path":"favicon/favicon-32x32.png","modified":0,"renderable":1},{"_id":"themes/heyan/source/favicon/favicon.ico","path":"favicon/favicon.ico","modified":0,"renderable":1},{"_id":"themes/heyan/source/favicon/site.webmanifest","path":"favicon/site.webmanifest","modified":0,"renderable":1},{"_id":"themes/heyan/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/heyan/source/js/prism.js","path":"js/prism.js","modified":0,"renderable":1},{"_id":"themes/heyan/source/js/search.js","path":"js/search.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/heyan/.gitignore","hash":"b74ab8670f8a87b36fb8726fd6282ef2f8f27e5a","modified":1753076462000},{"_id":"themes/heyan/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1753076462000},{"_id":"themes/heyan/README.md","hash":"87dc0dad2bd5b68a9e8b5c3819174b2bf8937848","modified":1753076462000},{"_id":"themes/heyan/_config.yml","hash":"c2a68a6f45ff2aa9893c4f56e8924c665ae8f1e4","modified":1760521690610},{"_id":"themes/heyan/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1753076462000},{"_id":"themes/heyan/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1753076462000},{"_id":"themes/heyan/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1753076462000},{"_id":"themes/heyan/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1753076462000},{"_id":"themes/heyan/languages/en.yml","hash":"9c979a2f107536399bbe2be572c2d0bebcdd9d95","modified":1753076462000},{"_id":"themes/heyan/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1753076462000},{"_id":"themes/heyan/languages/zh-TW.yml","hash":"e9747f9b3ec1314a3cae44a9a90e7649af739633","modified":1753076462000},{"_id":"themes/heyan/languages/zh-CN.yml","hash":"78cc1794a3ce3e186c462c1a70f097d0c05cd210","modified":1753076462000},{"_id":"themes/heyan/layout/archive.ejs","hash":"97ac0ea7dff13181f74415fb35a733de4c2d3e82","modified":1760518008489},{"_id":"themes/heyan/layout/category.ejs","hash":"5e97ceb9309b8361b33b9d09d622bef2f6a33ab0","modified":1753076462000},{"_id":"themes/heyan/layout/layout.ejs","hash":"537088692915fda76a12830c9674fc4a2a3cab6b","modified":1753076462000},{"_id":"themes/heyan/layout/index.ejs","hash":"20f43b481c7748b27394ed017fe7b20f7a30fbfb","modified":1760523493014},{"_id":"themes/heyan/layout/page.ejs","hash":"a5f9afe66aefb24abb2b88975bfd631376791f65","modified":1753076462000},{"_id":"themes/heyan/layout/post.ejs","hash":"432a12279e997bf46df556161432e0f5b34db783","modified":1753076462000},{"_id":"themes/heyan/layout/tag.ejs","hash":"2fad18eaf49ffbd1338e5bc8d15ebdbe3a696ea9","modified":1753076462000},{"_id":"themes/heyan/source/logo - 副本.png","hash":"ce91374e148e3391f8f3235b672fa32cd3746d7c","modified":1753076462000},{"_id":"themes/heyan/source/logo1.png","hash":"ce91374e148e3391f8f3235b672fa32cd3746d7c","modified":1753076462000},{"_id":"themes/heyan/scripts/mathjax_util.js","hash":"9a6be519b747c70948b8b63840d13cf0bdff95ec","modified":1753076462000},{"_id":"themes/heyan/source/police.png","hash":"7ec67ebc6cf0b3c79ec5cdd35b8c48f2fef2d80e","modified":1753076462000},{"_id":"themes/heyan/layout/_partial/footer.ejs","hash":"9e10eca74cd0f34fc4b63b0bfc1917088537ea30","modified":1760511846542},{"_id":"themes/heyan/layout/_partial/header.ejs","hash":"a861ff21fb57c7de48bdea9a8b9cd0cd1aefdf63","modified":1760583564182},{"_id":"themes/heyan/layout/_partial/nav.ejs","hash":"4e1ba71082b05dd7fee2573f82599feffac37c62","modified":1760518512048},{"_id":"themes/heyan/layout/_partial/next_post.ejs","hash":"a0ea0efc0b4b6f2cd3867373ed8d91056b57afe2","modified":1753076462000},{"_id":"themes/heyan/layout/_partial/paginator.ejs","hash":"e6ad2d3ab7e929cac007f25cf3d01658463114ab","modified":1753076462000},{"_id":"themes/heyan/layout/_partial/nav_menu.ejs","hash":"d98f7154722d4a4f6cd2cb31b7e1b603b1b72625","modified":1753076462000},{"_id":"themes/heyan/layout/_partial/post_list.ejs","hash":"88fe95a52bf0283ff284084b2f553d992feb87e5","modified":1760580976881},{"_id":"themes/heyan/layout/_partial/sidebar.ejs","hash":"b4c5ca3531674b194be7ffbdd5464f28fe1e9790","modified":1753076462000},{"_id":"themes/heyan/layout/_widget/category.ejs","hash":"60a5dd9a839b7379485ad3fc84746835f271211b","modified":1753076462000},{"_id":"themes/heyan/layout/_widget/links.ejs","hash":"e3c53cf5a247e5f916ce9aec1e7a1d121ce25ba4","modified":1753076462000},{"_id":"themes/heyan/layout/_widget/recent.ejs","hash":"245b3ce687dbab17dbd0b9f7c966a61064466689","modified":1753076462000},{"_id":"themes/heyan/layout/_widget/same_category.ejs","hash":"45a7b90364a5057dabd0ae6266a2ca139cfdb3ec","modified":1753076462000},{"_id":"themes/heyan/layout/_widget/related_posts.ejs","hash":"be23800b8777da59c0fb60fc540bc97caa980ffe","modified":1753076462000},{"_id":"themes/heyan/layout/_widget/search.ejs","hash":"1c1dffe48aa0e301b5866661faa4c79378f72f68","modified":1760518384127},{"_id":"themes/heyan/layout/_widget/tag.ejs","hash":"deef7b208d3d283dd960bf1f462080070959d0d7","modified":1753076462000},{"_id":"themes/heyan/layout/_widget/toc.ejs","hash":"c313013b91a7d2d58ca528886d2f68c2959a88fb","modified":1753076462000},{"_id":"themes/heyan/source/css/index.styl","hash":"0f3c6643833eb15907ba83ca36513174afaf9934","modified":1760579400919},{"_id":"themes/heyan/source/css/markdown.styl","hash":"46309f1bd5bf6425f9dac28f51c788b375cb7c15","modified":1753076462000},{"_id":"themes/heyan/source/favicon/about.txt","hash":"0d732aeb0fbae1e3a711c98a0ad4e04cc079f5e6","modified":1753076462000},{"_id":"themes/heyan/source/css/prism.css","hash":"8f4f3c2c50e06c4c93cea8f65273ba3d69038a36","modified":1760516486038},{"_id":"themes/heyan/source/favicon/android-chrome-192x192.png","hash":"ae182103e859a6cf14ea9bc053cf1a4926ea3d21","modified":1753076462000},{"_id":"themes/heyan/source/favicon/android-chrome-512x512.png","hash":"ebae4f76f3bb5521ed0655e78a10c235444ad42c","modified":1753076462000},{"_id":"themes/heyan/source/favicon/favicon-16x16.png","hash":"cb44828efc81002729bbc2396ba85f0e30e63bc4","modified":1753076462000},{"_id":"themes/heyan/source/favicon/apple-touch-icon.png","hash":"662a0af0933fcc0ce3c1cfc12ed07e7ae4306094","modified":1753076462000},{"_id":"themes/heyan/source/favicon/favicon-32x32.png","hash":"763b31f84d7ecf62946eb426692b949d31218b8e","modified":1753076462000},{"_id":"themes/heyan/source/favicon/site.webmanifest","hash":"bf31baf91bdd2fcde24a45e3f2a1be33733c6f69","modified":1753076462000},{"_id":"themes/heyan/source/favicon/favicon.ico","hash":"27ad4ec726910ba22e33da90ac55a9ac0bfac593","modified":1753076462000},{"_id":"themes/heyan/source/js/fancybox.js","hash":"d638c7b5fc3f87dd44b65c4769dbf97f41834f9f","modified":1753076462000},{"_id":"themes/heyan/source/js/prism.js","hash":"b8aad0b4b24ebc2907a60af635b22b4c459541b9","modified":1753076462000},{"_id":"themes/heyan/source/js/search.js","hash":"a6410a3f33b47ee4548d461b6fc6d1785fa36f2b","modified":1753076462000},{"_id":"source/index.md","hash":"dc20e7e49e39ba8510e36df7948f43a180e8c634","modified":1760522793232},{"_id":"source/_data/styles.styl","hash":"c223785291fa67b65e801b98311fc977c03f39a6","modified":1760522137846},{"_id":"source/_posts/JVM/JVM运行时区域详解.md","hash":"19a37b48d04e3c0d06146ed76fe05aac9bd9c203","modified":1760523131562},{"_id":"source/_posts/hello-world.md","hash":"a57a9052918633fc13216e39e9be39630fd91b22","modified":1760516544471},{"_id":"source/about/index.md","hash":"a53c2e0ba2e14493d3e51df1adce12e0fc9770dc","modified":1760514010208},{"_id":"source/_posts/进阶/Java 中的 6 颗语法糖.md","hash":"7d4008ab03cdae5b843470e5c8fd4156e957013b","modified":1760583068329},{"_id":"source/categories/index.md","hash":"68ab054f1a5307fa0f5f88948df8c993754d3992","modified":1760515966510},{"_id":"source/_posts/进阶/Java 中的伪共享详解及解决方案.md","hash":"2d9d3fcfbc521374961a1624acbc6371724331cc","modified":1760512874235},{"_id":"source/_posts/新特性/Java 5 ~ 10 新特性倾情整理！.md","hash":"92b86a97241dbe839d2f6f1895e2b29f2fe67e2d","modified":1760512851376},{"_id":"source/_posts/进阶/Java 中的 String 真的是不可变吗？.md","hash":"eac371e22a5539d4c00ff8b6a8af34007bb25d13","modified":1760512874230},{"_id":"source/_posts/进阶/Java 中的宏变量，宏替换详解。.md","hash":"c02b542a02caecb74c15d3f1b5640b348e003008","modified":1760512874269},{"_id":"source/_posts/进阶/Java 中获取类名的三种方法，你知道几种？.md","hash":"cbdb8cef57206781573ddc8fe6483144e775cf32","modified":1760512874226},{"_id":"source/_posts/进阶/Java 对象引用四个级别（强、软、弱、虚）.md","hash":"1446572619bf8625178315aef788d12e65c07ad0","modified":1760512874282},{"_id":"source/_posts/进阶/Java 异常处理 10 个最佳实践.md","hash":"0109a7d5183bb9a7a23ef06388a50381a7f9cb7b","modified":1760512874273},{"_id":"source/_posts/进阶/Java 类初始化顺序，3个示例带你躺坑。.md","hash":"11ae00de8b6b61534164942a4db5b0dd04e48b5e","modified":1760512874219},{"_id":"source/_posts/进阶/Java 自定义 ClassLoader 实战.md","hash":"194d79d2784bf0e45a3d814b2370da82744860ae","modified":1760512874287},{"_id":"source/_posts/进阶/hashCode 和 identityHashCode 的区别你知道吗？.md","hash":"2b7e58819972df8626c0f043c4678af6cfe0e1b5","modified":1760512874277},{"_id":"source/_posts/进阶/别再写 bug 了，避免空指针的 5 个案例！.md","hash":"672ea27c566546c4c38e59f1915d257ef5ffbab9","modified":1760512874206},{"_id":"source/_posts/进阶/不能用 + 拼接字符串？ 这次我要吊打面试官！.md","hash":"cc2b20c79e5ad16a93411c0b356c3c3215d4f023","modified":1760512874223},{"_id":"source/_posts/进阶/字符串 substring 方法在 JDK 6,7,8 中的差异。.md","hash":"b988100b3796681dc4bb30cfa847cc5dd9d549ff","modified":1760512874239},{"_id":"source/_posts/进阶/神奇，教你用随机数打印hello world.md","hash":"fe67000495276933450c48a3c350514822e1ae70","modified":1760512874215},{"_id":"source/_posts/进阶/金融系统中正确的金额计算及存储方式.md","hash":"5680db59ebec5cc7a50a58fb1d89bdfda9843f02","modified":1760512874292},{"_id":"source/_posts/进阶/面试问我 Java 逃逸分析，瞬间被秒杀了。.md","hash":"2831bda6be4e7eb0de38707cfe8c035db2ed26c1","modified":1760512874211},{"_id":"source/_posts/多线程/Java多线程join使用及原理.md","hash":"18bf8f28448865853f50bc503b91ffc0348e934a","modified":1760512825057},{"_id":"source/_posts/多线程/Java虚拟机对锁优化所做的努力.md","hash":"6d65d23e3a8df93de9f2b12b7bd20021bcd7f83b","modified":1760512825052},{"_id":"source/_posts/多线程/Synchronized 有几种用法？.md","hash":"03c73fdb4c38fcfe61a7c04da3ef3c944df54f41","modified":1760512824976},{"_id":"source/_posts/多线程/Java多线程可以分组还能这样玩.md","hash":"0944de993d5660358fbafc3a9156813a61c9a0f9","modified":1760512824996},{"_id":"source/_posts/多线程/Synchronized 与 ReentrantLock 的区别！.md","hash":"43841b8200d264d20de8a5f0575759bd20317cf0","modified":1760512825073},{"_id":"source/_posts/多线程/i++是线程安全的吗？.md","hash":"4f95f41ab81d054d259d9a886da3796d4e006083","modified":1760512825069},{"_id":"source/_posts/多线程/一文搞懂 Java 线程中断.md","hash":"5cc472936d029b1b204cc5dee6c524cfbb607b92","modified":1760512825065},{"_id":"source/_posts/多线程/sleep( )和wait( )的这5个区别，你知道几个？.md","hash":"87506f6c1ebc70a0db94a78d7780f9b47be1c19b","modified":1760512825001},{"_id":"source/_posts/多线程/出场率比较高的一道多线程安全面试题.md","hash":"3a927a0092698bd459892195cfb695915552e77a","modified":1760512825061},{"_id":"source/_posts/多线程/到底什么是重入锁，拜托，一次搞清楚！.md","hash":"4eb30b656081d9787319c3b7fbf38f0bd023e7a2","modified":1760512825077},{"_id":"source/_posts/多线程/多线程 Thread.yield 方法到底有什么用？.md","hash":"1eeb3c6b51527b691f2e4fcc92425ffe03179427","modified":1760512825018},{"_id":"source/_posts/多线程/多线程 start 和 run 方法到底有什么区别？.md","hash":"9239aff69b4dd4a11c69e529d205d70f1bccf95e","modified":1760512824991},{"_id":"source/_posts/多线程/并行任务执行神器 Fork & Join 实战.md","hash":"37d029afda70a28476156f9a92a2420f4ecea764","modified":1760512824981},{"_id":"source/_posts/多线程/多线程通信的三大法器，你真的会用吗？.md","hash":"1d74eae8091143169d5120d60fcecd305d1f6ebe","modified":1760512825005},{"_id":"source/_posts/多线程/教你如何监控 Java 线程池运行状态.md","hash":"fb2397aa04bc0ad26b431e0166eeffb48d49a610","modified":1760512824986},{"_id":"source/_posts/多线程/线程休眠只会用Thread.sleep？那就弱爆了！.md","hash":"1e7423fdffc3e53d0e1479e52a5e3f2a5542f46d","modified":1760512825009},{"_id":"source/_posts/多线程/面试官问线程安全的List，看完再也不怕了！.md","hash":"4d932a029fc696019bc41953c7f7e6257037902a","modified":1760512825014},{"_id":"source/_posts/基础/10 个深恶痛绝的 Java 异常.md","hash":"20f11ef0880b6570a2fd2c092fdaaabaa2d9e81e","modified":1760512791879},{"_id":"source/_posts/基础/Java Base64 编码解码方案总结.md","hash":"e3f5e26d19390b3104c04da84cf07864b39e5371","modified":1760512791820},{"_id":"source/_posts/基础/Java Jar包压缩、解压使用指南.md","hash":"f4a47cdf74a673c433fef301cd377ce541a5b8df","modified":1760512431265},{"_id":"source/_posts/基础/Java 中的基本数据类型转换详解.md","hash":"db00ae3048a88abb739ad0a2c67086fe510455d7","modified":1760512791795},{"_id":"source/_posts/基础/Java 父类强制转换子类原则.md","hash":"b8cbe6f24b9d8aa84dd27b1c2ed00f45592de4e3","modified":1760512791800},{"_id":"source/_posts/基础/StringBuffer 和 StringBuilder 的 3 个区别.md","hash":"10d718ce9ce8a3bbf336588d5bfbb959eb97291f","modified":1760512791814},{"_id":"source/_posts/基础/switch case 支持的 6 种数据类型！.md","hash":"c4454dc7e21bb799e4dd7cac2f5349ce38b01593","modified":1760512791810},{"_id":"source/_posts/基础/switch多值匹配骚操作，带你涨姿势！.md","hash":"8a235c193c7ee2e372d6c6e813765d85e980de64","modified":1760512791833},{"_id":"source/_posts/基础/一张图搞清楚Java异常机制.md","hash":"42f947797f22344ee38865406776f23235e1f5d6","modified":1760512791824},{"_id":"source/_posts/基础/你真的搞懂 transient  关键字了吗？.md","hash":"4c4b71435388232a46a77ae6a534e1c4ddec1631","modified":1760512791838},{"_id":"source/_posts/基础/关于Java序列化你应该知道的一切.md","hash":"1af5f6ba1893cdbb8278d970654d4e35953c2c34","modified":1760512791784},{"_id":"source/_posts/基础/坑爹的 Java 可变参数，把我整得够惨。.md","hash":"6b529e9faa46f3656be2093550ac88855150b3b3","modified":1760512791805},{"_id":"source/_posts/基础/你真的搞懂 transient 关键字了吗？.md","hash":"c02d30c3ff8d5f0ab8b180e9c2e9cc943017e0c0","modified":1760512791829},{"_id":"source/_posts/基础/关于 Java 序列化你不知道的 5 件事.md","hash":"c9e705295a342a1d49508bd08c5e491f869f0f3c","modified":1760512791889},{"_id":"source/_posts/基础/常见的 3 种 Class 级别的错误.md","hash":"8c4bbf5457e34c2924a8393b99609759227e1ef8","modified":1760512791893},{"_id":"source/_posts/基础/字符串拼接 + 和 concat 的区别.md","hash":"ca88c7699d99ea07a8cb480a6a3a6819a977dcdf","modified":1760512791789},{"_id":"source/_posts/基础/深入浅出 Java 中的包装类.md","hash":"b9863c74bc042e7e76705e20125da2bff7660139","modified":1760512791843},{"_id":"source/_posts/集合/HashMap 和 Hashtable 的 6 个区别.md","hash":"e7dbcc871f27070cafd8016f67a1e315b561c77c","modified":1760512889813},{"_id":"source/_posts/基础/通用唯一标识码 UUID 的介绍及使用。.md","hash":"b32abeea8914c6f360bfd440ae2246d91d533a66","modified":1760512791883},{"_id":"source/_posts/集合/Hashtable 为什么不叫 HashTable？.md","hash":"b80f7eeb16e94527046f01d9b57d946aa9883714","modified":1760512889809},{"_id":"source/_posts/集合/Java 中初始化 List 集合的 6 种方式!.md","hash":"aa24446cbe11c42d64c91ebf3d6809df77d43990","modified":1760512889764},{"_id":"source/_posts/新特性/Java10/Java 10 的 10 个新特性，将彻底改变你写代码的方式.md","hash":"6cb8e6b36f498446756bfc7f5ac9f5dbfd3409fd","modified":1760512851431},{"_id":"source/_posts/新特性/Java10/Java 10 局部变量类型推断介绍及实战.md","hash":"e7a5bb6c3dd4954b5f24be80e521ace70595aae3","modified":1760512851453},{"_id":"source/_posts/新特性/Java11/Java 11 正式发布，这 8 个新特性教你写出更牛逼的代码.md","hash":"0395100751b043397886ff8026c6930ef6a066f3","modified":1760512851502},{"_id":"source/_posts/新特性/Java8/Java8 之新特性扩展篇.md","hash":"693231457018b3e6f51ad1772ea37cd208c15f3a","modified":1760512851461},{"_id":"source/_posts/新特性/Java8/Java8 新特性之Optional.md","hash":"15a42f2883daf2a3c110f8825f8b4be08bdab73c","modified":1760512851398},{"_id":"source/_posts/新特性/Java11/Java 11 已发布，String 还能这样玩.md","hash":"1386022c1bae1fa6fa96e9da117e291c0442ed3a","modified":1760512851427},{"_id":"source/_posts/新特性/Java8/Java8 新特性之Lambda表达式.md","hash":"b99c7edfcf71edc239031f861168b8125bb099cf","modified":1760512851510},{"_id":"source/_posts/新特性/Java8/Java8 新特性之函数式接口.md","hash":"c319f7fce08ed01df53880605daaaed1cfdf34fe","modified":1760512851515},{"_id":"source/_posts/新特性/Java8/Java8 新特性之方法引用.md","hash":"50d93453d3cc1ed532bcbbbfff7a89bf526b6ed6","modified":1760512851389},{"_id":"source/_posts/新特性/Java8/Java8 新特性之接口默认方法与静态方法.md","hash":"775ef9f30b1bf7841b725a4eb77b42968d7aa0c5","modified":1760512851412},{"_id":"source/_posts/新特性/Java8/Java8 新特性之重复注解.md","hash":"28eb2cd94555089d0f6c7643fdb339a2d9a6d62a","modified":1760512851456},{"_id":"source/_posts/新特性/Java12/Java 12 骚操作， String居然还能这样玩.md","hash":"58731b4ad1ff6f85659ffa5d83bdda61c1b1eb89","modified":1760512851435},{"_id":"source/_posts/新特性/Java12/Java 12 骚操作， 文件比对居然还能这样玩！.md","hash":"f88e6b517cca60e7cbdc57fbe923cfb7dea41ee1","modified":1760512851380},{"_id":"source/_posts/新特性/Java12/Java 12 骚操作， switch居然还能这样玩！.md","hash":"98333d65adff850ef6dcf5a1f772a1ac780a1318","modified":1760512851408},{"_id":"source/_posts/新特性/Java9/Java9 简化流关闭新姿势.md","hash":"012f16ec68b88bd606590b4bd324b4724d0e6cdc","modified":1760512851394},{"_id":"source/_posts/新特性/Java8/Stream/Java 8 创建 Stream 的 10 种方式，我保证你受益无穷!.md","hash":"ebc5f123fa9ee90e5d72d71468848044855522fc","modified":1760512851449},{"_id":"source/_posts/新特性/Java8/Stream/Java 8 新特性之 Stream 流（七）流与迭代器，流系列大结局！.md","hash":"1c22f223fd0c609f9027e81b72019ebd25262b36","modified":1760512851465},{"_id":"source/_posts/新特性/Java8/Stream/Java 8 新特性之 Stream 流（三）缩减操作.md","hash":"0df9f96dcbc7732f081bd70c9f11ebb135fb8cde","modified":1760512851402},{"_id":"source/_posts/新特性/Java8/Stream/Java 8 新特性之 Stream 流（一）基础体验.md","hash":"ec16309cedc95b2de0259e35cfbb5eb48cca1a78","modified":1760512851422},{"_id":"source/_posts/新特性/Java8/Stream/Java 8 新特性之 Stream 流（二）关键知识点.md","hash":"91f88a4508d6bedd4791f8c1d41ca4cc091c0067","modified":1760512851443},{"_id":"source/_posts/新特性/Java8/Stream/Java 8 新特性之 Stream 流（六）收集.md","hash":"09933a7fa09b619e241e0809d7e21ee72e20c78e","modified":1760512851417},{"_id":"source/_posts/新特性/Java8/Stream/Java 8 新特性之 Stream 流（四）并行流.md","hash":"264512e3ee090131c1175b18ae18a4e213cd3d04","modified":1760512851506},{"_id":"source/_posts/新特性/Java8/Stream/Java 8 新特性之 Stream 流（五）映射.md","hash":"7979bafe3c43e617c1cc7a4a21164d2c7cc6f6ab","modified":1760512851385},{"_id":"source/_posts/新特性/Java8/Stream/Java 8 新特性之Stream流.md","hash":"542c169c8525c75c0ad1cfb00eb78df8c9f678f6","modified":1760512851439},{"_id":"source/_posts/集合/HashMap, ConcurrentHashMap 原理及源码.md","hash":"10618796195da0617d0c8095e4cfacdda56fc10c","modified":1760512889773},{"_id":"themes/heyan/source/logo.png","hash":"763da9c5d814ceced803525677f11337c908de63","modified":1760511437790},{"_id":"public/search.xml","hash":"a01fa7bd02213c6ee4a715582ecaa30e6663b9de","modified":1760583577910},{"_id":"public/index.html","hash":"4d131bccb2d671d0003344f8cbc0853b194ffcac","modified":1760583577910},{"_id":"public/about/index.html","hash":"35831f0fae2a184ece67f2007075c7fe8f50771f","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java 5 ~ 10 新特性倾情整理！/index.html","hash":"36d078e35c1fb02b819794a8b42f1087bfd4e707","modified":1760583577910},{"_id":"public/categories/index.html","hash":"eefcba446f03e86fd093004258ac48c40e1cf7fe","modified":1760583577910},{"_id":"public/2025/10/15/进阶/Java 中的 String 真的是不可变吗？/index.html","hash":"f93820b168c3a80ed07b5f02f92c070906e846e9","modified":1760583577910},{"_id":"public/2025/10/15/进阶/Java 中的 6 颗语法糖/index.html","hash":"529126da4bc12d503350854a921f284bdfabde68","modified":1760583577910},{"_id":"public/2025/10/15/进阶/Java 中的伪共享详解及解决方案/index.html","hash":"7aea7c0acf1281a6d88d79004c4b9ec3db313c6b","modified":1760583577910},{"_id":"public/2025/10/15/进阶/Java 中的宏变量，宏替换详解。/index.html","hash":"d2858c83ceb57343adfebf8d9505484a070b210b","modified":1760583577910},{"_id":"public/2025/10/15/进阶/Java 中获取类名的三种方法，你知道几种？/index.html","hash":"38780da22887b69c0c8832aad5df40a709dd9477","modified":1760583577910},{"_id":"public/2025/10/15/进阶/Java 对象引用四个级别（强、软、弱、虚）/index.html","hash":"bc4560568cdbd40b3f5ef6929b77475990b22224","modified":1760583577910},{"_id":"public/2025/10/15/进阶/Java 异常处理 10 个最佳实践/index.html","hash":"a141aa6206c22aa11521152dbed3e5182cc6d9db","modified":1760583577910},{"_id":"public/2025/10/15/进阶/Java 类初始化顺序，3个示例带你躺坑。/index.html","hash":"5a6ab33e587fa28ad27b9109ddda658494adeb66","modified":1760583577910},{"_id":"public/2025/10/15/进阶/Java 自定义 ClassLoader 实战/index.html","hash":"32f65104763e8296942a945ea3f82331daada2fc","modified":1760583577910},{"_id":"public/2025/10/15/进阶/hashCode 和 identityHashCode 的区别你知道吗？/index.html","hash":"9b8af8d8e10fb1d5771fd1cf72bd5f8fb891a2c7","modified":1760583577910},{"_id":"public/2025/10/15/进阶/不能用 + 拼接字符串？ 这次我要吊打面试官！/index.html","hash":"819ff8836f8e66adb5900e1a77a187d4873549e1","modified":1760583577910},{"_id":"public/2025/10/15/进阶/别再写 bug 了，避免空指针的 5 个案例！/index.html","hash":"c163b14d3f159bfa2b3e8893cfda8695d4b219f2","modified":1760583577910},{"_id":"public/2025/10/15/进阶/神奇，教你用随机数打印hello world/index.html","hash":"06a4238557045d004c6d2382f7f1473fbe3d2dcc","modified":1760583577910},{"_id":"public/2025/10/15/进阶/字符串 substring 方法在 JDK 6,7,8 中的差异。/index.html","hash":"5d852d211ca9e7f95befe7240409186501a397ae","modified":1760583577910},{"_id":"public/2025/10/15/进阶/金融系统中正确的金额计算及存储方式/index.html","hash":"5ee121978aa1a5639059074e234c5007f6290e3f","modified":1760583577910},{"_id":"public/2025/10/15/进阶/面试问我 Java 逃逸分析，瞬间被秒杀了。/index.html","hash":"4295e719d1d2e7a66fd4713752745e3ff94d9fe6","modified":1760583577910},{"_id":"public/2025/10/15/集合/HashMap 和 Hashtable 的 6 个区别/index.html","hash":"41ecd1425fa0684fc1b42dc69eeec5123b1ede47","modified":1760583577910},{"_id":"public/2025/10/15/集合/Hashtable 为什么不叫 HashTable？/index.html","hash":"a34813c9049712912668ee33822884600d0c7a77","modified":1760583577910},{"_id":"public/2025/10/15/集合/Java 中初始化 List 集合的 6 种方式!/index.html","hash":"19a2b2080ed24d22bf01a99e5e7dabf1c471a6cc","modified":1760583577910},{"_id":"public/2025/10/15/集合/HashMap, ConcurrentHashMap 原理及源码/index.html","hash":"8ce98bf57683bdc04010634fa8232e86723e4d55","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java10/Java 10 的 10 个新特性，将彻底改变你写代码的方式/index.html","hash":"d0d4e9d48406e09c5b7ef2a42f06905ee5b059c4","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java10/Java 10 局部变量类型推断介绍及实战/index.html","hash":"b2092e996abc3065ca6089bf19fda9a4cd5677ee","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java11/Java 11 正式发布，这 8 个新特性教你写出更牛逼的代码/index.html","hash":"e65af4ae602544b2d252dcbadda187dd15750561","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java8/Java8 之新特性扩展篇/index.html","hash":"8be45510b8d89e72d29bdc8446b992a61a6a157b","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java11/Java 11 已发布，String 还能这样玩/index.html","hash":"28a5feed536e4bb0a534f4794932adbc417e7a38","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java8/Java8 新特性之Lambda表达式/index.html","hash":"e6f1007b571451caac7efdafba0d4876d01e8c89","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java8/Java8 新特性之Optional/index.html","hash":"9f0c4d837b686d9b88c4f46d431ccf72cb5f6c85","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java8/Java8 新特性之函数式接口/index.html","hash":"a77b695fbe24032cbcbf42f20c2adeb6f49ab817","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java8/Java8 新特性之接口默认方法与静态方法/index.html","hash":"dda77ebea50be1d1ab7c5176d352e0b85b192bca","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java8/Java8 新特性之方法引用/index.html","hash":"c2cc601adb1eae1d7f2762d2b9f7920a6b84aae5","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java8/Java8 新特性之重复注解/index.html","hash":"57cfd3a6673e749ed657bcbeca66211705453ef6","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java12/Java 12 骚操作， String居然还能这样玩/index.html","hash":"d58b23b6a40e596b6027e8d61127db90feebec95","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java12/Java 12 骚操作， switch居然还能这样玩！/index.html","hash":"0654624d7be7409f42325e9619886f2fdbcd3c6f","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java12/Java 12 骚操作， 文件比对居然还能这样玩！/index.html","hash":"62fec2b01ccb359d25a8884404d878f810b768f0","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java9/Java9 简化流关闭新姿势/index.html","hash":"e17f82b327b44e24d10a0d50c140d4b6f3752680","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java8/Stream/Java 8 创建 Stream 的 10 种方式，我保证你受益无穷!/index.html","hash":"05fdbd5d0068105583f6ccb48b32d02c09f1535c","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java8/Stream/Java 8 新特性之 Stream 流（一）基础体验/index.html","hash":"f775fb187a603abdfaccb0720fd6898ce2277729","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java8/Stream/Java 8 新特性之 Stream 流（七）流与迭代器，流系列大结局！/index.html","hash":"51e9e966eaa303fbc8e2da4ebd10e6ed75a633c2","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java8/Stream/Java 8 新特性之 Stream 流（三）缩减操作/index.html","hash":"9dae917cf0041ecb4197f00471c4818e9dfb993e","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java8/Stream/Java 8 新特性之 Stream 流（二）关键知识点/index.html","hash":"b44676b78e92310e5e412b7b6fdf9ce101eba746","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java8/Stream/Java 8 新特性之 Stream 流（六）收集/index.html","hash":"38edd7a8ed242926801b90738075fc22e98c6dd7","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java8/Stream/Java 8 新特性之 Stream 流（五）映射/index.html","hash":"ccd62dc7a30a5eb9cea62d9d29bbf64fda85708e","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java8/Stream/Java 8 新特性之 Stream 流（四）并行流/index.html","hash":"478c663cd71feefe441626753e259c78695de48d","modified":1760583577910},{"_id":"public/2025/10/15/新特性/Java8/Stream/Java 8 新特性之Stream流/index.html","hash":"e0981f760d742c7a6bdaf0d91e141e6a60960746","modified":1760583577910},{"_id":"public/2025/10/14/多线程/Synchronized 与 ReentrantLock 的区别！/index.html","hash":"69884f08d693f8bd75df3b17267d8239277238bc","modified":1760583577910},{"_id":"public/2025/10/14/多线程/Java虚拟机对锁优化所做的努力/index.html","hash":"ea7cdbf35dc55b0635fb8ee5587d5553da91f3dd","modified":1760583577910},{"_id":"public/2025/10/14/多线程/Synchronized 有几种用法？/index.html","hash":"32921c5409789ee87102dcab223c6a2bb4f06b60","modified":1760583577910},{"_id":"public/2025/10/14/多线程/sleep( )和wait( )的这5个区别，你知道几个？/index.html","hash":"1ed1b104f564f7455e84cf8a560348feec5cfdbf","modified":1760583577910},{"_id":"public/2025/10/14/多线程/一文搞懂 Java 线程中断/index.html","hash":"8d558936367ae2eee229d21039499a1a382a7726","modified":1760583577910},{"_id":"public/2025/10/14/多线程/出场率比较高的一道多线程安全面试题/index.html","hash":"718997f936840a098a4159e64953b68b71837145","modified":1760583577910},{"_id":"public/2025/10/14/多线程/到底什么是重入锁，拜托，一次搞清楚！/index.html","hash":"f5637ff904a6f87c25f1eaea45ebca978a12adee","modified":1760583577910},{"_id":"public/2025/10/14/多线程/多线程 Thread.yield 方法到底有什么用？/index.html","hash":"baeda373ae2728da1189bd4e55558b1d7e5ae576","modified":1760583577910},{"_id":"public/2025/10/14/多线程/多线程通信的三大法器，你真的会用吗？/index.html","hash":"093c82ab424e634aaba268561271c922749b9f67","modified":1760583577910},{"_id":"public/2025/10/14/多线程/多线程 start 和 run 方法到底有什么区别？/index.html","hash":"3502d52376b006743121f4594c9c1446121fdaf3","modified":1760583577910},{"_id":"public/2025/10/14/多线程/并行任务执行神器 Fork & Join 实战/index.html","hash":"8a7338d0e8c79478f312924821db1524a8a76eb7","modified":1760583577910},{"_id":"public/2025/10/14/多线程/教你如何监控 Java 线程池运行状态/index.html","hash":"ef9a0082f1fb3dd9c267f147f8527a3630eacfe2","modified":1760583577910},{"_id":"public/2025/10/14/多线程/线程休眠只会用Thread.sleep？那就弱爆了！/index.html","hash":"a9e126c768a2b8ea107b0a655d4e0a48d93832f9","modified":1760583577910},{"_id":"public/2025/10/14/多线程/面试官问线程安全的List，看完再也不怕了！/index.html","hash":"1d17479b86729e90be5a5ca3cc271b5da9ea8838","modified":1760583577910},{"_id":"public/2025/10/14/基础/10 个深恶痛绝的 Java 异常/index.html","hash":"cf1c8a9071c41a675eea5d90502f29a83b0cdc86","modified":1760583577910},{"_id":"public/2025/10/14/基础/Java Base64 编码解码方案总结/index.html","hash":"a9e3c20f293d481b19282b6da1aa8234038b2f27","modified":1760583577910},{"_id":"public/2025/10/14/基础/Java 中的基本数据类型转换详解/index.html","hash":"d80fbfed603481e203a46ce023574b43597124ae","modified":1760583577910},{"_id":"public/2025/10/14/基础/Java 父类强制转换子类原则/index.html","hash":"fb5da382a90446d8c1bc80ac8c5a3f1e96467371","modified":1760583577910},{"_id":"public/2025/10/14/基础/Java Jar包压缩、解压使用指南/index.html","hash":"04f644feb3ef451833aea8e9f42c253f9cebfdda","modified":1760583577910},{"_id":"public/2025/10/14/基础/StringBuffer 和 StringBuilder 的 3 个区别/index.html","hash":"9cccaaff1adfce111b8f4ad22ae44cf82816d598","modified":1760583577910},{"_id":"public/2025/10/14/基础/switch case 支持的 6 种数据类型！/index.html","hash":"1c959ec6131634cc77ae13e9357afdc58af36672","modified":1760583577910},{"_id":"public/2025/10/14/基础/switch多值匹配骚操作，带你涨姿势！/index.html","hash":"8b65c5ad2a9fc795c1c39fecd6ae19cddd69f7e3","modified":1760583577910},{"_id":"public/2025/10/14/基础/一张图搞清楚Java异常机制/index.html","hash":"5ce83b720d180adf0c2a44b639968d250534d1eb","modified":1760583577910},{"_id":"public/2025/10/14/基础/你真的搞懂 transient  关键字了吗？/index.html","hash":"c5c211786b90c05bf17130a474b74f1668cf33b5","modified":1760583577910},{"_id":"public/2025/10/14/基础/你真的搞懂 transient 关键字了吗？/index.html","hash":"c1d65bdc829b565a9516d9f1ae4f635d137a2caf","modified":1760583577910},{"_id":"public/2025/10/14/基础/关于 Java 序列化你不知道的 5 件事/index.html","hash":"9fbd48af407d130123cb8f376dbc6ec1ce905fd7","modified":1760583577910},{"_id":"public/2025/10/14/基础/关于Java序列化你应该知道的一切/index.html","hash":"7e9d46f4a9ae9dcd40280d5191d8ca64e4f318ef","modified":1760583577910},{"_id":"public/2025/10/14/基础/坑爹的 Java 可变参数，把我整得够惨。/index.html","hash":"a17f1fcb1224c900670d7e38a9982deadc137474","modified":1760583577910},{"_id":"public/2025/10/14/基础/常见的 3 种 Class 级别的错误/index.html","hash":"7798c86167b934b957f2c69afdbd92b84292d8c0","modified":1760583577910},{"_id":"public/2025/10/14/基础/字符串拼接 + 和 concat 的区别/index.html","hash":"84fee0ed956bcde90d7e58ab8f9eaa21d8cc4321","modified":1760583577910},{"_id":"public/2025/10/14/基础/深入浅出 Java 中的包装类/index.html","hash":"f1f607a81d3cee5047818537f69a9f4f2d13b8c1","modified":1760583577910},{"_id":"public/2025/10/14/基础/通用唯一标识码 UUID 的介绍及使用。/index.html","hash":"559e1ac9cb073cf812ab6682e2214fa5a821df0e","modified":1760583577910},{"_id":"public/2025/10/14/多线程/Java多线程可以分组还能这样玩/index.html","hash":"96f9f9b20de821598efda9cdbc62045a067eba0f","modified":1760583577910},{"_id":"public/2025/10/14/多线程/Java多线程join使用及原理/index.html","hash":"a725c65924523441c09723b3a6f8966327067154","modified":1760583577910},{"_id":"public/2025/10/14/多线程/i++是线程安全的吗？/index.html","hash":"4c5f798f23316163932b548d37192459942e8f3d","modified":1760583577910},{"_id":"public/2025/09/14/JVM/JVM运行时区域详解/index.html","hash":"f4554265b09dba3103cd601c684cc8290ab09d3e","modified":1760583577910},{"_id":"public/archives/index.html","hash":"e3fe7ae908da9a8293a0c365c480b5342c0c74e7","modified":1760583577910},{"_id":"public/2024/12/15/hello-world/index.html","hash":"1b9849f6ae45373ba3c38aca554ac2f83308468a","modified":1760583577910},{"_id":"public/categories/教程/index.html","hash":"a6711622a8b105a2ece0e7e385c08a31ff673904","modified":1760583577910},{"_id":"public/categories/后端/index.html","hash":"aafdac1ff42155dc8cd2ffcb9cbf7fe6c2362f3b","modified":1760583577910},{"_id":"public/categories/后端/page/3/index.html","hash":"6bb9f27efe730e760c265eb18e1c2c24d857b11b","modified":1760583577910},{"_id":"public/categories/后端/page/2/index.html","hash":"5635fae5fcd435fc41c9c5f01a015a5fedd9c5a6","modified":1760583577910},{"_id":"public/categories/后端/page/4/index.html","hash":"8571a63ed9c4f0e0010557f9805a562b7872b453","modified":1760583577910},{"_id":"public/categories/后端/page/5/index.html","hash":"54f11c6c3314a9e480c5a9f52df457ca5f048a7a","modified":1760583577910},{"_id":"public/categories/后端/page/6/index.html","hash":"b4e64d0285b32cc2aabedc68ac75af8d1893b2a6","modified":1760583577910},{"_id":"public/categories/后端/page/7/index.html","hash":"4fd1f3f6bae1a430bfd86a475025a30c193ca3df","modified":1760583577910},{"_id":"public/categories/后端/page/8/index.html","hash":"11e96140c87b368ebdb182ea294ee0fe130f8a47","modified":1760583577910},{"_id":"public/categories/后端/page/9/index.html","hash":"19b5d04783dbf02666eb644676f09bfc600bae30","modified":1760583577910},{"_id":"public/tags/JVM/index.html","hash":"5baea4e8f796f0fe2645826ca055681286b34ace","modified":1760583577910},{"_id":"public/tags/文章/index.html","hash":"667542e4bd7c9ca89b502b2a327a29d4fba19492","modified":1760583577910},{"_id":"public/tags/新特性/index.html","hash":"4df143385b71906ed1522c73edd00c6beb9fffd0","modified":1760583577910},{"_id":"public/tags/新特性/page/2/index.html","hash":"401c91cd5327206621ffc3edd5fceecec23f48ba","modified":1760583577910},{"_id":"public/tags/新特性/page/3/index.html","hash":"55c0aa48843444e50719691d284d212dd37b40d3","modified":1760583577910},{"_id":"public/tags/进阶/index.html","hash":"ea19ff7f21e03cce329b9271b25d799c31ecb877","modified":1760583577910},{"_id":"public/tags/进阶/page/2/index.html","hash":"e4af40abdc7281f28a1338ce0997d77cf6828d30","modified":1760583577910},{"_id":"public/tags/多线程/index.html","hash":"f90be5ba3182a368320aa4ea338905e3d44206b3","modified":1760583577910},{"_id":"public/tags/多线程/page/2/index.html","hash":"dd3986bd2ed37a0a2589b275aafeaac956328f53","modified":1760583577910},{"_id":"public/tags/基础/index.html","hash":"2ea9a35633d33a3980bb05028f39d02636f57174","modified":1760583577910},{"_id":"public/tags/基础/page/2/index.html","hash":"56d244073e35904d2d544d8ec1785fb714212aa1","modified":1760583577910},{"_id":"public/tags/集合/index.html","hash":"bb9d4658d68a0e7c5d835338c767030ba8c40987","modified":1760583577910},{"_id":"public/page/2/index.html","hash":"27eb60ddf649a4e253beb9886e41e4964abf68e0","modified":1760583577910},{"_id":"public/page/5/index.html","hash":"8dd591675de3070105d23c4c9e4ad8682b589526","modified":1760583577910},{"_id":"public/page/4/index.html","hash":"4780f80ab695e58ed8d40bbce140afa41c01f89c","modified":1760583577910},{"_id":"public/page/7/index.html","hash":"b76bb175893ecaf06d083bc08ac7d6ce5ab371fc","modified":1760583577910},{"_id":"public/page/6/index.html","hash":"22d57eb32ead0b00b8b16487fd99bc168369dadc","modified":1760583577910},{"_id":"public/page/3/index.html","hash":"67d3ef4203be03be4e3a6c6113663270f45c6129","modified":1760583577910},{"_id":"public/page/8/index.html","hash":"491b303dafe9d1b3497fd51e1d2870729177b453","modified":1760583577910},{"_id":"public/page/9/index.html","hash":"8f0629831e1b7afe2bcd841f0b84bc93a22d1239","modified":1760583577910},{"_id":"public/police.png","hash":"7ec67ebc6cf0b3c79ec5cdd35b8c48f2fef2d80e","modified":1760583577910},{"_id":"public/logo - 副本.png","hash":"ce91374e148e3391f8f3235b672fa32cd3746d7c","modified":1760583577910},{"_id":"public/favicon/about.txt","hash":"0d732aeb0fbae1e3a711c98a0ad4e04cc079f5e6","modified":1760583577910},{"_id":"public/logo1.png","hash":"ce91374e148e3391f8f3235b672fa32cd3746d7c","modified":1760583577910},{"_id":"public/favicon/apple-touch-icon.png","hash":"662a0af0933fcc0ce3c1cfc12ed07e7ae4306094","modified":1760583577910},{"_id":"public/favicon/favicon-16x16.png","hash":"cb44828efc81002729bbc2396ba85f0e30e63bc4","modified":1760583577910},{"_id":"public/favicon/android-chrome-192x192.png","hash":"ae182103e859a6cf14ea9bc053cf1a4926ea3d21","modified":1760583577910},{"_id":"public/favicon/android-chrome-512x512.png","hash":"ebae4f76f3bb5521ed0655e78a10c235444ad42c","modified":1760583577910},{"_id":"public/favicon/favicon-32x32.png","hash":"763b31f84d7ecf62946eb426692b949d31218b8e","modified":1760583577910},{"_id":"public/favicon/site.webmanifest","hash":"bf31baf91bdd2fcde24a45e3f2a1be33733c6f69","modified":1760583577910},{"_id":"public/favicon/favicon.ico","hash":"27ad4ec726910ba22e33da90ac55a9ac0bfac593","modified":1760583577910},{"_id":"public/css/index.css","hash":"e7c243a4fd04ea6adf8f31f8bbe8366e8ca85987","modified":1760583577910},{"_id":"public/js/fancybox.js","hash":"d638c7b5fc3f87dd44b65c4769dbf97f41834f9f","modified":1760583577910},{"_id":"public/css/markdown.css","hash":"0ac3c0fd374afd4ddac4bfbaf8fefd8baabafa0f","modified":1760583577910},{"_id":"public/css/prism.css","hash":"8f4f3c2c50e06c4c93cea8f65273ba3d69038a36","modified":1760583577910},{"_id":"public/js/search.js","hash":"a6410a3f33b47ee4548d461b6fc6d1785fa36f2b","modified":1760583577910},{"_id":"public/js/prism.js","hash":"b8aad0b4b24ebc2907a60af635b22b4c459541b9","modified":1760583577910},{"_id":"public/logo.png","hash":"763da9c5d814ceced803525677f11337c908de63","modified":1760583577910}],"Category":[{"name":"教程","_id":"cmgsu07690004qkd484knc1h0"},{"name":"后端","_id":"cmgsu076c000aqkd4csl5d6aa"}],"Data":[{"_id":"styles","data":"#page-header.full_page {\n  height: 60vh !important;\n  background-attachment: fixed;\n}\n#page-header.full_page #site-title {\n  font-size: 3.5rem;\n  font-weight: bold;\n  text-shadow: 2px 2px 4px rgba(0,0,0,0.5);\n}\n#page-header.full_page #site-subtitle {\n  font-size: 1.5rem;\n  margin-top: 1rem;\n}\n.recent-post-item {\n  border-radius: 12px;\n  box-shadow: 0 4px 8px rgba(0,0,0,0.1);\n  transition: all 0.3s ease;\n}\n.recent-post-item:hover {\n  transform: translateY(-5px);\n  box-shadow: 0 8px 16px rgba(0,0,0,0.15);\n}\n#aside-content .card-widget {\n  border-radius: 12px;\n  box-shadow: 0 2px 6px rgba(0,0,0,0.1);\n}\n@media screen and (max-width: 768px) {\n  #page-header.full_page {\n    height: 40vh !important;\n  }\n  #page-header.full_page #site-title {\n    font-size: 2.5rem;\n  }\n  #page-header.full_page #site-subtitle {\n    font-size: 1.2rem;\n  }\n}\n"}],"Page":[{"title":"首页","date":"2022-12-31T16:00:00.000Z","layout":"custom-home","_content":"\n## 🎯 最新文章\n\n<%- list_posts({ limit: 5, order: -1 }) %>\n\n## 📚 热门分类\n\n<%- list_categories({\nshow_count: true,\nlimit: 8,\norder: -1,\nstyle: 'list'\n}) %>\n\n## 🔖 热门标签\n\n<%- list_tags({\nshow_count: true,\nlimit: 15,\norder: -1,\nstyle: 'list'\n}) %>","source":"index.md","raw":"---\ntitle: 首页\ndate: 2023-01-01 00:00:00\nlayout: custom-home\n---\n\n## 🎯 最新文章\n\n<%- list_posts({ limit: 5, order: -1 }) %>\n\n## 📚 热门分类\n\n<%- list_categories({\nshow_count: true,\nlimit: 8,\norder: -1,\nstyle: 'list'\n}) %>\n\n## 🔖 热门标签\n\n<%- list_tags({\nshow_count: true,\nlimit: 15,\norder: -1,\nstyle: 'list'\n}) %>","updated":"2025-10-15T10:06:33.232Z","path":"index.html","comments":1,"_id":"cmgsu07630000qkd47ltudnes","content":"<h2 id=\"🎯-最新文章\"><a href=\"#🎯-最新文章\" class=\"headerlink\" title=\"🎯 最新文章\"></a>🎯 最新文章</h2><p>&lt;%- list_posts({ limit: 5, order: -1 }) %&gt;</p>\n<h2 id=\"📚-热门分类\"><a href=\"#📚-热门分类\" class=\"headerlink\" title=\"📚 热门分类\"></a>📚 热门分类</h2><p>&lt;%- list_categories({<br>show_count: true,<br>limit: 8,<br>order: -1,<br>style: ‘list’<br>}) %&gt;</p>\n<h2 id=\"🔖-热门标签\"><a href=\"#🔖-热门标签\" class=\"headerlink\" title=\"🔖 热门标签\"></a>🔖 热门标签</h2><p>&lt;%- list_tags({<br>show_count: true,<br>limit: 15,<br>order: -1,<br>style: ‘list’<br>}) %&gt;</p>\n","excerpt":"","more":"<h2 id=\"🎯-最新文章\"><a href=\"#🎯-最新文章\" class=\"headerlink\" title=\"🎯 最新文章\"></a>🎯 最新文章</h2><p>&lt;%- list_posts({ limit: 5, order: -1 }) %&gt;</p>\n<h2 id=\"📚-热门分类\"><a href=\"#📚-热门分类\" class=\"headerlink\" title=\"📚 热门分类\"></a>📚 热门分类</h2><p>&lt;%- list_categories({<br>show_count: true,<br>limit: 8,<br>order: -1,<br>style: ‘list’<br>}) %&gt;</p>\n<h2 id=\"🔖-热门标签\"><a href=\"#🔖-热门标签\" class=\"headerlink\" title=\"🔖 热门标签\"></a>🔖 热门标签</h2><p>&lt;%- list_tags({<br>show_count: true,<br>limit: 15,<br>order: -1,<br>style: ‘list’<br>}) %&gt;</p>\n"},{"title":"about","date":"2025-10-15T07:40:10.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2025-10-15 15:40:10\n---\n","updated":"2025-10-15T07:40:10.208Z","path":"about/index.html","comments":1,"layout":"page","_id":"cmgsu07680002qkd47j868xxt","content":"","excerpt":"","more":""},{"title":"分类","date":"2022-12-31T16:00:00.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2023-01-01 00:00:00\ntype: \"categories\"\ncomments: false\n---\n","updated":"2025-10-15T08:12:46.510Z","path":"categories/index.html","layout":"page","_id":"cmgsu076a0006qkd432gk4vuk","content":"","excerpt":"","more":""}],"Post":[{"title":"Hello World","date":"2024-12-15T03:36:33.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2024-12-15 11:36:33\ncategory: 教程\ntags: 文章\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"updated":"2025-10-15T08:22:24.471Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu07650001qkd4cw89bbnf","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ hexo new <span class=\"token string\">\"My New Post\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ hexo server<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ hexo generate<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ hexo deploy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ hexo new <span class=\"token string\">\"My New Post\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ hexo server<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ hexo generate<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ hexo deploy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"JVM运行时区域详解","date":"2025-09-14T01:30:25.000Z","_content":"\n我们知道的JVM内存区域有：堆和栈，这是一种泛的分法，也是按运行时区域的一种分法，堆是所有线程共享的一块区域，而栈是线程隔离的，每个线程互不共享。\n\n### 线程不共享区域\n\n每个线程的数据区域包括程序计数器、虚拟机栈和本地方法栈，它们都是在新线程创建时才创建的。\n\n\n##### 程序计数器（Program Counter Rerister）\n\n程序计数器区域一块内存较小的区域，它用于存储线程的每个执行指令，每个线程都有自己的程序计数器，此区域不会有内存溢出的情况。\n\n##### 虚拟机栈（VM Stack）\n\n虚拟机栈描述的是Java方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\n\n##### 本地方法栈（Native Method Stack）\n\n本地方法栈用于支持本地方法（native标识的方法，即非Java语言实现的方法）。 　\n\n虚拟机栈和本地方法栈，当线程请求分配的栈容量超过JVM允许的最大容量时抛出StackOverflowError异常。\n\n线程不共享区域如下图绿色背景所示。\n\n![image](https://www.programcreek.com/wp-content/uploads/2013/04/JVM-runtime-data-area.jpg)\n\n### 线程共享区域\n\n线程共享区域包含：堆和方法区。\n\n##### 堆（Heap）\n\n堆是最常处理的区域，它存储在JVM启动时创建的数组和对象，JVM垃圾收集也主要是在堆上面工作。\n\n如果实际所需的堆超过了自动内存管理系统能提供的最大容量时抛出OutOfMemoryError异常。\n\n##### 方法区（Method Area）\n\n方法区是可供各条线程共享的运行时内存区域。存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法。\n\n当创建类和接口时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大内存空间后就会抛出OutOfMemoryError\n\n##### 运行时常量池（Runtime Constant Pool）\n\n运行时常量池是方法区的一部分，每一个运行时常量池都分配在JVM的方法区中，在类和接口被加载到JVM后，对应的运行时常量池就被创建。运行时常量池是每一个类或接口的常量池（Constant_Pool）的运行时表现形式，它包括了若干种常量：编译器可知的数值字面量到必须运行期解析后才能获得的方法或字段的引用。\n\n如果方法区的内存空间不能满足内存分配请求，那Java虚拟机将抛出一个OutOfMemoryError异常。\n\n![image](https://www.programcreek.com/wp-content/uploads/2013/04/JVM-Stack.png)\n\n栈包含Frames，当调用方法时，Frame被推送到堆栈。一个Frame包含局部变量数组、操作数栈、常量池引用。\n","source":"_posts/JVM/JVM运行时区域详解.md","raw":"---\ntitle: JVM运行时区域详解\ndate: 2025-09-14 09:30:25\ncategory: 后端\ntags: JVM\n---\n\n我们知道的JVM内存区域有：堆和栈，这是一种泛的分法，也是按运行时区域的一种分法，堆是所有线程共享的一块区域，而栈是线程隔离的，每个线程互不共享。\n\n### 线程不共享区域\n\n每个线程的数据区域包括程序计数器、虚拟机栈和本地方法栈，它们都是在新线程创建时才创建的。\n\n\n##### 程序计数器（Program Counter Rerister）\n\n程序计数器区域一块内存较小的区域，它用于存储线程的每个执行指令，每个线程都有自己的程序计数器，此区域不会有内存溢出的情况。\n\n##### 虚拟机栈（VM Stack）\n\n虚拟机栈描述的是Java方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\n\n##### 本地方法栈（Native Method Stack）\n\n本地方法栈用于支持本地方法（native标识的方法，即非Java语言实现的方法）。 　\n\n虚拟机栈和本地方法栈，当线程请求分配的栈容量超过JVM允许的最大容量时抛出StackOverflowError异常。\n\n线程不共享区域如下图绿色背景所示。\n\n![image](https://www.programcreek.com/wp-content/uploads/2013/04/JVM-runtime-data-area.jpg)\n\n### 线程共享区域\n\n线程共享区域包含：堆和方法区。\n\n##### 堆（Heap）\n\n堆是最常处理的区域，它存储在JVM启动时创建的数组和对象，JVM垃圾收集也主要是在堆上面工作。\n\n如果实际所需的堆超过了自动内存管理系统能提供的最大容量时抛出OutOfMemoryError异常。\n\n##### 方法区（Method Area）\n\n方法区是可供各条线程共享的运行时内存区域。存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法。\n\n当创建类和接口时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大内存空间后就会抛出OutOfMemoryError\n\n##### 运行时常量池（Runtime Constant Pool）\n\n运行时常量池是方法区的一部分，每一个运行时常量池都分配在JVM的方法区中，在类和接口被加载到JVM后，对应的运行时常量池就被创建。运行时常量池是每一个类或接口的常量池（Constant_Pool）的运行时表现形式，它包括了若干种常量：编译器可知的数值字面量到必须运行期解析后才能获得的方法或字段的引用。\n\n如果方法区的内存空间不能满足内存分配请求，那Java虚拟机将抛出一个OutOfMemoryError异常。\n\n![image](https://www.programcreek.com/wp-content/uploads/2013/04/JVM-Stack.png)\n\n栈包含Frames，当调用方法时，Frame被推送到堆栈。一个Frame包含局部变量数组、操作数栈、常量池引用。\n","slug":"JVM/JVM运行时区域详解","published":1,"updated":"2025-10-15T10:12:11.562Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu07680003qkd42iuygj9v","content":"<p>我们知道的JVM内存区域有：堆和栈，这是一种泛的分法，也是按运行时区域的一种分法，堆是所有线程共享的一块区域，而栈是线程隔离的，每个线程互不共享。</p>\n<h3 id=\"线程不共享区域\"><a href=\"#线程不共享区域\" class=\"headerlink\" title=\"线程不共享区域\"></a>线程不共享区域</h3><p>每个线程的数据区域包括程序计数器、虚拟机栈和本地方法栈，它们都是在新线程创建时才创建的。</p>\n<h5 id=\"程序计数器（Program-Counter-Rerister）\"><a href=\"#程序计数器（Program-Counter-Rerister）\" class=\"headerlink\" title=\"程序计数器（Program Counter Rerister）\"></a>程序计数器（Program Counter Rerister）</h5><p>程序计数器区域一块内存较小的区域，它用于存储线程的每个执行指令，每个线程都有自己的程序计数器，此区域不会有内存溢出的情况。</p>\n<h5 id=\"虚拟机栈（VM-Stack）\"><a href=\"#虚拟机栈（VM-Stack）\" class=\"headerlink\" title=\"虚拟机栈（VM Stack）\"></a>虚拟机栈（VM Stack）</h5><p>虚拟机栈描述的是Java方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>\n<h5 id=\"本地方法栈（Native-Method-Stack）\"><a href=\"#本地方法栈（Native-Method-Stack）\" class=\"headerlink\" title=\"本地方法栈（Native Method Stack）\"></a>本地方法栈（Native Method Stack）</h5><p>本地方法栈用于支持本地方法（native标识的方法，即非Java语言实现的方法）。 　</p>\n<p>虚拟机栈和本地方法栈，当线程请求分配的栈容量超过JVM允许的最大容量时抛出StackOverflowError异常。</p>\n<p>线程不共享区域如下图绿色背景所示。</p>\n<p><img src=\"https://www.programcreek.com/wp-content/uploads/2013/04/JVM-runtime-data-area.jpg\" alt=\"image\"></p>\n<h3 id=\"线程共享区域\"><a href=\"#线程共享区域\" class=\"headerlink\" title=\"线程共享区域\"></a>线程共享区域</h3><p>线程共享区域包含：堆和方法区。</p>\n<h5 id=\"堆（Heap）\"><a href=\"#堆（Heap）\" class=\"headerlink\" title=\"堆（Heap）\"></a>堆（Heap）</h5><p>堆是最常处理的区域，它存储在JVM启动时创建的数组和对象，JVM垃圾收集也主要是在堆上面工作。</p>\n<p>如果实际所需的堆超过了自动内存管理系统能提供的最大容量时抛出OutOfMemoryError异常。</p>\n<h5 id=\"方法区（Method-Area）\"><a href=\"#方法区（Method-Area）\" class=\"headerlink\" title=\"方法区（Method Area）\"></a>方法区（Method Area）</h5><p>方法区是可供各条线程共享的运行时内存区域。存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法。</p>\n<p>当创建类和接口时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大内存空间后就会抛出OutOfMemoryError</p>\n<h5 id=\"运行时常量池（Runtime-Constant-Pool）\"><a href=\"#运行时常量池（Runtime-Constant-Pool）\" class=\"headerlink\" title=\"运行时常量池（Runtime Constant Pool）\"></a>运行时常量池（Runtime Constant Pool）</h5><p>运行时常量池是方法区的一部分，每一个运行时常量池都分配在JVM的方法区中，在类和接口被加载到JVM后，对应的运行时常量池就被创建。运行时常量池是每一个类或接口的常量池（Constant_Pool）的运行时表现形式，它包括了若干种常量：编译器可知的数值字面量到必须运行期解析后才能获得的方法或字段的引用。</p>\n<p>如果方法区的内存空间不能满足内存分配请求，那Java虚拟机将抛出一个OutOfMemoryError异常。</p>\n<p><img src=\"https://www.programcreek.com/wp-content/uploads/2013/04/JVM-Stack.png\" alt=\"image\"></p>\n<p>栈包含Frames，当调用方法时，Frame被推送到堆栈。一个Frame包含局部变量数组、操作数栈、常量池引用。</p>\n","excerpt":"","more":"<p>我们知道的JVM内存区域有：堆和栈，这是一种泛的分法，也是按运行时区域的一种分法，堆是所有线程共享的一块区域，而栈是线程隔离的，每个线程互不共享。</p>\n<h3 id=\"线程不共享区域\"><a href=\"#线程不共享区域\" class=\"headerlink\" title=\"线程不共享区域\"></a>线程不共享区域</h3><p>每个线程的数据区域包括程序计数器、虚拟机栈和本地方法栈，它们都是在新线程创建时才创建的。</p>\n<h5 id=\"程序计数器（Program-Counter-Rerister）\"><a href=\"#程序计数器（Program-Counter-Rerister）\" class=\"headerlink\" title=\"程序计数器（Program Counter Rerister）\"></a>程序计数器（Program Counter Rerister）</h5><p>程序计数器区域一块内存较小的区域，它用于存储线程的每个执行指令，每个线程都有自己的程序计数器，此区域不会有内存溢出的情况。</p>\n<h5 id=\"虚拟机栈（VM-Stack）\"><a href=\"#虚拟机栈（VM-Stack）\" class=\"headerlink\" title=\"虚拟机栈（VM Stack）\"></a>虚拟机栈（VM Stack）</h5><p>虚拟机栈描述的是Java方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>\n<h5 id=\"本地方法栈（Native-Method-Stack）\"><a href=\"#本地方法栈（Native-Method-Stack）\" class=\"headerlink\" title=\"本地方法栈（Native Method Stack）\"></a>本地方法栈（Native Method Stack）</h5><p>本地方法栈用于支持本地方法（native标识的方法，即非Java语言实现的方法）。 　</p>\n<p>虚拟机栈和本地方法栈，当线程请求分配的栈容量超过JVM允许的最大容量时抛出StackOverflowError异常。</p>\n<p>线程不共享区域如下图绿色背景所示。</p>\n<p><img src=\"https://www.programcreek.com/wp-content/uploads/2013/04/JVM-runtime-data-area.jpg\" alt=\"image\"></p>\n<h3 id=\"线程共享区域\"><a href=\"#线程共享区域\" class=\"headerlink\" title=\"线程共享区域\"></a>线程共享区域</h3><p>线程共享区域包含：堆和方法区。</p>\n<h5 id=\"堆（Heap）\"><a href=\"#堆（Heap）\" class=\"headerlink\" title=\"堆（Heap）\"></a>堆（Heap）</h5><p>堆是最常处理的区域，它存储在JVM启动时创建的数组和对象，JVM垃圾收集也主要是在堆上面工作。</p>\n<p>如果实际所需的堆超过了自动内存管理系统能提供的最大容量时抛出OutOfMemoryError异常。</p>\n<h5 id=\"方法区（Method-Area）\"><a href=\"#方法区（Method-Area）\" class=\"headerlink\" title=\"方法区（Method Area）\"></a>方法区（Method Area）</h5><p>方法区是可供各条线程共享的运行时内存区域。存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法。</p>\n<p>当创建类和接口时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大内存空间后就会抛出OutOfMemoryError</p>\n<h5 id=\"运行时常量池（Runtime-Constant-Pool）\"><a href=\"#运行时常量池（Runtime-Constant-Pool）\" class=\"headerlink\" title=\"运行时常量池（Runtime Constant Pool）\"></a>运行时常量池（Runtime Constant Pool）</h5><p>运行时常量池是方法区的一部分，每一个运行时常量池都分配在JVM的方法区中，在类和接口被加载到JVM后，对应的运行时常量池就被创建。运行时常量池是每一个类或接口的常量池（Constant_Pool）的运行时表现形式，它包括了若干种常量：编译器可知的数值字面量到必须运行期解析后才能获得的方法或字段的引用。</p>\n<p>如果方法区的内存空间不能满足内存分配请求，那Java虚拟机将抛出一个OutOfMemoryError异常。</p>\n<p><img src=\"https://www.programcreek.com/wp-content/uploads/2013/04/JVM-Stack.png\" alt=\"image\"></p>\n<p>栈包含Frames，当调用方法时，Frame被推送到堆栈。一个Frame包含局部变量数组、操作数栈、常量池引用。</p>\n"},{"title":"Java 5 ~ 10 新特性倾情整理！","date":"2025-10-15T03:36:33.000Z","_content":"\n最近连 JDK11都在准备发布的路上了，大家都整明白了吗？也许现在大部分人还在用6-8，8的新特性都没用熟，9刚出不久，10-11就不用说了。\n\n为了大家对JDK有一个全面的了解，下面我为大家整理了JDK5~10的所有关键新特性！\n\n**JDK5新特性**\n\n- 自动装箱与拆箱\n- 枚举\n- 静态导入\n- 可变参数（Varargs）\n- 内省（introspector）\n- 泛型（Generic）\n- For-Each循环\n\n**JDK6新特性**\n\n- Desktop类和SystemTray类\n- 使用JAXB2来实现对象与XML之间的映射\n- 理解STAX\n- 使用Compiler API\n- 轻量级 Http Server API\n- 插入式注解处理 API\n- 使用Console开发控制台程序\n- 对脚本语言的支持\n- Common Annotations\n- Java GUI界面的显示\n- 嵌入式数据库Derby\n- Web服务元数据\n- Jtable的排序和过滤\n- 更简单更强大的JAX-WS\n\n**JDK7新特性**\n\n- switch中可以使用字符串了\n- 泛型实例化类型自动推断\n- 自定义自动关闭类\n- 新增一些读取环境信息的工具方法\n- Boolean类型反转，空指针安全，参与位运算\n- 两个char之间的equals\n- 安全的加减乘除|sd\n- 对Java集合( Collections）的增强支持\n- 数值可加下划线\n- 支持二进制数字\n- 在try/catch异常扑捉中，一个catch可以写多个异常类型用|隔开\n- 可以不必要写finally语句来关闭资源，只要你在try()的括号内部定义要使用的资源\n\n**JDK8新特性**\n\n- 接口的默认方法\n- Lambda表达式\n- 函数式接口\n- 方法与构造函数引用\n- 扩展了集合类\n- 新的Date API\n- Annotation多重注解\n- streams（流）\n- parallel streams(并行流)\n- Map数据结构改进\n\n**JDK9新特性**\n\n- Jigsaw模块化项目\n- 简化进程API\n- 轻量级JSON API\n- 钱和货币的API\n- 改善锁竞争机制\n- 代码分段缓存\n- 智能java编译\n- http2.0客户端\n- kulla计划\n\n**JDK10新特性**\n\n- 局部变量的类型推断\n- GC改进和内存管理\n- 线程本地握手\n- 备用内存设备上的堆分配\n- 其他Unicode语言 - 标记扩展\n- 基于Java的实验性JIT编译器\n- 开源根证书\n- 根证书颁发认证（CA）\n- 将JDK生态整合单个存储库\n- 删除工具javah\n\n怎么样，这些新特性都知道多少？都用过多少？多学习这些新特性，对写代码的效率、逼格、技能成长、就业还是会很有帮助的。\n\n","source":"_posts/新特性/Java 5 ~ 10 新特性倾情整理！.md","raw":"---\ntitle: Java 5 ~ 10 新特性倾情整理！\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n\n最近连 JDK11都在准备发布的路上了，大家都整明白了吗？也许现在大部分人还在用6-8，8的新特性都没用熟，9刚出不久，10-11就不用说了。\n\n为了大家对JDK有一个全面的了解，下面我为大家整理了JDK5~10的所有关键新特性！\n\n**JDK5新特性**\n\n- 自动装箱与拆箱\n- 枚举\n- 静态导入\n- 可变参数（Varargs）\n- 内省（introspector）\n- 泛型（Generic）\n- For-Each循环\n\n**JDK6新特性**\n\n- Desktop类和SystemTray类\n- 使用JAXB2来实现对象与XML之间的映射\n- 理解STAX\n- 使用Compiler API\n- 轻量级 Http Server API\n- 插入式注解处理 API\n- 使用Console开发控制台程序\n- 对脚本语言的支持\n- Common Annotations\n- Java GUI界面的显示\n- 嵌入式数据库Derby\n- Web服务元数据\n- Jtable的排序和过滤\n- 更简单更强大的JAX-WS\n\n**JDK7新特性**\n\n- switch中可以使用字符串了\n- 泛型实例化类型自动推断\n- 自定义自动关闭类\n- 新增一些读取环境信息的工具方法\n- Boolean类型反转，空指针安全，参与位运算\n- 两个char之间的equals\n- 安全的加减乘除|sd\n- 对Java集合( Collections）的增强支持\n- 数值可加下划线\n- 支持二进制数字\n- 在try/catch异常扑捉中，一个catch可以写多个异常类型用|隔开\n- 可以不必要写finally语句来关闭资源，只要你在try()的括号内部定义要使用的资源\n\n**JDK8新特性**\n\n- 接口的默认方法\n- Lambda表达式\n- 函数式接口\n- 方法与构造函数引用\n- 扩展了集合类\n- 新的Date API\n- Annotation多重注解\n- streams（流）\n- parallel streams(并行流)\n- Map数据结构改进\n\n**JDK9新特性**\n\n- Jigsaw模块化项目\n- 简化进程API\n- 轻量级JSON API\n- 钱和货币的API\n- 改善锁竞争机制\n- 代码分段缓存\n- 智能java编译\n- http2.0客户端\n- kulla计划\n\n**JDK10新特性**\n\n- 局部变量的类型推断\n- GC改进和内存管理\n- 线程本地握手\n- 备用内存设备上的堆分配\n- 其他Unicode语言 - 标记扩展\n- 基于Java的实验性JIT编译器\n- 开源根证书\n- 根证书颁发认证（CA）\n- 将JDK生态整合单个存储库\n- 删除工具javah\n\n怎么样，这些新特性都知道多少？都用过多少？多学习这些新特性，对写代码的效率、逼格、技能成长、就业还是会很有帮助的。\n\n","slug":"新特性/Java 5 ~ 10 新特性倾情整理！","published":1,"updated":"2025-10-15T07:20:51.376Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076a0007qkd413e6bn54","content":"<p>最近连 JDK11都在准备发布的路上了，大家都整明白了吗？也许现在大部分人还在用6-8，8的新特性都没用熟，9刚出不久，10-11就不用说了。</p>\n<p>为了大家对JDK有一个全面的了解，下面我为大家整理了JDK5~10的所有关键新特性！</p>\n<p><strong>JDK5新特性</strong></p>\n<ul>\n<li>自动装箱与拆箱</li>\n<li>枚举</li>\n<li>静态导入</li>\n<li>可变参数（Varargs）</li>\n<li>内省（introspector）</li>\n<li>泛型（Generic）</li>\n<li>For-Each循环</li>\n</ul>\n<p><strong>JDK6新特性</strong></p>\n<ul>\n<li>Desktop类和SystemTray类</li>\n<li>使用JAXB2来实现对象与XML之间的映射</li>\n<li>理解STAX</li>\n<li>使用Compiler API</li>\n<li>轻量级 Http Server API</li>\n<li>插入式注解处理 API</li>\n<li>使用Console开发控制台程序</li>\n<li>对脚本语言的支持</li>\n<li>Common Annotations</li>\n<li>Java GUI界面的显示</li>\n<li>嵌入式数据库Derby</li>\n<li>Web服务元数据</li>\n<li>Jtable的排序和过滤</li>\n<li>更简单更强大的JAX-WS</li>\n</ul>\n<p><strong>JDK7新特性</strong></p>\n<ul>\n<li>switch中可以使用字符串了</li>\n<li>泛型实例化类型自动推断</li>\n<li>自定义自动关闭类</li>\n<li>新增一些读取环境信息的工具方法</li>\n<li>Boolean类型反转，空指针安全，参与位运算</li>\n<li>两个char之间的equals</li>\n<li>安全的加减乘除|sd</li>\n<li>对Java集合( Collections）的增强支持</li>\n<li>数值可加下划线</li>\n<li>支持二进制数字</li>\n<li>在try&#x2F;catch异常扑捉中，一个catch可以写多个异常类型用|隔开</li>\n<li>可以不必要写finally语句来关闭资源，只要你在try()的括号内部定义要使用的资源</li>\n</ul>\n<p><strong>JDK8新特性</strong></p>\n<ul>\n<li>接口的默认方法</li>\n<li>Lambda表达式</li>\n<li>函数式接口</li>\n<li>方法与构造函数引用</li>\n<li>扩展了集合类</li>\n<li>新的Date API</li>\n<li>Annotation多重注解</li>\n<li>streams（流）</li>\n<li>parallel streams(并行流)</li>\n<li>Map数据结构改进</li>\n</ul>\n<p><strong>JDK9新特性</strong></p>\n<ul>\n<li>Jigsaw模块化项目</li>\n<li>简化进程API</li>\n<li>轻量级JSON API</li>\n<li>钱和货币的API</li>\n<li>改善锁竞争机制</li>\n<li>代码分段缓存</li>\n<li>智能java编译</li>\n<li>http2.0客户端</li>\n<li>kulla计划</li>\n</ul>\n<p><strong>JDK10新特性</strong></p>\n<ul>\n<li>局部变量的类型推断</li>\n<li>GC改进和内存管理</li>\n<li>线程本地握手</li>\n<li>备用内存设备上的堆分配</li>\n<li>其他Unicode语言 - 标记扩展</li>\n<li>基于Java的实验性JIT编译器</li>\n<li>开源根证书</li>\n<li>根证书颁发认证（CA）</li>\n<li>将JDK生态整合单个存储库</li>\n<li>删除工具javah</li>\n</ul>\n<p>怎么样，这些新特性都知道多少？都用过多少？多学习这些新特性，对写代码的效率、逼格、技能成长、就业还是会很有帮助的。</p>\n","excerpt":"","more":"<p>最近连 JDK11都在准备发布的路上了，大家都整明白了吗？也许现在大部分人还在用6-8，8的新特性都没用熟，9刚出不久，10-11就不用说了。</p>\n<p>为了大家对JDK有一个全面的了解，下面我为大家整理了JDK5~10的所有关键新特性！</p>\n<p><strong>JDK5新特性</strong></p>\n<ul>\n<li>自动装箱与拆箱</li>\n<li>枚举</li>\n<li>静态导入</li>\n<li>可变参数（Varargs）</li>\n<li>内省（introspector）</li>\n<li>泛型（Generic）</li>\n<li>For-Each循环</li>\n</ul>\n<p><strong>JDK6新特性</strong></p>\n<ul>\n<li>Desktop类和SystemTray类</li>\n<li>使用JAXB2来实现对象与XML之间的映射</li>\n<li>理解STAX</li>\n<li>使用Compiler API</li>\n<li>轻量级 Http Server API</li>\n<li>插入式注解处理 API</li>\n<li>使用Console开发控制台程序</li>\n<li>对脚本语言的支持</li>\n<li>Common Annotations</li>\n<li>Java GUI界面的显示</li>\n<li>嵌入式数据库Derby</li>\n<li>Web服务元数据</li>\n<li>Jtable的排序和过滤</li>\n<li>更简单更强大的JAX-WS</li>\n</ul>\n<p><strong>JDK7新特性</strong></p>\n<ul>\n<li>switch中可以使用字符串了</li>\n<li>泛型实例化类型自动推断</li>\n<li>自定义自动关闭类</li>\n<li>新增一些读取环境信息的工具方法</li>\n<li>Boolean类型反转，空指针安全，参与位运算</li>\n<li>两个char之间的equals</li>\n<li>安全的加减乘除|sd</li>\n<li>对Java集合( Collections）的增强支持</li>\n<li>数值可加下划线</li>\n<li>支持二进制数字</li>\n<li>在try&#x2F;catch异常扑捉中，一个catch可以写多个异常类型用|隔开</li>\n<li>可以不必要写finally语句来关闭资源，只要你在try()的括号内部定义要使用的资源</li>\n</ul>\n<p><strong>JDK8新特性</strong></p>\n<ul>\n<li>接口的默认方法</li>\n<li>Lambda表达式</li>\n<li>函数式接口</li>\n<li>方法与构造函数引用</li>\n<li>扩展了集合类</li>\n<li>新的Date API</li>\n<li>Annotation多重注解</li>\n<li>streams（流）</li>\n<li>parallel streams(并行流)</li>\n<li>Map数据结构改进</li>\n</ul>\n<p><strong>JDK9新特性</strong></p>\n<ul>\n<li>Jigsaw模块化项目</li>\n<li>简化进程API</li>\n<li>轻量级JSON API</li>\n<li>钱和货币的API</li>\n<li>改善锁竞争机制</li>\n<li>代码分段缓存</li>\n<li>智能java编译</li>\n<li>http2.0客户端</li>\n<li>kulla计划</li>\n</ul>\n<p><strong>JDK10新特性</strong></p>\n<ul>\n<li>局部变量的类型推断</li>\n<li>GC改进和内存管理</li>\n<li>线程本地握手</li>\n<li>备用内存设备上的堆分配</li>\n<li>其他Unicode语言 - 标记扩展</li>\n<li>基于Java的实验性JIT编译器</li>\n<li>开源根证书</li>\n<li>根证书颁发认证（CA）</li>\n<li>将JDK生态整合单个存储库</li>\n<li>删除工具javah</li>\n</ul>\n<p>怎么样，这些新特性都知道多少？都用过多少？多学习这些新特性，对写代码的效率、逼格、技能成长、就业还是会很有帮助的。</p>\n"},{"title":"Java 中的 String 真的是不可变吗？","date":"2025-10-15T03:36:33.000Z","_content":"\n我们都知道 Java 中的 String 类的设计是不可变的，来看下 String 类的源码。\n\n```\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    \n    /** The value is used for character storage. */\n    private final char value[];\n    \n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n    \n    // ...\n    \n}\n```\n\n可以看出 String 类是 final 类型的，String 不能被继承。其值 value 也就是对字符数组的封装，即 char[]，其值被定义成 private final 的，说明不能通过外界修改，即不可变。\n\n### String 真的 \"不可变 \" 吗？\n\n来看下面这个例子。\n\n```\nString str = \"Python\";\nSystem.out.println(str); // Python\n\nstr = \"Java\";\nSystem.out.println(str); // Java\n\nstr = str.substring(1);\nSystem.out.println(str); // ava\n```\n\n**你有可能会问：str 不是由 Python 变成 Java 了吗？然后通过 substring 方法变成 ava 了吗？**\n\n这其实是初学者的一个误区，从上面看 String 的结构可以得知字符串是由字符数组构成的，str 只是一个引用而已，第一次引用了 \"Python\"，后面变成了 \"Java\"，而 substring 也是用 Arrays.copyOfRange 方法重新复制字符数组构造了一个新的字符串。\n\n![](http://img.javastack.cn/18-9-12/688492.jpg)\n\n所以说，这里的字符串并不是可变，只是变更了字符串引用。\n\n关于 substring 在 JDK 各个版本的差异可以看这篇文章《[注意：字符串substring方法在jkd6,7,8中的差异](https://mp.weixin.qq.com/s/3KrBept61jDAtheR27gFJA)》，也可以去看 substring 的各个版本的源码。\n\n### String 真的真的真的 \"不可变 \" 吗？\n\n上面的例子肯定是不可变的，下面这个就尴尬了。\n\n```\nString str = \"Hello Python\";\nSystem.out.println(str); // Hello Python\n\nField field = String.class.getDeclaredField(\"value\");\nfield.setAccessible(true);\n\nchar[] value = (char[])field.get(str);\nvalue[6] = 'J';\nvalue[7] = 'a';\nvalue[8] = 'v';\nvalue[9] = 'a';\nvalue[10] = '!';\nvalue[11] = '!';\nSystem.out.println(str); // Hello Java!!\n```\n\n通过反射，我们改变了底层的字符数组的值，实现了字符串的 “不可变” 性，这是一种骚操作，不建议这么使用，违反了 Java 对 String 类的不可变设计原则，会造成一些安全问题。\n\n是不是又涨姿势了？分享给你的朋友们吧！\n\n","source":"_posts/进阶/Java 中的 String 真的是不可变吗？.md","raw":"---\ntitle: Java 中的 String 真的是不可变吗？\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 进阶\n---\n\n我们都知道 Java 中的 String 类的设计是不可变的，来看下 String 类的源码。\n\n```\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    \n    /** The value is used for character storage. */\n    private final char value[];\n    \n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n    \n    // ...\n    \n}\n```\n\n可以看出 String 类是 final 类型的，String 不能被继承。其值 value 也就是对字符数组的封装，即 char[]，其值被定义成 private final 的，说明不能通过外界修改，即不可变。\n\n### String 真的 \"不可变 \" 吗？\n\n来看下面这个例子。\n\n```\nString str = \"Python\";\nSystem.out.println(str); // Python\n\nstr = \"Java\";\nSystem.out.println(str); // Java\n\nstr = str.substring(1);\nSystem.out.println(str); // ava\n```\n\n**你有可能会问：str 不是由 Python 变成 Java 了吗？然后通过 substring 方法变成 ava 了吗？**\n\n这其实是初学者的一个误区，从上面看 String 的结构可以得知字符串是由字符数组构成的，str 只是一个引用而已，第一次引用了 \"Python\"，后面变成了 \"Java\"，而 substring 也是用 Arrays.copyOfRange 方法重新复制字符数组构造了一个新的字符串。\n\n![](http://img.javastack.cn/18-9-12/688492.jpg)\n\n所以说，这里的字符串并不是可变，只是变更了字符串引用。\n\n关于 substring 在 JDK 各个版本的差异可以看这篇文章《[注意：字符串substring方法在jkd6,7,8中的差异](https://mp.weixin.qq.com/s/3KrBept61jDAtheR27gFJA)》，也可以去看 substring 的各个版本的源码。\n\n### String 真的真的真的 \"不可变 \" 吗？\n\n上面的例子肯定是不可变的，下面这个就尴尬了。\n\n```\nString str = \"Hello Python\";\nSystem.out.println(str); // Hello Python\n\nField field = String.class.getDeclaredField(\"value\");\nfield.setAccessible(true);\n\nchar[] value = (char[])field.get(str);\nvalue[6] = 'J';\nvalue[7] = 'a';\nvalue[8] = 'v';\nvalue[9] = 'a';\nvalue[10] = '!';\nvalue[11] = '!';\nSystem.out.println(str); // Hello Java!!\n```\n\n通过反射，我们改变了底层的字符数组的值，实现了字符串的 “不可变” 性，这是一种骚操作，不建议这么使用，违反了 Java 对 String 类的不可变设计原则，会造成一些安全问题。\n\n是不是又涨姿势了？分享给你的朋友们吧！\n\n","slug":"进阶/Java 中的 String 真的是不可变吗？","published":1,"updated":"2025-10-15T07:21:14.230Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076b0008qkd4ht4ig6e4","content":"<p>我们都知道 Java 中的 String 类的设计是不可变的，来看下 String 类的源码。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public final class String\n    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;\n    \n    &#x2F;** The value is used for character storage. *&#x2F;\n    private final char value[];\n    \n    &#x2F;** Cache the hash code for the string *&#x2F;\n    private int hash; &#x2F;&#x2F; Default to 0\n    \n    &#x2F;&#x2F; ...\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出 String 类是 final 类型的，String 不能被继承。其值 value 也就是对字符数组的封装，即 char[]，其值被定义成 private final 的，说明不能通过外界修改，即不可变。</p>\n<h3 id=\"String-真的-“不可变-“-吗？\"><a href=\"#String-真的-“不可变-“-吗？\" class=\"headerlink\" title=\"String 真的 “不可变 “ 吗？\"></a>String 真的 “不可变 “ 吗？</h3><p>来看下面这个例子。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">String str &#x3D; &quot;Python&quot;;\nSystem.out.println(str); &#x2F;&#x2F; Python\n\nstr &#x3D; &quot;Java&quot;;\nSystem.out.println(str); &#x2F;&#x2F; Java\n\nstr &#x3D; str.substring(1);\nSystem.out.println(str); &#x2F;&#x2F; ava<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>你有可能会问：str 不是由 Python 变成 Java 了吗？然后通过 substring 方法变成 ava 了吗？</strong></p>\n<p>这其实是初学者的一个误区，从上面看 String 的结构可以得知字符串是由字符数组构成的，str 只是一个引用而已，第一次引用了 “Python”，后面变成了 “Java”，而 substring 也是用 Arrays.copyOfRange 方法重新复制字符数组构造了一个新的字符串。</p>\n<p><img src=\"http://img.javastack.cn/18-9-12/688492.jpg\"></p>\n<p>所以说，这里的字符串并不是可变，只是变更了字符串引用。</p>\n<p>关于 substring 在 JDK 各个版本的差异可以看这篇文章《<a href=\"https://mp.weixin.qq.com/s/3KrBept61jDAtheR27gFJA\">注意：字符串substring方法在jkd6,7,8中的差异</a>》，也可以去看 substring 的各个版本的源码。</p>\n<h3 id=\"String-真的真的真的-“不可变-“-吗？\"><a href=\"#String-真的真的真的-“不可变-“-吗？\" class=\"headerlink\" title=\"String 真的真的真的 “不可变 “ 吗？\"></a>String 真的真的真的 “不可变 “ 吗？</h3><p>上面的例子肯定是不可变的，下面这个就尴尬了。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">String str &#x3D; &quot;Hello Python&quot;;\nSystem.out.println(str); &#x2F;&#x2F; Hello Python\n\nField field &#x3D; String.class.getDeclaredField(&quot;value&quot;);\nfield.setAccessible(true);\n\nchar[] value &#x3D; (char[])field.get(str);\nvalue[6] &#x3D; &#39;J&#39;;\nvalue[7] &#x3D; &#39;a&#39;;\nvalue[8] &#x3D; &#39;v&#39;;\nvalue[9] &#x3D; &#39;a&#39;;\nvalue[10] &#x3D; &#39;!&#39;;\nvalue[11] &#x3D; &#39;!&#39;;\nSystem.out.println(str); &#x2F;&#x2F; Hello Java!!<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>通过反射，我们改变了底层的字符数组的值，实现了字符串的 “不可变” 性，这是一种骚操作，不建议这么使用，违反了 Java 对 String 类的不可变设计原则，会造成一些安全问题。</p>\n<p>是不是又涨姿势了？分享给你的朋友们吧！</p>\n","excerpt":"","more":"<p>我们都知道 Java 中的 String 类的设计是不可变的，来看下 String 类的源码。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public final class String\n    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;\n    \n    &#x2F;** The value is used for character storage. *&#x2F;\n    private final char value[];\n    \n    &#x2F;** Cache the hash code for the string *&#x2F;\n    private int hash; &#x2F;&#x2F; Default to 0\n    \n    &#x2F;&#x2F; ...\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出 String 类是 final 类型的，String 不能被继承。其值 value 也就是对字符数组的封装，即 char[]，其值被定义成 private final 的，说明不能通过外界修改，即不可变。</p>\n<h3 id=\"String-真的-“不可变-“-吗？\"><a href=\"#String-真的-“不可变-“-吗？\" class=\"headerlink\" title=\"String 真的 “不可变 “ 吗？\"></a>String 真的 “不可变 “ 吗？</h3><p>来看下面这个例子。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">String str &#x3D; &quot;Python&quot;;\nSystem.out.println(str); &#x2F;&#x2F; Python\n\nstr &#x3D; &quot;Java&quot;;\nSystem.out.println(str); &#x2F;&#x2F; Java\n\nstr &#x3D; str.substring(1);\nSystem.out.println(str); &#x2F;&#x2F; ava<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>你有可能会问：str 不是由 Python 变成 Java 了吗？然后通过 substring 方法变成 ava 了吗？</strong></p>\n<p>这其实是初学者的一个误区，从上面看 String 的结构可以得知字符串是由字符数组构成的，str 只是一个引用而已，第一次引用了 “Python”，后面变成了 “Java”，而 substring 也是用 Arrays.copyOfRange 方法重新复制字符数组构造了一个新的字符串。</p>\n<p><img src=\"http://img.javastack.cn/18-9-12/688492.jpg\"></p>\n<p>所以说，这里的字符串并不是可变，只是变更了字符串引用。</p>\n<p>关于 substring 在 JDK 各个版本的差异可以看这篇文章《<a href=\"https://mp.weixin.qq.com/s/3KrBept61jDAtheR27gFJA\">注意：字符串substring方法在jkd6,7,8中的差异</a>》，也可以去看 substring 的各个版本的源码。</p>\n<h3 id=\"String-真的真的真的-“不可变-“-吗？\"><a href=\"#String-真的真的真的-“不可变-“-吗？\" class=\"headerlink\" title=\"String 真的真的真的 “不可变 “ 吗？\"></a>String 真的真的真的 “不可变 “ 吗？</h3><p>上面的例子肯定是不可变的，下面这个就尴尬了。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">String str &#x3D; &quot;Hello Python&quot;;\nSystem.out.println(str); &#x2F;&#x2F; Hello Python\n\nField field &#x3D; String.class.getDeclaredField(&quot;value&quot;);\nfield.setAccessible(true);\n\nchar[] value &#x3D; (char[])field.get(str);\nvalue[6] &#x3D; &#39;J&#39;;\nvalue[7] &#x3D; &#39;a&#39;;\nvalue[8] &#x3D; &#39;v&#39;;\nvalue[9] &#x3D; &#39;a&#39;;\nvalue[10] &#x3D; &#39;!&#39;;\nvalue[11] &#x3D; &#39;!&#39;;\nSystem.out.println(str); &#x2F;&#x2F; Hello Java!!<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>通过反射，我们改变了底层的字符数组的值，实现了字符串的 “不可变” 性，这是一种骚操作，不建议这么使用，违反了 Java 对 String 类的不可变设计原则，会造成一些安全问题。</p>\n<p>是不是又涨姿势了？分享给你的朋友们吧！</p>\n"},{"title":"Java 中的 6 颗语法糖","date":"2025-10-15T03:36:33.000Z","_content":"\n\n语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言本身功能来说没有什么影响，只是为了方便程序员的开发，提高开发效率。说白了，语法糖就是对现有语法的一个封装。\n\nJava作为一种与平台无关的高级语言，当然也含有语法糖，这些语法糖并不被虚拟机所支持，在编译成字节码阶段就自动转换成简单常用语法。\n\n**一般来说Java中的语法糖主要有以下几种：** \n\n1. 泛型与类型擦除 \n2. 自动装箱与拆箱\n3. 变长参数\n4. 增强for循环 \n5. 内部类\n6. 枚举类\n\n**泛型与类型擦除**\n\nJava语言并不是一开始就支持泛型的。在早期的JDK中，只能通过Object类是所有类型的父类和强制类型转换来实现泛型的功能。强制类型转换的缺点就是把编译期间的问题延迟到运行时，JVM并不能为我们提供编译期间的检查。\n\n在JDK1.5中，Java语言引入了泛型机制。但是这种泛型机制是通过类型擦除来实现的，即Java中的泛型只在程序源代码中有效（源代码阶段提供类型检查），在编译后的字节码中自动用强制类型转换进行替代。也就是说，Java语言中的泛型机制其实就是一颗语法糖，相较与C++、C#相比，其泛型实现实在是不那么优雅。\n\n\n```\n/**\n* 在源代码中存在泛型\n*/\npublic static void main(String[] args) {\n    Map<String,String> map = new HashMap<String,String>();\n    map.put(\"hello\",\"你好\");\n    String hello = map.get(\"hello\");\n    System.out.println(hello);\n}\n```\n\n当上述源代码被编译为class文件后，泛型被擦除且引入强制类型转换\n\n\n```\npublic static void main(String[] args) {\n    HashMap map = new HashMap(); //类型擦除\n    map.put(\"hello\", \"你好\");\n    String hello = (String)map.get(\"hello\");//强制转换\n    System.out.println(hello);\n}\n```\n\n\n**自动装箱与拆箱**\n\nJava中的自动装箱与拆箱指的是基本数据类型与他们的包装类型之间的相互转换。\n\n我们知道Java是一门面向对象的语言，在Java世界中有一句话是这么说的：“万物皆对象”。但是Java中的基本数据类型却不是对象，他们不需要进行new操作，也不能调用任何方法，这在使用的时候有诸多不便。因此Java为这些基本类型提供了包装类，并且为了使用方便，提供了自动装箱与拆箱功能。自动装箱与拆箱在使用的过程中，其实是一个语法糖，内部还是调用了相应的函数进行转换。\n\n下面代码演示了自动装箱和拆箱功能\n\n\n```\npublic static void main(String[] args) {\n    Integer a = 1;\n    int b = 2;\n    int c = a + b;\n    System.out.println(c);\n}\n```\n\n经过编译后，代码如下\n\n\n```\npublic static void main(String[] args) {\n    Integer a = Integer.valueOf(1); // 自动装箱\n    byte b = 2;\n    int c = a.intValue() + b;//自动拆箱\n    System.out.println(c);\n}\n```\n\n**变长参数**\n\n所谓变长参数，就是方法可以接受长度不定确定的参数。变长参数特性是在JDK1.5中引入的，使用变长参数有两个条件，一是变长的那一部分参数具有相同的类型，二是变长参数必须位于方法参数列表的最后面。变长参数同样是Java中的语法糖，其内部实现是Java数组。\n\n\n```\npublic class Varargs {\n    public static void print(String... args) {\n        for(String str : args){\n            System.out.println(str);\n        }\n    }\n\n    public static void main(String[] args) {\n        print(\"hello\", \"world\");\n    }\n}\n```\n\n编译为class文件后如下，从中可以很明显的看出变长参数内部是通过数组实现的\n\n\n```\npublic class Varargs {\n    public Varargs() {\n    }\n\n    public static void print(String... args) {\n        String[] var1 = args;\n        int var2 = args.length;\n        //增强for循环的数组实现方式\n        for(int var3 = 0; var3 < var2; ++var3) {\n            String str = var1[var3];\n            System.out.println(str);\n        }\n\n    }\n\n    public static void main(String[] args) {\n        //变长参数转换为数组\n        print(new String[]{\"hello\", \"world\"});\n    }\n}\n```\n\n**增强for循环**\n\n增强for循环与普通for循环相比，功能更强并且代码更简洁。增强for循环的对象要么是一个数组，要么实现了Iterable接口。这个语法糖主要用来对数组或者集合进行遍历，其在循环过程中不能改变集合的大小。\n\n\n```\npublic static void main(String[] args) {\n    String[] params = new String[]{\"hello\",\"world\"};\n    //增强for循环对象为数组\n    for(String str : params){\n        System.out.println(str);\n    }\n\n    List<String> lists = Arrays.asList(\"hello\",\"world\");\n    //增强for循环对象实现Iterable接口\n    for(String str : lists){\n        System.out.println(str);\n    }\n}\n```\n\n编译后的class文件为\n\n\n```\npublic static void main(String[] args) {\n   String[] params = new String[]{\"hello\", \"world\"};\n   String[] lists = params;\n   int var3 = params.length;\n   //数组形式的增强for退化为普通for\n   for(int str = 0; str < var3; ++str) {\n       String str1 = lists[str];\n       System.out.println(str1);\n   }\n\n   List var6 = Arrays.asList(new String[]{\"hello\", \"world\"});\n   Iterator var7 = var6.iterator();\n   //实现Iterable接口的增强for使用iterator接口进行遍历\n   while(var7.hasNext()) {\n       String var8 = (String)var7.next();\n       System.out.println(var8);\n   }\n\n}\n```\n\n**内部类**\n\n内部类就是定义在一个类内部的类\nJava语言中之所以引入内部类，是因为有些时候一个类只在另一个类中有用，我们不想让其在另外一个地方被使用。内部类之所以是语法糖，是因为其只是一个编译时的概念，一旦编译完成，编译器就会为内部类生成一个单独的class文件，名为outer$innter.class。\n\n\n```\npublic class Outer {\n    class Inner{\n    }\n}\n```\n\n使用javac编译后，生成两个class文件Outer.class和Outer$Inner.class，其中Outer$Inner.class的内容如下：\n\n\n```\nclass Outer$Inner {\n    Outer$Inner(Outer var1) {\n        this.this$0 = var1;\n    }\n}\n```\n\n内部类分为四种：成员内部类、局部内部类、匿名内部类、静态内部类，每一种都有其用法，这里就不介绍了\n\n**枚举类型**\n\n枚举类型就是一些具有相同特性的类常量\njava中类的定义使用class，枚举类的定义使用enum。在Java的字节码结构中，其实并没有枚举类型，枚举类型只是一个语法糖，在编译完成后被编译成一个普通的类。这个类继承java.lang.Enum，并被final关键字修饰。\n\n\n```\npublic enum Fruit {\n    APPLE,ORINGE\n}\n```\n\n使用jad对编译后的class文件进行反编译后得到：\n\n```\n//继承java.lang.Enum并声明为final\npublic final class Fruit extends Enum\n{\n\n    public static Fruit[] values()\n    {\n        return (Fruit[])$VALUES.clone();\n    }\n\n    public static Fruit valueOf(String s)\n    {\n        return (Fruit)Enum.valueOf(Fruit, s);\n    }\n\n    private Fruit(String s, int i)\n    {\n        super(s, i);\n    }\n    //枚举类型常量\n    public static final Fruit APPLE;\n    public static final Fruit ORANGE;\n    private static final Fruit $VALUES[];//使用数组进行维护\n\n    static\n    {\n        APPLE = new Fruit(\"APPLE\", 0);\n        ORANGE = new Fruit(\"ORANGE\", 1);\n        $VALUES = (new Fruit[] {\n            APPLE, ORANGE\n        });\n    }\n}\n```\n\nJava远不止这些语法糖，JDK7、JDK8添加的新特性都有很多高级的语法糖。\n","source":"_posts/进阶/Java 中的 6 颗语法糖.md","raw":"---\ntitle: Java 中的 6 颗语法糖\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 进阶\n---\n\n\n语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言本身功能来说没有什么影响，只是为了方便程序员的开发，提高开发效率。说白了，语法糖就是对现有语法的一个封装。\n\nJava作为一种与平台无关的高级语言，当然也含有语法糖，这些语法糖并不被虚拟机所支持，在编译成字节码阶段就自动转换成简单常用语法。\n\n**一般来说Java中的语法糖主要有以下几种：** \n\n1. 泛型与类型擦除 \n2. 自动装箱与拆箱\n3. 变长参数\n4. 增强for循环 \n5. 内部类\n6. 枚举类\n\n**泛型与类型擦除**\n\nJava语言并不是一开始就支持泛型的。在早期的JDK中，只能通过Object类是所有类型的父类和强制类型转换来实现泛型的功能。强制类型转换的缺点就是把编译期间的问题延迟到运行时，JVM并不能为我们提供编译期间的检查。\n\n在JDK1.5中，Java语言引入了泛型机制。但是这种泛型机制是通过类型擦除来实现的，即Java中的泛型只在程序源代码中有效（源代码阶段提供类型检查），在编译后的字节码中自动用强制类型转换进行替代。也就是说，Java语言中的泛型机制其实就是一颗语法糖，相较与C++、C#相比，其泛型实现实在是不那么优雅。\n\n\n```\n/**\n* 在源代码中存在泛型\n*/\npublic static void main(String[] args) {\n    Map<String,String> map = new HashMap<String,String>();\n    map.put(\"hello\",\"你好\");\n    String hello = map.get(\"hello\");\n    System.out.println(hello);\n}\n```\n\n当上述源代码被编译为class文件后，泛型被擦除且引入强制类型转换\n\n\n```\npublic static void main(String[] args) {\n    HashMap map = new HashMap(); //类型擦除\n    map.put(\"hello\", \"你好\");\n    String hello = (String)map.get(\"hello\");//强制转换\n    System.out.println(hello);\n}\n```\n\n\n**自动装箱与拆箱**\n\nJava中的自动装箱与拆箱指的是基本数据类型与他们的包装类型之间的相互转换。\n\n我们知道Java是一门面向对象的语言，在Java世界中有一句话是这么说的：“万物皆对象”。但是Java中的基本数据类型却不是对象，他们不需要进行new操作，也不能调用任何方法，这在使用的时候有诸多不便。因此Java为这些基本类型提供了包装类，并且为了使用方便，提供了自动装箱与拆箱功能。自动装箱与拆箱在使用的过程中，其实是一个语法糖，内部还是调用了相应的函数进行转换。\n\n下面代码演示了自动装箱和拆箱功能\n\n\n```\npublic static void main(String[] args) {\n    Integer a = 1;\n    int b = 2;\n    int c = a + b;\n    System.out.println(c);\n}\n```\n\n经过编译后，代码如下\n\n\n```\npublic static void main(String[] args) {\n    Integer a = Integer.valueOf(1); // 自动装箱\n    byte b = 2;\n    int c = a.intValue() + b;//自动拆箱\n    System.out.println(c);\n}\n```\n\n**变长参数**\n\n所谓变长参数，就是方法可以接受长度不定确定的参数。变长参数特性是在JDK1.5中引入的，使用变长参数有两个条件，一是变长的那一部分参数具有相同的类型，二是变长参数必须位于方法参数列表的最后面。变长参数同样是Java中的语法糖，其内部实现是Java数组。\n\n\n```\npublic class Varargs {\n    public static void print(String... args) {\n        for(String str : args){\n            System.out.println(str);\n        }\n    }\n\n    public static void main(String[] args) {\n        print(\"hello\", \"world\");\n    }\n}\n```\n\n编译为class文件后如下，从中可以很明显的看出变长参数内部是通过数组实现的\n\n\n```\npublic class Varargs {\n    public Varargs() {\n    }\n\n    public static void print(String... args) {\n        String[] var1 = args;\n        int var2 = args.length;\n        //增强for循环的数组实现方式\n        for(int var3 = 0; var3 < var2; ++var3) {\n            String str = var1[var3];\n            System.out.println(str);\n        }\n\n    }\n\n    public static void main(String[] args) {\n        //变长参数转换为数组\n        print(new String[]{\"hello\", \"world\"});\n    }\n}\n```\n\n**增强for循环**\n\n增强for循环与普通for循环相比，功能更强并且代码更简洁。增强for循环的对象要么是一个数组，要么实现了Iterable接口。这个语法糖主要用来对数组或者集合进行遍历，其在循环过程中不能改变集合的大小。\n\n\n```\npublic static void main(String[] args) {\n    String[] params = new String[]{\"hello\",\"world\"};\n    //增强for循环对象为数组\n    for(String str : params){\n        System.out.println(str);\n    }\n\n    List<String> lists = Arrays.asList(\"hello\",\"world\");\n    //增强for循环对象实现Iterable接口\n    for(String str : lists){\n        System.out.println(str);\n    }\n}\n```\n\n编译后的class文件为\n\n\n```\npublic static void main(String[] args) {\n   String[] params = new String[]{\"hello\", \"world\"};\n   String[] lists = params;\n   int var3 = params.length;\n   //数组形式的增强for退化为普通for\n   for(int str = 0; str < var3; ++str) {\n       String str1 = lists[str];\n       System.out.println(str1);\n   }\n\n   List var6 = Arrays.asList(new String[]{\"hello\", \"world\"});\n   Iterator var7 = var6.iterator();\n   //实现Iterable接口的增强for使用iterator接口进行遍历\n   while(var7.hasNext()) {\n       String var8 = (String)var7.next();\n       System.out.println(var8);\n   }\n\n}\n```\n\n**内部类**\n\n内部类就是定义在一个类内部的类\nJava语言中之所以引入内部类，是因为有些时候一个类只在另一个类中有用，我们不想让其在另外一个地方被使用。内部类之所以是语法糖，是因为其只是一个编译时的概念，一旦编译完成，编译器就会为内部类生成一个单独的class文件，名为outer$innter.class。\n\n\n```\npublic class Outer {\n    class Inner{\n    }\n}\n```\n\n使用javac编译后，生成两个class文件Outer.class和Outer$Inner.class，其中Outer$Inner.class的内容如下：\n\n\n```\nclass Outer$Inner {\n    Outer$Inner(Outer var1) {\n        this.this$0 = var1;\n    }\n}\n```\n\n内部类分为四种：成员内部类、局部内部类、匿名内部类、静态内部类，每一种都有其用法，这里就不介绍了\n\n**枚举类型**\n\n枚举类型就是一些具有相同特性的类常量\njava中类的定义使用class，枚举类的定义使用enum。在Java的字节码结构中，其实并没有枚举类型，枚举类型只是一个语法糖，在编译完成后被编译成一个普通的类。这个类继承java.lang.Enum，并被final关键字修饰。\n\n\n```\npublic enum Fruit {\n    APPLE,ORINGE\n}\n```\n\n使用jad对编译后的class文件进行反编译后得到：\n\n```\n//继承java.lang.Enum并声明为final\npublic final class Fruit extends Enum\n{\n\n    public static Fruit[] values()\n    {\n        return (Fruit[])$VALUES.clone();\n    }\n\n    public static Fruit valueOf(String s)\n    {\n        return (Fruit)Enum.valueOf(Fruit, s);\n    }\n\n    private Fruit(String s, int i)\n    {\n        super(s, i);\n    }\n    //枚举类型常量\n    public static final Fruit APPLE;\n    public static final Fruit ORANGE;\n    private static final Fruit $VALUES[];//使用数组进行维护\n\n    static\n    {\n        APPLE = new Fruit(\"APPLE\", 0);\n        ORANGE = new Fruit(\"ORANGE\", 1);\n        $VALUES = (new Fruit[] {\n            APPLE, ORANGE\n        });\n    }\n}\n```\n\nJava远不止这些语法糖，JDK7、JDK8添加的新特性都有很多高级的语法糖。\n","slug":"进阶/Java 中的 6 颗语法糖","published":1,"updated":"2025-10-16T02:51:08.329Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076c0009qkd4260v5ajm","content":"<p>语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言本身功能来说没有什么影响，只是为了方便程序员的开发，提高开发效率。说白了，语法糖就是对现有语法的一个封装。</p>\n<p>Java作为一种与平台无关的高级语言，当然也含有语法糖，这些语法糖并不被虚拟机所支持，在编译成字节码阶段就自动转换成简单常用语法。</p>\n<p><strong>一般来说Java中的语法糖主要有以下几种：</strong> </p>\n<ol>\n<li>泛型与类型擦除 </li>\n<li>自动装箱与拆箱</li>\n<li>变长参数</li>\n<li>增强for循环 </li>\n<li>内部类</li>\n<li>枚举类</li>\n</ol>\n<p><strong>泛型与类型擦除</strong></p>\n<p>Java语言并不是一开始就支持泛型的。在早期的JDK中，只能通过Object类是所有类型的父类和强制类型转换来实现泛型的功能。强制类型转换的缺点就是把编译期间的问题延迟到运行时，JVM并不能为我们提供编译期间的检查。</p>\n<p>在JDK1.5中，Java语言引入了泛型机制。但是这种泛型机制是通过类型擦除来实现的，即Java中的泛型只在程序源代码中有效（源代码阶段提供类型检查），在编译后的字节码中自动用强制类型转换进行替代。也就是说，Java语言中的泛型机制其实就是一颗语法糖，相较与C++、C#相比，其泛型实现实在是不那么优雅。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n* 在源代码中存在泛型\n*&#x2F;\npublic static void main(String[] args) &#123;\n    Map&lt;String,String&gt; map &#x3D; new HashMap&lt;String,String&gt;();\n    map.put(&quot;hello&quot;,&quot;你好&quot;);\n    String hello &#x3D; map.get(&quot;hello&quot;);\n    System.out.println(hello);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当上述源代码被编译为class文件后，泛型被擦除且引入强制类型转换</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    HashMap map &#x3D; new HashMap(); &#x2F;&#x2F;类型擦除\n    map.put(&quot;hello&quot;, &quot;你好&quot;);\n    String hello &#x3D; (String)map.get(&quot;hello&quot;);&#x2F;&#x2F;强制转换\n    System.out.println(hello);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<p><strong>自动装箱与拆箱</strong></p>\n<p>Java中的自动装箱与拆箱指的是基本数据类型与他们的包装类型之间的相互转换。</p>\n<p>我们知道Java是一门面向对象的语言，在Java世界中有一句话是这么说的：“万物皆对象”。但是Java中的基本数据类型却不是对象，他们不需要进行new操作，也不能调用任何方法，这在使用的时候有诸多不便。因此Java为这些基本类型提供了包装类，并且为了使用方便，提供了自动装箱与拆箱功能。自动装箱与拆箱在使用的过程中，其实是一个语法糖，内部还是调用了相应的函数进行转换。</p>\n<p>下面代码演示了自动装箱和拆箱功能</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    Integer a &#x3D; 1;\n    int b &#x3D; 2;\n    int c &#x3D; a + b;\n    System.out.println(c);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>经过编译后，代码如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    Integer a &#x3D; Integer.valueOf(1); &#x2F;&#x2F; 自动装箱\n    byte b &#x3D; 2;\n    int c &#x3D; a.intValue() + b;&#x2F;&#x2F;自动拆箱\n    System.out.println(c);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>变长参数</strong></p>\n<p>所谓变长参数，就是方法可以接受长度不定确定的参数。变长参数特性是在JDK1.5中引入的，使用变长参数有两个条件，一是变长的那一部分参数具有相同的类型，二是变长参数必须位于方法参数列表的最后面。变长参数同样是Java中的语法糖，其内部实现是Java数组。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Varargs &#123;\n    public static void print(String... args) &#123;\n        for(String str : args)&#123;\n            System.out.println(str);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        print(&quot;hello&quot;, &quot;world&quot;);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>编译为class文件后如下，从中可以很明显的看出变长参数内部是通过数组实现的</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Varargs &#123;\n    public Varargs() &#123;\n    &#125;\n\n    public static void print(String... args) &#123;\n        String[] var1 &#x3D; args;\n        int var2 &#x3D; args.length;\n        &#x2F;&#x2F;增强for循环的数组实现方式\n        for(int var3 &#x3D; 0; var3 &lt; var2; ++var3) &#123;\n            String str &#x3D; var1[var3];\n            System.out.println(str);\n        &#125;\n\n    &#125;\n\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;变长参数转换为数组\n        print(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>增强for循环</strong></p>\n<p>增强for循环与普通for循环相比，功能更强并且代码更简洁。增强for循环的对象要么是一个数组，要么实现了Iterable接口。这个语法糖主要用来对数组或者集合进行遍历，其在循环过程中不能改变集合的大小。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    String[] params &#x3D; new String[]&#123;&quot;hello&quot;,&quot;world&quot;&#125;;\n    &#x2F;&#x2F;增强for循环对象为数组\n    for(String str : params)&#123;\n        System.out.println(str);\n    &#125;\n\n    List&lt;String&gt; lists &#x3D; Arrays.asList(&quot;hello&quot;,&quot;world&quot;);\n    &#x2F;&#x2F;增强for循环对象实现Iterable接口\n    for(String str : lists)&#123;\n        System.out.println(str);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>编译后的class文件为</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n   String[] params &#x3D; new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;;\n   String[] lists &#x3D; params;\n   int var3 &#x3D; params.length;\n   &#x2F;&#x2F;数组形式的增强for退化为普通for\n   for(int str &#x3D; 0; str &lt; var3; ++str) &#123;\n       String str1 &#x3D; lists[str];\n       System.out.println(str1);\n   &#125;\n\n   List var6 &#x3D; Arrays.asList(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;);\n   Iterator var7 &#x3D; var6.iterator();\n   &#x2F;&#x2F;实现Iterable接口的增强for使用iterator接口进行遍历\n   while(var7.hasNext()) &#123;\n       String var8 &#x3D; (String)var7.next();\n       System.out.println(var8);\n   &#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>内部类</strong></p>\n<p>内部类就是定义在一个类内部的类<br>Java语言中之所以引入内部类，是因为有些时候一个类只在另一个类中有用，我们不想让其在另外一个地方被使用。内部类之所以是语法糖，是因为其只是一个编译时的概念，一旦编译完成，编译器就会为内部类生成一个单独的class文件，名为outer$innter.class。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Outer &#123;\n    class Inner&#123;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用javac编译后，生成两个class文件Outer.class和Outer$Inner.class，其中Outer$Inner.class的内容如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Outer$Inner &#123;\n    Outer$Inner(Outer var1) &#123;\n        this.this$0 &#x3D; var1;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>内部类分为四种：成员内部类、局部内部类、匿名内部类、静态内部类，每一种都有其用法，这里就不介绍了</p>\n<p><strong>枚举类型</strong></p>\n<p>枚举类型就是一些具有相同特性的类常量<br>java中类的定义使用class，枚举类的定义使用enum。在Java的字节码结构中，其实并没有枚举类型，枚举类型只是一个语法糖，在编译完成后被编译成一个普通的类。这个类继承java.lang.Enum，并被final关键字修饰。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public enum Fruit &#123;\n    APPLE,ORINGE\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>使用jad对编译后的class文件进行反编译后得到：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;继承java.lang.Enum并声明为final\npublic final class Fruit extends Enum\n&#123;\n\n    public static Fruit[] values()\n    &#123;\n        return (Fruit[])$VALUES.clone();\n    &#125;\n\n    public static Fruit valueOf(String s)\n    &#123;\n        return (Fruit)Enum.valueOf(Fruit, s);\n    &#125;\n\n    private Fruit(String s, int i)\n    &#123;\n        super(s, i);\n    &#125;\n    &#x2F;&#x2F;枚举类型常量\n    public static final Fruit APPLE;\n    public static final Fruit ORANGE;\n    private static final Fruit $VALUES[];&#x2F;&#x2F;使用数组进行维护\n\n    static\n    &#123;\n        APPLE &#x3D; new Fruit(&quot;APPLE&quot;, 0);\n        ORANGE &#x3D; new Fruit(&quot;ORANGE&quot;, 1);\n        $VALUES &#x3D; (new Fruit[] &#123;\n            APPLE, ORANGE\n        &#125;);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>Java远不止这些语法糖，JDK7、JDK8添加的新特性都有很多高级的语法糖。</p>\n","excerpt":"","more":"<p>语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言本身功能来说没有什么影响，只是为了方便程序员的开发，提高开发效率。说白了，语法糖就是对现有语法的一个封装。</p>\n<p>Java作为一种与平台无关的高级语言，当然也含有语法糖，这些语法糖并不被虚拟机所支持，在编译成字节码阶段就自动转换成简单常用语法。</p>\n<p><strong>一般来说Java中的语法糖主要有以下几种：</strong> </p>\n<ol>\n<li>泛型与类型擦除 </li>\n<li>自动装箱与拆箱</li>\n<li>变长参数</li>\n<li>增强for循环 </li>\n<li>内部类</li>\n<li>枚举类</li>\n</ol>\n<p><strong>泛型与类型擦除</strong></p>\n<p>Java语言并不是一开始就支持泛型的。在早期的JDK中，只能通过Object类是所有类型的父类和强制类型转换来实现泛型的功能。强制类型转换的缺点就是把编译期间的问题延迟到运行时，JVM并不能为我们提供编译期间的检查。</p>\n<p>在JDK1.5中，Java语言引入了泛型机制。但是这种泛型机制是通过类型擦除来实现的，即Java中的泛型只在程序源代码中有效（源代码阶段提供类型检查），在编译后的字节码中自动用强制类型转换进行替代。也就是说，Java语言中的泛型机制其实就是一颗语法糖，相较与C++、C#相比，其泛型实现实在是不那么优雅。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n* 在源代码中存在泛型\n*&#x2F;\npublic static void main(String[] args) &#123;\n    Map&lt;String,String&gt; map &#x3D; new HashMap&lt;String,String&gt;();\n    map.put(&quot;hello&quot;,&quot;你好&quot;);\n    String hello &#x3D; map.get(&quot;hello&quot;);\n    System.out.println(hello);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当上述源代码被编译为class文件后，泛型被擦除且引入强制类型转换</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    HashMap map &#x3D; new HashMap(); &#x2F;&#x2F;类型擦除\n    map.put(&quot;hello&quot;, &quot;你好&quot;);\n    String hello &#x3D; (String)map.get(&quot;hello&quot;);&#x2F;&#x2F;强制转换\n    System.out.println(hello);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<p><strong>自动装箱与拆箱</strong></p>\n<p>Java中的自动装箱与拆箱指的是基本数据类型与他们的包装类型之间的相互转换。</p>\n<p>我们知道Java是一门面向对象的语言，在Java世界中有一句话是这么说的：“万物皆对象”。但是Java中的基本数据类型却不是对象，他们不需要进行new操作，也不能调用任何方法，这在使用的时候有诸多不便。因此Java为这些基本类型提供了包装类，并且为了使用方便，提供了自动装箱与拆箱功能。自动装箱与拆箱在使用的过程中，其实是一个语法糖，内部还是调用了相应的函数进行转换。</p>\n<p>下面代码演示了自动装箱和拆箱功能</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    Integer a &#x3D; 1;\n    int b &#x3D; 2;\n    int c &#x3D; a + b;\n    System.out.println(c);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>经过编译后，代码如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    Integer a &#x3D; Integer.valueOf(1); &#x2F;&#x2F; 自动装箱\n    byte b &#x3D; 2;\n    int c &#x3D; a.intValue() + b;&#x2F;&#x2F;自动拆箱\n    System.out.println(c);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>变长参数</strong></p>\n<p>所谓变长参数，就是方法可以接受长度不定确定的参数。变长参数特性是在JDK1.5中引入的，使用变长参数有两个条件，一是变长的那一部分参数具有相同的类型，二是变长参数必须位于方法参数列表的最后面。变长参数同样是Java中的语法糖，其内部实现是Java数组。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Varargs &#123;\n    public static void print(String... args) &#123;\n        for(String str : args)&#123;\n            System.out.println(str);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        print(&quot;hello&quot;, &quot;world&quot;);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>编译为class文件后如下，从中可以很明显的看出变长参数内部是通过数组实现的</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Varargs &#123;\n    public Varargs() &#123;\n    &#125;\n\n    public static void print(String... args) &#123;\n        String[] var1 &#x3D; args;\n        int var2 &#x3D; args.length;\n        &#x2F;&#x2F;增强for循环的数组实现方式\n        for(int var3 &#x3D; 0; var3 &lt; var2; ++var3) &#123;\n            String str &#x3D; var1[var3];\n            System.out.println(str);\n        &#125;\n\n    &#125;\n\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;变长参数转换为数组\n        print(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>增强for循环</strong></p>\n<p>增强for循环与普通for循环相比，功能更强并且代码更简洁。增强for循环的对象要么是一个数组，要么实现了Iterable接口。这个语法糖主要用来对数组或者集合进行遍历，其在循环过程中不能改变集合的大小。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    String[] params &#x3D; new String[]&#123;&quot;hello&quot;,&quot;world&quot;&#125;;\n    &#x2F;&#x2F;增强for循环对象为数组\n    for(String str : params)&#123;\n        System.out.println(str);\n    &#125;\n\n    List&lt;String&gt; lists &#x3D; Arrays.asList(&quot;hello&quot;,&quot;world&quot;);\n    &#x2F;&#x2F;增强for循环对象实现Iterable接口\n    for(String str : lists)&#123;\n        System.out.println(str);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>编译后的class文件为</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n   String[] params &#x3D; new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;;\n   String[] lists &#x3D; params;\n   int var3 &#x3D; params.length;\n   &#x2F;&#x2F;数组形式的增强for退化为普通for\n   for(int str &#x3D; 0; str &lt; var3; ++str) &#123;\n       String str1 &#x3D; lists[str];\n       System.out.println(str1);\n   &#125;\n\n   List var6 &#x3D; Arrays.asList(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;);\n   Iterator var7 &#x3D; var6.iterator();\n   &#x2F;&#x2F;实现Iterable接口的增强for使用iterator接口进行遍历\n   while(var7.hasNext()) &#123;\n       String var8 &#x3D; (String)var7.next();\n       System.out.println(var8);\n   &#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>内部类</strong></p>\n<p>内部类就是定义在一个类内部的类<br>Java语言中之所以引入内部类，是因为有些时候一个类只在另一个类中有用，我们不想让其在另外一个地方被使用。内部类之所以是语法糖，是因为其只是一个编译时的概念，一旦编译完成，编译器就会为内部类生成一个单独的class文件，名为outer$innter.class。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Outer &#123;\n    class Inner&#123;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用javac编译后，生成两个class文件Outer.class和Outer$Inner.class，其中Outer$Inner.class的内容如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Outer$Inner &#123;\n    Outer$Inner(Outer var1) &#123;\n        this.this$0 &#x3D; var1;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>内部类分为四种：成员内部类、局部内部类、匿名内部类、静态内部类，每一种都有其用法，这里就不介绍了</p>\n<p><strong>枚举类型</strong></p>\n<p>枚举类型就是一些具有相同特性的类常量<br>java中类的定义使用class，枚举类的定义使用enum。在Java的字节码结构中，其实并没有枚举类型，枚举类型只是一个语法糖，在编译完成后被编译成一个普通的类。这个类继承java.lang.Enum，并被final关键字修饰。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public enum Fruit &#123;\n    APPLE,ORINGE\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>使用jad对编译后的class文件进行反编译后得到：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;继承java.lang.Enum并声明为final\npublic final class Fruit extends Enum\n&#123;\n\n    public static Fruit[] values()\n    &#123;\n        return (Fruit[])$VALUES.clone();\n    &#125;\n\n    public static Fruit valueOf(String s)\n    &#123;\n        return (Fruit)Enum.valueOf(Fruit, s);\n    &#125;\n\n    private Fruit(String s, int i)\n    &#123;\n        super(s, i);\n    &#125;\n    &#x2F;&#x2F;枚举类型常量\n    public static final Fruit APPLE;\n    public static final Fruit ORANGE;\n    private static final Fruit $VALUES[];&#x2F;&#x2F;使用数组进行维护\n\n    static\n    &#123;\n        APPLE &#x3D; new Fruit(&quot;APPLE&quot;, 0);\n        ORANGE &#x3D; new Fruit(&quot;ORANGE&quot;, 1);\n        $VALUES &#x3D; (new Fruit[] &#123;\n            APPLE, ORANGE\n        &#125;);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>Java远不止这些语法糖，JDK7、JDK8添加的新特性都有很多高级的语法糖。</p>\n"},{"title":"Java 中的伪共享详解及解决方案","date":"2025-10-15T03:36:33.000Z","_content":"\n#### 1. 什么是伪共享\n\nCPU 缓存系统中是以缓存行（cache line）为单位存储的。目前主流的 CPU Cache 的 Cache Line 大小都是 64 Bytes。在多线程情况下，如果需要修改“共享同一个缓存行的变量”，就会无意中影响彼此的性能，这就是伪共享（False Sharing）。\n\n#### 2. 缓存行\n\n由于共享变量在 CPU 缓存中的存储是以缓存行为单位，一个缓存行可以存储多个变量（存满当前缓存行的字节数）；而CPU对缓存的修改又是以缓存行为最小单位的，那么就会出现上诉的伪共享问题。\n\nCache Line 可以简单的理解为 CPU Cache 中的最小缓存单位，今天的 CPU 不再是按字节访问内存，而是以 64 字节为单位的块(chunk)拿取，称为一个缓存行(cache line)。当你读一个特定的内存地址，整个缓存行将从主存换入缓存，并且访问同一个缓存行内的其它值的开销是很小的。\n\n#### 3. CPU 的三级缓存\n\n由于 CPU 的速度远远大于内存速度，所以 CPU 设计者们就给 CPU 加上了缓存(CPU Cache)。 以免运算被内存速度拖累。（就像我们写代码把共享数据做Cache不想被DB存取速度拖累一样），CPU Cache 分成了三个级别：L1，L2，L3。越靠近CPU的缓存越快也越小。所 以L1 缓存很小但很快，并且紧靠着在使用它的 CPU 内核。L2 大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。L3 在现代多核机器中更普遍，仍然更大，更慢，并且被单个插槽上的所有 CPU 核共享。最后，你拥有一块主存，由全部插槽上的所有 CPU 核共享。\n\n当 CPU 执行运算的时候，它先去L1查找所需的数据，再去L2，然后是L3，最后如果这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果你在做一些很频繁的事，你要确保数据在L1缓存中。\n\n![](http://img.javastack.cn/18-5-31/91078691.jpg)\n\n#### 4. 缓存关联性\n\n目前常用的缓存设计是N路组关联(N-Way Set Associative Cache)，他的原理是把一个缓存按照N个 Cache Line 作为一组（Set），缓存按组划为等分。每个内存块能够被映射到相对应的set中的任意一个缓存行中。比如一个16路缓存，16个 Cache Line 作为一个Set，每个内存块能够被映射到相对应的 Set 中的16个 CacheLine 中的任意一个。一般地，具有一定相同低bit位地址的内存块将共享同一个Set。 \n\n下图为一个2-Way的Cache。由图中可以看到 Main Memory 中的 Index 0,2,4 都映射在Way0的不同 CacheLine 中，Index 1,3,5都映射在Way1的不同 CacheLine 中。\n\n![](http://img.javastack.cn/18-5-31/71458405.jpg)\n\n#### 5. MESI 协议\n\n多核 CPU 都有自己的专有缓存（一般为L1，L2），以及同一个 CPU 插槽之间的核共享的缓存（一般为L3）。不同核心的CPU缓存中难免会加载同样的数据，那么如何保证数据的一致性呢，就是 MESI 协议了。\n\n在 MESI 协议中，每个 Cache line 有4个状态，可用 2 个 bit 表示，它们分别是： \nM(Modified)：这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本 Cache 中； \nE(Exclusive)：这行数据有效，数据和内存中的数据一致，数据只存在于本 Cache 中； \nS(Shared)：这行数据有效，数据和内存中的数据一致，数据存在于很多 Cache 中； \nI(Invalid)：这行数据无效。\n\n那么，假设有一个变量i=3（应该是包括变量i的缓存块，块大小为缓存行大小）；已经加载到多核（a,b,c）的缓存中，此时该缓存行的状态为S；此时其中的一个核a改变了变量i的值，那么在核a中的当前缓存行的状态将变为M，b,c核中的当前缓存行状态将变为I。如下图：\n\n![](http://img.javastack.cn/18-5-31/66429246.jpg)\n\n#### 6. 解决原理\n\n为了避免由于 false sharing 导致 Cache Line 从 L1,L2,L3 到主存之间重复载入，我们可以使用数据填充的方式来避免，即单个数据填充满一个CacheLine。这本质是一种空间换时间的做法。\n\n#### 7. Java 对于伪共享的传统解决方案\n\n```\n/***\n* \n**/\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic final class FalseSharing\n    implements Runnable\n{\n    public final static int NUM_THREADS = 4; // change\n    public final static long ITERATIONS = 500L * 1000L * 1000L;\n    private final int arrayIndex;\n\n    private static VolatileLong[] longs = new VolatileLong[NUM_THREADS];\n    static\n    {\n        for (int i = 0; i < longs.length; i++)\n        {\n            longs[i] = new VolatileLong();\n        }\n    }\n\n    public FalseSharing(final int arrayIndex)\n    {\n        this.arrayIndex = arrayIndex;\n    }\n\n    public static void main(final String[] args) throws Exception\n    {\n        final long start = System.nanoTime();\n        runTest();\n        System.out.println(\"duration = \" + (System.nanoTime() - start));\n    }\n\n    private static void runTest() throws InterruptedException\n    {\n        Thread[] threads = new Thread[NUM_THREADS];\n\n        for (int i = 0; i < threads.length; i++)\n        {\n            threads[i] = new Thread(new FalseSharing(i));\n        }\n\n        for (Thread t : threads)\n        {\n            t.start();\n        }\n\n        for (Thread t : threads)\n        {\n            t.join();\n        }\n    }\n\n    public void run()\n    {\n        long i = ITERATIONS + 1;\n        while (0 != --i)\n        {\n            longs[arrayIndex].set(i);\n        }\n    }\n\n    public static long sumPaddingToPreventOptimisation(final int index)\n    {\n        VolatileLong v = longs[index];\n        return v.p1 + v.p2 + v.p3 + v.p4 + v.p5 + v.p6;\n    }\n\n    //jdk7以上使用此方法(jdk7的某个版本oracle对伪共享做了优化)\n    public final static class VolatileLong\n    {\n        public volatile long value = 0L;\n        public long p1, p2, p3, p4, p5, p6;\n    }\n\n    // jdk7以下使用此方法\n    public final static class VolatileLong\n    {\n        public long p1, p2, p3, p4, p5, p6, p7; // cache line padding\n        public volatile long value = 0L;\n        public long p8, p9, p10, p11, p12, p13, p14; // cache line padding\n\n    }\n}\n```\n\n\n#### 8. Java 8 中的解决方案\n\nJava 8 中已经提供了官方的解决方案，Java 8 中新增了一个注解：`@sun.misc.Contended`。加上这个注解的类会自动补齐缓存行，需要注意的是此注解默认是无效的，需要在 jvm 启动时设置 `-XX:-RestrictContended` 才会生效。\n\n\n```\n@sun.misc.Contended\npublic final static class VolatileLong {\n    public volatile long value = 0L;\n    //public long p1, p2, p3, p4, p5, p6;\n```\n\n\n#### 参考文献\n\n> http://igoro.com/archive/gallery-of-processor-cache-effects/\n> http://ifeve.com/false-sharing/ \n> http://blog.csdn.net/muxiqingyang/article/details/6615199 \n> https://yq.aliyun.com/articles/62865\n\n@码农们，你们是怎么理解和解决伪共享的？欢迎留言！\n\n","source":"_posts/进阶/Java 中的伪共享详解及解决方案.md","raw":"---\ntitle: Java 中的伪共享详解及解决方案\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 进阶\n---\n\n#### 1. 什么是伪共享\n\nCPU 缓存系统中是以缓存行（cache line）为单位存储的。目前主流的 CPU Cache 的 Cache Line 大小都是 64 Bytes。在多线程情况下，如果需要修改“共享同一个缓存行的变量”，就会无意中影响彼此的性能，这就是伪共享（False Sharing）。\n\n#### 2. 缓存行\n\n由于共享变量在 CPU 缓存中的存储是以缓存行为单位，一个缓存行可以存储多个变量（存满当前缓存行的字节数）；而CPU对缓存的修改又是以缓存行为最小单位的，那么就会出现上诉的伪共享问题。\n\nCache Line 可以简单的理解为 CPU Cache 中的最小缓存单位，今天的 CPU 不再是按字节访问内存，而是以 64 字节为单位的块(chunk)拿取，称为一个缓存行(cache line)。当你读一个特定的内存地址，整个缓存行将从主存换入缓存，并且访问同一个缓存行内的其它值的开销是很小的。\n\n#### 3. CPU 的三级缓存\n\n由于 CPU 的速度远远大于内存速度，所以 CPU 设计者们就给 CPU 加上了缓存(CPU Cache)。 以免运算被内存速度拖累。（就像我们写代码把共享数据做Cache不想被DB存取速度拖累一样），CPU Cache 分成了三个级别：L1，L2，L3。越靠近CPU的缓存越快也越小。所 以L1 缓存很小但很快，并且紧靠着在使用它的 CPU 内核。L2 大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。L3 在现代多核机器中更普遍，仍然更大，更慢，并且被单个插槽上的所有 CPU 核共享。最后，你拥有一块主存，由全部插槽上的所有 CPU 核共享。\n\n当 CPU 执行运算的时候，它先去L1查找所需的数据，再去L2，然后是L3，最后如果这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果你在做一些很频繁的事，你要确保数据在L1缓存中。\n\n![](http://img.javastack.cn/18-5-31/91078691.jpg)\n\n#### 4. 缓存关联性\n\n目前常用的缓存设计是N路组关联(N-Way Set Associative Cache)，他的原理是把一个缓存按照N个 Cache Line 作为一组（Set），缓存按组划为等分。每个内存块能够被映射到相对应的set中的任意一个缓存行中。比如一个16路缓存，16个 Cache Line 作为一个Set，每个内存块能够被映射到相对应的 Set 中的16个 CacheLine 中的任意一个。一般地，具有一定相同低bit位地址的内存块将共享同一个Set。 \n\n下图为一个2-Way的Cache。由图中可以看到 Main Memory 中的 Index 0,2,4 都映射在Way0的不同 CacheLine 中，Index 1,3,5都映射在Way1的不同 CacheLine 中。\n\n![](http://img.javastack.cn/18-5-31/71458405.jpg)\n\n#### 5. MESI 协议\n\n多核 CPU 都有自己的专有缓存（一般为L1，L2），以及同一个 CPU 插槽之间的核共享的缓存（一般为L3）。不同核心的CPU缓存中难免会加载同样的数据，那么如何保证数据的一致性呢，就是 MESI 协议了。\n\n在 MESI 协议中，每个 Cache line 有4个状态，可用 2 个 bit 表示，它们分别是： \nM(Modified)：这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本 Cache 中； \nE(Exclusive)：这行数据有效，数据和内存中的数据一致，数据只存在于本 Cache 中； \nS(Shared)：这行数据有效，数据和内存中的数据一致，数据存在于很多 Cache 中； \nI(Invalid)：这行数据无效。\n\n那么，假设有一个变量i=3（应该是包括变量i的缓存块，块大小为缓存行大小）；已经加载到多核（a,b,c）的缓存中，此时该缓存行的状态为S；此时其中的一个核a改变了变量i的值，那么在核a中的当前缓存行的状态将变为M，b,c核中的当前缓存行状态将变为I。如下图：\n\n![](http://img.javastack.cn/18-5-31/66429246.jpg)\n\n#### 6. 解决原理\n\n为了避免由于 false sharing 导致 Cache Line 从 L1,L2,L3 到主存之间重复载入，我们可以使用数据填充的方式来避免，即单个数据填充满一个CacheLine。这本质是一种空间换时间的做法。\n\n#### 7. Java 对于伪共享的传统解决方案\n\n```\n/***\n* \n**/\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic final class FalseSharing\n    implements Runnable\n{\n    public final static int NUM_THREADS = 4; // change\n    public final static long ITERATIONS = 500L * 1000L * 1000L;\n    private final int arrayIndex;\n\n    private static VolatileLong[] longs = new VolatileLong[NUM_THREADS];\n    static\n    {\n        for (int i = 0; i < longs.length; i++)\n        {\n            longs[i] = new VolatileLong();\n        }\n    }\n\n    public FalseSharing(final int arrayIndex)\n    {\n        this.arrayIndex = arrayIndex;\n    }\n\n    public static void main(final String[] args) throws Exception\n    {\n        final long start = System.nanoTime();\n        runTest();\n        System.out.println(\"duration = \" + (System.nanoTime() - start));\n    }\n\n    private static void runTest() throws InterruptedException\n    {\n        Thread[] threads = new Thread[NUM_THREADS];\n\n        for (int i = 0; i < threads.length; i++)\n        {\n            threads[i] = new Thread(new FalseSharing(i));\n        }\n\n        for (Thread t : threads)\n        {\n            t.start();\n        }\n\n        for (Thread t : threads)\n        {\n            t.join();\n        }\n    }\n\n    public void run()\n    {\n        long i = ITERATIONS + 1;\n        while (0 != --i)\n        {\n            longs[arrayIndex].set(i);\n        }\n    }\n\n    public static long sumPaddingToPreventOptimisation(final int index)\n    {\n        VolatileLong v = longs[index];\n        return v.p1 + v.p2 + v.p3 + v.p4 + v.p5 + v.p6;\n    }\n\n    //jdk7以上使用此方法(jdk7的某个版本oracle对伪共享做了优化)\n    public final static class VolatileLong\n    {\n        public volatile long value = 0L;\n        public long p1, p2, p3, p4, p5, p6;\n    }\n\n    // jdk7以下使用此方法\n    public final static class VolatileLong\n    {\n        public long p1, p2, p3, p4, p5, p6, p7; // cache line padding\n        public volatile long value = 0L;\n        public long p8, p9, p10, p11, p12, p13, p14; // cache line padding\n\n    }\n}\n```\n\n\n#### 8. Java 8 中的解决方案\n\nJava 8 中已经提供了官方的解决方案，Java 8 中新增了一个注解：`@sun.misc.Contended`。加上这个注解的类会自动补齐缓存行，需要注意的是此注解默认是无效的，需要在 jvm 启动时设置 `-XX:-RestrictContended` 才会生效。\n\n\n```\n@sun.misc.Contended\npublic final static class VolatileLong {\n    public volatile long value = 0L;\n    //public long p1, p2, p3, p4, p5, p6;\n```\n\n\n#### 参考文献\n\n> http://igoro.com/archive/gallery-of-processor-cache-effects/\n> http://ifeve.com/false-sharing/ \n> http://blog.csdn.net/muxiqingyang/article/details/6615199 \n> https://yq.aliyun.com/articles/62865\n\n@码农们，你们是怎么理解和解决伪共享的？欢迎留言！\n\n","slug":"进阶/Java 中的伪共享详解及解决方案","published":1,"updated":"2025-10-15T07:21:14.235Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076c000dqkd47jvjh55h","content":"<h4 id=\"1-什么是伪共享\"><a href=\"#1-什么是伪共享\" class=\"headerlink\" title=\"1. 什么是伪共享\"></a>1. 什么是伪共享</h4><p>CPU 缓存系统中是以缓存行（cache line）为单位存储的。目前主流的 CPU Cache 的 Cache Line 大小都是 64 Bytes。在多线程情况下，如果需要修改“共享同一个缓存行的变量”，就会无意中影响彼此的性能，这就是伪共享（False Sharing）。</p>\n<h4 id=\"2-缓存行\"><a href=\"#2-缓存行\" class=\"headerlink\" title=\"2. 缓存行\"></a>2. 缓存行</h4><p>由于共享变量在 CPU 缓存中的存储是以缓存行为单位，一个缓存行可以存储多个变量（存满当前缓存行的字节数）；而CPU对缓存的修改又是以缓存行为最小单位的，那么就会出现上诉的伪共享问题。</p>\n<p>Cache Line 可以简单的理解为 CPU Cache 中的最小缓存单位，今天的 CPU 不再是按字节访问内存，而是以 64 字节为单位的块(chunk)拿取，称为一个缓存行(cache line)。当你读一个特定的内存地址，整个缓存行将从主存换入缓存，并且访问同一个缓存行内的其它值的开销是很小的。</p>\n<h4 id=\"3-CPU-的三级缓存\"><a href=\"#3-CPU-的三级缓存\" class=\"headerlink\" title=\"3. CPU 的三级缓存\"></a>3. CPU 的三级缓存</h4><p>由于 CPU 的速度远远大于内存速度，所以 CPU 设计者们就给 CPU 加上了缓存(CPU Cache)。 以免运算被内存速度拖累。（就像我们写代码把共享数据做Cache不想被DB存取速度拖累一样），CPU Cache 分成了三个级别：L1，L2，L3。越靠近CPU的缓存越快也越小。所 以L1 缓存很小但很快，并且紧靠着在使用它的 CPU 内核。L2 大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。L3 在现代多核机器中更普遍，仍然更大，更慢，并且被单个插槽上的所有 CPU 核共享。最后，你拥有一块主存，由全部插槽上的所有 CPU 核共享。</p>\n<p>当 CPU 执行运算的时候，它先去L1查找所需的数据，再去L2，然后是L3，最后如果这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果你在做一些很频繁的事，你要确保数据在L1缓存中。</p>\n<p><img src=\"http://img.javastack.cn/18-5-31/91078691.jpg\"></p>\n<h4 id=\"4-缓存关联性\"><a href=\"#4-缓存关联性\" class=\"headerlink\" title=\"4. 缓存关联性\"></a>4. 缓存关联性</h4><p>目前常用的缓存设计是N路组关联(N-Way Set Associative Cache)，他的原理是把一个缓存按照N个 Cache Line 作为一组（Set），缓存按组划为等分。每个内存块能够被映射到相对应的set中的任意一个缓存行中。比如一个16路缓存，16个 Cache Line 作为一个Set，每个内存块能够被映射到相对应的 Set 中的16个 CacheLine 中的任意一个。一般地，具有一定相同低bit位地址的内存块将共享同一个Set。 </p>\n<p>下图为一个2-Way的Cache。由图中可以看到 Main Memory 中的 Index 0,2,4 都映射在Way0的不同 CacheLine 中，Index 1,3,5都映射在Way1的不同 CacheLine 中。</p>\n<p><img src=\"http://img.javastack.cn/18-5-31/71458405.jpg\"></p>\n<h4 id=\"5-MESI-协议\"><a href=\"#5-MESI-协议\" class=\"headerlink\" title=\"5. MESI 协议\"></a>5. MESI 协议</h4><p>多核 CPU 都有自己的专有缓存（一般为L1，L2），以及同一个 CPU 插槽之间的核共享的缓存（一般为L3）。不同核心的CPU缓存中难免会加载同样的数据，那么如何保证数据的一致性呢，就是 MESI 协议了。</p>\n<p>在 MESI 协议中，每个 Cache line 有4个状态，可用 2 个 bit 表示，它们分别是：<br>M(Modified)：这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本 Cache 中；<br>E(Exclusive)：这行数据有效，数据和内存中的数据一致，数据只存在于本 Cache 中；<br>S(Shared)：这行数据有效，数据和内存中的数据一致，数据存在于很多 Cache 中；<br>I(Invalid)：这行数据无效。</p>\n<p>那么，假设有一个变量i&#x3D;3（应该是包括变量i的缓存块，块大小为缓存行大小）；已经加载到多核（a,b,c）的缓存中，此时该缓存行的状态为S；此时其中的一个核a改变了变量i的值，那么在核a中的当前缓存行的状态将变为M，b,c核中的当前缓存行状态将变为I。如下图：</p>\n<p><img src=\"http://img.javastack.cn/18-5-31/66429246.jpg\"></p>\n<h4 id=\"6-解决原理\"><a href=\"#6-解决原理\" class=\"headerlink\" title=\"6. 解决原理\"></a>6. 解决原理</h4><p>为了避免由于 false sharing 导致 Cache Line 从 L1,L2,L3 到主存之间重复载入，我们可以使用数据填充的方式来避免，即单个数据填充满一个CacheLine。这本质是一种空间换时间的做法。</p>\n<h4 id=\"7-Java-对于伪共享的传统解决方案\"><a href=\"#7-Java-对于伪共享的传统解决方案\" class=\"headerlink\" title=\"7. Java 对于伪共享的传统解决方案\"></a>7. Java 对于伪共享的传统解决方案</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;***\n* \n**&#x2F;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic final class FalseSharing\n    implements Runnable\n&#123;\n    public final static int NUM_THREADS &#x3D; 4; &#x2F;&#x2F; change\n    public final static long ITERATIONS &#x3D; 500L * 1000L * 1000L;\n    private final int arrayIndex;\n\n    private static VolatileLong[] longs &#x3D; new VolatileLong[NUM_THREADS];\n    static\n    &#123;\n        for (int i &#x3D; 0; i &lt; longs.length; i++)\n        &#123;\n            longs[i] &#x3D; new VolatileLong();\n        &#125;\n    &#125;\n\n    public FalseSharing(final int arrayIndex)\n    &#123;\n        this.arrayIndex &#x3D; arrayIndex;\n    &#125;\n\n    public static void main(final String[] args) throws Exception\n    &#123;\n        final long start &#x3D; System.nanoTime();\n        runTest();\n        System.out.println(&quot;duration &#x3D; &quot; + (System.nanoTime() - start));\n    &#125;\n\n    private static void runTest() throws InterruptedException\n    &#123;\n        Thread[] threads &#x3D; new Thread[NUM_THREADS];\n\n        for (int i &#x3D; 0; i &lt; threads.length; i++)\n        &#123;\n            threads[i] &#x3D; new Thread(new FalseSharing(i));\n        &#125;\n\n        for (Thread t : threads)\n        &#123;\n            t.start();\n        &#125;\n\n        for (Thread t : threads)\n        &#123;\n            t.join();\n        &#125;\n    &#125;\n\n    public void run()\n    &#123;\n        long i &#x3D; ITERATIONS + 1;\n        while (0 !&#x3D; --i)\n        &#123;\n            longs[arrayIndex].set(i);\n        &#125;\n    &#125;\n\n    public static long sumPaddingToPreventOptimisation(final int index)\n    &#123;\n        VolatileLong v &#x3D; longs[index];\n        return v.p1 + v.p2 + v.p3 + v.p4 + v.p5 + v.p6;\n    &#125;\n\n    &#x2F;&#x2F;jdk7以上使用此方法(jdk7的某个版本oracle对伪共享做了优化)\n    public final static class VolatileLong\n    &#123;\n        public volatile long value &#x3D; 0L;\n        public long p1, p2, p3, p4, p5, p6;\n    &#125;\n\n    &#x2F;&#x2F; jdk7以下使用此方法\n    public final static class VolatileLong\n    &#123;\n        public long p1, p2, p3, p4, p5, p6, p7; &#x2F;&#x2F; cache line padding\n        public volatile long value &#x3D; 0L;\n        public long p8, p9, p10, p11, p12, p13, p14; &#x2F;&#x2F; cache line padding\n\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<h4 id=\"8-Java-8-中的解决方案\"><a href=\"#8-Java-8-中的解决方案\" class=\"headerlink\" title=\"8. Java 8 中的解决方案\"></a>8. Java 8 中的解决方案</h4><p>Java 8 中已经提供了官方的解决方案，Java 8 中新增了一个注解：<code>@sun.misc.Contended</code>。加上这个注解的类会自动补齐缓存行，需要注意的是此注解默认是无效的，需要在 jvm 启动时设置 <code>-XX:-RestrictContended</code> 才会生效。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@sun.misc.Contended\npublic final static class VolatileLong &#123;\n    public volatile long value &#x3D; 0L;\n    &#x2F;&#x2F;public long p1, p2, p3, p4, p5, p6;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<h4 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h4><blockquote>\n<p><a href=\"http://igoro.com/archive/gallery-of-processor-cache-effects/\">http://igoro.com/archive/gallery-of-processor-cache-effects/</a><br><a href=\"http://ifeve.com/false-sharing/\">http://ifeve.com/false-sharing/</a><br><a href=\"http://blog.csdn.net/muxiqingyang/article/details/6615199\">http://blog.csdn.net/muxiqingyang/article/details/6615199</a><br><a href=\"https://yq.aliyun.com/articles/62865\">https://yq.aliyun.com/articles/62865</a></p>\n</blockquote>\n<p>@码农们，你们是怎么理解和解决伪共享的？欢迎留言！</p>\n","excerpt":"","more":"<h4 id=\"1-什么是伪共享\"><a href=\"#1-什么是伪共享\" class=\"headerlink\" title=\"1. 什么是伪共享\"></a>1. 什么是伪共享</h4><p>CPU 缓存系统中是以缓存行（cache line）为单位存储的。目前主流的 CPU Cache 的 Cache Line 大小都是 64 Bytes。在多线程情况下，如果需要修改“共享同一个缓存行的变量”，就会无意中影响彼此的性能，这就是伪共享（False Sharing）。</p>\n<h4 id=\"2-缓存行\"><a href=\"#2-缓存行\" class=\"headerlink\" title=\"2. 缓存行\"></a>2. 缓存行</h4><p>由于共享变量在 CPU 缓存中的存储是以缓存行为单位，一个缓存行可以存储多个变量（存满当前缓存行的字节数）；而CPU对缓存的修改又是以缓存行为最小单位的，那么就会出现上诉的伪共享问题。</p>\n<p>Cache Line 可以简单的理解为 CPU Cache 中的最小缓存单位，今天的 CPU 不再是按字节访问内存，而是以 64 字节为单位的块(chunk)拿取，称为一个缓存行(cache line)。当你读一个特定的内存地址，整个缓存行将从主存换入缓存，并且访问同一个缓存行内的其它值的开销是很小的。</p>\n<h4 id=\"3-CPU-的三级缓存\"><a href=\"#3-CPU-的三级缓存\" class=\"headerlink\" title=\"3. CPU 的三级缓存\"></a>3. CPU 的三级缓存</h4><p>由于 CPU 的速度远远大于内存速度，所以 CPU 设计者们就给 CPU 加上了缓存(CPU Cache)。 以免运算被内存速度拖累。（就像我们写代码把共享数据做Cache不想被DB存取速度拖累一样），CPU Cache 分成了三个级别：L1，L2，L3。越靠近CPU的缓存越快也越小。所 以L1 缓存很小但很快，并且紧靠着在使用它的 CPU 内核。L2 大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。L3 在现代多核机器中更普遍，仍然更大，更慢，并且被单个插槽上的所有 CPU 核共享。最后，你拥有一块主存，由全部插槽上的所有 CPU 核共享。</p>\n<p>当 CPU 执行运算的时候，它先去L1查找所需的数据，再去L2，然后是L3，最后如果这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果你在做一些很频繁的事，你要确保数据在L1缓存中。</p>\n<p><img src=\"http://img.javastack.cn/18-5-31/91078691.jpg\"></p>\n<h4 id=\"4-缓存关联性\"><a href=\"#4-缓存关联性\" class=\"headerlink\" title=\"4. 缓存关联性\"></a>4. 缓存关联性</h4><p>目前常用的缓存设计是N路组关联(N-Way Set Associative Cache)，他的原理是把一个缓存按照N个 Cache Line 作为一组（Set），缓存按组划为等分。每个内存块能够被映射到相对应的set中的任意一个缓存行中。比如一个16路缓存，16个 Cache Line 作为一个Set，每个内存块能够被映射到相对应的 Set 中的16个 CacheLine 中的任意一个。一般地，具有一定相同低bit位地址的内存块将共享同一个Set。 </p>\n<p>下图为一个2-Way的Cache。由图中可以看到 Main Memory 中的 Index 0,2,4 都映射在Way0的不同 CacheLine 中，Index 1,3,5都映射在Way1的不同 CacheLine 中。</p>\n<p><img src=\"http://img.javastack.cn/18-5-31/71458405.jpg\"></p>\n<h4 id=\"5-MESI-协议\"><a href=\"#5-MESI-协议\" class=\"headerlink\" title=\"5. MESI 协议\"></a>5. MESI 协议</h4><p>多核 CPU 都有自己的专有缓存（一般为L1，L2），以及同一个 CPU 插槽之间的核共享的缓存（一般为L3）。不同核心的CPU缓存中难免会加载同样的数据，那么如何保证数据的一致性呢，就是 MESI 协议了。</p>\n<p>在 MESI 协议中，每个 Cache line 有4个状态，可用 2 个 bit 表示，它们分别是：<br>M(Modified)：这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本 Cache 中；<br>E(Exclusive)：这行数据有效，数据和内存中的数据一致，数据只存在于本 Cache 中；<br>S(Shared)：这行数据有效，数据和内存中的数据一致，数据存在于很多 Cache 中；<br>I(Invalid)：这行数据无效。</p>\n<p>那么，假设有一个变量i&#x3D;3（应该是包括变量i的缓存块，块大小为缓存行大小）；已经加载到多核（a,b,c）的缓存中，此时该缓存行的状态为S；此时其中的一个核a改变了变量i的值，那么在核a中的当前缓存行的状态将变为M，b,c核中的当前缓存行状态将变为I。如下图：</p>\n<p><img src=\"http://img.javastack.cn/18-5-31/66429246.jpg\"></p>\n<h4 id=\"6-解决原理\"><a href=\"#6-解决原理\" class=\"headerlink\" title=\"6. 解决原理\"></a>6. 解决原理</h4><p>为了避免由于 false sharing 导致 Cache Line 从 L1,L2,L3 到主存之间重复载入，我们可以使用数据填充的方式来避免，即单个数据填充满一个CacheLine。这本质是一种空间换时间的做法。</p>\n<h4 id=\"7-Java-对于伪共享的传统解决方案\"><a href=\"#7-Java-对于伪共享的传统解决方案\" class=\"headerlink\" title=\"7. Java 对于伪共享的传统解决方案\"></a>7. Java 对于伪共享的传统解决方案</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;***\n* \n**&#x2F;\nimport java.util.concurrent.atomic.AtomicLong;\n\npublic final class FalseSharing\n    implements Runnable\n&#123;\n    public final static int NUM_THREADS &#x3D; 4; &#x2F;&#x2F; change\n    public final static long ITERATIONS &#x3D; 500L * 1000L * 1000L;\n    private final int arrayIndex;\n\n    private static VolatileLong[] longs &#x3D; new VolatileLong[NUM_THREADS];\n    static\n    &#123;\n        for (int i &#x3D; 0; i &lt; longs.length; i++)\n        &#123;\n            longs[i] &#x3D; new VolatileLong();\n        &#125;\n    &#125;\n\n    public FalseSharing(final int arrayIndex)\n    &#123;\n        this.arrayIndex &#x3D; arrayIndex;\n    &#125;\n\n    public static void main(final String[] args) throws Exception\n    &#123;\n        final long start &#x3D; System.nanoTime();\n        runTest();\n        System.out.println(&quot;duration &#x3D; &quot; + (System.nanoTime() - start));\n    &#125;\n\n    private static void runTest() throws InterruptedException\n    &#123;\n        Thread[] threads &#x3D; new Thread[NUM_THREADS];\n\n        for (int i &#x3D; 0; i &lt; threads.length; i++)\n        &#123;\n            threads[i] &#x3D; new Thread(new FalseSharing(i));\n        &#125;\n\n        for (Thread t : threads)\n        &#123;\n            t.start();\n        &#125;\n\n        for (Thread t : threads)\n        &#123;\n            t.join();\n        &#125;\n    &#125;\n\n    public void run()\n    &#123;\n        long i &#x3D; ITERATIONS + 1;\n        while (0 !&#x3D; --i)\n        &#123;\n            longs[arrayIndex].set(i);\n        &#125;\n    &#125;\n\n    public static long sumPaddingToPreventOptimisation(final int index)\n    &#123;\n        VolatileLong v &#x3D; longs[index];\n        return v.p1 + v.p2 + v.p3 + v.p4 + v.p5 + v.p6;\n    &#125;\n\n    &#x2F;&#x2F;jdk7以上使用此方法(jdk7的某个版本oracle对伪共享做了优化)\n    public final static class VolatileLong\n    &#123;\n        public volatile long value &#x3D; 0L;\n        public long p1, p2, p3, p4, p5, p6;\n    &#125;\n\n    &#x2F;&#x2F; jdk7以下使用此方法\n    public final static class VolatileLong\n    &#123;\n        public long p1, p2, p3, p4, p5, p6, p7; &#x2F;&#x2F; cache line padding\n        public volatile long value &#x3D; 0L;\n        public long p8, p9, p10, p11, p12, p13, p14; &#x2F;&#x2F; cache line padding\n\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<h4 id=\"8-Java-8-中的解决方案\"><a href=\"#8-Java-8-中的解决方案\" class=\"headerlink\" title=\"8. Java 8 中的解决方案\"></a>8. Java 8 中的解决方案</h4><p>Java 8 中已经提供了官方的解决方案，Java 8 中新增了一个注解：<code>@sun.misc.Contended</code>。加上这个注解的类会自动补齐缓存行，需要注意的是此注解默认是无效的，需要在 jvm 启动时设置 <code>-XX:-RestrictContended</code> 才会生效。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@sun.misc.Contended\npublic final static class VolatileLong &#123;\n    public volatile long value &#x3D; 0L;\n    &#x2F;&#x2F;public long p1, p2, p3, p4, p5, p6;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<h4 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h4><blockquote>\n<p><a href=\"http://igoro.com/archive/gallery-of-processor-cache-effects/\">http://igoro.com/archive/gallery-of-processor-cache-effects/</a><br><a href=\"http://ifeve.com/false-sharing/\">http://ifeve.com/false-sharing/</a><br><a href=\"http://blog.csdn.net/muxiqingyang/article/details/6615199\">http://blog.csdn.net/muxiqingyang/article/details/6615199</a><br><a href=\"https://yq.aliyun.com/articles/62865\">https://yq.aliyun.com/articles/62865</a></p>\n</blockquote>\n<p>@码农们，你们是怎么理解和解决伪共享的？欢迎留言！</p>\n"},{"title":"Java 中的宏变量，宏替换详解。","date":"2025-10-15T03:36:33.000Z","_content":"\n\n首先来看下面这段程序，和群友分享的大致一样。\n\n```\npublic static void main(String[] args) {\n    String hw = \"hello world\";\n    \n    String hello = \"hello\";\n    final String finalWorld2 = \"hello\";\n    final String finalWorld3 = hello;\n    final String finalWorld4 = \"he\" + \"llo\";\n    \n    String hw1 = hello + \" world\";\n    String hw2 = finalWorld2 + \" world\";\n    String hw3 = finalWorld3 + \" world\";\n    String hw4 = finalWorld4 + \" world\";\n    \n    System.out.println(hw == hw1);\n    System.out.println(hw == hw2);\n    System.out.println(hw == hw3);\n    System.out.println(hw == hw4);\n}\n```\n\n程序输出：\n\n```\nfalse\ntrue\nfalse\ntrue\n```\n\n同样是字符串\"hello\"，为什么用final定义的，且个进行==操作却是true有一个是false，而没用final的却是false?\n\n**首先来理解下宏变量：**\n\nJava中，一个用final定义的变量，不管它是类型的变量，只要用final定义了并同时指定了初始值，并且这个初始值是在编译时就被确定下来的，那么这个final变量就是一个宏变量。编译器会把程序所有用到该变量的地方直接替换成该变量的值，也就是说编译器能对宏变量进行宏替换。\n\n如：\n\n```\nfinal String a = \"hello\";\nfinal String b = a;\nfinal String c = getHello();\n```\n\na在编译期间就能确定下来，而b、c不行，所以a是宏变量，b、c不是。\n\n所以，再回到上面的程序，finalWorld2和finalWorld4是final定义的，也是在编译期间能确定下来的，所以它能被宏替换，编译器就会让finalWorld2和finalWorld4指向字符串池中缓存的字符串\"\"hello world\"，所以它们就是同一个对象。\n\n","source":"_posts/进阶/Java 中的宏变量，宏替换详解。.md","raw":"---\ntitle: Java 中的宏变量，宏替换详解。\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 进阶\n---\n\n\n首先来看下面这段程序，和群友分享的大致一样。\n\n```\npublic static void main(String[] args) {\n    String hw = \"hello world\";\n    \n    String hello = \"hello\";\n    final String finalWorld2 = \"hello\";\n    final String finalWorld3 = hello;\n    final String finalWorld4 = \"he\" + \"llo\";\n    \n    String hw1 = hello + \" world\";\n    String hw2 = finalWorld2 + \" world\";\n    String hw3 = finalWorld3 + \" world\";\n    String hw4 = finalWorld4 + \" world\";\n    \n    System.out.println(hw == hw1);\n    System.out.println(hw == hw2);\n    System.out.println(hw == hw3);\n    System.out.println(hw == hw4);\n}\n```\n\n程序输出：\n\n```\nfalse\ntrue\nfalse\ntrue\n```\n\n同样是字符串\"hello\"，为什么用final定义的，且个进行==操作却是true有一个是false，而没用final的却是false?\n\n**首先来理解下宏变量：**\n\nJava中，一个用final定义的变量，不管它是类型的变量，只要用final定义了并同时指定了初始值，并且这个初始值是在编译时就被确定下来的，那么这个final变量就是一个宏变量。编译器会把程序所有用到该变量的地方直接替换成该变量的值，也就是说编译器能对宏变量进行宏替换。\n\n如：\n\n```\nfinal String a = \"hello\";\nfinal String b = a;\nfinal String c = getHello();\n```\n\na在编译期间就能确定下来，而b、c不行，所以a是宏变量，b、c不是。\n\n所以，再回到上面的程序，finalWorld2和finalWorld4是final定义的，也是在编译期间能确定下来的，所以它能被宏替换，编译器就会让finalWorld2和finalWorld4指向字符串池中缓存的字符串\"\"hello world\"，所以它们就是同一个对象。\n\n","slug":"进阶/Java 中的宏变量，宏替换详解。","published":1,"updated":"2025-10-15T07:21:14.269Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076d000eqkd4glyl48p9","content":"<p>首先来看下面这段程序，和群友分享的大致一样。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    String hw &#x3D; &quot;hello world&quot;;\n    \n    String hello &#x3D; &quot;hello&quot;;\n    final String finalWorld2 &#x3D; &quot;hello&quot;;\n    final String finalWorld3 &#x3D; hello;\n    final String finalWorld4 &#x3D; &quot;he&quot; + &quot;llo&quot;;\n    \n    String hw1 &#x3D; hello + &quot; world&quot;;\n    String hw2 &#x3D; finalWorld2 + &quot; world&quot;;\n    String hw3 &#x3D; finalWorld3 + &quot; world&quot;;\n    String hw4 &#x3D; finalWorld4 + &quot; world&quot;;\n    \n    System.out.println(hw &#x3D;&#x3D; hw1);\n    System.out.println(hw &#x3D;&#x3D; hw2);\n    System.out.println(hw &#x3D;&#x3D; hw3);\n    System.out.println(hw &#x3D;&#x3D; hw4);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">false\ntrue\nfalse\ntrue<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>同样是字符串”hello”，为什么用final定义的，且个进行&#x3D;&#x3D;操作却是true有一个是false，而没用final的却是false?</p>\n<p><strong>首先来理解下宏变量：</strong></p>\n<p>Java中，一个用final定义的变量，不管它是类型的变量，只要用final定义了并同时指定了初始值，并且这个初始值是在编译时就被确定下来的，那么这个final变量就是一个宏变量。编译器会把程序所有用到该变量的地方直接替换成该变量的值，也就是说编译器能对宏变量进行宏替换。</p>\n<p>如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final String a &#x3D; &quot;hello&quot;;\nfinal String b &#x3D; a;\nfinal String c &#x3D; getHello();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>a在编译期间就能确定下来，而b、c不行，所以a是宏变量，b、c不是。</p>\n<p>所以，再回到上面的程序，finalWorld2和finalWorld4是final定义的，也是在编译期间能确定下来的，所以它能被宏替换，编译器就会让finalWorld2和finalWorld4指向字符串池中缓存的字符串””hello world”，所以它们就是同一个对象。</p>\n","excerpt":"","more":"<p>首先来看下面这段程序，和群友分享的大致一样。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    String hw &#x3D; &quot;hello world&quot;;\n    \n    String hello &#x3D; &quot;hello&quot;;\n    final String finalWorld2 &#x3D; &quot;hello&quot;;\n    final String finalWorld3 &#x3D; hello;\n    final String finalWorld4 &#x3D; &quot;he&quot; + &quot;llo&quot;;\n    \n    String hw1 &#x3D; hello + &quot; world&quot;;\n    String hw2 &#x3D; finalWorld2 + &quot; world&quot;;\n    String hw3 &#x3D; finalWorld3 + &quot; world&quot;;\n    String hw4 &#x3D; finalWorld4 + &quot; world&quot;;\n    \n    System.out.println(hw &#x3D;&#x3D; hw1);\n    System.out.println(hw &#x3D;&#x3D; hw2);\n    System.out.println(hw &#x3D;&#x3D; hw3);\n    System.out.println(hw &#x3D;&#x3D; hw4);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">false\ntrue\nfalse\ntrue<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>同样是字符串”hello”，为什么用final定义的，且个进行&#x3D;&#x3D;操作却是true有一个是false，而没用final的却是false?</p>\n<p><strong>首先来理解下宏变量：</strong></p>\n<p>Java中，一个用final定义的变量，不管它是类型的变量，只要用final定义了并同时指定了初始值，并且这个初始值是在编译时就被确定下来的，那么这个final变量就是一个宏变量。编译器会把程序所有用到该变量的地方直接替换成该变量的值，也就是说编译器能对宏变量进行宏替换。</p>\n<p>如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final String a &#x3D; &quot;hello&quot;;\nfinal String b &#x3D; a;\nfinal String c &#x3D; getHello();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>a在编译期间就能确定下来，而b、c不行，所以a是宏变量，b、c不是。</p>\n<p>所以，再回到上面的程序，finalWorld2和finalWorld4是final定义的，也是在编译期间能确定下来的，所以它能被宏替换，编译器就会让finalWorld2和finalWorld4指向字符串池中缓存的字符串””hello world”，所以它们就是同一个对象。</p>\n"},{"title":"Java 中获取类名的三种方法，你知道几种？","date":"2025-10-15T03:36:33.000Z","_content":"#### 获取类名的方法\n\nJava 中获取类名的方式主要有以下三种。\n\n- **getName()**\n\n返回的是虚拟机里面的class的类名表现形式。\n\n- **getCanonicalName()**\n\n返回的是更容易理解的类名表示。\n\n- **getSimpleName()**\n\n返回的是类的简称。\n\n#### 都有什么区别？\n\n通过一个实例来看下它们主要的区别。\n\n```\npublic class TestClass {\n\n\tpublic static void main(String[] args) {\n\t\t// 外部普通类\n\t\tSystem.out.println(\"方法名             类名\");\n\t\tSystem.out.println(\"getName            \" + TestClass.class.getName());\n\t\tSystem.out.println(\"getCanonicalName   \" + TestClass.class.getCanonicalName());\n\t\tSystem.out.println(\"getSimpleName      \" + TestClass.class.getSimpleName());\n\t\tSystem.out.println();\n\n\t\t// 内部类\n\t\tSystem.out.println(\"getName            \" + TestInnerClass.class.getName());\n\t\tSystem.out.println(\"getCanonicalName   \" + TestInnerClass.class.getCanonicalName());\n\t\tSystem.out.println(\"getSimpleName      \" + TestInnerClass.class.getSimpleName());\n\t\tSystem.out.println();\n\n\t\t// 数组类\n\t\tTestInnerClass[] testInnerClasses = new TestInnerClass[]{\n\t\t\t\tnew TestInnerClass(),\n\t\t\t\tnew TestInnerClass(),\n\t\t\t\tnew TestInnerClass()\n\t\t};\n\t\tSystem.out.println(\"getName            \" + testInnerClasses.getClass().getName());\n\t\tSystem.out.println(\"getCanonicalName   \" + testInnerClasses.getClass().getCanonicalName());\n\t\tSystem.out.println(\"getSimpleName      \" + testInnerClasses.getClass().getSimpleName());\n\t\tSystem.out.println();\n\t}\n\n\tstatic class TestInnerClass {\n\n\t}\n\n}\n```\n\n程序输出以下结果。\n\n```\n方法名              类名\ngetName            com.test.TestClass\ngetCanonicalName   com.test.TestClass\ngetSimpleName      TestClass\n\ngetName            com.test.TestClass$TestInnerClass\ngetCanonicalName   com.test.TestClass.TestInnerClass\ngetSimpleName      TestInnerClass\n\ngetName            [Lcom.test.TestClass$TestInnerClass;\ngetCanonicalName   com.test.TestClass.TestInnerClass[]\ngetSimpleName      TestInnerClass[]\n```\n\n`[Lcom.test.TestClass$TestInnerClass;`值得说明一下。\n\n这是一种对函数返回值和参数的编码，叫做JNI字段描述符（JavaNative Interface FieldDescriptors)。\n\n`[` 表示数组，一个代表一维数组，比如 `[[` 代表二维数组。之后 `L` 代表类描述符，最后`;`表示类名结束。\n\n#### 结论\n\n1、从以上结果可以看出 getName() 和 getCanonicalName() 在获取普通类名的时候没有区别，在获取内部类和数组类有区别的。\n\n2、getSimpleName() 在获取普通类和内部类名的时候没区别，在获取数组类的时候有区别。\n\n","source":"_posts/进阶/Java 中获取类名的三种方法，你知道几种？.md","raw":"---\ntitle: Java 中获取类名的三种方法，你知道几种？\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 进阶\n---\n#### 获取类名的方法\n\nJava 中获取类名的方式主要有以下三种。\n\n- **getName()**\n\n返回的是虚拟机里面的class的类名表现形式。\n\n- **getCanonicalName()**\n\n返回的是更容易理解的类名表示。\n\n- **getSimpleName()**\n\n返回的是类的简称。\n\n#### 都有什么区别？\n\n通过一个实例来看下它们主要的区别。\n\n```\npublic class TestClass {\n\n\tpublic static void main(String[] args) {\n\t\t// 外部普通类\n\t\tSystem.out.println(\"方法名             类名\");\n\t\tSystem.out.println(\"getName            \" + TestClass.class.getName());\n\t\tSystem.out.println(\"getCanonicalName   \" + TestClass.class.getCanonicalName());\n\t\tSystem.out.println(\"getSimpleName      \" + TestClass.class.getSimpleName());\n\t\tSystem.out.println();\n\n\t\t// 内部类\n\t\tSystem.out.println(\"getName            \" + TestInnerClass.class.getName());\n\t\tSystem.out.println(\"getCanonicalName   \" + TestInnerClass.class.getCanonicalName());\n\t\tSystem.out.println(\"getSimpleName      \" + TestInnerClass.class.getSimpleName());\n\t\tSystem.out.println();\n\n\t\t// 数组类\n\t\tTestInnerClass[] testInnerClasses = new TestInnerClass[]{\n\t\t\t\tnew TestInnerClass(),\n\t\t\t\tnew TestInnerClass(),\n\t\t\t\tnew TestInnerClass()\n\t\t};\n\t\tSystem.out.println(\"getName            \" + testInnerClasses.getClass().getName());\n\t\tSystem.out.println(\"getCanonicalName   \" + testInnerClasses.getClass().getCanonicalName());\n\t\tSystem.out.println(\"getSimpleName      \" + testInnerClasses.getClass().getSimpleName());\n\t\tSystem.out.println();\n\t}\n\n\tstatic class TestInnerClass {\n\n\t}\n\n}\n```\n\n程序输出以下结果。\n\n```\n方法名              类名\ngetName            com.test.TestClass\ngetCanonicalName   com.test.TestClass\ngetSimpleName      TestClass\n\ngetName            com.test.TestClass$TestInnerClass\ngetCanonicalName   com.test.TestClass.TestInnerClass\ngetSimpleName      TestInnerClass\n\ngetName            [Lcom.test.TestClass$TestInnerClass;\ngetCanonicalName   com.test.TestClass.TestInnerClass[]\ngetSimpleName      TestInnerClass[]\n```\n\n`[Lcom.test.TestClass$TestInnerClass;`值得说明一下。\n\n这是一种对函数返回值和参数的编码，叫做JNI字段描述符（JavaNative Interface FieldDescriptors)。\n\n`[` 表示数组，一个代表一维数组，比如 `[[` 代表二维数组。之后 `L` 代表类描述符，最后`;`表示类名结束。\n\n#### 结论\n\n1、从以上结果可以看出 getName() 和 getCanonicalName() 在获取普通类名的时候没有区别，在获取内部类和数组类有区别的。\n\n2、getSimpleName() 在获取普通类和内部类名的时候没区别，在获取数组类的时候有区别。\n\n","slug":"进阶/Java 中获取类名的三种方法，你知道几种？","published":1,"updated":"2025-10-15T07:21:14.226Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076e000iqkd4d2ck5ag5","content":"<h4 id=\"获取类名的方法\"><a href=\"#获取类名的方法\" class=\"headerlink\" title=\"获取类名的方法\"></a>获取类名的方法</h4><p>Java 中获取类名的方式主要有以下三种。</p>\n<ul>\n<li><strong>getName()</strong></li>\n</ul>\n<p>返回的是虚拟机里面的class的类名表现形式。</p>\n<ul>\n<li><strong>getCanonicalName()</strong></li>\n</ul>\n<p>返回的是更容易理解的类名表示。</p>\n<ul>\n<li><strong>getSimpleName()</strong></li>\n</ul>\n<p>返回的是类的简称。</p>\n<h4 id=\"都有什么区别？\"><a href=\"#都有什么区别？\" class=\"headerlink\" title=\"都有什么区别？\"></a>都有什么区别？</h4><p>通过一个实例来看下它们主要的区别。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class TestClass &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\t&#x2F;&#x2F; 外部普通类\n\t\tSystem.out.println(&quot;方法名             类名&quot;);\n\t\tSystem.out.println(&quot;getName            &quot; + TestClass.class.getName());\n\t\tSystem.out.println(&quot;getCanonicalName   &quot; + TestClass.class.getCanonicalName());\n\t\tSystem.out.println(&quot;getSimpleName      &quot; + TestClass.class.getSimpleName());\n\t\tSystem.out.println();\n\n\t\t&#x2F;&#x2F; 内部类\n\t\tSystem.out.println(&quot;getName            &quot; + TestInnerClass.class.getName());\n\t\tSystem.out.println(&quot;getCanonicalName   &quot; + TestInnerClass.class.getCanonicalName());\n\t\tSystem.out.println(&quot;getSimpleName      &quot; + TestInnerClass.class.getSimpleName());\n\t\tSystem.out.println();\n\n\t\t&#x2F;&#x2F; 数组类\n\t\tTestInnerClass[] testInnerClasses &#x3D; new TestInnerClass[]&#123;\n\t\t\t\tnew TestInnerClass(),\n\t\t\t\tnew TestInnerClass(),\n\t\t\t\tnew TestInnerClass()\n\t\t&#125;;\n\t\tSystem.out.println(&quot;getName            &quot; + testInnerClasses.getClass().getName());\n\t\tSystem.out.println(&quot;getCanonicalName   &quot; + testInnerClasses.getClass().getCanonicalName());\n\t\tSystem.out.println(&quot;getSimpleName      &quot; + testInnerClasses.getClass().getSimpleName());\n\t\tSystem.out.println();\n\t&#125;\n\n\tstatic class TestInnerClass &#123;\n\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出以下结果。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">方法名              类名\ngetName            com.test.TestClass\ngetCanonicalName   com.test.TestClass\ngetSimpleName      TestClass\n\ngetName            com.test.TestClass$TestInnerClass\ngetCanonicalName   com.test.TestClass.TestInnerClass\ngetSimpleName      TestInnerClass\n\ngetName            [Lcom.test.TestClass$TestInnerClass;\ngetCanonicalName   com.test.TestClass.TestInnerClass[]\ngetSimpleName      TestInnerClass[]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>[Lcom.test.TestClass$TestInnerClass;</code>值得说明一下。</p>\n<p>这是一种对函数返回值和参数的编码，叫做JNI字段描述符（JavaNative Interface FieldDescriptors)。</p>\n<p><code>[</code> 表示数组，一个代表一维数组，比如 <code>[[</code> 代表二维数组。之后 <code>L</code> 代表类描述符，最后<code>;</code>表示类名结束。</p>\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>1、从以上结果可以看出 getName() 和 getCanonicalName() 在获取普通类名的时候没有区别，在获取内部类和数组类有区别的。</p>\n<p>2、getSimpleName() 在获取普通类和内部类名的时候没区别，在获取数组类的时候有区别。</p>\n","excerpt":"","more":"<h4 id=\"获取类名的方法\"><a href=\"#获取类名的方法\" class=\"headerlink\" title=\"获取类名的方法\"></a>获取类名的方法</h4><p>Java 中获取类名的方式主要有以下三种。</p>\n<ul>\n<li><strong>getName()</strong></li>\n</ul>\n<p>返回的是虚拟机里面的class的类名表现形式。</p>\n<ul>\n<li><strong>getCanonicalName()</strong></li>\n</ul>\n<p>返回的是更容易理解的类名表示。</p>\n<ul>\n<li><strong>getSimpleName()</strong></li>\n</ul>\n<p>返回的是类的简称。</p>\n<h4 id=\"都有什么区别？\"><a href=\"#都有什么区别？\" class=\"headerlink\" title=\"都有什么区别？\"></a>都有什么区别？</h4><p>通过一个实例来看下它们主要的区别。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class TestClass &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\t&#x2F;&#x2F; 外部普通类\n\t\tSystem.out.println(&quot;方法名             类名&quot;);\n\t\tSystem.out.println(&quot;getName            &quot; + TestClass.class.getName());\n\t\tSystem.out.println(&quot;getCanonicalName   &quot; + TestClass.class.getCanonicalName());\n\t\tSystem.out.println(&quot;getSimpleName      &quot; + TestClass.class.getSimpleName());\n\t\tSystem.out.println();\n\n\t\t&#x2F;&#x2F; 内部类\n\t\tSystem.out.println(&quot;getName            &quot; + TestInnerClass.class.getName());\n\t\tSystem.out.println(&quot;getCanonicalName   &quot; + TestInnerClass.class.getCanonicalName());\n\t\tSystem.out.println(&quot;getSimpleName      &quot; + TestInnerClass.class.getSimpleName());\n\t\tSystem.out.println();\n\n\t\t&#x2F;&#x2F; 数组类\n\t\tTestInnerClass[] testInnerClasses &#x3D; new TestInnerClass[]&#123;\n\t\t\t\tnew TestInnerClass(),\n\t\t\t\tnew TestInnerClass(),\n\t\t\t\tnew TestInnerClass()\n\t\t&#125;;\n\t\tSystem.out.println(&quot;getName            &quot; + testInnerClasses.getClass().getName());\n\t\tSystem.out.println(&quot;getCanonicalName   &quot; + testInnerClasses.getClass().getCanonicalName());\n\t\tSystem.out.println(&quot;getSimpleName      &quot; + testInnerClasses.getClass().getSimpleName());\n\t\tSystem.out.println();\n\t&#125;\n\n\tstatic class TestInnerClass &#123;\n\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出以下结果。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">方法名              类名\ngetName            com.test.TestClass\ngetCanonicalName   com.test.TestClass\ngetSimpleName      TestClass\n\ngetName            com.test.TestClass$TestInnerClass\ngetCanonicalName   com.test.TestClass.TestInnerClass\ngetSimpleName      TestInnerClass\n\ngetName            [Lcom.test.TestClass$TestInnerClass;\ngetCanonicalName   com.test.TestClass.TestInnerClass[]\ngetSimpleName      TestInnerClass[]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>[Lcom.test.TestClass$TestInnerClass;</code>值得说明一下。</p>\n<p>这是一种对函数返回值和参数的编码，叫做JNI字段描述符（JavaNative Interface FieldDescriptors)。</p>\n<p><code>[</code> 表示数组，一个代表一维数组，比如 <code>[[</code> 代表二维数组。之后 <code>L</code> 代表类描述符，最后<code>;</code>表示类名结束。</p>\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>1、从以上结果可以看出 getName() 和 getCanonicalName() 在获取普通类名的时候没有区别，在获取内部类和数组类有区别的。</p>\n<p>2、getSimpleName() 在获取普通类和内部类名的时候没区别，在获取数组类的时候有区别。</p>\n"},{"title":"Java 对象引用四个级别（强、软、弱、虚）","date":"2025-10-15T03:36:33.000Z","_content":"\n![image](http://img.javastack.cn/17-12-27/5366993.jpg)\n\n\n为了使程序能更加灵活地控制对象的生命周期，从JDK1.2版本开始，JDK把对象的引用级别分为了以下四种。\n\n**这4种级别由高到低依次为：**\n\n- 强引用（StrongReference）\n\n强引用就是我们平常最基本的对象引用，如果是强引用，那回收器不会回收带有强引用的对象。即使内存不足抛出OutOfMemoryError异常也不会回收强引用对象，存在即合理吧。\n\n如：\n```\nUser user = new User(\"Java技术\");\n```\n这就是强引用，user持有了这个对象的存储地址的引用。\n\n- 软引用（SoftReference）\n\n一个对象只有软引用，如果内存空间足够情况下垃圾回收器就不会回收它，如果内存空间不够了就会对这些只有软引用的对象进行回收。只要垃圾回收器没有回收，该软引用对象就可以继续被程序使用。\n\n所以软引用一般用来实现一些内存敏感的缓存，只要内存空间足够，对象就会保持不被回收掉。\n\n- 弱引用（WeakReference）\n\n弱引用的对象具有更短暂的生命周期，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。\n\n弱引用可以用来实现一些规范化映射，如WeakHashMap，当key或者value不再被引用时可以自动被回收。\n\n- 虚引用（PhantomReference）\n\n虚引用顾名思义就是形同虚设，虚引用并不决定对象的生命周期，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。\n\n虚引用主要用来跟踪对象被垃圾回收器回收的活动，虚引用必须和引用队列（ReferenceQueue）联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。\n\n**下面通过一张表格来说明它们的回收时间、用途。**\n\n\n引用类型 | 回收时间 | 用途\n---|---|---\n强引用 | 永不回收 | 普通对象引用\n软引用 | 内在不足回收 | 缓存对象\n弱引用 | 垃圾回收时 | 缓存对象\n虚引用 | 不确定 | 不确定\n\n不管这些东西平时有没有用到，我们都必须了解这些机制，这对个人的知识面及拓展是非常有帮助的。\n\n\n","source":"_posts/进阶/Java 对象引用四个级别（强、软、弱、虚）.md","raw":"---\ntitle: Java 对象引用四个级别（强、软、弱、虚）\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 进阶\n---\n\n![image](http://img.javastack.cn/17-12-27/5366993.jpg)\n\n\n为了使程序能更加灵活地控制对象的生命周期，从JDK1.2版本开始，JDK把对象的引用级别分为了以下四种。\n\n**这4种级别由高到低依次为：**\n\n- 强引用（StrongReference）\n\n强引用就是我们平常最基本的对象引用，如果是强引用，那回收器不会回收带有强引用的对象。即使内存不足抛出OutOfMemoryError异常也不会回收强引用对象，存在即合理吧。\n\n如：\n```\nUser user = new User(\"Java技术\");\n```\n这就是强引用，user持有了这个对象的存储地址的引用。\n\n- 软引用（SoftReference）\n\n一个对象只有软引用，如果内存空间足够情况下垃圾回收器就不会回收它，如果内存空间不够了就会对这些只有软引用的对象进行回收。只要垃圾回收器没有回收，该软引用对象就可以继续被程序使用。\n\n所以软引用一般用来实现一些内存敏感的缓存，只要内存空间足够，对象就会保持不被回收掉。\n\n- 弱引用（WeakReference）\n\n弱引用的对象具有更短暂的生命周期，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。\n\n弱引用可以用来实现一些规范化映射，如WeakHashMap，当key或者value不再被引用时可以自动被回收。\n\n- 虚引用（PhantomReference）\n\n虚引用顾名思义就是形同虚设，虚引用并不决定对象的生命周期，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。\n\n虚引用主要用来跟踪对象被垃圾回收器回收的活动，虚引用必须和引用队列（ReferenceQueue）联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。\n\n**下面通过一张表格来说明它们的回收时间、用途。**\n\n\n引用类型 | 回收时间 | 用途\n---|---|---\n强引用 | 永不回收 | 普通对象引用\n软引用 | 内在不足回收 | 缓存对象\n弱引用 | 垃圾回收时 | 缓存对象\n虚引用 | 不确定 | 不确定\n\n不管这些东西平时有没有用到，我们都必须了解这些机制，这对个人的知识面及拓展是非常有帮助的。\n\n\n","slug":"进阶/Java 对象引用四个级别（强、软、弱、虚）","published":1,"updated":"2025-10-15T07:21:14.282Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076f000kqkd40a0y7rel","content":"<p><img src=\"http://img.javastack.cn/17-12-27/5366993.jpg\" alt=\"image\"></p>\n<p>为了使程序能更加灵活地控制对象的生命周期，从JDK1.2版本开始，JDK把对象的引用级别分为了以下四种。</p>\n<p><strong>这4种级别由高到低依次为：</strong></p>\n<ul>\n<li>强引用（StrongReference）</li>\n</ul>\n<p>强引用就是我们平常最基本的对象引用，如果是强引用，那回收器不会回收带有强引用的对象。即使内存不足抛出OutOfMemoryError异常也不会回收强引用对象，存在即合理吧。</p>\n<p>如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">User user &#x3D; new User(&quot;Java技术&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这就是强引用，user持有了这个对象的存储地址的引用。</p>\n<ul>\n<li>软引用（SoftReference）</li>\n</ul>\n<p>一个对象只有软引用，如果内存空间足够情况下垃圾回收器就不会回收它，如果内存空间不够了就会对这些只有软引用的对象进行回收。只要垃圾回收器没有回收，该软引用对象就可以继续被程序使用。</p>\n<p>所以软引用一般用来实现一些内存敏感的缓存，只要内存空间足够，对象就会保持不被回收掉。</p>\n<ul>\n<li>弱引用（WeakReference）</li>\n</ul>\n<p>弱引用的对象具有更短暂的生命周期，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p>\n<p>弱引用可以用来实现一些规范化映射，如WeakHashMap，当key或者value不再被引用时可以自动被回收。</p>\n<ul>\n<li>虚引用（PhantomReference）</li>\n</ul>\n<p>虚引用顾名思义就是形同虚设，虚引用并不决定对象的生命周期，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p>\n<p>虚引用主要用来跟踪对象被垃圾回收器回收的活动，虚引用必须和引用队列（ReferenceQueue）联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>\n<p><strong>下面通过一张表格来说明它们的回收时间、用途。</strong></p>\n<table>\n<thead>\n<tr>\n<th>引用类型</th>\n<th>回收时间</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>强引用</td>\n<td>永不回收</td>\n<td>普通对象引用</td>\n</tr>\n<tr>\n<td>软引用</td>\n<td>内在不足回收</td>\n<td>缓存对象</td>\n</tr>\n<tr>\n<td>弱引用</td>\n<td>垃圾回收时</td>\n<td>缓存对象</td>\n</tr>\n<tr>\n<td>虚引用</td>\n<td>不确定</td>\n<td>不确定</td>\n</tr>\n</tbody></table>\n<p>不管这些东西平时有没有用到，我们都必须了解这些机制，这对个人的知识面及拓展是非常有帮助的。</p>\n","excerpt":"","more":"<p><img src=\"http://img.javastack.cn/17-12-27/5366993.jpg\" alt=\"image\"></p>\n<p>为了使程序能更加灵活地控制对象的生命周期，从JDK1.2版本开始，JDK把对象的引用级别分为了以下四种。</p>\n<p><strong>这4种级别由高到低依次为：</strong></p>\n<ul>\n<li>强引用（StrongReference）</li>\n</ul>\n<p>强引用就是我们平常最基本的对象引用，如果是强引用，那回收器不会回收带有强引用的对象。即使内存不足抛出OutOfMemoryError异常也不会回收强引用对象，存在即合理吧。</p>\n<p>如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">User user &#x3D; new User(&quot;Java技术&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这就是强引用，user持有了这个对象的存储地址的引用。</p>\n<ul>\n<li>软引用（SoftReference）</li>\n</ul>\n<p>一个对象只有软引用，如果内存空间足够情况下垃圾回收器就不会回收它，如果内存空间不够了就会对这些只有软引用的对象进行回收。只要垃圾回收器没有回收，该软引用对象就可以继续被程序使用。</p>\n<p>所以软引用一般用来实现一些内存敏感的缓存，只要内存空间足够，对象就会保持不被回收掉。</p>\n<ul>\n<li>弱引用（WeakReference）</li>\n</ul>\n<p>弱引用的对象具有更短暂的生命周期，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p>\n<p>弱引用可以用来实现一些规范化映射，如WeakHashMap，当key或者value不再被引用时可以自动被回收。</p>\n<ul>\n<li>虚引用（PhantomReference）</li>\n</ul>\n<p>虚引用顾名思义就是形同虚设，虚引用并不决定对象的生命周期，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p>\n<p>虚引用主要用来跟踪对象被垃圾回收器回收的活动，虚引用必须和引用队列（ReferenceQueue）联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>\n<p><strong>下面通过一张表格来说明它们的回收时间、用途。</strong></p>\n<table>\n<thead>\n<tr>\n<th>引用类型</th>\n<th>回收时间</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>强引用</td>\n<td>永不回收</td>\n<td>普通对象引用</td>\n</tr>\n<tr>\n<td>软引用</td>\n<td>内在不足回收</td>\n<td>缓存对象</td>\n</tr>\n<tr>\n<td>弱引用</td>\n<td>垃圾回收时</td>\n<td>缓存对象</td>\n</tr>\n<tr>\n<td>虚引用</td>\n<td>不确定</td>\n<td>不确定</td>\n</tr>\n</tbody></table>\n<p>不管这些东西平时有没有用到，我们都必须了解这些机制，这对个人的知识面及拓展是非常有帮助的。</p>\n"},{"title":"Java 异常处理 10 个最佳实践","date":"2025-10-15T03:36:33.000Z","_content":"\n异常处理是Java 开发中的一个重要部分。它是关乎每个应用的一个非功能性需求，是为了处理任何错误状况，比如资源不可访问，非法输入，空输入等等。Java提供了几个异常处理特性，以try，catch 和 finally 关键字的形式内建于语言自身之中。Java 编程语言也允许你创建新的异常，并通过使用 throw 和 throws关键字抛出它们。事实上，在Java编程中，Java的异常处理不单单是知道语法这么简单，它必须遵循标准的JDK库，和几个处理错误和异常的开源代码。这里我们将讨论一些关于异常处理的Java 最佳实践。\n\n#### 1) 为可恢复的错误使用检查型异常，为编程错误使用非检查型错误。\n\n选择检查型还是非检查型异常，对于Java编程人员来说，总是让人感到困惑。检查型异常保证你对错误条件提供异常处理代码，这是一种从语言到强制你编写健壮的代码的一种方式，但同时会引入大量杂乱的代码并导致其不可读。当然，如果你有替代品和恢复策略的话，捕捉异常并做些什么看起来似乎也在理。在Java 编程中选择检查型异常还是运行时异常。\n\n#### 2) 在finally程序块中关闭或者释放资源\n\n这在Java编程中，是一个广为人知的最佳实践，在处理网络和IO类的时候，相当于一个标准。在finally块中关闭资源， 在正常和异常执行的情况下，保证之前和稀缺资源的合理释放，这由finally块保证。从Java7开始，该语言有了一项更有趣的功能：资源管理自动化或者ARM块能实现这一功能。尽管如此，我们仍然要记住在finally块中关闭资源，这是对于释放像FileDescriptors这类，应用在socket和文件编程的情况下的有限资源很重要的。\n\n\n\n#### 3) 在堆栈跟踪中包含引起异常的原因\n\n很多时候，当一个由另一个异常导致的异常被抛出的时候，Java库和开放源代码会将一种异常包装成另一种异常。日志记录和打印根异常就变得非常重要。 Java异常类提供了 getCause()方法来检索导致异常的原因，这些(原因)可以对异常的根层次的原因提供更多的信息。该Java实践对在进行调试或排除故障大有帮助。时刻记住，如果你将一个异常包装成另一种异常时，构造一个新异常要传递源异常。\n\n#### 4) 始终提供关于异常的有意义的完整的信息\n\n异常信息是最重要的地方，因为这是程序员首先看到的第一个地方，这里你能找到问题产生的根本原因。这里始终提供精确的真实的信息。\n\n#### 5) 避免过度使用检查型异常\n\n检查型异常在强制执行方面有一定的优势，但同时它也破坏了代码，通过掩盖业务逻辑使代码可读性降低。只要你不过度使用检查型异常，你可以最大限度的减少这类情况，这样做的结果是你会得到更清洁的代码。你同样可以使用Java7的新功能，以移除重复项。\n\n#### 6) 将检查型异常转为运行时异常\n\n这是在像Spring之类的多数框架中用来限制使用检查型异常的技术之一，大部分出自于JDBC的检查型异常，都被包装进 DataAccessException中，而(DataAccessException)异常是一种非检查型异常。这是Java最佳实践带来的好处，特定的异常限制到特定的模块，像 SQLException 放到DAO层，将意思明确的运行时异常抛到客户层。\n\n#### 7) 记住对性能而言，异常代价高昂\n\n需要记住的一件事是异常代价高昂，同时让你的代码运行缓慢。假如你有方法从ResultSet(结果集)中进行读取，这时常会抛出SQLException 异常而不会移到下一元素，这将会比不抛出异常的正常代码执行的慢的多。因此最大限度的减少不必要的异常捕捉和移动，那里没有什么固定的原因。不要仅仅是抛出和捕捉异常，如果你能使用boolean变量去表示执行结果，可能会得到更整洁，更高性能的解决方案。修正错误的根源，避免不必须要的异常捕捉。\n\n#### 8) 避免catch块为空\n\n没有什么比空的catch块更糟糕的了，因为它不仅隐藏了错误和异常，同时可能导致你的对象处于不可使用或者脏的状态。空的catch块只能变得无意义，如果你非常肯定异常不会继续以任何方式影响对象状态，但在程序执行期间，用日志记录错误依然是最好的(方法)。对于在Java编程中编写异常处理代码，这不仅仅是一个Java最佳实践，而是一个最通用的实践。\n\n#### 9) 使用标准异常\n\n我们的第九条最佳实践建议使用标准和内置的Java异常。使用标准异常而不是每次创建我们自己的异常，对于维护性和一致性，不管是现在还是以后，都是最好的选择。重用标准异常使代码更具可读性，因为大部分Java开发人员对标准的像源自于JDK的RuntimeException 异常，IllegalStateException 异常，Illegal Argument Exception 异常或者NullPointerException异常，(开发者)他们能一眼就知道每种异常的目的，而不是在代码里查找或者在文档里查找用户定义的异常的目的。\n\n#### 10) 记录任何方法抛出的异常\n\nJava提供了throw和throws关键字来抛出异常，在javadoc中用@throw记录任何方法可能会抛出的异常。如果你编写API或者公共接口，这就变得非常重要。任何方法抛出的异常都有相应的文档记录，这样你就能下意识的提醒任何使用(该方法)的人。\n\n这些就是所有在Java编程中在处理异常的时候需要遵循的最佳实践。让我们知道了什么是在Java编程中编写异常处理代码时需要遵循的实践。\n\n原文：https://www.oschina.net/translate/10-exception-handling-best-practices-in-java-programming\n\n","source":"_posts/进阶/Java 异常处理 10 个最佳实践.md","raw":"---\ntitle: Java 异常处理 10 个最佳实践\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 进阶\n---\n\n异常处理是Java 开发中的一个重要部分。它是关乎每个应用的一个非功能性需求，是为了处理任何错误状况，比如资源不可访问，非法输入，空输入等等。Java提供了几个异常处理特性，以try，catch 和 finally 关键字的形式内建于语言自身之中。Java 编程语言也允许你创建新的异常，并通过使用 throw 和 throws关键字抛出它们。事实上，在Java编程中，Java的异常处理不单单是知道语法这么简单，它必须遵循标准的JDK库，和几个处理错误和异常的开源代码。这里我们将讨论一些关于异常处理的Java 最佳实践。\n\n#### 1) 为可恢复的错误使用检查型异常，为编程错误使用非检查型错误。\n\n选择检查型还是非检查型异常，对于Java编程人员来说，总是让人感到困惑。检查型异常保证你对错误条件提供异常处理代码，这是一种从语言到强制你编写健壮的代码的一种方式，但同时会引入大量杂乱的代码并导致其不可读。当然，如果你有替代品和恢复策略的话，捕捉异常并做些什么看起来似乎也在理。在Java 编程中选择检查型异常还是运行时异常。\n\n#### 2) 在finally程序块中关闭或者释放资源\n\n这在Java编程中，是一个广为人知的最佳实践，在处理网络和IO类的时候，相当于一个标准。在finally块中关闭资源， 在正常和异常执行的情况下，保证之前和稀缺资源的合理释放，这由finally块保证。从Java7开始，该语言有了一项更有趣的功能：资源管理自动化或者ARM块能实现这一功能。尽管如此，我们仍然要记住在finally块中关闭资源，这是对于释放像FileDescriptors这类，应用在socket和文件编程的情况下的有限资源很重要的。\n\n\n\n#### 3) 在堆栈跟踪中包含引起异常的原因\n\n很多时候，当一个由另一个异常导致的异常被抛出的时候，Java库和开放源代码会将一种异常包装成另一种异常。日志记录和打印根异常就变得非常重要。 Java异常类提供了 getCause()方法来检索导致异常的原因，这些(原因)可以对异常的根层次的原因提供更多的信息。该Java实践对在进行调试或排除故障大有帮助。时刻记住，如果你将一个异常包装成另一种异常时，构造一个新异常要传递源异常。\n\n#### 4) 始终提供关于异常的有意义的完整的信息\n\n异常信息是最重要的地方，因为这是程序员首先看到的第一个地方，这里你能找到问题产生的根本原因。这里始终提供精确的真实的信息。\n\n#### 5) 避免过度使用检查型异常\n\n检查型异常在强制执行方面有一定的优势，但同时它也破坏了代码，通过掩盖业务逻辑使代码可读性降低。只要你不过度使用检查型异常，你可以最大限度的减少这类情况，这样做的结果是你会得到更清洁的代码。你同样可以使用Java7的新功能，以移除重复项。\n\n#### 6) 将检查型异常转为运行时异常\n\n这是在像Spring之类的多数框架中用来限制使用检查型异常的技术之一，大部分出自于JDBC的检查型异常，都被包装进 DataAccessException中，而(DataAccessException)异常是一种非检查型异常。这是Java最佳实践带来的好处，特定的异常限制到特定的模块，像 SQLException 放到DAO层，将意思明确的运行时异常抛到客户层。\n\n#### 7) 记住对性能而言，异常代价高昂\n\n需要记住的一件事是异常代价高昂，同时让你的代码运行缓慢。假如你有方法从ResultSet(结果集)中进行读取，这时常会抛出SQLException 异常而不会移到下一元素，这将会比不抛出异常的正常代码执行的慢的多。因此最大限度的减少不必要的异常捕捉和移动，那里没有什么固定的原因。不要仅仅是抛出和捕捉异常，如果你能使用boolean变量去表示执行结果，可能会得到更整洁，更高性能的解决方案。修正错误的根源，避免不必须要的异常捕捉。\n\n#### 8) 避免catch块为空\n\n没有什么比空的catch块更糟糕的了，因为它不仅隐藏了错误和异常，同时可能导致你的对象处于不可使用或者脏的状态。空的catch块只能变得无意义，如果你非常肯定异常不会继续以任何方式影响对象状态，但在程序执行期间，用日志记录错误依然是最好的(方法)。对于在Java编程中编写异常处理代码，这不仅仅是一个Java最佳实践，而是一个最通用的实践。\n\n#### 9) 使用标准异常\n\n我们的第九条最佳实践建议使用标准和内置的Java异常。使用标准异常而不是每次创建我们自己的异常，对于维护性和一致性，不管是现在还是以后，都是最好的选择。重用标准异常使代码更具可读性，因为大部分Java开发人员对标准的像源自于JDK的RuntimeException 异常，IllegalStateException 异常，Illegal Argument Exception 异常或者NullPointerException异常，(开发者)他们能一眼就知道每种异常的目的，而不是在代码里查找或者在文档里查找用户定义的异常的目的。\n\n#### 10) 记录任何方法抛出的异常\n\nJava提供了throw和throws关键字来抛出异常，在javadoc中用@throw记录任何方法可能会抛出的异常。如果你编写API或者公共接口，这就变得非常重要。任何方法抛出的异常都有相应的文档记录，这样你就能下意识的提醒任何使用(该方法)的人。\n\n这些就是所有在Java编程中在处理异常的时候需要遵循的最佳实践。让我们知道了什么是在Java编程中编写异常处理代码时需要遵循的实践。\n\n原文：https://www.oschina.net/translate/10-exception-handling-best-practices-in-java-programming\n\n","slug":"进阶/Java 异常处理 10 个最佳实践","published":1,"updated":"2025-10-15T07:21:14.273Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076f000oqkd4cxjcdawn","content":"<p>异常处理是Java 开发中的一个重要部分。它是关乎每个应用的一个非功能性需求，是为了处理任何错误状况，比如资源不可访问，非法输入，空输入等等。Java提供了几个异常处理特性，以try，catch 和 finally 关键字的形式内建于语言自身之中。Java 编程语言也允许你创建新的异常，并通过使用 throw 和 throws关键字抛出它们。事实上，在Java编程中，Java的异常处理不单单是知道语法这么简单，它必须遵循标准的JDK库，和几个处理错误和异常的开源代码。这里我们将讨论一些关于异常处理的Java 最佳实践。</p>\n<h4 id=\"1-为可恢复的错误使用检查型异常，为编程错误使用非检查型错误。\"><a href=\"#1-为可恢复的错误使用检查型异常，为编程错误使用非检查型错误。\" class=\"headerlink\" title=\"1) 为可恢复的错误使用检查型异常，为编程错误使用非检查型错误。\"></a>1) 为可恢复的错误使用检查型异常，为编程错误使用非检查型错误。</h4><p>选择检查型还是非检查型异常，对于Java编程人员来说，总是让人感到困惑。检查型异常保证你对错误条件提供异常处理代码，这是一种从语言到强制你编写健壮的代码的一种方式，但同时会引入大量杂乱的代码并导致其不可读。当然，如果你有替代品和恢复策略的话，捕捉异常并做些什么看起来似乎也在理。在Java 编程中选择检查型异常还是运行时异常。</p>\n<h4 id=\"2-在finally程序块中关闭或者释放资源\"><a href=\"#2-在finally程序块中关闭或者释放资源\" class=\"headerlink\" title=\"2) 在finally程序块中关闭或者释放资源\"></a>2) 在finally程序块中关闭或者释放资源</h4><p>这在Java编程中，是一个广为人知的最佳实践，在处理网络和IO类的时候，相当于一个标准。在finally块中关闭资源， 在正常和异常执行的情况下，保证之前和稀缺资源的合理释放，这由finally块保证。从Java7开始，该语言有了一项更有趣的功能：资源管理自动化或者ARM块能实现这一功能。尽管如此，我们仍然要记住在finally块中关闭资源，这是对于释放像FileDescriptors这类，应用在socket和文件编程的情况下的有限资源很重要的。</p>\n<h4 id=\"3-在堆栈跟踪中包含引起异常的原因\"><a href=\"#3-在堆栈跟踪中包含引起异常的原因\" class=\"headerlink\" title=\"3) 在堆栈跟踪中包含引起异常的原因\"></a>3) 在堆栈跟踪中包含引起异常的原因</h4><p>很多时候，当一个由另一个异常导致的异常被抛出的时候，Java库和开放源代码会将一种异常包装成另一种异常。日志记录和打印根异常就变得非常重要。 Java异常类提供了 getCause()方法来检索导致异常的原因，这些(原因)可以对异常的根层次的原因提供更多的信息。该Java实践对在进行调试或排除故障大有帮助。时刻记住，如果你将一个异常包装成另一种异常时，构造一个新异常要传递源异常。</p>\n<h4 id=\"4-始终提供关于异常的有意义的完整的信息\"><a href=\"#4-始终提供关于异常的有意义的完整的信息\" class=\"headerlink\" title=\"4) 始终提供关于异常的有意义的完整的信息\"></a>4) 始终提供关于异常的有意义的完整的信息</h4><p>异常信息是最重要的地方，因为这是程序员首先看到的第一个地方，这里你能找到问题产生的根本原因。这里始终提供精确的真实的信息。</p>\n<h4 id=\"5-避免过度使用检查型异常\"><a href=\"#5-避免过度使用检查型异常\" class=\"headerlink\" title=\"5) 避免过度使用检查型异常\"></a>5) 避免过度使用检查型异常</h4><p>检查型异常在强制执行方面有一定的优势，但同时它也破坏了代码，通过掩盖业务逻辑使代码可读性降低。只要你不过度使用检查型异常，你可以最大限度的减少这类情况，这样做的结果是你会得到更清洁的代码。你同样可以使用Java7的新功能，以移除重复项。</p>\n<h4 id=\"6-将检查型异常转为运行时异常\"><a href=\"#6-将检查型异常转为运行时异常\" class=\"headerlink\" title=\"6) 将检查型异常转为运行时异常\"></a>6) 将检查型异常转为运行时异常</h4><p>这是在像Spring之类的多数框架中用来限制使用检查型异常的技术之一，大部分出自于JDBC的检查型异常，都被包装进 DataAccessException中，而(DataAccessException)异常是一种非检查型异常。这是Java最佳实践带来的好处，特定的异常限制到特定的模块，像 SQLException 放到DAO层，将意思明确的运行时异常抛到客户层。</p>\n<h4 id=\"7-记住对性能而言，异常代价高昂\"><a href=\"#7-记住对性能而言，异常代价高昂\" class=\"headerlink\" title=\"7) 记住对性能而言，异常代价高昂\"></a>7) 记住对性能而言，异常代价高昂</h4><p>需要记住的一件事是异常代价高昂，同时让你的代码运行缓慢。假如你有方法从ResultSet(结果集)中进行读取，这时常会抛出SQLException 异常而不会移到下一元素，这将会比不抛出异常的正常代码执行的慢的多。因此最大限度的减少不必要的异常捕捉和移动，那里没有什么固定的原因。不要仅仅是抛出和捕捉异常，如果你能使用boolean变量去表示执行结果，可能会得到更整洁，更高性能的解决方案。修正错误的根源，避免不必须要的异常捕捉。</p>\n<h4 id=\"8-避免catch块为空\"><a href=\"#8-避免catch块为空\" class=\"headerlink\" title=\"8) 避免catch块为空\"></a>8) 避免catch块为空</h4><p>没有什么比空的catch块更糟糕的了，因为它不仅隐藏了错误和异常，同时可能导致你的对象处于不可使用或者脏的状态。空的catch块只能变得无意义，如果你非常肯定异常不会继续以任何方式影响对象状态，但在程序执行期间，用日志记录错误依然是最好的(方法)。对于在Java编程中编写异常处理代码，这不仅仅是一个Java最佳实践，而是一个最通用的实践。</p>\n<h4 id=\"9-使用标准异常\"><a href=\"#9-使用标准异常\" class=\"headerlink\" title=\"9) 使用标准异常\"></a>9) 使用标准异常</h4><p>我们的第九条最佳实践建议使用标准和内置的Java异常。使用标准异常而不是每次创建我们自己的异常，对于维护性和一致性，不管是现在还是以后，都是最好的选择。重用标准异常使代码更具可读性，因为大部分Java开发人员对标准的像源自于JDK的RuntimeException 异常，IllegalStateException 异常，Illegal Argument Exception 异常或者NullPointerException异常，(开发者)他们能一眼就知道每种异常的目的，而不是在代码里查找或者在文档里查找用户定义的异常的目的。</p>\n<h4 id=\"10-记录任何方法抛出的异常\"><a href=\"#10-记录任何方法抛出的异常\" class=\"headerlink\" title=\"10) 记录任何方法抛出的异常\"></a>10) 记录任何方法抛出的异常</h4><p>Java提供了throw和throws关键字来抛出异常，在javadoc中用@throw记录任何方法可能会抛出的异常。如果你编写API或者公共接口，这就变得非常重要。任何方法抛出的异常都有相应的文档记录，这样你就能下意识的提醒任何使用(该方法)的人。</p>\n<p>这些就是所有在Java编程中在处理异常的时候需要遵循的最佳实践。让我们知道了什么是在Java编程中编写异常处理代码时需要遵循的实践。</p>\n<p>原文：<a href=\"https://www.oschina.net/translate/10-exception-handling-best-practices-in-java-programming\">https://www.oschina.net/translate/10-exception-handling-best-practices-in-java-programming</a></p>\n","excerpt":"","more":"<p>异常处理是Java 开发中的一个重要部分。它是关乎每个应用的一个非功能性需求，是为了处理任何错误状况，比如资源不可访问，非法输入，空输入等等。Java提供了几个异常处理特性，以try，catch 和 finally 关键字的形式内建于语言自身之中。Java 编程语言也允许你创建新的异常，并通过使用 throw 和 throws关键字抛出它们。事实上，在Java编程中，Java的异常处理不单单是知道语法这么简单，它必须遵循标准的JDK库，和几个处理错误和异常的开源代码。这里我们将讨论一些关于异常处理的Java 最佳实践。</p>\n<h4 id=\"1-为可恢复的错误使用检查型异常，为编程错误使用非检查型错误。\"><a href=\"#1-为可恢复的错误使用检查型异常，为编程错误使用非检查型错误。\" class=\"headerlink\" title=\"1) 为可恢复的错误使用检查型异常，为编程错误使用非检查型错误。\"></a>1) 为可恢复的错误使用检查型异常，为编程错误使用非检查型错误。</h4><p>选择检查型还是非检查型异常，对于Java编程人员来说，总是让人感到困惑。检查型异常保证你对错误条件提供异常处理代码，这是一种从语言到强制你编写健壮的代码的一种方式，但同时会引入大量杂乱的代码并导致其不可读。当然，如果你有替代品和恢复策略的话，捕捉异常并做些什么看起来似乎也在理。在Java 编程中选择检查型异常还是运行时异常。</p>\n<h4 id=\"2-在finally程序块中关闭或者释放资源\"><a href=\"#2-在finally程序块中关闭或者释放资源\" class=\"headerlink\" title=\"2) 在finally程序块中关闭或者释放资源\"></a>2) 在finally程序块中关闭或者释放资源</h4><p>这在Java编程中，是一个广为人知的最佳实践，在处理网络和IO类的时候，相当于一个标准。在finally块中关闭资源， 在正常和异常执行的情况下，保证之前和稀缺资源的合理释放，这由finally块保证。从Java7开始，该语言有了一项更有趣的功能：资源管理自动化或者ARM块能实现这一功能。尽管如此，我们仍然要记住在finally块中关闭资源，这是对于释放像FileDescriptors这类，应用在socket和文件编程的情况下的有限资源很重要的。</p>\n<h4 id=\"3-在堆栈跟踪中包含引起异常的原因\"><a href=\"#3-在堆栈跟踪中包含引起异常的原因\" class=\"headerlink\" title=\"3) 在堆栈跟踪中包含引起异常的原因\"></a>3) 在堆栈跟踪中包含引起异常的原因</h4><p>很多时候，当一个由另一个异常导致的异常被抛出的时候，Java库和开放源代码会将一种异常包装成另一种异常。日志记录和打印根异常就变得非常重要。 Java异常类提供了 getCause()方法来检索导致异常的原因，这些(原因)可以对异常的根层次的原因提供更多的信息。该Java实践对在进行调试或排除故障大有帮助。时刻记住，如果你将一个异常包装成另一种异常时，构造一个新异常要传递源异常。</p>\n<h4 id=\"4-始终提供关于异常的有意义的完整的信息\"><a href=\"#4-始终提供关于异常的有意义的完整的信息\" class=\"headerlink\" title=\"4) 始终提供关于异常的有意义的完整的信息\"></a>4) 始终提供关于异常的有意义的完整的信息</h4><p>异常信息是最重要的地方，因为这是程序员首先看到的第一个地方，这里你能找到问题产生的根本原因。这里始终提供精确的真实的信息。</p>\n<h4 id=\"5-避免过度使用检查型异常\"><a href=\"#5-避免过度使用检查型异常\" class=\"headerlink\" title=\"5) 避免过度使用检查型异常\"></a>5) 避免过度使用检查型异常</h4><p>检查型异常在强制执行方面有一定的优势，但同时它也破坏了代码，通过掩盖业务逻辑使代码可读性降低。只要你不过度使用检查型异常，你可以最大限度的减少这类情况，这样做的结果是你会得到更清洁的代码。你同样可以使用Java7的新功能，以移除重复项。</p>\n<h4 id=\"6-将检查型异常转为运行时异常\"><a href=\"#6-将检查型异常转为运行时异常\" class=\"headerlink\" title=\"6) 将检查型异常转为运行时异常\"></a>6) 将检查型异常转为运行时异常</h4><p>这是在像Spring之类的多数框架中用来限制使用检查型异常的技术之一，大部分出自于JDBC的检查型异常，都被包装进 DataAccessException中，而(DataAccessException)异常是一种非检查型异常。这是Java最佳实践带来的好处，特定的异常限制到特定的模块，像 SQLException 放到DAO层，将意思明确的运行时异常抛到客户层。</p>\n<h4 id=\"7-记住对性能而言，异常代价高昂\"><a href=\"#7-记住对性能而言，异常代价高昂\" class=\"headerlink\" title=\"7) 记住对性能而言，异常代价高昂\"></a>7) 记住对性能而言，异常代价高昂</h4><p>需要记住的一件事是异常代价高昂，同时让你的代码运行缓慢。假如你有方法从ResultSet(结果集)中进行读取，这时常会抛出SQLException 异常而不会移到下一元素，这将会比不抛出异常的正常代码执行的慢的多。因此最大限度的减少不必要的异常捕捉和移动，那里没有什么固定的原因。不要仅仅是抛出和捕捉异常，如果你能使用boolean变量去表示执行结果，可能会得到更整洁，更高性能的解决方案。修正错误的根源，避免不必须要的异常捕捉。</p>\n<h4 id=\"8-避免catch块为空\"><a href=\"#8-避免catch块为空\" class=\"headerlink\" title=\"8) 避免catch块为空\"></a>8) 避免catch块为空</h4><p>没有什么比空的catch块更糟糕的了，因为它不仅隐藏了错误和异常，同时可能导致你的对象处于不可使用或者脏的状态。空的catch块只能变得无意义，如果你非常肯定异常不会继续以任何方式影响对象状态，但在程序执行期间，用日志记录错误依然是最好的(方法)。对于在Java编程中编写异常处理代码，这不仅仅是一个Java最佳实践，而是一个最通用的实践。</p>\n<h4 id=\"9-使用标准异常\"><a href=\"#9-使用标准异常\" class=\"headerlink\" title=\"9) 使用标准异常\"></a>9) 使用标准异常</h4><p>我们的第九条最佳实践建议使用标准和内置的Java异常。使用标准异常而不是每次创建我们自己的异常，对于维护性和一致性，不管是现在还是以后，都是最好的选择。重用标准异常使代码更具可读性，因为大部分Java开发人员对标准的像源自于JDK的RuntimeException 异常，IllegalStateException 异常，Illegal Argument Exception 异常或者NullPointerException异常，(开发者)他们能一眼就知道每种异常的目的，而不是在代码里查找或者在文档里查找用户定义的异常的目的。</p>\n<h4 id=\"10-记录任何方法抛出的异常\"><a href=\"#10-记录任何方法抛出的异常\" class=\"headerlink\" title=\"10) 记录任何方法抛出的异常\"></a>10) 记录任何方法抛出的异常</h4><p>Java提供了throw和throws关键字来抛出异常，在javadoc中用@throw记录任何方法可能会抛出的异常。如果你编写API或者公共接口，这就变得非常重要。任何方法抛出的异常都有相应的文档记录，这样你就能下意识的提醒任何使用(该方法)的人。</p>\n<p>这些就是所有在Java编程中在处理异常的时候需要遵循的最佳实践。让我们知道了什么是在Java编程中编写异常处理代码时需要遵循的实践。</p>\n<p>原文：<a href=\"https://www.oschina.net/translate/10-exception-handling-best-practices-in-java-programming\">https://www.oschina.net/translate/10-exception-handling-best-practices-in-java-programming</a></p>\n"},{"title":"Java 类初始化顺序，3个示例带你躺坑。","date":"2025-10-15T03:36:33.000Z","_content":"\n最近发现微信群里面有些群友在讨论类的初始化顺序，如类的静态变量、成员变量、静态代码块、非静态代码块、构造器，及继承父类时，它们的初始化顺序都是怎样的，下面我通过例子来说明这个情况，以免被人误导。\n\n#### 示例1：测试单类的初始化顺序\n\n```\npublic class ClassInitOrderTest {\n\n\tpublic static String staticField = \"static field\";\n\n\tstatic {\n\t\tSystem.out.println(staticField);\n\t\tSystem.out.println(\"static block\");\n\t}\n\n\tprivate String field = \"member field\";\n\n\t{\n\t\tSystem.out.println(field);\n\t\tSystem.out.println(\"non-static block\");\n\t}\n\n\tpublic ClassInitOrderTest() {\n\t\tSystem.out.println(\"constructor\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew ClassInitOrderTest();\n\t}\n\n}\n```\n\n程序输出：\n\n\n```\nstatic field\nstatic block\nmember field\nnon-static block\nconstructor\n```\n\n可以得出以下结论，单类的初始化顺序为：\n\n> **静态变量 > 静态初始块 > 成员变量 > 非静态初始块 > 构造器**\n\n\n#### 示例2：测试类继承的初始化顺序\n\n```\nclass Parent {\n\n\tprivate static String parentStaticField = \"parent static field\";\n\n\tstatic {\n\t\tSystem.out.println(parentStaticField);\n\t\tSystem.out.println(\"parent static block\");\n\t}\n\n\tprivate String parentField = \"parent member field\";\n\n\t{\n\t\tSystem.out.println(parentField);\n\t\tSystem.out.println(\"parent non-static block\");\n\t}\n\n\tpublic Parent() {\n\t\tSystem.out.println(\"parent constructor\");\n\t}\n\n}\n\npublic class Child extends Parent {\n\n\tprivate static String childStaticField = \"child static field\";\n\n\tstatic {\n\t\tSystem.out.println(childStaticField);\n\t\tSystem.out.println(\"child static block\");\n\t}\n\n\tprivate String childField = \"child member field\";\n\n\t{\n\t\tSystem.out.println(childField);\n\t\tSystem.out.println(\"child non-static block\");\n\t}\n\n\tpublic Child() {\n\t\tSystem.out.println(\"child constructor\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Child();\n\t}\n\n}\n```\n\n程序输出：\n\n\n```\nparent static field\nparent static block\nchild static field\nchild static block\nparent member field\nparent non-static block\nparent constructor\nchild member field\nchild non-static block\nchild constructor\n```\n\n可以得出以下结论，单类的初始化顺序为：\n\n> **父类静态变量 > 父类静态初始块 > 子类静态变量 > 子类静态初始块 > 父类成员变量 > 父类非静态初始块 > 父类构造器 > 子类成员变量 > 子类非静态初始块 > 子类构造器**\n\n\n#### 示例3：测试成员变量、初始块的初始化顺序\n\n从上面两个例子可以看出，父类的静态变量和静态初始块肯定是先于子类加载的。但同一个类中的静态变量与静态初始块之间，成员变量与初始块之间的顺序一定是变量先于初始块吗？继续演示！\n\n```\npublic class TestOrder {\n\n\tprivate static A a = new A();\n\n\tstatic {\n\t\tSystem.out.println(\"static block\");\n\t}\n\n\tprivate static B b = new B();\n\n\tpublic static void main(String[] args) {\n\t\tnew TestOrder();\n\t}\n\n}\n\nclass A {\n\tpublic A() {\n\t\tSystem.out.println(\"static field A\");\n\t}\n}\n\nclass B {\n\tpublic B() {\n\t\tSystem.out.println(\"static field B\");\n\t}\n}\n```\n\n程序输出：\n\n\n```\nstatic field A\nstatic block\nstatic field B\n```\n\n可以得出以下结论，单类的初始化顺序为：\n\n> **静态变量A > 静态初始块 > 静态变量B**\n\n所以，它们的在类中的顺序就决定了它们的初始化顺序，而不是变量一定会优先于初始块。\n\n\n","source":"_posts/进阶/Java 类初始化顺序，3个示例带你躺坑。.md","raw":"---\ntitle: Java 类初始化顺序，3个示例带你躺坑。\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 进阶\n---\n\n最近发现微信群里面有些群友在讨论类的初始化顺序，如类的静态变量、成员变量、静态代码块、非静态代码块、构造器，及继承父类时，它们的初始化顺序都是怎样的，下面我通过例子来说明这个情况，以免被人误导。\n\n#### 示例1：测试单类的初始化顺序\n\n```\npublic class ClassInitOrderTest {\n\n\tpublic static String staticField = \"static field\";\n\n\tstatic {\n\t\tSystem.out.println(staticField);\n\t\tSystem.out.println(\"static block\");\n\t}\n\n\tprivate String field = \"member field\";\n\n\t{\n\t\tSystem.out.println(field);\n\t\tSystem.out.println(\"non-static block\");\n\t}\n\n\tpublic ClassInitOrderTest() {\n\t\tSystem.out.println(\"constructor\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew ClassInitOrderTest();\n\t}\n\n}\n```\n\n程序输出：\n\n\n```\nstatic field\nstatic block\nmember field\nnon-static block\nconstructor\n```\n\n可以得出以下结论，单类的初始化顺序为：\n\n> **静态变量 > 静态初始块 > 成员变量 > 非静态初始块 > 构造器**\n\n\n#### 示例2：测试类继承的初始化顺序\n\n```\nclass Parent {\n\n\tprivate static String parentStaticField = \"parent static field\";\n\n\tstatic {\n\t\tSystem.out.println(parentStaticField);\n\t\tSystem.out.println(\"parent static block\");\n\t}\n\n\tprivate String parentField = \"parent member field\";\n\n\t{\n\t\tSystem.out.println(parentField);\n\t\tSystem.out.println(\"parent non-static block\");\n\t}\n\n\tpublic Parent() {\n\t\tSystem.out.println(\"parent constructor\");\n\t}\n\n}\n\npublic class Child extends Parent {\n\n\tprivate static String childStaticField = \"child static field\";\n\n\tstatic {\n\t\tSystem.out.println(childStaticField);\n\t\tSystem.out.println(\"child static block\");\n\t}\n\n\tprivate String childField = \"child member field\";\n\n\t{\n\t\tSystem.out.println(childField);\n\t\tSystem.out.println(\"child non-static block\");\n\t}\n\n\tpublic Child() {\n\t\tSystem.out.println(\"child constructor\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Child();\n\t}\n\n}\n```\n\n程序输出：\n\n\n```\nparent static field\nparent static block\nchild static field\nchild static block\nparent member field\nparent non-static block\nparent constructor\nchild member field\nchild non-static block\nchild constructor\n```\n\n可以得出以下结论，单类的初始化顺序为：\n\n> **父类静态变量 > 父类静态初始块 > 子类静态变量 > 子类静态初始块 > 父类成员变量 > 父类非静态初始块 > 父类构造器 > 子类成员变量 > 子类非静态初始块 > 子类构造器**\n\n\n#### 示例3：测试成员变量、初始块的初始化顺序\n\n从上面两个例子可以看出，父类的静态变量和静态初始块肯定是先于子类加载的。但同一个类中的静态变量与静态初始块之间，成员变量与初始块之间的顺序一定是变量先于初始块吗？继续演示！\n\n```\npublic class TestOrder {\n\n\tprivate static A a = new A();\n\n\tstatic {\n\t\tSystem.out.println(\"static block\");\n\t}\n\n\tprivate static B b = new B();\n\n\tpublic static void main(String[] args) {\n\t\tnew TestOrder();\n\t}\n\n}\n\nclass A {\n\tpublic A() {\n\t\tSystem.out.println(\"static field A\");\n\t}\n}\n\nclass B {\n\tpublic B() {\n\t\tSystem.out.println(\"static field B\");\n\t}\n}\n```\n\n程序输出：\n\n\n```\nstatic field A\nstatic block\nstatic field B\n```\n\n可以得出以下结论，单类的初始化顺序为：\n\n> **静态变量A > 静态初始块 > 静态变量B**\n\n所以，它们的在类中的顺序就决定了它们的初始化顺序，而不是变量一定会优先于初始块。\n\n\n","slug":"进阶/Java 类初始化顺序，3个示例带你躺坑。","published":1,"updated":"2025-10-15T07:21:14.219Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076g000rqkd4fvzra77j","content":"<p>最近发现微信群里面有些群友在讨论类的初始化顺序，如类的静态变量、成员变量、静态代码块、非静态代码块、构造器，及继承父类时，它们的初始化顺序都是怎样的，下面我通过例子来说明这个情况，以免被人误导。</p>\n<h4 id=\"示例1：测试单类的初始化顺序\"><a href=\"#示例1：测试单类的初始化顺序\" class=\"headerlink\" title=\"示例1：测试单类的初始化顺序\"></a>示例1：测试单类的初始化顺序</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">public class ClassInitOrderTest &#123;\n\n\tpublic static String staticField &#x3D; &quot;static field&quot;;\n\n\tstatic &#123;\n\t\tSystem.out.println(staticField);\n\t\tSystem.out.println(&quot;static block&quot;);\n\t&#125;\n\n\tprivate String field &#x3D; &quot;member field&quot;;\n\n\t&#123;\n\t\tSystem.out.println(field);\n\t\tSystem.out.println(&quot;non-static block&quot;);\n\t&#125;\n\n\tpublic ClassInitOrderTest() &#123;\n\t\tSystem.out.println(&quot;constructor&quot;);\n\t&#125;\n\n\tpublic static void main(String[] args) &#123;\n\t\tnew ClassInitOrderTest();\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">static field\nstatic block\nmember field\nnon-static block\nconstructor<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以得出以下结论，单类的初始化顺序为：</p>\n<blockquote>\n<p><strong>静态变量 &gt; 静态初始块 &gt; 成员变量 &gt; 非静态初始块 &gt; 构造器</strong></p>\n</blockquote>\n<h4 id=\"示例2：测试类继承的初始化顺序\"><a href=\"#示例2：测试类继承的初始化顺序\" class=\"headerlink\" title=\"示例2：测试类继承的初始化顺序\"></a>示例2：测试类继承的初始化顺序</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">class Parent &#123;\n\n\tprivate static String parentStaticField &#x3D; &quot;parent static field&quot;;\n\n\tstatic &#123;\n\t\tSystem.out.println(parentStaticField);\n\t\tSystem.out.println(&quot;parent static block&quot;);\n\t&#125;\n\n\tprivate String parentField &#x3D; &quot;parent member field&quot;;\n\n\t&#123;\n\t\tSystem.out.println(parentField);\n\t\tSystem.out.println(&quot;parent non-static block&quot;);\n\t&#125;\n\n\tpublic Parent() &#123;\n\t\tSystem.out.println(&quot;parent constructor&quot;);\n\t&#125;\n\n&#125;\n\npublic class Child extends Parent &#123;\n\n\tprivate static String childStaticField &#x3D; &quot;child static field&quot;;\n\n\tstatic &#123;\n\t\tSystem.out.println(childStaticField);\n\t\tSystem.out.println(&quot;child static block&quot;);\n\t&#125;\n\n\tprivate String childField &#x3D; &quot;child member field&quot;;\n\n\t&#123;\n\t\tSystem.out.println(childField);\n\t\tSystem.out.println(&quot;child non-static block&quot;);\n\t&#125;\n\n\tpublic Child() &#123;\n\t\tSystem.out.println(&quot;child constructor&quot;);\n\t&#125;\n\n\tpublic static void main(String[] args) &#123;\n\t\tnew Child();\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">parent static field\nparent static block\nchild static field\nchild static block\nparent member field\nparent non-static block\nparent constructor\nchild member field\nchild non-static block\nchild constructor<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以得出以下结论，单类的初始化顺序为：</p>\n<blockquote>\n<p><strong>父类静态变量 &gt; 父类静态初始块 &gt; 子类静态变量 &gt; 子类静态初始块 &gt; 父类成员变量 &gt; 父类非静态初始块 &gt; 父类构造器 &gt; 子类成员变量 &gt; 子类非静态初始块 &gt; 子类构造器</strong></p>\n</blockquote>\n<h4 id=\"示例3：测试成员变量、初始块的初始化顺序\"><a href=\"#示例3：测试成员变量、初始块的初始化顺序\" class=\"headerlink\" title=\"示例3：测试成员变量、初始块的初始化顺序\"></a>示例3：测试成员变量、初始块的初始化顺序</h4><p>从上面两个例子可以看出，父类的静态变量和静态初始块肯定是先于子类加载的。但同一个类中的静态变量与静态初始块之间，成员变量与初始块之间的顺序一定是变量先于初始块吗？继续演示！</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class TestOrder &#123;\n\n\tprivate static A a &#x3D; new A();\n\n\tstatic &#123;\n\t\tSystem.out.println(&quot;static block&quot;);\n\t&#125;\n\n\tprivate static B b &#x3D; new B();\n\n\tpublic static void main(String[] args) &#123;\n\t\tnew TestOrder();\n\t&#125;\n\n&#125;\n\nclass A &#123;\n\tpublic A() &#123;\n\t\tSystem.out.println(&quot;static field A&quot;);\n\t&#125;\n&#125;\n\nclass B &#123;\n\tpublic B() &#123;\n\t\tSystem.out.println(&quot;static field B&quot;);\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">static field A\nstatic block\nstatic field B<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>可以得出以下结论，单类的初始化顺序为：</p>\n<blockquote>\n<p><strong>静态变量A &gt; 静态初始块 &gt; 静态变量B</strong></p>\n</blockquote>\n<p>所以，它们的在类中的顺序就决定了它们的初始化顺序，而不是变量一定会优先于初始块。</p>\n","excerpt":"","more":"<p>最近发现微信群里面有些群友在讨论类的初始化顺序，如类的静态变量、成员变量、静态代码块、非静态代码块、构造器，及继承父类时，它们的初始化顺序都是怎样的，下面我通过例子来说明这个情况，以免被人误导。</p>\n<h4 id=\"示例1：测试单类的初始化顺序\"><a href=\"#示例1：测试单类的初始化顺序\" class=\"headerlink\" title=\"示例1：测试单类的初始化顺序\"></a>示例1：测试单类的初始化顺序</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">public class ClassInitOrderTest &#123;\n\n\tpublic static String staticField &#x3D; &quot;static field&quot;;\n\n\tstatic &#123;\n\t\tSystem.out.println(staticField);\n\t\tSystem.out.println(&quot;static block&quot;);\n\t&#125;\n\n\tprivate String field &#x3D; &quot;member field&quot;;\n\n\t&#123;\n\t\tSystem.out.println(field);\n\t\tSystem.out.println(&quot;non-static block&quot;);\n\t&#125;\n\n\tpublic ClassInitOrderTest() &#123;\n\t\tSystem.out.println(&quot;constructor&quot;);\n\t&#125;\n\n\tpublic static void main(String[] args) &#123;\n\t\tnew ClassInitOrderTest();\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">static field\nstatic block\nmember field\nnon-static block\nconstructor<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以得出以下结论，单类的初始化顺序为：</p>\n<blockquote>\n<p><strong>静态变量 &gt; 静态初始块 &gt; 成员变量 &gt; 非静态初始块 &gt; 构造器</strong></p>\n</blockquote>\n<h4 id=\"示例2：测试类继承的初始化顺序\"><a href=\"#示例2：测试类继承的初始化顺序\" class=\"headerlink\" title=\"示例2：测试类继承的初始化顺序\"></a>示例2：测试类继承的初始化顺序</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">class Parent &#123;\n\n\tprivate static String parentStaticField &#x3D; &quot;parent static field&quot;;\n\n\tstatic &#123;\n\t\tSystem.out.println(parentStaticField);\n\t\tSystem.out.println(&quot;parent static block&quot;);\n\t&#125;\n\n\tprivate String parentField &#x3D; &quot;parent member field&quot;;\n\n\t&#123;\n\t\tSystem.out.println(parentField);\n\t\tSystem.out.println(&quot;parent non-static block&quot;);\n\t&#125;\n\n\tpublic Parent() &#123;\n\t\tSystem.out.println(&quot;parent constructor&quot;);\n\t&#125;\n\n&#125;\n\npublic class Child extends Parent &#123;\n\n\tprivate static String childStaticField &#x3D; &quot;child static field&quot;;\n\n\tstatic &#123;\n\t\tSystem.out.println(childStaticField);\n\t\tSystem.out.println(&quot;child static block&quot;);\n\t&#125;\n\n\tprivate String childField &#x3D; &quot;child member field&quot;;\n\n\t&#123;\n\t\tSystem.out.println(childField);\n\t\tSystem.out.println(&quot;child non-static block&quot;);\n\t&#125;\n\n\tpublic Child() &#123;\n\t\tSystem.out.println(&quot;child constructor&quot;);\n\t&#125;\n\n\tpublic static void main(String[] args) &#123;\n\t\tnew Child();\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">parent static field\nparent static block\nchild static field\nchild static block\nparent member field\nparent non-static block\nparent constructor\nchild member field\nchild non-static block\nchild constructor<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以得出以下结论，单类的初始化顺序为：</p>\n<blockquote>\n<p><strong>父类静态变量 &gt; 父类静态初始块 &gt; 子类静态变量 &gt; 子类静态初始块 &gt; 父类成员变量 &gt; 父类非静态初始块 &gt; 父类构造器 &gt; 子类成员变量 &gt; 子类非静态初始块 &gt; 子类构造器</strong></p>\n</blockquote>\n<h4 id=\"示例3：测试成员变量、初始块的初始化顺序\"><a href=\"#示例3：测试成员变量、初始块的初始化顺序\" class=\"headerlink\" title=\"示例3：测试成员变量、初始块的初始化顺序\"></a>示例3：测试成员变量、初始块的初始化顺序</h4><p>从上面两个例子可以看出，父类的静态变量和静态初始块肯定是先于子类加载的。但同一个类中的静态变量与静态初始块之间，成员变量与初始块之间的顺序一定是变量先于初始块吗？继续演示！</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class TestOrder &#123;\n\n\tprivate static A a &#x3D; new A();\n\n\tstatic &#123;\n\t\tSystem.out.println(&quot;static block&quot;);\n\t&#125;\n\n\tprivate static B b &#x3D; new B();\n\n\tpublic static void main(String[] args) &#123;\n\t\tnew TestOrder();\n\t&#125;\n\n&#125;\n\nclass A &#123;\n\tpublic A() &#123;\n\t\tSystem.out.println(&quot;static field A&quot;);\n\t&#125;\n&#125;\n\nclass B &#123;\n\tpublic B() &#123;\n\t\tSystem.out.println(&quot;static field B&quot;);\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">static field A\nstatic block\nstatic field B<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>可以得出以下结论，单类的初始化顺序为：</p>\n<blockquote>\n<p><strong>静态变量A &gt; 静态初始块 &gt; 静态变量B</strong></p>\n</blockquote>\n<p>所以，它们的在类中的顺序就决定了它们的初始化顺序，而不是变量一定会优先于初始块。</p>\n"},{"title":"Java 自定义 ClassLoader 实战","date":"2025-10-15T03:36:33.000Z","_content":"\n假如我们的类不在classpath下，而我们又想读取一个自定义的目录下的class，如果做呢？\n\n## 读取自定义目录的类\n\n示例读取c:/test/com/test.jdk/Key.class这个类。\n\n```\npackage com.test.jdk;\n\npublic class Key {\n    private String key = \"111111\";\n}\n```\n\n## 自定义ClassLoader\n\n```\nimport org.apache.commons.io.IOUtils;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class LocalClassLoader extends ClassLoader {\n\n    private String path = \"c:/test/\";\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        Class<?> cls = findLoadedClass(name);\n        if (cls != null) {\n            return cls;\n        }\n\n        if (!name.endsWith(\".Key\")) {\n            return super.loadClass(name);\n        }\n\n        try {\n            InputStream is = new FileInputStream(path + name.replace(\".\", \"/\") + \".class\");\n            byte[] bytes = IOUtils.toByteArray(is);\n            return defineClass(name, bytes, 0, bytes.length);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        return super.loadClass(name);\n    }\n}\n```\n\n## 开始读取类\n\n```\npublic static void main(String[] args) {\n    try {\n        LocalClassLoader lcl = new LocalClassLoader();\n        Class<?> cls = lcl.loadClass(\"com.test.jdk.Key\");\n        Field field = FieldUtils.getField(cls, \"key\", true);\n        Object value = field.get(cls.newInstance());\n        System.out.println(value);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```\n自定义类加载器正常加载到类，程序最后输出：111111\n\n## URLClassLoader\n\n上面自定义一个类加载器来读取自定义的目录，其实可以直接使用URLClassLoader就能读取，它已经实现了路径下类的读取逻辑。\n\n```\npublic static void main(String[] args) {\n    try {\n        URLClassLoader ucl = new URLClassLoader(new URL[]{new URL(\"c:/test/\")});\n        Class<?> cls = ucl.loadClass(\"com.test.jdk.Key\");\n        Field field = FieldUtils.getField(cls, \"key\", true);\n        Object value = field.get(cls.newInstance());\n        System.out.println(value);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```\n\n","source":"_posts/进阶/Java 自定义 ClassLoader 实战.md","raw":"---\ntitle: Java 自定义 ClassLoader 实战\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 进阶\n---\n\n假如我们的类不在classpath下，而我们又想读取一个自定义的目录下的class，如果做呢？\n\n## 读取自定义目录的类\n\n示例读取c:/test/com/test.jdk/Key.class这个类。\n\n```\npackage com.test.jdk;\n\npublic class Key {\n    private String key = \"111111\";\n}\n```\n\n## 自定义ClassLoader\n\n```\nimport org.apache.commons.io.IOUtils;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class LocalClassLoader extends ClassLoader {\n\n    private String path = \"c:/test/\";\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        Class<?> cls = findLoadedClass(name);\n        if (cls != null) {\n            return cls;\n        }\n\n        if (!name.endsWith(\".Key\")) {\n            return super.loadClass(name);\n        }\n\n        try {\n            InputStream is = new FileInputStream(path + name.replace(\".\", \"/\") + \".class\");\n            byte[] bytes = IOUtils.toByteArray(is);\n            return defineClass(name, bytes, 0, bytes.length);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        return super.loadClass(name);\n    }\n}\n```\n\n## 开始读取类\n\n```\npublic static void main(String[] args) {\n    try {\n        LocalClassLoader lcl = new LocalClassLoader();\n        Class<?> cls = lcl.loadClass(\"com.test.jdk.Key\");\n        Field field = FieldUtils.getField(cls, \"key\", true);\n        Object value = field.get(cls.newInstance());\n        System.out.println(value);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```\n自定义类加载器正常加载到类，程序最后输出：111111\n\n## URLClassLoader\n\n上面自定义一个类加载器来读取自定义的目录，其实可以直接使用URLClassLoader就能读取，它已经实现了路径下类的读取逻辑。\n\n```\npublic static void main(String[] args) {\n    try {\n        URLClassLoader ucl = new URLClassLoader(new URL[]{new URL(\"c:/test/\")});\n        Class<?> cls = ucl.loadClass(\"com.test.jdk.Key\");\n        Field field = FieldUtils.getField(cls, \"key\", true);\n        Object value = field.get(cls.newInstance());\n        System.out.println(value);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```\n\n","slug":"进阶/Java 自定义 ClassLoader 实战","published":1,"updated":"2025-10-15T07:21:14.287Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076g000wqkd417w28zfm","content":"<p>假如我们的类不在classpath下，而我们又想读取一个自定义的目录下的class，如果做呢？</p>\n<h2 id=\"读取自定义目录的类\"><a href=\"#读取自定义目录的类\" class=\"headerlink\" title=\"读取自定义目录的类\"></a>读取自定义目录的类</h2><p>示例读取c:&#x2F;test&#x2F;com&#x2F;test.jdk&#x2F;Key.class这个类。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package com.test.jdk;\n\npublic class Key &#123;\n    private String key &#x3D; &quot;111111&quot;;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"自定义ClassLoader\"><a href=\"#自定义ClassLoader\" class=\"headerlink\" title=\"自定义ClassLoader\"></a>自定义ClassLoader</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">import org.apache.commons.io.IOUtils;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class LocalClassLoader extends ClassLoader &#123;\n\n    private String path &#x3D; &quot;c:&#x2F;test&#x2F;&quot;;\n\n    @Override\n    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;\n        Class&lt;?&gt; cls &#x3D; findLoadedClass(name);\n        if (cls !&#x3D; null) &#123;\n            return cls;\n        &#125;\n\n        if (!name.endsWith(&quot;.Key&quot;)) &#123;\n            return super.loadClass(name);\n        &#125;\n\n        try &#123;\n            InputStream is &#x3D; new FileInputStream(path + name.replace(&quot;.&quot;, &quot;&#x2F;&quot;) + &quot;.class&quot;);\n            byte[] bytes &#x3D; IOUtils.toByteArray(is);\n            return defineClass(name, bytes, 0, bytes.length);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        return super.loadClass(name);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"开始读取类\"><a href=\"#开始读取类\" class=\"headerlink\" title=\"开始读取类\"></a>开始读取类</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    try &#123;\n        LocalClassLoader lcl &#x3D; new LocalClassLoader();\n        Class&lt;?&gt; cls &#x3D; lcl.loadClass(&quot;com.test.jdk.Key&quot;);\n        Field field &#x3D; FieldUtils.getField(cls, &quot;key&quot;, true);\n        Object value &#x3D; field.get(cls.newInstance());\n        System.out.println(value);\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>自定义类加载器正常加载到类，程序最后输出：111111</p>\n<h2 id=\"URLClassLoader\"><a href=\"#URLClassLoader\" class=\"headerlink\" title=\"URLClassLoader\"></a>URLClassLoader</h2><p>上面自定义一个类加载器来读取自定义的目录，其实可以直接使用URLClassLoader就能读取，它已经实现了路径下类的读取逻辑。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    try &#123;\n        URLClassLoader ucl &#x3D; new URLClassLoader(new URL[]&#123;new URL(&quot;c:&#x2F;test&#x2F;&quot;)&#125;);\n        Class&lt;?&gt; cls &#x3D; ucl.loadClass(&quot;com.test.jdk.Key&quot;);\n        Field field &#x3D; FieldUtils.getField(cls, &quot;key&quot;, true);\n        Object value &#x3D; field.get(cls.newInstance());\n        System.out.println(value);\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","excerpt":"","more":"<p>假如我们的类不在classpath下，而我们又想读取一个自定义的目录下的class，如果做呢？</p>\n<h2 id=\"读取自定义目录的类\"><a href=\"#读取自定义目录的类\" class=\"headerlink\" title=\"读取自定义目录的类\"></a>读取自定义目录的类</h2><p>示例读取c:&#x2F;test&#x2F;com&#x2F;test.jdk&#x2F;Key.class这个类。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package com.test.jdk;\n\npublic class Key &#123;\n    private String key &#x3D; &quot;111111&quot;;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"自定义ClassLoader\"><a href=\"#自定义ClassLoader\" class=\"headerlink\" title=\"自定义ClassLoader\"></a>自定义ClassLoader</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">import org.apache.commons.io.IOUtils;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class LocalClassLoader extends ClassLoader &#123;\n\n    private String path &#x3D; &quot;c:&#x2F;test&#x2F;&quot;;\n\n    @Override\n    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;\n        Class&lt;?&gt; cls &#x3D; findLoadedClass(name);\n        if (cls !&#x3D; null) &#123;\n            return cls;\n        &#125;\n\n        if (!name.endsWith(&quot;.Key&quot;)) &#123;\n            return super.loadClass(name);\n        &#125;\n\n        try &#123;\n            InputStream is &#x3D; new FileInputStream(path + name.replace(&quot;.&quot;, &quot;&#x2F;&quot;) + &quot;.class&quot;);\n            byte[] bytes &#x3D; IOUtils.toByteArray(is);\n            return defineClass(name, bytes, 0, bytes.length);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        return super.loadClass(name);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"开始读取类\"><a href=\"#开始读取类\" class=\"headerlink\" title=\"开始读取类\"></a>开始读取类</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    try &#123;\n        LocalClassLoader lcl &#x3D; new LocalClassLoader();\n        Class&lt;?&gt; cls &#x3D; lcl.loadClass(&quot;com.test.jdk.Key&quot;);\n        Field field &#x3D; FieldUtils.getField(cls, &quot;key&quot;, true);\n        Object value &#x3D; field.get(cls.newInstance());\n        System.out.println(value);\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>自定义类加载器正常加载到类，程序最后输出：111111</p>\n<h2 id=\"URLClassLoader\"><a href=\"#URLClassLoader\" class=\"headerlink\" title=\"URLClassLoader\"></a>URLClassLoader</h2><p>上面自定义一个类加载器来读取自定义的目录，其实可以直接使用URLClassLoader就能读取，它已经实现了路径下类的读取逻辑。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    try &#123;\n        URLClassLoader ucl &#x3D; new URLClassLoader(new URL[]&#123;new URL(&quot;c:&#x2F;test&#x2F;&quot;)&#125;);\n        Class&lt;?&gt; cls &#x3D; ucl.loadClass(&quot;com.test.jdk.Key&quot;);\n        Field field &#x3D; FieldUtils.getField(cls, &quot;key&quot;, true);\n        Object value &#x3D; field.get(cls.newInstance());\n        System.out.println(value);\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n"},{"title":"hashCode 和 identityHashCode 的区别你知道吗？","date":"2025-10-15T03:36:33.000Z","_content":"\n## hashCode\n\n关于hashCode参考之前的文章，[点击](https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247483797&idx=1&sn=e3bb47b13d0c3f25341470a0ce598752&chksm=eb5384a3dc240db5e6378dc5160fa01fd10569ffb5f95f5d5daa4589c3308515139b29e2b314#rd)参考之前文章。\n\n## identityHashCode\n\nidentityHashCode是System里面提供的本地方法，java.lang.System#identityHashCode。\n\n```\n/**\n * Returns the same hash code for the given object as\n * would be returned by the default method hashCode(),\n * whether or not the given object's class overrides\n * hashCode().\n * The hash code for the null reference is zero.\n *\n * @param x object for which the hashCode is to be calculated\n * @return  the hashCode\n * @since   JDK1.1\n */\npublic static native int identityHashCode(Object x);\n```\n\nidentityHashCode和hashCode的区别是，identityHashCode会返回对象的hashCode，而不管对象是否重写了hashCode方法。\n\n## 示例\n\n\n```\npublic static void main(String[] args) {\n\tString str1 = new String(\"abc\");\n\tString str2 = new String(\"abc\");\n\tSystem.out.println(\"str1 hashCode: \" + str1.hashCode());\n\tSystem.out.println(\"str2 hashCode: \" + str2.hashCode());\n\tSystem.out.println(\"str1 identityHashCode: \" + System.identityHashCode(str1));\n\tSystem.out.println(\"str2 identityHashCode: \" + System.identityHashCode(str2));\n\n\tUser user = new User(\"test\", 1);\n\tSystem.out.println(\"user hashCode: \" + user.hashCode());\n\tSystem.out.println(\"user identityHashCode: \" + System.identityHashCode(user));\n}\n```\n\n输出结果：\n\n```\nstr1 hashCode: 96354\nstr2 hashCode: 96354\nstr1 identityHashCode: 1173230247\nstr2 identityHashCode: 856419764\nuser hashCode: 621009875\nuser identityHashCode: 621009875\n```\n\n结果分析：\n\n1、str1和str2的hashCode是相同的，是因为String类重写了hashCode方法，它根据String的值来确定hashCode的值，所以只要值一样，hashCode就会一样。\n\n2、str1和str2的identityHashCode不一样，虽然String重写了hashCode方法，identityHashCode永远返回根据对象物理内存地址产生的hash值，所以每个String对象的物理地址不一样，identityHashCode也会不一样。\n\n3、User对象没重写hashCode方法，所以hashCode和identityHashCode返回的值一样。\n\n## 结论\n\nhashCode方法可以被重写并返回重写后的值，identityHashCode会返回对象的hash值而不管对象是否重写了hashCode方法。\n\n","source":"_posts/进阶/hashCode 和 identityHashCode 的区别你知道吗？.md","raw":"---\ntitle: hashCode 和 identityHashCode 的区别你知道吗？\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 进阶\n---\n\n## hashCode\n\n关于hashCode参考之前的文章，[点击](https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247483797&idx=1&sn=e3bb47b13d0c3f25341470a0ce598752&chksm=eb5384a3dc240db5e6378dc5160fa01fd10569ffb5f95f5d5daa4589c3308515139b29e2b314#rd)参考之前文章。\n\n## identityHashCode\n\nidentityHashCode是System里面提供的本地方法，java.lang.System#identityHashCode。\n\n```\n/**\n * Returns the same hash code for the given object as\n * would be returned by the default method hashCode(),\n * whether or not the given object's class overrides\n * hashCode().\n * The hash code for the null reference is zero.\n *\n * @param x object for which the hashCode is to be calculated\n * @return  the hashCode\n * @since   JDK1.1\n */\npublic static native int identityHashCode(Object x);\n```\n\nidentityHashCode和hashCode的区别是，identityHashCode会返回对象的hashCode，而不管对象是否重写了hashCode方法。\n\n## 示例\n\n\n```\npublic static void main(String[] args) {\n\tString str1 = new String(\"abc\");\n\tString str2 = new String(\"abc\");\n\tSystem.out.println(\"str1 hashCode: \" + str1.hashCode());\n\tSystem.out.println(\"str2 hashCode: \" + str2.hashCode());\n\tSystem.out.println(\"str1 identityHashCode: \" + System.identityHashCode(str1));\n\tSystem.out.println(\"str2 identityHashCode: \" + System.identityHashCode(str2));\n\n\tUser user = new User(\"test\", 1);\n\tSystem.out.println(\"user hashCode: \" + user.hashCode());\n\tSystem.out.println(\"user identityHashCode: \" + System.identityHashCode(user));\n}\n```\n\n输出结果：\n\n```\nstr1 hashCode: 96354\nstr2 hashCode: 96354\nstr1 identityHashCode: 1173230247\nstr2 identityHashCode: 856419764\nuser hashCode: 621009875\nuser identityHashCode: 621009875\n```\n\n结果分析：\n\n1、str1和str2的hashCode是相同的，是因为String类重写了hashCode方法，它根据String的值来确定hashCode的值，所以只要值一样，hashCode就会一样。\n\n2、str1和str2的identityHashCode不一样，虽然String重写了hashCode方法，identityHashCode永远返回根据对象物理内存地址产生的hash值，所以每个String对象的物理地址不一样，identityHashCode也会不一样。\n\n3、User对象没重写hashCode方法，所以hashCode和identityHashCode返回的值一样。\n\n## 结论\n\nhashCode方法可以被重写并返回重写后的值，identityHashCode会返回对象的hash值而不管对象是否重写了hashCode方法。\n\n","slug":"进阶/hashCode 和 identityHashCode 的区别你知道吗？","published":1,"updated":"2025-10-15T07:21:14.277Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076h000zqkd4b9042yxp","content":"<h2 id=\"hashCode\"><a href=\"#hashCode\" class=\"headerlink\" title=\"hashCode\"></a>hashCode</h2><p>关于hashCode参考之前的文章，<a href=\"https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247483797&idx=1&sn=e3bb47b13d0c3f25341470a0ce598752&chksm=eb5384a3dc240db5e6378dc5160fa01fd10569ffb5f95f5d5daa4589c3308515139b29e2b314#rd\">点击</a>参考之前文章。</p>\n<h2 id=\"identityHashCode\"><a href=\"#identityHashCode\" class=\"headerlink\" title=\"identityHashCode\"></a>identityHashCode</h2><p>identityHashCode是System里面提供的本地方法，java.lang.System#identityHashCode。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * Returns the same hash code for the given object as\n * would be returned by the default method hashCode(),\n * whether or not the given object&#39;s class overrides\n * hashCode().\n * The hash code for the null reference is zero.\n *\n * @param x object for which the hashCode is to be calculated\n * @return  the hashCode\n * @since   JDK1.1\n *&#x2F;\npublic static native int identityHashCode(Object x);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>identityHashCode和hashCode的区别是，identityHashCode会返回对象的hashCode，而不管对象是否重写了hashCode方法。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n\tString str1 &#x3D; new String(&quot;abc&quot;);\n\tString str2 &#x3D; new String(&quot;abc&quot;);\n\tSystem.out.println(&quot;str1 hashCode: &quot; + str1.hashCode());\n\tSystem.out.println(&quot;str2 hashCode: &quot; + str2.hashCode());\n\tSystem.out.println(&quot;str1 identityHashCode: &quot; + System.identityHashCode(str1));\n\tSystem.out.println(&quot;str2 identityHashCode: &quot; + System.identityHashCode(str2));\n\n\tUser user &#x3D; new User(&quot;test&quot;, 1);\n\tSystem.out.println(&quot;user hashCode: &quot; + user.hashCode());\n\tSystem.out.println(&quot;user identityHashCode: &quot; + System.identityHashCode(user));\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">str1 hashCode: 96354\nstr2 hashCode: 96354\nstr1 identityHashCode: 1173230247\nstr2 identityHashCode: 856419764\nuser hashCode: 621009875\nuser identityHashCode: 621009875<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>结果分析：</p>\n<p>1、str1和str2的hashCode是相同的，是因为String类重写了hashCode方法，它根据String的值来确定hashCode的值，所以只要值一样，hashCode就会一样。</p>\n<p>2、str1和str2的identityHashCode不一样，虽然String重写了hashCode方法，identityHashCode永远返回根据对象物理内存地址产生的hash值，所以每个String对象的物理地址不一样，identityHashCode也会不一样。</p>\n<p>3、User对象没重写hashCode方法，所以hashCode和identityHashCode返回的值一样。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>hashCode方法可以被重写并返回重写后的值，identityHashCode会返回对象的hash值而不管对象是否重写了hashCode方法。</p>\n","excerpt":"","more":"<h2 id=\"hashCode\"><a href=\"#hashCode\" class=\"headerlink\" title=\"hashCode\"></a>hashCode</h2><p>关于hashCode参考之前的文章，<a href=\"https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247483797&idx=1&sn=e3bb47b13d0c3f25341470a0ce598752&chksm=eb5384a3dc240db5e6378dc5160fa01fd10569ffb5f95f5d5daa4589c3308515139b29e2b314#rd\">点击</a>参考之前文章。</p>\n<h2 id=\"identityHashCode\"><a href=\"#identityHashCode\" class=\"headerlink\" title=\"identityHashCode\"></a>identityHashCode</h2><p>identityHashCode是System里面提供的本地方法，java.lang.System#identityHashCode。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * Returns the same hash code for the given object as\n * would be returned by the default method hashCode(),\n * whether or not the given object&#39;s class overrides\n * hashCode().\n * The hash code for the null reference is zero.\n *\n * @param x object for which the hashCode is to be calculated\n * @return  the hashCode\n * @since   JDK1.1\n *&#x2F;\npublic static native int identityHashCode(Object x);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>identityHashCode和hashCode的区别是，identityHashCode会返回对象的hashCode，而不管对象是否重写了hashCode方法。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n\tString str1 &#x3D; new String(&quot;abc&quot;);\n\tString str2 &#x3D; new String(&quot;abc&quot;);\n\tSystem.out.println(&quot;str1 hashCode: &quot; + str1.hashCode());\n\tSystem.out.println(&quot;str2 hashCode: &quot; + str2.hashCode());\n\tSystem.out.println(&quot;str1 identityHashCode: &quot; + System.identityHashCode(str1));\n\tSystem.out.println(&quot;str2 identityHashCode: &quot; + System.identityHashCode(str2));\n\n\tUser user &#x3D; new User(&quot;test&quot;, 1);\n\tSystem.out.println(&quot;user hashCode: &quot; + user.hashCode());\n\tSystem.out.println(&quot;user identityHashCode: &quot; + System.identityHashCode(user));\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">str1 hashCode: 96354\nstr2 hashCode: 96354\nstr1 identityHashCode: 1173230247\nstr2 identityHashCode: 856419764\nuser hashCode: 621009875\nuser identityHashCode: 621009875<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>结果分析：</p>\n<p>1、str1和str2的hashCode是相同的，是因为String类重写了hashCode方法，它根据String的值来确定hashCode的值，所以只要值一样，hashCode就会一样。</p>\n<p>2、str1和str2的identityHashCode不一样，虽然String重写了hashCode方法，identityHashCode永远返回根据对象物理内存地址产生的hash值，所以每个String对象的物理地址不一样，identityHashCode也会不一样。</p>\n<p>3、User对象没重写hashCode方法，所以hashCode和identityHashCode返回的值一样。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>hashCode方法可以被重写并返回重写后的值，identityHashCode会返回对象的hash值而不管对象是否重写了hashCode方法。</p>\n"},{"title":"不能用 + 拼接字符串？ 这次我要吊打面试官！","date":"2025-10-15T03:36:33.000Z","_content":"\n我们做 Java 程序员以来，不管是工作当中，还是面试过程中，都知道：字符串拼接不能用 String，要用 `StringBuilder` 或者是 `StringBuffer`，以至于它们都被滥用了。\n\nStringBuilder、StringBuffer 简称：SB，下文统一用 `SB` 代替。\n\n`SB`它们都是可变的字符串，它们之间的区别也是 Java 初中级面试战场上出现几率十分高的一道题，上场率没有 90% 也有 80% 吧。\n\n这两个的具体区别请看这篇文章：[StringBuffer 和 StringBuilder 的 3 个区别](https://mp.weixin.qq.com/s/Eeb9wa0DfUs9U5snahAJZQ)。\n\n我们反过来想下，String真的是不可变的么？不一定，看下这篇：[Java 中的 String 真的是不可变的吗？](https://mp.weixin.qq.com/s/sLsCZ7T-GnkI6ZZXn22o-w)\n\n当然，本文不是讨论字符串可变与不可变的问题，而是讨论：字符串拼接一定要用 `SB` 吗？为什么不能用 `+` ？能不能用 `+` ？什么时候可以用 `+` ？\n\n为什么不能用 + 号拼接字符串？我不服，接下来我要吊打面试官！\n\n#### 什么时候不能用 `+`\n\n通过多个表达式完成一个字符串拼接操作。\n\n```\nprivate void test1() {\n    String www = \"www.\";\n    String str = www;\n    str += \"javastack.\";\n    str += \"com\";\n}\n```\n\n字节码如下：\n\n```\n// access flags 0xA\nprivate static test2()V\nL0\nLINENUMBER 14 L0\nLDC \"www.\"\nASTORE 0\nL1\nLINENUMBER 15 L1\nALOAD 0\nASTORE 1\nL2\nLINENUMBER 16 L2\nNEW java/lang/StringBuilder\nDUP\nINVOKESPECIAL java/lang/StringBuilder.<init> ()V\nALOAD 1\nINVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;\nLDC \"javastack.\"\nINVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;\nINVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;\nASTORE 1\nL3\nLINENUMBER 17 L3\nNEW java/lang/StringBuilder\nDUP\nINVOKESPECIAL java/lang/StringBuilder.<init> ()V\nALOAD 1\nINVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;\nLDC \"com\"\nINVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;\nINVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;\nASTORE 1\nL4\nLINENUMBER 18 L4\nRETURN\nL5\nLOCALVARIABLE www Ljava/lang/String; L1 L5 0\nLOCALVARIABLE str Ljava/lang/String; L2 L5 1\nMAXSTACK = 2\nMAXLOCALS = 2\n```\n\n不会查看字节码的，看这里：[3种骚操作，教你查看 Java 字节码](https://mp.weixin.qq.com/s/bEEQf7bNik-rBPgK0uhjWg)，看这一篇就会了。\n\n观察下，`NEW java/lang/StringBuilder` 出现了两次，是因为我们在代码中拼接了两次，也就是说每一次拼接操作都会创建一次 `StringBuilder`。\n\n如果我们是在一个循环中进行字符串拼接，那是不是一次拼接就要创建一个 `StringBuilder`？\n\nwtf……这哪能接受！频繁创建对象是有性能开销的，这也是为什么我们常说的字符串不能用 `+` 拼接，而要用那两个 `SB`  拼接了。\n\n#### 什么时候可以用 `+`\n\n直接将三个字面量的字符串拼接成一个字符串。\n\n```\nprivate static void test2() {\n    String str = \"www.\" + \"javastack.\" + \"com\";\n}\n```\n\n字节码如下：\n\n```\n// access flags 0x2\nprivate test2()V\nL0\nLINENUMBER 13 L0\nLDC \"www.javastack.com\"\nASTORE 1\nL1\nLINENUMBER 14 L1\nRETURN\nL2\nLOCALVARIABLE this Lcom/test/jdk/TestSB; L0 L2 0\nLOCALVARIABLE str Ljava/lang/String; L1 L2 1\nMAXSTACK = 1\nMAXLOCALS = 2\n```\n\n从字节码看出，没有任何创建 `StringBuilder` 的指令，直接从常量池进行取出一个完整的字符串：www.javastack.com。很明显，这是 Java 编译器对代码进行了优化。\n\n所以，通过这个示例告诉你，在这种情况下是可以用 `+` 号进行字符串拼接的。\n\n这个示例可以演变成我们实际工作当中的某个 SQL 语句拼接的案例，如：\n\n```\nString sql = \"select name, sex, age, address\"\n        + \"from t_user\"\n        + \"where age > 18\";\n```\n\n别说这样不行，这样是行的。\n\n但你要是换成这样就不行了：\n\n```\nString sql = \"select name, sex, age, address\";\nsql += \"from t_user\";\nsql += \"where age > 18\";\n```\n\n这样又回到创建多个 `StringBuilder` 的时候了。\n\n也就是说，在一个表达式中完成字符串拼接是可以用 `+` 号完成的，因为编译器已经做了优化。\n\n#### 小结一下\n\n你只需要记住这两点：\n\n1、在循环和多个表达式中不能 `+`，频繁创建 `SB` 性能影响；\n\n2、在单个表达式中可以用 `+`，编译器直接做了优化；\n\n老铁们，都搞清楚了？\n\n这个观点有没有被误解很久？\n\n下次面试，把这篇内容亮出来，吊打面试官，没问题的。\n\n有收获的朋友一定要点个在看，这样我写原创更带劲了，谢了，老铁们。\n","source":"_posts/进阶/不能用 + 拼接字符串？ 这次我要吊打面试官！.md","raw":"---\ntitle: 不能用 + 拼接字符串？ 这次我要吊打面试官！\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 进阶\n---\n\n我们做 Java 程序员以来，不管是工作当中，还是面试过程中，都知道：字符串拼接不能用 String，要用 `StringBuilder` 或者是 `StringBuffer`，以至于它们都被滥用了。\n\nStringBuilder、StringBuffer 简称：SB，下文统一用 `SB` 代替。\n\n`SB`它们都是可变的字符串，它们之间的区别也是 Java 初中级面试战场上出现几率十分高的一道题，上场率没有 90% 也有 80% 吧。\n\n这两个的具体区别请看这篇文章：[StringBuffer 和 StringBuilder 的 3 个区别](https://mp.weixin.qq.com/s/Eeb9wa0DfUs9U5snahAJZQ)。\n\n我们反过来想下，String真的是不可变的么？不一定，看下这篇：[Java 中的 String 真的是不可变的吗？](https://mp.weixin.qq.com/s/sLsCZ7T-GnkI6ZZXn22o-w)\n\n当然，本文不是讨论字符串可变与不可变的问题，而是讨论：字符串拼接一定要用 `SB` 吗？为什么不能用 `+` ？能不能用 `+` ？什么时候可以用 `+` ？\n\n为什么不能用 + 号拼接字符串？我不服，接下来我要吊打面试官！\n\n#### 什么时候不能用 `+`\n\n通过多个表达式完成一个字符串拼接操作。\n\n```\nprivate void test1() {\n    String www = \"www.\";\n    String str = www;\n    str += \"javastack.\";\n    str += \"com\";\n}\n```\n\n字节码如下：\n\n```\n// access flags 0xA\nprivate static test2()V\nL0\nLINENUMBER 14 L0\nLDC \"www.\"\nASTORE 0\nL1\nLINENUMBER 15 L1\nALOAD 0\nASTORE 1\nL2\nLINENUMBER 16 L2\nNEW java/lang/StringBuilder\nDUP\nINVOKESPECIAL java/lang/StringBuilder.<init> ()V\nALOAD 1\nINVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;\nLDC \"javastack.\"\nINVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;\nINVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;\nASTORE 1\nL3\nLINENUMBER 17 L3\nNEW java/lang/StringBuilder\nDUP\nINVOKESPECIAL java/lang/StringBuilder.<init> ()V\nALOAD 1\nINVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;\nLDC \"com\"\nINVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;\nINVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;\nASTORE 1\nL4\nLINENUMBER 18 L4\nRETURN\nL5\nLOCALVARIABLE www Ljava/lang/String; L1 L5 0\nLOCALVARIABLE str Ljava/lang/String; L2 L5 1\nMAXSTACK = 2\nMAXLOCALS = 2\n```\n\n不会查看字节码的，看这里：[3种骚操作，教你查看 Java 字节码](https://mp.weixin.qq.com/s/bEEQf7bNik-rBPgK0uhjWg)，看这一篇就会了。\n\n观察下，`NEW java/lang/StringBuilder` 出现了两次，是因为我们在代码中拼接了两次，也就是说每一次拼接操作都会创建一次 `StringBuilder`。\n\n如果我们是在一个循环中进行字符串拼接，那是不是一次拼接就要创建一个 `StringBuilder`？\n\nwtf……这哪能接受！频繁创建对象是有性能开销的，这也是为什么我们常说的字符串不能用 `+` 拼接，而要用那两个 `SB`  拼接了。\n\n#### 什么时候可以用 `+`\n\n直接将三个字面量的字符串拼接成一个字符串。\n\n```\nprivate static void test2() {\n    String str = \"www.\" + \"javastack.\" + \"com\";\n}\n```\n\n字节码如下：\n\n```\n// access flags 0x2\nprivate test2()V\nL0\nLINENUMBER 13 L0\nLDC \"www.javastack.com\"\nASTORE 1\nL1\nLINENUMBER 14 L1\nRETURN\nL2\nLOCALVARIABLE this Lcom/test/jdk/TestSB; L0 L2 0\nLOCALVARIABLE str Ljava/lang/String; L1 L2 1\nMAXSTACK = 1\nMAXLOCALS = 2\n```\n\n从字节码看出，没有任何创建 `StringBuilder` 的指令，直接从常量池进行取出一个完整的字符串：www.javastack.com。很明显，这是 Java 编译器对代码进行了优化。\n\n所以，通过这个示例告诉你，在这种情况下是可以用 `+` 号进行字符串拼接的。\n\n这个示例可以演变成我们实际工作当中的某个 SQL 语句拼接的案例，如：\n\n```\nString sql = \"select name, sex, age, address\"\n        + \"from t_user\"\n        + \"where age > 18\";\n```\n\n别说这样不行，这样是行的。\n\n但你要是换成这样就不行了：\n\n```\nString sql = \"select name, sex, age, address\";\nsql += \"from t_user\";\nsql += \"where age > 18\";\n```\n\n这样又回到创建多个 `StringBuilder` 的时候了。\n\n也就是说，在一个表达式中完成字符串拼接是可以用 `+` 号完成的，因为编译器已经做了优化。\n\n#### 小结一下\n\n你只需要记住这两点：\n\n1、在循环和多个表达式中不能 `+`，频繁创建 `SB` 性能影响；\n\n2、在单个表达式中可以用 `+`，编译器直接做了优化；\n\n老铁们，都搞清楚了？\n\n这个观点有没有被误解很久？\n\n下次面试，把这篇内容亮出来，吊打面试官，没问题的。\n\n有收获的朋友一定要点个在看，这样我写原创更带劲了，谢了，老铁们。\n","slug":"进阶/不能用 + 拼接字符串？ 这次我要吊打面试官！","published":1,"updated":"2025-10-15T07:21:14.223Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076h0013qkd42sjh4ej0","content":"<p>我们做 Java 程序员以来，不管是工作当中，还是面试过程中，都知道：字符串拼接不能用 String，要用 <code>StringBuilder</code> 或者是 <code>StringBuffer</code>，以至于它们都被滥用了。</p>\n<p>StringBuilder、StringBuffer 简称：SB，下文统一用 <code>SB</code> 代替。</p>\n<p><code>SB</code>它们都是可变的字符串，它们之间的区别也是 Java 初中级面试战场上出现几率十分高的一道题，上场率没有 90% 也有 80% 吧。</p>\n<p>这两个的具体区别请看这篇文章：<a href=\"https://mp.weixin.qq.com/s/Eeb9wa0DfUs9U5snahAJZQ\">StringBuffer 和 StringBuilder 的 3 个区别</a>。</p>\n<p>我们反过来想下，String真的是不可变的么？不一定，看下这篇：<a href=\"https://mp.weixin.qq.com/s/sLsCZ7T-GnkI6ZZXn22o-w\">Java 中的 String 真的是不可变的吗？</a></p>\n<p>当然，本文不是讨论字符串可变与不可变的问题，而是讨论：字符串拼接一定要用 <code>SB</code> 吗？为什么不能用 <code>+</code> ？能不能用 <code>+</code> ？什么时候可以用 <code>+</code> ？</p>\n<p>为什么不能用 + 号拼接字符串？我不服，接下来我要吊打面试官！</p>\n<h4 id=\"什么时候不能用\"><a href=\"#什么时候不能用\" class=\"headerlink\" title=\"什么时候不能用 +\"></a>什么时候不能用 <code>+</code></h4><p>通过多个表达式完成一个字符串拼接操作。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private void test1() &#123;\n    String www &#x3D; &quot;www.&quot;;\n    String str &#x3D; www;\n    str +&#x3D; &quot;javastack.&quot;;\n    str +&#x3D; &quot;com&quot;;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>字节码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; access flags 0xA\nprivate static test2()V\nL0\nLINENUMBER 14 L0\nLDC &quot;www.&quot;\nASTORE 0\nL1\nLINENUMBER 15 L1\nALOAD 0\nASTORE 1\nL2\nLINENUMBER 16 L2\nNEW java&#x2F;lang&#x2F;StringBuilder\nDUP\nINVOKESPECIAL java&#x2F;lang&#x2F;StringBuilder.&lt;init&gt; ()V\nALOAD 1\nINVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.append (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;\nLDC &quot;javastack.&quot;\nINVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.append (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;\nINVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.toString ()Ljava&#x2F;lang&#x2F;String;\nASTORE 1\nL3\nLINENUMBER 17 L3\nNEW java&#x2F;lang&#x2F;StringBuilder\nDUP\nINVOKESPECIAL java&#x2F;lang&#x2F;StringBuilder.&lt;init&gt; ()V\nALOAD 1\nINVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.append (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;\nLDC &quot;com&quot;\nINVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.append (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;\nINVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.toString ()Ljava&#x2F;lang&#x2F;String;\nASTORE 1\nL4\nLINENUMBER 18 L4\nRETURN\nL5\nLOCALVARIABLE www Ljava&#x2F;lang&#x2F;String; L1 L5 0\nLOCALVARIABLE str Ljava&#x2F;lang&#x2F;String; L2 L5 1\nMAXSTACK &#x3D; 2\nMAXLOCALS &#x3D; 2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>不会查看字节码的，看这里：<a href=\"https://mp.weixin.qq.com/s/bEEQf7bNik-rBPgK0uhjWg\">3种骚操作，教你查看 Java 字节码</a>，看这一篇就会了。</p>\n<p>观察下，<code>NEW java/lang/StringBuilder</code> 出现了两次，是因为我们在代码中拼接了两次，也就是说每一次拼接操作都会创建一次 <code>StringBuilder</code>。</p>\n<p>如果我们是在一个循环中进行字符串拼接，那是不是一次拼接就要创建一个 <code>StringBuilder</code>？</p>\n<p>wtf……这哪能接受！频繁创建对象是有性能开销的，这也是为什么我们常说的字符串不能用 <code>+</code> 拼接，而要用那两个 <code>SB</code>  拼接了。</p>\n<h4 id=\"什么时候可以用\"><a href=\"#什么时候可以用\" class=\"headerlink\" title=\"什么时候可以用 +\"></a>什么时候可以用 <code>+</code></h4><p>直接将三个字面量的字符串拼接成一个字符串。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void test2() &#123;\n    String str &#x3D; &quot;www.&quot; + &quot;javastack.&quot; + &quot;com&quot;;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>字节码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; access flags 0x2\nprivate test2()V\nL0\nLINENUMBER 13 L0\nLDC &quot;www.javastack.com&quot;\nASTORE 1\nL1\nLINENUMBER 14 L1\nRETURN\nL2\nLOCALVARIABLE this Lcom&#x2F;test&#x2F;jdk&#x2F;TestSB; L0 L2 0\nLOCALVARIABLE str Ljava&#x2F;lang&#x2F;String; L1 L2 1\nMAXSTACK &#x3D; 1\nMAXLOCALS &#x3D; 2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>从字节码看出，没有任何创建 <code>StringBuilder</code> 的指令，直接从常量池进行取出一个完整的字符串：<a href=\"http://www.javastack.com.很明显,这是/\">www.javastack.com。很明显，这是</a> Java 编译器对代码进行了优化。</p>\n<p>所以，通过这个示例告诉你，在这种情况下是可以用 <code>+</code> 号进行字符串拼接的。</p>\n<p>这个示例可以演变成我们实际工作当中的某个 SQL 语句拼接的案例，如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">String sql &#x3D; &quot;select name, sex, age, address&quot;\n        + &quot;from t_user&quot;\n        + &quot;where age &gt; 18&quot;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>别说这样不行，这样是行的。</p>\n<p>但你要是换成这样就不行了：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">String sql &#x3D; &quot;select name, sex, age, address&quot;;\nsql +&#x3D; &quot;from t_user&quot;;\nsql +&#x3D; &quot;where age &gt; 18&quot;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>这样又回到创建多个 <code>StringBuilder</code> 的时候了。</p>\n<p>也就是说，在一个表达式中完成字符串拼接是可以用 <code>+</code> 号完成的，因为编译器已经做了优化。</p>\n<h4 id=\"小结一下\"><a href=\"#小结一下\" class=\"headerlink\" title=\"小结一下\"></a>小结一下</h4><p>你只需要记住这两点：</p>\n<p>1、在循环和多个表达式中不能 <code>+</code>，频繁创建 <code>SB</code> 性能影响；</p>\n<p>2、在单个表达式中可以用 <code>+</code>，编译器直接做了优化；</p>\n<p>老铁们，都搞清楚了？</p>\n<p>这个观点有没有被误解很久？</p>\n<p>下次面试，把这篇内容亮出来，吊打面试官，没问题的。</p>\n<p>有收获的朋友一定要点个在看，这样我写原创更带劲了，谢了，老铁们。</p>\n","excerpt":"","more":"<p>我们做 Java 程序员以来，不管是工作当中，还是面试过程中，都知道：字符串拼接不能用 String，要用 <code>StringBuilder</code> 或者是 <code>StringBuffer</code>，以至于它们都被滥用了。</p>\n<p>StringBuilder、StringBuffer 简称：SB，下文统一用 <code>SB</code> 代替。</p>\n<p><code>SB</code>它们都是可变的字符串，它们之间的区别也是 Java 初中级面试战场上出现几率十分高的一道题，上场率没有 90% 也有 80% 吧。</p>\n<p>这两个的具体区别请看这篇文章：<a href=\"https://mp.weixin.qq.com/s/Eeb9wa0DfUs9U5snahAJZQ\">StringBuffer 和 StringBuilder 的 3 个区别</a>。</p>\n<p>我们反过来想下，String真的是不可变的么？不一定，看下这篇：<a href=\"https://mp.weixin.qq.com/s/sLsCZ7T-GnkI6ZZXn22o-w\">Java 中的 String 真的是不可变的吗？</a></p>\n<p>当然，本文不是讨论字符串可变与不可变的问题，而是讨论：字符串拼接一定要用 <code>SB</code> 吗？为什么不能用 <code>+</code> ？能不能用 <code>+</code> ？什么时候可以用 <code>+</code> ？</p>\n<p>为什么不能用 + 号拼接字符串？我不服，接下来我要吊打面试官！</p>\n<h4 id=\"什么时候不能用\"><a href=\"#什么时候不能用\" class=\"headerlink\" title=\"什么时候不能用 +\"></a>什么时候不能用 <code>+</code></h4><p>通过多个表达式完成一个字符串拼接操作。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private void test1() &#123;\n    String www &#x3D; &quot;www.&quot;;\n    String str &#x3D; www;\n    str +&#x3D; &quot;javastack.&quot;;\n    str +&#x3D; &quot;com&quot;;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>字节码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; access flags 0xA\nprivate static test2()V\nL0\nLINENUMBER 14 L0\nLDC &quot;www.&quot;\nASTORE 0\nL1\nLINENUMBER 15 L1\nALOAD 0\nASTORE 1\nL2\nLINENUMBER 16 L2\nNEW java&#x2F;lang&#x2F;StringBuilder\nDUP\nINVOKESPECIAL java&#x2F;lang&#x2F;StringBuilder.&lt;init&gt; ()V\nALOAD 1\nINVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.append (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;\nLDC &quot;javastack.&quot;\nINVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.append (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;\nINVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.toString ()Ljava&#x2F;lang&#x2F;String;\nASTORE 1\nL3\nLINENUMBER 17 L3\nNEW java&#x2F;lang&#x2F;StringBuilder\nDUP\nINVOKESPECIAL java&#x2F;lang&#x2F;StringBuilder.&lt;init&gt; ()V\nALOAD 1\nINVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.append (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;\nLDC &quot;com&quot;\nINVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.append (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;\nINVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.toString ()Ljava&#x2F;lang&#x2F;String;\nASTORE 1\nL4\nLINENUMBER 18 L4\nRETURN\nL5\nLOCALVARIABLE www Ljava&#x2F;lang&#x2F;String; L1 L5 0\nLOCALVARIABLE str Ljava&#x2F;lang&#x2F;String; L2 L5 1\nMAXSTACK &#x3D; 2\nMAXLOCALS &#x3D; 2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>不会查看字节码的，看这里：<a href=\"https://mp.weixin.qq.com/s/bEEQf7bNik-rBPgK0uhjWg\">3种骚操作，教你查看 Java 字节码</a>，看这一篇就会了。</p>\n<p>观察下，<code>NEW java/lang/StringBuilder</code> 出现了两次，是因为我们在代码中拼接了两次，也就是说每一次拼接操作都会创建一次 <code>StringBuilder</code>。</p>\n<p>如果我们是在一个循环中进行字符串拼接，那是不是一次拼接就要创建一个 <code>StringBuilder</code>？</p>\n<p>wtf……这哪能接受！频繁创建对象是有性能开销的，这也是为什么我们常说的字符串不能用 <code>+</code> 拼接，而要用那两个 <code>SB</code>  拼接了。</p>\n<h4 id=\"什么时候可以用\"><a href=\"#什么时候可以用\" class=\"headerlink\" title=\"什么时候可以用 +\"></a>什么时候可以用 <code>+</code></h4><p>直接将三个字面量的字符串拼接成一个字符串。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void test2() &#123;\n    String str &#x3D; &quot;www.&quot; + &quot;javastack.&quot; + &quot;com&quot;;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>字节码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; access flags 0x2\nprivate test2()V\nL0\nLINENUMBER 13 L0\nLDC &quot;www.javastack.com&quot;\nASTORE 1\nL1\nLINENUMBER 14 L1\nRETURN\nL2\nLOCALVARIABLE this Lcom&#x2F;test&#x2F;jdk&#x2F;TestSB; L0 L2 0\nLOCALVARIABLE str Ljava&#x2F;lang&#x2F;String; L1 L2 1\nMAXSTACK &#x3D; 1\nMAXLOCALS &#x3D; 2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>从字节码看出，没有任何创建 <code>StringBuilder</code> 的指令，直接从常量池进行取出一个完整的字符串：<a href=\"http://www.javastack.com.很明显,这是/\">www.javastack.com。很明显，这是</a> Java 编译器对代码进行了优化。</p>\n<p>所以，通过这个示例告诉你，在这种情况下是可以用 <code>+</code> 号进行字符串拼接的。</p>\n<p>这个示例可以演变成我们实际工作当中的某个 SQL 语句拼接的案例，如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">String sql &#x3D; &quot;select name, sex, age, address&quot;\n        + &quot;from t_user&quot;\n        + &quot;where age &gt; 18&quot;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>别说这样不行，这样是行的。</p>\n<p>但你要是换成这样就不行了：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">String sql &#x3D; &quot;select name, sex, age, address&quot;;\nsql +&#x3D; &quot;from t_user&quot;;\nsql +&#x3D; &quot;where age &gt; 18&quot;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>这样又回到创建多个 <code>StringBuilder</code> 的时候了。</p>\n<p>也就是说，在一个表达式中完成字符串拼接是可以用 <code>+</code> 号完成的，因为编译器已经做了优化。</p>\n<h4 id=\"小结一下\"><a href=\"#小结一下\" class=\"headerlink\" title=\"小结一下\"></a>小结一下</h4><p>你只需要记住这两点：</p>\n<p>1、在循环和多个表达式中不能 <code>+</code>，频繁创建 <code>SB</code> 性能影响；</p>\n<p>2、在单个表达式中可以用 <code>+</code>，编译器直接做了优化；</p>\n<p>老铁们，都搞清楚了？</p>\n<p>这个观点有没有被误解很久？</p>\n<p>下次面试，把这篇内容亮出来，吊打面试官，没问题的。</p>\n<p>有收获的朋友一定要点个在看，这样我写原创更带劲了，谢了，老铁们。</p>\n"},{"title":"别再写 bug 了，避免空指针的 5 个案例！","date":"2025-10-15T03:36:33.000Z","_content":"\n空指针是我们 Java 开发人员经常遇到的一个基本异常，这是一个极其普遍但似乎又无法根治的问题。\n\n本文，栈长将带你了解什么是空指针，还有如何有效的避免空指针。\n\n## 什么是空指针？\n\n当一个变量的值为 null 时，在 Java 里面表示一个不存在的空对象，没有实际内容，没有给它分配内存，null 也是对象成员变量的默认值。\n\n所以，一个对象如果没有进行初始化操作，这时候，如果你调用这个对象的方法或者变量，就会出现空指针异常。\n\n如下面示例会发生空指针异常：\n\n```\nObject object = null;\nString string = object.toString();\n```\n\n![](http://qianniu.javastack.cn/18-12-12/46377586.jpg)\n\n从类结构图来看，空指针它是属于运行时异常 `RuntimeException` 的子类，它不是捕获型的，只有在程序运行时才可能报出来，而且会造成程序中断。\n\n> 什么是运行时异常及异常的分类请看这篇文章：[一张图搞清楚 Java 异常机制](https://mp.weixin.qq.com/s/xbopgxZ5BEDdSvwO9ad9Xg)。\n\n## 如何避免空指针？\n\n下面说几个空指针的几个最常见的案例及解决之道。\n\n#### 1、字符串比较，常量放前面\n\n```\nif(status.equals(SUCCESS)){\n    \n}\n```\n\n这个时候 status 可能为 null 造成空指针异常，应该把常量放前面，就能避免空指针异常。\n\n```\nif(SUCCESS.equals(status)){\n    \n}\n```\n\n这个应该在各种开发规范里面都会提到，也是最基础的。\n\n#### 2、初始化默认值\n\n在对象初始化的时候给它一个默认值或者默认构造实现，如：\n\n```\nUser user = new User();\nString name = StringUtils.EMPTY;\n```\n\n#### 3、返回空集合\n\n在返回一个集合的话，默认会是 null，统一规范返回一个空集合。\n\n举个 List 例子，如：\n\n```\npublic List getUserList(){\n    List list = userMapper.gerUserList();\n    return list == null ? new ArrayList() : list;\n}\n```\n\n这样接收方就不用担心空指针异常了，也不会影响业务。\n\n#### 4、断言\n\n断言是用来检查程序的安全性的，在使用之前进行检查条件，如果不符合条件就报异常，符合就继续。\n\nJava 中自带的断言关键字：assert，如：\n\n```\nassert name == null : \"名称不能为空\";\n```\n\n输出：\n\n```\nException in thread \"main\" java.lang.AssertionError: 名称不正确\n```\n\n不过默认是不启动断言检查的，需要要带上 JVM 参数：-enableassertions 才能生效。\n\nJava 中这个用的很少，建议使用 Spring 中的，更强大，更方便好用。\n\nSpring中的用法：\n\n```\nAssert.notNull(name,\"名称不能为空\");\n```\n\n#### 5、Optional\n\nOptional 是 JDK 8 新增的新特性，再也不用 != null 来判断了，这个在一个对象里面的多个子对象连续判断的时候非常有用。\n\n这里不再详细介绍了，具体看这篇文章：[JDK8新特性之Optional](https://mp.weixin.qq.com/s/uXw4eTZqLfj871FlciPh6Q)。\n\n大家都有什么高见，欢迎留言分享！\n\n","source":"_posts/进阶/别再写 bug 了，避免空指针的 5 个案例！.md","raw":"---\ntitle: 别再写 bug 了，避免空指针的 5 个案例！\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 进阶\n---\n\n空指针是我们 Java 开发人员经常遇到的一个基本异常，这是一个极其普遍但似乎又无法根治的问题。\n\n本文，栈长将带你了解什么是空指针，还有如何有效的避免空指针。\n\n## 什么是空指针？\n\n当一个变量的值为 null 时，在 Java 里面表示一个不存在的空对象，没有实际内容，没有给它分配内存，null 也是对象成员变量的默认值。\n\n所以，一个对象如果没有进行初始化操作，这时候，如果你调用这个对象的方法或者变量，就会出现空指针异常。\n\n如下面示例会发生空指针异常：\n\n```\nObject object = null;\nString string = object.toString();\n```\n\n![](http://qianniu.javastack.cn/18-12-12/46377586.jpg)\n\n从类结构图来看，空指针它是属于运行时异常 `RuntimeException` 的子类，它不是捕获型的，只有在程序运行时才可能报出来，而且会造成程序中断。\n\n> 什么是运行时异常及异常的分类请看这篇文章：[一张图搞清楚 Java 异常机制](https://mp.weixin.qq.com/s/xbopgxZ5BEDdSvwO9ad9Xg)。\n\n## 如何避免空指针？\n\n下面说几个空指针的几个最常见的案例及解决之道。\n\n#### 1、字符串比较，常量放前面\n\n```\nif(status.equals(SUCCESS)){\n    \n}\n```\n\n这个时候 status 可能为 null 造成空指针异常，应该把常量放前面，就能避免空指针异常。\n\n```\nif(SUCCESS.equals(status)){\n    \n}\n```\n\n这个应该在各种开发规范里面都会提到，也是最基础的。\n\n#### 2、初始化默认值\n\n在对象初始化的时候给它一个默认值或者默认构造实现，如：\n\n```\nUser user = new User();\nString name = StringUtils.EMPTY;\n```\n\n#### 3、返回空集合\n\n在返回一个集合的话，默认会是 null，统一规范返回一个空集合。\n\n举个 List 例子，如：\n\n```\npublic List getUserList(){\n    List list = userMapper.gerUserList();\n    return list == null ? new ArrayList() : list;\n}\n```\n\n这样接收方就不用担心空指针异常了，也不会影响业务。\n\n#### 4、断言\n\n断言是用来检查程序的安全性的，在使用之前进行检查条件，如果不符合条件就报异常，符合就继续。\n\nJava 中自带的断言关键字：assert，如：\n\n```\nassert name == null : \"名称不能为空\";\n```\n\n输出：\n\n```\nException in thread \"main\" java.lang.AssertionError: 名称不正确\n```\n\n不过默认是不启动断言检查的，需要要带上 JVM 参数：-enableassertions 才能生效。\n\nJava 中这个用的很少，建议使用 Spring 中的，更强大，更方便好用。\n\nSpring中的用法：\n\n```\nAssert.notNull(name,\"名称不能为空\");\n```\n\n#### 5、Optional\n\nOptional 是 JDK 8 新增的新特性，再也不用 != null 来判断了，这个在一个对象里面的多个子对象连续判断的时候非常有用。\n\n这里不再详细介绍了，具体看这篇文章：[JDK8新特性之Optional](https://mp.weixin.qq.com/s/uXw4eTZqLfj871FlciPh6Q)。\n\n大家都有什么高见，欢迎留言分享！\n\n","slug":"进阶/别再写 bug 了，避免空指针的 5 个案例！","published":1,"updated":"2025-10-15T07:21:14.206Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076i0016qkd498g4cosa","content":"<p>空指针是我们 Java 开发人员经常遇到的一个基本异常，这是一个极其普遍但似乎又无法根治的问题。</p>\n<p>本文，栈长将带你了解什么是空指针，还有如何有效的避免空指针。</p>\n<h2 id=\"什么是空指针？\"><a href=\"#什么是空指针？\" class=\"headerlink\" title=\"什么是空指针？\"></a>什么是空指针？</h2><p>当一个变量的值为 null 时，在 Java 里面表示一个不存在的空对象，没有实际内容，没有给它分配内存，null 也是对象成员变量的默认值。</p>\n<p>所以，一个对象如果没有进行初始化操作，这时候，如果你调用这个对象的方法或者变量，就会出现空指针异常。</p>\n<p>如下面示例会发生空指针异常：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Object object &#x3D; null;\nString string &#x3D; object.toString();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><img src=\"http://qianniu.javastack.cn/18-12-12/46377586.jpg\"></p>\n<p>从类结构图来看，空指针它是属于运行时异常 <code>RuntimeException</code> 的子类，它不是捕获型的，只有在程序运行时才可能报出来，而且会造成程序中断。</p>\n<blockquote>\n<p>什么是运行时异常及异常的分类请看这篇文章：<a href=\"https://mp.weixin.qq.com/s/xbopgxZ5BEDdSvwO9ad9Xg\">一张图搞清楚 Java 异常机制</a>。</p>\n</blockquote>\n<h2 id=\"如何避免空指针？\"><a href=\"#如何避免空指针？\" class=\"headerlink\" title=\"如何避免空指针？\"></a>如何避免空指针？</h2><p>下面说几个空指针的几个最常见的案例及解决之道。</p>\n<h4 id=\"1、字符串比较，常量放前面\"><a href=\"#1、字符串比较，常量放前面\" class=\"headerlink\" title=\"1、字符串比较，常量放前面\"></a>1、字符串比较，常量放前面</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">if(status.equals(SUCCESS))&#123;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>这个时候 status 可能为 null 造成空指针异常，应该把常量放前面，就能避免空指针异常。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">if(SUCCESS.equals(status))&#123;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>这个应该在各种开发规范里面都会提到，也是最基础的。</p>\n<h4 id=\"2、初始化默认值\"><a href=\"#2、初始化默认值\" class=\"headerlink\" title=\"2、初始化默认值\"></a>2、初始化默认值</h4><p>在对象初始化的时候给它一个默认值或者默认构造实现，如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">User user &#x3D; new User();\nString name &#x3D; StringUtils.EMPTY;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h4 id=\"3、返回空集合\"><a href=\"#3、返回空集合\" class=\"headerlink\" title=\"3、返回空集合\"></a>3、返回空集合</h4><p>在返回一个集合的话，默认会是 null，统一规范返回一个空集合。</p>\n<p>举个 List 例子，如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public List getUserList()&#123;\n    List list &#x3D; userMapper.gerUserList();\n    return list &#x3D;&#x3D; null ? new ArrayList() : list;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这样接收方就不用担心空指针异常了，也不会影响业务。</p>\n<h4 id=\"4、断言\"><a href=\"#4、断言\" class=\"headerlink\" title=\"4、断言\"></a>4、断言</h4><p>断言是用来检查程序的安全性的，在使用之前进行检查条件，如果不符合条件就报异常，符合就继续。</p>\n<p>Java 中自带的断言关键字：assert，如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">assert name &#x3D;&#x3D; null : &quot;名称不能为空&quot;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Exception in thread &quot;main&quot; java.lang.AssertionError: 名称不正确<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>不过默认是不启动断言检查的，需要要带上 JVM 参数：-enableassertions 才能生效。</p>\n<p>Java 中这个用的很少，建议使用 Spring 中的，更强大，更方便好用。</p>\n<p>Spring中的用法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Assert.notNull(name,&quot;名称不能为空&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"5、Optional\"><a href=\"#5、Optional\" class=\"headerlink\" title=\"5、Optional\"></a>5、Optional</h4><p>Optional 是 JDK 8 新增的新特性，再也不用 !&#x3D; null 来判断了，这个在一个对象里面的多个子对象连续判断的时候非常有用。</p>\n<p>这里不再详细介绍了，具体看这篇文章：<a href=\"https://mp.weixin.qq.com/s/uXw4eTZqLfj871FlciPh6Q\">JDK8新特性之Optional</a>。</p>\n<p>大家都有什么高见，欢迎留言分享！</p>\n","excerpt":"","more":"<p>空指针是我们 Java 开发人员经常遇到的一个基本异常，这是一个极其普遍但似乎又无法根治的问题。</p>\n<p>本文，栈长将带你了解什么是空指针，还有如何有效的避免空指针。</p>\n<h2 id=\"什么是空指针？\"><a href=\"#什么是空指针？\" class=\"headerlink\" title=\"什么是空指针？\"></a>什么是空指针？</h2><p>当一个变量的值为 null 时，在 Java 里面表示一个不存在的空对象，没有实际内容，没有给它分配内存，null 也是对象成员变量的默认值。</p>\n<p>所以，一个对象如果没有进行初始化操作，这时候，如果你调用这个对象的方法或者变量，就会出现空指针异常。</p>\n<p>如下面示例会发生空指针异常：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Object object &#x3D; null;\nString string &#x3D; object.toString();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><img src=\"http://qianniu.javastack.cn/18-12-12/46377586.jpg\"></p>\n<p>从类结构图来看，空指针它是属于运行时异常 <code>RuntimeException</code> 的子类，它不是捕获型的，只有在程序运行时才可能报出来，而且会造成程序中断。</p>\n<blockquote>\n<p>什么是运行时异常及异常的分类请看这篇文章：<a href=\"https://mp.weixin.qq.com/s/xbopgxZ5BEDdSvwO9ad9Xg\">一张图搞清楚 Java 异常机制</a>。</p>\n</blockquote>\n<h2 id=\"如何避免空指针？\"><a href=\"#如何避免空指针？\" class=\"headerlink\" title=\"如何避免空指针？\"></a>如何避免空指针？</h2><p>下面说几个空指针的几个最常见的案例及解决之道。</p>\n<h4 id=\"1、字符串比较，常量放前面\"><a href=\"#1、字符串比较，常量放前面\" class=\"headerlink\" title=\"1、字符串比较，常量放前面\"></a>1、字符串比较，常量放前面</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">if(status.equals(SUCCESS))&#123;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>这个时候 status 可能为 null 造成空指针异常，应该把常量放前面，就能避免空指针异常。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">if(SUCCESS.equals(status))&#123;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>这个应该在各种开发规范里面都会提到，也是最基础的。</p>\n<h4 id=\"2、初始化默认值\"><a href=\"#2、初始化默认值\" class=\"headerlink\" title=\"2、初始化默认值\"></a>2、初始化默认值</h4><p>在对象初始化的时候给它一个默认值或者默认构造实现，如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">User user &#x3D; new User();\nString name &#x3D; StringUtils.EMPTY;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h4 id=\"3、返回空集合\"><a href=\"#3、返回空集合\" class=\"headerlink\" title=\"3、返回空集合\"></a>3、返回空集合</h4><p>在返回一个集合的话，默认会是 null，统一规范返回一个空集合。</p>\n<p>举个 List 例子，如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public List getUserList()&#123;\n    List list &#x3D; userMapper.gerUserList();\n    return list &#x3D;&#x3D; null ? new ArrayList() : list;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这样接收方就不用担心空指针异常了，也不会影响业务。</p>\n<h4 id=\"4、断言\"><a href=\"#4、断言\" class=\"headerlink\" title=\"4、断言\"></a>4、断言</h4><p>断言是用来检查程序的安全性的，在使用之前进行检查条件，如果不符合条件就报异常，符合就继续。</p>\n<p>Java 中自带的断言关键字：assert，如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">assert name &#x3D;&#x3D; null : &quot;名称不能为空&quot;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Exception in thread &quot;main&quot; java.lang.AssertionError: 名称不正确<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>不过默认是不启动断言检查的，需要要带上 JVM 参数：-enableassertions 才能生效。</p>\n<p>Java 中这个用的很少，建议使用 Spring 中的，更强大，更方便好用。</p>\n<p>Spring中的用法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Assert.notNull(name,&quot;名称不能为空&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"5、Optional\"><a href=\"#5、Optional\" class=\"headerlink\" title=\"5、Optional\"></a>5、Optional</h4><p>Optional 是 JDK 8 新增的新特性，再也不用 !&#x3D; null 来判断了，这个在一个对象里面的多个子对象连续判断的时候非常有用。</p>\n<p>这里不再详细介绍了，具体看这篇文章：<a href=\"https://mp.weixin.qq.com/s/uXw4eTZqLfj871FlciPh6Q\">JDK8新特性之Optional</a>。</p>\n<p>大家都有什么高见，欢迎留言分享！</p>\n"},{"title":"字符串 substring 方法在 JDK 6,7,8 中的差异。","date":"2025-10-15T03:36:33.000Z","_content":"\n标题中的substring方法指的是字符串的substring(int beginIndex, int endIndex)方法，这个方法在jdk6,7是有差异的。\n\n## substring有什么用？\n\nsubstring返回的是字符串索引位置beginIndex开始，endIndex-1结束的字符串。\n\n来看这个例子：\n\n```\nString x = \"abcdef\";\nx = x.substring(1,3);\nSystem.out.println(x);\n```\n输出：\n\n```\nbc\n```\n\n下面看看在JDK之间，它们的实现原理有什么不一样，及值得注意的地方。\n\n#### JDK 6\n\nString背后是由char数组构成的，在JDK6中，String包含三个字段：char value[], int offset, int count，意思很简单。\n\nsubstring被调用时，它会创建一个新的字符串，但字符串的值还指向堆中同样的字符数组。它们的区别只是数量和下标引用不一样，如图所示。\n\n![image](https://www.programcreek.com/wp-content/uploads/2013/09/string-substring-jdk6-650x389.jpeg)\n\nJDK6中的部分源码可以说明这个问题。\n\n```\n//JDK 6\nString(int offset, int count, char value[]) {\n\tthis.value = value;\n\tthis.offset = offset;\n\tthis.count = count;\n}\n \npublic String substring(int beginIndex, int endIndex) {\n\t//check boundary\n\treturn  new String(offset + beginIndex, endIndex - beginIndex, value);\n}\n```\n\n**会有什么问题？**\n\n如果一个很长的字符串，但是每次使用substring()，你只需要很小的一部分。这将会导致性能问题，因为只需要一小部分，却引用了整个字符数组内容。对于JDK 6，解决方案是使用以下内容：\n\n```\nx = x.substring(x, y) + \"\"\n```\n\n#### JDK 7,8\n\nJDK6这种问题在JDK7+中已经改善了，JDK7+中实际是重新创建了一个字符数组，如图。\n\n![image](https://www.programcreek.com/wp-content/uploads/2013/09/string-substring-jdk71-650x389.jpeg)\n\n\nJDK7中的部分源码，JDK8类似。\n\n```\n//JDK 7\npublic String(char value[], int offset, int count) {\n\t//check boundary\n\tthis.value = Arrays.copyOfRange(value, offset, offset + count);\n}\n \npublic String substring(int beginIndex, int endIndex) {\n\t//check boundary\n\tint subLen = endIndex - beginIndex;\n\treturn new String(value, beginIndex, subLen);\n}\n```\n\n对于JDK的这种差异，我们知道就好，现在应该都是JDK7及8了吧，其实对于小字符串的这种操作性能也是可以忽略不计的。\n\n","source":"_posts/进阶/字符串 substring 方法在 JDK 6,7,8 中的差异。.md","raw":"---\ntitle: 字符串 substring 方法在 JDK 6,7,8 中的差异。\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 进阶\n---\n\n标题中的substring方法指的是字符串的substring(int beginIndex, int endIndex)方法，这个方法在jdk6,7是有差异的。\n\n## substring有什么用？\n\nsubstring返回的是字符串索引位置beginIndex开始，endIndex-1结束的字符串。\n\n来看这个例子：\n\n```\nString x = \"abcdef\";\nx = x.substring(1,3);\nSystem.out.println(x);\n```\n输出：\n\n```\nbc\n```\n\n下面看看在JDK之间，它们的实现原理有什么不一样，及值得注意的地方。\n\n#### JDK 6\n\nString背后是由char数组构成的，在JDK6中，String包含三个字段：char value[], int offset, int count，意思很简单。\n\nsubstring被调用时，它会创建一个新的字符串，但字符串的值还指向堆中同样的字符数组。它们的区别只是数量和下标引用不一样，如图所示。\n\n![image](https://www.programcreek.com/wp-content/uploads/2013/09/string-substring-jdk6-650x389.jpeg)\n\nJDK6中的部分源码可以说明这个问题。\n\n```\n//JDK 6\nString(int offset, int count, char value[]) {\n\tthis.value = value;\n\tthis.offset = offset;\n\tthis.count = count;\n}\n \npublic String substring(int beginIndex, int endIndex) {\n\t//check boundary\n\treturn  new String(offset + beginIndex, endIndex - beginIndex, value);\n}\n```\n\n**会有什么问题？**\n\n如果一个很长的字符串，但是每次使用substring()，你只需要很小的一部分。这将会导致性能问题，因为只需要一小部分，却引用了整个字符数组内容。对于JDK 6，解决方案是使用以下内容：\n\n```\nx = x.substring(x, y) + \"\"\n```\n\n#### JDK 7,8\n\nJDK6这种问题在JDK7+中已经改善了，JDK7+中实际是重新创建了一个字符数组，如图。\n\n![image](https://www.programcreek.com/wp-content/uploads/2013/09/string-substring-jdk71-650x389.jpeg)\n\n\nJDK7中的部分源码，JDK8类似。\n\n```\n//JDK 7\npublic String(char value[], int offset, int count) {\n\t//check boundary\n\tthis.value = Arrays.copyOfRange(value, offset, offset + count);\n}\n \npublic String substring(int beginIndex, int endIndex) {\n\t//check boundary\n\tint subLen = endIndex - beginIndex;\n\treturn new String(value, beginIndex, subLen);\n}\n```\n\n对于JDK的这种差异，我们知道就好，现在应该都是JDK7及8了吧，其实对于小字符串的这种操作性能也是可以忽略不计的。\n\n","slug":"进阶/字符串 substring 方法在 JDK 6,7,8 中的差异。","published":1,"updated":"2025-10-15T07:21:14.239Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076j001aqkd4f4878bo7","content":"<p>标题中的substring方法指的是字符串的substring(int beginIndex, int endIndex)方法，这个方法在jdk6,7是有差异的。</p>\n<h2 id=\"substring有什么用？\"><a href=\"#substring有什么用？\" class=\"headerlink\" title=\"substring有什么用？\"></a>substring有什么用？</h2><p>substring返回的是字符串索引位置beginIndex开始，endIndex-1结束的字符串。</p>\n<p>来看这个例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">String x &#x3D; &quot;abcdef&quot;;\nx &#x3D; x.substring(1,3);\nSystem.out.println(x);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">bc<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>下面看看在JDK之间，它们的实现原理有什么不一样，及值得注意的地方。</p>\n<h4 id=\"JDK-6\"><a href=\"#JDK-6\" class=\"headerlink\" title=\"JDK 6\"></a>JDK 6</h4><p>String背后是由char数组构成的，在JDK6中，String包含三个字段：char value[], int offset, int count，意思很简单。</p>\n<p>substring被调用时，它会创建一个新的字符串，但字符串的值还指向堆中同样的字符数组。它们的区别只是数量和下标引用不一样，如图所示。</p>\n<p><img src=\"https://www.programcreek.com/wp-content/uploads/2013/09/string-substring-jdk6-650x389.jpeg\" alt=\"image\"></p>\n<p>JDK6中的部分源码可以说明这个问题。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;JDK 6\nString(int offset, int count, char value[]) &#123;\n\tthis.value &#x3D; value;\n\tthis.offset &#x3D; offset;\n\tthis.count &#x3D; count;\n&#125;\n \npublic String substring(int beginIndex, int endIndex) &#123;\n\t&#x2F;&#x2F;check boundary\n\treturn  new String(offset + beginIndex, endIndex - beginIndex, value);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>会有什么问题？</strong></p>\n<p>如果一个很长的字符串，但是每次使用substring()，你只需要很小的一部分。这将会导致性能问题，因为只需要一小部分，却引用了整个字符数组内容。对于JDK 6，解决方案是使用以下内容：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">x &#x3D; x.substring(x, y) + &quot;&quot;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"JDK-7-8\"><a href=\"#JDK-7-8\" class=\"headerlink\" title=\"JDK 7,8\"></a>JDK 7,8</h4><p>JDK6这种问题在JDK7+中已经改善了，JDK7+中实际是重新创建了一个字符数组，如图。</p>\n<p><img src=\"https://www.programcreek.com/wp-content/uploads/2013/09/string-substring-jdk71-650x389.jpeg\" alt=\"image\"></p>\n<p>JDK7中的部分源码，JDK8类似。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;JDK 7\npublic String(char value[], int offset, int count) &#123;\n\t&#x2F;&#x2F;check boundary\n\tthis.value &#x3D; Arrays.copyOfRange(value, offset, offset + count);\n&#125;\n \npublic String substring(int beginIndex, int endIndex) &#123;\n\t&#x2F;&#x2F;check boundary\n\tint subLen &#x3D; endIndex - beginIndex;\n\treturn new String(value, beginIndex, subLen);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>对于JDK的这种差异，我们知道就好，现在应该都是JDK7及8了吧，其实对于小字符串的这种操作性能也是可以忽略不计的。</p>\n","excerpt":"","more":"<p>标题中的substring方法指的是字符串的substring(int beginIndex, int endIndex)方法，这个方法在jdk6,7是有差异的。</p>\n<h2 id=\"substring有什么用？\"><a href=\"#substring有什么用？\" class=\"headerlink\" title=\"substring有什么用？\"></a>substring有什么用？</h2><p>substring返回的是字符串索引位置beginIndex开始，endIndex-1结束的字符串。</p>\n<p>来看这个例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">String x &#x3D; &quot;abcdef&quot;;\nx &#x3D; x.substring(1,3);\nSystem.out.println(x);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">bc<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>下面看看在JDK之间，它们的实现原理有什么不一样，及值得注意的地方。</p>\n<h4 id=\"JDK-6\"><a href=\"#JDK-6\" class=\"headerlink\" title=\"JDK 6\"></a>JDK 6</h4><p>String背后是由char数组构成的，在JDK6中，String包含三个字段：char value[], int offset, int count，意思很简单。</p>\n<p>substring被调用时，它会创建一个新的字符串，但字符串的值还指向堆中同样的字符数组。它们的区别只是数量和下标引用不一样，如图所示。</p>\n<p><img src=\"https://www.programcreek.com/wp-content/uploads/2013/09/string-substring-jdk6-650x389.jpeg\" alt=\"image\"></p>\n<p>JDK6中的部分源码可以说明这个问题。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;JDK 6\nString(int offset, int count, char value[]) &#123;\n\tthis.value &#x3D; value;\n\tthis.offset &#x3D; offset;\n\tthis.count &#x3D; count;\n&#125;\n \npublic String substring(int beginIndex, int endIndex) &#123;\n\t&#x2F;&#x2F;check boundary\n\treturn  new String(offset + beginIndex, endIndex - beginIndex, value);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>会有什么问题？</strong></p>\n<p>如果一个很长的字符串，但是每次使用substring()，你只需要很小的一部分。这将会导致性能问题，因为只需要一小部分，却引用了整个字符数组内容。对于JDK 6，解决方案是使用以下内容：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">x &#x3D; x.substring(x, y) + &quot;&quot;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"JDK-7-8\"><a href=\"#JDK-7-8\" class=\"headerlink\" title=\"JDK 7,8\"></a>JDK 7,8</h4><p>JDK6这种问题在JDK7+中已经改善了，JDK7+中实际是重新创建了一个字符数组，如图。</p>\n<p><img src=\"https://www.programcreek.com/wp-content/uploads/2013/09/string-substring-jdk71-650x389.jpeg\" alt=\"image\"></p>\n<p>JDK7中的部分源码，JDK8类似。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;JDK 7\npublic String(char value[], int offset, int count) &#123;\n\t&#x2F;&#x2F;check boundary\n\tthis.value &#x3D; Arrays.copyOfRange(value, offset, offset + count);\n&#125;\n \npublic String substring(int beginIndex, int endIndex) &#123;\n\t&#x2F;&#x2F;check boundary\n\tint subLen &#x3D; endIndex - beginIndex;\n\treturn new String(value, beginIndex, subLen);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>对于JDK的这种差异，我们知道就好，现在应该都是JDK7及8了吧，其实对于小字符串的这种操作性能也是可以忽略不计的。</p>\n"},{"title":"神奇，教你用随机数打印hello world","date":"2025-10-15T03:36:33.000Z","_content":"下面是一段随机数程序。\n\n```\npublic static void main(String[] args) {\n\tSystem.out.println(randomString(-229985452) + \" \" + randomString(-147909649));\n}\n\npublic static String randomString(int seed) {\n\tRandom ran = new Random(seed);\n\tStringBuilder sb = new StringBuilder();\n\twhile (true) {\n\t\tint k = ran.nextInt(27);\n\t\tif (k == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tsb.append((char) ('`' + k));\n\t}\n\treturn sb.toString();\n}\n```\n\n**每次都会输出：hello world，这是为什么呢？？**\n\nRandom构造函数，参数seed是初始种子，相同的种子每次产生的随机数都一样，所以无论怎么随机，构造出来的随机数都一样。\n\n**Random r = new Random(-229985452)**\n\n会产生以下5位不为0的随机数：\n\n\n```\n8\n5\n12\n12\n15\n```\n\n**Random r = new Random(-147909649)**\n\n会产生以下5位不为0的随机数：\n\n\n```\n23\n15\n18\n12\n4\n```\n\n程序里面用\\`符号相加，\\`代表96.\n\n所以，有下面的结果：\n\n\n```\n8  + 96 = 104 --> h\n5  + 96 = 101 --> e\n12 + 96 = 108 --> l\n12 + 96 = 108 --> l\n15 + 96 = 111 --> o\n\n23 + 96 = 119 --> w\n15 + 96 = 111 --> o\n18 + 96 = 114 --> r\n12 + 96 = 108 --> l\n4  + 96 = 100 --> d\n```\n\n一段很简单的程序却如此神奇，分享给别人，看他知道不？\n\n","source":"_posts/进阶/神奇，教你用随机数打印hello world.md","raw":"---\ntitle: 神奇，教你用随机数打印hello world\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 进阶\n---\n下面是一段随机数程序。\n\n```\npublic static void main(String[] args) {\n\tSystem.out.println(randomString(-229985452) + \" \" + randomString(-147909649));\n}\n\npublic static String randomString(int seed) {\n\tRandom ran = new Random(seed);\n\tStringBuilder sb = new StringBuilder();\n\twhile (true) {\n\t\tint k = ran.nextInt(27);\n\t\tif (k == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tsb.append((char) ('`' + k));\n\t}\n\treturn sb.toString();\n}\n```\n\n**每次都会输出：hello world，这是为什么呢？？**\n\nRandom构造函数，参数seed是初始种子，相同的种子每次产生的随机数都一样，所以无论怎么随机，构造出来的随机数都一样。\n\n**Random r = new Random(-229985452)**\n\n会产生以下5位不为0的随机数：\n\n\n```\n8\n5\n12\n12\n15\n```\n\n**Random r = new Random(-147909649)**\n\n会产生以下5位不为0的随机数：\n\n\n```\n23\n15\n18\n12\n4\n```\n\n程序里面用\\`符号相加，\\`代表96.\n\n所以，有下面的结果：\n\n\n```\n8  + 96 = 104 --> h\n5  + 96 = 101 --> e\n12 + 96 = 108 --> l\n12 + 96 = 108 --> l\n15 + 96 = 111 --> o\n\n23 + 96 = 119 --> w\n15 + 96 = 111 --> o\n18 + 96 = 114 --> r\n12 + 96 = 108 --> l\n4  + 96 = 100 --> d\n```\n\n一段很简单的程序却如此神奇，分享给别人，看他知道不？\n\n","slug":"进阶/神奇，教你用随机数打印hello world","published":1,"updated":"2025-10-15T07:21:14.215Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076j001dqkd4d422aq8t","content":"<p>下面是一段随机数程序。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n\tSystem.out.println(randomString(-229985452) + &quot; &quot; + randomString(-147909649));\n&#125;\n\npublic static String randomString(int seed) &#123;\n\tRandom ran &#x3D; new Random(seed);\n\tStringBuilder sb &#x3D; new StringBuilder();\n\twhile (true) &#123;\n\t\tint k &#x3D; ran.nextInt(27);\n\t\tif (k &#x3D;&#x3D; 0) &#123;\n\t\t\tbreak;\n\t\t&#125;\n\t\tsb.append((char) (&#39;&#96;&#39; + k));\n\t&#125;\n\treturn sb.toString();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>每次都会输出：hello world，这是为什么呢？？</strong></p>\n<p>Random构造函数，参数seed是初始种子，相同的种子每次产生的随机数都一样，所以无论怎么随机，构造出来的随机数都一样。</p>\n<p><strong>Random r &#x3D; new Random(-229985452)</strong></p>\n<p>会产生以下5位不为0的随机数：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">8\n5\n12\n12\n15<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>Random r &#x3D; new Random(-147909649)</strong></p>\n<p>会产生以下5位不为0的随机数：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">23\n15\n18\n12\n4<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>程序里面用`符号相加，`代表96.</p>\n<p>所以，有下面的结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">8  + 96 &#x3D; 104 --&gt; h\n5  + 96 &#x3D; 101 --&gt; e\n12 + 96 &#x3D; 108 --&gt; l\n12 + 96 &#x3D; 108 --&gt; l\n15 + 96 &#x3D; 111 --&gt; o\n\n23 + 96 &#x3D; 119 --&gt; w\n15 + 96 &#x3D; 111 --&gt; o\n18 + 96 &#x3D; 114 --&gt; r\n12 + 96 &#x3D; 108 --&gt; l\n4  + 96 &#x3D; 100 --&gt; d<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>一段很简单的程序却如此神奇，分享给别人，看他知道不？</p>\n","excerpt":"","more":"<p>下面是一段随机数程序。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n\tSystem.out.println(randomString(-229985452) + &quot; &quot; + randomString(-147909649));\n&#125;\n\npublic static String randomString(int seed) &#123;\n\tRandom ran &#x3D; new Random(seed);\n\tStringBuilder sb &#x3D; new StringBuilder();\n\twhile (true) &#123;\n\t\tint k &#x3D; ran.nextInt(27);\n\t\tif (k &#x3D;&#x3D; 0) &#123;\n\t\t\tbreak;\n\t\t&#125;\n\t\tsb.append((char) (&#39;&#96;&#39; + k));\n\t&#125;\n\treturn sb.toString();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>每次都会输出：hello world，这是为什么呢？？</strong></p>\n<p>Random构造函数，参数seed是初始种子，相同的种子每次产生的随机数都一样，所以无论怎么随机，构造出来的随机数都一样。</p>\n<p><strong>Random r &#x3D; new Random(-229985452)</strong></p>\n<p>会产生以下5位不为0的随机数：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">8\n5\n12\n12\n15<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>Random r &#x3D; new Random(-147909649)</strong></p>\n<p>会产生以下5位不为0的随机数：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">23\n15\n18\n12\n4<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>程序里面用`符号相加，`代表96.</p>\n<p>所以，有下面的结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">8  + 96 &#x3D; 104 --&gt; h\n5  + 96 &#x3D; 101 --&gt; e\n12 + 96 &#x3D; 108 --&gt; l\n12 + 96 &#x3D; 108 --&gt; l\n15 + 96 &#x3D; 111 --&gt; o\n\n23 + 96 &#x3D; 119 --&gt; w\n15 + 96 &#x3D; 111 --&gt; o\n18 + 96 &#x3D; 114 --&gt; r\n12 + 96 &#x3D; 108 --&gt; l\n4  + 96 &#x3D; 100 --&gt; d<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>一段很简单的程序却如此神奇，分享给别人，看他知道不？</p>\n"},{"title":"金融系统中正确的金额计算及存储方式","date":"2025-10-15T03:36:33.000Z","_content":"\n#### 经典的精度丢失问题\n\n Java中的类型float、double用来做计算会有精度丢失问题，下面来看下面的示例。\n\n```\npublic static void main(String[] args) {\n\ttest1();\n\ttest2();\n}\n\nprivate static void test1() {\n\tdouble totalAmount = 0.09;\n\tdouble feeAmount = 0.02;\n\tdouble tradeAmount = totalAmount - feeAmount;\n\tSystem.out.println(tradeAmount);\n}\n```\n\n上面的程序输出结果是多少？\n\n0.07？非也！\n\n正确的结果是：\n\n\n```\n0.06999999999999999\n```\n\n为什么是这样？\n\n浮点数可能丢失精度，浮点十进制数通常没有完全相同的二进制的表示形式，这是CPU所采用的浮点数据表示形式的副作用。为此，可能会有一些精度丢失，并且一些浮点运算可能会产生未知的结果。\n\n浮点运算很少是精确的，只要是超过精度能表示的范围就会产生误差。所以，在使用float、double作精确运算的时候一定要特别小心，除非能容忍精度丢失，不然产生的误差也是会造成双方对账不一致的结果。\n\n#### 怎么解决\n\n> 在《Effective Java》这本书中也提到这个原则，float和double只能用来做科学计算或者是工程计算，在商业计算中我们要用 java.math.BigDecimal。\n\nBigDecimal适合更精度的运算，也提供了丰富的操作符类型，小数位控制，四舍五入规则等。\n\n不过，使用BigDecimal不当也有精度丢失的情况，如double的构造方法：\n\n```\nBigDecimal(double val)\n```\n\n再来看这个示例：\n\n```\nprivate static void test2() {\n\tdouble totalAmount = 0.09;\n\tdouble feeAmount = 0.02;\n\tBigDecimal tradeAmount = new BigDecimal(totalAmount).subtract(new BigDecimal(feeAmount));\n\tSystem.out.println(tradeAmount);\n}\n```\n\n输出：\n\n```\n0.0699999999999999962529972918900966760702431201934814453125\n```\n\n这个精度就更恐怖了。。\n\n所以，一定要使用String的构造方法：\n\n```\nBigDecimal(String val)\n```\n\n```\nprivate static void test3() {\n\tdouble totalAmount = 0.09;\n\tdouble feeAmount = 0.02;\n\tBigDecimal tradeAmount = new BigDecimal(String.valueOf(totalAmount))\n\t\t\t.subtract(new BigDecimal(String.valueOf(feeAmount)));\n\tSystem.out.println(tradeAmount);\n}\n```\n\n#### 总结\n\n1. 金额运算尽量使用BigDecimal(String val)进行运算。\n\n1. 数据库存储金额，一般有整型和浮点型两种存储方式。如果是有汇率转换的，建议使用浮点数decimal进行存储，可以灵活的控制精度，decimal直接对应java类型BigDecimal。当然，用整数存储分这种形式也可以，转账的时候单位为元而如果忘了转换分为元，那就悲剧了。","source":"_posts/进阶/金融系统中正确的金额计算及存储方式.md","raw":"---\ntitle: 金融系统中正确的金额计算及存储方式\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 进阶\n---\n\n#### 经典的精度丢失问题\n\n Java中的类型float、double用来做计算会有精度丢失问题，下面来看下面的示例。\n\n```\npublic static void main(String[] args) {\n\ttest1();\n\ttest2();\n}\n\nprivate static void test1() {\n\tdouble totalAmount = 0.09;\n\tdouble feeAmount = 0.02;\n\tdouble tradeAmount = totalAmount - feeAmount;\n\tSystem.out.println(tradeAmount);\n}\n```\n\n上面的程序输出结果是多少？\n\n0.07？非也！\n\n正确的结果是：\n\n\n```\n0.06999999999999999\n```\n\n为什么是这样？\n\n浮点数可能丢失精度，浮点十进制数通常没有完全相同的二进制的表示形式，这是CPU所采用的浮点数据表示形式的副作用。为此，可能会有一些精度丢失，并且一些浮点运算可能会产生未知的结果。\n\n浮点运算很少是精确的，只要是超过精度能表示的范围就会产生误差。所以，在使用float、double作精确运算的时候一定要特别小心，除非能容忍精度丢失，不然产生的误差也是会造成双方对账不一致的结果。\n\n#### 怎么解决\n\n> 在《Effective Java》这本书中也提到这个原则，float和double只能用来做科学计算或者是工程计算，在商业计算中我们要用 java.math.BigDecimal。\n\nBigDecimal适合更精度的运算，也提供了丰富的操作符类型，小数位控制，四舍五入规则等。\n\n不过，使用BigDecimal不当也有精度丢失的情况，如double的构造方法：\n\n```\nBigDecimal(double val)\n```\n\n再来看这个示例：\n\n```\nprivate static void test2() {\n\tdouble totalAmount = 0.09;\n\tdouble feeAmount = 0.02;\n\tBigDecimal tradeAmount = new BigDecimal(totalAmount).subtract(new BigDecimal(feeAmount));\n\tSystem.out.println(tradeAmount);\n}\n```\n\n输出：\n\n```\n0.0699999999999999962529972918900966760702431201934814453125\n```\n\n这个精度就更恐怖了。。\n\n所以，一定要使用String的构造方法：\n\n```\nBigDecimal(String val)\n```\n\n```\nprivate static void test3() {\n\tdouble totalAmount = 0.09;\n\tdouble feeAmount = 0.02;\n\tBigDecimal tradeAmount = new BigDecimal(String.valueOf(totalAmount))\n\t\t\t.subtract(new BigDecimal(String.valueOf(feeAmount)));\n\tSystem.out.println(tradeAmount);\n}\n```\n\n#### 总结\n\n1. 金额运算尽量使用BigDecimal(String val)进行运算。\n\n1. 数据库存储金额，一般有整型和浮点型两种存储方式。如果是有汇率转换的，建议使用浮点数decimal进行存储，可以灵活的控制精度，decimal直接对应java类型BigDecimal。当然，用整数存储分这种形式也可以，转账的时候单位为元而如果忘了转换分为元，那就悲剧了。","slug":"进阶/金融系统中正确的金额计算及存储方式","published":1,"updated":"2025-10-15T07:21:14.292Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076j001hqkd423ox8ra0","content":"<h4 id=\"经典的精度丢失问题\"><a href=\"#经典的精度丢失问题\" class=\"headerlink\" title=\"经典的精度丢失问题\"></a>经典的精度丢失问题</h4><p> Java中的类型float、double用来做计算会有精度丢失问题，下面来看下面的示例。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n\ttest1();\n\ttest2();\n&#125;\n\nprivate static void test1() &#123;\n\tdouble totalAmount &#x3D; 0.09;\n\tdouble feeAmount &#x3D; 0.02;\n\tdouble tradeAmount &#x3D; totalAmount - feeAmount;\n\tSystem.out.println(tradeAmount);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>上面的程序输出结果是多少？</p>\n<p>0.07？非也！</p>\n<p>正确的结果是：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0.06999999999999999<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>为什么是这样？</p>\n<p>浮点数可能丢失精度，浮点十进制数通常没有完全相同的二进制的表示形式，这是CPU所采用的浮点数据表示形式的副作用。为此，可能会有一些精度丢失，并且一些浮点运算可能会产生未知的结果。</p>\n<p>浮点运算很少是精确的，只要是超过精度能表示的范围就会产生误差。所以，在使用float、double作精确运算的时候一定要特别小心，除非能容忍精度丢失，不然产生的误差也是会造成双方对账不一致的结果。</p>\n<h4 id=\"怎么解决\"><a href=\"#怎么解决\" class=\"headerlink\" title=\"怎么解决\"></a>怎么解决</h4><blockquote>\n<p>在《Effective Java》这本书中也提到这个原则，float和double只能用来做科学计算或者是工程计算，在商业计算中我们要用 java.math.BigDecimal。</p>\n</blockquote>\n<p>BigDecimal适合更精度的运算，也提供了丰富的操作符类型，小数位控制，四舍五入规则等。</p>\n<p>不过，使用BigDecimal不当也有精度丢失的情况，如double的构造方法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">BigDecimal(double val)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>再来看这个示例：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void test2() &#123;\n\tdouble totalAmount &#x3D; 0.09;\n\tdouble feeAmount &#x3D; 0.02;\n\tBigDecimal tradeAmount &#x3D; new BigDecimal(totalAmount).subtract(new BigDecimal(feeAmount));\n\tSystem.out.println(tradeAmount);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0.0699999999999999962529972918900966760702431201934814453125<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这个精度就更恐怖了。。</p>\n<p>所以，一定要使用String的构造方法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">BigDecimal(String val)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void test3() &#123;\n\tdouble totalAmount &#x3D; 0.09;\n\tdouble feeAmount &#x3D; 0.02;\n\tBigDecimal tradeAmount &#x3D; new BigDecimal(String.valueOf(totalAmount))\n\t\t\t.subtract(new BigDecimal(String.valueOf(feeAmount)));\n\tSystem.out.println(tradeAmount);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ol>\n<li><p>金额运算尽量使用BigDecimal(String val)进行运算。</p>\n</li>\n<li><p>数据库存储金额，一般有整型和浮点型两种存储方式。如果是有汇率转换的，建议使用浮点数decimal进行存储，可以灵活的控制精度，decimal直接对应java类型BigDecimal。当然，用整数存储分这种形式也可以，转账的时候单位为元而如果忘了转换分为元，那就悲剧了。</p>\n</li>\n</ol>\n","excerpt":"","more":"<h4 id=\"经典的精度丢失问题\"><a href=\"#经典的精度丢失问题\" class=\"headerlink\" title=\"经典的精度丢失问题\"></a>经典的精度丢失问题</h4><p> Java中的类型float、double用来做计算会有精度丢失问题，下面来看下面的示例。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n\ttest1();\n\ttest2();\n&#125;\n\nprivate static void test1() &#123;\n\tdouble totalAmount &#x3D; 0.09;\n\tdouble feeAmount &#x3D; 0.02;\n\tdouble tradeAmount &#x3D; totalAmount - feeAmount;\n\tSystem.out.println(tradeAmount);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>上面的程序输出结果是多少？</p>\n<p>0.07？非也！</p>\n<p>正确的结果是：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0.06999999999999999<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>为什么是这样？</p>\n<p>浮点数可能丢失精度，浮点十进制数通常没有完全相同的二进制的表示形式，这是CPU所采用的浮点数据表示形式的副作用。为此，可能会有一些精度丢失，并且一些浮点运算可能会产生未知的结果。</p>\n<p>浮点运算很少是精确的，只要是超过精度能表示的范围就会产生误差。所以，在使用float、double作精确运算的时候一定要特别小心，除非能容忍精度丢失，不然产生的误差也是会造成双方对账不一致的结果。</p>\n<h4 id=\"怎么解决\"><a href=\"#怎么解决\" class=\"headerlink\" title=\"怎么解决\"></a>怎么解决</h4><blockquote>\n<p>在《Effective Java》这本书中也提到这个原则，float和double只能用来做科学计算或者是工程计算，在商业计算中我们要用 java.math.BigDecimal。</p>\n</blockquote>\n<p>BigDecimal适合更精度的运算，也提供了丰富的操作符类型，小数位控制，四舍五入规则等。</p>\n<p>不过，使用BigDecimal不当也有精度丢失的情况，如double的构造方法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">BigDecimal(double val)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>再来看这个示例：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void test2() &#123;\n\tdouble totalAmount &#x3D; 0.09;\n\tdouble feeAmount &#x3D; 0.02;\n\tBigDecimal tradeAmount &#x3D; new BigDecimal(totalAmount).subtract(new BigDecimal(feeAmount));\n\tSystem.out.println(tradeAmount);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0.0699999999999999962529972918900966760702431201934814453125<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这个精度就更恐怖了。。</p>\n<p>所以，一定要使用String的构造方法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">BigDecimal(String val)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void test3() &#123;\n\tdouble totalAmount &#x3D; 0.09;\n\tdouble feeAmount &#x3D; 0.02;\n\tBigDecimal tradeAmount &#x3D; new BigDecimal(String.valueOf(totalAmount))\n\t\t\t.subtract(new BigDecimal(String.valueOf(feeAmount)));\n\tSystem.out.println(tradeAmount);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ol>\n<li><p>金额运算尽量使用BigDecimal(String val)进行运算。</p>\n</li>\n<li><p>数据库存储金额，一般有整型和浮点型两种存储方式。如果是有汇率转换的，建议使用浮点数decimal进行存储，可以灵活的控制精度，decimal直接对应java类型BigDecimal。当然，用整数存储分这种形式也可以，转账的时候单位为元而如果忘了转换分为元，那就悲剧了。</p>\n</li>\n</ol>\n"},{"title":"面试问我 Java 逃逸分析，瞬间被秒杀了。","date":"2025-10-15T03:36:33.000Z","_content":"\n记得几年前有一次栈长去面试，问到了这么一个问题:\n\n> Java中的对象都是在堆中分配吗？说明为什么！\n\n当时我被问得一脸蒙逼，瞬间被秒杀得体无完肤，当时我压根就不知道他在考什么知识点，难道对象不是在堆中分配吗？最后就没然后了，回去等通知了。。\n\n这个面试题很经典，我最近也分享到了知识星球上面：\n\n![](http://img.javastack.cn/20190527134034.png)\n\n回答很精彩，大家可以加入一起搞技术，我现在将答案总结一下给大家。\n\n## 什么是逃逸分析？\n\n关于 Java 逃逸分析的定义：\n\n逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。\n\n逃逸分析的 JVM 参数如下：\n\n- 开启逃逸分析：-XX:+DoEscapeAnalysis\n- 关闭逃逸分析：-XX:-DoEscapeAnalysis\n- 显示分析结果：-XX:+PrintEscapeAnalysis\n\n逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数。\n\n## 逃逸分析算法\n\nJava Hotspot 编译器实现下面论文中描述的逃逸算法：\n\n```\n[Choi99] Jong-Deok Choi, Manish Gupta, Mauricio Seffano,\n          Vugranam C. Sreedhar, Sam Midkiff,\n          \"Escape Analysis for Java\", Procedings of ACM SIGPLAN\n          OOPSLA  Conference, November 1, 1999\n```\n\n根据 Jong-Deok Choi, Manish Gupta, Mauricio Seffano,Vugranam C. Sreedhar, Sam Midkiff 等大牛在论文《**Escape Analysis for Java**》中描述的算法进行逃逸分析的。\n\n该算法引入了连通图，用连通图来构建对象和对象引用之间的可达性关系，并在次基础上，提出一种组合数据流分析法。\n\n由于算法是上下文相关和流敏感的，并且模拟了对象任意层次的嵌套关系，所以分析精度较高，只是运行时间和内存消耗相对较大。 \n\n## 对象逃逸状态\n\n我们了解了 Java 中的逃逸分析技术，再来了解下一个对象的逃逸状态。\n\n#### 1、全局逃逸（GlobalEscape）\n\n即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：\n\n- 对象是一个静态变量\n- 对象是一个已经发生逃逸的对象\n- 对象作为当前方法的返回值\n\n#### 2、参数逃逸（ArgEscape）\n\n即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的。\n\n#### 3、没有逃逸\n\n即方法中的对象没有发生逃逸。\n\n## 逃逸分析优化\n\n针对上面第三点，当一个对象没有逃逸时，可以得到以下几个虚拟机的优化。\n\n**1) 锁消除**\n\n我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁。\n\n例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作。\n\n锁消除的 JVM 参数如下：\n\n- 开启锁消除：-XX:+EliminateLocks\n- 关闭锁消除：-XX:-EliminateLocks\n\n锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上。\n\n**2) 标量替换**\n\n首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象。\n\n对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。\n\n这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能。\n\n标量替换的 JVM 参数如下：\n\n- 开启标量替换：-XX:+EliminateAllocations\n- 关闭标量替换：-XX:-EliminateAllocations\n- 显示标量替换详情：-XX:+PrintEliminateAllocations\n\n标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上。\n\n**3) 栈上分配**\n\n当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能。\n\n## 总结\n\n逃逸分析讲完了，总结了不少时间，我们也应该大概知道逃逸分析是为了优化 JVM 内存和提升程序性能的。\n\n我们知道这点后，在平时开发过程中就要可尽可能的控制变量的作用范围了，变量范围越小越好，让虚拟机尽可能有优化的空间。\n\n简单举一个例子吧，如：\n\n```\nreturn sb;\n```\n\n可以改为：\n\n```\nreturn sb.toString();\n```\n\n这是一种优化案例，把 StringBuilder 变量控制在了当前方法之内，没有逃出当前方法作用域。\n\n大家还有没有别的优化经验，欢迎分享~\n\n参考资料：\n\n - https://docs.oracle.com/javase/8/docs/technotes/guides/vm/performance-enhancements-7.html#escapeAnalysis\n - https://blog.csdn.net/rickiyeat/article/details/76802085\n - https://blog.csdn.net/baichoufei90/article/details/85180478\n \n\n- 你真的搞懂 transient 关键字了吗？\n- 面试常考：Synchronized 有几种用法？\n- Java 11 已发布，String 还能这样玩！\n- Java 中的 String 真的是不可变吗？\n- sleep( ) 和 wait( ) 的这 5 个区别\n- ……\n\n\n \n","source":"_posts/进阶/面试问我 Java 逃逸分析，瞬间被秒杀了。.md","raw":"---\ntitle: 面试问我 Java 逃逸分析，瞬间被秒杀了。\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 进阶\n---\n\n记得几年前有一次栈长去面试，问到了这么一个问题:\n\n> Java中的对象都是在堆中分配吗？说明为什么！\n\n当时我被问得一脸蒙逼，瞬间被秒杀得体无完肤，当时我压根就不知道他在考什么知识点，难道对象不是在堆中分配吗？最后就没然后了，回去等通知了。。\n\n这个面试题很经典，我最近也分享到了知识星球上面：\n\n![](http://img.javastack.cn/20190527134034.png)\n\n回答很精彩，大家可以加入一起搞技术，我现在将答案总结一下给大家。\n\n## 什么是逃逸分析？\n\n关于 Java 逃逸分析的定义：\n\n逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。\n\n逃逸分析的 JVM 参数如下：\n\n- 开启逃逸分析：-XX:+DoEscapeAnalysis\n- 关闭逃逸分析：-XX:-DoEscapeAnalysis\n- 显示分析结果：-XX:+PrintEscapeAnalysis\n\n逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数。\n\n## 逃逸分析算法\n\nJava Hotspot 编译器实现下面论文中描述的逃逸算法：\n\n```\n[Choi99] Jong-Deok Choi, Manish Gupta, Mauricio Seffano,\n          Vugranam C. Sreedhar, Sam Midkiff,\n          \"Escape Analysis for Java\", Procedings of ACM SIGPLAN\n          OOPSLA  Conference, November 1, 1999\n```\n\n根据 Jong-Deok Choi, Manish Gupta, Mauricio Seffano,Vugranam C. Sreedhar, Sam Midkiff 等大牛在论文《**Escape Analysis for Java**》中描述的算法进行逃逸分析的。\n\n该算法引入了连通图，用连通图来构建对象和对象引用之间的可达性关系，并在次基础上，提出一种组合数据流分析法。\n\n由于算法是上下文相关和流敏感的，并且模拟了对象任意层次的嵌套关系，所以分析精度较高，只是运行时间和内存消耗相对较大。 \n\n## 对象逃逸状态\n\n我们了解了 Java 中的逃逸分析技术，再来了解下一个对象的逃逸状态。\n\n#### 1、全局逃逸（GlobalEscape）\n\n即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：\n\n- 对象是一个静态变量\n- 对象是一个已经发生逃逸的对象\n- 对象作为当前方法的返回值\n\n#### 2、参数逃逸（ArgEscape）\n\n即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的。\n\n#### 3、没有逃逸\n\n即方法中的对象没有发生逃逸。\n\n## 逃逸分析优化\n\n针对上面第三点，当一个对象没有逃逸时，可以得到以下几个虚拟机的优化。\n\n**1) 锁消除**\n\n我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁。\n\n例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作。\n\n锁消除的 JVM 参数如下：\n\n- 开启锁消除：-XX:+EliminateLocks\n- 关闭锁消除：-XX:-EliminateLocks\n\n锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上。\n\n**2) 标量替换**\n\n首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象。\n\n对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。\n\n这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能。\n\n标量替换的 JVM 参数如下：\n\n- 开启标量替换：-XX:+EliminateAllocations\n- 关闭标量替换：-XX:-EliminateAllocations\n- 显示标量替换详情：-XX:+PrintEliminateAllocations\n\n标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上。\n\n**3) 栈上分配**\n\n当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能。\n\n## 总结\n\n逃逸分析讲完了，总结了不少时间，我们也应该大概知道逃逸分析是为了优化 JVM 内存和提升程序性能的。\n\n我们知道这点后，在平时开发过程中就要可尽可能的控制变量的作用范围了，变量范围越小越好，让虚拟机尽可能有优化的空间。\n\n简单举一个例子吧，如：\n\n```\nreturn sb;\n```\n\n可以改为：\n\n```\nreturn sb.toString();\n```\n\n这是一种优化案例，把 StringBuilder 变量控制在了当前方法之内，没有逃出当前方法作用域。\n\n大家还有没有别的优化经验，欢迎分享~\n\n参考资料：\n\n - https://docs.oracle.com/javase/8/docs/technotes/guides/vm/performance-enhancements-7.html#escapeAnalysis\n - https://blog.csdn.net/rickiyeat/article/details/76802085\n - https://blog.csdn.net/baichoufei90/article/details/85180478\n \n\n- 你真的搞懂 transient 关键字了吗？\n- 面试常考：Synchronized 有几种用法？\n- Java 11 已发布，String 还能这样玩！\n- Java 中的 String 真的是不可变吗？\n- sleep( ) 和 wait( ) 的这 5 个区别\n- ……\n\n\n \n","slug":"进阶/面试问我 Java 逃逸分析，瞬间被秒杀了。","published":1,"updated":"2025-10-15T07:21:14.211Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076k001kqkd44fgl9hlq","content":"<p>记得几年前有一次栈长去面试，问到了这么一个问题:</p>\n<blockquote>\n<p>Java中的对象都是在堆中分配吗？说明为什么！</p>\n</blockquote>\n<p>当时我被问得一脸蒙逼，瞬间被秒杀得体无完肤，当时我压根就不知道他在考什么知识点，难道对象不是在堆中分配吗？最后就没然后了，回去等通知了。。</p>\n<p>这个面试题很经典，我最近也分享到了知识星球上面：</p>\n<p><img src=\"http://img.javastack.cn/20190527134034.png\"></p>\n<p>回答很精彩，大家可以加入一起搞技术，我现在将答案总结一下给大家。</p>\n<h2 id=\"什么是逃逸分析？\"><a href=\"#什么是逃逸分析？\" class=\"headerlink\" title=\"什么是逃逸分析？\"></a>什么是逃逸分析？</h2><p>关于 Java 逃逸分析的定义：</p>\n<p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。</p>\n<p>逃逸分析的 JVM 参数如下：</p>\n<ul>\n<li>开启逃逸分析：-XX:+DoEscapeAnalysis</li>\n<li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li>\n<li>显示分析结果：-XX:+PrintEscapeAnalysis</li>\n</ul>\n<p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数。</p>\n<h2 id=\"逃逸分析算法\"><a href=\"#逃逸分析算法\" class=\"headerlink\" title=\"逃逸分析算法\"></a>逃逸分析算法</h2><p>Java Hotspot 编译器实现下面论文中描述的逃逸算法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">[Choi99] Jong-Deok Choi, Manish Gupta, Mauricio Seffano,\n          Vugranam C. Sreedhar, Sam Midkiff,\n          &quot;Escape Analysis for Java&quot;, Procedings of ACM SIGPLAN\n          OOPSLA  Conference, November 1, 1999<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>根据 Jong-Deok Choi, Manish Gupta, Mauricio Seffano,Vugranam C. Sreedhar, Sam Midkiff 等大牛在论文《<strong>Escape Analysis for Java</strong>》中描述的算法进行逃逸分析的。</p>\n<p>该算法引入了连通图，用连通图来构建对象和对象引用之间的可达性关系，并在次基础上，提出一种组合数据流分析法。</p>\n<p>由于算法是上下文相关和流敏感的，并且模拟了对象任意层次的嵌套关系，所以分析精度较高，只是运行时间和内存消耗相对较大。 </p>\n<h2 id=\"对象逃逸状态\"><a href=\"#对象逃逸状态\" class=\"headerlink\" title=\"对象逃逸状态\"></a>对象逃逸状态</h2><p>我们了解了 Java 中的逃逸分析技术，再来了解下一个对象的逃逸状态。</p>\n<h4 id=\"1、全局逃逸（GlobalEscape）\"><a href=\"#1、全局逃逸（GlobalEscape）\" class=\"headerlink\" title=\"1、全局逃逸（GlobalEscape）\"></a>1、全局逃逸（GlobalEscape）</h4><p>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：</p>\n<ul>\n<li>对象是一个静态变量</li>\n<li>对象是一个已经发生逃逸的对象</li>\n<li>对象作为当前方法的返回值</li>\n</ul>\n<h4 id=\"2、参数逃逸（ArgEscape）\"><a href=\"#2、参数逃逸（ArgEscape）\" class=\"headerlink\" title=\"2、参数逃逸（ArgEscape）\"></a>2、参数逃逸（ArgEscape）</h4><p>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的。</p>\n<h4 id=\"3、没有逃逸\"><a href=\"#3、没有逃逸\" class=\"headerlink\" title=\"3、没有逃逸\"></a>3、没有逃逸</h4><p>即方法中的对象没有发生逃逸。</p>\n<h2 id=\"逃逸分析优化\"><a href=\"#逃逸分析优化\" class=\"headerlink\" title=\"逃逸分析优化\"></a>逃逸分析优化</h2><p>针对上面第三点，当一个对象没有逃逸时，可以得到以下几个虚拟机的优化。</p>\n<p><strong>1) 锁消除</strong></p>\n<p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁。</p>\n<p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作。</p>\n<p>锁消除的 JVM 参数如下：</p>\n<ul>\n<li>开启锁消除：-XX:+EliminateLocks</li>\n<li>关闭锁消除：-XX:-EliminateLocks</li>\n</ul>\n<p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上。</p>\n<p><strong>2) 标量替换</strong></p>\n<p>首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象。</p>\n<p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。</p>\n<p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能。</p>\n<p>标量替换的 JVM 参数如下：</p>\n<ul>\n<li>开启标量替换：-XX:+EliminateAllocations</li>\n<li>关闭标量替换：-XX:-EliminateAllocations</li>\n<li>显示标量替换详情：-XX:+PrintEliminateAllocations</li>\n</ul>\n<p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上。</p>\n<p><strong>3) 栈上分配</strong></p>\n<p>当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>逃逸分析讲完了，总结了不少时间，我们也应该大概知道逃逸分析是为了优化 JVM 内存和提升程序性能的。</p>\n<p>我们知道这点后，在平时开发过程中就要可尽可能的控制变量的作用范围了，变量范围越小越好，让虚拟机尽可能有优化的空间。</p>\n<p>简单举一个例子吧，如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">return sb;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>可以改为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">return sb.toString();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这是一种优化案例，把 StringBuilder 变量控制在了当前方法之内，没有逃出当前方法作用域。</p>\n<p>大家还有没有别的优化经验，欢迎分享~</p>\n<p>参考资料：</p>\n<ul>\n<li><p><a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/vm/performance-enhancements-7.html#escapeAnalysis\">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/performance-enhancements-7.html#escapeAnalysis</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/rickiyeat/article/details/76802085\">https://blog.csdn.net/rickiyeat/article/details/76802085</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/baichoufei90/article/details/85180478\">https://blog.csdn.net/baichoufei90/article/details/85180478</a></p>\n</li>\n<li><p>你真的搞懂 transient 关键字了吗？</p>\n</li>\n<li><p>面试常考：Synchronized 有几种用法？</p>\n</li>\n<li><p>Java 11 已发布，String 还能这样玩！</p>\n</li>\n<li><p>Java 中的 String 真的是不可变吗？</p>\n</li>\n<li><p>sleep( ) 和 wait( ) 的这 5 个区别</p>\n</li>\n<li><p>……</p>\n</li>\n</ul>\n","excerpt":"","more":"<p>记得几年前有一次栈长去面试，问到了这么一个问题:</p>\n<blockquote>\n<p>Java中的对象都是在堆中分配吗？说明为什么！</p>\n</blockquote>\n<p>当时我被问得一脸蒙逼，瞬间被秒杀得体无完肤，当时我压根就不知道他在考什么知识点，难道对象不是在堆中分配吗？最后就没然后了，回去等通知了。。</p>\n<p>这个面试题很经典，我最近也分享到了知识星球上面：</p>\n<p><img src=\"http://img.javastack.cn/20190527134034.png\"></p>\n<p>回答很精彩，大家可以加入一起搞技术，我现在将答案总结一下给大家。</p>\n<h2 id=\"什么是逃逸分析？\"><a href=\"#什么是逃逸分析？\" class=\"headerlink\" title=\"什么是逃逸分析？\"></a>什么是逃逸分析？</h2><p>关于 Java 逃逸分析的定义：</p>\n<p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。</p>\n<p>逃逸分析的 JVM 参数如下：</p>\n<ul>\n<li>开启逃逸分析：-XX:+DoEscapeAnalysis</li>\n<li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li>\n<li>显示分析结果：-XX:+PrintEscapeAnalysis</li>\n</ul>\n<p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数。</p>\n<h2 id=\"逃逸分析算法\"><a href=\"#逃逸分析算法\" class=\"headerlink\" title=\"逃逸分析算法\"></a>逃逸分析算法</h2><p>Java Hotspot 编译器实现下面论文中描述的逃逸算法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">[Choi99] Jong-Deok Choi, Manish Gupta, Mauricio Seffano,\n          Vugranam C. Sreedhar, Sam Midkiff,\n          &quot;Escape Analysis for Java&quot;, Procedings of ACM SIGPLAN\n          OOPSLA  Conference, November 1, 1999<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>根据 Jong-Deok Choi, Manish Gupta, Mauricio Seffano,Vugranam C. Sreedhar, Sam Midkiff 等大牛在论文《<strong>Escape Analysis for Java</strong>》中描述的算法进行逃逸分析的。</p>\n<p>该算法引入了连通图，用连通图来构建对象和对象引用之间的可达性关系，并在次基础上，提出一种组合数据流分析法。</p>\n<p>由于算法是上下文相关和流敏感的，并且模拟了对象任意层次的嵌套关系，所以分析精度较高，只是运行时间和内存消耗相对较大。 </p>\n<h2 id=\"对象逃逸状态\"><a href=\"#对象逃逸状态\" class=\"headerlink\" title=\"对象逃逸状态\"></a>对象逃逸状态</h2><p>我们了解了 Java 中的逃逸分析技术，再来了解下一个对象的逃逸状态。</p>\n<h4 id=\"1、全局逃逸（GlobalEscape）\"><a href=\"#1、全局逃逸（GlobalEscape）\" class=\"headerlink\" title=\"1、全局逃逸（GlobalEscape）\"></a>1、全局逃逸（GlobalEscape）</h4><p>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：</p>\n<ul>\n<li>对象是一个静态变量</li>\n<li>对象是一个已经发生逃逸的对象</li>\n<li>对象作为当前方法的返回值</li>\n</ul>\n<h4 id=\"2、参数逃逸（ArgEscape）\"><a href=\"#2、参数逃逸（ArgEscape）\" class=\"headerlink\" title=\"2、参数逃逸（ArgEscape）\"></a>2、参数逃逸（ArgEscape）</h4><p>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的。</p>\n<h4 id=\"3、没有逃逸\"><a href=\"#3、没有逃逸\" class=\"headerlink\" title=\"3、没有逃逸\"></a>3、没有逃逸</h4><p>即方法中的对象没有发生逃逸。</p>\n<h2 id=\"逃逸分析优化\"><a href=\"#逃逸分析优化\" class=\"headerlink\" title=\"逃逸分析优化\"></a>逃逸分析优化</h2><p>针对上面第三点，当一个对象没有逃逸时，可以得到以下几个虚拟机的优化。</p>\n<p><strong>1) 锁消除</strong></p>\n<p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁。</p>\n<p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作。</p>\n<p>锁消除的 JVM 参数如下：</p>\n<ul>\n<li>开启锁消除：-XX:+EliminateLocks</li>\n<li>关闭锁消除：-XX:-EliminateLocks</li>\n</ul>\n<p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上。</p>\n<p><strong>2) 标量替换</strong></p>\n<p>首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象。</p>\n<p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。</p>\n<p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能。</p>\n<p>标量替换的 JVM 参数如下：</p>\n<ul>\n<li>开启标量替换：-XX:+EliminateAllocations</li>\n<li>关闭标量替换：-XX:-EliminateAllocations</li>\n<li>显示标量替换详情：-XX:+PrintEliminateAllocations</li>\n</ul>\n<p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上。</p>\n<p><strong>3) 栈上分配</strong></p>\n<p>当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>逃逸分析讲完了，总结了不少时间，我们也应该大概知道逃逸分析是为了优化 JVM 内存和提升程序性能的。</p>\n<p>我们知道这点后，在平时开发过程中就要可尽可能的控制变量的作用范围了，变量范围越小越好，让虚拟机尽可能有优化的空间。</p>\n<p>简单举一个例子吧，如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">return sb;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>可以改为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">return sb.toString();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这是一种优化案例，把 StringBuilder 变量控制在了当前方法之内，没有逃出当前方法作用域。</p>\n<p>大家还有没有别的优化经验，欢迎分享~</p>\n<p>参考资料：</p>\n<ul>\n<li><p><a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/vm/performance-enhancements-7.html#escapeAnalysis\">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/performance-enhancements-7.html#escapeAnalysis</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/rickiyeat/article/details/76802085\">https://blog.csdn.net/rickiyeat/article/details/76802085</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/baichoufei90/article/details/85180478\">https://blog.csdn.net/baichoufei90/article/details/85180478</a></p>\n</li>\n<li><p>你真的搞懂 transient 关键字了吗？</p>\n</li>\n<li><p>面试常考：Synchronized 有几种用法？</p>\n</li>\n<li><p>Java 11 已发布，String 还能这样玩！</p>\n</li>\n<li><p>Java 中的 String 真的是不可变吗？</p>\n</li>\n<li><p>sleep( ) 和 wait( ) 的这 5 个区别</p>\n</li>\n<li><p>……</p>\n</li>\n</ul>\n"},{"title":"Java多线程join使用及原理","date":"2025-10-14T01:53:44.000Z","_content":"\n## join()\n\njoin()是线程类`Thread`的方法，官方的说明是：\n\n> Waits for this thread to die.\n\n等待这个线程结束，也就是说当前线程等待这个线程结束后再继续执行，下面来看这个示例就明白了。\n\n## 示例\n\n```\npublic static void main(String[] args) throws Exception {\n\tSystem.out.println(\"start\");\n\n\tThread t = new Thread(() -> {\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tSystem.out.println(i);\n\t\t\ttry {\n\t\t\t\tThread.sleep(500);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t});\n\tt.start();\n\tt.join();\n\n\tSystem.out.println(\"end\");\n}\n```\n\n结果输出：\n\n\n```\nstart\n0\n1\n2\n3\n4\nend\n```\n\n线程t开始后，接着加入t.join()方法，t线程里面程序在主线程end输出之前全部执行完了，说明t.join()阻塞了主线程直到t线程执行完毕。\n\n如果没有t.join()，end可能会在0~5之间输出。\n\n\n## join()原理\n\n下面是join()的源码：\n\n```\npublic final synchronized void join(long millis)\n    throws InterruptedException {\n    long base = System.currentTimeMillis();\n    long now = 0;\n\n    if (millis < 0) {\n        throw new IllegalArgumentException(\"timeout value is negative\");\n    }\n\n    if (millis == 0) {\n        while (isAlive()) {\n            wait(0);\n        }\n    } else {\n        while (isAlive()) {\n            long delay = millis - now;\n            if (delay <= 0) {\n                break;\n            }\n            wait(delay);\n            now = System.currentTimeMillis() - base;\n        }\n    }\n}\n```\n\n可以看出它是利用wait方法来实现的，上面的例子当main方法主线程调用线程t的时候，main方法获取到了t的对象锁，而t调用自身wait方法进行阻塞，只要当t结束或者到时间后才会退出，接着唤醒主线程继续执行。millis为主线程等待t线程最长执行多久，0为永久直到t线程执行结束。","source":"_posts/多线程/Java多线程join使用及原理.md","raw":"---\ntitle: Java多线程join使用及原理\ndate: 2025-10-14 09:53:44\ncategory: 后端\ntags: 多线程\n---\n\n## join()\n\njoin()是线程类`Thread`的方法，官方的说明是：\n\n> Waits for this thread to die.\n\n等待这个线程结束，也就是说当前线程等待这个线程结束后再继续执行，下面来看这个示例就明白了。\n\n## 示例\n\n```\npublic static void main(String[] args) throws Exception {\n\tSystem.out.println(\"start\");\n\n\tThread t = new Thread(() -> {\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tSystem.out.println(i);\n\t\t\ttry {\n\t\t\t\tThread.sleep(500);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t});\n\tt.start();\n\tt.join();\n\n\tSystem.out.println(\"end\");\n}\n```\n\n结果输出：\n\n\n```\nstart\n0\n1\n2\n3\n4\nend\n```\n\n线程t开始后，接着加入t.join()方法，t线程里面程序在主线程end输出之前全部执行完了，说明t.join()阻塞了主线程直到t线程执行完毕。\n\n如果没有t.join()，end可能会在0~5之间输出。\n\n\n## join()原理\n\n下面是join()的源码：\n\n```\npublic final synchronized void join(long millis)\n    throws InterruptedException {\n    long base = System.currentTimeMillis();\n    long now = 0;\n\n    if (millis < 0) {\n        throw new IllegalArgumentException(\"timeout value is negative\");\n    }\n\n    if (millis == 0) {\n        while (isAlive()) {\n            wait(0);\n        }\n    } else {\n        while (isAlive()) {\n            long delay = millis - now;\n            if (delay <= 0) {\n                break;\n            }\n            wait(delay);\n            now = System.currentTimeMillis() - base;\n        }\n    }\n}\n```\n\n可以看出它是利用wait方法来实现的，上面的例子当main方法主线程调用线程t的时候，main方法获取到了t的对象锁，而t调用自身wait方法进行阻塞，只要当t结束或者到时间后才会退出，接着唤醒主线程继续执行。millis为主线程等待t线程最长执行多久，0为永久直到t线程执行结束。","slug":"多线程/Java多线程join使用及原理","published":1,"updated":"2025-10-15T07:20:25.057Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076k001oqkd47hvn1fd4","content":"<h2 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join()\"></a>join()</h2><p>join()是线程类<code>Thread</code>的方法，官方的说明是：</p>\n<blockquote>\n<p>Waits for this thread to die.</p>\n</blockquote>\n<p>等待这个线程结束，也就是说当前线程等待这个线程结束后再继续执行，下面来看这个示例就明白了。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) throws Exception &#123;\n\tSystem.out.println(&quot;start&quot;);\n\n\tThread t &#x3D; new Thread(() -&gt; &#123;\n\t\tfor (int i &#x3D; 0; i &lt; 5; i++) &#123;\n\t\t\tSystem.out.println(i);\n\t\t\ttry &#123;\n\t\t\t\tThread.sleep(500);\n\t\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\t\te.printStackTrace();\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;);\n\tt.start();\n\tt.join();\n\n\tSystem.out.println(&quot;end&quot;);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>结果输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">start\n0\n1\n2\n3\n4\nend<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>线程t开始后，接着加入t.join()方法，t线程里面程序在主线程end输出之前全部执行完了，说明t.join()阻塞了主线程直到t线程执行完毕。</p>\n<p>如果没有t.join()，end可能会在0~5之间输出。</p>\n<h2 id=\"join-原理\"><a href=\"#join-原理\" class=\"headerlink\" title=\"join()原理\"></a>join()原理</h2><p>下面是join()的源码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public final synchronized void join(long millis)\n    throws InterruptedException &#123;\n    long base &#x3D; System.currentTimeMillis();\n    long now &#x3D; 0;\n\n    if (millis &lt; 0) &#123;\n        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);\n    &#125;\n\n    if (millis &#x3D;&#x3D; 0) &#123;\n        while (isAlive()) &#123;\n            wait(0);\n        &#125;\n    &#125; else &#123;\n        while (isAlive()) &#123;\n            long delay &#x3D; millis - now;\n            if (delay &lt;&#x3D; 0) &#123;\n                break;\n            &#125;\n            wait(delay);\n            now &#x3D; System.currentTimeMillis() - base;\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出它是利用wait方法来实现的，上面的例子当main方法主线程调用线程t的时候，main方法获取到了t的对象锁，而t调用自身wait方法进行阻塞，只要当t结束或者到时间后才会退出，接着唤醒主线程继续执行。millis为主线程等待t线程最长执行多久，0为永久直到t线程执行结束。</p>\n","excerpt":"","more":"<h2 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join()\"></a>join()</h2><p>join()是线程类<code>Thread</code>的方法，官方的说明是：</p>\n<blockquote>\n<p>Waits for this thread to die.</p>\n</blockquote>\n<p>等待这个线程结束，也就是说当前线程等待这个线程结束后再继续执行，下面来看这个示例就明白了。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) throws Exception &#123;\n\tSystem.out.println(&quot;start&quot;);\n\n\tThread t &#x3D; new Thread(() -&gt; &#123;\n\t\tfor (int i &#x3D; 0; i &lt; 5; i++) &#123;\n\t\t\tSystem.out.println(i);\n\t\t\ttry &#123;\n\t\t\t\tThread.sleep(500);\n\t\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\t\te.printStackTrace();\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;);\n\tt.start();\n\tt.join();\n\n\tSystem.out.println(&quot;end&quot;);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>结果输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">start\n0\n1\n2\n3\n4\nend<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>线程t开始后，接着加入t.join()方法，t线程里面程序在主线程end输出之前全部执行完了，说明t.join()阻塞了主线程直到t线程执行完毕。</p>\n<p>如果没有t.join()，end可能会在0~5之间输出。</p>\n<h2 id=\"join-原理\"><a href=\"#join-原理\" class=\"headerlink\" title=\"join()原理\"></a>join()原理</h2><p>下面是join()的源码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public final synchronized void join(long millis)\n    throws InterruptedException &#123;\n    long base &#x3D; System.currentTimeMillis();\n    long now &#x3D; 0;\n\n    if (millis &lt; 0) &#123;\n        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);\n    &#125;\n\n    if (millis &#x3D;&#x3D; 0) &#123;\n        while (isAlive()) &#123;\n            wait(0);\n        &#125;\n    &#125; else &#123;\n        while (isAlive()) &#123;\n            long delay &#x3D; millis - now;\n            if (delay &lt;&#x3D; 0) &#123;\n                break;\n            &#125;\n            wait(delay);\n            now &#x3D; System.currentTimeMillis() - base;\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出它是利用wait方法来实现的，上面的例子当main方法主线程调用线程t的时候，main方法获取到了t的对象锁，而t调用自身wait方法进行阻塞，只要当t结束或者到时间后才会退出，接着唤醒主线程继续执行。millis为主线程等待t线程最长执行多久，0为永久直到t线程执行结束。</p>\n"},{"title":"Java多线程可以分组还能这样玩","date":"2025-10-14T01:56:28.000Z","_content":"\n\n但如果线程很多的情况下，你知道如何对它们进行分组吗？\n\n和 Dubbo 的服务分组一样，Java 可以对相同性质的线程进行分组。\n\n来看下线程类 Thread 的所有构造方法。\n\n![](http://qianniu.javastack.cn/18-6-3/9061041.jpg)\n\n如图所示，带有 ThreadGroup 的所有线程构造方法都可以定义线程组的。\n\n线程组使用 java.lang.ThreadGroup 类定义，它有两个构造方法，第二个构造方法允许线程组有父类线程组，也就是说一个线程组可以多个子线程组。\n\n```\njava.lang.ThreadGroup#ThreadGroup(java.lang.String)\njava.lang.ThreadGroup#ThreadGroup(java.lang.ThreadGroup, java.lang.String)\n```\n\n![](http://qianniu.javastack.cn/18-6-4/38415499.jpg)\n\n线程组中比较有用的几个方法。\n\n> // 获取当前线程组内的运行线程数\n> java.lang.ThreadGroup#activeCount\n>\n> // 中断线程组内的所有线程\n> java.lang.ThreadGroup#interrupt\n>\n> // 使用 System.out 打印出所有线程信息\n> java.lang.ThreadGroup#list()\n\n我们来简单使用下线程组吧！\n\n```\n/**\n * \n */\npublic static void main(String[] args) {\n\tRunnable runnable = () -> {\n\t\tSystem.out.println(\"Java技术线程线程组名称：\" + Thread.currentThread().getThreadGroup());\n\t\tSystem.out.println(\"Java技术线程线程名称：\" + Thread.currentThread().getName());\n\t\ttry {\n\t\t\tThread.sleep(3000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t};\n\n\tThreadGroup userGroup = new ThreadGroup(\"user\");\n    userGroup.setMaxPriority(Thread.MIN_PRIORITY);\n    \n\tThread userTask1 = new Thread(userGroup, runnable, \"user-task1\");\n\tThread userTask2 = new Thread(userGroup, runnable, \"user-task2\");\n\n\tuserTask1.start();\n\tuserTask2.start();\n\n\tSystem.out.println(\"Java技术线程线程组活跃线程数：\" + userGroup.activeCount());\n\tuserGroup.list();\n\n}\n```\n\n程序输出以下结果。\n\n```\nJava技术线程线程组名称：java.lang.ThreadGroup[name=user,maxpri=1]\nJava技术线程线程名称：user-task1\nJava技术线程线程组活跃线程数：2\nJava技术线程线程组名称：java.lang.ThreadGroup[name=user,maxpri=1]\nJava技术线程线程名称：user-task2\njava.lang.ThreadGroup[name=user,maxpri=1]\n    Thread[user-task1,1,user]\n    Thread[user-task2,1,user]\n```\n\n根据示例代码和程序输出结果应该对线程组有了一个大概的了解吧。\n\n线程组还能统一设置组内所有线程的最高优先级，线程单独设置的优先级不会高于线程组设置的最大优先级。\n\n另外，线程组中有一个 stop 方法用来终止组内所有的线程，但这个方法和 Thread 中的 stop 方法一样会带来很多问题，所以它们两个现在都已经被废弃了，官方也是不建议使用了，建议使用线程中断功能进行优雅终止线程。\n\n---\n\n","source":"_posts/多线程/Java多线程可以分组还能这样玩.md","raw":"---\ntitle: Java多线程可以分组还能这样玩\ndate: 2025-10-14 09:56:28\ncategory: 后端\ntags: 多线程\n---\n\n\n但如果线程很多的情况下，你知道如何对它们进行分组吗？\n\n和 Dubbo 的服务分组一样，Java 可以对相同性质的线程进行分组。\n\n来看下线程类 Thread 的所有构造方法。\n\n![](http://qianniu.javastack.cn/18-6-3/9061041.jpg)\n\n如图所示，带有 ThreadGroup 的所有线程构造方法都可以定义线程组的。\n\n线程组使用 java.lang.ThreadGroup 类定义，它有两个构造方法，第二个构造方法允许线程组有父类线程组，也就是说一个线程组可以多个子线程组。\n\n```\njava.lang.ThreadGroup#ThreadGroup(java.lang.String)\njava.lang.ThreadGroup#ThreadGroup(java.lang.ThreadGroup, java.lang.String)\n```\n\n![](http://qianniu.javastack.cn/18-6-4/38415499.jpg)\n\n线程组中比较有用的几个方法。\n\n> // 获取当前线程组内的运行线程数\n> java.lang.ThreadGroup#activeCount\n>\n> // 中断线程组内的所有线程\n> java.lang.ThreadGroup#interrupt\n>\n> // 使用 System.out 打印出所有线程信息\n> java.lang.ThreadGroup#list()\n\n我们来简单使用下线程组吧！\n\n```\n/**\n * \n */\npublic static void main(String[] args) {\n\tRunnable runnable = () -> {\n\t\tSystem.out.println(\"Java技术线程线程组名称：\" + Thread.currentThread().getThreadGroup());\n\t\tSystem.out.println(\"Java技术线程线程名称：\" + Thread.currentThread().getName());\n\t\ttry {\n\t\t\tThread.sleep(3000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t};\n\n\tThreadGroup userGroup = new ThreadGroup(\"user\");\n    userGroup.setMaxPriority(Thread.MIN_PRIORITY);\n    \n\tThread userTask1 = new Thread(userGroup, runnable, \"user-task1\");\n\tThread userTask2 = new Thread(userGroup, runnable, \"user-task2\");\n\n\tuserTask1.start();\n\tuserTask2.start();\n\n\tSystem.out.println(\"Java技术线程线程组活跃线程数：\" + userGroup.activeCount());\n\tuserGroup.list();\n\n}\n```\n\n程序输出以下结果。\n\n```\nJava技术线程线程组名称：java.lang.ThreadGroup[name=user,maxpri=1]\nJava技术线程线程名称：user-task1\nJava技术线程线程组活跃线程数：2\nJava技术线程线程组名称：java.lang.ThreadGroup[name=user,maxpri=1]\nJava技术线程线程名称：user-task2\njava.lang.ThreadGroup[name=user,maxpri=1]\n    Thread[user-task1,1,user]\n    Thread[user-task2,1,user]\n```\n\n根据示例代码和程序输出结果应该对线程组有了一个大概的了解吧。\n\n线程组还能统一设置组内所有线程的最高优先级，线程单独设置的优先级不会高于线程组设置的最大优先级。\n\n另外，线程组中有一个 stop 方法用来终止组内所有的线程，但这个方法和 Thread 中的 stop 方法一样会带来很多问题，所以它们两个现在都已经被废弃了，官方也是不建议使用了，建议使用线程中断功能进行优雅终止线程。\n\n---\n\n","slug":"多线程/Java多线程可以分组还能这样玩","published":1,"updated":"2025-10-15T07:20:24.996Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076l001rqkd4e7k6bofk","content":"<p>但如果线程很多的情况下，你知道如何对它们进行分组吗？</p>\n<p>和 Dubbo 的服务分组一样，Java 可以对相同性质的线程进行分组。</p>\n<p>来看下线程类 Thread 的所有构造方法。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-6-3/9061041.jpg\"></p>\n<p>如图所示，带有 ThreadGroup 的所有线程构造方法都可以定义线程组的。</p>\n<p>线程组使用 java.lang.ThreadGroup 类定义，它有两个构造方法，第二个构造方法允许线程组有父类线程组，也就是说一个线程组可以多个子线程组。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">java.lang.ThreadGroup#ThreadGroup(java.lang.String)\njava.lang.ThreadGroup#ThreadGroup(java.lang.ThreadGroup, java.lang.String)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><img src=\"http://qianniu.javastack.cn/18-6-4/38415499.jpg\"></p>\n<p>线程组中比较有用的几个方法。</p>\n<blockquote>\n<p>&#x2F;&#x2F; 获取当前线程组内的运行线程数<br>java.lang.ThreadGroup#activeCount</p>\n<p>&#x2F;&#x2F; 中断线程组内的所有线程<br>java.lang.ThreadGroup#interrupt</p>\n<p>&#x2F;&#x2F; 使用 System.out 打印出所有线程信息<br>java.lang.ThreadGroup#list()</p>\n</blockquote>\n<p>我们来简单使用下线程组吧！</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n *&#x2F;\npublic static void main(String[] args) &#123;\n\tRunnable runnable &#x3D; () -&gt; &#123;\n\t\tSystem.out.println(&quot;Java技术线程线程组名称：&quot; + Thread.currentThread().getThreadGroup());\n\t\tSystem.out.println(&quot;Java技术线程线程名称：&quot; + Thread.currentThread().getName());\n\t\ttry &#123;\n\t\t\tThread.sleep(3000);\n\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;;\n\n\tThreadGroup userGroup &#x3D; new ThreadGroup(&quot;user&quot;);\n    userGroup.setMaxPriority(Thread.MIN_PRIORITY);\n    \n\tThread userTask1 &#x3D; new Thread(userGroup, runnable, &quot;user-task1&quot;);\n\tThread userTask2 &#x3D; new Thread(userGroup, runnable, &quot;user-task2&quot;);\n\n\tuserTask1.start();\n\tuserTask2.start();\n\n\tSystem.out.println(&quot;Java技术线程线程组活跃线程数：&quot; + userGroup.activeCount());\n\tuserGroup.list();\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出以下结果。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Java技术线程线程组名称：java.lang.ThreadGroup[name&#x3D;user,maxpri&#x3D;1]\nJava技术线程线程名称：user-task1\nJava技术线程线程组活跃线程数：2\nJava技术线程线程组名称：java.lang.ThreadGroup[name&#x3D;user,maxpri&#x3D;1]\nJava技术线程线程名称：user-task2\njava.lang.ThreadGroup[name&#x3D;user,maxpri&#x3D;1]\n    Thread[user-task1,1,user]\n    Thread[user-task2,1,user]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>根据示例代码和程序输出结果应该对线程组有了一个大概的了解吧。</p>\n<p>线程组还能统一设置组内所有线程的最高优先级，线程单独设置的优先级不会高于线程组设置的最大优先级。</p>\n<p>另外，线程组中有一个 stop 方法用来终止组内所有的线程，但这个方法和 Thread 中的 stop 方法一样会带来很多问题，所以它们两个现在都已经被废弃了，官方也是不建议使用了，建议使用线程中断功能进行优雅终止线程。</p>\n<hr>\n","excerpt":"","more":"<p>但如果线程很多的情况下，你知道如何对它们进行分组吗？</p>\n<p>和 Dubbo 的服务分组一样，Java 可以对相同性质的线程进行分组。</p>\n<p>来看下线程类 Thread 的所有构造方法。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-6-3/9061041.jpg\"></p>\n<p>如图所示，带有 ThreadGroup 的所有线程构造方法都可以定义线程组的。</p>\n<p>线程组使用 java.lang.ThreadGroup 类定义，它有两个构造方法，第二个构造方法允许线程组有父类线程组，也就是说一个线程组可以多个子线程组。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">java.lang.ThreadGroup#ThreadGroup(java.lang.String)\njava.lang.ThreadGroup#ThreadGroup(java.lang.ThreadGroup, java.lang.String)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><img src=\"http://qianniu.javastack.cn/18-6-4/38415499.jpg\"></p>\n<p>线程组中比较有用的几个方法。</p>\n<blockquote>\n<p>&#x2F;&#x2F; 获取当前线程组内的运行线程数<br>java.lang.ThreadGroup#activeCount</p>\n<p>&#x2F;&#x2F; 中断线程组内的所有线程<br>java.lang.ThreadGroup#interrupt</p>\n<p>&#x2F;&#x2F; 使用 System.out 打印出所有线程信息<br>java.lang.ThreadGroup#list()</p>\n</blockquote>\n<p>我们来简单使用下线程组吧！</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n *&#x2F;\npublic static void main(String[] args) &#123;\n\tRunnable runnable &#x3D; () -&gt; &#123;\n\t\tSystem.out.println(&quot;Java技术线程线程组名称：&quot; + Thread.currentThread().getThreadGroup());\n\t\tSystem.out.println(&quot;Java技术线程线程名称：&quot; + Thread.currentThread().getName());\n\t\ttry &#123;\n\t\t\tThread.sleep(3000);\n\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;;\n\n\tThreadGroup userGroup &#x3D; new ThreadGroup(&quot;user&quot;);\n    userGroup.setMaxPriority(Thread.MIN_PRIORITY);\n    \n\tThread userTask1 &#x3D; new Thread(userGroup, runnable, &quot;user-task1&quot;);\n\tThread userTask2 &#x3D; new Thread(userGroup, runnable, &quot;user-task2&quot;);\n\n\tuserTask1.start();\n\tuserTask2.start();\n\n\tSystem.out.println(&quot;Java技术线程线程组活跃线程数：&quot; + userGroup.activeCount());\n\tuserGroup.list();\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出以下结果。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Java技术线程线程组名称：java.lang.ThreadGroup[name&#x3D;user,maxpri&#x3D;1]\nJava技术线程线程名称：user-task1\nJava技术线程线程组活跃线程数：2\nJava技术线程线程组名称：java.lang.ThreadGroup[name&#x3D;user,maxpri&#x3D;1]\nJava技术线程线程名称：user-task2\njava.lang.ThreadGroup[name&#x3D;user,maxpri&#x3D;1]\n    Thread[user-task1,1,user]\n    Thread[user-task2,1,user]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>根据示例代码和程序输出结果应该对线程组有了一个大概的了解吧。</p>\n<p>线程组还能统一设置组内所有线程的最高优先级，线程单独设置的优先级不会高于线程组设置的最大优先级。</p>\n<p>另外，线程组中有一个 stop 方法用来终止组内所有的线程，但这个方法和 Thread 中的 stop 方法一样会带来很多问题，所以它们两个现在都已经被废弃了，官方也是不建议使用了，建议使用线程中断功能进行优雅终止线程。</p>\n<hr>\n"},{"title":"Java虚拟机对锁优化所做的努力","date":"2025-10-14T06:42:34.000Z","_content":"\n![](http://img.javastack.cn/18-6-10/54034705.jpg)\n\n作为一款公用平台，JDK 本身也为并发程序的性能绞尽脑汁，在 JDK 内部也想尽一切办法提供并发时的系统吞吐量。这里，我将向大家简单介绍几种 JDK 内部的 \"锁\" 优化策略。\n\n### 1、 锁偏向\n\n锁偏向是一种针对加锁操作的优化手段。\n\n如果一个线程获得了锁，那么锁就进入偏向模式。当这个线程再次请求锁时，无须再做任何同步操作。这样就节省了大量有关锁申请的操作，从而提高了程序性能。因此，对于几乎没有锁竞争的场合，偏向锁有比较红啊的优化效果，因为连续多次极有可能是同一个线程请求相同的锁。而对于锁竞争比较激烈的场合，其效果不佳。因为在竞争激烈的场合，最有可能的情况是每次都是不同的线程来请求相同的锁。\n\n### 2、 轻量级锁\n\n如果偏向锁失败，即上一个请求的锁的线程和这个线程不是同一个。偏向锁失败意味者不能避免做同步操作。此时，虚拟机并不会立即挂起线程。他会使用一种成为轻量级锁的优化手段。 轻量级锁的操作也很方便，它只是简单地将对象头部作为指针，指向蚩尤锁的线程堆栈的内部，来判断一个线程是否持有对象锁。 如果线程获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁失败，则表示其他线程抢先争夺了锁，那么当前线程的锁请求就会膨胀为重量级锁。\n\n### 3、 自选锁\n\n锁膨胀后，虚拟机为了避免线程真实地在操作系统层面挂起，虚拟机还会在做最后的努力–自选锁。由于当前线程暂时无法获得锁，但是什么时候可以获得锁是一个未知数。也许在CPU几个时钟周期后，就可以得到锁。如果这样，简单粗暴的挂起线程可能是一种得不偿失的操作，因此系统会进行一次赌注：它会假设在不久的将来，线程可以得到这把锁。因此虚拟机让当前线程做个空循环，在经过若干次循环后，如果可以得到锁，那么就顺利进入临界区。如果还不能得到锁，才会真实地将线程在操作系统层面挂起。\n\n### 4、 锁消除\n\n锁消除是一种更彻底的锁优化。Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。通过锁消除，可以节省毫无意义的请求锁时间。\n\n下面这种这种情况，我们使用vector， 而vector内部使用了synchronize请求锁。\n\n\n```\npublic String []  createStrings(){\n    Vector<String>  v= new Vector<String>();\n    for(int i=0;i<100;i++){\n        v.add(Integer.toString(i));\n    }\n    return v.toArray(new String[]{});\n}\n```\n\n由于V只在函数 createStrnigs 中使用，因此它只是一个单纯的局部变量。局部变量是在线程栈上分配的，属于线程私有额数据，因此不可能被其他线程访问。所以，在这种情况下，Vector内部所有加锁同步都是没有必要的。如果虚拟机检测到这种情况，就会将这些无用的锁操作去除。\n\n锁消除涉及的一项关键技术为逃逸分析。所谓逃逸分析就是观察某一个变量是否会逃出某一个作用域。在本例中，变量v显然没有逃出createString 函数之外。以此为基础，虚拟机才可以大胆的将v内部的加锁操作去除。如果createStrings 返回的不是String数组，而是v本身，那么就认为变量v逃逸出了当前函数，也就是说v有可能被其他线程访问。如是这样，虚拟机就不能消除v中的锁操作。\n\n逃逸分析必须在 -server 模式下进行，可以使用 -XX:DoEscapeAnalysis 参数打开逃逸分析，使用 -XX:+EliminateLocks 参数可以打开锁消除。\n\n本文摘自《Java高并发程序设计》一书。\n\n","source":"_posts/多线程/Java虚拟机对锁优化所做的努力.md","raw":"---\ntitle: Java虚拟机对锁优化所做的努力\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 多线程\n---\n\n![](http://img.javastack.cn/18-6-10/54034705.jpg)\n\n作为一款公用平台，JDK 本身也为并发程序的性能绞尽脑汁，在 JDK 内部也想尽一切办法提供并发时的系统吞吐量。这里，我将向大家简单介绍几种 JDK 内部的 \"锁\" 优化策略。\n\n### 1、 锁偏向\n\n锁偏向是一种针对加锁操作的优化手段。\n\n如果一个线程获得了锁，那么锁就进入偏向模式。当这个线程再次请求锁时，无须再做任何同步操作。这样就节省了大量有关锁申请的操作，从而提高了程序性能。因此，对于几乎没有锁竞争的场合，偏向锁有比较红啊的优化效果，因为连续多次极有可能是同一个线程请求相同的锁。而对于锁竞争比较激烈的场合，其效果不佳。因为在竞争激烈的场合，最有可能的情况是每次都是不同的线程来请求相同的锁。\n\n### 2、 轻量级锁\n\n如果偏向锁失败，即上一个请求的锁的线程和这个线程不是同一个。偏向锁失败意味者不能避免做同步操作。此时，虚拟机并不会立即挂起线程。他会使用一种成为轻量级锁的优化手段。 轻量级锁的操作也很方便，它只是简单地将对象头部作为指针，指向蚩尤锁的线程堆栈的内部，来判断一个线程是否持有对象锁。 如果线程获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁失败，则表示其他线程抢先争夺了锁，那么当前线程的锁请求就会膨胀为重量级锁。\n\n### 3、 自选锁\n\n锁膨胀后，虚拟机为了避免线程真实地在操作系统层面挂起，虚拟机还会在做最后的努力–自选锁。由于当前线程暂时无法获得锁，但是什么时候可以获得锁是一个未知数。也许在CPU几个时钟周期后，就可以得到锁。如果这样，简单粗暴的挂起线程可能是一种得不偿失的操作，因此系统会进行一次赌注：它会假设在不久的将来，线程可以得到这把锁。因此虚拟机让当前线程做个空循环，在经过若干次循环后，如果可以得到锁，那么就顺利进入临界区。如果还不能得到锁，才会真实地将线程在操作系统层面挂起。\n\n### 4、 锁消除\n\n锁消除是一种更彻底的锁优化。Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。通过锁消除，可以节省毫无意义的请求锁时间。\n\n下面这种这种情况，我们使用vector， 而vector内部使用了synchronize请求锁。\n\n\n```\npublic String []  createStrings(){\n    Vector<String>  v= new Vector<String>();\n    for(int i=0;i<100;i++){\n        v.add(Integer.toString(i));\n    }\n    return v.toArray(new String[]{});\n}\n```\n\n由于V只在函数 createStrnigs 中使用，因此它只是一个单纯的局部变量。局部变量是在线程栈上分配的，属于线程私有额数据，因此不可能被其他线程访问。所以，在这种情况下，Vector内部所有加锁同步都是没有必要的。如果虚拟机检测到这种情况，就会将这些无用的锁操作去除。\n\n锁消除涉及的一项关键技术为逃逸分析。所谓逃逸分析就是观察某一个变量是否会逃出某一个作用域。在本例中，变量v显然没有逃出createString 函数之外。以此为基础，虚拟机才可以大胆的将v内部的加锁操作去除。如果createStrings 返回的不是String数组，而是v本身，那么就认为变量v逃逸出了当前函数，也就是说v有可能被其他线程访问。如是这样，虚拟机就不能消除v中的锁操作。\n\n逃逸分析必须在 -server 模式下进行，可以使用 -XX:DoEscapeAnalysis 参数打开逃逸分析，使用 -XX:+EliminateLocks 参数可以打开锁消除。\n\n本文摘自《Java高并发程序设计》一书。\n\n","slug":"多线程/Java虚拟机对锁优化所做的努力","published":1,"updated":"2025-10-15T07:20:25.052Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076l001vqkd4706abfkz","content":"<p><img src=\"http://img.javastack.cn/18-6-10/54034705.jpg\"></p>\n<p>作为一款公用平台，JDK 本身也为并发程序的性能绞尽脑汁，在 JDK 内部也想尽一切办法提供并发时的系统吞吐量。这里，我将向大家简单介绍几种 JDK 内部的 “锁” 优化策略。</p>\n<h3 id=\"1、-锁偏向\"><a href=\"#1、-锁偏向\" class=\"headerlink\" title=\"1、 锁偏向\"></a>1、 锁偏向</h3><p>锁偏向是一种针对加锁操作的优化手段。</p>\n<p>如果一个线程获得了锁，那么锁就进入偏向模式。当这个线程再次请求锁时，无须再做任何同步操作。这样就节省了大量有关锁申请的操作，从而提高了程序性能。因此，对于几乎没有锁竞争的场合，偏向锁有比较红啊的优化效果，因为连续多次极有可能是同一个线程请求相同的锁。而对于锁竞争比较激烈的场合，其效果不佳。因为在竞争激烈的场合，最有可能的情况是每次都是不同的线程来请求相同的锁。</p>\n<h3 id=\"2、-轻量级锁\"><a href=\"#2、-轻量级锁\" class=\"headerlink\" title=\"2、 轻量级锁\"></a>2、 轻量级锁</h3><p>如果偏向锁失败，即上一个请求的锁的线程和这个线程不是同一个。偏向锁失败意味者不能避免做同步操作。此时，虚拟机并不会立即挂起线程。他会使用一种成为轻量级锁的优化手段。 轻量级锁的操作也很方便，它只是简单地将对象头部作为指针，指向蚩尤锁的线程堆栈的内部，来判断一个线程是否持有对象锁。 如果线程获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁失败，则表示其他线程抢先争夺了锁，那么当前线程的锁请求就会膨胀为重量级锁。</p>\n<h3 id=\"3、-自选锁\"><a href=\"#3、-自选锁\" class=\"headerlink\" title=\"3、 自选锁\"></a>3、 自选锁</h3><p>锁膨胀后，虚拟机为了避免线程真实地在操作系统层面挂起，虚拟机还会在做最后的努力–自选锁。由于当前线程暂时无法获得锁，但是什么时候可以获得锁是一个未知数。也许在CPU几个时钟周期后，就可以得到锁。如果这样，简单粗暴的挂起线程可能是一种得不偿失的操作，因此系统会进行一次赌注：它会假设在不久的将来，线程可以得到这把锁。因此虚拟机让当前线程做个空循环，在经过若干次循环后，如果可以得到锁，那么就顺利进入临界区。如果还不能得到锁，才会真实地将线程在操作系统层面挂起。</p>\n<h3 id=\"4、-锁消除\"><a href=\"#4、-锁消除\" class=\"headerlink\" title=\"4、 锁消除\"></a>4、 锁消除</h3><p>锁消除是一种更彻底的锁优化。Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。通过锁消除，可以节省毫无意义的请求锁时间。</p>\n<p>下面这种这种情况，我们使用vector， 而vector内部使用了synchronize请求锁。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public String []  createStrings()&#123;\n    Vector&lt;String&gt;  v&#x3D; new Vector&lt;String&gt;();\n    for(int i&#x3D;0;i&lt;100;i++)&#123;\n        v.add(Integer.toString(i));\n    &#125;\n    return v.toArray(new String[]&#123;&#125;);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>由于V只在函数 createStrnigs 中使用，因此它只是一个单纯的局部变量。局部变量是在线程栈上分配的，属于线程私有额数据，因此不可能被其他线程访问。所以，在这种情况下，Vector内部所有加锁同步都是没有必要的。如果虚拟机检测到这种情况，就会将这些无用的锁操作去除。</p>\n<p>锁消除涉及的一项关键技术为逃逸分析。所谓逃逸分析就是观察某一个变量是否会逃出某一个作用域。在本例中，变量v显然没有逃出createString 函数之外。以此为基础，虚拟机才可以大胆的将v内部的加锁操作去除。如果createStrings 返回的不是String数组，而是v本身，那么就认为变量v逃逸出了当前函数，也就是说v有可能被其他线程访问。如是这样，虚拟机就不能消除v中的锁操作。</p>\n<p>逃逸分析必须在 -server 模式下进行，可以使用 -XX:DoEscapeAnalysis 参数打开逃逸分析，使用 -XX:+EliminateLocks 参数可以打开锁消除。</p>\n<p>本文摘自《Java高并发程序设计》一书。</p>\n","excerpt":"","more":"<p><img src=\"http://img.javastack.cn/18-6-10/54034705.jpg\"></p>\n<p>作为一款公用平台，JDK 本身也为并发程序的性能绞尽脑汁，在 JDK 内部也想尽一切办法提供并发时的系统吞吐量。这里，我将向大家简单介绍几种 JDK 内部的 “锁” 优化策略。</p>\n<h3 id=\"1、-锁偏向\"><a href=\"#1、-锁偏向\" class=\"headerlink\" title=\"1、 锁偏向\"></a>1、 锁偏向</h3><p>锁偏向是一种针对加锁操作的优化手段。</p>\n<p>如果一个线程获得了锁，那么锁就进入偏向模式。当这个线程再次请求锁时，无须再做任何同步操作。这样就节省了大量有关锁申请的操作，从而提高了程序性能。因此，对于几乎没有锁竞争的场合，偏向锁有比较红啊的优化效果，因为连续多次极有可能是同一个线程请求相同的锁。而对于锁竞争比较激烈的场合，其效果不佳。因为在竞争激烈的场合，最有可能的情况是每次都是不同的线程来请求相同的锁。</p>\n<h3 id=\"2、-轻量级锁\"><a href=\"#2、-轻量级锁\" class=\"headerlink\" title=\"2、 轻量级锁\"></a>2、 轻量级锁</h3><p>如果偏向锁失败，即上一个请求的锁的线程和这个线程不是同一个。偏向锁失败意味者不能避免做同步操作。此时，虚拟机并不会立即挂起线程。他会使用一种成为轻量级锁的优化手段。 轻量级锁的操作也很方便，它只是简单地将对象头部作为指针，指向蚩尤锁的线程堆栈的内部，来判断一个线程是否持有对象锁。 如果线程获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁失败，则表示其他线程抢先争夺了锁，那么当前线程的锁请求就会膨胀为重量级锁。</p>\n<h3 id=\"3、-自选锁\"><a href=\"#3、-自选锁\" class=\"headerlink\" title=\"3、 自选锁\"></a>3、 自选锁</h3><p>锁膨胀后，虚拟机为了避免线程真实地在操作系统层面挂起，虚拟机还会在做最后的努力–自选锁。由于当前线程暂时无法获得锁，但是什么时候可以获得锁是一个未知数。也许在CPU几个时钟周期后，就可以得到锁。如果这样，简单粗暴的挂起线程可能是一种得不偿失的操作，因此系统会进行一次赌注：它会假设在不久的将来，线程可以得到这把锁。因此虚拟机让当前线程做个空循环，在经过若干次循环后，如果可以得到锁，那么就顺利进入临界区。如果还不能得到锁，才会真实地将线程在操作系统层面挂起。</p>\n<h3 id=\"4、-锁消除\"><a href=\"#4、-锁消除\" class=\"headerlink\" title=\"4、 锁消除\"></a>4、 锁消除</h3><p>锁消除是一种更彻底的锁优化。Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。通过锁消除，可以节省毫无意义的请求锁时间。</p>\n<p>下面这种这种情况，我们使用vector， 而vector内部使用了synchronize请求锁。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public String []  createStrings()&#123;\n    Vector&lt;String&gt;  v&#x3D; new Vector&lt;String&gt;();\n    for(int i&#x3D;0;i&lt;100;i++)&#123;\n        v.add(Integer.toString(i));\n    &#125;\n    return v.toArray(new String[]&#123;&#125;);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>由于V只在函数 createStrnigs 中使用，因此它只是一个单纯的局部变量。局部变量是在线程栈上分配的，属于线程私有额数据，因此不可能被其他线程访问。所以，在这种情况下，Vector内部所有加锁同步都是没有必要的。如果虚拟机检测到这种情况，就会将这些无用的锁操作去除。</p>\n<p>锁消除涉及的一项关键技术为逃逸分析。所谓逃逸分析就是观察某一个变量是否会逃出某一个作用域。在本例中，变量v显然没有逃出createString 函数之外。以此为基础，虚拟机才可以大胆的将v内部的加锁操作去除。如果createStrings 返回的不是String数组，而是v本身，那么就认为变量v逃逸出了当前函数，也就是说v有可能被其他线程访问。如是这样，虚拟机就不能消除v中的锁操作。</p>\n<p>逃逸分析必须在 -server 模式下进行，可以使用 -XX:DoEscapeAnalysis 参数打开逃逸分析，使用 -XX:+EliminateLocks 参数可以打开锁消除。</p>\n<p>本文摘自《Java高并发程序设计》一书。</p>\n"},{"title":"Synchronized 与 ReentrantLock 的区别！","date":"2025-10-14T06:42:34.000Z","_content":"**可重入性：**\n\n从名字上理解，ReenTrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程没进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。\n\n\n**锁的实现：**\n\nSynchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。\n\n\n**性能的区别：**\n\n在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。\n\n\n**功能区别：**\n\n便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。\n\n锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized\n\n\n**ReenTrantLock独有的能力：**\n\n1.ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。\n\n2.ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。\n\n3.ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。\n\n\n**ReenTrantLock实现的原理：**\n\n在网上看到相关的源码分析，本来这块应该是本文的核心，但是感觉比较复杂就不一一详解了，简单来说，ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。\n\n\n**什么情况下使用ReenTrantLock：**\n\n答案是，如果你需要实现ReenTrantLock的三个独有功能时。\n\n","source":"_posts/多线程/Synchronized 与 ReentrantLock 的区别！.md","raw":"---\ntitle: Synchronized 与 ReentrantLock 的区别！\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 多线程\n---\n**可重入性：**\n\n从名字上理解，ReenTrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程没进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。\n\n\n**锁的实现：**\n\nSynchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。\n\n\n**性能的区别：**\n\n在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。\n\n\n**功能区别：**\n\n便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。\n\n锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized\n\n\n**ReenTrantLock独有的能力：**\n\n1.ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。\n\n2.ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。\n\n3.ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。\n\n\n**ReenTrantLock实现的原理：**\n\n在网上看到相关的源码分析，本来这块应该是本文的核心，但是感觉比较复杂就不一一详解了，简单来说，ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。\n\n\n**什么情况下使用ReenTrantLock：**\n\n答案是，如果你需要实现ReenTrantLock的三个独有功能时。\n\n","slug":"多线程/Synchronized 与 ReentrantLock 的区别！","published":1,"updated":"2025-10-15T07:20:25.073Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076m001yqkd4b6j17olg","content":"<p><strong>可重入性：</strong></p>\n<p>从名字上理解，ReenTrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程没进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>\n<p><strong>锁的实现：</strong></p>\n<p>Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。</p>\n<p><strong>性能的区别：</strong></p>\n<p>在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。</p>\n<p><strong>功能区别：</strong></p>\n<p>便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。</p>\n<p>锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized</p>\n<p><strong>ReenTrantLock独有的能力：</strong></p>\n<p>1.ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</p>\n<p>2.ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</p>\n<p>3.ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。</p>\n<p><strong>ReenTrantLock实现的原理：</strong></p>\n<p>在网上看到相关的源码分析，本来这块应该是本文的核心，但是感觉比较复杂就不一一详解了，简单来说，ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。</p>\n<p><strong>什么情况下使用ReenTrantLock：</strong></p>\n<p>答案是，如果你需要实现ReenTrantLock的三个独有功能时。</p>\n","excerpt":"","more":"<p><strong>可重入性：</strong></p>\n<p>从名字上理解，ReenTrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程没进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>\n<p><strong>锁的实现：</strong></p>\n<p>Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。</p>\n<p><strong>性能的区别：</strong></p>\n<p>在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。</p>\n<p><strong>功能区别：</strong></p>\n<p>便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。</p>\n<p>锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized</p>\n<p><strong>ReenTrantLock独有的能力：</strong></p>\n<p>1.ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</p>\n<p>2.ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</p>\n<p>3.ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。</p>\n<p><strong>ReenTrantLock实现的原理：</strong></p>\n<p>在网上看到相关的源码分析，本来这块应该是本文的核心，但是感觉比较复杂就不一一详解了，简单来说，ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。</p>\n<p><strong>什么情况下使用ReenTrantLock：</strong></p>\n<p>答案是，如果你需要实现ReenTrantLock的三个独有功能时。</p>\n"},{"title":"Synchronized 有几种用法？","date":"2025-10-14T06:42:34.000Z","_content":"\n我们都知道 Synchronized 是线程安全同步用的，大部分程序可能只会用到同步方法上面。其实 Synchronized 可以用到更多的场合，栈长列举了以下几个用法。\n\n## **1、同步普通方法**\n\n这个也是我们用得最多的，只要涉及线程安全，上来就给方法来个同步锁。这种方法使用虽然最简单，但是只能作用在单例上面，如果不是单例，同步方法锁将失效。\n\n```\n/**\n * 用在普通方法\n */\nprivate synchronized void synchronizedMethod() {\n\tSystem.out.println(\"synchronizedMethod\");\n\ttry {\n\t\tThread.sleep(2000);\n\t} catch (InterruptedException e) {\n\t\te.printStackTrace();\n\t}\n}\n```\n\n此时，同一个实例只有一个线程能获取锁进入这个方法。\n\n\n## 2、同步静态方法\n\n同步静态方法，不管你有多少个类实例，同时只有一个线程能获取锁进入这个方法。\n\n```\n/**\n * 用在静态方法\n */\nprivate synchronized static void synchronizedStaticMethod() {\n\tSystem.out.println(\"synchronizedStaticMethod\");\n\ttry {\n\t\tThread.sleep(2000);\n\t} catch (InterruptedException e) {\n\t\te.printStackTrace();\n\t}\n}\n```\n\n同步静态方法是类级别的锁，一旦任何一个线程进入这个方法，其他所有线程将无法访问这个类的任何同步类锁的方法。\n\n## 3、同步类\n\n下面提供了两种同步类的方法，锁住效果和同步静态方法一样，都是类级别的锁，同时只有一个线程能访问带有同步类锁的方法。\n\n```\n/**\n * 用在类\n */\nprivate void synchronizedClass() {\n\tsynchronized (TestSynchronized.class) {\n\t\tSystem.out.println(\"synchronizedClass\");\n\t\ttry {\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\n/**\n * 用在类\n */\nprivate void synchronizedGetClass() {\n\tsynchronized (this.getClass()) {\n\t\tSystem.out.println(\"synchronizedGetClass\");\n\t\ttry {\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n这里的两种用法是同步块的用法，这里表示只有获取到这个类锁才能进入这个代码块。\n\n## 4、同步this实例\n\n这也是同步块的用法，表示锁住整个当前对象实例，只有获取到这个实例的锁才能进入这个方法。\n\n```\n/**\n * 用在this\n */\nprivate void synchronizedThis() {\n\tsynchronized (this) {\n\t\tSystem.out.println(\"synchronizedThis\");\n\t\ttry {\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n用法和同步普通方法锁一样，都是锁住整个当前实例。\n\n## 5、同步对象实例\n\n这也是同步块的用法，和上面的锁住当前实例一样，这里表示锁住整个 LOCK 对象实例，只有获取到这个 LOCK 实例的锁才能进入这个方法。\n\n```\n/**\n * 用在对象\n */\nprivate void synchronizedInstance() {\n\tsynchronized (LOCK) {\n\t\tSystem.out.println(\"synchronizedInstance\");\n\t\ttry {\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n另外，类锁与实例锁不相互阻塞，但相同的类锁，相同的当前实例锁，相同的对象锁会相互阻塞。\n\n关于 Synchronized 的几种用法栈长就介绍到这里了，如果你还知道其他的用法，欢迎留言。\n\n\n","source":"_posts/多线程/Synchronized 有几种用法？.md","raw":"---\ntitle: Synchronized 有几种用法？\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 多线程\n---\n\n我们都知道 Synchronized 是线程安全同步用的，大部分程序可能只会用到同步方法上面。其实 Synchronized 可以用到更多的场合，栈长列举了以下几个用法。\n\n## **1、同步普通方法**\n\n这个也是我们用得最多的，只要涉及线程安全，上来就给方法来个同步锁。这种方法使用虽然最简单，但是只能作用在单例上面，如果不是单例，同步方法锁将失效。\n\n```\n/**\n * 用在普通方法\n */\nprivate synchronized void synchronizedMethod() {\n\tSystem.out.println(\"synchronizedMethod\");\n\ttry {\n\t\tThread.sleep(2000);\n\t} catch (InterruptedException e) {\n\t\te.printStackTrace();\n\t}\n}\n```\n\n此时，同一个实例只有一个线程能获取锁进入这个方法。\n\n\n## 2、同步静态方法\n\n同步静态方法，不管你有多少个类实例，同时只有一个线程能获取锁进入这个方法。\n\n```\n/**\n * 用在静态方法\n */\nprivate synchronized static void synchronizedStaticMethod() {\n\tSystem.out.println(\"synchronizedStaticMethod\");\n\ttry {\n\t\tThread.sleep(2000);\n\t} catch (InterruptedException e) {\n\t\te.printStackTrace();\n\t}\n}\n```\n\n同步静态方法是类级别的锁，一旦任何一个线程进入这个方法，其他所有线程将无法访问这个类的任何同步类锁的方法。\n\n## 3、同步类\n\n下面提供了两种同步类的方法，锁住效果和同步静态方法一样，都是类级别的锁，同时只有一个线程能访问带有同步类锁的方法。\n\n```\n/**\n * 用在类\n */\nprivate void synchronizedClass() {\n\tsynchronized (TestSynchronized.class) {\n\t\tSystem.out.println(\"synchronizedClass\");\n\t\ttry {\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\n/**\n * 用在类\n */\nprivate void synchronizedGetClass() {\n\tsynchronized (this.getClass()) {\n\t\tSystem.out.println(\"synchronizedGetClass\");\n\t\ttry {\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n这里的两种用法是同步块的用法，这里表示只有获取到这个类锁才能进入这个代码块。\n\n## 4、同步this实例\n\n这也是同步块的用法，表示锁住整个当前对象实例，只有获取到这个实例的锁才能进入这个方法。\n\n```\n/**\n * 用在this\n */\nprivate void synchronizedThis() {\n\tsynchronized (this) {\n\t\tSystem.out.println(\"synchronizedThis\");\n\t\ttry {\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n用法和同步普通方法锁一样，都是锁住整个当前实例。\n\n## 5、同步对象实例\n\n这也是同步块的用法，和上面的锁住当前实例一样，这里表示锁住整个 LOCK 对象实例，只有获取到这个 LOCK 实例的锁才能进入这个方法。\n\n```\n/**\n * 用在对象\n */\nprivate void synchronizedInstance() {\n\tsynchronized (LOCK) {\n\t\tSystem.out.println(\"synchronizedInstance\");\n\t\ttry {\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n另外，类锁与实例锁不相互阻塞，但相同的类锁，相同的当前实例锁，相同的对象锁会相互阻塞。\n\n关于 Synchronized 的几种用法栈长就介绍到这里了，如果你还知道其他的用法，欢迎留言。\n\n\n","slug":"多线程/Synchronized 有几种用法？","published":1,"updated":"2025-10-15T07:20:24.976Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076m0021qkd431iqcc5g","content":"<p>我们都知道 Synchronized 是线程安全同步用的，大部分程序可能只会用到同步方法上面。其实 Synchronized 可以用到更多的场合，栈长列举了以下几个用法。</p>\n<h2 id=\"1、同步普通方法\"><a href=\"#1、同步普通方法\" class=\"headerlink\" title=\"1、同步普通方法\"></a><strong>1、同步普通方法</strong></h2><p>这个也是我们用得最多的，只要涉及线程安全，上来就给方法来个同步锁。这种方法使用虽然最简单，但是只能作用在单例上面，如果不是单例，同步方法锁将失效。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * 用在普通方法\n *&#x2F;\nprivate synchronized void synchronizedMethod() &#123;\n\tSystem.out.println(&quot;synchronizedMethod&quot;);\n\ttry &#123;\n\t\tThread.sleep(2000);\n\t&#125; catch (InterruptedException e) &#123;\n\t\te.printStackTrace();\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>此时，同一个实例只有一个线程能获取锁进入这个方法。</p>\n<h2 id=\"2、同步静态方法\"><a href=\"#2、同步静态方法\" class=\"headerlink\" title=\"2、同步静态方法\"></a>2、同步静态方法</h2><p>同步静态方法，不管你有多少个类实例，同时只有一个线程能获取锁进入这个方法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * 用在静态方法\n *&#x2F;\nprivate synchronized static void synchronizedStaticMethod() &#123;\n\tSystem.out.println(&quot;synchronizedStaticMethod&quot;);\n\ttry &#123;\n\t\tThread.sleep(2000);\n\t&#125; catch (InterruptedException e) &#123;\n\t\te.printStackTrace();\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>同步静态方法是类级别的锁，一旦任何一个线程进入这个方法，其他所有线程将无法访问这个类的任何同步类锁的方法。</p>\n<h2 id=\"3、同步类\"><a href=\"#3、同步类\" class=\"headerlink\" title=\"3、同步类\"></a>3、同步类</h2><p>下面提供了两种同步类的方法，锁住效果和同步静态方法一样，都是类级别的锁，同时只有一个线程能访问带有同步类锁的方法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * 用在类\n *&#x2F;\nprivate void synchronizedClass() &#123;\n\tsynchronized (TestSynchronized.class) &#123;\n\t\tSystem.out.println(&quot;synchronizedClass&quot;);\n\t\ttry &#123;\n\t\t\tThread.sleep(2000);\n\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n&#125;\n\n&#x2F;**\n * 用在类\n *&#x2F;\nprivate void synchronizedGetClass() &#123;\n\tsynchronized (this.getClass()) &#123;\n\t\tSystem.out.println(&quot;synchronizedGetClass&quot;);\n\t\ttry &#123;\n\t\t\tThread.sleep(2000);\n\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里的两种用法是同步块的用法，这里表示只有获取到这个类锁才能进入这个代码块。</p>\n<h2 id=\"4、同步this实例\"><a href=\"#4、同步this实例\" class=\"headerlink\" title=\"4、同步this实例\"></a>4、同步this实例</h2><p>这也是同步块的用法，表示锁住整个当前对象实例，只有获取到这个实例的锁才能进入这个方法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * 用在this\n *&#x2F;\nprivate void synchronizedThis() &#123;\n\tsynchronized (this) &#123;\n\t\tSystem.out.println(&quot;synchronizedThis&quot;);\n\t\ttry &#123;\n\t\t\tThread.sleep(2000);\n\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>用法和同步普通方法锁一样，都是锁住整个当前实例。</p>\n<h2 id=\"5、同步对象实例\"><a href=\"#5、同步对象实例\" class=\"headerlink\" title=\"5、同步对象实例\"></a>5、同步对象实例</h2><p>这也是同步块的用法，和上面的锁住当前实例一样，这里表示锁住整个 LOCK 对象实例，只有获取到这个 LOCK 实例的锁才能进入这个方法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * 用在对象\n *&#x2F;\nprivate void synchronizedInstance() &#123;\n\tsynchronized (LOCK) &#123;\n\t\tSystem.out.println(&quot;synchronizedInstance&quot;);\n\t\ttry &#123;\n\t\t\tThread.sleep(2000);\n\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>另外，类锁与实例锁不相互阻塞，但相同的类锁，相同的当前实例锁，相同的对象锁会相互阻塞。</p>\n<p>关于 Synchronized 的几种用法栈长就介绍到这里了，如果你还知道其他的用法，欢迎留言。</p>\n","excerpt":"","more":"<p>我们都知道 Synchronized 是线程安全同步用的，大部分程序可能只会用到同步方法上面。其实 Synchronized 可以用到更多的场合，栈长列举了以下几个用法。</p>\n<h2 id=\"1、同步普通方法\"><a href=\"#1、同步普通方法\" class=\"headerlink\" title=\"1、同步普通方法\"></a><strong>1、同步普通方法</strong></h2><p>这个也是我们用得最多的，只要涉及线程安全，上来就给方法来个同步锁。这种方法使用虽然最简单，但是只能作用在单例上面，如果不是单例，同步方法锁将失效。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * 用在普通方法\n *&#x2F;\nprivate synchronized void synchronizedMethod() &#123;\n\tSystem.out.println(&quot;synchronizedMethod&quot;);\n\ttry &#123;\n\t\tThread.sleep(2000);\n\t&#125; catch (InterruptedException e) &#123;\n\t\te.printStackTrace();\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>此时，同一个实例只有一个线程能获取锁进入这个方法。</p>\n<h2 id=\"2、同步静态方法\"><a href=\"#2、同步静态方法\" class=\"headerlink\" title=\"2、同步静态方法\"></a>2、同步静态方法</h2><p>同步静态方法，不管你有多少个类实例，同时只有一个线程能获取锁进入这个方法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * 用在静态方法\n *&#x2F;\nprivate synchronized static void synchronizedStaticMethod() &#123;\n\tSystem.out.println(&quot;synchronizedStaticMethod&quot;);\n\ttry &#123;\n\t\tThread.sleep(2000);\n\t&#125; catch (InterruptedException e) &#123;\n\t\te.printStackTrace();\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>同步静态方法是类级别的锁，一旦任何一个线程进入这个方法，其他所有线程将无法访问这个类的任何同步类锁的方法。</p>\n<h2 id=\"3、同步类\"><a href=\"#3、同步类\" class=\"headerlink\" title=\"3、同步类\"></a>3、同步类</h2><p>下面提供了两种同步类的方法，锁住效果和同步静态方法一样，都是类级别的锁，同时只有一个线程能访问带有同步类锁的方法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * 用在类\n *&#x2F;\nprivate void synchronizedClass() &#123;\n\tsynchronized (TestSynchronized.class) &#123;\n\t\tSystem.out.println(&quot;synchronizedClass&quot;);\n\t\ttry &#123;\n\t\t\tThread.sleep(2000);\n\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n&#125;\n\n&#x2F;**\n * 用在类\n *&#x2F;\nprivate void synchronizedGetClass() &#123;\n\tsynchronized (this.getClass()) &#123;\n\t\tSystem.out.println(&quot;synchronizedGetClass&quot;);\n\t\ttry &#123;\n\t\t\tThread.sleep(2000);\n\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里的两种用法是同步块的用法，这里表示只有获取到这个类锁才能进入这个代码块。</p>\n<h2 id=\"4、同步this实例\"><a href=\"#4、同步this实例\" class=\"headerlink\" title=\"4、同步this实例\"></a>4、同步this实例</h2><p>这也是同步块的用法，表示锁住整个当前对象实例，只有获取到这个实例的锁才能进入这个方法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * 用在this\n *&#x2F;\nprivate void synchronizedThis() &#123;\n\tsynchronized (this) &#123;\n\t\tSystem.out.println(&quot;synchronizedThis&quot;);\n\t\ttry &#123;\n\t\t\tThread.sleep(2000);\n\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>用法和同步普通方法锁一样，都是锁住整个当前实例。</p>\n<h2 id=\"5、同步对象实例\"><a href=\"#5、同步对象实例\" class=\"headerlink\" title=\"5、同步对象实例\"></a>5、同步对象实例</h2><p>这也是同步块的用法，和上面的锁住当前实例一样，这里表示锁住整个 LOCK 对象实例，只有获取到这个 LOCK 实例的锁才能进入这个方法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * 用在对象\n *&#x2F;\nprivate void synchronizedInstance() &#123;\n\tsynchronized (LOCK) &#123;\n\t\tSystem.out.println(&quot;synchronizedInstance&quot;);\n\t\ttry &#123;\n\t\t\tThread.sleep(2000);\n\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>另外，类锁与实例锁不相互阻塞，但相同的类锁，相同的当前实例锁，相同的对象锁会相互阻塞。</p>\n<p>关于 Synchronized 的几种用法栈长就介绍到这里了，如果你还知道其他的用法，欢迎留言。</p>\n"},{"title":"i++是线程安全的吗?","date":"2025-10-14T01:33:33.000Z","_content":"\n![](http://img.javastack.cn/18-6-8/12258861.jpg)\n\n**i++ 是线程安全的吗？**\n\n相信很多中高级的 Java 面试者都遇到过这个问题，很多对这个不是很清楚的肯定是一脸蒙逼。内心肯定还在质疑，i++ 居然还有线程安全问题？只能说自己了解的不够多，自己的水平有限。\n\n先来看下面的示例来验证下 i++ 到底是不是线程安全的。\n\n**1000个线程，每个线程对共享变量 count 进行 1000 次 ++ 操作。**\n\n```\nstatic int count = 0;\n\nstatic CountDownLatch cdl = new CountDownLatch(1000);\n\n/**\n* \n*/\npublic static void main(String[] args) throws Exception {\n\tCountRunnable countRunnable = new CountRunnable();\n\tfor (int i = 0; i < 1000; i++) {\n\t\tnew Thread(countRunnable).start();\n\t}\n\tcdl.await();\n\tSystem.out.println(count);\n}\n\nstatic class CountRunnable implements Runnable {\n\n\tprivate void count() {\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tcount++;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tcount();\n\t\tcdl.countDown();\n\t}\n\n}\n```\n\n上面的例子我们期望的结果应该是 1000000，但运行 N 遍，你会发现总是不为 1000000，至少你现在知道了 i++ 操作它不是线程安全的了。\n\n先来看 JMM 模型中对共享变量的读写原理吧。\n\n![](http://img.javastack.cn/18-6-8/60972585.jpg)\n\n每个线程都有自己的工作内存，每个线程需要对共享变量操作时必须先把共享变量从主内存 load 到自己的工作内存，等完成对共享变量的操作时再 save 到主内存。\n\n问题就出在这了，如果一个线程运算完后还没刷到主内存，此时这个共享变量的值被另外一个线程从主内存读取到了，这个时候读取的数据就是脏数据了，它会覆盖其他线程计算完的值。。。\n\n**这也是经典的内存不可见问题，那么把 count 加上 volatile 让内存可见是否能解决这个问题呢？** 答案是：不能。因为 volatile 只能保证可见性，不能保证原子性。多个线程同时读取这个共享变量的值，就算保证其他线程修改的可见性，也不能保证线程之间读取到同样的值然后相互覆盖对方的值的情况。\n\n关于多线程的几种关键概念请翻阅《[多线程之原子性、可见性、有序性详解](https://mp.weixin.qq.com/s/DWaxnysIQ8NSWN1NME_HvA)》这篇文章。\n\n#### 解决方案\n\n说了这么多，对于 i++ 这种线程不安全问题有没有其他解决方案呢？当然有，请参考以下几种解决方案。\n\n1、对 i++ 操作的方法加同步锁，同时只能有一个线程执行 i++ 操作；\n\n2、使用支持原子性操作的类，如 `java.util.concurrent.atomic.AtomicInteger`，它使用的是 CAS 算法，效率优于第 1 种；\n\n如果对你有帮助，点个赞分享下给个鼓励吧！\n","source":"_posts/多线程/i++是线程安全的吗？.md","raw":"---\ntitle: i++是线程安全的吗?\ndate: 2025-10-14 09:33:33\ncategory: 后端\ntags: 多线程\n---\n\n![](http://img.javastack.cn/18-6-8/12258861.jpg)\n\n**i++ 是线程安全的吗？**\n\n相信很多中高级的 Java 面试者都遇到过这个问题，很多对这个不是很清楚的肯定是一脸蒙逼。内心肯定还在质疑，i++ 居然还有线程安全问题？只能说自己了解的不够多，自己的水平有限。\n\n先来看下面的示例来验证下 i++ 到底是不是线程安全的。\n\n**1000个线程，每个线程对共享变量 count 进行 1000 次 ++ 操作。**\n\n```\nstatic int count = 0;\n\nstatic CountDownLatch cdl = new CountDownLatch(1000);\n\n/**\n* \n*/\npublic static void main(String[] args) throws Exception {\n\tCountRunnable countRunnable = new CountRunnable();\n\tfor (int i = 0; i < 1000; i++) {\n\t\tnew Thread(countRunnable).start();\n\t}\n\tcdl.await();\n\tSystem.out.println(count);\n}\n\nstatic class CountRunnable implements Runnable {\n\n\tprivate void count() {\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tcount++;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tcount();\n\t\tcdl.countDown();\n\t}\n\n}\n```\n\n上面的例子我们期望的结果应该是 1000000，但运行 N 遍，你会发现总是不为 1000000，至少你现在知道了 i++ 操作它不是线程安全的了。\n\n先来看 JMM 模型中对共享变量的读写原理吧。\n\n![](http://img.javastack.cn/18-6-8/60972585.jpg)\n\n每个线程都有自己的工作内存，每个线程需要对共享变量操作时必须先把共享变量从主内存 load 到自己的工作内存，等完成对共享变量的操作时再 save 到主内存。\n\n问题就出在这了，如果一个线程运算完后还没刷到主内存，此时这个共享变量的值被另外一个线程从主内存读取到了，这个时候读取的数据就是脏数据了，它会覆盖其他线程计算完的值。。。\n\n**这也是经典的内存不可见问题，那么把 count 加上 volatile 让内存可见是否能解决这个问题呢？** 答案是：不能。因为 volatile 只能保证可见性，不能保证原子性。多个线程同时读取这个共享变量的值，就算保证其他线程修改的可见性，也不能保证线程之间读取到同样的值然后相互覆盖对方的值的情况。\n\n关于多线程的几种关键概念请翻阅《[多线程之原子性、可见性、有序性详解](https://mp.weixin.qq.com/s/DWaxnysIQ8NSWN1NME_HvA)》这篇文章。\n\n#### 解决方案\n\n说了这么多，对于 i++ 这种线程不安全问题有没有其他解决方案呢？当然有，请参考以下几种解决方案。\n\n1、对 i++ 操作的方法加同步锁，同时只能有一个线程执行 i++ 操作；\n\n2、使用支持原子性操作的类，如 `java.util.concurrent.atomic.AtomicInteger`，它使用的是 CAS 算法，效率优于第 1 种；\n\n如果对你有帮助，点个赞分享下给个鼓励吧！\n","slug":"多线程/i++是线程安全的吗？","published":1,"updated":"2025-10-15T07:20:25.069Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076n0025qkd40r4ecb2t","content":"<p><img src=\"http://img.javastack.cn/18-6-8/12258861.jpg\"></p>\n<p><strong>i++ 是线程安全的吗？</strong></p>\n<p>相信很多中高级的 Java 面试者都遇到过这个问题，很多对这个不是很清楚的肯定是一脸蒙逼。内心肯定还在质疑，i++ 居然还有线程安全问题？只能说自己了解的不够多，自己的水平有限。</p>\n<p>先来看下面的示例来验证下 i++ 到底是不是线程安全的。</p>\n<p><strong>1000个线程，每个线程对共享变量 count 进行 1000 次 ++ 操作。</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">static int count &#x3D; 0;\n\nstatic CountDownLatch cdl &#x3D; new CountDownLatch(1000);\n\n&#x2F;**\n* \n*&#x2F;\npublic static void main(String[] args) throws Exception &#123;\n\tCountRunnable countRunnable &#x3D; new CountRunnable();\n\tfor (int i &#x3D; 0; i &lt; 1000; i++) &#123;\n\t\tnew Thread(countRunnable).start();\n\t&#125;\n\tcdl.await();\n\tSystem.out.println(count);\n&#125;\n\nstatic class CountRunnable implements Runnable &#123;\n\n\tprivate void count() &#123;\n\t\tfor (int i &#x3D; 0; i &lt; 1000; i++) &#123;\n\t\t\tcount++;\n\t\t&#125;\n\t&#125;\n\n\t@Override\n\tpublic void run() &#123;\n\t\tcount();\n\t\tcdl.countDown();\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>上面的例子我们期望的结果应该是 1000000，但运行 N 遍，你会发现总是不为 1000000，至少你现在知道了 i++ 操作它不是线程安全的了。</p>\n<p>先来看 JMM 模型中对共享变量的读写原理吧。</p>\n<p><img src=\"http://img.javastack.cn/18-6-8/60972585.jpg\"></p>\n<p>每个线程都有自己的工作内存，每个线程需要对共享变量操作时必须先把共享变量从主内存 load 到自己的工作内存，等完成对共享变量的操作时再 save 到主内存。</p>\n<p>问题就出在这了，如果一个线程运算完后还没刷到主内存，此时这个共享变量的值被另外一个线程从主内存读取到了，这个时候读取的数据就是脏数据了，它会覆盖其他线程计算完的值。。。</p>\n<p><strong>这也是经典的内存不可见问题，那么把 count 加上 volatile 让内存可见是否能解决这个问题呢？</strong> 答案是：不能。因为 volatile 只能保证可见性，不能保证原子性。多个线程同时读取这个共享变量的值，就算保证其他线程修改的可见性，也不能保证线程之间读取到同样的值然后相互覆盖对方的值的情况。</p>\n<p>关于多线程的几种关键概念请翻阅《<a href=\"https://mp.weixin.qq.com/s/DWaxnysIQ8NSWN1NME_HvA\">多线程之原子性、可见性、有序性详解</a>》这篇文章。</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>说了这么多，对于 i++ 这种线程不安全问题有没有其他解决方案呢？当然有，请参考以下几种解决方案。</p>\n<p>1、对 i++ 操作的方法加同步锁，同时只能有一个线程执行 i++ 操作；</p>\n<p>2、使用支持原子性操作的类，如 <code>java.util.concurrent.atomic.AtomicInteger</code>，它使用的是 CAS 算法，效率优于第 1 种；</p>\n<p>如果对你有帮助，点个赞分享下给个鼓励吧！</p>\n","excerpt":"","more":"<p><img src=\"http://img.javastack.cn/18-6-8/12258861.jpg\"></p>\n<p><strong>i++ 是线程安全的吗？</strong></p>\n<p>相信很多中高级的 Java 面试者都遇到过这个问题，很多对这个不是很清楚的肯定是一脸蒙逼。内心肯定还在质疑，i++ 居然还有线程安全问题？只能说自己了解的不够多，自己的水平有限。</p>\n<p>先来看下面的示例来验证下 i++ 到底是不是线程安全的。</p>\n<p><strong>1000个线程，每个线程对共享变量 count 进行 1000 次 ++ 操作。</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">static int count &#x3D; 0;\n\nstatic CountDownLatch cdl &#x3D; new CountDownLatch(1000);\n\n&#x2F;**\n* \n*&#x2F;\npublic static void main(String[] args) throws Exception &#123;\n\tCountRunnable countRunnable &#x3D; new CountRunnable();\n\tfor (int i &#x3D; 0; i &lt; 1000; i++) &#123;\n\t\tnew Thread(countRunnable).start();\n\t&#125;\n\tcdl.await();\n\tSystem.out.println(count);\n&#125;\n\nstatic class CountRunnable implements Runnable &#123;\n\n\tprivate void count() &#123;\n\t\tfor (int i &#x3D; 0; i &lt; 1000; i++) &#123;\n\t\t\tcount++;\n\t\t&#125;\n\t&#125;\n\n\t@Override\n\tpublic void run() &#123;\n\t\tcount();\n\t\tcdl.countDown();\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>上面的例子我们期望的结果应该是 1000000，但运行 N 遍，你会发现总是不为 1000000，至少你现在知道了 i++ 操作它不是线程安全的了。</p>\n<p>先来看 JMM 模型中对共享变量的读写原理吧。</p>\n<p><img src=\"http://img.javastack.cn/18-6-8/60972585.jpg\"></p>\n<p>每个线程都有自己的工作内存，每个线程需要对共享变量操作时必须先把共享变量从主内存 load 到自己的工作内存，等完成对共享变量的操作时再 save 到主内存。</p>\n<p>问题就出在这了，如果一个线程运算完后还没刷到主内存，此时这个共享变量的值被另外一个线程从主内存读取到了，这个时候读取的数据就是脏数据了，它会覆盖其他线程计算完的值。。。</p>\n<p><strong>这也是经典的内存不可见问题，那么把 count 加上 volatile 让内存可见是否能解决这个问题呢？</strong> 答案是：不能。因为 volatile 只能保证可见性，不能保证原子性。多个线程同时读取这个共享变量的值，就算保证其他线程修改的可见性，也不能保证线程之间读取到同样的值然后相互覆盖对方的值的情况。</p>\n<p>关于多线程的几种关键概念请翻阅《<a href=\"https://mp.weixin.qq.com/s/DWaxnysIQ8NSWN1NME_HvA\">多线程之原子性、可见性、有序性详解</a>》这篇文章。</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>说了这么多，对于 i++ 这种线程不安全问题有没有其他解决方案呢？当然有，请参考以下几种解决方案。</p>\n<p>1、对 i++ 操作的方法加同步锁，同时只能有一个线程执行 i++ 操作；</p>\n<p>2、使用支持原子性操作的类，如 <code>java.util.concurrent.atomic.AtomicInteger</code>，它使用的是 CAS 算法，效率优于第 1 种；</p>\n<p>如果对你有帮助，点个赞分享下给个鼓励吧！</p>\n"},{"title":"sleep( )和wait( )的这5个区别，你知道几个？","date":"2025-10-14T06:42:34.000Z","_content":"\nsleep(休眠) 和 wait(等待) 方法是 Java 多线程中常用的两个方法，它们有什么区别及一些该注意的地方有哪些呢？下面给大家一一分解。\n\n在之前的文章《[Java多线程神器：join使用及原理](https://mp.weixin.qq.com/s/at8NynjnYvqkFw61kn3Apg)》介绍了，它其实用的是 wait 实现的线程等待。\n\n#### 区别1：使用限制\n\n使用 sleep 方法可以让让当前线程休眠，时间一到当前线程继续往下执行，在任何地方都能使用，但需要捕获 InterruptedException 异常。\n\n```\ntry {\n\tThread.sleep(3000L);\n} catch (InterruptedException e) {\n\te.printStackTrace();\n}\n```\n\n而使用 wait 方法则必须放在 synchronized 块里面，同样需要捕获 InterruptedException 异常，并且需要获取对象的锁。\n\n```\nsynchronized (lock){\n    try {\n        lock.wait();\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n而且 wait 还需要额外的方法 notify/ notifyAll 进行唤醒，它们同样需要放在 synchronized 块里面，且获取对象的锁。。\n\n\n```\nsynchronized (lock) {\n    // 随机唤醒\n    lock.notify();\n    \n    // 唤醒全部\n    lock.notifyAll();\n}\n```\n\n当然也可以使用带时间的 wait(long millis) 方法，时间一到，无需其他线程唤醒，也会重新竞争获取对象的锁继续执行。\n\n#### 区别2：使用场景\n\nsleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。\n\n#### 区别3：所属类\n\nsleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。\n\n> java.lang.Thread#sleep\n\n```\npublic static native void sleep(long millis) throws InterruptedException;\n```\n\n> java.lang.Object#wait\n\n```\npublic final native void wait(long timeout) throws InterruptedException;\n```\n\n**为什么要这样设计呢？**\n\n因为 sleep 是让当前线程休眠，不涉及到对象类，也不需要获得对象的锁，所以是线程类的方法。wait 是让获得对象锁的线程实现等待，前提是要楚获得对象的锁，所以是类的方法。\n\n#### 区别4：释放锁\n\n\n```\nObject lock = new Object();\nsynchronized (lock) {\n    try {\n        lock.wait(3000L);\n        Thread.sleep(2000L);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n如上代码所示，wait 可以释放当前线程对 lock 对象锁的持有，而 sleep 则不会。\n\n#### 区别5：线程切换\n\nsleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。\n\n@程序猿 你们还知道别的吗？欢迎留言！\n","source":"_posts/多线程/sleep( )和wait( )的这5个区别，你知道几个？.md","raw":"---\ntitle: sleep( )和wait( )的这5个区别，你知道几个？\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 多线程\n---\n\nsleep(休眠) 和 wait(等待) 方法是 Java 多线程中常用的两个方法，它们有什么区别及一些该注意的地方有哪些呢？下面给大家一一分解。\n\n在之前的文章《[Java多线程神器：join使用及原理](https://mp.weixin.qq.com/s/at8NynjnYvqkFw61kn3Apg)》介绍了，它其实用的是 wait 实现的线程等待。\n\n#### 区别1：使用限制\n\n使用 sleep 方法可以让让当前线程休眠，时间一到当前线程继续往下执行，在任何地方都能使用，但需要捕获 InterruptedException 异常。\n\n```\ntry {\n\tThread.sleep(3000L);\n} catch (InterruptedException e) {\n\te.printStackTrace();\n}\n```\n\n而使用 wait 方法则必须放在 synchronized 块里面，同样需要捕获 InterruptedException 异常，并且需要获取对象的锁。\n\n```\nsynchronized (lock){\n    try {\n        lock.wait();\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n而且 wait 还需要额外的方法 notify/ notifyAll 进行唤醒，它们同样需要放在 synchronized 块里面，且获取对象的锁。。\n\n\n```\nsynchronized (lock) {\n    // 随机唤醒\n    lock.notify();\n    \n    // 唤醒全部\n    lock.notifyAll();\n}\n```\n\n当然也可以使用带时间的 wait(long millis) 方法，时间一到，无需其他线程唤醒，也会重新竞争获取对象的锁继续执行。\n\n#### 区别2：使用场景\n\nsleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。\n\n#### 区别3：所属类\n\nsleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。\n\n> java.lang.Thread#sleep\n\n```\npublic static native void sleep(long millis) throws InterruptedException;\n```\n\n> java.lang.Object#wait\n\n```\npublic final native void wait(long timeout) throws InterruptedException;\n```\n\n**为什么要这样设计呢？**\n\n因为 sleep 是让当前线程休眠，不涉及到对象类，也不需要获得对象的锁，所以是线程类的方法。wait 是让获得对象锁的线程实现等待，前提是要楚获得对象的锁，所以是类的方法。\n\n#### 区别4：释放锁\n\n\n```\nObject lock = new Object();\nsynchronized (lock) {\n    try {\n        lock.wait(3000L);\n        Thread.sleep(2000L);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n如上代码所示，wait 可以释放当前线程对 lock 对象锁的持有，而 sleep 则不会。\n\n#### 区别5：线程切换\n\nsleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。\n\n@程序猿 你们还知道别的吗？欢迎留言！\n","slug":"多线程/sleep( )和wait( )的这5个区别，你知道几个？","published":1,"updated":"2025-10-15T07:20:25.001Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076n0028qkd42e5y8lqn","content":"<p>sleep(休眠) 和 wait(等待) 方法是 Java 多线程中常用的两个方法，它们有什么区别及一些该注意的地方有哪些呢？下面给大家一一分解。</p>\n<p>在之前的文章《<a href=\"https://mp.weixin.qq.com/s/at8NynjnYvqkFw61kn3Apg\">Java多线程神器：join使用及原理</a>》介绍了，它其实用的是 wait 实现的线程等待。</p>\n<h4 id=\"区别1：使用限制\"><a href=\"#区别1：使用限制\" class=\"headerlink\" title=\"区别1：使用限制\"></a>区别1：使用限制</h4><p>使用 sleep 方法可以让让当前线程休眠，时间一到当前线程继续往下执行，在任何地方都能使用，但需要捕获 InterruptedException 异常。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">try &#123;\n\tThread.sleep(3000L);\n&#125; catch (InterruptedException e) &#123;\n\te.printStackTrace();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>而使用 wait 方法则必须放在 synchronized 块里面，同样需要捕获 InterruptedException 异常，并且需要获取对象的锁。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">synchronized (lock)&#123;\n    try &#123;\n        lock.wait();\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>而且 wait 还需要额外的方法 notify&#x2F; notifyAll 进行唤醒，它们同样需要放在 synchronized 块里面，且获取对象的锁。。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">synchronized (lock) &#123;\n    &#x2F;&#x2F; 随机唤醒\n    lock.notify();\n    \n    &#x2F;&#x2F; 唤醒全部\n    lock.notifyAll();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当然也可以使用带时间的 wait(long millis) 方法，时间一到，无需其他线程唤醒，也会重新竞争获取对象的锁继续执行。</p>\n<h4 id=\"区别2：使用场景\"><a href=\"#区别2：使用场景\" class=\"headerlink\" title=\"区别2：使用场景\"></a>区别2：使用场景</h4><p>sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。</p>\n<h4 id=\"区别3：所属类\"><a href=\"#区别3：所属类\" class=\"headerlink\" title=\"区别3：所属类\"></a>区别3：所属类</h4><p>sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。</p>\n<blockquote>\n<p>java.lang.Thread#sleep</p>\n</blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static native void sleep(long millis) throws InterruptedException;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<blockquote>\n<p>java.lang.Object#wait</p>\n</blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public final native void wait(long timeout) throws InterruptedException;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><strong>为什么要这样设计呢？</strong></p>\n<p>因为 sleep 是让当前线程休眠，不涉及到对象类，也不需要获得对象的锁，所以是线程类的方法。wait 是让获得对象锁的线程实现等待，前提是要楚获得对象的锁，所以是类的方法。</p>\n<h4 id=\"区别4：释放锁\"><a href=\"#区别4：释放锁\" class=\"headerlink\" title=\"区别4：释放锁\"></a>区别4：释放锁</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">Object lock &#x3D; new Object();\nsynchronized (lock) &#123;\n    try &#123;\n        lock.wait(3000L);\n        Thread.sleep(2000L);\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如上代码所示，wait 可以释放当前线程对 lock 对象锁的持有，而 sleep 则不会。</p>\n<h4 id=\"区别5：线程切换\"><a href=\"#区别5：线程切换\" class=\"headerlink\" title=\"区别5：线程切换\"></a>区别5：线程切换</h4><p>sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。</p>\n<p>@程序猿 你们还知道别的吗？欢迎留言！</p>\n","excerpt":"","more":"<p>sleep(休眠) 和 wait(等待) 方法是 Java 多线程中常用的两个方法，它们有什么区别及一些该注意的地方有哪些呢？下面给大家一一分解。</p>\n<p>在之前的文章《<a href=\"https://mp.weixin.qq.com/s/at8NynjnYvqkFw61kn3Apg\">Java多线程神器：join使用及原理</a>》介绍了，它其实用的是 wait 实现的线程等待。</p>\n<h4 id=\"区别1：使用限制\"><a href=\"#区别1：使用限制\" class=\"headerlink\" title=\"区别1：使用限制\"></a>区别1：使用限制</h4><p>使用 sleep 方法可以让让当前线程休眠，时间一到当前线程继续往下执行，在任何地方都能使用，但需要捕获 InterruptedException 异常。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">try &#123;\n\tThread.sleep(3000L);\n&#125; catch (InterruptedException e) &#123;\n\te.printStackTrace();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>而使用 wait 方法则必须放在 synchronized 块里面，同样需要捕获 InterruptedException 异常，并且需要获取对象的锁。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">synchronized (lock)&#123;\n    try &#123;\n        lock.wait();\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>而且 wait 还需要额外的方法 notify&#x2F; notifyAll 进行唤醒，它们同样需要放在 synchronized 块里面，且获取对象的锁。。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">synchronized (lock) &#123;\n    &#x2F;&#x2F; 随机唤醒\n    lock.notify();\n    \n    &#x2F;&#x2F; 唤醒全部\n    lock.notifyAll();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当然也可以使用带时间的 wait(long millis) 方法，时间一到，无需其他线程唤醒，也会重新竞争获取对象的锁继续执行。</p>\n<h4 id=\"区别2：使用场景\"><a href=\"#区别2：使用场景\" class=\"headerlink\" title=\"区别2：使用场景\"></a>区别2：使用场景</h4><p>sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。</p>\n<h4 id=\"区别3：所属类\"><a href=\"#区别3：所属类\" class=\"headerlink\" title=\"区别3：所属类\"></a>区别3：所属类</h4><p>sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。</p>\n<blockquote>\n<p>java.lang.Thread#sleep</p>\n</blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static native void sleep(long millis) throws InterruptedException;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<blockquote>\n<p>java.lang.Object#wait</p>\n</blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public final native void wait(long timeout) throws InterruptedException;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><strong>为什么要这样设计呢？</strong></p>\n<p>因为 sleep 是让当前线程休眠，不涉及到对象类，也不需要获得对象的锁，所以是线程类的方法。wait 是让获得对象锁的线程实现等待，前提是要楚获得对象的锁，所以是类的方法。</p>\n<h4 id=\"区别4：释放锁\"><a href=\"#区别4：释放锁\" class=\"headerlink\" title=\"区别4：释放锁\"></a>区别4：释放锁</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">Object lock &#x3D; new Object();\nsynchronized (lock) &#123;\n    try &#123;\n        lock.wait(3000L);\n        Thread.sleep(2000L);\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如上代码所示，wait 可以释放当前线程对 lock 对象锁的持有，而 sleep 则不会。</p>\n<h4 id=\"区别5：线程切换\"><a href=\"#区别5：线程切换\" class=\"headerlink\" title=\"区别5：线程切换\"></a>区别5：线程切换</h4><p>sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。</p>\n<p>@程序猿 你们还知道别的吗？欢迎留言！</p>\n"},{"title":"一文搞懂 Java 线程中断","date":"2025-10-14T06:42:34.000Z","_content":"\n```\ntry {\n\tThread.sleep(3000);\n} catch (InterruptedException e) {\n\te.printStackTrace();\n}\n```\n\n此时线程被打断后，代码会继续运行或者抛出异常结束运行，这并不是我们需要的中断线程的作用。\n\n#### 到底是什么是线程中断？\n\n线程中断即线程运行过程中被其他线程给打断了，它与 stop 最大的区别是：stop 是由系统强制终止线程，而线程中断则是给目标线程发送一个中断信号，如果目标线程没有接收线程中断的信号并结束线程，线程则不会终止，具体是否退出或者执行其他逻辑由目标线程决定。\n\n我们来看下线程中断最重要的 3 个方法，它们都是来自 Thread 类！\n\n**1、java.lang.Thread#interrupt**\n\n中断目标线程，给目标线程发一个中断信号，线程被打上中断标记。\n\n**2、java.lang.Thread#isInterrupted()**\n\n判断目标线程是否被中断，不会清除中断标记。\n\n**3、java.lang.Thread#interrupted**\n\n判断目标线程是否被中断，会清除中断标记。\n\n#### 线程中断实战\n\n我们来实例演示下线程中断如何用！\n\n**示例1（中断失败）**\n\n```\n/**\n * \n */\nprivate static void test1() {\n\tThread thread = new Thread(() -> {\n\t\twhile (true) {\n\t\t\tThread.yield();\n\t\t}\n\t});\n\tthread.start();\n\tthread.interrupt();\n}\n```\n\n请问示例1中的线程会被中断吗？答案：不会，因为虽然给线程发出了中断信号，但程序中并没有响应中断信号的逻辑，所以程序不会有任何反应。\n\n**示例2：（中断成功）**\n\n```\n/**\n * \n */\nprivate static void test2() {\n\tThread thread = new Thread(() -> {\n\t\twhile (true) {\n\t\t\tThread.yield();\n\n\t\t\t// 响应中断\n\t\t\tif (Thread.currentThread().isInterrupted()) {\n\t\t\t\tSystem.out.println(\"Java技术线程被中断，程序退出。\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t});\n\tthread.start();\n\tthread.interrupt();\n}\n```\n\n我们给示例2加上了响应中断的逻辑，程序接收到中断信号打印出信息后返回退出。\n\n**示例3（中断失败）**\n\n```\n/**\n * \n */\nprivate static void test3() throws InterruptedException {\n\tThread thread = new Thread(() -> {\n\t\twhile (true) {\n\t\t\t// 响应中断\n\t\t\tif (Thread.currentThread().isInterrupted()) {\n\t\t\t\tSystem.out.println(\"Java技术线程被中断，程序退出。\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tThread.sleep(3000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tSystem.out.println(\"Java技术线程休眠被中断，程序退出。\");\n\t\t\t}\n\t\t}\n\t});\n\tthread.start();\n\tThread.sleep(2000);\n\tthread.interrupt();\n}\n```\n\n示例3 sleep() 方法被中断，并输出了 `Java技术线程休眠被中断，程序退出。` 程序继续运行……为什么呢？\n\n来看 sleep 的源码：\n\n![](http://img.javastack.cn/18-6-1/1779530.jpg)\n\n可以看出 sleep() 方法被中断后会清除中断标记，所以循环会继续运行。。\n\n**示例4（中断成功）**\n\n```\n/**\n * \n */\nprivate static void test4() throws InterruptedException {\n\tThread thread = new Thread(() -> {\n\t\twhile (true) {\n\t\t\t// 响应中断\n\t\t\tif (Thread.currentThread().isInterrupted()) {\n\t\t\t\tSystem.out.println(\"Java技术线程被中断，程序退出。\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tThread.sleep(3000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tSystem.out.println(\"Java技术线程休眠被中断，程序退出。\");\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t}\n\t\t}\n\t});\n\tthread.start();\n\tThread.sleep(2000);\n\tthread.interrupt();\n}\n```\n\n示例4全部信息输出并正常退出，只是在 sleep() 方法被中断并清除标记后手动重新中断当前线程，然后程序接收中断信号返回退出。\n\n通过以上 4 个中断示例，相信对 Java 线程中断的概念有了全面的了解。\n\n\n","source":"_posts/多线程/一文搞懂 Java 线程中断.md","raw":"---\ntitle: 一文搞懂 Java 线程中断\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 多线程\n---\n\n```\ntry {\n\tThread.sleep(3000);\n} catch (InterruptedException e) {\n\te.printStackTrace();\n}\n```\n\n此时线程被打断后，代码会继续运行或者抛出异常结束运行，这并不是我们需要的中断线程的作用。\n\n#### 到底是什么是线程中断？\n\n线程中断即线程运行过程中被其他线程给打断了，它与 stop 最大的区别是：stop 是由系统强制终止线程，而线程中断则是给目标线程发送一个中断信号，如果目标线程没有接收线程中断的信号并结束线程，线程则不会终止，具体是否退出或者执行其他逻辑由目标线程决定。\n\n我们来看下线程中断最重要的 3 个方法，它们都是来自 Thread 类！\n\n**1、java.lang.Thread#interrupt**\n\n中断目标线程，给目标线程发一个中断信号，线程被打上中断标记。\n\n**2、java.lang.Thread#isInterrupted()**\n\n判断目标线程是否被中断，不会清除中断标记。\n\n**3、java.lang.Thread#interrupted**\n\n判断目标线程是否被中断，会清除中断标记。\n\n#### 线程中断实战\n\n我们来实例演示下线程中断如何用！\n\n**示例1（中断失败）**\n\n```\n/**\n * \n */\nprivate static void test1() {\n\tThread thread = new Thread(() -> {\n\t\twhile (true) {\n\t\t\tThread.yield();\n\t\t}\n\t});\n\tthread.start();\n\tthread.interrupt();\n}\n```\n\n请问示例1中的线程会被中断吗？答案：不会，因为虽然给线程发出了中断信号，但程序中并没有响应中断信号的逻辑，所以程序不会有任何反应。\n\n**示例2：（中断成功）**\n\n```\n/**\n * \n */\nprivate static void test2() {\n\tThread thread = new Thread(() -> {\n\t\twhile (true) {\n\t\t\tThread.yield();\n\n\t\t\t// 响应中断\n\t\t\tif (Thread.currentThread().isInterrupted()) {\n\t\t\t\tSystem.out.println(\"Java技术线程被中断，程序退出。\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t});\n\tthread.start();\n\tthread.interrupt();\n}\n```\n\n我们给示例2加上了响应中断的逻辑，程序接收到中断信号打印出信息后返回退出。\n\n**示例3（中断失败）**\n\n```\n/**\n * \n */\nprivate static void test3() throws InterruptedException {\n\tThread thread = new Thread(() -> {\n\t\twhile (true) {\n\t\t\t// 响应中断\n\t\t\tif (Thread.currentThread().isInterrupted()) {\n\t\t\t\tSystem.out.println(\"Java技术线程被中断，程序退出。\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tThread.sleep(3000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tSystem.out.println(\"Java技术线程休眠被中断，程序退出。\");\n\t\t\t}\n\t\t}\n\t});\n\tthread.start();\n\tThread.sleep(2000);\n\tthread.interrupt();\n}\n```\n\n示例3 sleep() 方法被中断，并输出了 `Java技术线程休眠被中断，程序退出。` 程序继续运行……为什么呢？\n\n来看 sleep 的源码：\n\n![](http://img.javastack.cn/18-6-1/1779530.jpg)\n\n可以看出 sleep() 方法被中断后会清除中断标记，所以循环会继续运行。。\n\n**示例4（中断成功）**\n\n```\n/**\n * \n */\nprivate static void test4() throws InterruptedException {\n\tThread thread = new Thread(() -> {\n\t\twhile (true) {\n\t\t\t// 响应中断\n\t\t\tif (Thread.currentThread().isInterrupted()) {\n\t\t\t\tSystem.out.println(\"Java技术线程被中断，程序退出。\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tThread.sleep(3000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tSystem.out.println(\"Java技术线程休眠被中断，程序退出。\");\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t}\n\t\t}\n\t});\n\tthread.start();\n\tThread.sleep(2000);\n\tthread.interrupt();\n}\n```\n\n示例4全部信息输出并正常退出，只是在 sleep() 方法被中断并清除标记后手动重新中断当前线程，然后程序接收中断信号返回退出。\n\n通过以上 4 个中断示例，相信对 Java 线程中断的概念有了全面的了解。\n\n\n","slug":"多线程/一文搞懂 Java 线程中断","published":1,"updated":"2025-10-15T07:20:25.065Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076n002cqkd48rqshy9n","content":"<pre class=\"line-numbers language-none\"><code class=\"language-none\">try &#123;\n\tThread.sleep(3000);\n&#125; catch (InterruptedException e) &#123;\n\te.printStackTrace();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>此时线程被打断后，代码会继续运行或者抛出异常结束运行，这并不是我们需要的中断线程的作用。</p>\n<h4 id=\"到底是什么是线程中断？\"><a href=\"#到底是什么是线程中断？\" class=\"headerlink\" title=\"到底是什么是线程中断？\"></a>到底是什么是线程中断？</h4><p>线程中断即线程运行过程中被其他线程给打断了，它与 stop 最大的区别是：stop 是由系统强制终止线程，而线程中断则是给目标线程发送一个中断信号，如果目标线程没有接收线程中断的信号并结束线程，线程则不会终止，具体是否退出或者执行其他逻辑由目标线程决定。</p>\n<p>我们来看下线程中断最重要的 3 个方法，它们都是来自 Thread 类！</p>\n<p><strong>1、java.lang.Thread#interrupt</strong></p>\n<p>中断目标线程，给目标线程发一个中断信号，线程被打上中断标记。</p>\n<p><strong>2、java.lang.Thread#isInterrupted()</strong></p>\n<p>判断目标线程是否被中断，不会清除中断标记。</p>\n<p><strong>3、java.lang.Thread#interrupted</strong></p>\n<p>判断目标线程是否被中断，会清除中断标记。</p>\n<h4 id=\"线程中断实战\"><a href=\"#线程中断实战\" class=\"headerlink\" title=\"线程中断实战\"></a>线程中断实战</h4><p>我们来实例演示下线程中断如何用！</p>\n<p><strong>示例1（中断失败）</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n *&#x2F;\nprivate static void test1() &#123;\n\tThread thread &#x3D; new Thread(() -&gt; &#123;\n\t\twhile (true) &#123;\n\t\t\tThread.yield();\n\t\t&#125;\n\t&#125;);\n\tthread.start();\n\tthread.interrupt();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>请问示例1中的线程会被中断吗？答案：不会，因为虽然给线程发出了中断信号，但程序中并没有响应中断信号的逻辑，所以程序不会有任何反应。</p>\n<p><strong>示例2：（中断成功）</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n *&#x2F;\nprivate static void test2() &#123;\n\tThread thread &#x3D; new Thread(() -&gt; &#123;\n\t\twhile (true) &#123;\n\t\t\tThread.yield();\n\n\t\t\t&#x2F;&#x2F; 响应中断\n\t\t\tif (Thread.currentThread().isInterrupted()) &#123;\n\t\t\t\tSystem.out.println(&quot;Java技术线程被中断，程序退出。&quot;);\n\t\t\t\treturn;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;);\n\tthread.start();\n\tthread.interrupt();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们给示例2加上了响应中断的逻辑，程序接收到中断信号打印出信息后返回退出。</p>\n<p><strong>示例3（中断失败）</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n *&#x2F;\nprivate static void test3() throws InterruptedException &#123;\n\tThread thread &#x3D; new Thread(() -&gt; &#123;\n\t\twhile (true) &#123;\n\t\t\t&#x2F;&#x2F; 响应中断\n\t\t\tif (Thread.currentThread().isInterrupted()) &#123;\n\t\t\t\tSystem.out.println(&quot;Java技术线程被中断，程序退出。&quot;);\n\t\t\t\treturn;\n\t\t\t&#125;\n\n\t\t\ttry &#123;\n\t\t\t\tThread.sleep(3000);\n\t\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\t\tSystem.out.println(&quot;Java技术线程休眠被中断，程序退出。&quot;);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;);\n\tthread.start();\n\tThread.sleep(2000);\n\tthread.interrupt();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>示例3 sleep() 方法被中断，并输出了 <code>Java技术线程休眠被中断，程序退出。</code> 程序继续运行……为什么呢？</p>\n<p>来看 sleep 的源码：</p>\n<p><img src=\"http://img.javastack.cn/18-6-1/1779530.jpg\"></p>\n<p>可以看出 sleep() 方法被中断后会清除中断标记，所以循环会继续运行。。</p>\n<p><strong>示例4（中断成功）</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n *&#x2F;\nprivate static void test4() throws InterruptedException &#123;\n\tThread thread &#x3D; new Thread(() -&gt; &#123;\n\t\twhile (true) &#123;\n\t\t\t&#x2F;&#x2F; 响应中断\n\t\t\tif (Thread.currentThread().isInterrupted()) &#123;\n\t\t\t\tSystem.out.println(&quot;Java技术线程被中断，程序退出。&quot;);\n\t\t\t\treturn;\n\t\t\t&#125;\n\n\t\t\ttry &#123;\n\t\t\t\tThread.sleep(3000);\n\t\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\t\tSystem.out.println(&quot;Java技术线程休眠被中断，程序退出。&quot;);\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;);\n\tthread.start();\n\tThread.sleep(2000);\n\tthread.interrupt();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>示例4全部信息输出并正常退出，只是在 sleep() 方法被中断并清除标记后手动重新中断当前线程，然后程序接收中断信号返回退出。</p>\n<p>通过以上 4 个中断示例，相信对 Java 线程中断的概念有了全面的了解。</p>\n","excerpt":"","more":"<pre class=\"line-numbers language-none\"><code class=\"language-none\">try &#123;\n\tThread.sleep(3000);\n&#125; catch (InterruptedException e) &#123;\n\te.printStackTrace();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>此时线程被打断后，代码会继续运行或者抛出异常结束运行，这并不是我们需要的中断线程的作用。</p>\n<h4 id=\"到底是什么是线程中断？\"><a href=\"#到底是什么是线程中断？\" class=\"headerlink\" title=\"到底是什么是线程中断？\"></a>到底是什么是线程中断？</h4><p>线程中断即线程运行过程中被其他线程给打断了，它与 stop 最大的区别是：stop 是由系统强制终止线程，而线程中断则是给目标线程发送一个中断信号，如果目标线程没有接收线程中断的信号并结束线程，线程则不会终止，具体是否退出或者执行其他逻辑由目标线程决定。</p>\n<p>我们来看下线程中断最重要的 3 个方法，它们都是来自 Thread 类！</p>\n<p><strong>1、java.lang.Thread#interrupt</strong></p>\n<p>中断目标线程，给目标线程发一个中断信号，线程被打上中断标记。</p>\n<p><strong>2、java.lang.Thread#isInterrupted()</strong></p>\n<p>判断目标线程是否被中断，不会清除中断标记。</p>\n<p><strong>3、java.lang.Thread#interrupted</strong></p>\n<p>判断目标线程是否被中断，会清除中断标记。</p>\n<h4 id=\"线程中断实战\"><a href=\"#线程中断实战\" class=\"headerlink\" title=\"线程中断实战\"></a>线程中断实战</h4><p>我们来实例演示下线程中断如何用！</p>\n<p><strong>示例1（中断失败）</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n *&#x2F;\nprivate static void test1() &#123;\n\tThread thread &#x3D; new Thread(() -&gt; &#123;\n\t\twhile (true) &#123;\n\t\t\tThread.yield();\n\t\t&#125;\n\t&#125;);\n\tthread.start();\n\tthread.interrupt();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>请问示例1中的线程会被中断吗？答案：不会，因为虽然给线程发出了中断信号，但程序中并没有响应中断信号的逻辑，所以程序不会有任何反应。</p>\n<p><strong>示例2：（中断成功）</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n *&#x2F;\nprivate static void test2() &#123;\n\tThread thread &#x3D; new Thread(() -&gt; &#123;\n\t\twhile (true) &#123;\n\t\t\tThread.yield();\n\n\t\t\t&#x2F;&#x2F; 响应中断\n\t\t\tif (Thread.currentThread().isInterrupted()) &#123;\n\t\t\t\tSystem.out.println(&quot;Java技术线程被中断，程序退出。&quot;);\n\t\t\t\treturn;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;);\n\tthread.start();\n\tthread.interrupt();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们给示例2加上了响应中断的逻辑，程序接收到中断信号打印出信息后返回退出。</p>\n<p><strong>示例3（中断失败）</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n *&#x2F;\nprivate static void test3() throws InterruptedException &#123;\n\tThread thread &#x3D; new Thread(() -&gt; &#123;\n\t\twhile (true) &#123;\n\t\t\t&#x2F;&#x2F; 响应中断\n\t\t\tif (Thread.currentThread().isInterrupted()) &#123;\n\t\t\t\tSystem.out.println(&quot;Java技术线程被中断，程序退出。&quot;);\n\t\t\t\treturn;\n\t\t\t&#125;\n\n\t\t\ttry &#123;\n\t\t\t\tThread.sleep(3000);\n\t\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\t\tSystem.out.println(&quot;Java技术线程休眠被中断，程序退出。&quot;);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;);\n\tthread.start();\n\tThread.sleep(2000);\n\tthread.interrupt();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>示例3 sleep() 方法被中断，并输出了 <code>Java技术线程休眠被中断，程序退出。</code> 程序继续运行……为什么呢？</p>\n<p>来看 sleep 的源码：</p>\n<p><img src=\"http://img.javastack.cn/18-6-1/1779530.jpg\"></p>\n<p>可以看出 sleep() 方法被中断后会清除中断标记，所以循环会继续运行。。</p>\n<p><strong>示例4（中断成功）</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n *&#x2F;\nprivate static void test4() throws InterruptedException &#123;\n\tThread thread &#x3D; new Thread(() -&gt; &#123;\n\t\twhile (true) &#123;\n\t\t\t&#x2F;&#x2F; 响应中断\n\t\t\tif (Thread.currentThread().isInterrupted()) &#123;\n\t\t\t\tSystem.out.println(&quot;Java技术线程被中断，程序退出。&quot;);\n\t\t\t\treturn;\n\t\t\t&#125;\n\n\t\t\ttry &#123;\n\t\t\t\tThread.sleep(3000);\n\t\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\t\tSystem.out.println(&quot;Java技术线程休眠被中断，程序退出。&quot;);\n\t\t\t\tThread.currentThread().interrupt();\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;);\n\tthread.start();\n\tThread.sleep(2000);\n\tthread.interrupt();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>示例4全部信息输出并正常退出，只是在 sleep() 方法被中断并清除标记后手动重新中断当前线程，然后程序接收中断信号返回退出。</p>\n<p>通过以上 4 个中断示例，相信对 Java 线程中断的概念有了全面的了解。</p>\n"},{"title":"出场率比较高的一道多线程安全面试题","date":"2025-10-14T06:42:34.000Z","_content":"\n工作一两年的应该都知道 ArrayList 是线程不安全的，要使用线程安全的就使用 Vector，这也是各种 Java 面试宝典里面所提及的，可能很多工作好几年的程序员都停留在这个知识面上。\n\n先说说为什么 ArrayList 是线程不安全的吧，来看以下的代码。\n\n```\n/**\n * \n */\npublic class TestArrayList {\n\n\tprivate static List<Integer> list = new ArrayList<>();\n\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\ttestList();\n\t\t\tlist.clear();\n\t\t}\n\t}\n\n\tprivate static void testList() throws InterruptedException {\n\t\tRunnable runnable = () -> {\n\t\t\tfor (int i = 0; i < 10000; i++) {\n\t\t\t\tlist.add(i);\n\t\t\t}\n\t\t};\n\n\t\tThread t1 = new Thread(runnable);\n\t\tThread t2 = new Thread(runnable);\n\t\tThread t3 = new Thread(runnable);\n\n\t\tt1.start();\n\t\tt2.start();\n\t\tt3.start();\n\n\t\tt1.join();\n\t\tt2.join();\n\t\tt3.join();\n\n\t\tSystem.out.println(list.size());\n\t}\n\n}\n```\n\n这是它的输出结果，我们期望的结果应该都是：30000，然后并不是，这就是传说中的多线程并发问题了。\n\n```\nException in thread \"Thread-1\" java.lang.ArrayIndexOutOfBoundsException: 15786\n\tat java.base/java.util.ArrayList.add(ArrayList.java:468)\n\tat java.base/java.util.ArrayList.add(ArrayList.java:480)\n\tat com.test.thread.TestArrayList.lambda$testList$0(TestArrayList.java:23)\n\tat java.base/java.lang.Thread.run(Thread.java:844)\n20332\n16100\n14941\n23749\n15631\n22118\n27417\n30000\n28691\n27843\n```\n\n#### 现象分析\n\n从以上结果可以总结出 ArrayList 在并发情况下会出现的几种现象。\n\n**1、发生 ArrayIndexOutOfBoundsException 异常；**\n\n```\nprivate void add(E e, Object[] elementData, int s) {\n    if (s == elementData.length)\n        elementData = grow();\n    elementData[s] = e;\n    size = s + 1;\n}\n```\n\n定位到异常所在源代码，毫无疑问，问题是出现在多线程并发访问下，由于没有同步锁的保护，造成了 ArrayList 扩容不一致的问题。\n\n\n**2、程序正常运行，输出了少于实际容量的大小；**\n\n这个也是多线程并发赋值时，对同一个数组索引位置进行了赋值，所以出现少于预期大小的情况。\n\n**3、程序正常运行，输出了预期容量的大小；**\n\n这是正常运行结果，未发生多线程安全问题，但这是不确定性的，不是每次都会达到正常预期的。\n\n#### 解决方案\n\n既然这样，那么在高并发情况下，使用什么样的列表集合保护线程安全呢？回到文章最开始的地方，使用 Vector，还有别的吗？当然有，篇幅有限，请各位看官期待后续文章。\n\n另外，像 HashMap, HashSet 等都有类似多线程安全问题，在多线程并发环境下避免使用这种集合。\n\n","source":"_posts/多线程/出场率比较高的一道多线程安全面试题.md","raw":"---\ntitle: 出场率比较高的一道多线程安全面试题\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 多线程\n---\n\n工作一两年的应该都知道 ArrayList 是线程不安全的，要使用线程安全的就使用 Vector，这也是各种 Java 面试宝典里面所提及的，可能很多工作好几年的程序员都停留在这个知识面上。\n\n先说说为什么 ArrayList 是线程不安全的吧，来看以下的代码。\n\n```\n/**\n * \n */\npublic class TestArrayList {\n\n\tprivate static List<Integer> list = new ArrayList<>();\n\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\ttestList();\n\t\t\tlist.clear();\n\t\t}\n\t}\n\n\tprivate static void testList() throws InterruptedException {\n\t\tRunnable runnable = () -> {\n\t\t\tfor (int i = 0; i < 10000; i++) {\n\t\t\t\tlist.add(i);\n\t\t\t}\n\t\t};\n\n\t\tThread t1 = new Thread(runnable);\n\t\tThread t2 = new Thread(runnable);\n\t\tThread t3 = new Thread(runnable);\n\n\t\tt1.start();\n\t\tt2.start();\n\t\tt3.start();\n\n\t\tt1.join();\n\t\tt2.join();\n\t\tt3.join();\n\n\t\tSystem.out.println(list.size());\n\t}\n\n}\n```\n\n这是它的输出结果，我们期望的结果应该都是：30000，然后并不是，这就是传说中的多线程并发问题了。\n\n```\nException in thread \"Thread-1\" java.lang.ArrayIndexOutOfBoundsException: 15786\n\tat java.base/java.util.ArrayList.add(ArrayList.java:468)\n\tat java.base/java.util.ArrayList.add(ArrayList.java:480)\n\tat com.test.thread.TestArrayList.lambda$testList$0(TestArrayList.java:23)\n\tat java.base/java.lang.Thread.run(Thread.java:844)\n20332\n16100\n14941\n23749\n15631\n22118\n27417\n30000\n28691\n27843\n```\n\n#### 现象分析\n\n从以上结果可以总结出 ArrayList 在并发情况下会出现的几种现象。\n\n**1、发生 ArrayIndexOutOfBoundsException 异常；**\n\n```\nprivate void add(E e, Object[] elementData, int s) {\n    if (s == elementData.length)\n        elementData = grow();\n    elementData[s] = e;\n    size = s + 1;\n}\n```\n\n定位到异常所在源代码，毫无疑问，问题是出现在多线程并发访问下，由于没有同步锁的保护，造成了 ArrayList 扩容不一致的问题。\n\n\n**2、程序正常运行，输出了少于实际容量的大小；**\n\n这个也是多线程并发赋值时，对同一个数组索引位置进行了赋值，所以出现少于预期大小的情况。\n\n**3、程序正常运行，输出了预期容量的大小；**\n\n这是正常运行结果，未发生多线程安全问题，但这是不确定性的，不是每次都会达到正常预期的。\n\n#### 解决方案\n\n既然这样，那么在高并发情况下，使用什么样的列表集合保护线程安全呢？回到文章最开始的地方，使用 Vector，还有别的吗？当然有，篇幅有限，请各位看官期待后续文章。\n\n另外，像 HashMap, HashSet 等都有类似多线程安全问题，在多线程并发环境下避免使用这种集合。\n\n","slug":"多线程/出场率比较高的一道多线程安全面试题","published":1,"updated":"2025-10-15T07:20:25.061Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076o002fqkd4blhv0iwh","content":"<p>工作一两年的应该都知道 ArrayList 是线程不安全的，要使用线程安全的就使用 Vector，这也是各种 Java 面试宝典里面所提及的，可能很多工作好几年的程序员都停留在这个知识面上。</p>\n<p>先说说为什么 ArrayList 是线程不安全的吧，来看以下的代码。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n *&#x2F;\npublic class TestArrayList &#123;\n\n\tprivate static List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\n\n\tpublic static void main(String[] args) throws InterruptedException &#123;\n\t\tfor (int i &#x3D; 0; i &lt; 10; i++) &#123;\n\t\t\ttestList();\n\t\t\tlist.clear();\n\t\t&#125;\n\t&#125;\n\n\tprivate static void testList() throws InterruptedException &#123;\n\t\tRunnable runnable &#x3D; () -&gt; &#123;\n\t\t\tfor (int i &#x3D; 0; i &lt; 10000; i++) &#123;\n\t\t\t\tlist.add(i);\n\t\t\t&#125;\n\t\t&#125;;\n\n\t\tThread t1 &#x3D; new Thread(runnable);\n\t\tThread t2 &#x3D; new Thread(runnable);\n\t\tThread t3 &#x3D; new Thread(runnable);\n\n\t\tt1.start();\n\t\tt2.start();\n\t\tt3.start();\n\n\t\tt1.join();\n\t\tt2.join();\n\t\tt3.join();\n\n\t\tSystem.out.println(list.size());\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这是它的输出结果，我们期望的结果应该都是：30000，然后并不是，这就是传说中的多线程并发问题了。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Exception in thread &quot;Thread-1&quot; java.lang.ArrayIndexOutOfBoundsException: 15786\n\tat java.base&#x2F;java.util.ArrayList.add(ArrayList.java:468)\n\tat java.base&#x2F;java.util.ArrayList.add(ArrayList.java:480)\n\tat com.test.thread.TestArrayList.lambda$testList$0(TestArrayList.java:23)\n\tat java.base&#x2F;java.lang.Thread.run(Thread.java:844)\n20332\n16100\n14941\n23749\n15631\n22118\n27417\n30000\n28691\n27843<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"现象分析\"><a href=\"#现象分析\" class=\"headerlink\" title=\"现象分析\"></a>现象分析</h4><p>从以上结果可以总结出 ArrayList 在并发情况下会出现的几种现象。</p>\n<p><strong>1、发生 ArrayIndexOutOfBoundsException 异常；</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private void add(E e, Object[] elementData, int s) &#123;\n    if (s &#x3D;&#x3D; elementData.length)\n        elementData &#x3D; grow();\n    elementData[s] &#x3D; e;\n    size &#x3D; s + 1;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>定位到异常所在源代码，毫无疑问，问题是出现在多线程并发访问下，由于没有同步锁的保护，造成了 ArrayList 扩容不一致的问题。</p>\n<p><strong>2、程序正常运行，输出了少于实际容量的大小；</strong></p>\n<p>这个也是多线程并发赋值时，对同一个数组索引位置进行了赋值，所以出现少于预期大小的情况。</p>\n<p><strong>3、程序正常运行，输出了预期容量的大小；</strong></p>\n<p>这是正常运行结果，未发生多线程安全问题，但这是不确定性的，不是每次都会达到正常预期的。</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>既然这样，那么在高并发情况下，使用什么样的列表集合保护线程安全呢？回到文章最开始的地方，使用 Vector，还有别的吗？当然有，篇幅有限，请各位看官期待后续文章。</p>\n<p>另外，像 HashMap, HashSet 等都有类似多线程安全问题，在多线程并发环境下避免使用这种集合。</p>\n","excerpt":"","more":"<p>工作一两年的应该都知道 ArrayList 是线程不安全的，要使用线程安全的就使用 Vector，这也是各种 Java 面试宝典里面所提及的，可能很多工作好几年的程序员都停留在这个知识面上。</p>\n<p>先说说为什么 ArrayList 是线程不安全的吧，来看以下的代码。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n *&#x2F;\npublic class TestArrayList &#123;\n\n\tprivate static List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\n\n\tpublic static void main(String[] args) throws InterruptedException &#123;\n\t\tfor (int i &#x3D; 0; i &lt; 10; i++) &#123;\n\t\t\ttestList();\n\t\t\tlist.clear();\n\t\t&#125;\n\t&#125;\n\n\tprivate static void testList() throws InterruptedException &#123;\n\t\tRunnable runnable &#x3D; () -&gt; &#123;\n\t\t\tfor (int i &#x3D; 0; i &lt; 10000; i++) &#123;\n\t\t\t\tlist.add(i);\n\t\t\t&#125;\n\t\t&#125;;\n\n\t\tThread t1 &#x3D; new Thread(runnable);\n\t\tThread t2 &#x3D; new Thread(runnable);\n\t\tThread t3 &#x3D; new Thread(runnable);\n\n\t\tt1.start();\n\t\tt2.start();\n\t\tt3.start();\n\n\t\tt1.join();\n\t\tt2.join();\n\t\tt3.join();\n\n\t\tSystem.out.println(list.size());\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这是它的输出结果，我们期望的结果应该都是：30000，然后并不是，这就是传说中的多线程并发问题了。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Exception in thread &quot;Thread-1&quot; java.lang.ArrayIndexOutOfBoundsException: 15786\n\tat java.base&#x2F;java.util.ArrayList.add(ArrayList.java:468)\n\tat java.base&#x2F;java.util.ArrayList.add(ArrayList.java:480)\n\tat com.test.thread.TestArrayList.lambda$testList$0(TestArrayList.java:23)\n\tat java.base&#x2F;java.lang.Thread.run(Thread.java:844)\n20332\n16100\n14941\n23749\n15631\n22118\n27417\n30000\n28691\n27843<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"现象分析\"><a href=\"#现象分析\" class=\"headerlink\" title=\"现象分析\"></a>现象分析</h4><p>从以上结果可以总结出 ArrayList 在并发情况下会出现的几种现象。</p>\n<p><strong>1、发生 ArrayIndexOutOfBoundsException 异常；</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private void add(E e, Object[] elementData, int s) &#123;\n    if (s &#x3D;&#x3D; elementData.length)\n        elementData &#x3D; grow();\n    elementData[s] &#x3D; e;\n    size &#x3D; s + 1;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>定位到异常所在源代码，毫无疑问，问题是出现在多线程并发访问下，由于没有同步锁的保护，造成了 ArrayList 扩容不一致的问题。</p>\n<p><strong>2、程序正常运行，输出了少于实际容量的大小；</strong></p>\n<p>这个也是多线程并发赋值时，对同一个数组索引位置进行了赋值，所以出现少于预期大小的情况。</p>\n<p><strong>3、程序正常运行，输出了预期容量的大小；</strong></p>\n<p>这是正常运行结果，未发生多线程安全问题，但这是不确定性的，不是每次都会达到正常预期的。</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>既然这样，那么在高并发情况下，使用什么样的列表集合保护线程安全呢？回到文章最开始的地方，使用 Vector，还有别的吗？当然有，篇幅有限，请各位看官期待后续文章。</p>\n<p>另外，像 HashMap, HashSet 等都有类似多线程安全问题，在多线程并发环境下避免使用这种集合。</p>\n"},{"title":"到底什么是重入锁，拜托，一次搞清楚！","date":"2025-10-14T06:42:34.000Z","_content":"\n\n#### 什么是重入锁\n\n> java.util.concurrent.locks.ReentrantLock\n\n这个是 JDK @since 1.5 添加的一种颗粒度更小的锁，它完全可以替代 synchronized 关键字来实现它的所有功能，而且 ReentrantLock 锁的灵活度要远远大于 synchronized 关键字。\n\n![](http://img.javastack.cn/ReentrantLock.png)\n\n从类结构图看出，ReentrantLock 实现了 Lock 接口，ReentrantLock 只是 Lock 接口的一个实现而已。\n\n> java.util.concurrent.locks.Lock\n\n它们都是 java.util.concurrent 包里面的内容（俗称 JUC、并发包），也都是 JDK 1.5 开始加入的。\n\n#### 为什么叫重入锁呢？\n\nReentrantLock，我们把它拆开来看就明了了。\n\nRe-Entrant-Lock：即表示可重新反复进入的锁，但仅限于当前线程；\n\n```\npublic void m() {\n    lock.lock();\n    lock.lock();\n    try {\n      // ... method body\n    } finally {\n      lock.unlock()\n      lock.unlock()\n    }\n}\n```\n\n如示例代码所示，当前线程可以反复加锁，但也需要释放同样加锁次数的锁，即重入了多少次，就要释放多少次，不然也会导入锁不被释放。\n\n试想一下，如果不设计成可重入锁，那自己如果反复给自己加锁，不是会把自己加死锁了吗？所以，到现在，重入锁的概念大概应该清楚了吧？\n\n#### 重入锁最重要的几个方法\n\n这几个方法都是 Lock 接口中定义的：\n\n![](http://img.javastack.cn/Lock.png)\n\n**1）lock()**\n\n获取锁，有以下三种情况：\n\n- 锁空闲：直接获取锁并返回，同时设置锁持有者数量为：1；\n- 当前线程持有锁：直接获取锁并返回，同时锁持有者数量递增1；\n- 其他线程持有锁：当前线程会休眠等待，直至获取锁为止；\n\n**2）lockInterruptibly()**\n\n获取锁，逻辑和 lock() 方法一样，但这个方法在获取锁过程中能响应中断。\n\n**3）tryLock()**\n\n从关键字字面理解，这是在尝试获取锁，获取成功返回：true，获取失败返回：false, 这个方法不会等待，有以下三种情况：\n\n- 锁空闲：直接获取锁并返回：true，同时设置锁持有者数量为：1；\n- 当前线程持有锁：直接获取锁并返回：true，同时锁持有者数量递增1；\n- 其他线程持有锁：获取锁失败，返回：false；\n\n**4）tryLock(long timeout, TimeUnit unit)**\n\n逻辑和 tryLock() 差不多，只是这个方法是带时间的。\n\n**5）unlock()**\n\n释放锁，每次锁持有者数量递减 1，直到 0 为止。所以，现在知道为什么 lock 多少次，就要对应 unlock 多少次了吧。\n\n**6）newCondition**\n\n返回一个这个锁的 Condition 实例，可以实现 synchronized 关键字类似 wait/ notify 实现多线程通信的功能，不过这个比 wait/ notify 要更灵活，更强大！\n\n#### 重入锁大概的用法\n\n```\nclass X {\n\n  private final ReentrantLock lock = new ReentrantLock();\n  \n  // ...\n\n  public void m() {\n    lock.lock();  // block until condition holds\n    try {\n      // ... method body\n    } finally {\n      lock.unlock()\n    }\n  }\n  \n}}\n```\n\n看见没有，加锁和释放锁都在方法里面进行，可以自由控制，比 synchronized 更灵活，更方便。但要注意的是，释放锁操作必须在 finally 里面，不然如果出现异常导致锁不能被正常释放，进而会卡死后续所有访问该锁的线程。\n\n#### synchronized 是重入锁吗？\n\n那么问题来了，synchronized 是重入锁吗？\n\n你可能会说不是，因为 ReentrantLock 既然是重入锁，根据推理，相反，那 synchronized 肯定就不是重入锁，那你就错了。\n\n答案是：yes，为什么？看下面的例子：\n\n```\npublic synchronized void operation(){\n    add();\n}\n\npublic synchronized void add(){\n\n}\n```\n\noperation 方法调用了 add 方法，两个方法都是用 synchronized 修饰的，add()  方法可以成功获取当前线程 operation() 方法已经获取到的锁，说明 synchronized 就是可重入锁。\n\n面试常问的Synchronized的几种用法推荐看下这篇文章：[Synchronized 有几种用法？](https://mp.weixin.qq.com/s/9h6VjHAmLA3twD6Y-FqfwA)。\n\n#### 总结\n\n\n","source":"_posts/多线程/到底什么是重入锁，拜托，一次搞清楚！.md","raw":"---\ntitle: 到底什么是重入锁，拜托，一次搞清楚！\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 多线程\n---\n\n\n#### 什么是重入锁\n\n> java.util.concurrent.locks.ReentrantLock\n\n这个是 JDK @since 1.5 添加的一种颗粒度更小的锁，它完全可以替代 synchronized 关键字来实现它的所有功能，而且 ReentrantLock 锁的灵活度要远远大于 synchronized 关键字。\n\n![](http://img.javastack.cn/ReentrantLock.png)\n\n从类结构图看出，ReentrantLock 实现了 Lock 接口，ReentrantLock 只是 Lock 接口的一个实现而已。\n\n> java.util.concurrent.locks.Lock\n\n它们都是 java.util.concurrent 包里面的内容（俗称 JUC、并发包），也都是 JDK 1.5 开始加入的。\n\n#### 为什么叫重入锁呢？\n\nReentrantLock，我们把它拆开来看就明了了。\n\nRe-Entrant-Lock：即表示可重新反复进入的锁，但仅限于当前线程；\n\n```\npublic void m() {\n    lock.lock();\n    lock.lock();\n    try {\n      // ... method body\n    } finally {\n      lock.unlock()\n      lock.unlock()\n    }\n}\n```\n\n如示例代码所示，当前线程可以反复加锁，但也需要释放同样加锁次数的锁，即重入了多少次，就要释放多少次，不然也会导入锁不被释放。\n\n试想一下，如果不设计成可重入锁，那自己如果反复给自己加锁，不是会把自己加死锁了吗？所以，到现在，重入锁的概念大概应该清楚了吧？\n\n#### 重入锁最重要的几个方法\n\n这几个方法都是 Lock 接口中定义的：\n\n![](http://img.javastack.cn/Lock.png)\n\n**1）lock()**\n\n获取锁，有以下三种情况：\n\n- 锁空闲：直接获取锁并返回，同时设置锁持有者数量为：1；\n- 当前线程持有锁：直接获取锁并返回，同时锁持有者数量递增1；\n- 其他线程持有锁：当前线程会休眠等待，直至获取锁为止；\n\n**2）lockInterruptibly()**\n\n获取锁，逻辑和 lock() 方法一样，但这个方法在获取锁过程中能响应中断。\n\n**3）tryLock()**\n\n从关键字字面理解，这是在尝试获取锁，获取成功返回：true，获取失败返回：false, 这个方法不会等待，有以下三种情况：\n\n- 锁空闲：直接获取锁并返回：true，同时设置锁持有者数量为：1；\n- 当前线程持有锁：直接获取锁并返回：true，同时锁持有者数量递增1；\n- 其他线程持有锁：获取锁失败，返回：false；\n\n**4）tryLock(long timeout, TimeUnit unit)**\n\n逻辑和 tryLock() 差不多，只是这个方法是带时间的。\n\n**5）unlock()**\n\n释放锁，每次锁持有者数量递减 1，直到 0 为止。所以，现在知道为什么 lock 多少次，就要对应 unlock 多少次了吧。\n\n**6）newCondition**\n\n返回一个这个锁的 Condition 实例，可以实现 synchronized 关键字类似 wait/ notify 实现多线程通信的功能，不过这个比 wait/ notify 要更灵活，更强大！\n\n#### 重入锁大概的用法\n\n```\nclass X {\n\n  private final ReentrantLock lock = new ReentrantLock();\n  \n  // ...\n\n  public void m() {\n    lock.lock();  // block until condition holds\n    try {\n      // ... method body\n    } finally {\n      lock.unlock()\n    }\n  }\n  \n}}\n```\n\n看见没有，加锁和释放锁都在方法里面进行，可以自由控制，比 synchronized 更灵活，更方便。但要注意的是，释放锁操作必须在 finally 里面，不然如果出现异常导致锁不能被正常释放，进而会卡死后续所有访问该锁的线程。\n\n#### synchronized 是重入锁吗？\n\n那么问题来了，synchronized 是重入锁吗？\n\n你可能会说不是，因为 ReentrantLock 既然是重入锁，根据推理，相反，那 synchronized 肯定就不是重入锁，那你就错了。\n\n答案是：yes，为什么？看下面的例子：\n\n```\npublic synchronized void operation(){\n    add();\n}\n\npublic synchronized void add(){\n\n}\n```\n\noperation 方法调用了 add 方法，两个方法都是用 synchronized 修饰的，add()  方法可以成功获取当前线程 operation() 方法已经获取到的锁，说明 synchronized 就是可重入锁。\n\n面试常问的Synchronized的几种用法推荐看下这篇文章：[Synchronized 有几种用法？](https://mp.weixin.qq.com/s/9h6VjHAmLA3twD6Y-FqfwA)。\n\n#### 总结\n\n\n","slug":"多线程/到底什么是重入锁，拜托，一次搞清楚！","published":1,"updated":"2025-10-15T07:20:25.077Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076o002iqkd4296q7rb9","content":"<h4 id=\"什么是重入锁\"><a href=\"#什么是重入锁\" class=\"headerlink\" title=\"什么是重入锁\"></a>什么是重入锁</h4><blockquote>\n<p>java.util.concurrent.locks.ReentrantLock</p>\n</blockquote>\n<p>这个是 JDK @since 1.5 添加的一种颗粒度更小的锁，它完全可以替代 synchronized 关键字来实现它的所有功能，而且 ReentrantLock 锁的灵活度要远远大于 synchronized 关键字。</p>\n<p><img src=\"http://img.javastack.cn/ReentrantLock.png\"></p>\n<p>从类结构图看出，ReentrantLock 实现了 Lock 接口，ReentrantLock 只是 Lock 接口的一个实现而已。</p>\n<blockquote>\n<p>java.util.concurrent.locks.Lock</p>\n</blockquote>\n<p>它们都是 java.util.concurrent 包里面的内容（俗称 JUC、并发包），也都是 JDK 1.5 开始加入的。</p>\n<h4 id=\"为什么叫重入锁呢？\"><a href=\"#为什么叫重入锁呢？\" class=\"headerlink\" title=\"为什么叫重入锁呢？\"></a>为什么叫重入锁呢？</h4><p>ReentrantLock，我们把它拆开来看就明了了。</p>\n<p>Re-Entrant-Lock：即表示可重新反复进入的锁，但仅限于当前线程；</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public void m() &#123;\n    lock.lock();\n    lock.lock();\n    try &#123;\n      &#x2F;&#x2F; ... method body\n    &#125; finally &#123;\n      lock.unlock()\n      lock.unlock()\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如示例代码所示，当前线程可以反复加锁，但也需要释放同样加锁次数的锁，即重入了多少次，就要释放多少次，不然也会导入锁不被释放。</p>\n<p>试想一下，如果不设计成可重入锁，那自己如果反复给自己加锁，不是会把自己加死锁了吗？所以，到现在，重入锁的概念大概应该清楚了吧？</p>\n<h4 id=\"重入锁最重要的几个方法\"><a href=\"#重入锁最重要的几个方法\" class=\"headerlink\" title=\"重入锁最重要的几个方法\"></a>重入锁最重要的几个方法</h4><p>这几个方法都是 Lock 接口中定义的：</p>\n<p><img src=\"http://img.javastack.cn/Lock.png\"></p>\n<p><strong>1）lock()</strong></p>\n<p>获取锁，有以下三种情况：</p>\n<ul>\n<li>锁空闲：直接获取锁并返回，同时设置锁持有者数量为：1；</li>\n<li>当前线程持有锁：直接获取锁并返回，同时锁持有者数量递增1；</li>\n<li>其他线程持有锁：当前线程会休眠等待，直至获取锁为止；</li>\n</ul>\n<p><strong>2）lockInterruptibly()</strong></p>\n<p>获取锁，逻辑和 lock() 方法一样，但这个方法在获取锁过程中能响应中断。</p>\n<p><strong>3）tryLock()</strong></p>\n<p>从关键字字面理解，这是在尝试获取锁，获取成功返回：true，获取失败返回：false, 这个方法不会等待，有以下三种情况：</p>\n<ul>\n<li>锁空闲：直接获取锁并返回：true，同时设置锁持有者数量为：1；</li>\n<li>当前线程持有锁：直接获取锁并返回：true，同时锁持有者数量递增1；</li>\n<li>其他线程持有锁：获取锁失败，返回：false；</li>\n</ul>\n<p><strong>4）tryLock(long timeout, TimeUnit unit)</strong></p>\n<p>逻辑和 tryLock() 差不多，只是这个方法是带时间的。</p>\n<p><strong>5）unlock()</strong></p>\n<p>释放锁，每次锁持有者数量递减 1，直到 0 为止。所以，现在知道为什么 lock 多少次，就要对应 unlock 多少次了吧。</p>\n<p><strong>6）newCondition</strong></p>\n<p>返回一个这个锁的 Condition 实例，可以实现 synchronized 关键字类似 wait&#x2F; notify 实现多线程通信的功能，不过这个比 wait&#x2F; notify 要更灵活，更强大！</p>\n<h4 id=\"重入锁大概的用法\"><a href=\"#重入锁大概的用法\" class=\"headerlink\" title=\"重入锁大概的用法\"></a>重入锁大概的用法</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">class X &#123;\n\n  private final ReentrantLock lock &#x3D; new ReentrantLock();\n  \n  &#x2F;&#x2F; ...\n\n  public void m() &#123;\n    lock.lock();  &#x2F;&#x2F; block until condition holds\n    try &#123;\n      &#x2F;&#x2F; ... method body\n    &#125; finally &#123;\n      lock.unlock()\n    &#125;\n  &#125;\n  \n&#125;&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>看见没有，加锁和释放锁都在方法里面进行，可以自由控制，比 synchronized 更灵活，更方便。但要注意的是，释放锁操作必须在 finally 里面，不然如果出现异常导致锁不能被正常释放，进而会卡死后续所有访问该锁的线程。</p>\n<h4 id=\"synchronized-是重入锁吗？\"><a href=\"#synchronized-是重入锁吗？\" class=\"headerlink\" title=\"synchronized 是重入锁吗？\"></a>synchronized 是重入锁吗？</h4><p>那么问题来了，synchronized 是重入锁吗？</p>\n<p>你可能会说不是，因为 ReentrantLock 既然是重入锁，根据推理，相反，那 synchronized 肯定就不是重入锁，那你就错了。</p>\n<p>答案是：yes，为什么？看下面的例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public synchronized void operation()&#123;\n    add();\n&#125;\n\npublic synchronized void add()&#123;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>operation 方法调用了 add 方法，两个方法都是用 synchronized 修饰的，add()  方法可以成功获取当前线程 operation() 方法已经获取到的锁，说明 synchronized 就是可重入锁。</p>\n<p>面试常问的Synchronized的几种用法推荐看下这篇文章：<a href=\"https://mp.weixin.qq.com/s/9h6VjHAmLA3twD6Y-FqfwA\">Synchronized 有几种用法？</a>。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4>","excerpt":"","more":"<h4 id=\"什么是重入锁\"><a href=\"#什么是重入锁\" class=\"headerlink\" title=\"什么是重入锁\"></a>什么是重入锁</h4><blockquote>\n<p>java.util.concurrent.locks.ReentrantLock</p>\n</blockquote>\n<p>这个是 JDK @since 1.5 添加的一种颗粒度更小的锁，它完全可以替代 synchronized 关键字来实现它的所有功能，而且 ReentrantLock 锁的灵活度要远远大于 synchronized 关键字。</p>\n<p><img src=\"http://img.javastack.cn/ReentrantLock.png\"></p>\n<p>从类结构图看出，ReentrantLock 实现了 Lock 接口，ReentrantLock 只是 Lock 接口的一个实现而已。</p>\n<blockquote>\n<p>java.util.concurrent.locks.Lock</p>\n</blockquote>\n<p>它们都是 java.util.concurrent 包里面的内容（俗称 JUC、并发包），也都是 JDK 1.5 开始加入的。</p>\n<h4 id=\"为什么叫重入锁呢？\"><a href=\"#为什么叫重入锁呢？\" class=\"headerlink\" title=\"为什么叫重入锁呢？\"></a>为什么叫重入锁呢？</h4><p>ReentrantLock，我们把它拆开来看就明了了。</p>\n<p>Re-Entrant-Lock：即表示可重新反复进入的锁，但仅限于当前线程；</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public void m() &#123;\n    lock.lock();\n    lock.lock();\n    try &#123;\n      &#x2F;&#x2F; ... method body\n    &#125; finally &#123;\n      lock.unlock()\n      lock.unlock()\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如示例代码所示，当前线程可以反复加锁，但也需要释放同样加锁次数的锁，即重入了多少次，就要释放多少次，不然也会导入锁不被释放。</p>\n<p>试想一下，如果不设计成可重入锁，那自己如果反复给自己加锁，不是会把自己加死锁了吗？所以，到现在，重入锁的概念大概应该清楚了吧？</p>\n<h4 id=\"重入锁最重要的几个方法\"><a href=\"#重入锁最重要的几个方法\" class=\"headerlink\" title=\"重入锁最重要的几个方法\"></a>重入锁最重要的几个方法</h4><p>这几个方法都是 Lock 接口中定义的：</p>\n<p><img src=\"http://img.javastack.cn/Lock.png\"></p>\n<p><strong>1）lock()</strong></p>\n<p>获取锁，有以下三种情况：</p>\n<ul>\n<li>锁空闲：直接获取锁并返回，同时设置锁持有者数量为：1；</li>\n<li>当前线程持有锁：直接获取锁并返回，同时锁持有者数量递增1；</li>\n<li>其他线程持有锁：当前线程会休眠等待，直至获取锁为止；</li>\n</ul>\n<p><strong>2）lockInterruptibly()</strong></p>\n<p>获取锁，逻辑和 lock() 方法一样，但这个方法在获取锁过程中能响应中断。</p>\n<p><strong>3）tryLock()</strong></p>\n<p>从关键字字面理解，这是在尝试获取锁，获取成功返回：true，获取失败返回：false, 这个方法不会等待，有以下三种情况：</p>\n<ul>\n<li>锁空闲：直接获取锁并返回：true，同时设置锁持有者数量为：1；</li>\n<li>当前线程持有锁：直接获取锁并返回：true，同时锁持有者数量递增1；</li>\n<li>其他线程持有锁：获取锁失败，返回：false；</li>\n</ul>\n<p><strong>4）tryLock(long timeout, TimeUnit unit)</strong></p>\n<p>逻辑和 tryLock() 差不多，只是这个方法是带时间的。</p>\n<p><strong>5）unlock()</strong></p>\n<p>释放锁，每次锁持有者数量递减 1，直到 0 为止。所以，现在知道为什么 lock 多少次，就要对应 unlock 多少次了吧。</p>\n<p><strong>6）newCondition</strong></p>\n<p>返回一个这个锁的 Condition 实例，可以实现 synchronized 关键字类似 wait&#x2F; notify 实现多线程通信的功能，不过这个比 wait&#x2F; notify 要更灵活，更强大！</p>\n<h4 id=\"重入锁大概的用法\"><a href=\"#重入锁大概的用法\" class=\"headerlink\" title=\"重入锁大概的用法\"></a>重入锁大概的用法</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">class X &#123;\n\n  private final ReentrantLock lock &#x3D; new ReentrantLock();\n  \n  &#x2F;&#x2F; ...\n\n  public void m() &#123;\n    lock.lock();  &#x2F;&#x2F; block until condition holds\n    try &#123;\n      &#x2F;&#x2F; ... method body\n    &#125; finally &#123;\n      lock.unlock()\n    &#125;\n  &#125;\n  \n&#125;&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>看见没有，加锁和释放锁都在方法里面进行，可以自由控制，比 synchronized 更灵活，更方便。但要注意的是，释放锁操作必须在 finally 里面，不然如果出现异常导致锁不能被正常释放，进而会卡死后续所有访问该锁的线程。</p>\n<h4 id=\"synchronized-是重入锁吗？\"><a href=\"#synchronized-是重入锁吗？\" class=\"headerlink\" title=\"synchronized 是重入锁吗？\"></a>synchronized 是重入锁吗？</h4><p>那么问题来了，synchronized 是重入锁吗？</p>\n<p>你可能会说不是，因为 ReentrantLock 既然是重入锁，根据推理，相反，那 synchronized 肯定就不是重入锁，那你就错了。</p>\n<p>答案是：yes，为什么？看下面的例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public synchronized void operation()&#123;\n    add();\n&#125;\n\npublic synchronized void add()&#123;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>operation 方法调用了 add 方法，两个方法都是用 synchronized 修饰的，add()  方法可以成功获取当前线程 operation() 方法已经获取到的锁，说明 synchronized 就是可重入锁。</p>\n<p>面试常问的Synchronized的几种用法推荐看下这篇文章：<a href=\"https://mp.weixin.qq.com/s/9h6VjHAmLA3twD6Y-FqfwA\">Synchronized 有几种用法？</a>。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4>"},{"title":"多线程 Thread.yield 方法到底有什么用？","date":"2025-10-14T06:42:34.000Z","_content":"\n## 概念\n\n我们知道 start() 方法是启动线程，让线程变成就绪状态等待 CPU 调度后执行。\n\n那 yield() 方法是干什么用的呢？来看下源码。\n\n```\n/**\n * A hint to the scheduler that the current thread is willing to yield\n * its current use of a processor. The scheduler is free to ignore this\n * hint.\n *\n * <p> Yield is a heuristic attempt to improve relative progression\n * between threads that would otherwise over-utilise a CPU. Its use\n * should be combined with detailed profiling and benchmarking to\n * ensure that it actually has the desired effect.\n *\n * <p> It is rarely appropriate to use this method. It may be useful\n * for debugging or testing purposes, where it may help to reproduce\n * bugs due to race conditions. It may also be useful when designing\n * concurrency control constructs such as the ones in the\n * {@link java.util.concurrent.locks} package.\n */\npublic static native void yield();\n```\n\nyield 即 \"谦让\"，也是 Thread 类的方法。它让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。它可能会获取到，也有可能被其他线程获取到。\n\n## 实战\n\n下面是一个使用示例。\n\n```\n/**\n * \n */\npublic static void main(String[] args) {\n\tRunnable runnable = () -> {\n\t\tfor (int i = 0; i <= 100; i++) {\n\t\t\tSystem.out.println(Thread.currentThread().getName() + \"-----\" + i);\n\t\t\tif (i % 20 == 0) {\n\t\t\t\tThread.yield();\n\t\t\t}\n\t\t}\n\t};\n\tnew Thread(runnable, \"栈长\").start();\n    new Thread(runnable, \"小蜜\").start();\n}\n```\n\n这个示例每当执行完 20 个之后就让出 CPU，每次谦让后就会马上获取到调度权继续执行。\n\n**运行以上程序，可以有以下两种结果。**\n\n结果1：栈长让出了 CPU 资源，小蜜成功上位。\n\n```\n栈长-----29\n栈长-----30\n小蜜-----26\n栈长-----31\n```\n\n结果2：栈长让出了 CPU 资源，栈长继续运行。\n\n```\n栈长-----28\n栈长-----29\n栈长-----30\n栈长-----31\n```\n\n而如果我们把两个线程加上线程优先级，那输出的结果又不一样。\n\n```\nthread1.setPriority(Thread.MIN_PRIORITY);\nthread2.setPriority(Thread.MAX_PRIORITY);\n```\n\n因为给小蜜加了最高优先权，栈长加了最低优先权，即使栈长先启动，那小蜜还是有很大的概率比栈长先会输出完的，大家可以试一下。\n\n## yield 和 sleep 的异同\n\n1）yield, sleep 都能暂停当前线程，sleep 可以指定具体休眠的时间，而 yield 则依赖 CPU 的时间片划分。\n\n2）yield, sleep 两个在暂停过程中，如已经持有锁，则都不会释放锁资源。\n\n3）yield 不能被中断，而 sleep 则可以接受中断。\n\n## 总结 \n\n栈长没用过 yield，感觉没什么鸟用。\n\n如果一定要用它的话，一句话解释就是：yield 方法可以很好的控制多线程，如执行某项复杂的任务时，如果担心占用资源过多，可以在完成某个重要的工作后使用 yield 方法让掉当前 CPU 的调度权，等下次获取到再继续执行，这样不但能完成自己的重要工作，也能给其他线程一些运行的机会，避免一个线程长时间占有 CPU 资源。\n\n\n\n","source":"_posts/多线程/多线程 Thread.yield 方法到底有什么用？.md","raw":"---\ntitle: 多线程 Thread.yield 方法到底有什么用？\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 多线程\n---\n\n## 概念\n\n我们知道 start() 方法是启动线程，让线程变成就绪状态等待 CPU 调度后执行。\n\n那 yield() 方法是干什么用的呢？来看下源码。\n\n```\n/**\n * A hint to the scheduler that the current thread is willing to yield\n * its current use of a processor. The scheduler is free to ignore this\n * hint.\n *\n * <p> Yield is a heuristic attempt to improve relative progression\n * between threads that would otherwise over-utilise a CPU. Its use\n * should be combined with detailed profiling and benchmarking to\n * ensure that it actually has the desired effect.\n *\n * <p> It is rarely appropriate to use this method. It may be useful\n * for debugging or testing purposes, where it may help to reproduce\n * bugs due to race conditions. It may also be useful when designing\n * concurrency control constructs such as the ones in the\n * {@link java.util.concurrent.locks} package.\n */\npublic static native void yield();\n```\n\nyield 即 \"谦让\"，也是 Thread 类的方法。它让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。它可能会获取到，也有可能被其他线程获取到。\n\n## 实战\n\n下面是一个使用示例。\n\n```\n/**\n * \n */\npublic static void main(String[] args) {\n\tRunnable runnable = () -> {\n\t\tfor (int i = 0; i <= 100; i++) {\n\t\t\tSystem.out.println(Thread.currentThread().getName() + \"-----\" + i);\n\t\t\tif (i % 20 == 0) {\n\t\t\t\tThread.yield();\n\t\t\t}\n\t\t}\n\t};\n\tnew Thread(runnable, \"栈长\").start();\n    new Thread(runnable, \"小蜜\").start();\n}\n```\n\n这个示例每当执行完 20 个之后就让出 CPU，每次谦让后就会马上获取到调度权继续执行。\n\n**运行以上程序，可以有以下两种结果。**\n\n结果1：栈长让出了 CPU 资源，小蜜成功上位。\n\n```\n栈长-----29\n栈长-----30\n小蜜-----26\n栈长-----31\n```\n\n结果2：栈长让出了 CPU 资源，栈长继续运行。\n\n```\n栈长-----28\n栈长-----29\n栈长-----30\n栈长-----31\n```\n\n而如果我们把两个线程加上线程优先级，那输出的结果又不一样。\n\n```\nthread1.setPriority(Thread.MIN_PRIORITY);\nthread2.setPriority(Thread.MAX_PRIORITY);\n```\n\n因为给小蜜加了最高优先权，栈长加了最低优先权，即使栈长先启动，那小蜜还是有很大的概率比栈长先会输出完的，大家可以试一下。\n\n## yield 和 sleep 的异同\n\n1）yield, sleep 都能暂停当前线程，sleep 可以指定具体休眠的时间，而 yield 则依赖 CPU 的时间片划分。\n\n2）yield, sleep 两个在暂停过程中，如已经持有锁，则都不会释放锁资源。\n\n3）yield 不能被中断，而 sleep 则可以接受中断。\n\n## 总结 \n\n栈长没用过 yield，感觉没什么鸟用。\n\n如果一定要用它的话，一句话解释就是：yield 方法可以很好的控制多线程，如执行某项复杂的任务时，如果担心占用资源过多，可以在完成某个重要的工作后使用 yield 方法让掉当前 CPU 的调度权，等下次获取到再继续执行，这样不但能完成自己的重要工作，也能给其他线程一些运行的机会，避免一个线程长时间占有 CPU 资源。\n\n\n\n","slug":"多线程/多线程 Thread.yield 方法到底有什么用？","published":1,"updated":"2025-10-15T07:20:25.018Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076p002lqkd437gr0xfm","content":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>我们知道 start() 方法是启动线程，让线程变成就绪状态等待 CPU 调度后执行。</p>\n<p>那 yield() 方法是干什么用的呢？来看下源码。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * A hint to the scheduler that the current thread is willing to yield\n * its current use of a processor. The scheduler is free to ignore this\n * hint.\n *\n * &lt;p&gt; Yield is a heuristic attempt to improve relative progression\n * between threads that would otherwise over-utilise a CPU. Its use\n * should be combined with detailed profiling and benchmarking to\n * ensure that it actually has the desired effect.\n *\n * &lt;p&gt; It is rarely appropriate to use this method. It may be useful\n * for debugging or testing purposes, where it may help to reproduce\n * bugs due to race conditions. It may also be useful when designing\n * concurrency control constructs such as the ones in the\n * &#123;@link java.util.concurrent.locks&#125; package.\n *&#x2F;\npublic static native void yield();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>yield 即 “谦让”，也是 Thread 类的方法。它让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。它可能会获取到，也有可能被其他线程获取到。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><p>下面是一个使用示例。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n *&#x2F;\npublic static void main(String[] args) &#123;\n\tRunnable runnable &#x3D; () -&gt; &#123;\n\t\tfor (int i &#x3D; 0; i &lt;&#x3D; 100; i++) &#123;\n\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot;-----&quot; + i);\n\t\t\tif (i % 20 &#x3D;&#x3D; 0) &#123;\n\t\t\t\tThread.yield();\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;;\n\tnew Thread(runnable, &quot;栈长&quot;).start();\n    new Thread(runnable, &quot;小蜜&quot;).start();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个示例每当执行完 20 个之后就让出 CPU，每次谦让后就会马上获取到调度权继续执行。</p>\n<p><strong>运行以上程序，可以有以下两种结果。</strong></p>\n<p>结果1：栈长让出了 CPU 资源，小蜜成功上位。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">栈长-----29\n栈长-----30\n小蜜-----26\n栈长-----31<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>结果2：栈长让出了 CPU 资源，栈长继续运行。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">栈长-----28\n栈长-----29\n栈长-----30\n栈长-----31<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>而如果我们把两个线程加上线程优先级，那输出的结果又不一样。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">thread1.setPriority(Thread.MIN_PRIORITY);\nthread2.setPriority(Thread.MAX_PRIORITY);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>因为给小蜜加了最高优先权，栈长加了最低优先权，即使栈长先启动，那小蜜还是有很大的概率比栈长先会输出完的，大家可以试一下。</p>\n<h2 id=\"yield-和-sleep-的异同\"><a href=\"#yield-和-sleep-的异同\" class=\"headerlink\" title=\"yield 和 sleep 的异同\"></a>yield 和 sleep 的异同</h2><p>1）yield, sleep 都能暂停当前线程，sleep 可以指定具体休眠的时间，而 yield 则依赖 CPU 的时间片划分。</p>\n<p>2）yield, sleep 两个在暂停过程中，如已经持有锁，则都不会释放锁资源。</p>\n<p>3）yield 不能被中断，而 sleep 则可以接受中断。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>栈长没用过 yield，感觉没什么鸟用。</p>\n<p>如果一定要用它的话，一句话解释就是：yield 方法可以很好的控制多线程，如执行某项复杂的任务时，如果担心占用资源过多，可以在完成某个重要的工作后使用 yield 方法让掉当前 CPU 的调度权，等下次获取到再继续执行，这样不但能完成自己的重要工作，也能给其他线程一些运行的机会，避免一个线程长时间占有 CPU 资源。</p>\n","excerpt":"","more":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>我们知道 start() 方法是启动线程，让线程变成就绪状态等待 CPU 调度后执行。</p>\n<p>那 yield() 方法是干什么用的呢？来看下源码。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * A hint to the scheduler that the current thread is willing to yield\n * its current use of a processor. The scheduler is free to ignore this\n * hint.\n *\n * &lt;p&gt; Yield is a heuristic attempt to improve relative progression\n * between threads that would otherwise over-utilise a CPU. Its use\n * should be combined with detailed profiling and benchmarking to\n * ensure that it actually has the desired effect.\n *\n * &lt;p&gt; It is rarely appropriate to use this method. It may be useful\n * for debugging or testing purposes, where it may help to reproduce\n * bugs due to race conditions. It may also be useful when designing\n * concurrency control constructs such as the ones in the\n * &#123;@link java.util.concurrent.locks&#125; package.\n *&#x2F;\npublic static native void yield();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>yield 即 “谦让”，也是 Thread 类的方法。它让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。它可能会获取到，也有可能被其他线程获取到。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><p>下面是一个使用示例。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n *&#x2F;\npublic static void main(String[] args) &#123;\n\tRunnable runnable &#x3D; () -&gt; &#123;\n\t\tfor (int i &#x3D; 0; i &lt;&#x3D; 100; i++) &#123;\n\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot;-----&quot; + i);\n\t\t\tif (i % 20 &#x3D;&#x3D; 0) &#123;\n\t\t\t\tThread.yield();\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;;\n\tnew Thread(runnable, &quot;栈长&quot;).start();\n    new Thread(runnable, &quot;小蜜&quot;).start();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个示例每当执行完 20 个之后就让出 CPU，每次谦让后就会马上获取到调度权继续执行。</p>\n<p><strong>运行以上程序，可以有以下两种结果。</strong></p>\n<p>结果1：栈长让出了 CPU 资源，小蜜成功上位。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">栈长-----29\n栈长-----30\n小蜜-----26\n栈长-----31<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>结果2：栈长让出了 CPU 资源，栈长继续运行。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">栈长-----28\n栈长-----29\n栈长-----30\n栈长-----31<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>而如果我们把两个线程加上线程优先级，那输出的结果又不一样。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">thread1.setPriority(Thread.MIN_PRIORITY);\nthread2.setPriority(Thread.MAX_PRIORITY);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>因为给小蜜加了最高优先权，栈长加了最低优先权，即使栈长先启动，那小蜜还是有很大的概率比栈长先会输出完的，大家可以试一下。</p>\n<h2 id=\"yield-和-sleep-的异同\"><a href=\"#yield-和-sleep-的异同\" class=\"headerlink\" title=\"yield 和 sleep 的异同\"></a>yield 和 sleep 的异同</h2><p>1）yield, sleep 都能暂停当前线程，sleep 可以指定具体休眠的时间，而 yield 则依赖 CPU 的时间片划分。</p>\n<p>2）yield, sleep 两个在暂停过程中，如已经持有锁，则都不会释放锁资源。</p>\n<p>3）yield 不能被中断，而 sleep 则可以接受中断。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>栈长没用过 yield，感觉没什么鸟用。</p>\n<p>如果一定要用它的话，一句话解释就是：yield 方法可以很好的控制多线程，如执行某项复杂的任务时，如果担心占用资源过多，可以在完成某个重要的工作后使用 yield 方法让掉当前 CPU 的调度权，等下次获取到再继续执行，这样不但能完成自己的重要工作，也能给其他线程一些运行的机会，避免一个线程长时间占有 CPU 资源。</p>\n"},{"title":"多线程 start 和 run 方法到底有什么区别？","date":"2025-10-14T06:42:34.000Z","_content":"\n**首先要知道实现多线程最基本的两种方式：**\n\n1、继承 `java.lang.Thread` 类；\n\n2、实现 `java.lang.Runnable`接口；\n\n其中 Thread 类也是实现了 Runnable 接口，而 Runnable 接口定义了唯一的一个 run() 方法，所以基于 Thread 和 Runnable 创建多线程都需要实现 run() 方法，是多线程真正运行的主方法。\n\n```\n@FunctionalInterface\npublic interface Runnable {\n    public abstract void run();\n}\n```\n\n而 start() 方法则是 Thread 类的方法，用来异步启动一个线程，然后主线程立刻返回。该启动的线程不会马上运行，会放到等待队列中等待 CPU 调度，只有线程真正被 CPU 调度时才会调用 run() 方法执行。\n\n所以 start() 方法只是标识线程为就绪状态的一个附加方法，以下 start() 方法的源码，其中 start0() 是一个本地 native 方法。\n\n```\npublic synchronized void start() {\n    if (threadStatus != 0)\n        throw new IllegalThreadStateException();\n\n    group.add(this);\n\n    boolean started = false;\n    try {\n        start0();\n        started = true;\n    } finally {\n        try {\n            if (!started) {\n                group.threadStartFailed(this);\n            }\n        } catch (Throwable ignore) {\n            /* do nothing. If start0 threw a Throwable then\n              it will be passed up the call stack */\n        }\n    }\n}\n```\n\n请注意，start() 方法被标识为 synchronized 的，即为了防止被多次启动的一个同步操作。\n\n**那么你会问了，为什么要有两个方法，直接用一个 run() 方法不就行了吗！？** 还真不行，如果直接调用 run() 方法，那就等于调用了一个普通的同步方法，达不到多线程运行的异步执行，来看下面的例子。\n\n```\n/**\n * \n */\npublic static void main(String[] args) {\n\tThread thread = new Thread(() -> {\n\t\ttry {\n\t\t\tThread.sleep(3000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(\"Java技术\");\n\t});\n\n\tlong start = System.currentTimeMillis();\n\tthread.start();\n\tSystem.out.println(System.currentTimeMillis() - start);\n\n\tstart = System.currentTimeMillis();\n\tthread.run();\n\tSystem.out.println(System.currentTimeMillis() - start);\n}\n\n```\n\n程序输出：\n\n```\n0\nJava技术\n3000\nJava技术\n```\n\n从程序输出结果可以看出，启动 start 方法前后只用了 0 毫秒，而启动 run 方法则阻塞了 3000 毫秒等程序执行完再继续执行，这就是同步与异步的一个最重要的区别。\n\n看完这篇，你应该对 start 和 run 方法有了一个大概的掌握吧，再也不怕面试官问你这两个的区别了吧！\n\n动手转发给更多的朋友吧！\n\n\n","source":"_posts/多线程/多线程 start 和 run 方法到底有什么区别？.md","raw":"---\ntitle: 多线程 start 和 run 方法到底有什么区别？\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 多线程\n---\n\n**首先要知道实现多线程最基本的两种方式：**\n\n1、继承 `java.lang.Thread` 类；\n\n2、实现 `java.lang.Runnable`接口；\n\n其中 Thread 类也是实现了 Runnable 接口，而 Runnable 接口定义了唯一的一个 run() 方法，所以基于 Thread 和 Runnable 创建多线程都需要实现 run() 方法，是多线程真正运行的主方法。\n\n```\n@FunctionalInterface\npublic interface Runnable {\n    public abstract void run();\n}\n```\n\n而 start() 方法则是 Thread 类的方法，用来异步启动一个线程，然后主线程立刻返回。该启动的线程不会马上运行，会放到等待队列中等待 CPU 调度，只有线程真正被 CPU 调度时才会调用 run() 方法执行。\n\n所以 start() 方法只是标识线程为就绪状态的一个附加方法，以下 start() 方法的源码，其中 start0() 是一个本地 native 方法。\n\n```\npublic synchronized void start() {\n    if (threadStatus != 0)\n        throw new IllegalThreadStateException();\n\n    group.add(this);\n\n    boolean started = false;\n    try {\n        start0();\n        started = true;\n    } finally {\n        try {\n            if (!started) {\n                group.threadStartFailed(this);\n            }\n        } catch (Throwable ignore) {\n            /* do nothing. If start0 threw a Throwable then\n              it will be passed up the call stack */\n        }\n    }\n}\n```\n\n请注意，start() 方法被标识为 synchronized 的，即为了防止被多次启动的一个同步操作。\n\n**那么你会问了，为什么要有两个方法，直接用一个 run() 方法不就行了吗！？** 还真不行，如果直接调用 run() 方法，那就等于调用了一个普通的同步方法，达不到多线程运行的异步执行，来看下面的例子。\n\n```\n/**\n * \n */\npublic static void main(String[] args) {\n\tThread thread = new Thread(() -> {\n\t\ttry {\n\t\t\tThread.sleep(3000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(\"Java技术\");\n\t});\n\n\tlong start = System.currentTimeMillis();\n\tthread.start();\n\tSystem.out.println(System.currentTimeMillis() - start);\n\n\tstart = System.currentTimeMillis();\n\tthread.run();\n\tSystem.out.println(System.currentTimeMillis() - start);\n}\n\n```\n\n程序输出：\n\n```\n0\nJava技术\n3000\nJava技术\n```\n\n从程序输出结果可以看出，启动 start 方法前后只用了 0 毫秒，而启动 run 方法则阻塞了 3000 毫秒等程序执行完再继续执行，这就是同步与异步的一个最重要的区别。\n\n看完这篇，你应该对 start 和 run 方法有了一个大概的掌握吧，再也不怕面试官问你这两个的区别了吧！\n\n动手转发给更多的朋友吧！\n\n\n","slug":"多线程/多线程 start 和 run 方法到底有什么区别？","published":1,"updated":"2025-10-15T07:20:24.991Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076q002oqkd411tz6n5b","content":"<p><strong>首先要知道实现多线程最基本的两种方式：</strong></p>\n<p>1、继承 <code>java.lang.Thread</code> 类；</p>\n<p>2、实现 <code>java.lang.Runnable</code>接口；</p>\n<p>其中 Thread 类也是实现了 Runnable 接口，而 Runnable 接口定义了唯一的一个 run() 方法，所以基于 Thread 和 Runnable 创建多线程都需要实现 run() 方法，是多线程真正运行的主方法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@FunctionalInterface\npublic interface Runnable &#123;\n    public abstract void run();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>而 start() 方法则是 Thread 类的方法，用来异步启动一个线程，然后主线程立刻返回。该启动的线程不会马上运行，会放到等待队列中等待 CPU 调度，只有线程真正被 CPU 调度时才会调用 run() 方法执行。</p>\n<p>所以 start() 方法只是标识线程为就绪状态的一个附加方法，以下 start() 方法的源码，其中 start0() 是一个本地 native 方法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public synchronized void start() &#123;\n    if (threadStatus !&#x3D; 0)\n        throw new IllegalThreadStateException();\n\n    group.add(this);\n\n    boolean started &#x3D; false;\n    try &#123;\n        start0();\n        started &#x3D; true;\n    &#125; finally &#123;\n        try &#123;\n            if (!started) &#123;\n                group.threadStartFailed(this);\n            &#125;\n        &#125; catch (Throwable ignore) &#123;\n            &#x2F;* do nothing. If start0 threw a Throwable then\n              it will be passed up the call stack *&#x2F;\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>请注意，start() 方法被标识为 synchronized 的，即为了防止被多次启动的一个同步操作。</p>\n<p><strong>那么你会问了，为什么要有两个方法，直接用一个 run() 方法不就行了吗！？</strong> 还真不行，如果直接调用 run() 方法，那就等于调用了一个普通的同步方法，达不到多线程运行的异步执行，来看下面的例子。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n *&#x2F;\npublic static void main(String[] args) &#123;\n\tThread thread &#x3D; new Thread(() -&gt; &#123;\n\t\ttry &#123;\n\t\t\tThread.sleep(3000);\n\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t\tSystem.out.println(&quot;Java技术&quot;);\n\t&#125;);\n\n\tlong start &#x3D; System.currentTimeMillis();\n\tthread.start();\n\tSystem.out.println(System.currentTimeMillis() - start);\n\n\tstart &#x3D; System.currentTimeMillis();\n\tthread.run();\n\tSystem.out.println(System.currentTimeMillis() - start);\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0\nJava技术\n3000\nJava技术<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>从程序输出结果可以看出，启动 start 方法前后只用了 0 毫秒，而启动 run 方法则阻塞了 3000 毫秒等程序执行完再继续执行，这就是同步与异步的一个最重要的区别。</p>\n<p>看完这篇，你应该对 start 和 run 方法有了一个大概的掌握吧，再也不怕面试官问你这两个的区别了吧！</p>\n<p>动手转发给更多的朋友吧！</p>\n","excerpt":"","more":"<p><strong>首先要知道实现多线程最基本的两种方式：</strong></p>\n<p>1、继承 <code>java.lang.Thread</code> 类；</p>\n<p>2、实现 <code>java.lang.Runnable</code>接口；</p>\n<p>其中 Thread 类也是实现了 Runnable 接口，而 Runnable 接口定义了唯一的一个 run() 方法，所以基于 Thread 和 Runnable 创建多线程都需要实现 run() 方法，是多线程真正运行的主方法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@FunctionalInterface\npublic interface Runnable &#123;\n    public abstract void run();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>而 start() 方法则是 Thread 类的方法，用来异步启动一个线程，然后主线程立刻返回。该启动的线程不会马上运行，会放到等待队列中等待 CPU 调度，只有线程真正被 CPU 调度时才会调用 run() 方法执行。</p>\n<p>所以 start() 方法只是标识线程为就绪状态的一个附加方法，以下 start() 方法的源码，其中 start0() 是一个本地 native 方法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public synchronized void start() &#123;\n    if (threadStatus !&#x3D; 0)\n        throw new IllegalThreadStateException();\n\n    group.add(this);\n\n    boolean started &#x3D; false;\n    try &#123;\n        start0();\n        started &#x3D; true;\n    &#125; finally &#123;\n        try &#123;\n            if (!started) &#123;\n                group.threadStartFailed(this);\n            &#125;\n        &#125; catch (Throwable ignore) &#123;\n            &#x2F;* do nothing. If start0 threw a Throwable then\n              it will be passed up the call stack *&#x2F;\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>请注意，start() 方法被标识为 synchronized 的，即为了防止被多次启动的一个同步操作。</p>\n<p><strong>那么你会问了，为什么要有两个方法，直接用一个 run() 方法不就行了吗！？</strong> 还真不行，如果直接调用 run() 方法，那就等于调用了一个普通的同步方法，达不到多线程运行的异步执行，来看下面的例子。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n *&#x2F;\npublic static void main(String[] args) &#123;\n\tThread thread &#x3D; new Thread(() -&gt; &#123;\n\t\ttry &#123;\n\t\t\tThread.sleep(3000);\n\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t\tSystem.out.println(&quot;Java技术&quot;);\n\t&#125;);\n\n\tlong start &#x3D; System.currentTimeMillis();\n\tthread.start();\n\tSystem.out.println(System.currentTimeMillis() - start);\n\n\tstart &#x3D; System.currentTimeMillis();\n\tthread.run();\n\tSystem.out.println(System.currentTimeMillis() - start);\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0\nJava技术\n3000\nJava技术<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>从程序输出结果可以看出，启动 start 方法前后只用了 0 毫秒，而启动 run 方法则阻塞了 3000 毫秒等程序执行完再继续执行，这就是同步与异步的一个最重要的区别。</p>\n<p>看完这篇，你应该对 start 和 run 方法有了一个大概的掌握吧，再也不怕面试官问你这两个的区别了吧！</p>\n<p>动手转发给更多的朋友吧！</p>\n"},{"title":"多线程通信的三大法器，你真的会用吗？","date":"2025-10-14T06:42:34.000Z","_content":"\nwait, notify, notifyAll 是多线程之间通信最重要的 3 个方法，今天，栈长给大家普及一下它们的知识要点及应用实战。\n\n## 定义\n\nwait：让持有该对象锁的线程等待；\n\nnotify: 唤醒任何一个持有该对象锁的线程；\n\nnotify: 唤醒所有持有该对象锁的线程；\n\n它们 3 个的关系是，调用对象的 wait 方法使线程暂停运行，通过 notify/ notifyAll 方法唤醒调用 wait 暂时的线程。\n\n**然而，它们并不是 Thread 类中的方法，而是 Object 类中的，为什么呢！？** 因为每个对象都有监视锁，线程要操作某个对象当然是要获取某个对象的锁了，而不是线程的锁。\n\n![](http://qianniu.javastack.cn/18-6-1/82637503.jpg)\n\n如图所示，wait 带时间表示最大超时时间，过了时间还不唤醒就会自动唤醒线程重新竞争对象锁。\n\n## 几个重要的点\n\n1、调用对象的 wait, notify, notifyAll 方法需要拥有对象的监视器锁，即它们只能在同步方法（块）中使用；\n\n2、调用 wait 方法会使用线程暂停并让出 CPU 资源，同时释放持有的对象的锁；\n\n3、多线程使用 notify 容易发生死锁，一般使用 notifyAll；\n\n4、关于 wait 和 sleep 的详细区别请翻阅 《[多线程 sleep 和 wait 的 5 个区别](https://mp.weixin.qq.com/s/gvaksKy2ss90bsybCnajpQ)》这篇文章。\n\n## 实战\n\n```\n/**\n * \n */\npublic static void main(String[] args) {\n\tObject lock = new Object();\n\tThread t1 = new Thread(() -> {\n\t\tsynchronized (lock) {\n\t\t\tfor (int i = 0; i < 20; i++) {\n\t\t\t\tSystem.out.print(i);\n\t\t\t\tif (i == 10) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlock.wait();\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tThread t2 = new Thread(() -> {\n\t\tsynchronized (lock) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(5000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.print(\"Java技术\");\n\t\t\tlock.notifyAll();\n\t\t}\n\t});\n\n\tt1.start();\n\tt2.start();\n}\n```\n\n上面的例子结合 wait/ notifyAll 来演示了它们的相互作用。\n\n线程 t1 首先输出 `012345678910`，5秒后继续输出 `Java技术111213141516171819`。\n\n","source":"_posts/多线程/多线程通信的三大法器，你真的会用吗？.md","raw":"---\ntitle: 多线程通信的三大法器，你真的会用吗？\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 多线程\n---\n\nwait, notify, notifyAll 是多线程之间通信最重要的 3 个方法，今天，栈长给大家普及一下它们的知识要点及应用实战。\n\n## 定义\n\nwait：让持有该对象锁的线程等待；\n\nnotify: 唤醒任何一个持有该对象锁的线程；\n\nnotify: 唤醒所有持有该对象锁的线程；\n\n它们 3 个的关系是，调用对象的 wait 方法使线程暂停运行，通过 notify/ notifyAll 方法唤醒调用 wait 暂时的线程。\n\n**然而，它们并不是 Thread 类中的方法，而是 Object 类中的，为什么呢！？** 因为每个对象都有监视锁，线程要操作某个对象当然是要获取某个对象的锁了，而不是线程的锁。\n\n![](http://qianniu.javastack.cn/18-6-1/82637503.jpg)\n\n如图所示，wait 带时间表示最大超时时间，过了时间还不唤醒就会自动唤醒线程重新竞争对象锁。\n\n## 几个重要的点\n\n1、调用对象的 wait, notify, notifyAll 方法需要拥有对象的监视器锁，即它们只能在同步方法（块）中使用；\n\n2、调用 wait 方法会使用线程暂停并让出 CPU 资源，同时释放持有的对象的锁；\n\n3、多线程使用 notify 容易发生死锁，一般使用 notifyAll；\n\n4、关于 wait 和 sleep 的详细区别请翻阅 《[多线程 sleep 和 wait 的 5 个区别](https://mp.weixin.qq.com/s/gvaksKy2ss90bsybCnajpQ)》这篇文章。\n\n## 实战\n\n```\n/**\n * \n */\npublic static void main(String[] args) {\n\tObject lock = new Object();\n\tThread t1 = new Thread(() -> {\n\t\tsynchronized (lock) {\n\t\t\tfor (int i = 0; i < 20; i++) {\n\t\t\t\tSystem.out.print(i);\n\t\t\t\tif (i == 10) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlock.wait();\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tThread t2 = new Thread(() -> {\n\t\tsynchronized (lock) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(5000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.print(\"Java技术\");\n\t\t\tlock.notifyAll();\n\t\t}\n\t});\n\n\tt1.start();\n\tt2.start();\n}\n```\n\n上面的例子结合 wait/ notifyAll 来演示了它们的相互作用。\n\n线程 t1 首先输出 `012345678910`，5秒后继续输出 `Java技术111213141516171819`。\n\n","slug":"多线程/多线程通信的三大法器，你真的会用吗？","published":1,"updated":"2025-10-15T07:20:25.005Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076r002rqkd42p0o7veo","content":"<p>wait, notify, notifyAll 是多线程之间通信最重要的 3 个方法，今天，栈长给大家普及一下它们的知识要点及应用实战。</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>wait：让持有该对象锁的线程等待；</p>\n<p>notify: 唤醒任何一个持有该对象锁的线程；</p>\n<p>notify: 唤醒所有持有该对象锁的线程；</p>\n<p>它们 3 个的关系是，调用对象的 wait 方法使线程暂停运行，通过 notify&#x2F; notifyAll 方法唤醒调用 wait 暂时的线程。</p>\n<p><strong>然而，它们并不是 Thread 类中的方法，而是 Object 类中的，为什么呢！？</strong> 因为每个对象都有监视锁，线程要操作某个对象当然是要获取某个对象的锁了，而不是线程的锁。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-6-1/82637503.jpg\"></p>\n<p>如图所示，wait 带时间表示最大超时时间，过了时间还不唤醒就会自动唤醒线程重新竞争对象锁。</p>\n<h2 id=\"几个重要的点\"><a href=\"#几个重要的点\" class=\"headerlink\" title=\"几个重要的点\"></a>几个重要的点</h2><p>1、调用对象的 wait, notify, notifyAll 方法需要拥有对象的监视器锁，即它们只能在同步方法（块）中使用；</p>\n<p>2、调用 wait 方法会使用线程暂停并让出 CPU 资源，同时释放持有的对象的锁；</p>\n<p>3、多线程使用 notify 容易发生死锁，一般使用 notifyAll；</p>\n<p>4、关于 wait 和 sleep 的详细区别请翻阅 《<a href=\"https://mp.weixin.qq.com/s/gvaksKy2ss90bsybCnajpQ\">多线程 sleep 和 wait 的 5 个区别</a>》这篇文章。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n *&#x2F;\npublic static void main(String[] args) &#123;\n\tObject lock &#x3D; new Object();\n\tThread t1 &#x3D; new Thread(() -&gt; &#123;\n\t\tsynchronized (lock) &#123;\n\t\t\tfor (int i &#x3D; 0; i &lt; 20; i++) &#123;\n\t\t\t\tSystem.out.print(i);\n\t\t\t\tif (i &#x3D;&#x3D; 10) &#123;\n\t\t\t\t\ttry &#123;\n\t\t\t\t\t\tlock.wait();\n\t\t\t\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;);\n\n\tThread t2 &#x3D; new Thread(() -&gt; &#123;\n\t\tsynchronized (lock) &#123;\n\t\t\ttry &#123;\n\t\t\t\tThread.sleep(5000);\n\t\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\t\te.printStackTrace();\n\t\t\t&#125;\n\t\t\tSystem.out.print(&quot;Java技术&quot;);\n\t\t\tlock.notifyAll();\n\t\t&#125;\n\t&#125;);\n\n\tt1.start();\n\tt2.start();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>上面的例子结合 wait&#x2F; notifyAll 来演示了它们的相互作用。</p>\n<p>线程 t1 首先输出 <code>012345678910</code>，5秒后继续输出 <code>Java技术111213141516171819</code>。</p>\n","excerpt":"","more":"<p>wait, notify, notifyAll 是多线程之间通信最重要的 3 个方法，今天，栈长给大家普及一下它们的知识要点及应用实战。</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>wait：让持有该对象锁的线程等待；</p>\n<p>notify: 唤醒任何一个持有该对象锁的线程；</p>\n<p>notify: 唤醒所有持有该对象锁的线程；</p>\n<p>它们 3 个的关系是，调用对象的 wait 方法使线程暂停运行，通过 notify&#x2F; notifyAll 方法唤醒调用 wait 暂时的线程。</p>\n<p><strong>然而，它们并不是 Thread 类中的方法，而是 Object 类中的，为什么呢！？</strong> 因为每个对象都有监视锁，线程要操作某个对象当然是要获取某个对象的锁了，而不是线程的锁。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-6-1/82637503.jpg\"></p>\n<p>如图所示，wait 带时间表示最大超时时间，过了时间还不唤醒就会自动唤醒线程重新竞争对象锁。</p>\n<h2 id=\"几个重要的点\"><a href=\"#几个重要的点\" class=\"headerlink\" title=\"几个重要的点\"></a>几个重要的点</h2><p>1、调用对象的 wait, notify, notifyAll 方法需要拥有对象的监视器锁，即它们只能在同步方法（块）中使用；</p>\n<p>2、调用 wait 方法会使用线程暂停并让出 CPU 资源，同时释放持有的对象的锁；</p>\n<p>3、多线程使用 notify 容易发生死锁，一般使用 notifyAll；</p>\n<p>4、关于 wait 和 sleep 的详细区别请翻阅 《<a href=\"https://mp.weixin.qq.com/s/gvaksKy2ss90bsybCnajpQ\">多线程 sleep 和 wait 的 5 个区别</a>》这篇文章。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n *&#x2F;\npublic static void main(String[] args) &#123;\n\tObject lock &#x3D; new Object();\n\tThread t1 &#x3D; new Thread(() -&gt; &#123;\n\t\tsynchronized (lock) &#123;\n\t\t\tfor (int i &#x3D; 0; i &lt; 20; i++) &#123;\n\t\t\t\tSystem.out.print(i);\n\t\t\t\tif (i &#x3D;&#x3D; 10) &#123;\n\t\t\t\t\ttry &#123;\n\t\t\t\t\t\tlock.wait();\n\t\t\t\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;);\n\n\tThread t2 &#x3D; new Thread(() -&gt; &#123;\n\t\tsynchronized (lock) &#123;\n\t\t\ttry &#123;\n\t\t\t\tThread.sleep(5000);\n\t\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\t\te.printStackTrace();\n\t\t\t&#125;\n\t\t\tSystem.out.print(&quot;Java技术&quot;);\n\t\t\tlock.notifyAll();\n\t\t&#125;\n\t&#125;);\n\n\tt1.start();\n\tt2.start();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>上面的例子结合 wait&#x2F; notifyAll 来演示了它们的相互作用。</p>\n<p>线程 t1 首先输出 <code>012345678910</code>，5秒后继续输出 <code>Java技术111213141516171819</code>。</p>\n"},{"title":"并行任务执行神器 Fork & Join 实战","date":"2025-10-14T06:42:34.000Z","_content":"\n#### Fork/Join是什么？\n\nFork/Join框架是Java7提供的并行执行任务框架，思想是将大任务分解成小任务，然后小任务又可以继续分解，然后每个小任务分别计算出结果再合并起来，最后将汇总的结果作为大任务结果。其思想和MapReduce的思想非常类似。对于任务的分割，要求各个子任务之间相互独立，能够并行独立地执行任务，互相之间不影响。\n\n**Fork/Join的运行流程图如下：**\n\n![image](https://res.infoq.com/articles/fork-join-introduction/zh/resources/21.png)\n\n我们可以通过Fork/Join单词字面上的意思去理解这个框架。Fork是叉子分叉的意思，即将大任务分解成并行的小任务，Join是连接结合的意思，即将所有并行的小任务的执行结果汇总起来。\n\n![image](http://java.boot.by/ocpjp7-upgrade/images/040501.gif)\n\n#### 工作窃取算法\n\nForkJoin采用了工作窃取（work-stealing）算法，若一个工作线程的任务队列为空没有任务执行时，便从其他工作线程中获取任务主动执行。为了实现工作窃取，在工作线程中维护了双端队列，窃取任务线程从队尾获取任务，被窃取任务线程从队头获取任务。这种机制充分利用线程进行并行计算，减少了线程竞争。但是当队列中只存在一个任务了时，两个线程去取反而会造成资源浪费。\n\n**工作窃取的运行流程图如下：**\n\n![image](https://res.infoq.com/articles/fork-join-introduction/zh/resources/image3.png)\n\n#### Fork/Join核心类\n\nFork/Join框架主要由子任务、任务调度两部分组成，类层次图如下。\n\n![image](http://img.blog.csdn.net/20160720172854109)\n\n- **ForkJoinPool**\n\nForkJoinPool是ForkJoin框架中的任务调度器，和ThreadPoolExecutor一样实现了自己的线程池，提供了三种调度子任务的方法：\n\n1. execute：异步执行指定任务，无返回结果；\n1. invoke、invokeAll：异步执行指定任务，等待完成才返回结果；\n1. submit：异步执行指定任务，并立即返回一个Future对象；\n\n- **ForkJoinTask**\n\nFork/Join框架中的实际的执行任务类，有以下两种实现，一般继承这两种实现类即可。\n\n1. RecursiveAction：用于无结果返回的子任务；\n1. RecursiveTask：用于有结果返回的子任务；\n\n#### Fork/Join框架实战\n\n下面实现一个Fork/Join小例子，从1+2+...10亿，每个任务只能处理1000个数相加，超过1000个的自动分解成小任务并行处理；并展示了通过不使用Fork/Join和使用时的时间损耗对比。\n\n```\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.RecursiveTask;\n\npublic class ForkJoinTask extends RecursiveTask<Long> {\n\n\tprivate static final long MAX = 1000000000L;\n\tprivate static final long THRESHOLD = 1000L;\n\tprivate long start;\n\tprivate long end;\n\n\tpublic ForkJoinTask(long start, long end) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttest();\n\t\tSystem.out.println(\"--------------------\");\n\t\ttestForkJoin();\n\t}\n\n\tprivate static void test() {\n\t\tSystem.out.println(\"test\");\n\t\tlong start = System.currentTimeMillis();\n\t\tLong sum = 0L;\n\t\tfor (long i = 0L; i <= MAX; i++) {\n\t\t\tsum += i;\n\t\t}\n\t\tSystem.out.println(sum);\n\t\tSystem.out.println(System.currentTimeMillis() - start + \"ms\");\n\t}\n\n\tprivate static void testForkJoin() {\n\t\tSystem.out.println(\"testForkJoin\");\n\t\tlong start = System.currentTimeMillis();\n\t\tForkJoinPool forkJoinPool = new ForkJoinPool();\n\t\tLong sum = forkJoinPool.invoke(new ForkJoinTask(1, MAX));\n\t\tSystem.out.println(sum);\n\t\tSystem.out.println(System.currentTimeMillis() - start + \"ms\");\n\t}\n\n\t@Override\n\tprotected Long compute() {\n\t\tlong sum = 0;\n\t\tif (end - start <= THRESHOLD) {\n\t\t\tfor (long i = start; i <= end; i++) {\n\t\t\t\tsum += i;\n\t\t\t}\n\t\t\treturn sum;\n\t\t} else {\n\t\t\tlong mid = (start + end) / 2;\n\n\t\t\tForkJoinTask task1 = new ForkJoinTask(start, mid);\n\t\t\ttask1.fork();\n\n\t\t\tForkJoinTask task2 = new ForkJoinTask(mid + 1, end);\n\t\t\ttask2.fork();\n\n\t\t\treturn task1.join() + task2.join();\n\t\t}\n\t}\n\n}\n```\n\n这里需要计算结果，所以任务继承的是RecursiveTask类。ForkJoinTask需要实现compute方法，在这个方法里首先需要判断任务是否小于等于阈值1000，如果是就直接执行任务。否则分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成孙任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会阻塞并等待子任务执行完并得到其结果。\n\n程序输出：\n\n```\ntest\n500000000500000000\n4992ms\n--------------------\ntestForkJoin\n500000000500000000\n508ms\n```\n从结果看出，并行的时间损耗明显要少于串行的，这就是并行任务的好处。\n\n尽管如此，在使用Fork/Join时也得注意，不要盲目使用。\n\n1. 如果任务拆解的很深，系统内的线程数量堆积，导致系统性能性能严重下降；\n1. 如果函数的调用栈很深，会导致栈内存溢出；","source":"_posts/多线程/并行任务执行神器 Fork & Join 实战.md","raw":"---\ntitle: 并行任务执行神器 Fork & Join 实战\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 多线程\n---\n\n#### Fork/Join是什么？\n\nFork/Join框架是Java7提供的并行执行任务框架，思想是将大任务分解成小任务，然后小任务又可以继续分解，然后每个小任务分别计算出结果再合并起来，最后将汇总的结果作为大任务结果。其思想和MapReduce的思想非常类似。对于任务的分割，要求各个子任务之间相互独立，能够并行独立地执行任务，互相之间不影响。\n\n**Fork/Join的运行流程图如下：**\n\n![image](https://res.infoq.com/articles/fork-join-introduction/zh/resources/21.png)\n\n我们可以通过Fork/Join单词字面上的意思去理解这个框架。Fork是叉子分叉的意思，即将大任务分解成并行的小任务，Join是连接结合的意思，即将所有并行的小任务的执行结果汇总起来。\n\n![image](http://java.boot.by/ocpjp7-upgrade/images/040501.gif)\n\n#### 工作窃取算法\n\nForkJoin采用了工作窃取（work-stealing）算法，若一个工作线程的任务队列为空没有任务执行时，便从其他工作线程中获取任务主动执行。为了实现工作窃取，在工作线程中维护了双端队列，窃取任务线程从队尾获取任务，被窃取任务线程从队头获取任务。这种机制充分利用线程进行并行计算，减少了线程竞争。但是当队列中只存在一个任务了时，两个线程去取反而会造成资源浪费。\n\n**工作窃取的运行流程图如下：**\n\n![image](https://res.infoq.com/articles/fork-join-introduction/zh/resources/image3.png)\n\n#### Fork/Join核心类\n\nFork/Join框架主要由子任务、任务调度两部分组成，类层次图如下。\n\n![image](http://img.blog.csdn.net/20160720172854109)\n\n- **ForkJoinPool**\n\nForkJoinPool是ForkJoin框架中的任务调度器，和ThreadPoolExecutor一样实现了自己的线程池，提供了三种调度子任务的方法：\n\n1. execute：异步执行指定任务，无返回结果；\n1. invoke、invokeAll：异步执行指定任务，等待完成才返回结果；\n1. submit：异步执行指定任务，并立即返回一个Future对象；\n\n- **ForkJoinTask**\n\nFork/Join框架中的实际的执行任务类，有以下两种实现，一般继承这两种实现类即可。\n\n1. RecursiveAction：用于无结果返回的子任务；\n1. RecursiveTask：用于有结果返回的子任务；\n\n#### Fork/Join框架实战\n\n下面实现一个Fork/Join小例子，从1+2+...10亿，每个任务只能处理1000个数相加，超过1000个的自动分解成小任务并行处理；并展示了通过不使用Fork/Join和使用时的时间损耗对比。\n\n```\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.RecursiveTask;\n\npublic class ForkJoinTask extends RecursiveTask<Long> {\n\n\tprivate static final long MAX = 1000000000L;\n\tprivate static final long THRESHOLD = 1000L;\n\tprivate long start;\n\tprivate long end;\n\n\tpublic ForkJoinTask(long start, long end) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttest();\n\t\tSystem.out.println(\"--------------------\");\n\t\ttestForkJoin();\n\t}\n\n\tprivate static void test() {\n\t\tSystem.out.println(\"test\");\n\t\tlong start = System.currentTimeMillis();\n\t\tLong sum = 0L;\n\t\tfor (long i = 0L; i <= MAX; i++) {\n\t\t\tsum += i;\n\t\t}\n\t\tSystem.out.println(sum);\n\t\tSystem.out.println(System.currentTimeMillis() - start + \"ms\");\n\t}\n\n\tprivate static void testForkJoin() {\n\t\tSystem.out.println(\"testForkJoin\");\n\t\tlong start = System.currentTimeMillis();\n\t\tForkJoinPool forkJoinPool = new ForkJoinPool();\n\t\tLong sum = forkJoinPool.invoke(new ForkJoinTask(1, MAX));\n\t\tSystem.out.println(sum);\n\t\tSystem.out.println(System.currentTimeMillis() - start + \"ms\");\n\t}\n\n\t@Override\n\tprotected Long compute() {\n\t\tlong sum = 0;\n\t\tif (end - start <= THRESHOLD) {\n\t\t\tfor (long i = start; i <= end; i++) {\n\t\t\t\tsum += i;\n\t\t\t}\n\t\t\treturn sum;\n\t\t} else {\n\t\t\tlong mid = (start + end) / 2;\n\n\t\t\tForkJoinTask task1 = new ForkJoinTask(start, mid);\n\t\t\ttask1.fork();\n\n\t\t\tForkJoinTask task2 = new ForkJoinTask(mid + 1, end);\n\t\t\ttask2.fork();\n\n\t\t\treturn task1.join() + task2.join();\n\t\t}\n\t}\n\n}\n```\n\n这里需要计算结果，所以任务继承的是RecursiveTask类。ForkJoinTask需要实现compute方法，在这个方法里首先需要判断任务是否小于等于阈值1000，如果是就直接执行任务。否则分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成孙任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会阻塞并等待子任务执行完并得到其结果。\n\n程序输出：\n\n```\ntest\n500000000500000000\n4992ms\n--------------------\ntestForkJoin\n500000000500000000\n508ms\n```\n从结果看出，并行的时间损耗明显要少于串行的，这就是并行任务的好处。\n\n尽管如此，在使用Fork/Join时也得注意，不要盲目使用。\n\n1. 如果任务拆解的很深，系统内的线程数量堆积，导致系统性能性能严重下降；\n1. 如果函数的调用栈很深，会导致栈内存溢出；","slug":"多线程/并行任务执行神器 Fork & Join 实战","published":1,"updated":"2025-10-15T07:20:24.981Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076r002uqkd4gvoxcw3r","content":"<h4 id=\"Fork-Join是什么？\"><a href=\"#Fork-Join是什么？\" class=\"headerlink\" title=\"Fork&#x2F;Join是什么？\"></a>Fork&#x2F;Join是什么？</h4><p>Fork&#x2F;Join框架是Java7提供的并行执行任务框架，思想是将大任务分解成小任务，然后小任务又可以继续分解，然后每个小任务分别计算出结果再合并起来，最后将汇总的结果作为大任务结果。其思想和MapReduce的思想非常类似。对于任务的分割，要求各个子任务之间相互独立，能够并行独立地执行任务，互相之间不影响。</p>\n<p><strong>Fork&#x2F;Join的运行流程图如下：</strong></p>\n<p><img src=\"https://res.infoq.com/articles/fork-join-introduction/zh/resources/21.png\" alt=\"image\"></p>\n<p>我们可以通过Fork&#x2F;Join单词字面上的意思去理解这个框架。Fork是叉子分叉的意思，即将大任务分解成并行的小任务，Join是连接结合的意思，即将所有并行的小任务的执行结果汇总起来。</p>\n<p><img src=\"http://java.boot.by/ocpjp7-upgrade/images/040501.gif\" alt=\"image\"></p>\n<h4 id=\"工作窃取算法\"><a href=\"#工作窃取算法\" class=\"headerlink\" title=\"工作窃取算法\"></a>工作窃取算法</h4><p>ForkJoin采用了工作窃取（work-stealing）算法，若一个工作线程的任务队列为空没有任务执行时，便从其他工作线程中获取任务主动执行。为了实现工作窃取，在工作线程中维护了双端队列，窃取任务线程从队尾获取任务，被窃取任务线程从队头获取任务。这种机制充分利用线程进行并行计算，减少了线程竞争。但是当队列中只存在一个任务了时，两个线程去取反而会造成资源浪费。</p>\n<p><strong>工作窃取的运行流程图如下：</strong></p>\n<p><img src=\"https://res.infoq.com/articles/fork-join-introduction/zh/resources/image3.png\" alt=\"image\"></p>\n<h4 id=\"Fork-Join核心类\"><a href=\"#Fork-Join核心类\" class=\"headerlink\" title=\"Fork&#x2F;Join核心类\"></a>Fork&#x2F;Join核心类</h4><p>Fork&#x2F;Join框架主要由子任务、任务调度两部分组成，类层次图如下。</p>\n<p><img src=\"http://img.blog.csdn.net/20160720172854109\" alt=\"image\"></p>\n<ul>\n<li><strong>ForkJoinPool</strong></li>\n</ul>\n<p>ForkJoinPool是ForkJoin框架中的任务调度器，和ThreadPoolExecutor一样实现了自己的线程池，提供了三种调度子任务的方法：</p>\n<ol>\n<li>execute：异步执行指定任务，无返回结果；</li>\n<li>invoke、invokeAll：异步执行指定任务，等待完成才返回结果；</li>\n<li>submit：异步执行指定任务，并立即返回一个Future对象；</li>\n</ol>\n<ul>\n<li><strong>ForkJoinTask</strong></li>\n</ul>\n<p>Fork&#x2F;Join框架中的实际的执行任务类，有以下两种实现，一般继承这两种实现类即可。</p>\n<ol>\n<li>RecursiveAction：用于无结果返回的子任务；</li>\n<li>RecursiveTask：用于有结果返回的子任务；</li>\n</ol>\n<h4 id=\"Fork-Join框架实战\"><a href=\"#Fork-Join框架实战\" class=\"headerlink\" title=\"Fork&#x2F;Join框架实战\"></a>Fork&#x2F;Join框架实战</h4><p>下面实现一个Fork&#x2F;Join小例子，从1+2+…10亿，每个任务只能处理1000个数相加，超过1000个的自动分解成小任务并行处理；并展示了通过不使用Fork&#x2F;Join和使用时的时间损耗对比。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.RecursiveTask;\n\npublic class ForkJoinTask extends RecursiveTask&lt;Long&gt; &#123;\n\n\tprivate static final long MAX &#x3D; 1000000000L;\n\tprivate static final long THRESHOLD &#x3D; 1000L;\n\tprivate long start;\n\tprivate long end;\n\n\tpublic ForkJoinTask(long start, long end) &#123;\n\t\tthis.start &#x3D; start;\n\t\tthis.end &#x3D; end;\n\t&#125;\n\n\tpublic static void main(String[] args) &#123;\n\t\ttest();\n\t\tSystem.out.println(&quot;--------------------&quot;);\n\t\ttestForkJoin();\n\t&#125;\n\n\tprivate static void test() &#123;\n\t\tSystem.out.println(&quot;test&quot;);\n\t\tlong start &#x3D; System.currentTimeMillis();\n\t\tLong sum &#x3D; 0L;\n\t\tfor (long i &#x3D; 0L; i &lt;&#x3D; MAX; i++) &#123;\n\t\t\tsum +&#x3D; i;\n\t\t&#125;\n\t\tSystem.out.println(sum);\n\t\tSystem.out.println(System.currentTimeMillis() - start + &quot;ms&quot;);\n\t&#125;\n\n\tprivate static void testForkJoin() &#123;\n\t\tSystem.out.println(&quot;testForkJoin&quot;);\n\t\tlong start &#x3D; System.currentTimeMillis();\n\t\tForkJoinPool forkJoinPool &#x3D; new ForkJoinPool();\n\t\tLong sum &#x3D; forkJoinPool.invoke(new ForkJoinTask(1, MAX));\n\t\tSystem.out.println(sum);\n\t\tSystem.out.println(System.currentTimeMillis() - start + &quot;ms&quot;);\n\t&#125;\n\n\t@Override\n\tprotected Long compute() &#123;\n\t\tlong sum &#x3D; 0;\n\t\tif (end - start &lt;&#x3D; THRESHOLD) &#123;\n\t\t\tfor (long i &#x3D; start; i &lt;&#x3D; end; i++) &#123;\n\t\t\t\tsum +&#x3D; i;\n\t\t\t&#125;\n\t\t\treturn sum;\n\t\t&#125; else &#123;\n\t\t\tlong mid &#x3D; (start + end) &#x2F; 2;\n\n\t\t\tForkJoinTask task1 &#x3D; new ForkJoinTask(start, mid);\n\t\t\ttask1.fork();\n\n\t\t\tForkJoinTask task2 &#x3D; new ForkJoinTask(mid + 1, end);\n\t\t\ttask2.fork();\n\n\t\t\treturn task1.join() + task2.join();\n\t\t&#125;\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里需要计算结果，所以任务继承的是RecursiveTask类。ForkJoinTask需要实现compute方法，在这个方法里首先需要判断任务是否小于等于阈值1000，如果是就直接执行任务。否则分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成孙任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会阻塞并等待子任务执行完并得到其结果。</p>\n<p>程序输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">test\n500000000500000000\n4992ms\n--------------------\ntestForkJoin\n500000000500000000\n508ms<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从结果看出，并行的时间损耗明显要少于串行的，这就是并行任务的好处。</p>\n<p>尽管如此，在使用Fork&#x2F;Join时也得注意，不要盲目使用。</p>\n<ol>\n<li>如果任务拆解的很深，系统内的线程数量堆积，导致系统性能性能严重下降；</li>\n<li>如果函数的调用栈很深，会导致栈内存溢出；</li>\n</ol>\n","excerpt":"","more":"<h4 id=\"Fork-Join是什么？\"><a href=\"#Fork-Join是什么？\" class=\"headerlink\" title=\"Fork&#x2F;Join是什么？\"></a>Fork&#x2F;Join是什么？</h4><p>Fork&#x2F;Join框架是Java7提供的并行执行任务框架，思想是将大任务分解成小任务，然后小任务又可以继续分解，然后每个小任务分别计算出结果再合并起来，最后将汇总的结果作为大任务结果。其思想和MapReduce的思想非常类似。对于任务的分割，要求各个子任务之间相互独立，能够并行独立地执行任务，互相之间不影响。</p>\n<p><strong>Fork&#x2F;Join的运行流程图如下：</strong></p>\n<p><img src=\"https://res.infoq.com/articles/fork-join-introduction/zh/resources/21.png\" alt=\"image\"></p>\n<p>我们可以通过Fork&#x2F;Join单词字面上的意思去理解这个框架。Fork是叉子分叉的意思，即将大任务分解成并行的小任务，Join是连接结合的意思，即将所有并行的小任务的执行结果汇总起来。</p>\n<p><img src=\"http://java.boot.by/ocpjp7-upgrade/images/040501.gif\" alt=\"image\"></p>\n<h4 id=\"工作窃取算法\"><a href=\"#工作窃取算法\" class=\"headerlink\" title=\"工作窃取算法\"></a>工作窃取算法</h4><p>ForkJoin采用了工作窃取（work-stealing）算法，若一个工作线程的任务队列为空没有任务执行时，便从其他工作线程中获取任务主动执行。为了实现工作窃取，在工作线程中维护了双端队列，窃取任务线程从队尾获取任务，被窃取任务线程从队头获取任务。这种机制充分利用线程进行并行计算，减少了线程竞争。但是当队列中只存在一个任务了时，两个线程去取反而会造成资源浪费。</p>\n<p><strong>工作窃取的运行流程图如下：</strong></p>\n<p><img src=\"https://res.infoq.com/articles/fork-join-introduction/zh/resources/image3.png\" alt=\"image\"></p>\n<h4 id=\"Fork-Join核心类\"><a href=\"#Fork-Join核心类\" class=\"headerlink\" title=\"Fork&#x2F;Join核心类\"></a>Fork&#x2F;Join核心类</h4><p>Fork&#x2F;Join框架主要由子任务、任务调度两部分组成，类层次图如下。</p>\n<p><img src=\"http://img.blog.csdn.net/20160720172854109\" alt=\"image\"></p>\n<ul>\n<li><strong>ForkJoinPool</strong></li>\n</ul>\n<p>ForkJoinPool是ForkJoin框架中的任务调度器，和ThreadPoolExecutor一样实现了自己的线程池，提供了三种调度子任务的方法：</p>\n<ol>\n<li>execute：异步执行指定任务，无返回结果；</li>\n<li>invoke、invokeAll：异步执行指定任务，等待完成才返回结果；</li>\n<li>submit：异步执行指定任务，并立即返回一个Future对象；</li>\n</ol>\n<ul>\n<li><strong>ForkJoinTask</strong></li>\n</ul>\n<p>Fork&#x2F;Join框架中的实际的执行任务类，有以下两种实现，一般继承这两种实现类即可。</p>\n<ol>\n<li>RecursiveAction：用于无结果返回的子任务；</li>\n<li>RecursiveTask：用于有结果返回的子任务；</li>\n</ol>\n<h4 id=\"Fork-Join框架实战\"><a href=\"#Fork-Join框架实战\" class=\"headerlink\" title=\"Fork&#x2F;Join框架实战\"></a>Fork&#x2F;Join框架实战</h4><p>下面实现一个Fork&#x2F;Join小例子，从1+2+…10亿，每个任务只能处理1000个数相加，超过1000个的自动分解成小任务并行处理；并展示了通过不使用Fork&#x2F;Join和使用时的时间损耗对比。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.RecursiveTask;\n\npublic class ForkJoinTask extends RecursiveTask&lt;Long&gt; &#123;\n\n\tprivate static final long MAX &#x3D; 1000000000L;\n\tprivate static final long THRESHOLD &#x3D; 1000L;\n\tprivate long start;\n\tprivate long end;\n\n\tpublic ForkJoinTask(long start, long end) &#123;\n\t\tthis.start &#x3D; start;\n\t\tthis.end &#x3D; end;\n\t&#125;\n\n\tpublic static void main(String[] args) &#123;\n\t\ttest();\n\t\tSystem.out.println(&quot;--------------------&quot;);\n\t\ttestForkJoin();\n\t&#125;\n\n\tprivate static void test() &#123;\n\t\tSystem.out.println(&quot;test&quot;);\n\t\tlong start &#x3D; System.currentTimeMillis();\n\t\tLong sum &#x3D; 0L;\n\t\tfor (long i &#x3D; 0L; i &lt;&#x3D; MAX; i++) &#123;\n\t\t\tsum +&#x3D; i;\n\t\t&#125;\n\t\tSystem.out.println(sum);\n\t\tSystem.out.println(System.currentTimeMillis() - start + &quot;ms&quot;);\n\t&#125;\n\n\tprivate static void testForkJoin() &#123;\n\t\tSystem.out.println(&quot;testForkJoin&quot;);\n\t\tlong start &#x3D; System.currentTimeMillis();\n\t\tForkJoinPool forkJoinPool &#x3D; new ForkJoinPool();\n\t\tLong sum &#x3D; forkJoinPool.invoke(new ForkJoinTask(1, MAX));\n\t\tSystem.out.println(sum);\n\t\tSystem.out.println(System.currentTimeMillis() - start + &quot;ms&quot;);\n\t&#125;\n\n\t@Override\n\tprotected Long compute() &#123;\n\t\tlong sum &#x3D; 0;\n\t\tif (end - start &lt;&#x3D; THRESHOLD) &#123;\n\t\t\tfor (long i &#x3D; start; i &lt;&#x3D; end; i++) &#123;\n\t\t\t\tsum +&#x3D; i;\n\t\t\t&#125;\n\t\t\treturn sum;\n\t\t&#125; else &#123;\n\t\t\tlong mid &#x3D; (start + end) &#x2F; 2;\n\n\t\t\tForkJoinTask task1 &#x3D; new ForkJoinTask(start, mid);\n\t\t\ttask1.fork();\n\n\t\t\tForkJoinTask task2 &#x3D; new ForkJoinTask(mid + 1, end);\n\t\t\ttask2.fork();\n\n\t\t\treturn task1.join() + task2.join();\n\t\t&#125;\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里需要计算结果，所以任务继承的是RecursiveTask类。ForkJoinTask需要实现compute方法，在这个方法里首先需要判断任务是否小于等于阈值1000，如果是就直接执行任务。否则分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成孙任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会阻塞并等待子任务执行完并得到其结果。</p>\n<p>程序输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">test\n500000000500000000\n4992ms\n--------------------\ntestForkJoin\n500000000500000000\n508ms<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从结果看出，并行的时间损耗明显要少于串行的，这就是并行任务的好处。</p>\n<p>尽管如此，在使用Fork&#x2F;Join时也得注意，不要盲目使用。</p>\n<ol>\n<li>如果任务拆解的很深，系统内的线程数量堆积，导致系统性能性能严重下降；</li>\n<li>如果函数的调用栈很深，会导致栈内存溢出；</li>\n</ol>\n"},{"title":"教你如何监控 Java 线程池运行状态","date":"2025-10-14T06:42:34.000Z","_content":"\n\n\n如果你想监控某一个线程池的执行状态，线程池执行类 `ThreadPoolExecutor ` 也给出了相关的 API, 能实时获取线程池的当前活动线程数、正在排队中的线程数、已经执行完成的线程数、总线程数等。\n\n> 总线程数 = 排队线程数 + 活动线程数 +  执行完成的线程数。\n\n下面给出一个线程池使用示例，及教你获取线程池状态。\n\n\n```\nprivate static ExecutorService es = new ThreadPoolExecutor(50, 100, 0L, TimeUnit.MILLISECONDS,\n\t\t\tnew LinkedBlockingQueue<Runnable>(100000));\n\npublic static void main(String[] args) throws Exception {\n\tfor (int i = 0; i < 100000; i++) {\n\t\tes.execute(() -> {\n\t\t\tSystem.out.print(1);\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t});\n\t}\n\n\tThreadPoolExecutor tpe = ((ThreadPoolExecutor) es);\n\n\twhile (true) {\n\t\tSystem.out.println();\n\n\t\tint queueSize = tpe.getQueue().size();\n\t\tSystem.out.println(\"当前排队线程数：\" + queueSize);\n\n\t\tint activeCount = tpe.getActiveCount();\n\t\tSystem.out.println(\"当前活动线程数：\" + activeCount);\n\n\t\tlong completedTaskCount = tpe.getCompletedTaskCount();\n\t\tSystem.out.println(\"执行完成线程数：\" + completedTaskCount);\n\n\t\tlong taskCount = tpe.getTaskCount();\n\t\tSystem.out.println(\"总线程数：\" + taskCount);\n\n\t\tThread.sleep(3000);\n\t}\n\n}\n```\n\n线程池提交了 100000 个任务，但同时只有 50 个线程在执行工作，我们每陋 3 秒来获取当前线程池的运行状态。\n\n第一次程序输出：\n\n```\n当前排队线程数：99950\n当前活动线程数：50\n执行完成线程数：0\n总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000\n```\n\n第二次程序输出：\n\n```\n当前排队线程数：99800\n当前活动线程数：50\n执行完成线程数：150\n总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000\n```\n\n活动线程数和总线程数是不变的，排队中的线程数和执行完成的线程数不断在变化，直到所有任务执行完毕，最后输出：\n\n```\n当前排队线程数：0\n当前活动线程数：0\n执行完成线程数：100000\n总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000\n```\n\n这样，你了解了这些 API 的使用方法，你想监控线程池的状态就非常方便了。\n\n","source":"_posts/多线程/教你如何监控 Java 线程池运行状态.md","raw":"---\ntitle: 教你如何监控 Java 线程池运行状态\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 多线程\n---\n\n\n\n如果你想监控某一个线程池的执行状态，线程池执行类 `ThreadPoolExecutor ` 也给出了相关的 API, 能实时获取线程池的当前活动线程数、正在排队中的线程数、已经执行完成的线程数、总线程数等。\n\n> 总线程数 = 排队线程数 + 活动线程数 +  执行完成的线程数。\n\n下面给出一个线程池使用示例，及教你获取线程池状态。\n\n\n```\nprivate static ExecutorService es = new ThreadPoolExecutor(50, 100, 0L, TimeUnit.MILLISECONDS,\n\t\t\tnew LinkedBlockingQueue<Runnable>(100000));\n\npublic static void main(String[] args) throws Exception {\n\tfor (int i = 0; i < 100000; i++) {\n\t\tes.execute(() -> {\n\t\t\tSystem.out.print(1);\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t});\n\t}\n\n\tThreadPoolExecutor tpe = ((ThreadPoolExecutor) es);\n\n\twhile (true) {\n\t\tSystem.out.println();\n\n\t\tint queueSize = tpe.getQueue().size();\n\t\tSystem.out.println(\"当前排队线程数：\" + queueSize);\n\n\t\tint activeCount = tpe.getActiveCount();\n\t\tSystem.out.println(\"当前活动线程数：\" + activeCount);\n\n\t\tlong completedTaskCount = tpe.getCompletedTaskCount();\n\t\tSystem.out.println(\"执行完成线程数：\" + completedTaskCount);\n\n\t\tlong taskCount = tpe.getTaskCount();\n\t\tSystem.out.println(\"总线程数：\" + taskCount);\n\n\t\tThread.sleep(3000);\n\t}\n\n}\n```\n\n线程池提交了 100000 个任务，但同时只有 50 个线程在执行工作，我们每陋 3 秒来获取当前线程池的运行状态。\n\n第一次程序输出：\n\n```\n当前排队线程数：99950\n当前活动线程数：50\n执行完成线程数：0\n总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000\n```\n\n第二次程序输出：\n\n```\n当前排队线程数：99800\n当前活动线程数：50\n执行完成线程数：150\n总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000\n```\n\n活动线程数和总线程数是不变的，排队中的线程数和执行完成的线程数不断在变化，直到所有任务执行完毕，最后输出：\n\n```\n当前排队线程数：0\n当前活动线程数：0\n执行完成线程数：100000\n总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000\n```\n\n这样，你了解了这些 API 的使用方法，你想监控线程池的状态就非常方便了。\n\n","slug":"多线程/教你如何监控 Java 线程池运行状态","published":1,"updated":"2025-10-15T07:20:24.986Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076r002xqkd40why35oe","content":"<p>如果你想监控某一个线程池的执行状态，线程池执行类 <code>ThreadPoolExecutor </code> 也给出了相关的 API, 能实时获取线程池的当前活动线程数、正在排队中的线程数、已经执行完成的线程数、总线程数等。</p>\n<blockquote>\n<p>总线程数 &#x3D; 排队线程数 + 活动线程数 +  执行完成的线程数。</p>\n</blockquote>\n<p>下面给出一个线程池使用示例，及教你获取线程池状态。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static ExecutorService es &#x3D; new ThreadPoolExecutor(50, 100, 0L, TimeUnit.MILLISECONDS,\n\t\t\tnew LinkedBlockingQueue&lt;Runnable&gt;(100000));\n\npublic static void main(String[] args) throws Exception &#123;\n\tfor (int i &#x3D; 0; i &lt; 100000; i++) &#123;\n\t\tes.execute(() -&gt; &#123;\n\t\t\tSystem.out.print(1);\n\t\t\ttry &#123;\n\t\t\t\tThread.sleep(1000);\n\t\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\t\te.printStackTrace();\n\t\t\t&#125;\n\t\t&#125;);\n\t&#125;\n\n\tThreadPoolExecutor tpe &#x3D; ((ThreadPoolExecutor) es);\n\n\twhile (true) &#123;\n\t\tSystem.out.println();\n\n\t\tint queueSize &#x3D; tpe.getQueue().size();\n\t\tSystem.out.println(&quot;当前排队线程数：&quot; + queueSize);\n\n\t\tint activeCount &#x3D; tpe.getActiveCount();\n\t\tSystem.out.println(&quot;当前活动线程数：&quot; + activeCount);\n\n\t\tlong completedTaskCount &#x3D; tpe.getCompletedTaskCount();\n\t\tSystem.out.println(&quot;执行完成线程数：&quot; + completedTaskCount);\n\n\t\tlong taskCount &#x3D; tpe.getTaskCount();\n\t\tSystem.out.println(&quot;总线程数：&quot; + taskCount);\n\n\t\tThread.sleep(3000);\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>线程池提交了 100000 个任务，但同时只有 50 个线程在执行工作，我们每陋 3 秒来获取当前线程池的运行状态。</p>\n<p>第一次程序输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">当前排队线程数：99950\n当前活动线程数：50\n执行完成线程数：0\n总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>第二次程序输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">当前排队线程数：99800\n当前活动线程数：50\n执行完成线程数：150\n总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>活动线程数和总线程数是不变的，排队中的线程数和执行完成的线程数不断在变化，直到所有任务执行完毕，最后输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">当前排队线程数：0\n当前活动线程数：0\n执行完成线程数：100000\n总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这样，你了解了这些 API 的使用方法，你想监控线程池的状态就非常方便了。</p>\n","excerpt":"","more":"<p>如果你想监控某一个线程池的执行状态，线程池执行类 <code>ThreadPoolExecutor </code> 也给出了相关的 API, 能实时获取线程池的当前活动线程数、正在排队中的线程数、已经执行完成的线程数、总线程数等。</p>\n<blockquote>\n<p>总线程数 &#x3D; 排队线程数 + 活动线程数 +  执行完成的线程数。</p>\n</blockquote>\n<p>下面给出一个线程池使用示例，及教你获取线程池状态。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static ExecutorService es &#x3D; new ThreadPoolExecutor(50, 100, 0L, TimeUnit.MILLISECONDS,\n\t\t\tnew LinkedBlockingQueue&lt;Runnable&gt;(100000));\n\npublic static void main(String[] args) throws Exception &#123;\n\tfor (int i &#x3D; 0; i &lt; 100000; i++) &#123;\n\t\tes.execute(() -&gt; &#123;\n\t\t\tSystem.out.print(1);\n\t\t\ttry &#123;\n\t\t\t\tThread.sleep(1000);\n\t\t\t&#125; catch (InterruptedException e) &#123;\n\t\t\t\te.printStackTrace();\n\t\t\t&#125;\n\t\t&#125;);\n\t&#125;\n\n\tThreadPoolExecutor tpe &#x3D; ((ThreadPoolExecutor) es);\n\n\twhile (true) &#123;\n\t\tSystem.out.println();\n\n\t\tint queueSize &#x3D; tpe.getQueue().size();\n\t\tSystem.out.println(&quot;当前排队线程数：&quot; + queueSize);\n\n\t\tint activeCount &#x3D; tpe.getActiveCount();\n\t\tSystem.out.println(&quot;当前活动线程数：&quot; + activeCount);\n\n\t\tlong completedTaskCount &#x3D; tpe.getCompletedTaskCount();\n\t\tSystem.out.println(&quot;执行完成线程数：&quot; + completedTaskCount);\n\n\t\tlong taskCount &#x3D; tpe.getTaskCount();\n\t\tSystem.out.println(&quot;总线程数：&quot; + taskCount);\n\n\t\tThread.sleep(3000);\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>线程池提交了 100000 个任务，但同时只有 50 个线程在执行工作，我们每陋 3 秒来获取当前线程池的运行状态。</p>\n<p>第一次程序输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">当前排队线程数：99950\n当前活动线程数：50\n执行完成线程数：0\n总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>第二次程序输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">当前排队线程数：99800\n当前活动线程数：50\n执行完成线程数：150\n总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>活动线程数和总线程数是不变的，排队中的线程数和执行完成的线程数不断在变化，直到所有任务执行完毕，最后输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">当前排队线程数：0\n当前活动线程数：0\n执行完成线程数：100000\n总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这样，你了解了这些 API 的使用方法，你想监控线程池的状态就非常方便了。</p>\n"},{"title":"线程休眠只会用Thread.sleep？那就弱爆了！","date":"2025-10-14T06:42:34.000Z","_content":"\n线程休眠是 Java 开发经常会用到的一个手段，就是让当前线程睡一会儿，睡醒之后再继续运行。\n\n咱大多数程序员，多线程虽然学得不好，但线程休眠，无人不知，无人不晓，也都会用，不就是用 Thread.sleep 方法嘛！而且还将它用到那么绝，之前不是还有人写过休眠排序算法和休眠取时间的算法，再来回味下这么脑洞大开的两个算法：\n\n- [休眠排序算法](https://mp.weixin.qq.com/s/Or3q3souk1GGVNB2qvEY2Q)\n- [休眠取时间算法](https://mp.weixin.qq.com/s/Or3q3souk1GGVNB2qvEY2Q)\n\n笑过之后，当然，这不是咋今天要讲的主题，栈长今天要讲的是如何更优雅的让线程休眠。\n\n**来看下面的休眠程序：**\n\n```\nThread.sleep(87000000);\n```\n\n你知道休眠多久吗？\n\n醉了……\n\n**再把上面的稍微改装下：**\n\n```\nThread.sleep(24 * 60 * 60 * 1000 + 10 * 60 * 1000);\n```\n\n现在你估计大概能知道休眠多久了，但还是很茫然，很无助，不写注释，谁知道休眠多久？单位还是毫秒。。\n\n其实就是休眠 24 小时 10 分钟，何必整这么麻烦呢？\n\n**优雅又简单的方式来了：**\n\n```\nTimeUnit.DAYS.sleep(1);\nTimeUnit.MINUTES.sleep(10);\n\n或者 \n\nTimeUnit.HOURS.sleep(24);\nTimeUnit.MINUTES.sleep(10);\n```\n\n使用 `java.util.concurrent.TimeUnit` 类就可以优雅的搞定，不需要过多的单位运算及修饰，是不是很优雅，很简单？\n\n上面演示了 HOURS、MINUTES，还有更多的枚举可以用。\n\n**来看下 TimeUnit 的详细方法和枚举值：**\n\n![](http://img.javastack.cn/TimeUnit.png)\n\n其实 TimeUnit 还可以用来做时间单位转换，TimeUnit 提供了各种丰富的时间单位转换方法。\n\n我们随便来看一个枚举值：\n\n```\nMINUTES {\n    public long toNanos(long d)   { return x(d, C4/C0, MAX/(C4/C0)); }\n    public long toMicros(long d)  { return x(d, C4/C1, MAX/(C4/C1)); }\n    public long toMillis(long d)  { return x(d, C4/C2, MAX/(C4/C2)); }\n    public long toSeconds(long d) { return x(d, C4/C3, MAX/(C4/C3)); }\n    public long toMinutes(long d) { return d; }\n    public long toHours(long d)   { return d/(C5/C4); }\n    public long toDays(long d)    { return d/(C6/C4); }\n    public long convert(long d, TimeUnit u) { return u.toMinutes(d); }\n    int excessNanos(long d, long m) { return 0; }\n}\n```\n\n可以很方便的把分钟转换成各种单位的值。\n\n**再来看一下 TimeUnit 休眠的原理：**\n\n```\npublic void sleep(long timeout) throws InterruptedException {\n    if (timeout > 0) {\n        long ms = toMillis(timeout);\n        int ns = excessNanos(timeout, ms);\n        Thread.sleep(ms, ns);\n    }\n}\n```\n\n其实 TimeUnit 的休眠就是调用了 Thread.sleep 休眠方法，哈哈，只是把 Thread.sleep 封装了，这样，用起来很简单方便，也提高了可读性。\n\n\n","source":"_posts/多线程/线程休眠只会用Thread.sleep？那就弱爆了！.md","raw":"---\ntitle: 线程休眠只会用Thread.sleep？那就弱爆了！\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 多线程\n---\n\n线程休眠是 Java 开发经常会用到的一个手段，就是让当前线程睡一会儿，睡醒之后再继续运行。\n\n咱大多数程序员，多线程虽然学得不好，但线程休眠，无人不知，无人不晓，也都会用，不就是用 Thread.sleep 方法嘛！而且还将它用到那么绝，之前不是还有人写过休眠排序算法和休眠取时间的算法，再来回味下这么脑洞大开的两个算法：\n\n- [休眠排序算法](https://mp.weixin.qq.com/s/Or3q3souk1GGVNB2qvEY2Q)\n- [休眠取时间算法](https://mp.weixin.qq.com/s/Or3q3souk1GGVNB2qvEY2Q)\n\n笑过之后，当然，这不是咋今天要讲的主题，栈长今天要讲的是如何更优雅的让线程休眠。\n\n**来看下面的休眠程序：**\n\n```\nThread.sleep(87000000);\n```\n\n你知道休眠多久吗？\n\n醉了……\n\n**再把上面的稍微改装下：**\n\n```\nThread.sleep(24 * 60 * 60 * 1000 + 10 * 60 * 1000);\n```\n\n现在你估计大概能知道休眠多久了，但还是很茫然，很无助，不写注释，谁知道休眠多久？单位还是毫秒。。\n\n其实就是休眠 24 小时 10 分钟，何必整这么麻烦呢？\n\n**优雅又简单的方式来了：**\n\n```\nTimeUnit.DAYS.sleep(1);\nTimeUnit.MINUTES.sleep(10);\n\n或者 \n\nTimeUnit.HOURS.sleep(24);\nTimeUnit.MINUTES.sleep(10);\n```\n\n使用 `java.util.concurrent.TimeUnit` 类就可以优雅的搞定，不需要过多的单位运算及修饰，是不是很优雅，很简单？\n\n上面演示了 HOURS、MINUTES，还有更多的枚举可以用。\n\n**来看下 TimeUnit 的详细方法和枚举值：**\n\n![](http://img.javastack.cn/TimeUnit.png)\n\n其实 TimeUnit 还可以用来做时间单位转换，TimeUnit 提供了各种丰富的时间单位转换方法。\n\n我们随便来看一个枚举值：\n\n```\nMINUTES {\n    public long toNanos(long d)   { return x(d, C4/C0, MAX/(C4/C0)); }\n    public long toMicros(long d)  { return x(d, C4/C1, MAX/(C4/C1)); }\n    public long toMillis(long d)  { return x(d, C4/C2, MAX/(C4/C2)); }\n    public long toSeconds(long d) { return x(d, C4/C3, MAX/(C4/C3)); }\n    public long toMinutes(long d) { return d; }\n    public long toHours(long d)   { return d/(C5/C4); }\n    public long toDays(long d)    { return d/(C6/C4); }\n    public long convert(long d, TimeUnit u) { return u.toMinutes(d); }\n    int excessNanos(long d, long m) { return 0; }\n}\n```\n\n可以很方便的把分钟转换成各种单位的值。\n\n**再来看一下 TimeUnit 休眠的原理：**\n\n```\npublic void sleep(long timeout) throws InterruptedException {\n    if (timeout > 0) {\n        long ms = toMillis(timeout);\n        int ns = excessNanos(timeout, ms);\n        Thread.sleep(ms, ns);\n    }\n}\n```\n\n其实 TimeUnit 的休眠就是调用了 Thread.sleep 休眠方法，哈哈，只是把 Thread.sleep 封装了，这样，用起来很简单方便，也提高了可读性。\n\n\n","slug":"多线程/线程休眠只会用Thread.sleep？那就弱爆了！","published":1,"updated":"2025-10-15T07:20:25.009Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076s0030qkd4f7mb7dqg","content":"<p>线程休眠是 Java 开发经常会用到的一个手段，就是让当前线程睡一会儿，睡醒之后再继续运行。</p>\n<p>咱大多数程序员，多线程虽然学得不好，但线程休眠，无人不知，无人不晓，也都会用，不就是用 Thread.sleep 方法嘛！而且还将它用到那么绝，之前不是还有人写过休眠排序算法和休眠取时间的算法，再来回味下这么脑洞大开的两个算法：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/Or3q3souk1GGVNB2qvEY2Q\">休眠排序算法</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Or3q3souk1GGVNB2qvEY2Q\">休眠取时间算法</a></li>\n</ul>\n<p>笑过之后，当然，这不是咋今天要讲的主题，栈长今天要讲的是如何更优雅的让线程休眠。</p>\n<p><strong>来看下面的休眠程序：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Thread.sleep(87000000);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>你知道休眠多久吗？</p>\n<p>醉了……</p>\n<p><strong>再把上面的稍微改装下：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Thread.sleep(24 * 60 * 60 * 1000 + 10 * 60 * 1000);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>现在你估计大概能知道休眠多久了，但还是很茫然，很无助，不写注释，谁知道休眠多久？单位还是毫秒。。</p>\n<p>其实就是休眠 24 小时 10 分钟，何必整这么麻烦呢？</p>\n<p><strong>优雅又简单的方式来了：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">TimeUnit.DAYS.sleep(1);\nTimeUnit.MINUTES.sleep(10);\n\n或者 \n\nTimeUnit.HOURS.sleep(24);\nTimeUnit.MINUTES.sleep(10);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用 <code>java.util.concurrent.TimeUnit</code> 类就可以优雅的搞定，不需要过多的单位运算及修饰，是不是很优雅，很简单？</p>\n<p>上面演示了 HOURS、MINUTES，还有更多的枚举可以用。</p>\n<p><strong>来看下 TimeUnit 的详细方法和枚举值：</strong></p>\n<p><img src=\"http://img.javastack.cn/TimeUnit.png\"></p>\n<p>其实 TimeUnit 还可以用来做时间单位转换，TimeUnit 提供了各种丰富的时间单位转换方法。</p>\n<p>我们随便来看一个枚举值：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">MINUTES &#123;\n    public long toNanos(long d)   &#123; return x(d, C4&#x2F;C0, MAX&#x2F;(C4&#x2F;C0)); &#125;\n    public long toMicros(long d)  &#123; return x(d, C4&#x2F;C1, MAX&#x2F;(C4&#x2F;C1)); &#125;\n    public long toMillis(long d)  &#123; return x(d, C4&#x2F;C2, MAX&#x2F;(C4&#x2F;C2)); &#125;\n    public long toSeconds(long d) &#123; return x(d, C4&#x2F;C3, MAX&#x2F;(C4&#x2F;C3)); &#125;\n    public long toMinutes(long d) &#123; return d; &#125;\n    public long toHours(long d)   &#123; return d&#x2F;(C5&#x2F;C4); &#125;\n    public long toDays(long d)    &#123; return d&#x2F;(C6&#x2F;C4); &#125;\n    public long convert(long d, TimeUnit u) &#123; return u.toMinutes(d); &#125;\n    int excessNanos(long d, long m) &#123; return 0; &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以很方便的把分钟转换成各种单位的值。</p>\n<p><strong>再来看一下 TimeUnit 休眠的原理：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public void sleep(long timeout) throws InterruptedException &#123;\n    if (timeout &gt; 0) &#123;\n        long ms &#x3D; toMillis(timeout);\n        int ns &#x3D; excessNanos(timeout, ms);\n        Thread.sleep(ms, ns);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其实 TimeUnit 的休眠就是调用了 Thread.sleep 休眠方法，哈哈，只是把 Thread.sleep 封装了，这样，用起来很简单方便，也提高了可读性。</p>\n","excerpt":"","more":"<p>线程休眠是 Java 开发经常会用到的一个手段，就是让当前线程睡一会儿，睡醒之后再继续运行。</p>\n<p>咱大多数程序员，多线程虽然学得不好，但线程休眠，无人不知，无人不晓，也都会用，不就是用 Thread.sleep 方法嘛！而且还将它用到那么绝，之前不是还有人写过休眠排序算法和休眠取时间的算法，再来回味下这么脑洞大开的两个算法：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/Or3q3souk1GGVNB2qvEY2Q\">休眠排序算法</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Or3q3souk1GGVNB2qvEY2Q\">休眠取时间算法</a></li>\n</ul>\n<p>笑过之后，当然，这不是咋今天要讲的主题，栈长今天要讲的是如何更优雅的让线程休眠。</p>\n<p><strong>来看下面的休眠程序：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Thread.sleep(87000000);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>你知道休眠多久吗？</p>\n<p>醉了……</p>\n<p><strong>再把上面的稍微改装下：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Thread.sleep(24 * 60 * 60 * 1000 + 10 * 60 * 1000);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>现在你估计大概能知道休眠多久了，但还是很茫然，很无助，不写注释，谁知道休眠多久？单位还是毫秒。。</p>\n<p>其实就是休眠 24 小时 10 分钟，何必整这么麻烦呢？</p>\n<p><strong>优雅又简单的方式来了：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">TimeUnit.DAYS.sleep(1);\nTimeUnit.MINUTES.sleep(10);\n\n或者 \n\nTimeUnit.HOURS.sleep(24);\nTimeUnit.MINUTES.sleep(10);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用 <code>java.util.concurrent.TimeUnit</code> 类就可以优雅的搞定，不需要过多的单位运算及修饰，是不是很优雅，很简单？</p>\n<p>上面演示了 HOURS、MINUTES，还有更多的枚举可以用。</p>\n<p><strong>来看下 TimeUnit 的详细方法和枚举值：</strong></p>\n<p><img src=\"http://img.javastack.cn/TimeUnit.png\"></p>\n<p>其实 TimeUnit 还可以用来做时间单位转换，TimeUnit 提供了各种丰富的时间单位转换方法。</p>\n<p>我们随便来看一个枚举值：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">MINUTES &#123;\n    public long toNanos(long d)   &#123; return x(d, C4&#x2F;C0, MAX&#x2F;(C4&#x2F;C0)); &#125;\n    public long toMicros(long d)  &#123; return x(d, C4&#x2F;C1, MAX&#x2F;(C4&#x2F;C1)); &#125;\n    public long toMillis(long d)  &#123; return x(d, C4&#x2F;C2, MAX&#x2F;(C4&#x2F;C2)); &#125;\n    public long toSeconds(long d) &#123; return x(d, C4&#x2F;C3, MAX&#x2F;(C4&#x2F;C3)); &#125;\n    public long toMinutes(long d) &#123; return d; &#125;\n    public long toHours(long d)   &#123; return d&#x2F;(C5&#x2F;C4); &#125;\n    public long toDays(long d)    &#123; return d&#x2F;(C6&#x2F;C4); &#125;\n    public long convert(long d, TimeUnit u) &#123; return u.toMinutes(d); &#125;\n    int excessNanos(long d, long m) &#123; return 0; &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以很方便的把分钟转换成各种单位的值。</p>\n<p><strong>再来看一下 TimeUnit 休眠的原理：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public void sleep(long timeout) throws InterruptedException &#123;\n    if (timeout &gt; 0) &#123;\n        long ms &#x3D; toMillis(timeout);\n        int ns &#x3D; excessNanos(timeout, ms);\n        Thread.sleep(ms, ns);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其实 TimeUnit 的休眠就是调用了 Thread.sleep 休眠方法，哈哈，只是把 Thread.sleep 封装了，这样，用起来很简单方便，也提高了可读性。</p>\n"},{"title":"面试官问线程安全的List，看完再也不怕了！","date":"2025-10-14T06:42:34.000Z","_content":"\n最近在Java技术知识星球里面有球友问到了线程安全的 List：\n\n![](http://img.javastack.cn/20190927184141.png)\n\n扫码查看答案或加入知识星球\n\n栈长在之前的文章《[出场率比较高的一道多线程安全面试题](https://mp.weixin.qq.com/s/oA-uEbzNYA4KYwLtRWXRVw)》里面讲过 ArrayList 的不安全性。\n\n那么面试官会问你，既然 ArrayList 是线程不安全的，怎么保证它的线程安全性呢？或者有什么替代方案？\n\n往下看，看我如何碾压他！\n\n大部分人会脱口而出：用Vector，这样只会让面试官鄙视！除了Vector，你还会别的吗？\n\n你至少还得说得上这种：\n\n> java.util.Collections.SynchronizedList\n\n它能把所有 List 接口的实现类转换成线程安全的List，比 Vector 有更好的扩展性和兼容性，SynchronizedList的构造方法如下：\n\n```\nfinal List<E> list;\n\nSynchronizedList(List<E> list) {\n    super(list);\n    this.list = list;\n}\n```\n\nSynchronizedList的部分方法源码如下：\n\n```\npublic E get(int index) {\n    synchronized (mutex) {return list.get(index);}\n}\npublic E set(int index, E element) {\n    synchronized (mutex) {return list.set(index, element);}\n}\npublic void add(int index, E element) {\n    synchronized (mutex) {list.add(index, element);}\n}\npublic E remove(int index) {\n    synchronized (mutex) {return list.remove(index);}\n}\n```\n\n很可惜，它所有方法都是带同步对象锁的，和 Vector 一样，它不是性能最优的。即使你能说到这里，面试官还会继续往下追问，比如在读多写少的情况，SynchronizedList这种集合性能非常差，还有没有更合适的方案？\n\n介绍两个并发包里面的并发集合类：\n\n> java.util.concurrent.CopyOnWriteArrayList\n> java.util.concurrent.CopyOnWriteArraySet\n\nCopyOnWrite集合类也就这两个，Java 1.5 开始加入，你要能说得上这两个才能让面试官信服。\n\n#### CopyOnWriteArrayList\n\nCopyOnWrite（简称：COW）：即复制再写入，就是在添加元素的时候，先把原 List 列表复制一份，再添加新的元素。\n\n\n先来看下它的 add 方法源码：\n\n```\npublic boolean add(E e) {\n    // 加锁\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        // 获取原始集合\n        Object[] elements = getArray();\n        int len = elements.length;\n        \n        // 复制一个新集合\n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n        newElements[len] = e;\n        \n        // 替换原始集合为新集合\n        setArray(newElements);\n        return true;\n    } finally {\n        // 释放锁\n        lock.unlock();\n    }\n}\n```\n\n添加元素时，先加锁，再进行复制替换操作，最后再释放锁。\n\n再来看下它的 get 方法源码：\n\n```\nprivate E get(Object[] a, int index) {\n    return (E) a[index];\n}\n\npublic E get(int index) {\n    return get(getArray(), index);\n}\n```\n\n可以看到，获取元素并没有加锁。\n\n这样做的好处是，在高并发情况下，读取元素时就不用加锁，写数据时才加锁，大大提升了读取性能。\n\n#### CopyOnWriteArraySet\n\nCopyOnWriteArraySet逻辑就更简单了，就是使用 CopyOnWriteArrayList 的 addIfAbsent 方法来去重的，添加元素的时候判断对象是否已经存在，不存在才添加进集合。\n\n```\n/**\n * Appends the element, if not present.\n *\n * @param e element to be added to this list, if absent\n * @return {@code true} if the element was added\n */\npublic boolean addIfAbsent(E e) {\n    Object[] snapshot = getArray();\n    return indexOf(e, snapshot, 0, snapshot.length) >= 0 ? false :\n        addIfAbsent(e, snapshot);\n}\n```\n\n这两种并发集合，虽然牛逼，但只适合于读多写少的情况，如果写多读少，使用这个就没意义了，因为每次写操作都要进行集合内存复制，性能开销很大，如果集合较大，很容易造成内存溢出。\n\n#### 总结\n\n下次面试官问你线程安全的 List，你可以从 Vector > SynchronizedList > CopyOnWriteArrayList 这样的顺序依次说上来，这样才有带入感，也能体现你对知识点的掌握程度。\n\n看完有没有收获呢？下次面试应该能秒杀面试官了吧！\n\n","source":"_posts/多线程/面试官问线程安全的List，看完再也不怕了！.md","raw":"---\ntitle: 面试官问线程安全的List，看完再也不怕了！\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 多线程\n---\n\n最近在Java技术知识星球里面有球友问到了线程安全的 List：\n\n![](http://img.javastack.cn/20190927184141.png)\n\n扫码查看答案或加入知识星球\n\n栈长在之前的文章《[出场率比较高的一道多线程安全面试题](https://mp.weixin.qq.com/s/oA-uEbzNYA4KYwLtRWXRVw)》里面讲过 ArrayList 的不安全性。\n\n那么面试官会问你，既然 ArrayList 是线程不安全的，怎么保证它的线程安全性呢？或者有什么替代方案？\n\n往下看，看我如何碾压他！\n\n大部分人会脱口而出：用Vector，这样只会让面试官鄙视！除了Vector，你还会别的吗？\n\n你至少还得说得上这种：\n\n> java.util.Collections.SynchronizedList\n\n它能把所有 List 接口的实现类转换成线程安全的List，比 Vector 有更好的扩展性和兼容性，SynchronizedList的构造方法如下：\n\n```\nfinal List<E> list;\n\nSynchronizedList(List<E> list) {\n    super(list);\n    this.list = list;\n}\n```\n\nSynchronizedList的部分方法源码如下：\n\n```\npublic E get(int index) {\n    synchronized (mutex) {return list.get(index);}\n}\npublic E set(int index, E element) {\n    synchronized (mutex) {return list.set(index, element);}\n}\npublic void add(int index, E element) {\n    synchronized (mutex) {list.add(index, element);}\n}\npublic E remove(int index) {\n    synchronized (mutex) {return list.remove(index);}\n}\n```\n\n很可惜，它所有方法都是带同步对象锁的，和 Vector 一样，它不是性能最优的。即使你能说到这里，面试官还会继续往下追问，比如在读多写少的情况，SynchronizedList这种集合性能非常差，还有没有更合适的方案？\n\n介绍两个并发包里面的并发集合类：\n\n> java.util.concurrent.CopyOnWriteArrayList\n> java.util.concurrent.CopyOnWriteArraySet\n\nCopyOnWrite集合类也就这两个，Java 1.5 开始加入，你要能说得上这两个才能让面试官信服。\n\n#### CopyOnWriteArrayList\n\nCopyOnWrite（简称：COW）：即复制再写入，就是在添加元素的时候，先把原 List 列表复制一份，再添加新的元素。\n\n\n先来看下它的 add 方法源码：\n\n```\npublic boolean add(E e) {\n    // 加锁\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        // 获取原始集合\n        Object[] elements = getArray();\n        int len = elements.length;\n        \n        // 复制一个新集合\n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n        newElements[len] = e;\n        \n        // 替换原始集合为新集合\n        setArray(newElements);\n        return true;\n    } finally {\n        // 释放锁\n        lock.unlock();\n    }\n}\n```\n\n添加元素时，先加锁，再进行复制替换操作，最后再释放锁。\n\n再来看下它的 get 方法源码：\n\n```\nprivate E get(Object[] a, int index) {\n    return (E) a[index];\n}\n\npublic E get(int index) {\n    return get(getArray(), index);\n}\n```\n\n可以看到，获取元素并没有加锁。\n\n这样做的好处是，在高并发情况下，读取元素时就不用加锁，写数据时才加锁，大大提升了读取性能。\n\n#### CopyOnWriteArraySet\n\nCopyOnWriteArraySet逻辑就更简单了，就是使用 CopyOnWriteArrayList 的 addIfAbsent 方法来去重的，添加元素的时候判断对象是否已经存在，不存在才添加进集合。\n\n```\n/**\n * Appends the element, if not present.\n *\n * @param e element to be added to this list, if absent\n * @return {@code true} if the element was added\n */\npublic boolean addIfAbsent(E e) {\n    Object[] snapshot = getArray();\n    return indexOf(e, snapshot, 0, snapshot.length) >= 0 ? false :\n        addIfAbsent(e, snapshot);\n}\n```\n\n这两种并发集合，虽然牛逼，但只适合于读多写少的情况，如果写多读少，使用这个就没意义了，因为每次写操作都要进行集合内存复制，性能开销很大，如果集合较大，很容易造成内存溢出。\n\n#### 总结\n\n下次面试官问你线程安全的 List，你可以从 Vector > SynchronizedList > CopyOnWriteArrayList 这样的顺序依次说上来，这样才有带入感，也能体现你对知识点的掌握程度。\n\n看完有没有收获呢？下次面试应该能秒杀面试官了吧！\n\n","slug":"多线程/面试官问线程安全的List，看完再也不怕了！","published":1,"updated":"2025-10-15T07:20:25.014Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076s0033qkd4ddwdap0i","content":"<p>最近在Java技术知识星球里面有球友问到了线程安全的 List：</p>\n<p><img src=\"http://img.javastack.cn/20190927184141.png\"></p>\n<p>扫码查看答案或加入知识星球</p>\n<p>栈长在之前的文章《<a href=\"https://mp.weixin.qq.com/s/oA-uEbzNYA4KYwLtRWXRVw\">出场率比较高的一道多线程安全面试题</a>》里面讲过 ArrayList 的不安全性。</p>\n<p>那么面试官会问你，既然 ArrayList 是线程不安全的，怎么保证它的线程安全性呢？或者有什么替代方案？</p>\n<p>往下看，看我如何碾压他！</p>\n<p>大部分人会脱口而出：用Vector，这样只会让面试官鄙视！除了Vector，你还会别的吗？</p>\n<p>你至少还得说得上这种：</p>\n<blockquote>\n<p>java.util.Collections.SynchronizedList</p>\n</blockquote>\n<p>它能把所有 List 接口的实现类转换成线程安全的List，比 Vector 有更好的扩展性和兼容性，SynchronizedList的构造方法如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final List&lt;E&gt; list;\n\nSynchronizedList(List&lt;E&gt; list) &#123;\n    super(list);\n    this.list &#x3D; list;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>SynchronizedList的部分方法源码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public E get(int index) &#123;\n    synchronized (mutex) &#123;return list.get(index);&#125;\n&#125;\npublic E set(int index, E element) &#123;\n    synchronized (mutex) &#123;return list.set(index, element);&#125;\n&#125;\npublic void add(int index, E element) &#123;\n    synchronized (mutex) &#123;list.add(index, element);&#125;\n&#125;\npublic E remove(int index) &#123;\n    synchronized (mutex) &#123;return list.remove(index);&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>很可惜，它所有方法都是带同步对象锁的，和 Vector 一样，它不是性能最优的。即使你能说到这里，面试官还会继续往下追问，比如在读多写少的情况，SynchronizedList这种集合性能非常差，还有没有更合适的方案？</p>\n<p>介绍两个并发包里面的并发集合类：</p>\n<blockquote>\n<p>java.util.concurrent.CopyOnWriteArrayList<br>java.util.concurrent.CopyOnWriteArraySet</p>\n</blockquote>\n<p>CopyOnWrite集合类也就这两个，Java 1.5 开始加入，你要能说得上这两个才能让面试官信服。</p>\n<h4 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h4><p>CopyOnWrite（简称：COW）：即复制再写入，就是在添加元素的时候，先把原 List 列表复制一份，再添加新的元素。</p>\n<p>先来看下它的 add 方法源码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public boolean add(E e) &#123;\n    &#x2F;&#x2F; 加锁\n    final ReentrantLock lock &#x3D; this.lock;\n    lock.lock();\n    try &#123;\n        &#x2F;&#x2F; 获取原始集合\n        Object[] elements &#x3D; getArray();\n        int len &#x3D; elements.length;\n        \n        &#x2F;&#x2F; 复制一个新集合\n        Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);\n        newElements[len] &#x3D; e;\n        \n        &#x2F;&#x2F; 替换原始集合为新集合\n        setArray(newElements);\n        return true;\n    &#125; finally &#123;\n        &#x2F;&#x2F; 释放锁\n        lock.unlock();\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>添加元素时，先加锁，再进行复制替换操作，最后再释放锁。</p>\n<p>再来看下它的 get 方法源码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private E get(Object[] a, int index) &#123;\n    return (E) a[index];\n&#125;\n\npublic E get(int index) &#123;\n    return get(getArray(), index);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看到，获取元素并没有加锁。</p>\n<p>这样做的好处是，在高并发情况下，读取元素时就不用加锁，写数据时才加锁，大大提升了读取性能。</p>\n<h4 id=\"CopyOnWriteArraySet\"><a href=\"#CopyOnWriteArraySet\" class=\"headerlink\" title=\"CopyOnWriteArraySet\"></a>CopyOnWriteArraySet</h4><p>CopyOnWriteArraySet逻辑就更简单了，就是使用 CopyOnWriteArrayList 的 addIfAbsent 方法来去重的，添加元素的时候判断对象是否已经存在，不存在才添加进集合。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * Appends the element, if not present.\n *\n * @param e element to be added to this list, if absent\n * @return &#123;@code true&#125; if the element was added\n *&#x2F;\npublic boolean addIfAbsent(E e) &#123;\n    Object[] snapshot &#x3D; getArray();\n    return indexOf(e, snapshot, 0, snapshot.length) &gt;&#x3D; 0 ? false :\n        addIfAbsent(e, snapshot);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这两种并发集合，虽然牛逼，但只适合于读多写少的情况，如果写多读少，使用这个就没意义了，因为每次写操作都要进行集合内存复制，性能开销很大，如果集合较大，很容易造成内存溢出。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>下次面试官问你线程安全的 List，你可以从 Vector &gt; SynchronizedList &gt; CopyOnWriteArrayList 这样的顺序依次说上来，这样才有带入感，也能体现你对知识点的掌握程度。</p>\n<p>看完有没有收获呢？下次面试应该能秒杀面试官了吧！</p>\n","excerpt":"","more":"<p>最近在Java技术知识星球里面有球友问到了线程安全的 List：</p>\n<p><img src=\"http://img.javastack.cn/20190927184141.png\"></p>\n<p>扫码查看答案或加入知识星球</p>\n<p>栈长在之前的文章《<a href=\"https://mp.weixin.qq.com/s/oA-uEbzNYA4KYwLtRWXRVw\">出场率比较高的一道多线程安全面试题</a>》里面讲过 ArrayList 的不安全性。</p>\n<p>那么面试官会问你，既然 ArrayList 是线程不安全的，怎么保证它的线程安全性呢？或者有什么替代方案？</p>\n<p>往下看，看我如何碾压他！</p>\n<p>大部分人会脱口而出：用Vector，这样只会让面试官鄙视！除了Vector，你还会别的吗？</p>\n<p>你至少还得说得上这种：</p>\n<blockquote>\n<p>java.util.Collections.SynchronizedList</p>\n</blockquote>\n<p>它能把所有 List 接口的实现类转换成线程安全的List，比 Vector 有更好的扩展性和兼容性，SynchronizedList的构造方法如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final List&lt;E&gt; list;\n\nSynchronizedList(List&lt;E&gt; list) &#123;\n    super(list);\n    this.list &#x3D; list;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>SynchronizedList的部分方法源码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public E get(int index) &#123;\n    synchronized (mutex) &#123;return list.get(index);&#125;\n&#125;\npublic E set(int index, E element) &#123;\n    synchronized (mutex) &#123;return list.set(index, element);&#125;\n&#125;\npublic void add(int index, E element) &#123;\n    synchronized (mutex) &#123;list.add(index, element);&#125;\n&#125;\npublic E remove(int index) &#123;\n    synchronized (mutex) &#123;return list.remove(index);&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>很可惜，它所有方法都是带同步对象锁的，和 Vector 一样，它不是性能最优的。即使你能说到这里，面试官还会继续往下追问，比如在读多写少的情况，SynchronizedList这种集合性能非常差，还有没有更合适的方案？</p>\n<p>介绍两个并发包里面的并发集合类：</p>\n<blockquote>\n<p>java.util.concurrent.CopyOnWriteArrayList<br>java.util.concurrent.CopyOnWriteArraySet</p>\n</blockquote>\n<p>CopyOnWrite集合类也就这两个，Java 1.5 开始加入，你要能说得上这两个才能让面试官信服。</p>\n<h4 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h4><p>CopyOnWrite（简称：COW）：即复制再写入，就是在添加元素的时候，先把原 List 列表复制一份，再添加新的元素。</p>\n<p>先来看下它的 add 方法源码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public boolean add(E e) &#123;\n    &#x2F;&#x2F; 加锁\n    final ReentrantLock lock &#x3D; this.lock;\n    lock.lock();\n    try &#123;\n        &#x2F;&#x2F; 获取原始集合\n        Object[] elements &#x3D; getArray();\n        int len &#x3D; elements.length;\n        \n        &#x2F;&#x2F; 复制一个新集合\n        Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);\n        newElements[len] &#x3D; e;\n        \n        &#x2F;&#x2F; 替换原始集合为新集合\n        setArray(newElements);\n        return true;\n    &#125; finally &#123;\n        &#x2F;&#x2F; 释放锁\n        lock.unlock();\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>添加元素时，先加锁，再进行复制替换操作，最后再释放锁。</p>\n<p>再来看下它的 get 方法源码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private E get(Object[] a, int index) &#123;\n    return (E) a[index];\n&#125;\n\npublic E get(int index) &#123;\n    return get(getArray(), index);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看到，获取元素并没有加锁。</p>\n<p>这样做的好处是，在高并发情况下，读取元素时就不用加锁，写数据时才加锁，大大提升了读取性能。</p>\n<h4 id=\"CopyOnWriteArraySet\"><a href=\"#CopyOnWriteArraySet\" class=\"headerlink\" title=\"CopyOnWriteArraySet\"></a>CopyOnWriteArraySet</h4><p>CopyOnWriteArraySet逻辑就更简单了，就是使用 CopyOnWriteArrayList 的 addIfAbsent 方法来去重的，添加元素的时候判断对象是否已经存在，不存在才添加进集合。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * Appends the element, if not present.\n *\n * @param e element to be added to this list, if absent\n * @return &#123;@code true&#125; if the element was added\n *&#x2F;\npublic boolean addIfAbsent(E e) &#123;\n    Object[] snapshot &#x3D; getArray();\n    return indexOf(e, snapshot, 0, snapshot.length) &gt;&#x3D; 0 ? false :\n        addIfAbsent(e, snapshot);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这两种并发集合，虽然牛逼，但只适合于读多写少的情况，如果写多读少，使用这个就没意义了，因为每次写操作都要进行集合内存复制，性能开销很大，如果集合较大，很容易造成内存溢出。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>下次面试官问你线程安全的 List，你可以从 Vector &gt; SynchronizedList &gt; CopyOnWriteArrayList 这样的顺序依次说上来，这样才有带入感，也能体现你对知识点的掌握程度。</p>\n<p>看完有没有收获呢？下次面试应该能秒杀面试官了吧！</p>\n"},{"title":"10 个深恶痛绝的 Java 异常","date":"2025-10-14T06:42:34.000Z","_content":"\n异常是 Java 程序中经常遇到的问题，我想每一个 Java 程序员都讨厌异常，一 个异常就是一个 BUG，就要花很多时间来定位异常问题。\n\n> 什么是异常及异常的分类请看这篇文章：[一张图搞清楚 Java 异常机制](https://mp.weixin.qq.com/s/xbopgxZ5BEDdSvwO9ad9Xg)。\n\n今天，栈长来列一下 Java 中经常遇到的前 10 个异常，排名不分先后。\n\n## 1、NullPointerException\n\n空指针异常，操作一个 null 对象的方法或属性时会抛出这个异常。具体看这篇文章：[Java 避免空指针的 5 个案例](https://mp.weixin.qq.com/s/cmkKuhEZl1qx6TXPxvA5pw)。\n\n## 2、OutOfMemoryError\n\n内存异常异常，这不是程序能控制的，是指要分配的对象的内存超出了当前最大的堆内存，需要调整堆内存大小（-Xmx）以及优化程序。\n\n## 3、IOException\n\nIO，即：input, output，我们在读写磁盘文件、网络内容的时候经常会生的一种异常，这种异常是受检查异常，需要进行手工捕获。\n\n如文件读写会抛出 IOException：\n\n```\npublic int read() throws IOException\npublic void write(int b) throws IOException\n```\n\n## 4、FileNotFoundException\n\n文件找不到异常，如果文件不存在就会抛出这种异常。\n\n如定义输入输出文件流，文件不存在会报错：\n\n```\npublic FileInputStream(File file) throws FileNotFoundException\npublic FileOutputStream(File file) throws FileNotFoundException\n```\n\nFileNotFoundException 其实是 IOException 的子类，同样是受检查异常，需要进行手工捕获。\n\n## 5、ClassNotFoundException\n\n类找不到异常，Java开发中经常遇到，是不是很绝望？这是在加载类的时候抛出来的，即在类路径下不能加载指定的类。\n\n看一个示例：\n\n```\npublic static <T> Class<T> getExistingClass(ClassLoader classLoader, String className) {\n  try {\n     return (Class<T>) Class.forName(className, true, classLoader);\n  }\n  catch (ClassNotFoundException e) {\n     return null;\n  }\n}\n```\n\n它是受检查异常，需要进行手工捕获。\n\n## 6、ClassCastException\n\n类转换异常，将一个不是该类的实例转换成这个类就会抛出这个异常。\n\n如将一个数字强制转换成字符串就会报这个异常：\n\n```\nObject x = new Integer(0);\nSystem.out.println((String)x);\n```\n\n这是运行时异常，不需要手工捕获。\n\n## 7、NoSuchMethodException\n\n没有这个方法异常，一般发生在反射调用方法的时候，如：\n\n```\npublic Method getMethod(String name, Class<?>... parameterTypes)\n    throws NoSuchMethodException, SecurityException {\n    checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);\n    Method method = getMethod0(name, parameterTypes, true);\n    if (method == null) {\n        throw new NoSuchMethodException(getName() + \".\" + name + argumentTypesToString(parameterTypes));\n    }\n    return method;\n}\n```\n\n它是受检查异常，需要进行手工捕获。\n\n## 8、IndexOutOfBoundsException\n\n索引越界异常，当操作一个字符串或者数组的时候经常遇到的异常。\n\n![](http://qianniu.javastack.cn/18-12-12/80818264.jpg)\n\n如图所示，它是运行时异常，不需要手工捕获。\n\n## 9、ArithmeticException\n\n算术异常，发生在数字的算术运算时的异常，如一个数字除以 0 就会报这个错。\n\n```\ndouble n = 3 / 0;\n```\n\n这个异常虽然是运行时异常，可以手工捕获抛出自定义的异常，如：\n\n```\npublic static Timestamp from(Instant instant) {\n    try {\n        Timestamp stamp = new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);\n        stamp.nanos = instant.getNano();\n        return stamp;\n    } catch (ArithmeticException ex) {\n        throw new IllegalArgumentException(ex);\n    }\n}\n```\n\n## 10、SQLException\n\nSQL异常，发生在操作数据库时的异常。\n\n如下面的获取连接：\n\n```\npublic Connection getConnection() throws SQLException {\n    if (getUser() == null) {\n        return DriverManager.getConnection(url);\n    } else {\n        return DriverManager.getConnection(url, getUser(), getPassword());\n    }\n}\n```\n\n又或者是获取下一条记录的时候：\n\n```\nboolean next() throws SQLException;\n```\n\n它是受检查异常，需要进行手工捕获。\n\n\n","source":"_posts/基础/10 个深恶痛绝的 Java 异常.md","raw":"---\ntitle: 10 个深恶痛绝的 Java 异常\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 基础\n---\n\n异常是 Java 程序中经常遇到的问题，我想每一个 Java 程序员都讨厌异常，一 个异常就是一个 BUG，就要花很多时间来定位异常问题。\n\n> 什么是异常及异常的分类请看这篇文章：[一张图搞清楚 Java 异常机制](https://mp.weixin.qq.com/s/xbopgxZ5BEDdSvwO9ad9Xg)。\n\n今天，栈长来列一下 Java 中经常遇到的前 10 个异常，排名不分先后。\n\n## 1、NullPointerException\n\n空指针异常，操作一个 null 对象的方法或属性时会抛出这个异常。具体看这篇文章：[Java 避免空指针的 5 个案例](https://mp.weixin.qq.com/s/cmkKuhEZl1qx6TXPxvA5pw)。\n\n## 2、OutOfMemoryError\n\n内存异常异常，这不是程序能控制的，是指要分配的对象的内存超出了当前最大的堆内存，需要调整堆内存大小（-Xmx）以及优化程序。\n\n## 3、IOException\n\nIO，即：input, output，我们在读写磁盘文件、网络内容的时候经常会生的一种异常，这种异常是受检查异常，需要进行手工捕获。\n\n如文件读写会抛出 IOException：\n\n```\npublic int read() throws IOException\npublic void write(int b) throws IOException\n```\n\n## 4、FileNotFoundException\n\n文件找不到异常，如果文件不存在就会抛出这种异常。\n\n如定义输入输出文件流，文件不存在会报错：\n\n```\npublic FileInputStream(File file) throws FileNotFoundException\npublic FileOutputStream(File file) throws FileNotFoundException\n```\n\nFileNotFoundException 其实是 IOException 的子类，同样是受检查异常，需要进行手工捕获。\n\n## 5、ClassNotFoundException\n\n类找不到异常，Java开发中经常遇到，是不是很绝望？这是在加载类的时候抛出来的，即在类路径下不能加载指定的类。\n\n看一个示例：\n\n```\npublic static <T> Class<T> getExistingClass(ClassLoader classLoader, String className) {\n  try {\n     return (Class<T>) Class.forName(className, true, classLoader);\n  }\n  catch (ClassNotFoundException e) {\n     return null;\n  }\n}\n```\n\n它是受检查异常，需要进行手工捕获。\n\n## 6、ClassCastException\n\n类转换异常，将一个不是该类的实例转换成这个类就会抛出这个异常。\n\n如将一个数字强制转换成字符串就会报这个异常：\n\n```\nObject x = new Integer(0);\nSystem.out.println((String)x);\n```\n\n这是运行时异常，不需要手工捕获。\n\n## 7、NoSuchMethodException\n\n没有这个方法异常，一般发生在反射调用方法的时候，如：\n\n```\npublic Method getMethod(String name, Class<?>... parameterTypes)\n    throws NoSuchMethodException, SecurityException {\n    checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);\n    Method method = getMethod0(name, parameterTypes, true);\n    if (method == null) {\n        throw new NoSuchMethodException(getName() + \".\" + name + argumentTypesToString(parameterTypes));\n    }\n    return method;\n}\n```\n\n它是受检查异常，需要进行手工捕获。\n\n## 8、IndexOutOfBoundsException\n\n索引越界异常，当操作一个字符串或者数组的时候经常遇到的异常。\n\n![](http://qianniu.javastack.cn/18-12-12/80818264.jpg)\n\n如图所示，它是运行时异常，不需要手工捕获。\n\n## 9、ArithmeticException\n\n算术异常，发生在数字的算术运算时的异常，如一个数字除以 0 就会报这个错。\n\n```\ndouble n = 3 / 0;\n```\n\n这个异常虽然是运行时异常，可以手工捕获抛出自定义的异常，如：\n\n```\npublic static Timestamp from(Instant instant) {\n    try {\n        Timestamp stamp = new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);\n        stamp.nanos = instant.getNano();\n        return stamp;\n    } catch (ArithmeticException ex) {\n        throw new IllegalArgumentException(ex);\n    }\n}\n```\n\n## 10、SQLException\n\nSQL异常，发生在操作数据库时的异常。\n\n如下面的获取连接：\n\n```\npublic Connection getConnection() throws SQLException {\n    if (getUser() == null) {\n        return DriverManager.getConnection(url);\n    } else {\n        return DriverManager.getConnection(url, getUser(), getPassword());\n    }\n}\n```\n\n又或者是获取下一条记录的时候：\n\n```\nboolean next() throws SQLException;\n```\n\n它是受检查异常，需要进行手工捕获。\n\n\n","slug":"基础/10 个深恶痛绝的 Java 异常","published":1,"updated":"2025-10-15T07:19:51.879Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076s0036qkd4h11xeyed","content":"<p>异常是 Java 程序中经常遇到的问题，我想每一个 Java 程序员都讨厌异常，一 个异常就是一个 BUG，就要花很多时间来定位异常问题。</p>\n<blockquote>\n<p>什么是异常及异常的分类请看这篇文章：<a href=\"https://mp.weixin.qq.com/s/xbopgxZ5BEDdSvwO9ad9Xg\">一张图搞清楚 Java 异常机制</a>。</p>\n</blockquote>\n<p>今天，栈长来列一下 Java 中经常遇到的前 10 个异常，排名不分先后。</p>\n<h2 id=\"1、NullPointerException\"><a href=\"#1、NullPointerException\" class=\"headerlink\" title=\"1、NullPointerException\"></a>1、NullPointerException</h2><p>空指针异常，操作一个 null 对象的方法或属性时会抛出这个异常。具体看这篇文章：<a href=\"https://mp.weixin.qq.com/s/cmkKuhEZl1qx6TXPxvA5pw\">Java 避免空指针的 5 个案例</a>。</p>\n<h2 id=\"2、OutOfMemoryError\"><a href=\"#2、OutOfMemoryError\" class=\"headerlink\" title=\"2、OutOfMemoryError\"></a>2、OutOfMemoryError</h2><p>内存异常异常，这不是程序能控制的，是指要分配的对象的内存超出了当前最大的堆内存，需要调整堆内存大小（-Xmx）以及优化程序。</p>\n<h2 id=\"3、IOException\"><a href=\"#3、IOException\" class=\"headerlink\" title=\"3、IOException\"></a>3、IOException</h2><p>IO，即：input, output，我们在读写磁盘文件、网络内容的时候经常会生的一种异常，这种异常是受检查异常，需要进行手工捕获。</p>\n<p>如文件读写会抛出 IOException：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public int read() throws IOException\npublic void write(int b) throws IOException<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"4、FileNotFoundException\"><a href=\"#4、FileNotFoundException\" class=\"headerlink\" title=\"4、FileNotFoundException\"></a>4、FileNotFoundException</h2><p>文件找不到异常，如果文件不存在就会抛出这种异常。</p>\n<p>如定义输入输出文件流，文件不存在会报错：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public FileInputStream(File file) throws FileNotFoundException\npublic FileOutputStream(File file) throws FileNotFoundException<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>FileNotFoundException 其实是 IOException 的子类，同样是受检查异常，需要进行手工捕获。</p>\n<h2 id=\"5、ClassNotFoundException\"><a href=\"#5、ClassNotFoundException\" class=\"headerlink\" title=\"5、ClassNotFoundException\"></a>5、ClassNotFoundException</h2><p>类找不到异常，Java开发中经常遇到，是不是很绝望？这是在加载类的时候抛出来的，即在类路径下不能加载指定的类。</p>\n<p>看一个示例：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static &lt;T&gt; Class&lt;T&gt; getExistingClass(ClassLoader classLoader, String className) &#123;\n  try &#123;\n     return (Class&lt;T&gt;) Class.forName(className, true, classLoader);\n  &#125;\n  catch (ClassNotFoundException e) &#123;\n     return null;\n  &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>它是受检查异常，需要进行手工捕获。</p>\n<h2 id=\"6、ClassCastException\"><a href=\"#6、ClassCastException\" class=\"headerlink\" title=\"6、ClassCastException\"></a>6、ClassCastException</h2><p>类转换异常，将一个不是该类的实例转换成这个类就会抛出这个异常。</p>\n<p>如将一个数字强制转换成字符串就会报这个异常：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Object x &#x3D; new Integer(0);\nSystem.out.println((String)x);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>这是运行时异常，不需要手工捕获。</p>\n<h2 id=\"7、NoSuchMethodException\"><a href=\"#7、NoSuchMethodException\" class=\"headerlink\" title=\"7、NoSuchMethodException\"></a>7、NoSuchMethodException</h2><p>没有这个方法异常，一般发生在反射调用方法的时候，如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)\n    throws NoSuchMethodException, SecurityException &#123;\n    checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);\n    Method method &#x3D; getMethod0(name, parameterTypes, true);\n    if (method &#x3D;&#x3D; null) &#123;\n        throw new NoSuchMethodException(getName() + &quot;.&quot; + name + argumentTypesToString(parameterTypes));\n    &#125;\n    return method;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>它是受检查异常，需要进行手工捕获。</p>\n<h2 id=\"8、IndexOutOfBoundsException\"><a href=\"#8、IndexOutOfBoundsException\" class=\"headerlink\" title=\"8、IndexOutOfBoundsException\"></a>8、IndexOutOfBoundsException</h2><p>索引越界异常，当操作一个字符串或者数组的时候经常遇到的异常。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-12-12/80818264.jpg\"></p>\n<p>如图所示，它是运行时异常，不需要手工捕获。</p>\n<h2 id=\"9、ArithmeticException\"><a href=\"#9、ArithmeticException\" class=\"headerlink\" title=\"9、ArithmeticException\"></a>9、ArithmeticException</h2><p>算术异常，发生在数字的算术运算时的异常，如一个数字除以 0 就会报这个错。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">double n &#x3D; 3 &#x2F; 0;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这个异常虽然是运行时异常，可以手工捕获抛出自定义的异常，如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static Timestamp from(Instant instant) &#123;\n    try &#123;\n        Timestamp stamp &#x3D; new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);\n        stamp.nanos &#x3D; instant.getNano();\n        return stamp;\n    &#125; catch (ArithmeticException ex) &#123;\n        throw new IllegalArgumentException(ex);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"10、SQLException\"><a href=\"#10、SQLException\" class=\"headerlink\" title=\"10、SQLException\"></a>10、SQLException</h2><p>SQL异常，发生在操作数据库时的异常。</p>\n<p>如下面的获取连接：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public Connection getConnection() throws SQLException &#123;\n    if (getUser() &#x3D;&#x3D; null) &#123;\n        return DriverManager.getConnection(url);\n    &#125; else &#123;\n        return DriverManager.getConnection(url, getUser(), getPassword());\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>又或者是获取下一条记录的时候：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">boolean next() throws SQLException;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>它是受检查异常，需要进行手工捕获。</p>\n","excerpt":"","more":"<p>异常是 Java 程序中经常遇到的问题，我想每一个 Java 程序员都讨厌异常，一 个异常就是一个 BUG，就要花很多时间来定位异常问题。</p>\n<blockquote>\n<p>什么是异常及异常的分类请看这篇文章：<a href=\"https://mp.weixin.qq.com/s/xbopgxZ5BEDdSvwO9ad9Xg\">一张图搞清楚 Java 异常机制</a>。</p>\n</blockquote>\n<p>今天，栈长来列一下 Java 中经常遇到的前 10 个异常，排名不分先后。</p>\n<h2 id=\"1、NullPointerException\"><a href=\"#1、NullPointerException\" class=\"headerlink\" title=\"1、NullPointerException\"></a>1、NullPointerException</h2><p>空指针异常，操作一个 null 对象的方法或属性时会抛出这个异常。具体看这篇文章：<a href=\"https://mp.weixin.qq.com/s/cmkKuhEZl1qx6TXPxvA5pw\">Java 避免空指针的 5 个案例</a>。</p>\n<h2 id=\"2、OutOfMemoryError\"><a href=\"#2、OutOfMemoryError\" class=\"headerlink\" title=\"2、OutOfMemoryError\"></a>2、OutOfMemoryError</h2><p>内存异常异常，这不是程序能控制的，是指要分配的对象的内存超出了当前最大的堆内存，需要调整堆内存大小（-Xmx）以及优化程序。</p>\n<h2 id=\"3、IOException\"><a href=\"#3、IOException\" class=\"headerlink\" title=\"3、IOException\"></a>3、IOException</h2><p>IO，即：input, output，我们在读写磁盘文件、网络内容的时候经常会生的一种异常，这种异常是受检查异常，需要进行手工捕获。</p>\n<p>如文件读写会抛出 IOException：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public int read() throws IOException\npublic void write(int b) throws IOException<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"4、FileNotFoundException\"><a href=\"#4、FileNotFoundException\" class=\"headerlink\" title=\"4、FileNotFoundException\"></a>4、FileNotFoundException</h2><p>文件找不到异常，如果文件不存在就会抛出这种异常。</p>\n<p>如定义输入输出文件流，文件不存在会报错：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public FileInputStream(File file) throws FileNotFoundException\npublic FileOutputStream(File file) throws FileNotFoundException<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>FileNotFoundException 其实是 IOException 的子类，同样是受检查异常，需要进行手工捕获。</p>\n<h2 id=\"5、ClassNotFoundException\"><a href=\"#5、ClassNotFoundException\" class=\"headerlink\" title=\"5、ClassNotFoundException\"></a>5、ClassNotFoundException</h2><p>类找不到异常，Java开发中经常遇到，是不是很绝望？这是在加载类的时候抛出来的，即在类路径下不能加载指定的类。</p>\n<p>看一个示例：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static &lt;T&gt; Class&lt;T&gt; getExistingClass(ClassLoader classLoader, String className) &#123;\n  try &#123;\n     return (Class&lt;T&gt;) Class.forName(className, true, classLoader);\n  &#125;\n  catch (ClassNotFoundException e) &#123;\n     return null;\n  &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>它是受检查异常，需要进行手工捕获。</p>\n<h2 id=\"6、ClassCastException\"><a href=\"#6、ClassCastException\" class=\"headerlink\" title=\"6、ClassCastException\"></a>6、ClassCastException</h2><p>类转换异常，将一个不是该类的实例转换成这个类就会抛出这个异常。</p>\n<p>如将一个数字强制转换成字符串就会报这个异常：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Object x &#x3D; new Integer(0);\nSystem.out.println((String)x);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>这是运行时异常，不需要手工捕获。</p>\n<h2 id=\"7、NoSuchMethodException\"><a href=\"#7、NoSuchMethodException\" class=\"headerlink\" title=\"7、NoSuchMethodException\"></a>7、NoSuchMethodException</h2><p>没有这个方法异常，一般发生在反射调用方法的时候，如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)\n    throws NoSuchMethodException, SecurityException &#123;\n    checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);\n    Method method &#x3D; getMethod0(name, parameterTypes, true);\n    if (method &#x3D;&#x3D; null) &#123;\n        throw new NoSuchMethodException(getName() + &quot;.&quot; + name + argumentTypesToString(parameterTypes));\n    &#125;\n    return method;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>它是受检查异常，需要进行手工捕获。</p>\n<h2 id=\"8、IndexOutOfBoundsException\"><a href=\"#8、IndexOutOfBoundsException\" class=\"headerlink\" title=\"8、IndexOutOfBoundsException\"></a>8、IndexOutOfBoundsException</h2><p>索引越界异常，当操作一个字符串或者数组的时候经常遇到的异常。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-12-12/80818264.jpg\"></p>\n<p>如图所示，它是运行时异常，不需要手工捕获。</p>\n<h2 id=\"9、ArithmeticException\"><a href=\"#9、ArithmeticException\" class=\"headerlink\" title=\"9、ArithmeticException\"></a>9、ArithmeticException</h2><p>算术异常，发生在数字的算术运算时的异常，如一个数字除以 0 就会报这个错。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">double n &#x3D; 3 &#x2F; 0;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这个异常虽然是运行时异常，可以手工捕获抛出自定义的异常，如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static Timestamp from(Instant instant) &#123;\n    try &#123;\n        Timestamp stamp &#x3D; new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);\n        stamp.nanos &#x3D; instant.getNano();\n        return stamp;\n    &#125; catch (ArithmeticException ex) &#123;\n        throw new IllegalArgumentException(ex);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"10、SQLException\"><a href=\"#10、SQLException\" class=\"headerlink\" title=\"10、SQLException\"></a>10、SQLException</h2><p>SQL异常，发生在操作数据库时的异常。</p>\n<p>如下面的获取连接：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public Connection getConnection() throws SQLException &#123;\n    if (getUser() &#x3D;&#x3D; null) &#123;\n        return DriverManager.getConnection(url);\n    &#125; else &#123;\n        return DriverManager.getConnection(url, getUser(), getPassword());\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>又或者是获取下一条记录的时候：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">boolean next() throws SQLException;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>它是受检查异常，需要进行手工捕获。</p>\n"},{"title":"Java Base64 编码解码方案总结","date":"2025-10-14T06:42:34.000Z","_content":"\nBase64是一种能将任意Binary资料用64种字元组合成字串的方法，而这个Binary资料和字串资料彼此之间是可以互相转换的，十分方便。在实际应用上，Base64除了能将Binary资料可视化之外，也常用来表示字串加密过后的内容。如果要使用Java 程式语言来实作Base64的编码与解码功能，可以参考本篇文章的作法。\n\n#### 早期作法\n\n早期在Java上做Base64的编码与解码，会使用到JDK里sun.misc套件下的BASE64Encoder和BASE64Decoder这两个类别，用法如下：\n\n```\nfinal BASE64Encoder encoder = new BASE64Encoder();\nfinal BASE64Decoder decoder = new BASE64Decoder();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = encoder.encode(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(decoder.decodeBuffer(encodedText), \"UTF-8\"));\n\nfinal BASE64Encoder encoder = new BASE64Encoder();\nfinal BASE64Decoder decoder = new BASE64Decoder();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = encoder.encode(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(decoder.decodeBuffer(encodedText), \"UTF-8\"));\n```\n\n\n从以上程式可以发现，在Java用Base64一点都不难，不用几行程式码就解决了！只是这个sun.mis c套件所提供的Base64功能，编码和解码的效率并不太好，而且在以后的Java版本可能就不被支援了，完全不建议使用。\n\n#### Apache Commons Codec作法\n\nApache Commons Codec有提供Base64的编码与解码功能，会使用到org.apache.commons.codec.binary套件下的Base64类别，用法如下：\n\n```\nfinal Base64 base64 = new Base64();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = base64.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(base64.decode(encodedText), \"UTF-8\"));\n\nfinal Base64 base64 = new Base64();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = base64.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(base64.decode(encodedText), \"UTF-8\"));\n```\n\n以上的程式码看起来又比早期用sun.mis c套件还要更精简，效能实际执行起来也快了不少。缺点是需要引用Apache Commons Codec，很麻烦。\n\n#### Java 8之后的作法\n\nJava 8的java.util套件中，新增了Base64的类别，可以用来处理Base64的编码与解码，用法如下：\n\n```\nfinal Base64.Decoder decoder = Base64.getDecoder();\nfinal Base64.Encoder encoder = Base64.getEncoder();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = encoder.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(decoder.decode(encodedText), \"UTF-8\"));\n\nfinal Base64.Decoder decoder = Base64.getDecoder();\nfinal Base64.Encoder encoder = Base64.getEncoder();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = encoder.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(decoder.decode(encodedText), \"UTF-8\"));\n```\n\n\n与sun.mis c套件和Apache Commons Codec所提供的Base64编解码器来比较的话，Java 8提供的Base64拥有更好的效能。实际测试编码与解码速度的话，Java 8提供的Base64，要比sun.mis c套件提供的还要快至少11倍，比Apache Commons Codec提供的还要快至少3倍。**因此在Java上若要使用Base64，这个Java 8底下的java .util套件所提供的Base64类别绝对是首选！**\n\n","source":"_posts/基础/Java Base64 编码解码方案总结.md","raw":"---\ntitle: Java Base64 编码解码方案总结\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 基础\n---\n\nBase64是一种能将任意Binary资料用64种字元组合成字串的方法，而这个Binary资料和字串资料彼此之间是可以互相转换的，十分方便。在实际应用上，Base64除了能将Binary资料可视化之外，也常用来表示字串加密过后的内容。如果要使用Java 程式语言来实作Base64的编码与解码功能，可以参考本篇文章的作法。\n\n#### 早期作法\n\n早期在Java上做Base64的编码与解码，会使用到JDK里sun.misc套件下的BASE64Encoder和BASE64Decoder这两个类别，用法如下：\n\n```\nfinal BASE64Encoder encoder = new BASE64Encoder();\nfinal BASE64Decoder decoder = new BASE64Decoder();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = encoder.encode(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(decoder.decodeBuffer(encodedText), \"UTF-8\"));\n\nfinal BASE64Encoder encoder = new BASE64Encoder();\nfinal BASE64Decoder decoder = new BASE64Decoder();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = encoder.encode(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(decoder.decodeBuffer(encodedText), \"UTF-8\"));\n```\n\n\n从以上程式可以发现，在Java用Base64一点都不难，不用几行程式码就解决了！只是这个sun.mis c套件所提供的Base64功能，编码和解码的效率并不太好，而且在以后的Java版本可能就不被支援了，完全不建议使用。\n\n#### Apache Commons Codec作法\n\nApache Commons Codec有提供Base64的编码与解码功能，会使用到org.apache.commons.codec.binary套件下的Base64类别，用法如下：\n\n```\nfinal Base64 base64 = new Base64();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = base64.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(base64.decode(encodedText), \"UTF-8\"));\n\nfinal Base64 base64 = new Base64();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = base64.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(base64.decode(encodedText), \"UTF-8\"));\n```\n\n以上的程式码看起来又比早期用sun.mis c套件还要更精简，效能实际执行起来也快了不少。缺点是需要引用Apache Commons Codec，很麻烦。\n\n#### Java 8之后的作法\n\nJava 8的java.util套件中，新增了Base64的类别，可以用来处理Base64的编码与解码，用法如下：\n\n```\nfinal Base64.Decoder decoder = Base64.getDecoder();\nfinal Base64.Encoder encoder = Base64.getEncoder();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = encoder.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(decoder.decode(encodedText), \"UTF-8\"));\n\nfinal Base64.Decoder decoder = Base64.getDecoder();\nfinal Base64.Encoder encoder = Base64.getEncoder();\nfinal String text = \"Java技术\";\nfinal byte[] textByte = text.getBytes(\"UTF-8\");\n\n//编码\nfinal String encodedText = encoder.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n//解码\nSystem.out.println(new String(decoder.decode(encodedText), \"UTF-8\"));\n```\n\n\n与sun.mis c套件和Apache Commons Codec所提供的Base64编解码器来比较的话，Java 8提供的Base64拥有更好的效能。实际测试编码与解码速度的话，Java 8提供的Base64，要比sun.mis c套件提供的还要快至少11倍，比Apache Commons Codec提供的还要快至少3倍。**因此在Java上若要使用Base64，这个Java 8底下的java .util套件所提供的Base64类别绝对是首选！**\n\n","slug":"基础/Java Base64 编码解码方案总结","published":1,"updated":"2025-10-15T07:19:51.820Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076t0039qkd43yqc2emq","content":"<p>Base64是一种能将任意Binary资料用64种字元组合成字串的方法，而这个Binary资料和字串资料彼此之间是可以互相转换的，十分方便。在实际应用上，Base64除了能将Binary资料可视化之外，也常用来表示字串加密过后的内容。如果要使用Java 程式语言来实作Base64的编码与解码功能，可以参考本篇文章的作法。</p>\n<h4 id=\"早期作法\"><a href=\"#早期作法\" class=\"headerlink\" title=\"早期作法\"></a>早期作法</h4><p>早期在Java上做Base64的编码与解码，会使用到JDK里sun.misc套件下的BASE64Encoder和BASE64Decoder这两个类别，用法如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final BASE64Encoder encoder &#x3D; new BASE64Encoder();\nfinal BASE64Decoder decoder &#x3D; new BASE64Decoder();\nfinal String text &#x3D; &quot;Java技术&quot;;\nfinal byte[] textByte &#x3D; text.getBytes(&quot;UTF-8&quot;);\n\n&#x2F;&#x2F;编码\nfinal String encodedText &#x3D; encoder.encode(textByte);\nSystem.out.println(encodedText);\n\n&#x2F;&#x2F;解码\nSystem.out.println(new String(decoder.decodeBuffer(encodedText), &quot;UTF-8&quot;));\n\nfinal BASE64Encoder encoder &#x3D; new BASE64Encoder();\nfinal BASE64Decoder decoder &#x3D; new BASE64Decoder();\nfinal String text &#x3D; &quot;Java技术&quot;;\nfinal byte[] textByte &#x3D; text.getBytes(&quot;UTF-8&quot;);\n\n&#x2F;&#x2F;编码\nfinal String encodedText &#x3D; encoder.encode(textByte);\nSystem.out.println(encodedText);\n\n&#x2F;&#x2F;解码\nSystem.out.println(new String(decoder.decodeBuffer(encodedText), &quot;UTF-8&quot;));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<p>从以上程式可以发现，在Java用Base64一点都不难，不用几行程式码就解决了！只是这个sun.mis c套件所提供的Base64功能，编码和解码的效率并不太好，而且在以后的Java版本可能就不被支援了，完全不建议使用。</p>\n<h4 id=\"Apache-Commons-Codec作法\"><a href=\"#Apache-Commons-Codec作法\" class=\"headerlink\" title=\"Apache Commons Codec作法\"></a>Apache Commons Codec作法</h4><p>Apache Commons Codec有提供Base64的编码与解码功能，会使用到org.apache.commons.codec.binary套件下的Base64类别，用法如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final Base64 base64 &#x3D; new Base64();\nfinal String text &#x3D; &quot;Java技术&quot;;\nfinal byte[] textByte &#x3D; text.getBytes(&quot;UTF-8&quot;);\n\n&#x2F;&#x2F;编码\nfinal String encodedText &#x3D; base64.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n&#x2F;&#x2F;解码\nSystem.out.println(new String(base64.decode(encodedText), &quot;UTF-8&quot;));\n\nfinal Base64 base64 &#x3D; new Base64();\nfinal String text &#x3D; &quot;Java技术&quot;;\nfinal byte[] textByte &#x3D; text.getBytes(&quot;UTF-8&quot;);\n\n&#x2F;&#x2F;编码\nfinal String encodedText &#x3D; base64.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n&#x2F;&#x2F;解码\nSystem.out.println(new String(base64.decode(encodedText), &quot;UTF-8&quot;));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上的程式码看起来又比早期用sun.mis c套件还要更精简，效能实际执行起来也快了不少。缺点是需要引用Apache Commons Codec，很麻烦。</p>\n<h4 id=\"Java-8之后的作法\"><a href=\"#Java-8之后的作法\" class=\"headerlink\" title=\"Java 8之后的作法\"></a>Java 8之后的作法</h4><p>Java 8的java.util套件中，新增了Base64的类别，可以用来处理Base64的编码与解码，用法如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final Base64.Decoder decoder &#x3D; Base64.getDecoder();\nfinal Base64.Encoder encoder &#x3D; Base64.getEncoder();\nfinal String text &#x3D; &quot;Java技术&quot;;\nfinal byte[] textByte &#x3D; text.getBytes(&quot;UTF-8&quot;);\n\n&#x2F;&#x2F;编码\nfinal String encodedText &#x3D; encoder.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n&#x2F;&#x2F;解码\nSystem.out.println(new String(decoder.decode(encodedText), &quot;UTF-8&quot;));\n\nfinal Base64.Decoder decoder &#x3D; Base64.getDecoder();\nfinal Base64.Encoder encoder &#x3D; Base64.getEncoder();\nfinal String text &#x3D; &quot;Java技术&quot;;\nfinal byte[] textByte &#x3D; text.getBytes(&quot;UTF-8&quot;);\n\n&#x2F;&#x2F;编码\nfinal String encodedText &#x3D; encoder.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n&#x2F;&#x2F;解码\nSystem.out.println(new String(decoder.decode(encodedText), &quot;UTF-8&quot;));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<p>与sun.mis c套件和Apache Commons Codec所提供的Base64编解码器来比较的话，Java 8提供的Base64拥有更好的效能。实际测试编码与解码速度的话，Java 8提供的Base64，要比sun.mis c套件提供的还要快至少11倍，比Apache Commons Codec提供的还要快至少3倍。<strong>因此在Java上若要使用Base64，这个Java 8底下的java .util套件所提供的Base64类别绝对是首选！</strong></p>\n","excerpt":"","more":"<p>Base64是一种能将任意Binary资料用64种字元组合成字串的方法，而这个Binary资料和字串资料彼此之间是可以互相转换的，十分方便。在实际应用上，Base64除了能将Binary资料可视化之外，也常用来表示字串加密过后的内容。如果要使用Java 程式语言来实作Base64的编码与解码功能，可以参考本篇文章的作法。</p>\n<h4 id=\"早期作法\"><a href=\"#早期作法\" class=\"headerlink\" title=\"早期作法\"></a>早期作法</h4><p>早期在Java上做Base64的编码与解码，会使用到JDK里sun.misc套件下的BASE64Encoder和BASE64Decoder这两个类别，用法如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final BASE64Encoder encoder &#x3D; new BASE64Encoder();\nfinal BASE64Decoder decoder &#x3D; new BASE64Decoder();\nfinal String text &#x3D; &quot;Java技术&quot;;\nfinal byte[] textByte &#x3D; text.getBytes(&quot;UTF-8&quot;);\n\n&#x2F;&#x2F;编码\nfinal String encodedText &#x3D; encoder.encode(textByte);\nSystem.out.println(encodedText);\n\n&#x2F;&#x2F;解码\nSystem.out.println(new String(decoder.decodeBuffer(encodedText), &quot;UTF-8&quot;));\n\nfinal BASE64Encoder encoder &#x3D; new BASE64Encoder();\nfinal BASE64Decoder decoder &#x3D; new BASE64Decoder();\nfinal String text &#x3D; &quot;Java技术&quot;;\nfinal byte[] textByte &#x3D; text.getBytes(&quot;UTF-8&quot;);\n\n&#x2F;&#x2F;编码\nfinal String encodedText &#x3D; encoder.encode(textByte);\nSystem.out.println(encodedText);\n\n&#x2F;&#x2F;解码\nSystem.out.println(new String(decoder.decodeBuffer(encodedText), &quot;UTF-8&quot;));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<p>从以上程式可以发现，在Java用Base64一点都不难，不用几行程式码就解决了！只是这个sun.mis c套件所提供的Base64功能，编码和解码的效率并不太好，而且在以后的Java版本可能就不被支援了，完全不建议使用。</p>\n<h4 id=\"Apache-Commons-Codec作法\"><a href=\"#Apache-Commons-Codec作法\" class=\"headerlink\" title=\"Apache Commons Codec作法\"></a>Apache Commons Codec作法</h4><p>Apache Commons Codec有提供Base64的编码与解码功能，会使用到org.apache.commons.codec.binary套件下的Base64类别，用法如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final Base64 base64 &#x3D; new Base64();\nfinal String text &#x3D; &quot;Java技术&quot;;\nfinal byte[] textByte &#x3D; text.getBytes(&quot;UTF-8&quot;);\n\n&#x2F;&#x2F;编码\nfinal String encodedText &#x3D; base64.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n&#x2F;&#x2F;解码\nSystem.out.println(new String(base64.decode(encodedText), &quot;UTF-8&quot;));\n\nfinal Base64 base64 &#x3D; new Base64();\nfinal String text &#x3D; &quot;Java技术&quot;;\nfinal byte[] textByte &#x3D; text.getBytes(&quot;UTF-8&quot;);\n\n&#x2F;&#x2F;编码\nfinal String encodedText &#x3D; base64.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n&#x2F;&#x2F;解码\nSystem.out.println(new String(base64.decode(encodedText), &quot;UTF-8&quot;));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上的程式码看起来又比早期用sun.mis c套件还要更精简，效能实际执行起来也快了不少。缺点是需要引用Apache Commons Codec，很麻烦。</p>\n<h4 id=\"Java-8之后的作法\"><a href=\"#Java-8之后的作法\" class=\"headerlink\" title=\"Java 8之后的作法\"></a>Java 8之后的作法</h4><p>Java 8的java.util套件中，新增了Base64的类别，可以用来处理Base64的编码与解码，用法如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final Base64.Decoder decoder &#x3D; Base64.getDecoder();\nfinal Base64.Encoder encoder &#x3D; Base64.getEncoder();\nfinal String text &#x3D; &quot;Java技术&quot;;\nfinal byte[] textByte &#x3D; text.getBytes(&quot;UTF-8&quot;);\n\n&#x2F;&#x2F;编码\nfinal String encodedText &#x3D; encoder.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n&#x2F;&#x2F;解码\nSystem.out.println(new String(decoder.decode(encodedText), &quot;UTF-8&quot;));\n\nfinal Base64.Decoder decoder &#x3D; Base64.getDecoder();\nfinal Base64.Encoder encoder &#x3D; Base64.getEncoder();\nfinal String text &#x3D; &quot;Java技术&quot;;\nfinal byte[] textByte &#x3D; text.getBytes(&quot;UTF-8&quot;);\n\n&#x2F;&#x2F;编码\nfinal String encodedText &#x3D; encoder.encodeToString(textByte);\nSystem.out.println(encodedText);\n\n&#x2F;&#x2F;解码\nSystem.out.println(new String(decoder.decode(encodedText), &quot;UTF-8&quot;));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<p>与sun.mis c套件和Apache Commons Codec所提供的Base64编解码器来比较的话，Java 8提供的Base64拥有更好的效能。实际测试编码与解码速度的话，Java 8提供的Base64，要比sun.mis c套件提供的还要快至少11倍，比Apache Commons Codec提供的还要快至少3倍。<strong>因此在Java上若要使用Base64，这个Java 8底下的java .util套件所提供的Base64类别绝对是首选！</strong></p>\n"},{"title":"Java 中的基本数据类型转换详解","date":"2025-10-14T06:42:34.000Z","_content":"\n![](http://img.javastack.cn/18-4-3/88886519.jpg)\n\n说基本数据类型转换之前，先了解下 Java 中的 8 种基本数据类型，以及它们的占内存的容量大小和表示的范围，如下图所示。\n\n![](http://img.javastack.cn/18-4-3/32808656.jpg)\n\n之前分享过《[深入浅出 Java 中的包装类](https://mp.weixin.qq.com/s/uoNVT9IoRQmWnmy8w22UUQ)》，现在重新温故了下原始数据类型，现在来解释下它们之间的转换关系。\n\n#### 自动类型转换\n\n自动类型转换是指：数字表示范围小的数据类型可以自动转换成范围大的数据类型。\n\n如：\n\n```\nlong l = 100;\n\nint i = 200;\nlong ll = i;\n```\n\n具体自动转换如如下图所示。\n\n![](http://img.javastack.cn/18-4-3/42423859.jpg)\n\n实线表示自动转换时不会造成数据丢失，虚线则可能会出现数据丢失问题。\n\n**自动转换也要小心数据溢出问题，看下面的例子。**\n\n```\nint count = 100000000;\nint price = 1999;\nlong totalPrice = count * price;\n```\n\n编译没任何问题，但结果却输出的是负数，这是因为两个 int 相乘得到的结果是 int, 相乘的结果超出了 int 的代表范围。这种情况，一般把第一个数据转换成范围大的数据类型再和其他的数据进行运算。\n\n```\nint count = 100000000;\nint price = 1999;\nlong totalPrice = (long) count * price;\n```\n\n另外，向下转换时可以直接将 int 常量字面量赋值给 byte、short、char 等数据类型，而不需要强制转换，只要该常量值不超过该类型的表示范围都能自动转换。\n\n#### 强制类型转换\n\n强制类型转换我们再清楚不过了，即强制显示的把一个数据类型转换为另外一种数据类型。\n\n如：\n\n```\nshort s = 199;\nint i = s;// 199\n\ndouble d = 10.24;\nlong ll = (long) d;// 10\n```\n\n以上的转换结果都在我们的预期之内，属于正常的转换和丢失精度的情况，下面的例子就一样属于数据溢出的情况。\n\n```\nint ii = 300;\nbyte b = (byte)ii;\n```\n\n300 已经超出了 byte 类型表示的范围，所以会转换成一个毫无意义的数字。\n\n#### 类型提升\n\n所谓类型提升就是指在多种不同数据类型的表达式中，类型会自动向范围表示大的值的数据类型提升。\n\n把上面的溢出的例子再改下。\n\n```\nlong count = 100000000;\nint price = 1999;\nlong totalPrice = price * count;\n```\n\nprice 为 int 型，count 为 long 型，运算结果为 long 型，运算结果正常，没有出现溢出的情况。\n\n","source":"_posts/基础/Java 中的基本数据类型转换详解.md","raw":"---\ntitle: Java 中的基本数据类型转换详解\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 基础\n---\n\n![](http://img.javastack.cn/18-4-3/88886519.jpg)\n\n说基本数据类型转换之前，先了解下 Java 中的 8 种基本数据类型，以及它们的占内存的容量大小和表示的范围，如下图所示。\n\n![](http://img.javastack.cn/18-4-3/32808656.jpg)\n\n之前分享过《[深入浅出 Java 中的包装类](https://mp.weixin.qq.com/s/uoNVT9IoRQmWnmy8w22UUQ)》，现在重新温故了下原始数据类型，现在来解释下它们之间的转换关系。\n\n#### 自动类型转换\n\n自动类型转换是指：数字表示范围小的数据类型可以自动转换成范围大的数据类型。\n\n如：\n\n```\nlong l = 100;\n\nint i = 200;\nlong ll = i;\n```\n\n具体自动转换如如下图所示。\n\n![](http://img.javastack.cn/18-4-3/42423859.jpg)\n\n实线表示自动转换时不会造成数据丢失，虚线则可能会出现数据丢失问题。\n\n**自动转换也要小心数据溢出问题，看下面的例子。**\n\n```\nint count = 100000000;\nint price = 1999;\nlong totalPrice = count * price;\n```\n\n编译没任何问题，但结果却输出的是负数，这是因为两个 int 相乘得到的结果是 int, 相乘的结果超出了 int 的代表范围。这种情况，一般把第一个数据转换成范围大的数据类型再和其他的数据进行运算。\n\n```\nint count = 100000000;\nint price = 1999;\nlong totalPrice = (long) count * price;\n```\n\n另外，向下转换时可以直接将 int 常量字面量赋值给 byte、short、char 等数据类型，而不需要强制转换，只要该常量值不超过该类型的表示范围都能自动转换。\n\n#### 强制类型转换\n\n强制类型转换我们再清楚不过了，即强制显示的把一个数据类型转换为另外一种数据类型。\n\n如：\n\n```\nshort s = 199;\nint i = s;// 199\n\ndouble d = 10.24;\nlong ll = (long) d;// 10\n```\n\n以上的转换结果都在我们的预期之内，属于正常的转换和丢失精度的情况，下面的例子就一样属于数据溢出的情况。\n\n```\nint ii = 300;\nbyte b = (byte)ii;\n```\n\n300 已经超出了 byte 类型表示的范围，所以会转换成一个毫无意义的数字。\n\n#### 类型提升\n\n所谓类型提升就是指在多种不同数据类型的表达式中，类型会自动向范围表示大的值的数据类型提升。\n\n把上面的溢出的例子再改下。\n\n```\nlong count = 100000000;\nint price = 1999;\nlong totalPrice = price * count;\n```\n\nprice 为 int 型，count 为 long 型，运算结果为 long 型，运算结果正常，没有出现溢出的情况。\n\n","slug":"基础/Java 中的基本数据类型转换详解","published":1,"updated":"2025-10-15T07:19:51.795Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076t003dqkd4alg39ec5","content":"<p><img src=\"http://img.javastack.cn/18-4-3/88886519.jpg\"></p>\n<p>说基本数据类型转换之前，先了解下 Java 中的 8 种基本数据类型，以及它们的占内存的容量大小和表示的范围，如下图所示。</p>\n<p><img src=\"http://img.javastack.cn/18-4-3/32808656.jpg\"></p>\n<p>之前分享过《<a href=\"https://mp.weixin.qq.com/s/uoNVT9IoRQmWnmy8w22UUQ\">深入浅出 Java 中的包装类</a>》，现在重新温故了下原始数据类型，现在来解释下它们之间的转换关系。</p>\n<h4 id=\"自动类型转换\"><a href=\"#自动类型转换\" class=\"headerlink\" title=\"自动类型转换\"></a>自动类型转换</h4><p>自动类型转换是指：数字表示范围小的数据类型可以自动转换成范围大的数据类型。</p>\n<p>如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">long l &#x3D; 100;\n\nint i &#x3D; 200;\nlong ll &#x3D; i;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>具体自动转换如如下图所示。</p>\n<p><img src=\"http://img.javastack.cn/18-4-3/42423859.jpg\"></p>\n<p>实线表示自动转换时不会造成数据丢失，虚线则可能会出现数据丢失问题。</p>\n<p><strong>自动转换也要小心数据溢出问题，看下面的例子。</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int count &#x3D; 100000000;\nint price &#x3D; 1999;\nlong totalPrice &#x3D; count * price;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>编译没任何问题，但结果却输出的是负数，这是因为两个 int 相乘得到的结果是 int, 相乘的结果超出了 int 的代表范围。这种情况，一般把第一个数据转换成范围大的数据类型再和其他的数据进行运算。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int count &#x3D; 100000000;\nint price &#x3D; 1999;\nlong totalPrice &#x3D; (long) count * price;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>另外，向下转换时可以直接将 int 常量字面量赋值给 byte、short、char 等数据类型，而不需要强制转换，只要该常量值不超过该类型的表示范围都能自动转换。</p>\n<h4 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h4><p>强制类型转换我们再清楚不过了，即强制显示的把一个数据类型转换为另外一种数据类型。</p>\n<p>如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">short s &#x3D; 199;\nint i &#x3D; s;&#x2F;&#x2F; 199\n\ndouble d &#x3D; 10.24;\nlong ll &#x3D; (long) d;&#x2F;&#x2F; 10<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上的转换结果都在我们的预期之内，属于正常的转换和丢失精度的情况，下面的例子就一样属于数据溢出的情况。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int ii &#x3D; 300;\nbyte b &#x3D; (byte)ii;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>300 已经超出了 byte 类型表示的范围，所以会转换成一个毫无意义的数字。</p>\n<h4 id=\"类型提升\"><a href=\"#类型提升\" class=\"headerlink\" title=\"类型提升\"></a>类型提升</h4><p>所谓类型提升就是指在多种不同数据类型的表达式中，类型会自动向范围表示大的值的数据类型提升。</p>\n<p>把上面的溢出的例子再改下。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">long count &#x3D; 100000000;\nint price &#x3D; 1999;\nlong totalPrice &#x3D; price * count;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>price 为 int 型，count 为 long 型，运算结果为 long 型，运算结果正常，没有出现溢出的情况。</p>\n","excerpt":"","more":"<p><img src=\"http://img.javastack.cn/18-4-3/88886519.jpg\"></p>\n<p>说基本数据类型转换之前，先了解下 Java 中的 8 种基本数据类型，以及它们的占内存的容量大小和表示的范围，如下图所示。</p>\n<p><img src=\"http://img.javastack.cn/18-4-3/32808656.jpg\"></p>\n<p>之前分享过《<a href=\"https://mp.weixin.qq.com/s/uoNVT9IoRQmWnmy8w22UUQ\">深入浅出 Java 中的包装类</a>》，现在重新温故了下原始数据类型，现在来解释下它们之间的转换关系。</p>\n<h4 id=\"自动类型转换\"><a href=\"#自动类型转换\" class=\"headerlink\" title=\"自动类型转换\"></a>自动类型转换</h4><p>自动类型转换是指：数字表示范围小的数据类型可以自动转换成范围大的数据类型。</p>\n<p>如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">long l &#x3D; 100;\n\nint i &#x3D; 200;\nlong ll &#x3D; i;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>具体自动转换如如下图所示。</p>\n<p><img src=\"http://img.javastack.cn/18-4-3/42423859.jpg\"></p>\n<p>实线表示自动转换时不会造成数据丢失，虚线则可能会出现数据丢失问题。</p>\n<p><strong>自动转换也要小心数据溢出问题，看下面的例子。</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int count &#x3D; 100000000;\nint price &#x3D; 1999;\nlong totalPrice &#x3D; count * price;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>编译没任何问题，但结果却输出的是负数，这是因为两个 int 相乘得到的结果是 int, 相乘的结果超出了 int 的代表范围。这种情况，一般把第一个数据转换成范围大的数据类型再和其他的数据进行运算。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int count &#x3D; 100000000;\nint price &#x3D; 1999;\nlong totalPrice &#x3D; (long) count * price;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>另外，向下转换时可以直接将 int 常量字面量赋值给 byte、short、char 等数据类型，而不需要强制转换，只要该常量值不超过该类型的表示范围都能自动转换。</p>\n<h4 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h4><p>强制类型转换我们再清楚不过了，即强制显示的把一个数据类型转换为另外一种数据类型。</p>\n<p>如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">short s &#x3D; 199;\nint i &#x3D; s;&#x2F;&#x2F; 199\n\ndouble d &#x3D; 10.24;\nlong ll &#x3D; (long) d;&#x2F;&#x2F; 10<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上的转换结果都在我们的预期之内，属于正常的转换和丢失精度的情况，下面的例子就一样属于数据溢出的情况。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int ii &#x3D; 300;\nbyte b &#x3D; (byte)ii;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>300 已经超出了 byte 类型表示的范围，所以会转换成一个毫无意义的数字。</p>\n<h4 id=\"类型提升\"><a href=\"#类型提升\" class=\"headerlink\" title=\"类型提升\"></a>类型提升</h4><p>所谓类型提升就是指在多种不同数据类型的表达式中，类型会自动向范围表示大的值的数据类型提升。</p>\n<p>把上面的溢出的例子再改下。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">long count &#x3D; 100000000;\nint price &#x3D; 1999;\nlong totalPrice &#x3D; price * count;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>price 为 int 型，count 为 long 型，运算结果为 long 型，运算结果正常，没有出现溢出的情况。</p>\n"},{"title":"Java Jar包压缩、解压使用指南","date":"2025-10-14T06:42:34.000Z","_content":"\n![](http://img.javastack.cn/18-2-27/79692618.jpg)\n\n#### 什么是jar包\n\nJAR（Java Archive）是Java的归档文件，它是一种与平台无关的文件格式，它允许将许多文件组合成一个压缩文件。\n\n#### 如何打/解包\n\n使用jdk/bin/jar.exe工具，配置完环境变量后直接使得jar命令即可。\n\n#### jar命令格式\n\njar {c t x u f }[ v m e 0 M i ][-C 目录]文件名...\n \n{ctxu}，这四个参数必须选选其一。\n\n[v f m e 0 M i]，这几个是可选参数，文件名也是必须的。\n\n参数 | 说明\n---|---\n-c | 创建一个jar包\n-t | 显示jar中的内容列表\n-x | 解压jar包\n-u | 添加文件到jar包中\n-f | 指定jar包的文件名\n-v | 输出详细报告\n-m | 指定MANIFEST.MF文件\n-0 | 生成jar包时不压缩内容\n-M | 不生成清单文件MANIFEST.MF\n-i | 为指定的jar文件创建索引文件\n-C | 可在相应的目录下执行命令\n\n关于MANIFEST.MF定义：\n> https://baike.baidu.com/item/MANIFEST.MF\n\n#### 演示\n\n**往jar包添加文件**\n\n> jar uf xxx.jar BOOT-INF/classes/application.yml\n\n**解压jar包**\n\n> jar -xvf xxx.jar\n\n**打jar包，不生成清单文件，不压缩**\n\n> jar -cvfM0 xxx.jar BOOT-INF/ META-INF/ org/\n\n或者\n\n> jar -cvfM0 xxx.jar *\n\n如果要往线上jar包添加、更新部分文件到jar包，这些命令也许对你有用。\n","source":"_posts/基础/Java Jar包压缩、解压使用指南.md","raw":"---\ntitle: Java Jar包压缩、解压使用指南\ndate: 2025-10-14 14:42:34\ncategory: 后端\n---\n\n![](http://img.javastack.cn/18-2-27/79692618.jpg)\n\n#### 什么是jar包\n\nJAR（Java Archive）是Java的归档文件，它是一种与平台无关的文件格式，它允许将许多文件组合成一个压缩文件。\n\n#### 如何打/解包\n\n使用jdk/bin/jar.exe工具，配置完环境变量后直接使得jar命令即可。\n\n#### jar命令格式\n\njar {c t x u f }[ v m e 0 M i ][-C 目录]文件名...\n \n{ctxu}，这四个参数必须选选其一。\n\n[v f m e 0 M i]，这几个是可选参数，文件名也是必须的。\n\n参数 | 说明\n---|---\n-c | 创建一个jar包\n-t | 显示jar中的内容列表\n-x | 解压jar包\n-u | 添加文件到jar包中\n-f | 指定jar包的文件名\n-v | 输出详细报告\n-m | 指定MANIFEST.MF文件\n-0 | 生成jar包时不压缩内容\n-M | 不生成清单文件MANIFEST.MF\n-i | 为指定的jar文件创建索引文件\n-C | 可在相应的目录下执行命令\n\n关于MANIFEST.MF定义：\n> https://baike.baidu.com/item/MANIFEST.MF\n\n#### 演示\n\n**往jar包添加文件**\n\n> jar uf xxx.jar BOOT-INF/classes/application.yml\n\n**解压jar包**\n\n> jar -xvf xxx.jar\n\n**打jar包，不生成清单文件，不压缩**\n\n> jar -cvfM0 xxx.jar BOOT-INF/ META-INF/ org/\n\n或者\n\n> jar -cvfM0 xxx.jar *\n\n如果要往线上jar包添加、更新部分文件到jar包，这些命令也许对你有用。\n","slug":"基础/Java Jar包压缩、解压使用指南","published":1,"updated":"2025-10-15T07:13:51.265Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076t003gqkd4fn3f1uhe","content":"<p><img src=\"http://img.javastack.cn/18-2-27/79692618.jpg\"></p>\n<h4 id=\"什么是jar包\"><a href=\"#什么是jar包\" class=\"headerlink\" title=\"什么是jar包\"></a>什么是jar包</h4><p>JAR（Java Archive）是Java的归档文件，它是一种与平台无关的文件格式，它允许将许多文件组合成一个压缩文件。</p>\n<h4 id=\"如何打-解包\"><a href=\"#如何打-解包\" class=\"headerlink\" title=\"如何打&#x2F;解包\"></a>如何打&#x2F;解包</h4><p>使用jdk&#x2F;bin&#x2F;jar.exe工具，配置完环境变量后直接使得jar命令即可。</p>\n<h4 id=\"jar命令格式\"><a href=\"#jar命令格式\" class=\"headerlink\" title=\"jar命令格式\"></a>jar命令格式</h4><p>jar {c t x u f }[ v m e 0 M i ][-C 目录]文件名…</p>\n<p>{ctxu}，这四个参数必须选选其一。</p>\n<p>[v f m e 0 M i]，这几个是可选参数，文件名也是必须的。</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-c</td>\n<td>创建一个jar包</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>显示jar中的内容列表</td>\n</tr>\n<tr>\n<td>-x</td>\n<td>解压jar包</td>\n</tr>\n<tr>\n<td>-u</td>\n<td>添加文件到jar包中</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>指定jar包的文件名</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>输出详细报告</td>\n</tr>\n<tr>\n<td>-m</td>\n<td>指定MANIFEST.MF文件</td>\n</tr>\n<tr>\n<td>-0</td>\n<td>生成jar包时不压缩内容</td>\n</tr>\n<tr>\n<td>-M</td>\n<td>不生成清单文件MANIFEST.MF</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>为指定的jar文件创建索引文件</td>\n</tr>\n<tr>\n<td>-C</td>\n<td>可在相应的目录下执行命令</td>\n</tr>\n</tbody></table>\n<p>关于MANIFEST.MF定义：</p>\n<blockquote>\n<p><a href=\"https://baike.baidu.com/item/MANIFEST.MF\">https://baike.baidu.com/item/MANIFEST.MF</a></p>\n</blockquote>\n<h4 id=\"演示\"><a href=\"#演示\" class=\"headerlink\" title=\"演示\"></a>演示</h4><p><strong>往jar包添加文件</strong></p>\n<blockquote>\n<p>jar uf xxx.jar BOOT-INF&#x2F;classes&#x2F;application.yml</p>\n</blockquote>\n<p><strong>解压jar包</strong></p>\n<blockquote>\n<p>jar -xvf xxx.jar</p>\n</blockquote>\n<p><strong>打jar包，不生成清单文件，不压缩</strong></p>\n<blockquote>\n<p>jar -cvfM0 xxx.jar BOOT-INF&#x2F; META-INF&#x2F; org&#x2F;</p>\n</blockquote>\n<p>或者</p>\n<blockquote>\n<p>jar -cvfM0 xxx.jar *</p>\n</blockquote>\n<p>如果要往线上jar包添加、更新部分文件到jar包，这些命令也许对你有用。</p>\n","excerpt":"","more":"<p><img src=\"http://img.javastack.cn/18-2-27/79692618.jpg\"></p>\n<h4 id=\"什么是jar包\"><a href=\"#什么是jar包\" class=\"headerlink\" title=\"什么是jar包\"></a>什么是jar包</h4><p>JAR（Java Archive）是Java的归档文件，它是一种与平台无关的文件格式，它允许将许多文件组合成一个压缩文件。</p>\n<h4 id=\"如何打-解包\"><a href=\"#如何打-解包\" class=\"headerlink\" title=\"如何打&#x2F;解包\"></a>如何打&#x2F;解包</h4><p>使用jdk&#x2F;bin&#x2F;jar.exe工具，配置完环境变量后直接使得jar命令即可。</p>\n<h4 id=\"jar命令格式\"><a href=\"#jar命令格式\" class=\"headerlink\" title=\"jar命令格式\"></a>jar命令格式</h4><p>jar {c t x u f }[ v m e 0 M i ][-C 目录]文件名…</p>\n<p>{ctxu}，这四个参数必须选选其一。</p>\n<p>[v f m e 0 M i]，这几个是可选参数，文件名也是必须的。</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-c</td>\n<td>创建一个jar包</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>显示jar中的内容列表</td>\n</tr>\n<tr>\n<td>-x</td>\n<td>解压jar包</td>\n</tr>\n<tr>\n<td>-u</td>\n<td>添加文件到jar包中</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>指定jar包的文件名</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>输出详细报告</td>\n</tr>\n<tr>\n<td>-m</td>\n<td>指定MANIFEST.MF文件</td>\n</tr>\n<tr>\n<td>-0</td>\n<td>生成jar包时不压缩内容</td>\n</tr>\n<tr>\n<td>-M</td>\n<td>不生成清单文件MANIFEST.MF</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>为指定的jar文件创建索引文件</td>\n</tr>\n<tr>\n<td>-C</td>\n<td>可在相应的目录下执行命令</td>\n</tr>\n</tbody></table>\n<p>关于MANIFEST.MF定义：</p>\n<blockquote>\n<p><a href=\"https://baike.baidu.com/item/MANIFEST.MF\">https://baike.baidu.com/item/MANIFEST.MF</a></p>\n</blockquote>\n<h4 id=\"演示\"><a href=\"#演示\" class=\"headerlink\" title=\"演示\"></a>演示</h4><p><strong>往jar包添加文件</strong></p>\n<blockquote>\n<p>jar uf xxx.jar BOOT-INF&#x2F;classes&#x2F;application.yml</p>\n</blockquote>\n<p><strong>解压jar包</strong></p>\n<blockquote>\n<p>jar -xvf xxx.jar</p>\n</blockquote>\n<p><strong>打jar包，不生成清单文件，不压缩</strong></p>\n<blockquote>\n<p>jar -cvfM0 xxx.jar BOOT-INF&#x2F; META-INF&#x2F; org&#x2F;</p>\n</blockquote>\n<p>或者</p>\n<blockquote>\n<p>jar -cvfM0 xxx.jar *</p>\n</blockquote>\n<p>如果要往线上jar包添加、更新部分文件到jar包，这些命令也许对你有用。</p>\n"},{"title":"Java 父类强制转换子类原则","date":"2025-10-14T06:42:34.000Z","_content":"\n![image](http://img.javastack.cn/17-12-20/25802617.jpg)\n\n最近，微信群友在讨论子类父类的转换问题，其实不难，给大家用实例来说明一下就很明了了。\n\n我们知道Java中子类转换成父类是没有任何问题的，那父类可以转换成子类吗？\n\n来看下面这段程序：\n\n```\npublic class TestObjectConvert {\n\n\tpublic static void main(String[] args) {\n\t\ttest1();\n\t\ttest2();\n\t}\n\n\tprivate static void test1() {\n\t\tFruit fruit1 = new Fruit();\n\t\tApple apple1 = new Apple();\n\t\tapple1 = (Apple) fruit1; // java.lang.ClassCastException\n\t}\n\n\tprivate static void test2() {\n\t\tFruit fruit1 = new Apple();\n\t\tApple apple1 = new Apple();\n\t\tapple1 = (Apple) fruit1;\n\t}\n\n\tstatic class Fruit {\n\n\t}\n\n\tstatic class Apple extends Fruit {\n\n\t}\n\n}\n```\n\n结果是：\n\n```\ntest1：报类转异常；\ntest2：转换正常。\n```\n\n**所以，想让父类强制转换成子类，不是没有可能，除非父类是子类构造出来的实例，不然是不能强转的。**\n\n为什么呢？\n\n如上代码，如果父类实例出来的对象是Orange，Orange当然不能强制转成Apple，所以说父类只有该子类对应的实例才能强转。\n\n\n","source":"_posts/基础/Java 父类强制转换子类原则.md","raw":"---\ntitle: Java 父类强制转换子类原则\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 基础\n---\n\n![image](http://img.javastack.cn/17-12-20/25802617.jpg)\n\n最近，微信群友在讨论子类父类的转换问题，其实不难，给大家用实例来说明一下就很明了了。\n\n我们知道Java中子类转换成父类是没有任何问题的，那父类可以转换成子类吗？\n\n来看下面这段程序：\n\n```\npublic class TestObjectConvert {\n\n\tpublic static void main(String[] args) {\n\t\ttest1();\n\t\ttest2();\n\t}\n\n\tprivate static void test1() {\n\t\tFruit fruit1 = new Fruit();\n\t\tApple apple1 = new Apple();\n\t\tapple1 = (Apple) fruit1; // java.lang.ClassCastException\n\t}\n\n\tprivate static void test2() {\n\t\tFruit fruit1 = new Apple();\n\t\tApple apple1 = new Apple();\n\t\tapple1 = (Apple) fruit1;\n\t}\n\n\tstatic class Fruit {\n\n\t}\n\n\tstatic class Apple extends Fruit {\n\n\t}\n\n}\n```\n\n结果是：\n\n```\ntest1：报类转异常；\ntest2：转换正常。\n```\n\n**所以，想让父类强制转换成子类，不是没有可能，除非父类是子类构造出来的实例，不然是不能强转的。**\n\n为什么呢？\n\n如上代码，如果父类实例出来的对象是Orange，Orange当然不能强制转成Apple，所以说父类只有该子类对应的实例才能强转。\n\n\n","slug":"基础/Java 父类强制转换子类原则","published":1,"updated":"2025-10-15T07:19:51.800Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076u003jqkd49t6tc10h","content":"<p><img src=\"http://img.javastack.cn/17-12-20/25802617.jpg\" alt=\"image\"></p>\n<p>最近，微信群友在讨论子类父类的转换问题，其实不难，给大家用实例来说明一下就很明了了。</p>\n<p>我们知道Java中子类转换成父类是没有任何问题的，那父类可以转换成子类吗？</p>\n<p>来看下面这段程序：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class TestObjectConvert &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\ttest1();\n\t\ttest2();\n\t&#125;\n\n\tprivate static void test1() &#123;\n\t\tFruit fruit1 &#x3D; new Fruit();\n\t\tApple apple1 &#x3D; new Apple();\n\t\tapple1 &#x3D; (Apple) fruit1; &#x2F;&#x2F; java.lang.ClassCastException\n\t&#125;\n\n\tprivate static void test2() &#123;\n\t\tFruit fruit1 &#x3D; new Apple();\n\t\tApple apple1 &#x3D; new Apple();\n\t\tapple1 &#x3D; (Apple) fruit1;\n\t&#125;\n\n\tstatic class Fruit &#123;\n\n\t&#125;\n\n\tstatic class Apple extends Fruit &#123;\n\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>结果是：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">test1：报类转异常；\ntest2：转换正常。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><strong>所以，想让父类强制转换成子类，不是没有可能，除非父类是子类构造出来的实例，不然是不能强转的。</strong></p>\n<p>为什么呢？</p>\n<p>如上代码，如果父类实例出来的对象是Orange，Orange当然不能强制转成Apple，所以说父类只有该子类对应的实例才能强转。</p>\n","excerpt":"","more":"<p><img src=\"http://img.javastack.cn/17-12-20/25802617.jpg\" alt=\"image\"></p>\n<p>最近，微信群友在讨论子类父类的转换问题，其实不难，给大家用实例来说明一下就很明了了。</p>\n<p>我们知道Java中子类转换成父类是没有任何问题的，那父类可以转换成子类吗？</p>\n<p>来看下面这段程序：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class TestObjectConvert &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\ttest1();\n\t\ttest2();\n\t&#125;\n\n\tprivate static void test1() &#123;\n\t\tFruit fruit1 &#x3D; new Fruit();\n\t\tApple apple1 &#x3D; new Apple();\n\t\tapple1 &#x3D; (Apple) fruit1; &#x2F;&#x2F; java.lang.ClassCastException\n\t&#125;\n\n\tprivate static void test2() &#123;\n\t\tFruit fruit1 &#x3D; new Apple();\n\t\tApple apple1 &#x3D; new Apple();\n\t\tapple1 &#x3D; (Apple) fruit1;\n\t&#125;\n\n\tstatic class Fruit &#123;\n\n\t&#125;\n\n\tstatic class Apple extends Fruit &#123;\n\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>结果是：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">test1：报类转异常；\ntest2：转换正常。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><strong>所以，想让父类强制转换成子类，不是没有可能，除非父类是子类构造出来的实例，不然是不能强转的。</strong></p>\n<p>为什么呢？</p>\n<p>如上代码，如果父类实例出来的对象是Orange，Orange当然不能强制转成Apple，所以说父类只有该子类对应的实例才能强转。</p>\n"},{"title":"StringBuffer 和 StringBuilder 的 3 个区别","date":"2025-10-14T06:42:34.000Z","_content":"\nStringBuffer 和 StringBuilder 它们都是可变的字符串，不过它们之间的区别是 Java 初中级面试出现几率十分高的一道题。这么简单的一道题，栈长在最近的面试过程中，却经常遇到很多求职者说反，搞不清使用场景的情况。\n\n今天，栈长我带大家彻底搞懂 StringBuffer 和 StringBuilder 的几个区别和它们的应用场景，如果你是大牛，请略过，如果你是菜鸟，或者对这两个不是很清楚，可以学习一下，也可以为年底的面试加油冲刺。\n\n先看看 StringBuffer 和 StringBuilder 的类结构吧：\n\n![](http://img.javastack.cn/18-12-29/23490736.jpg)\n\n其实很简单，就是继承了一个抽象的字符串父类：`AbstractStringBuilder`。下面我们再来看看它们的三个区别。\n\n## 区别1：线程安全\n\nStringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有公开方法都是 synchronized 修饰的，而 StringBuilder 并没有 StringBuilder 修饰。\n\n**StringBuffer 代码片段：**\n\n```\n@Override\npublic synchronized StringBuffer append(String str) {\n    toStringCache = null;\n    super.append(str);\n    return this;\n}\n```\n\n## 区别2：缓冲区\n\n**StringBuffer 代码片段：**\n\n```\nprivate transient char[] toStringCache;\n\n@Override\npublic synchronized String toString() {\n    if (toStringCache == null) {\n        toStringCache = Arrays.copyOfRange(value, 0, count);\n    }\n    return new String(toStringCache, true);\n}\n```\n\n**StringBuilder 代码片段：**\n\n```\n@Override\npublic String toString() {\n    // Create a copy, don't share the array\n    return new String(value, 0, count);\n}\n```\n\n可以看出，StringBuffer 每次获取 toString 都会直接使用缓存区的 toStringCache 值来构造一个字符串。\n\n而 StringBuilder 则每次都需要复制一次字符数组，再构造一个字符串。\n\n所以，缓存冲这也是对 StringBuffer 的一个优化吧，不过 StringBuffer 的这个toString 方法仍然是同步的。\n\n## 区别3：性能\n\n既然 StringBuffer 是线程安全的，它的所有公开方法都是同步的，StringBuilder 是没有对方法加锁同步的，所以毫无疑问，StringBuilder 的性能要远大于 StringBuffer。\n\n## 总结\n\n所以，StringBuffer 适用于用在多线程操作同一个 StringBuffer 的场景，如果是单线程场合 StringBuilder 更适合。\n\n以此送给正在面试或者即将去面试的 Java 程序猿们，如果对你有帮助，也欢迎分享给身边的朋友们，让大家少走弯路。\n\n","source":"_posts/基础/StringBuffer 和 StringBuilder 的 3 个区别.md","raw":"---\ntitle: StringBuffer 和 StringBuilder 的 3 个区别\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 基础\n---\n\nStringBuffer 和 StringBuilder 它们都是可变的字符串，不过它们之间的区别是 Java 初中级面试出现几率十分高的一道题。这么简单的一道题，栈长在最近的面试过程中，却经常遇到很多求职者说反，搞不清使用场景的情况。\n\n今天，栈长我带大家彻底搞懂 StringBuffer 和 StringBuilder 的几个区别和它们的应用场景，如果你是大牛，请略过，如果你是菜鸟，或者对这两个不是很清楚，可以学习一下，也可以为年底的面试加油冲刺。\n\n先看看 StringBuffer 和 StringBuilder 的类结构吧：\n\n![](http://img.javastack.cn/18-12-29/23490736.jpg)\n\n其实很简单，就是继承了一个抽象的字符串父类：`AbstractStringBuilder`。下面我们再来看看它们的三个区别。\n\n## 区别1：线程安全\n\nStringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有公开方法都是 synchronized 修饰的，而 StringBuilder 并没有 StringBuilder 修饰。\n\n**StringBuffer 代码片段：**\n\n```\n@Override\npublic synchronized StringBuffer append(String str) {\n    toStringCache = null;\n    super.append(str);\n    return this;\n}\n```\n\n## 区别2：缓冲区\n\n**StringBuffer 代码片段：**\n\n```\nprivate transient char[] toStringCache;\n\n@Override\npublic synchronized String toString() {\n    if (toStringCache == null) {\n        toStringCache = Arrays.copyOfRange(value, 0, count);\n    }\n    return new String(toStringCache, true);\n}\n```\n\n**StringBuilder 代码片段：**\n\n```\n@Override\npublic String toString() {\n    // Create a copy, don't share the array\n    return new String(value, 0, count);\n}\n```\n\n可以看出，StringBuffer 每次获取 toString 都会直接使用缓存区的 toStringCache 值来构造一个字符串。\n\n而 StringBuilder 则每次都需要复制一次字符数组，再构造一个字符串。\n\n所以，缓存冲这也是对 StringBuffer 的一个优化吧，不过 StringBuffer 的这个toString 方法仍然是同步的。\n\n## 区别3：性能\n\n既然 StringBuffer 是线程安全的，它的所有公开方法都是同步的，StringBuilder 是没有对方法加锁同步的，所以毫无疑问，StringBuilder 的性能要远大于 StringBuffer。\n\n## 总结\n\n所以，StringBuffer 适用于用在多线程操作同一个 StringBuffer 的场景，如果是单线程场合 StringBuilder 更适合。\n\n以此送给正在面试或者即将去面试的 Java 程序猿们，如果对你有帮助，也欢迎分享给身边的朋友们，让大家少走弯路。\n\n","slug":"基础/StringBuffer 和 StringBuilder 的 3 个区别","published":1,"updated":"2025-10-15T07:19:51.814Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076u003nqkd48kavh4lg","content":"<p>StringBuffer 和 StringBuilder 它们都是可变的字符串，不过它们之间的区别是 Java 初中级面试出现几率十分高的一道题。这么简单的一道题，栈长在最近的面试过程中，却经常遇到很多求职者说反，搞不清使用场景的情况。</p>\n<p>今天，栈长我带大家彻底搞懂 StringBuffer 和 StringBuilder 的几个区别和它们的应用场景，如果你是大牛，请略过，如果你是菜鸟，或者对这两个不是很清楚，可以学习一下，也可以为年底的面试加油冲刺。</p>\n<p>先看看 StringBuffer 和 StringBuilder 的类结构吧：</p>\n<p><img src=\"http://img.javastack.cn/18-12-29/23490736.jpg\"></p>\n<p>其实很简单，就是继承了一个抽象的字符串父类：<code>AbstractStringBuilder</code>。下面我们再来看看它们的三个区别。</p>\n<h2 id=\"区别1：线程安全\"><a href=\"#区别1：线程安全\" class=\"headerlink\" title=\"区别1：线程安全\"></a>区别1：线程安全</h2><p>StringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有公开方法都是 synchronized 修饰的，而 StringBuilder 并没有 StringBuilder 修饰。</p>\n<p><strong>StringBuffer 代码片段：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Override\npublic synchronized StringBuffer append(String str) &#123;\n    toStringCache &#x3D; null;\n    super.append(str);\n    return this;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"区别2：缓冲区\"><a href=\"#区别2：缓冲区\" class=\"headerlink\" title=\"区别2：缓冲区\"></a>区别2：缓冲区</h2><p><strong>StringBuffer 代码片段：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private transient char[] toStringCache;\n\n@Override\npublic synchronized String toString() &#123;\n    if (toStringCache &#x3D;&#x3D; null) &#123;\n        toStringCache &#x3D; Arrays.copyOfRange(value, 0, count);\n    &#125;\n    return new String(toStringCache, true);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>StringBuilder 代码片段：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Override\npublic String toString() &#123;\n    &#x2F;&#x2F; Create a copy, don&#39;t share the array\n    return new String(value, 0, count);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出，StringBuffer 每次获取 toString 都会直接使用缓存区的 toStringCache 值来构造一个字符串。</p>\n<p>而 StringBuilder 则每次都需要复制一次字符数组，再构造一个字符串。</p>\n<p>所以，缓存冲这也是对 StringBuffer 的一个优化吧，不过 StringBuffer 的这个toString 方法仍然是同步的。</p>\n<h2 id=\"区别3：性能\"><a href=\"#区别3：性能\" class=\"headerlink\" title=\"区别3：性能\"></a>区别3：性能</h2><p>既然 StringBuffer 是线程安全的，它的所有公开方法都是同步的，StringBuilder 是没有对方法加锁同步的，所以毫无疑问，StringBuilder 的性能要远大于 StringBuffer。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>所以，StringBuffer 适用于用在多线程操作同一个 StringBuffer 的场景，如果是单线程场合 StringBuilder 更适合。</p>\n<p>以此送给正在面试或者即将去面试的 Java 程序猿们，如果对你有帮助，也欢迎分享给身边的朋友们，让大家少走弯路。</p>\n","excerpt":"","more":"<p>StringBuffer 和 StringBuilder 它们都是可变的字符串，不过它们之间的区别是 Java 初中级面试出现几率十分高的一道题。这么简单的一道题，栈长在最近的面试过程中，却经常遇到很多求职者说反，搞不清使用场景的情况。</p>\n<p>今天，栈长我带大家彻底搞懂 StringBuffer 和 StringBuilder 的几个区别和它们的应用场景，如果你是大牛，请略过，如果你是菜鸟，或者对这两个不是很清楚，可以学习一下，也可以为年底的面试加油冲刺。</p>\n<p>先看看 StringBuffer 和 StringBuilder 的类结构吧：</p>\n<p><img src=\"http://img.javastack.cn/18-12-29/23490736.jpg\"></p>\n<p>其实很简单，就是继承了一个抽象的字符串父类：<code>AbstractStringBuilder</code>。下面我们再来看看它们的三个区别。</p>\n<h2 id=\"区别1：线程安全\"><a href=\"#区别1：线程安全\" class=\"headerlink\" title=\"区别1：线程安全\"></a>区别1：线程安全</h2><p>StringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有公开方法都是 synchronized 修饰的，而 StringBuilder 并没有 StringBuilder 修饰。</p>\n<p><strong>StringBuffer 代码片段：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Override\npublic synchronized StringBuffer append(String str) &#123;\n    toStringCache &#x3D; null;\n    super.append(str);\n    return this;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"区别2：缓冲区\"><a href=\"#区别2：缓冲区\" class=\"headerlink\" title=\"区别2：缓冲区\"></a>区别2：缓冲区</h2><p><strong>StringBuffer 代码片段：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private transient char[] toStringCache;\n\n@Override\npublic synchronized String toString() &#123;\n    if (toStringCache &#x3D;&#x3D; null) &#123;\n        toStringCache &#x3D; Arrays.copyOfRange(value, 0, count);\n    &#125;\n    return new String(toStringCache, true);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>StringBuilder 代码片段：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Override\npublic String toString() &#123;\n    &#x2F;&#x2F; Create a copy, don&#39;t share the array\n    return new String(value, 0, count);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出，StringBuffer 每次获取 toString 都会直接使用缓存区的 toStringCache 值来构造一个字符串。</p>\n<p>而 StringBuilder 则每次都需要复制一次字符数组，再构造一个字符串。</p>\n<p>所以，缓存冲这也是对 StringBuffer 的一个优化吧，不过 StringBuffer 的这个toString 方法仍然是同步的。</p>\n<h2 id=\"区别3：性能\"><a href=\"#区别3：性能\" class=\"headerlink\" title=\"区别3：性能\"></a>区别3：性能</h2><p>既然 StringBuffer 是线程安全的，它的所有公开方法都是同步的，StringBuilder 是没有对方法加锁同步的，所以毫无疑问，StringBuilder 的性能要远大于 StringBuffer。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>所以，StringBuffer 适用于用在多线程操作同一个 StringBuffer 的场景，如果是单线程场合 StringBuilder 更适合。</p>\n<p>以此送给正在面试或者即将去面试的 Java 程序猿们，如果对你有帮助，也欢迎分享给身边的朋友们，让大家少走弯路。</p>\n"},{"title":"switch case 支持的 6 种数据类型！","date":"2025-10-14T06:42:34.000Z","_content":"\n**Java 中 switch case 语句用来判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。**\n\n**语法格式如下：**\n\n```\nswitch(expression){\n    case value :\n       //语句\n       break; //可选\n    case value :\n       //语句\n       break; //可选\n    //你可以有任意数量的case语句\n    default : //可选\n       //语句\n}\n```\n\n**这里的 `expression` 都支持哪些类型呢？**\n\n- 基本数据类型：byte, short, char, int\n\n- 包装数据类型：Byte, Short, Character, Integer\n\n- 枚举类型：Enum\n\n- 字符串类型：String（Jdk 7+ 开始支持）\n\n基本数据类型和字符串很简单不用说，下面举一个使用包装类型和枚举的，其实也不难，注意只能用在 switch 块里面。\n\n```\n// 使用包装类型\nInteger value = 5;\nswitch (value) {\n\tcase 3:\n\t\tSystem.out.println(\"3\");\n\t\tbreak;\n\tcase 5:\n\t\tSystem.out.println(\"5\");\n\t\tbreak;\n\tdefault:\n\t\tSystem.out.println(\"default\");\n}\n\n// 使用枚举类型\nStatus status = Status.PROCESSING;\nswitch (status) {\n\tcase OPEN:\n\t\tSystem.out.println(\"open\");\n\t\tbreak;\n\tcase PROCESSING:\n\t\tSystem.out.println(\"processing\");\n\t\tbreak;\n\tcase CLOSE:\n\t\tSystem.out.println(\"close\");\n\t\tbreak;\n\tdefault:\n\t\tSystem.out.println(\"default\");\n}\n```\n\n以下为官网的介绍文档。\n> https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html\n\n包装类不懂的看这篇文章《[深入浅出 Java 中的包装类](https://mp.weixin.qq.com/s/uoNVT9IoRQmWnmy8w22UUQ)》。\n\n**使用 switch case 语句也有以下几点需要注意。**\n\n1. case 里面必须跟 break，不然程序会一个个 case 执行下去，直到最后一个 break 的 case 或者 default 出现。\n\n2. case 条件里面只能是常量或者字面常量。\n\n3. default 语句可有可无，最多只能有一个。\n\n有问题请留言，希望本文能对你有有所帮助！\n\n","source":"_posts/基础/switch case 支持的 6 种数据类型！.md","raw":"---\ntitle: switch case 支持的 6 种数据类型！\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 基础\n---\n\n**Java 中 switch case 语句用来判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。**\n\n**语法格式如下：**\n\n```\nswitch(expression){\n    case value :\n       //语句\n       break; //可选\n    case value :\n       //语句\n       break; //可选\n    //你可以有任意数量的case语句\n    default : //可选\n       //语句\n}\n```\n\n**这里的 `expression` 都支持哪些类型呢？**\n\n- 基本数据类型：byte, short, char, int\n\n- 包装数据类型：Byte, Short, Character, Integer\n\n- 枚举类型：Enum\n\n- 字符串类型：String（Jdk 7+ 开始支持）\n\n基本数据类型和字符串很简单不用说，下面举一个使用包装类型和枚举的，其实也不难，注意只能用在 switch 块里面。\n\n```\n// 使用包装类型\nInteger value = 5;\nswitch (value) {\n\tcase 3:\n\t\tSystem.out.println(\"3\");\n\t\tbreak;\n\tcase 5:\n\t\tSystem.out.println(\"5\");\n\t\tbreak;\n\tdefault:\n\t\tSystem.out.println(\"default\");\n}\n\n// 使用枚举类型\nStatus status = Status.PROCESSING;\nswitch (status) {\n\tcase OPEN:\n\t\tSystem.out.println(\"open\");\n\t\tbreak;\n\tcase PROCESSING:\n\t\tSystem.out.println(\"processing\");\n\t\tbreak;\n\tcase CLOSE:\n\t\tSystem.out.println(\"close\");\n\t\tbreak;\n\tdefault:\n\t\tSystem.out.println(\"default\");\n}\n```\n\n以下为官网的介绍文档。\n> https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html\n\n包装类不懂的看这篇文章《[深入浅出 Java 中的包装类](https://mp.weixin.qq.com/s/uoNVT9IoRQmWnmy8w22UUQ)》。\n\n**使用 switch case 语句也有以下几点需要注意。**\n\n1. case 里面必须跟 break，不然程序会一个个 case 执行下去，直到最后一个 break 的 case 或者 default 出现。\n\n2. case 条件里面只能是常量或者字面常量。\n\n3. default 语句可有可无，最多只能有一个。\n\n有问题请留言，希望本文能对你有有所帮助！\n\n","slug":"基础/switch case 支持的 6 种数据类型！","published":1,"updated":"2025-10-15T07:19:51.810Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076v003qqkd4cndjac5l","content":"<p><strong>Java 中 switch case 语句用来判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</strong></p>\n<p><strong>语法格式如下：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">switch(expression)&#123;\n    case value :\n       &#x2F;&#x2F;语句\n       break; &#x2F;&#x2F;可选\n    case value :\n       &#x2F;&#x2F;语句\n       break; &#x2F;&#x2F;可选\n    &#x2F;&#x2F;你可以有任意数量的case语句\n    default : &#x2F;&#x2F;可选\n       &#x2F;&#x2F;语句\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>这里的 <code>expression</code> 都支持哪些类型呢？</strong></p>\n<ul>\n<li><p>基本数据类型：byte, short, char, int</p>\n</li>\n<li><p>包装数据类型：Byte, Short, Character, Integer</p>\n</li>\n<li><p>枚举类型：Enum</p>\n</li>\n<li><p>字符串类型：String（Jdk 7+ 开始支持）</p>\n</li>\n</ul>\n<p>基本数据类型和字符串很简单不用说，下面举一个使用包装类型和枚举的，其实也不难，注意只能用在 switch 块里面。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 使用包装类型\nInteger value &#x3D; 5;\nswitch (value) &#123;\n\tcase 3:\n\t\tSystem.out.println(&quot;3&quot;);\n\t\tbreak;\n\tcase 5:\n\t\tSystem.out.println(&quot;5&quot;);\n\t\tbreak;\n\tdefault:\n\t\tSystem.out.println(&quot;default&quot;);\n&#125;\n\n&#x2F;&#x2F; 使用枚举类型\nStatus status &#x3D; Status.PROCESSING;\nswitch (status) &#123;\n\tcase OPEN:\n\t\tSystem.out.println(&quot;open&quot;);\n\t\tbreak;\n\tcase PROCESSING:\n\t\tSystem.out.println(&quot;processing&quot;);\n\t\tbreak;\n\tcase CLOSE:\n\t\tSystem.out.println(&quot;close&quot;);\n\t\tbreak;\n\tdefault:\n\t\tSystem.out.println(&quot;default&quot;);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以下为官网的介绍文档。</p>\n<blockquote>\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html\">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html</a></p>\n</blockquote>\n<p>包装类不懂的看这篇文章《<a href=\"https://mp.weixin.qq.com/s/uoNVT9IoRQmWnmy8w22UUQ\">深入浅出 Java 中的包装类</a>》。</p>\n<p><strong>使用 switch case 语句也有以下几点需要注意。</strong></p>\n<ol>\n<li><p>case 里面必须跟 break，不然程序会一个个 case 执行下去，直到最后一个 break 的 case 或者 default 出现。</p>\n</li>\n<li><p>case 条件里面只能是常量或者字面常量。</p>\n</li>\n<li><p>default 语句可有可无，最多只能有一个。</p>\n</li>\n</ol>\n<p>有问题请留言，希望本文能对你有有所帮助！</p>\n","excerpt":"","more":"<p><strong>Java 中 switch case 语句用来判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</strong></p>\n<p><strong>语法格式如下：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">switch(expression)&#123;\n    case value :\n       &#x2F;&#x2F;语句\n       break; &#x2F;&#x2F;可选\n    case value :\n       &#x2F;&#x2F;语句\n       break; &#x2F;&#x2F;可选\n    &#x2F;&#x2F;你可以有任意数量的case语句\n    default : &#x2F;&#x2F;可选\n       &#x2F;&#x2F;语句\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>这里的 <code>expression</code> 都支持哪些类型呢？</strong></p>\n<ul>\n<li><p>基本数据类型：byte, short, char, int</p>\n</li>\n<li><p>包装数据类型：Byte, Short, Character, Integer</p>\n</li>\n<li><p>枚举类型：Enum</p>\n</li>\n<li><p>字符串类型：String（Jdk 7+ 开始支持）</p>\n</li>\n</ul>\n<p>基本数据类型和字符串很简单不用说，下面举一个使用包装类型和枚举的，其实也不难，注意只能用在 switch 块里面。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 使用包装类型\nInteger value &#x3D; 5;\nswitch (value) &#123;\n\tcase 3:\n\t\tSystem.out.println(&quot;3&quot;);\n\t\tbreak;\n\tcase 5:\n\t\tSystem.out.println(&quot;5&quot;);\n\t\tbreak;\n\tdefault:\n\t\tSystem.out.println(&quot;default&quot;);\n&#125;\n\n&#x2F;&#x2F; 使用枚举类型\nStatus status &#x3D; Status.PROCESSING;\nswitch (status) &#123;\n\tcase OPEN:\n\t\tSystem.out.println(&quot;open&quot;);\n\t\tbreak;\n\tcase PROCESSING:\n\t\tSystem.out.println(&quot;processing&quot;);\n\t\tbreak;\n\tcase CLOSE:\n\t\tSystem.out.println(&quot;close&quot;);\n\t\tbreak;\n\tdefault:\n\t\tSystem.out.println(&quot;default&quot;);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以下为官网的介绍文档。</p>\n<blockquote>\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html\">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html</a></p>\n</blockquote>\n<p>包装类不懂的看这篇文章《<a href=\"https://mp.weixin.qq.com/s/uoNVT9IoRQmWnmy8w22UUQ\">深入浅出 Java 中的包装类</a>》。</p>\n<p><strong>使用 switch case 语句也有以下几点需要注意。</strong></p>\n<ol>\n<li><p>case 里面必须跟 break，不然程序会一个个 case 执行下去，直到最后一个 break 的 case 或者 default 出现。</p>\n</li>\n<li><p>case 条件里面只能是常量或者字面常量。</p>\n</li>\n<li><p>default 语句可有可无，最多只能有一个。</p>\n</li>\n</ol>\n<p>有问题请留言，希望本文能对你有有所帮助！</p>\n"},{"title":"switch多值匹配骚操作，带你涨姿势！","date":"2025-10-14T06:42:34.000Z","_content":"\n我们都知道 `switch` 用来走流程分支，大多情况下用来匹配单个值，如下面的例子所示：\n\n```\n/**\n * @from \n * @author 栈长\n */\nprivate static void test(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"1\");\n            break;\n        case 2:\n            System.out.println(\"1\");\n            break;\n        case 3:\n            System.out.println(\"1\");\n            break;\n        case 4:\n            System.out.println(\"1\");\n            break;\n        case 5:\n            System.out.println(\"1\");\n            break;\n        case 6:\n            System.out.println(\"0\");\n            break;\n        case 7:\n            System.out.println(\"0\");\n            break;\n        default:\n            System.out.println(\"-1\");\n    }\n}\n```\n\n相关阅读：[switch case 支持的 6 种数据类型](https://mp.weixin.qq.com/s/QuchavZfEexwAgUS5qgB_Q)。\n\n大概的意思就是，周一到周五输出：1，周六到周日输出：0，默认输出-1。\n\n这样写，很多重复的逻辑，冗余了。\n\n也许这个例子不是很合适，用 if/ else 更恰当，但这只是个例子，实际开发中肯定会有某几个 case 匹配同一段逻辑的情况。\n\n那么，如何让多个 case 匹配同一段逻辑呢？\n\n如下面例子所示：\n\n```\n/**\n * \n * @author 栈长\n */\nprivate static void test(int value) {\n    switch (value) {\n        case 1: case 2: case 3: case 4: case 5:\n            System.out.println(\"1\");\n            break;\n        case 6: case 7:\n            System.out.println(\"0\");\n            break;\n        default:\n            System.out.println(\"-1\");\n    }\n}\n```\n\n把相同逻辑的 case 放一起，最后一个 case 写逻辑就行了。\n\n格式化后就是这样了：\n\n```\n/**\n * \n * @author 栈长\n */\nprivate static void test(int value) {\n    switch (value) {\n        case 1: \n        case 2: \n        case 3: \n        case 4: \n        case 5:\n            System.out.println(\"1\");\n            break;\n        case 6: \n        case 7:\n            System.out.println(\"0\");\n            break;\n        default:\n            System.out.println(\"-1\");\n    }\n}\n```\n\n是不是很骚？\n\n其实这不是最合适的最好的写法，在 Java 12 中还可以更骚。\n\n在 Java 12 中可以用逗号来分开多个值，还能用 `lambda` 表达式，甚至还能省略 break，使用 `switch` 更方便。\n\n","source":"_posts/基础/switch多值匹配骚操作，带你涨姿势！.md","raw":"---\ntitle: switch多值匹配骚操作，带你涨姿势！\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 基础\n---\n\n我们都知道 `switch` 用来走流程分支，大多情况下用来匹配单个值，如下面的例子所示：\n\n```\n/**\n * @from \n * @author 栈长\n */\nprivate static void test(int value) {\n    switch (value) {\n        case 1:\n            System.out.println(\"1\");\n            break;\n        case 2:\n            System.out.println(\"1\");\n            break;\n        case 3:\n            System.out.println(\"1\");\n            break;\n        case 4:\n            System.out.println(\"1\");\n            break;\n        case 5:\n            System.out.println(\"1\");\n            break;\n        case 6:\n            System.out.println(\"0\");\n            break;\n        case 7:\n            System.out.println(\"0\");\n            break;\n        default:\n            System.out.println(\"-1\");\n    }\n}\n```\n\n相关阅读：[switch case 支持的 6 种数据类型](https://mp.weixin.qq.com/s/QuchavZfEexwAgUS5qgB_Q)。\n\n大概的意思就是，周一到周五输出：1，周六到周日输出：0，默认输出-1。\n\n这样写，很多重复的逻辑，冗余了。\n\n也许这个例子不是很合适，用 if/ else 更恰当，但这只是个例子，实际开发中肯定会有某几个 case 匹配同一段逻辑的情况。\n\n那么，如何让多个 case 匹配同一段逻辑呢？\n\n如下面例子所示：\n\n```\n/**\n * \n * @author 栈长\n */\nprivate static void test(int value) {\n    switch (value) {\n        case 1: case 2: case 3: case 4: case 5:\n            System.out.println(\"1\");\n            break;\n        case 6: case 7:\n            System.out.println(\"0\");\n            break;\n        default:\n            System.out.println(\"-1\");\n    }\n}\n```\n\n把相同逻辑的 case 放一起，最后一个 case 写逻辑就行了。\n\n格式化后就是这样了：\n\n```\n/**\n * \n * @author 栈长\n */\nprivate static void test(int value) {\n    switch (value) {\n        case 1: \n        case 2: \n        case 3: \n        case 4: \n        case 5:\n            System.out.println(\"1\");\n            break;\n        case 6: \n        case 7:\n            System.out.println(\"0\");\n            break;\n        default:\n            System.out.println(\"-1\");\n    }\n}\n```\n\n是不是很骚？\n\n其实这不是最合适的最好的写法，在 Java 12 中还可以更骚。\n\n在 Java 12 中可以用逗号来分开多个值，还能用 `lambda` 表达式，甚至还能省略 break，使用 `switch` 更方便。\n\n","slug":"基础/switch多值匹配骚操作，带你涨姿势！","published":1,"updated":"2025-10-15T07:19:51.833Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076v003uqkd49gus83ml","content":"<p>我们都知道 <code>switch</code> 用来走流程分支，大多情况下用来匹配单个值，如下面的例子所示：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * @from \n * @author 栈长\n *&#x2F;\nprivate static void test(int value) &#123;\n    switch (value) &#123;\n        case 1:\n            System.out.println(&quot;1&quot;);\n            break;\n        case 2:\n            System.out.println(&quot;1&quot;);\n            break;\n        case 3:\n            System.out.println(&quot;1&quot;);\n            break;\n        case 4:\n            System.out.println(&quot;1&quot;);\n            break;\n        case 5:\n            System.out.println(&quot;1&quot;);\n            break;\n        case 6:\n            System.out.println(&quot;0&quot;);\n            break;\n        case 7:\n            System.out.println(&quot;0&quot;);\n            break;\n        default:\n            System.out.println(&quot;-1&quot;);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>相关阅读：<a href=\"https://mp.weixin.qq.com/s/QuchavZfEexwAgUS5qgB_Q\">switch case 支持的 6 种数据类型</a>。</p>\n<p>大概的意思就是，周一到周五输出：1，周六到周日输出：0，默认输出-1。</p>\n<p>这样写，很多重复的逻辑，冗余了。</p>\n<p>也许这个例子不是很合适，用 if&#x2F; else 更恰当，但这只是个例子，实际开发中肯定会有某几个 case 匹配同一段逻辑的情况。</p>\n<p>那么，如何让多个 case 匹配同一段逻辑呢？</p>\n<p>如下面例子所示：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n * @author 栈长\n *&#x2F;\nprivate static void test(int value) &#123;\n    switch (value) &#123;\n        case 1: case 2: case 3: case 4: case 5:\n            System.out.println(&quot;1&quot;);\n            break;\n        case 6: case 7:\n            System.out.println(&quot;0&quot;);\n            break;\n        default:\n            System.out.println(&quot;-1&quot;);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>把相同逻辑的 case 放一起，最后一个 case 写逻辑就行了。</p>\n<p>格式化后就是这样了：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n * @author 栈长\n *&#x2F;\nprivate static void test(int value) &#123;\n    switch (value) &#123;\n        case 1: \n        case 2: \n        case 3: \n        case 4: \n        case 5:\n            System.out.println(&quot;1&quot;);\n            break;\n        case 6: \n        case 7:\n            System.out.println(&quot;0&quot;);\n            break;\n        default:\n            System.out.println(&quot;-1&quot;);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>是不是很骚？</p>\n<p>其实这不是最合适的最好的写法，在 Java 12 中还可以更骚。</p>\n<p>在 Java 12 中可以用逗号来分开多个值，还能用 <code>lambda</code> 表达式，甚至还能省略 break，使用 <code>switch</code> 更方便。</p>\n","excerpt":"","more":"<p>我们都知道 <code>switch</code> 用来走流程分支，大多情况下用来匹配单个值，如下面的例子所示：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * @from \n * @author 栈长\n *&#x2F;\nprivate static void test(int value) &#123;\n    switch (value) &#123;\n        case 1:\n            System.out.println(&quot;1&quot;);\n            break;\n        case 2:\n            System.out.println(&quot;1&quot;);\n            break;\n        case 3:\n            System.out.println(&quot;1&quot;);\n            break;\n        case 4:\n            System.out.println(&quot;1&quot;);\n            break;\n        case 5:\n            System.out.println(&quot;1&quot;);\n            break;\n        case 6:\n            System.out.println(&quot;0&quot;);\n            break;\n        case 7:\n            System.out.println(&quot;0&quot;);\n            break;\n        default:\n            System.out.println(&quot;-1&quot;);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>相关阅读：<a href=\"https://mp.weixin.qq.com/s/QuchavZfEexwAgUS5qgB_Q\">switch case 支持的 6 种数据类型</a>。</p>\n<p>大概的意思就是，周一到周五输出：1，周六到周日输出：0，默认输出-1。</p>\n<p>这样写，很多重复的逻辑，冗余了。</p>\n<p>也许这个例子不是很合适，用 if&#x2F; else 更恰当，但这只是个例子，实际开发中肯定会有某几个 case 匹配同一段逻辑的情况。</p>\n<p>那么，如何让多个 case 匹配同一段逻辑呢？</p>\n<p>如下面例子所示：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n * @author 栈长\n *&#x2F;\nprivate static void test(int value) &#123;\n    switch (value) &#123;\n        case 1: case 2: case 3: case 4: case 5:\n            System.out.println(&quot;1&quot;);\n            break;\n        case 6: case 7:\n            System.out.println(&quot;0&quot;);\n            break;\n        default:\n            System.out.println(&quot;-1&quot;);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>把相同逻辑的 case 放一起，最后一个 case 写逻辑就行了。</p>\n<p>格式化后就是这样了：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * \n * @author 栈长\n *&#x2F;\nprivate static void test(int value) &#123;\n    switch (value) &#123;\n        case 1: \n        case 2: \n        case 3: \n        case 4: \n        case 5:\n            System.out.println(&quot;1&quot;);\n            break;\n        case 6: \n        case 7:\n            System.out.println(&quot;0&quot;);\n            break;\n        default:\n            System.out.println(&quot;-1&quot;);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>是不是很骚？</p>\n<p>其实这不是最合适的最好的写法，在 Java 12 中还可以更骚。</p>\n<p>在 Java 12 中可以用逗号来分开多个值，还能用 <code>lambda</code> 表达式，甚至还能省略 break，使用 <code>switch</code> 更方便。</p>\n"},{"title":"一张图搞清楚Java异常机制","date":"2025-10-14T06:42:34.000Z","_content":"\n下面是Java异常类的组织结构，红色区域的异常类表示是程序需要显示捕捉或者抛出的。\n\n![image](https://www.programcreek.com/wp-content/uploads/2009/02/Exception-Hierarchy-Diagram.jpeg)\n\n### Throwable\nThrowable是Java异常的顶级类，所有的异常都继承于这个类。\n\nError，Exception是异常类的两个大分类。\n\n### Error\n\nError是非程序异常，即程序不能捕获的异常，一般是编译或者系统性的错误，如OutOfMemorry内存溢出异常等。\n\n### Exception\nException是程序异常类，由程序内部产生。Exception又分为运行时异常、非运行时异常。\n\n#### 运行时异常\n\n运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过，运行时异常可处理或者不处理。运行时异常一般常出来定义系统的自定义异常，业务根据自定义异常做出不同的处理。\n\n常见的运行时异常如NullPointException、ArrayIndexOutOfBoundsException等。\n\n#### 非运行时异常\n\n非运行时异常是程序必须进行处理的异常，捕获或者抛出，如果不处理程序就不能编译通过。如常见的IOException、ClassNotFoundException等。\n\n","source":"_posts/基础/一张图搞清楚Java异常机制.md","raw":"---\ntitle: 一张图搞清楚Java异常机制\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 基础\n---\n\n下面是Java异常类的组织结构，红色区域的异常类表示是程序需要显示捕捉或者抛出的。\n\n![image](https://www.programcreek.com/wp-content/uploads/2009/02/Exception-Hierarchy-Diagram.jpeg)\n\n### Throwable\nThrowable是Java异常的顶级类，所有的异常都继承于这个类。\n\nError，Exception是异常类的两个大分类。\n\n### Error\n\nError是非程序异常，即程序不能捕获的异常，一般是编译或者系统性的错误，如OutOfMemorry内存溢出异常等。\n\n### Exception\nException是程序异常类，由程序内部产生。Exception又分为运行时异常、非运行时异常。\n\n#### 运行时异常\n\n运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过，运行时异常可处理或者不处理。运行时异常一般常出来定义系统的自定义异常，业务根据自定义异常做出不同的处理。\n\n常见的运行时异常如NullPointException、ArrayIndexOutOfBoundsException等。\n\n#### 非运行时异常\n\n非运行时异常是程序必须进行处理的异常，捕获或者抛出，如果不处理程序就不能编译通过。如常见的IOException、ClassNotFoundException等。\n\n","slug":"基础/一张图搞清楚Java异常机制","published":1,"updated":"2025-10-15T07:19:51.824Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076v003xqkd4ajswdron","content":"<p>下面是Java异常类的组织结构，红色区域的异常类表示是程序需要显示捕捉或者抛出的。</p>\n<p><img src=\"https://www.programcreek.com/wp-content/uploads/2009/02/Exception-Hierarchy-Diagram.jpeg\" alt=\"image\"></p>\n<h3 id=\"Throwable\"><a href=\"#Throwable\" class=\"headerlink\" title=\"Throwable\"></a>Throwable</h3><p>Throwable是Java异常的顶级类，所有的异常都继承于这个类。</p>\n<p>Error，Exception是异常类的两个大分类。</p>\n<h3 id=\"Error\"><a href=\"#Error\" class=\"headerlink\" title=\"Error\"></a>Error</h3><p>Error是非程序异常，即程序不能捕获的异常，一般是编译或者系统性的错误，如OutOfMemorry内存溢出异常等。</p>\n<h3 id=\"Exception\"><a href=\"#Exception\" class=\"headerlink\" title=\"Exception\"></a>Exception</h3><p>Exception是程序异常类，由程序内部产生。Exception又分为运行时异常、非运行时异常。</p>\n<h4 id=\"运行时异常\"><a href=\"#运行时异常\" class=\"headerlink\" title=\"运行时异常\"></a>运行时异常</h4><p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过，运行时异常可处理或者不处理。运行时异常一般常出来定义系统的自定义异常，业务根据自定义异常做出不同的处理。</p>\n<p>常见的运行时异常如NullPointException、ArrayIndexOutOfBoundsException等。</p>\n<h4 id=\"非运行时异常\"><a href=\"#非运行时异常\" class=\"headerlink\" title=\"非运行时异常\"></a>非运行时异常</h4><p>非运行时异常是程序必须进行处理的异常，捕获或者抛出，如果不处理程序就不能编译通过。如常见的IOException、ClassNotFoundException等。</p>\n","excerpt":"","more":"<p>下面是Java异常类的组织结构，红色区域的异常类表示是程序需要显示捕捉或者抛出的。</p>\n<p><img src=\"https://www.programcreek.com/wp-content/uploads/2009/02/Exception-Hierarchy-Diagram.jpeg\" alt=\"image\"></p>\n<h3 id=\"Throwable\"><a href=\"#Throwable\" class=\"headerlink\" title=\"Throwable\"></a>Throwable</h3><p>Throwable是Java异常的顶级类，所有的异常都继承于这个类。</p>\n<p>Error，Exception是异常类的两个大分类。</p>\n<h3 id=\"Error\"><a href=\"#Error\" class=\"headerlink\" title=\"Error\"></a>Error</h3><p>Error是非程序异常，即程序不能捕获的异常，一般是编译或者系统性的错误，如OutOfMemorry内存溢出异常等。</p>\n<h3 id=\"Exception\"><a href=\"#Exception\" class=\"headerlink\" title=\"Exception\"></a>Exception</h3><p>Exception是程序异常类，由程序内部产生。Exception又分为运行时异常、非运行时异常。</p>\n<h4 id=\"运行时异常\"><a href=\"#运行时异常\" class=\"headerlink\" title=\"运行时异常\"></a>运行时异常</h4><p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过，运行时异常可处理或者不处理。运行时异常一般常出来定义系统的自定义异常，业务根据自定义异常做出不同的处理。</p>\n<p>常见的运行时异常如NullPointException、ArrayIndexOutOfBoundsException等。</p>\n<h4 id=\"非运行时异常\"><a href=\"#非运行时异常\" class=\"headerlink\" title=\"非运行时异常\"></a>非运行时异常</h4><p>非运行时异常是程序必须进行处理的异常，捕获或者抛出，如果不处理程序就不能编译通过。如常见的IOException、ClassNotFoundException等。</p>\n"},{"title":"你真的搞懂 transient  关键字了吗？","date":"2025-10-14T06:42:34.000Z","_content":"\n## 先解释下什么是序列化\n\n我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。\n\nJava序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。\n\n更多序列化请参考：《[关于Java序列化你应该知道的一切](https://mp.weixin.qq.com/s/wHmK1kKyne6gCkIxt0NERQ)》这篇文章。\n\n## 什么是 transient？\n\n简单来说就是，被 transient 修饰的变量不能被序列化。\n\n**具体来看下面的示例1**\n\n```\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n/**\n * @author \n */\npublic class TransientTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser user = new User();\n\t\tuser.setUsername(\"Java技术\");\n\t\tuser.setId(\"javastack\");\n\n\t\tSystem.out.println(\"\\n序列化之前\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"d:/user.txt\"));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\n\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(\"d:/user.txt\"));\n\t\tuser = (User) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(\"\\n序列化之后\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t}\n}\n\n/**\n * @author \n */\nclass User implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\n序列化之前\nusername: Java技术\nid: javastack\n\n序列化之后\nusername: Java技术\nid: null\n```\n\n示例1在 id 字段上加了 transient 关键字修饰，反序列化出来之后值为 null，说明了被 transient 修饰的变量不能被序列化。\n\n## 静态变量能被序列化吗？\n\n这个话题也是最近栈长的Java技术vip群里面讨论的，大家对这个知识点比较模糊，我就写了这篇文章测试总结一下。\n\n![](http://img.javastack.cn/微信图片_20190214162351.png)\n\n> 如果你也想加入我们的Java技术vip群和各位大牛一起讨论技术，那点击[这个链接](https://mp.weixin.qq.com/s/iqCLAduVzDqt19L6D4FCUQ)了解加入吧。\n\n那么，到底静态变量能被序列化吗？废话少说，先动手测试下吧！\n\n示例2：\n\n```\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n/**\n * @author \n */\npublic class TransientStaticTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser2 user = new User2();\n\t\tUser2.username = \"Java技术1\";\n\t\tuser.setId(\"javastack\");\n\n\t\tSystem.out.println(\"\\n序列化之前\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"d:/user.txt\"));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\t\t\n\t\t// 在反序列化出来之前，改变静态变量的值\n\t\tUser2.username = \"Java技术2\";\n\n\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(\"d:/user.txt\"));\n\t\tuser = (User2) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(\"\\n序列化之后\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t}\n}\n\n/**\n * @author \n */\nclass User2 implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic static String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\n序列化之前\nusername: Java技术1\nid: javastack\n\n序列化之后\nusername: Java技术2\nid: null\n```\n\n示例2把 username 改为了 public static, 并在反序列化出来之前改变了静态变量的值，结果可以看出序列化之后的值并非序列化进去时的值。\n\n由以上结果分析可知，静态变量不能被序列化，示例2读取出来的是 username 在 JVM 内存中存储的值。\n\n## transient 真不能被序列化吗？\n\n继续来看示例3：\n\n```\nimport java.io.Externalizable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\n\n/**\n * @author \n */\npublic class ExternalizableTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser3 user = new User3();\n\t\tuser.setUsername(\"Java技术\");\n\t\tuser.setId(\"javastack\");\n\t\tObjectOutput objectOutput = new ObjectOutputStream(new FileOutputStream(new File(\"javastack\")));\n\t\tobjectOutput.writeObject(user);\n\n\t\tObjectInput objectInput = new ObjectInputStream(new FileInputStream(new File(\"javastack\")));\n\t\tuser = (User3) objectInput.readObject();\n\n\t\tSystem.out.println(user.getUsername());\n\t\tSystem.out.println(user.getId());\n\n\t\tobjectOutput.close();\n\t\tobjectInput.close();\n\t}\n\n}\n\n/**\n * @author \n */\nclass User3 implements Externalizable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic User3() {\n\n\t}\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\t@Override\n\tpublic void writeExternal(ObjectOutput objectOutput) throws IOException {\n\t\tobjectOutput.writeObject(id);\n\t}\n\n\t@Override\n\tpublic void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException {\n\t\tid = (String) objectInput.readObject();\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\nnull\njavastack\n```\n\n示例3的 id 被 transient 修改了，为什么还能序列化出来？那是因为 User3 实现了接口 Externalizable，而不是 Serializable。\n\n在 Java 中有两种实现序列化的方式，Serializable 和 Externalizable，可能大部分人只知道 Serializable 而不知道 Externalizable。\n\n这两种序列化方式的区别是：实现了 Serializable 接口是自动序列化的，实现 Externalizable 则需要手动序列化，通过 writeExternal 和 readExternal 方法手动进行，这也是为什么上面的 username 为 null 的原因了。\n\n## transient 关键字总结\n\n1）transient修饰的变量不能被序列化；\n\n2）transient只作用于实现 Serializable 接口；\n\n3）transient只能用来修饰普通成员变量字段；\n\n4）不管有没有 transient 修饰，静态变量都不能被序列化；\n\n\n\n","source":"_posts/基础/你真的搞懂 transient  关键字了吗？.md","raw":"---\ntitle: 你真的搞懂 transient  关键字了吗？\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 基础\n---\n\n## 先解释下什么是序列化\n\n我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。\n\nJava序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。\n\n更多序列化请参考：《[关于Java序列化你应该知道的一切](https://mp.weixin.qq.com/s/wHmK1kKyne6gCkIxt0NERQ)》这篇文章。\n\n## 什么是 transient？\n\n简单来说就是，被 transient 修饰的变量不能被序列化。\n\n**具体来看下面的示例1**\n\n```\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n/**\n * @author \n */\npublic class TransientTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser user = new User();\n\t\tuser.setUsername(\"Java技术\");\n\t\tuser.setId(\"javastack\");\n\n\t\tSystem.out.println(\"\\n序列化之前\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"d:/user.txt\"));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\n\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(\"d:/user.txt\"));\n\t\tuser = (User) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(\"\\n序列化之后\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t}\n}\n\n/**\n * @author \n */\nclass User implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\n序列化之前\nusername: Java技术\nid: javastack\n\n序列化之后\nusername: Java技术\nid: null\n```\n\n示例1在 id 字段上加了 transient 关键字修饰，反序列化出来之后值为 null，说明了被 transient 修饰的变量不能被序列化。\n\n## 静态变量能被序列化吗？\n\n这个话题也是最近栈长的Java技术vip群里面讨论的，大家对这个知识点比较模糊，我就写了这篇文章测试总结一下。\n\n![](http://img.javastack.cn/微信图片_20190214162351.png)\n\n> 如果你也想加入我们的Java技术vip群和各位大牛一起讨论技术，那点击[这个链接](https://mp.weixin.qq.com/s/iqCLAduVzDqt19L6D4FCUQ)了解加入吧。\n\n那么，到底静态变量能被序列化吗？废话少说，先动手测试下吧！\n\n示例2：\n\n```\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n/**\n * @author \n */\npublic class TransientStaticTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser2 user = new User2();\n\t\tUser2.username = \"Java技术1\";\n\t\tuser.setId(\"javastack\");\n\n\t\tSystem.out.println(\"\\n序列化之前\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"d:/user.txt\"));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\t\t\n\t\t// 在反序列化出来之前，改变静态变量的值\n\t\tUser2.username = \"Java技术2\";\n\n\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(\"d:/user.txt\"));\n\t\tuser = (User2) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(\"\\n序列化之后\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t}\n}\n\n/**\n * @author \n */\nclass User2 implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic static String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\n序列化之前\nusername: Java技术1\nid: javastack\n\n序列化之后\nusername: Java技术2\nid: null\n```\n\n示例2把 username 改为了 public static, 并在反序列化出来之前改变了静态变量的值，结果可以看出序列化之后的值并非序列化进去时的值。\n\n由以上结果分析可知，静态变量不能被序列化，示例2读取出来的是 username 在 JVM 内存中存储的值。\n\n## transient 真不能被序列化吗？\n\n继续来看示例3：\n\n```\nimport java.io.Externalizable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\n\n/**\n * @author \n */\npublic class ExternalizableTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser3 user = new User3();\n\t\tuser.setUsername(\"Java技术\");\n\t\tuser.setId(\"javastack\");\n\t\tObjectOutput objectOutput = new ObjectOutputStream(new FileOutputStream(new File(\"javastack\")));\n\t\tobjectOutput.writeObject(user);\n\n\t\tObjectInput objectInput = new ObjectInputStream(new FileInputStream(new File(\"javastack\")));\n\t\tuser = (User3) objectInput.readObject();\n\n\t\tSystem.out.println(user.getUsername());\n\t\tSystem.out.println(user.getId());\n\n\t\tobjectOutput.close();\n\t\tobjectInput.close();\n\t}\n\n}\n\n/**\n * @author \n */\nclass User3 implements Externalizable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic User3() {\n\n\t}\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\t@Override\n\tpublic void writeExternal(ObjectOutput objectOutput) throws IOException {\n\t\tobjectOutput.writeObject(id);\n\t}\n\n\t@Override\n\tpublic void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException {\n\t\tid = (String) objectInput.readObject();\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\nnull\njavastack\n```\n\n示例3的 id 被 transient 修改了，为什么还能序列化出来？那是因为 User3 实现了接口 Externalizable，而不是 Serializable。\n\n在 Java 中有两种实现序列化的方式，Serializable 和 Externalizable，可能大部分人只知道 Serializable 而不知道 Externalizable。\n\n这两种序列化方式的区别是：实现了 Serializable 接口是自动序列化的，实现 Externalizable 则需要手动序列化，通过 writeExternal 和 readExternal 方法手动进行，这也是为什么上面的 username 为 null 的原因了。\n\n## transient 关键字总结\n\n1）transient修饰的变量不能被序列化；\n\n2）transient只作用于实现 Serializable 接口；\n\n3）transient只能用来修饰普通成员变量字段；\n\n4）不管有没有 transient 修饰，静态变量都不能被序列化；\n\n\n\n","slug":"基础/你真的搞懂 transient  关键字了吗？","published":1,"updated":"2025-10-15T07:19:51.838Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076w0040qkd45oqzaqxy","content":"<h2 id=\"先解释下什么是序列化\"><a href=\"#先解释下什么是序列化\" class=\"headerlink\" title=\"先解释下什么是序列化\"></a>先解释下什么是序列化</h2><p>我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。</p>\n<p>Java序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。</p>\n<p>更多序列化请参考：《<a href=\"https://mp.weixin.qq.com/s/wHmK1kKyne6gCkIxt0NERQ\">关于Java序列化你应该知道的一切</a>》这篇文章。</p>\n<h2 id=\"什么是-transient？\"><a href=\"#什么是-transient？\" class=\"headerlink\" title=\"什么是 transient？\"></a>什么是 transient？</h2><p>简单来说就是，被 transient 修饰的变量不能被序列化。</p>\n<p><strong>具体来看下面的示例1</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n&#x2F;**\n * @author \n *&#x2F;\npublic class TransientTest &#123;\n\n\tpublic static void main(String[] args) throws Exception &#123;\n\n\t\tUser user &#x3D; new User();\n\t\tuser.setUsername(&quot;Java技术&quot;);\n\t\tuser.setId(&quot;javastack&quot;);\n\n\t\tSystem.out.println(&quot;\\n序列化之前&quot;);\n\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());\n\t\tSystem.out.println(&quot;id: &quot; + user.getId());\n\n\t\tObjectOutputStream os &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;d:&#x2F;user.txt&quot;));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\n\t\tObjectInputStream is &#x3D; new ObjectInputStream(new FileInputStream(&quot;d:&#x2F;user.txt&quot;));\n\t\tuser &#x3D; (User) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(&quot;\\n序列化之后&quot;);\n\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());\n\t\tSystem.out.println(&quot;id: &quot; + user.getId());\n\n\t&#125;\n&#125;\n\n&#x2F;**\n * @author \n *&#x2F;\nclass User implements Serializable &#123;\n\n\tprivate static final long serialVersionUID &#x3D; 1L;\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() &#123;\n\t\treturn username;\n\t&#125;\n\n\tpublic void setUsername(String username) &#123;\n\t\tthis.username &#x3D; username;\n\t&#125;\n\n\tpublic String getId() &#123;\n\t\treturn id;\n\t&#125;\n\n\tpublic void setId(String id) &#123;\n\t\tthis.id &#x3D; id;\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>输出结果：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">序列化之前\nusername: Java技术\nid: javastack\n\n序列化之后\nusername: Java技术\nid: null<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>示例1在 id 字段上加了 transient 关键字修饰，反序列化出来之后值为 null，说明了被 transient 修饰的变量不能被序列化。</p>\n<h2 id=\"静态变量能被序列化吗？\"><a href=\"#静态变量能被序列化吗？\" class=\"headerlink\" title=\"静态变量能被序列化吗？\"></a>静态变量能被序列化吗？</h2><p>这个话题也是最近栈长的Java技术vip群里面讨论的，大家对这个知识点比较模糊，我就写了这篇文章测试总结一下。</p>\n<p><img src=\"http://img.javastack.cn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190214162351.png\"></p>\n<blockquote>\n<p>如果你也想加入我们的Java技术vip群和各位大牛一起讨论技术，那点击<a href=\"https://mp.weixin.qq.com/s/iqCLAduVzDqt19L6D4FCUQ\">这个链接</a>了解加入吧。</p>\n</blockquote>\n<p>那么，到底静态变量能被序列化吗？废话少说，先动手测试下吧！</p>\n<p>示例2：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n&#x2F;**\n * @author \n *&#x2F;\npublic class TransientStaticTest &#123;\n\n\tpublic static void main(String[] args) throws Exception &#123;\n\n\t\tUser2 user &#x3D; new User2();\n\t\tUser2.username &#x3D; &quot;Java技术1&quot;;\n\t\tuser.setId(&quot;javastack&quot;);\n\n\t\tSystem.out.println(&quot;\\n序列化之前&quot;);\n\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());\n\t\tSystem.out.println(&quot;id: &quot; + user.getId());\n\n\t\tObjectOutputStream os &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;d:&#x2F;user.txt&quot;));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\t\t\n\t\t&#x2F;&#x2F; 在反序列化出来之前，改变静态变量的值\n\t\tUser2.username &#x3D; &quot;Java技术2&quot;;\n\n\t\tObjectInputStream is &#x3D; new ObjectInputStream(new FileInputStream(&quot;d:&#x2F;user.txt&quot;));\n\t\tuser &#x3D; (User2) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(&quot;\\n序列化之后&quot;);\n\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());\n\t\tSystem.out.println(&quot;id: &quot; + user.getId());\n\n\t&#125;\n&#125;\n\n&#x2F;**\n * @author \n *&#x2F;\nclass User2 implements Serializable &#123;\n\n\tprivate static final long serialVersionUID &#x3D; 1L;\n\n\tpublic static String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() &#123;\n\t\treturn username;\n\t&#125;\n\n\tpublic String getId() &#123;\n\t\treturn id;\n\t&#125;\n\n\tpublic void setId(String id) &#123;\n\t\tthis.id &#x3D; id;\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>输出结果：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">序列化之前\nusername: Java技术1\nid: javastack\n\n序列化之后\nusername: Java技术2\nid: null<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>示例2把 username 改为了 public static, 并在反序列化出来之前改变了静态变量的值，结果可以看出序列化之后的值并非序列化进去时的值。</p>\n<p>由以上结果分析可知，静态变量不能被序列化，示例2读取出来的是 username 在 JVM 内存中存储的值。</p>\n<h2 id=\"transient-真不能被序列化吗？\"><a href=\"#transient-真不能被序列化吗？\" class=\"headerlink\" title=\"transient 真不能被序列化吗？\"></a>transient 真不能被序列化吗？</h2><p>继续来看示例3：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.io.Externalizable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\n\n&#x2F;**\n * @author \n *&#x2F;\npublic class ExternalizableTest &#123;\n\n\tpublic static void main(String[] args) throws Exception &#123;\n\n\t\tUser3 user &#x3D; new User3();\n\t\tuser.setUsername(&quot;Java技术&quot;);\n\t\tuser.setId(&quot;javastack&quot;);\n\t\tObjectOutput objectOutput &#x3D; new ObjectOutputStream(new FileOutputStream(new File(&quot;javastack&quot;)));\n\t\tobjectOutput.writeObject(user);\n\n\t\tObjectInput objectInput &#x3D; new ObjectInputStream(new FileInputStream(new File(&quot;javastack&quot;)));\n\t\tuser &#x3D; (User3) objectInput.readObject();\n\n\t\tSystem.out.println(user.getUsername());\n\t\tSystem.out.println(user.getId());\n\n\t\tobjectOutput.close();\n\t\tobjectInput.close();\n\t&#125;\n\n&#125;\n\n&#x2F;**\n * @author \n *&#x2F;\nclass User3 implements Externalizable &#123;\n\n\tprivate static final long serialVersionUID &#x3D; 1L;\n\n\tpublic User3() &#123;\n\n\t&#125;\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() &#123;\n\t\treturn username;\n\t&#125;\n\n\tpublic void setUsername(String username) &#123;\n\t\tthis.username &#x3D; username;\n\t&#125;\n\n\tpublic String getId() &#123;\n\t\treturn id;\n\t&#125;\n\n\tpublic void setId(String id) &#123;\n\t\tthis.id &#x3D; id;\n\t&#125;\n\n\t@Override\n\tpublic void writeExternal(ObjectOutput objectOutput) throws IOException &#123;\n\t\tobjectOutput.writeObject(id);\n\t&#125;\n\n\t@Override\n\tpublic void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException &#123;\n\t\tid &#x3D; (String) objectInput.readObject();\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>输出结果：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">null\njavastack<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>示例3的 id 被 transient 修改了，为什么还能序列化出来？那是因为 User3 实现了接口 Externalizable，而不是 Serializable。</p>\n<p>在 Java 中有两种实现序列化的方式，Serializable 和 Externalizable，可能大部分人只知道 Serializable 而不知道 Externalizable。</p>\n<p>这两种序列化方式的区别是：实现了 Serializable 接口是自动序列化的，实现 Externalizable 则需要手动序列化，通过 writeExternal 和 readExternal 方法手动进行，这也是为什么上面的 username 为 null 的原因了。</p>\n<h2 id=\"transient-关键字总结\"><a href=\"#transient-关键字总结\" class=\"headerlink\" title=\"transient 关键字总结\"></a>transient 关键字总结</h2><p>1）transient修饰的变量不能被序列化；</p>\n<p>2）transient只作用于实现 Serializable 接口；</p>\n<p>3）transient只能用来修饰普通成员变量字段；</p>\n<p>4）不管有没有 transient 修饰，静态变量都不能被序列化；</p>\n","excerpt":"","more":"<h2 id=\"先解释下什么是序列化\"><a href=\"#先解释下什么是序列化\" class=\"headerlink\" title=\"先解释下什么是序列化\"></a>先解释下什么是序列化</h2><p>我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。</p>\n<p>Java序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。</p>\n<p>更多序列化请参考：《<a href=\"https://mp.weixin.qq.com/s/wHmK1kKyne6gCkIxt0NERQ\">关于Java序列化你应该知道的一切</a>》这篇文章。</p>\n<h2 id=\"什么是-transient？\"><a href=\"#什么是-transient？\" class=\"headerlink\" title=\"什么是 transient？\"></a>什么是 transient？</h2><p>简单来说就是，被 transient 修饰的变量不能被序列化。</p>\n<p><strong>具体来看下面的示例1</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n&#x2F;**\n * @author \n *&#x2F;\npublic class TransientTest &#123;\n\n\tpublic static void main(String[] args) throws Exception &#123;\n\n\t\tUser user &#x3D; new User();\n\t\tuser.setUsername(&quot;Java技术&quot;);\n\t\tuser.setId(&quot;javastack&quot;);\n\n\t\tSystem.out.println(&quot;\\n序列化之前&quot;);\n\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());\n\t\tSystem.out.println(&quot;id: &quot; + user.getId());\n\n\t\tObjectOutputStream os &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;d:&#x2F;user.txt&quot;));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\n\t\tObjectInputStream is &#x3D; new ObjectInputStream(new FileInputStream(&quot;d:&#x2F;user.txt&quot;));\n\t\tuser &#x3D; (User) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(&quot;\\n序列化之后&quot;);\n\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());\n\t\tSystem.out.println(&quot;id: &quot; + user.getId());\n\n\t&#125;\n&#125;\n\n&#x2F;**\n * @author \n *&#x2F;\nclass User implements Serializable &#123;\n\n\tprivate static final long serialVersionUID &#x3D; 1L;\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() &#123;\n\t\treturn username;\n\t&#125;\n\n\tpublic void setUsername(String username) &#123;\n\t\tthis.username &#x3D; username;\n\t&#125;\n\n\tpublic String getId() &#123;\n\t\treturn id;\n\t&#125;\n\n\tpublic void setId(String id) &#123;\n\t\tthis.id &#x3D; id;\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>输出结果：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">序列化之前\nusername: Java技术\nid: javastack\n\n序列化之后\nusername: Java技术\nid: null<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>示例1在 id 字段上加了 transient 关键字修饰，反序列化出来之后值为 null，说明了被 transient 修饰的变量不能被序列化。</p>\n<h2 id=\"静态变量能被序列化吗？\"><a href=\"#静态变量能被序列化吗？\" class=\"headerlink\" title=\"静态变量能被序列化吗？\"></a>静态变量能被序列化吗？</h2><p>这个话题也是最近栈长的Java技术vip群里面讨论的，大家对这个知识点比较模糊，我就写了这篇文章测试总结一下。</p>\n<p><img src=\"http://img.javastack.cn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190214162351.png\"></p>\n<blockquote>\n<p>如果你也想加入我们的Java技术vip群和各位大牛一起讨论技术，那点击<a href=\"https://mp.weixin.qq.com/s/iqCLAduVzDqt19L6D4FCUQ\">这个链接</a>了解加入吧。</p>\n</blockquote>\n<p>那么，到底静态变量能被序列化吗？废话少说，先动手测试下吧！</p>\n<p>示例2：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n&#x2F;**\n * @author \n *&#x2F;\npublic class TransientStaticTest &#123;\n\n\tpublic static void main(String[] args) throws Exception &#123;\n\n\t\tUser2 user &#x3D; new User2();\n\t\tUser2.username &#x3D; &quot;Java技术1&quot;;\n\t\tuser.setId(&quot;javastack&quot;);\n\n\t\tSystem.out.println(&quot;\\n序列化之前&quot;);\n\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());\n\t\tSystem.out.println(&quot;id: &quot; + user.getId());\n\n\t\tObjectOutputStream os &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;d:&#x2F;user.txt&quot;));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\t\t\n\t\t&#x2F;&#x2F; 在反序列化出来之前，改变静态变量的值\n\t\tUser2.username &#x3D; &quot;Java技术2&quot;;\n\n\t\tObjectInputStream is &#x3D; new ObjectInputStream(new FileInputStream(&quot;d:&#x2F;user.txt&quot;));\n\t\tuser &#x3D; (User2) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(&quot;\\n序列化之后&quot;);\n\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());\n\t\tSystem.out.println(&quot;id: &quot; + user.getId());\n\n\t&#125;\n&#125;\n\n&#x2F;**\n * @author \n *&#x2F;\nclass User2 implements Serializable &#123;\n\n\tprivate static final long serialVersionUID &#x3D; 1L;\n\n\tpublic static String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() &#123;\n\t\treturn username;\n\t&#125;\n\n\tpublic String getId() &#123;\n\t\treturn id;\n\t&#125;\n\n\tpublic void setId(String id) &#123;\n\t\tthis.id &#x3D; id;\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>输出结果：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">序列化之前\nusername: Java技术1\nid: javastack\n\n序列化之后\nusername: Java技术2\nid: null<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>示例2把 username 改为了 public static, 并在反序列化出来之前改变了静态变量的值，结果可以看出序列化之后的值并非序列化进去时的值。</p>\n<p>由以上结果分析可知，静态变量不能被序列化，示例2读取出来的是 username 在 JVM 内存中存储的值。</p>\n<h2 id=\"transient-真不能被序列化吗？\"><a href=\"#transient-真不能被序列化吗？\" class=\"headerlink\" title=\"transient 真不能被序列化吗？\"></a>transient 真不能被序列化吗？</h2><p>继续来看示例3：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.io.Externalizable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\n\n&#x2F;**\n * @author \n *&#x2F;\npublic class ExternalizableTest &#123;\n\n\tpublic static void main(String[] args) throws Exception &#123;\n\n\t\tUser3 user &#x3D; new User3();\n\t\tuser.setUsername(&quot;Java技术&quot;);\n\t\tuser.setId(&quot;javastack&quot;);\n\t\tObjectOutput objectOutput &#x3D; new ObjectOutputStream(new FileOutputStream(new File(&quot;javastack&quot;)));\n\t\tobjectOutput.writeObject(user);\n\n\t\tObjectInput objectInput &#x3D; new ObjectInputStream(new FileInputStream(new File(&quot;javastack&quot;)));\n\t\tuser &#x3D; (User3) objectInput.readObject();\n\n\t\tSystem.out.println(user.getUsername());\n\t\tSystem.out.println(user.getId());\n\n\t\tobjectOutput.close();\n\t\tobjectInput.close();\n\t&#125;\n\n&#125;\n\n&#x2F;**\n * @author \n *&#x2F;\nclass User3 implements Externalizable &#123;\n\n\tprivate static final long serialVersionUID &#x3D; 1L;\n\n\tpublic User3() &#123;\n\n\t&#125;\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() &#123;\n\t\treturn username;\n\t&#125;\n\n\tpublic void setUsername(String username) &#123;\n\t\tthis.username &#x3D; username;\n\t&#125;\n\n\tpublic String getId() &#123;\n\t\treturn id;\n\t&#125;\n\n\tpublic void setId(String id) &#123;\n\t\tthis.id &#x3D; id;\n\t&#125;\n\n\t@Override\n\tpublic void writeExternal(ObjectOutput objectOutput) throws IOException &#123;\n\t\tobjectOutput.writeObject(id);\n\t&#125;\n\n\t@Override\n\tpublic void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException &#123;\n\t\tid &#x3D; (String) objectInput.readObject();\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>输出结果：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">null\njavastack<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>示例3的 id 被 transient 修改了，为什么还能序列化出来？那是因为 User3 实现了接口 Externalizable，而不是 Serializable。</p>\n<p>在 Java 中有两种实现序列化的方式，Serializable 和 Externalizable，可能大部分人只知道 Serializable 而不知道 Externalizable。</p>\n<p>这两种序列化方式的区别是：实现了 Serializable 接口是自动序列化的，实现 Externalizable 则需要手动序列化，通过 writeExternal 和 readExternal 方法手动进行，这也是为什么上面的 username 为 null 的原因了。</p>\n<h2 id=\"transient-关键字总结\"><a href=\"#transient-关键字总结\" class=\"headerlink\" title=\"transient 关键字总结\"></a>transient 关键字总结</h2><p>1）transient修饰的变量不能被序列化；</p>\n<p>2）transient只作用于实现 Serializable 接口；</p>\n<p>3）transient只能用来修饰普通成员变量字段；</p>\n<p>4）不管有没有 transient 修饰，静态变量都不能被序列化；</p>\n"},{"title":"你真的搞懂 transient 关键字了吗？","date":"2025-10-14T06:42:34.000Z","_content":"\n## 先解释下什么是序列化\n\n我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。\n\nJava序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。\n\n更多序列化请参考：《[关于Java序列化你应该知道的一切](https://mp.weixin.qq.com/s/wHmK1kKyne6gCkIxt0NERQ)》这篇文章。\n\n## 什么是 transient？\n\n简单来说就是，被 transient 修饰的变量不能被序列化。\n\n**具体来看下面的示例1**\n\n```\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n/**\n * @author \n */\npublic class TransientTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser user = new User();\n\t\tuser.setUsername(\"Java技术\");\n\t\tuser.setId(\"javastack\");\n\n\t\tSystem.out.println(\"\\n序列化之前\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"d:/user.txt\"));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\n\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(\"d:/user.txt\"));\n\t\tuser = (User) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(\"\\n序列化之后\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t}\n}\n\n/**\n * @author \n */\nclass User implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\n序列化之前\nusername: Java技术\nid: javastack\n\n序列化之后\nusername: Java技术\nid: null\n```\n\n示例1在 id 字段上加了 transient 关键字修饰，反序列化出来之后值为 null，说明了被 transient 修饰的变量不能被序列化。\n\n## 静态变量能被序列化吗？\n\n这个话题也是最近栈长的Java技术vip群里面讨论的，大家对这个知识点比较模糊，我就写了这篇文章测试总结一下。\n\n![](http://img.javastack.cn/微信图片_20190214162351.png)\n\n> 如果你也想加入我们的Java技术vip群和各位大牛一起讨论技术，那点击[这个链接](https://mp.weixin.qq.com/s/iqCLAduVzDqt19L6D4FCUQ)了解加入吧。\n\n那么，到底静态变量能被序列化吗？废话少说，先动手测试下吧！\n\n示例2：\n\n```\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n/**\n * @author \n */\npublic class TransientStaticTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser2 user = new User2();\n\t\tUser2.username = \"Java技术1\";\n\t\tuser.setId(\"javastack\");\n\n\t\tSystem.out.println(\"\\n序列化之前\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"d:/user.txt\"));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\t\t\n\t\t// 在反序列化出来之前，改变静态变量的值\n\t\tUser2.username = \"Java技术2\";\n\n\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(\"d:/user.txt\"));\n\t\tuser = (User2) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(\"\\n序列化之后\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t}\n}\n\n/**\n * @author \n */\nclass User2 implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic static String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\n序列化之前\nusername: Java技术1\nid: javastack\n\n序列化之后\nusername: Java技术2\nid: null\n```\n\n示例2把 username 改为了 public static, 并在反序列化出来之前改变了静态变量的值，结果可以看出序列化之后的值并非序列化进去时的值。\n\n由以上结果分析可知，静态变量不能被序列化，示例2读取出来的是 username 在 JVM 内存中存储的值。\n\n## transient 真不能被序列化吗？\n\n继续来看示例3：\n\n```\nimport java.io.Externalizable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\n\n/**\n * @author \n */\npublic class ExternalizableTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser3 user = new User3();\n\t\tuser.setUsername(\"Java技术\");\n\t\tuser.setId(\"javastack\");\n\t\tObjectOutput objectOutput = new ObjectOutputStream(new FileOutputStream(new File(\"javastack\")));\n\t\tobjectOutput.writeObject(user);\n\n\t\tObjectInput objectInput = new ObjectInputStream(new FileInputStream(new File(\"javastack\")));\n\t\tuser = (User3) objectInput.readObject();\n\n\t\tSystem.out.println(user.getUsername());\n\t\tSystem.out.println(user.getId());\n\n\t\tobjectOutput.close();\n\t\tobjectInput.close();\n\t}\n\n}\n\n/**\n * @author \n */\nclass User3 implements Externalizable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic User3() {\n\n\t}\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\t@Override\n\tpublic void writeExternal(ObjectOutput objectOutput) throws IOException {\n\t\tobjectOutput.writeObject(id);\n\t}\n\n\t@Override\n\tpublic void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException {\n\t\tid = (String) objectInput.readObject();\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\nnull\njavastack\n```\n\n示例3的 id 被 transient 修改了，为什么还能序列化出来？那是因为 User3 实现了接口 Externalizable，而不是 Serializable。\n\n在 Java 中有两种实现序列化的方式，Serializable 和 Externalizable，可能大部分人只知道 Serializable 而不知道 Externalizable。\n\n这两种序列化方式的区别是：实现了 Serializable 接口是自动序列化的，实现 Externalizable 则需要手动序列化，通过 writeExternal 和 readExternal 方法手动进行，这也是为什么上面的 username 为 null 的原因了。\n\n## transient 关键字总结\n\n1）transient修饰的变量不能被序列化；\n\n2）transient只作用于实现 Serializable 接口；\n\n3）transient只能用来修饰普通成员变量字段；\n\n4）不管有没有 transient 修饰，静态变量都不能被序列化；\n\n\n\n","source":"_posts/基础/你真的搞懂 transient 关键字了吗？.md","raw":"---\ntitle: 你真的搞懂 transient 关键字了吗？\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 基础\n---\n\n## 先解释下什么是序列化\n\n我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。\n\nJava序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。\n\n更多序列化请参考：《[关于Java序列化你应该知道的一切](https://mp.weixin.qq.com/s/wHmK1kKyne6gCkIxt0NERQ)》这篇文章。\n\n## 什么是 transient？\n\n简单来说就是，被 transient 修饰的变量不能被序列化。\n\n**具体来看下面的示例1**\n\n```\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n/**\n * @author \n */\npublic class TransientTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser user = new User();\n\t\tuser.setUsername(\"Java技术\");\n\t\tuser.setId(\"javastack\");\n\n\t\tSystem.out.println(\"\\n序列化之前\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"d:/user.txt\"));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\n\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(\"d:/user.txt\"));\n\t\tuser = (User) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(\"\\n序列化之后\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t}\n}\n\n/**\n * @author \n */\nclass User implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\n序列化之前\nusername: Java技术\nid: javastack\n\n序列化之后\nusername: Java技术\nid: null\n```\n\n示例1在 id 字段上加了 transient 关键字修饰，反序列化出来之后值为 null，说明了被 transient 修饰的变量不能被序列化。\n\n## 静态变量能被序列化吗？\n\n这个话题也是最近栈长的Java技术vip群里面讨论的，大家对这个知识点比较模糊，我就写了这篇文章测试总结一下。\n\n![](http://img.javastack.cn/微信图片_20190214162351.png)\n\n> 如果你也想加入我们的Java技术vip群和各位大牛一起讨论技术，那点击[这个链接](https://mp.weixin.qq.com/s/iqCLAduVzDqt19L6D4FCUQ)了解加入吧。\n\n那么，到底静态变量能被序列化吗？废话少说，先动手测试下吧！\n\n示例2：\n\n```\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n/**\n * @author \n */\npublic class TransientStaticTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser2 user = new User2();\n\t\tUser2.username = \"Java技术1\";\n\t\tuser.setId(\"javastack\");\n\n\t\tSystem.out.println(\"\\n序列化之前\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t\tObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"d:/user.txt\"));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\t\t\n\t\t// 在反序列化出来之前，改变静态变量的值\n\t\tUser2.username = \"Java技术2\";\n\n\t\tObjectInputStream is = new ObjectInputStream(new FileInputStream(\"d:/user.txt\"));\n\t\tuser = (User2) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(\"\\n序列化之后\");\n\t\tSystem.out.println(\"username: \" + user.getUsername());\n\t\tSystem.out.println(\"id: \" + user.getId());\n\n\t}\n}\n\n/**\n * @author \n */\nclass User2 implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic static String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\n序列化之前\nusername: Java技术1\nid: javastack\n\n序列化之后\nusername: Java技术2\nid: null\n```\n\n示例2把 username 改为了 public static, 并在反序列化出来之前改变了静态变量的值，结果可以看出序列化之后的值并非序列化进去时的值。\n\n由以上结果分析可知，静态变量不能被序列化，示例2读取出来的是 username 在 JVM 内存中存储的值。\n\n## transient 真不能被序列化吗？\n\n继续来看示例3：\n\n```\nimport java.io.Externalizable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\n\n/**\n * @author \n */\npublic class ExternalizableTest {\n\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tUser3 user = new User3();\n\t\tuser.setUsername(\"Java技术\");\n\t\tuser.setId(\"javastack\");\n\t\tObjectOutput objectOutput = new ObjectOutputStream(new FileOutputStream(new File(\"javastack\")));\n\t\tobjectOutput.writeObject(user);\n\n\t\tObjectInput objectInput = new ObjectInputStream(new FileInputStream(new File(\"javastack\")));\n\t\tuser = (User3) objectInput.readObject();\n\n\t\tSystem.out.println(user.getUsername());\n\t\tSystem.out.println(user.getId());\n\n\t\tobjectOutput.close();\n\t\tobjectInput.close();\n\t}\n\n}\n\n/**\n * @author \n */\nclass User3 implements Externalizable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic User3() {\n\n\t}\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\t@Override\n\tpublic void writeExternal(ObjectOutput objectOutput) throws IOException {\n\t\tobjectOutput.writeObject(id);\n\t}\n\n\t@Override\n\tpublic void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException {\n\t\tid = (String) objectInput.readObject();\n\t}\n\n}\n```\n\n**输出结果：**\n\n```\nnull\njavastack\n```\n\n示例3的 id 被 transient 修改了，为什么还能序列化出来？那是因为 User3 实现了接口 Externalizable，而不是 Serializable。\n\n在 Java 中有两种实现序列化的方式，Serializable 和 Externalizable，可能大部分人只知道 Serializable 而不知道 Externalizable。\n\n这两种序列化方式的区别是：实现了 Serializable 接口是自动序列化的，实现 Externalizable 则需要手动序列化，通过 writeExternal 和 readExternal 方法手动进行，这也是为什么上面的 username 为 null 的原因了。\n\n## transient 关键字总结\n\n1）transient修饰的变量不能被序列化；\n\n2）transient只作用于实现 Serializable 接口；\n\n3）transient只能用来修饰普通成员变量字段；\n\n4）不管有没有 transient 修饰，静态变量都不能被序列化；\n\n\n\n","slug":"基础/你真的搞懂 transient 关键字了吗？","published":1,"updated":"2025-10-15T07:19:51.829Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076w0043qkd420r86rm2","content":"<h2 id=\"先解释下什么是序列化\"><a href=\"#先解释下什么是序列化\" class=\"headerlink\" title=\"先解释下什么是序列化\"></a>先解释下什么是序列化</h2><p>我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。</p>\n<p>Java序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。</p>\n<p>更多序列化请参考：《<a href=\"https://mp.weixin.qq.com/s/wHmK1kKyne6gCkIxt0NERQ\">关于Java序列化你应该知道的一切</a>》这篇文章。</p>\n<h2 id=\"什么是-transient？\"><a href=\"#什么是-transient？\" class=\"headerlink\" title=\"什么是 transient？\"></a>什么是 transient？</h2><p>简单来说就是，被 transient 修饰的变量不能被序列化。</p>\n<p><strong>具体来看下面的示例1</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n&#x2F;**\n * @author \n *&#x2F;\npublic class TransientTest &#123;\n\n\tpublic static void main(String[] args) throws Exception &#123;\n\n\t\tUser user &#x3D; new User();\n\t\tuser.setUsername(&quot;Java技术&quot;);\n\t\tuser.setId(&quot;javastack&quot;);\n\n\t\tSystem.out.println(&quot;\\n序列化之前&quot;);\n\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());\n\t\tSystem.out.println(&quot;id: &quot; + user.getId());\n\n\t\tObjectOutputStream os &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;d:&#x2F;user.txt&quot;));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\n\t\tObjectInputStream is &#x3D; new ObjectInputStream(new FileInputStream(&quot;d:&#x2F;user.txt&quot;));\n\t\tuser &#x3D; (User) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(&quot;\\n序列化之后&quot;);\n\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());\n\t\tSystem.out.println(&quot;id: &quot; + user.getId());\n\n\t&#125;\n&#125;\n\n&#x2F;**\n * @author \n *&#x2F;\nclass User implements Serializable &#123;\n\n\tprivate static final long serialVersionUID &#x3D; 1L;\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() &#123;\n\t\treturn username;\n\t&#125;\n\n\tpublic void setUsername(String username) &#123;\n\t\tthis.username &#x3D; username;\n\t&#125;\n\n\tpublic String getId() &#123;\n\t\treturn id;\n\t&#125;\n\n\tpublic void setId(String id) &#123;\n\t\tthis.id &#x3D; id;\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>输出结果：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">序列化之前\nusername: Java技术\nid: javastack\n\n序列化之后\nusername: Java技术\nid: null<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>示例1在 id 字段上加了 transient 关键字修饰，反序列化出来之后值为 null，说明了被 transient 修饰的变量不能被序列化。</p>\n<h2 id=\"静态变量能被序列化吗？\"><a href=\"#静态变量能被序列化吗？\" class=\"headerlink\" title=\"静态变量能被序列化吗？\"></a>静态变量能被序列化吗？</h2><p>这个话题也是最近栈长的Java技术vip群里面讨论的，大家对这个知识点比较模糊，我就写了这篇文章测试总结一下。</p>\n<p><img src=\"http://img.javastack.cn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190214162351.png\"></p>\n<blockquote>\n<p>如果你也想加入我们的Java技术vip群和各位大牛一起讨论技术，那点击<a href=\"https://mp.weixin.qq.com/s/iqCLAduVzDqt19L6D4FCUQ\">这个链接</a>了解加入吧。</p>\n</blockquote>\n<p>那么，到底静态变量能被序列化吗？废话少说，先动手测试下吧！</p>\n<p>示例2：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n&#x2F;**\n * @author \n *&#x2F;\npublic class TransientStaticTest &#123;\n\n\tpublic static void main(String[] args) throws Exception &#123;\n\n\t\tUser2 user &#x3D; new User2();\n\t\tUser2.username &#x3D; &quot;Java技术1&quot;;\n\t\tuser.setId(&quot;javastack&quot;);\n\n\t\tSystem.out.println(&quot;\\n序列化之前&quot;);\n\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());\n\t\tSystem.out.println(&quot;id: &quot; + user.getId());\n\n\t\tObjectOutputStream os &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;d:&#x2F;user.txt&quot;));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\t\t\n\t\t&#x2F;&#x2F; 在反序列化出来之前，改变静态变量的值\n\t\tUser2.username &#x3D; &quot;Java技术2&quot;;\n\n\t\tObjectInputStream is &#x3D; new ObjectInputStream(new FileInputStream(&quot;d:&#x2F;user.txt&quot;));\n\t\tuser &#x3D; (User2) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(&quot;\\n序列化之后&quot;);\n\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());\n\t\tSystem.out.println(&quot;id: &quot; + user.getId());\n\n\t&#125;\n&#125;\n\n&#x2F;**\n * @author \n *&#x2F;\nclass User2 implements Serializable &#123;\n\n\tprivate static final long serialVersionUID &#x3D; 1L;\n\n\tpublic static String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() &#123;\n\t\treturn username;\n\t&#125;\n\n\tpublic String getId() &#123;\n\t\treturn id;\n\t&#125;\n\n\tpublic void setId(String id) &#123;\n\t\tthis.id &#x3D; id;\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>输出结果：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">序列化之前\nusername: Java技术1\nid: javastack\n\n序列化之后\nusername: Java技术2\nid: null<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>示例2把 username 改为了 public static, 并在反序列化出来之前改变了静态变量的值，结果可以看出序列化之后的值并非序列化进去时的值。</p>\n<p>由以上结果分析可知，静态变量不能被序列化，示例2读取出来的是 username 在 JVM 内存中存储的值。</p>\n<h2 id=\"transient-真不能被序列化吗？\"><a href=\"#transient-真不能被序列化吗？\" class=\"headerlink\" title=\"transient 真不能被序列化吗？\"></a>transient 真不能被序列化吗？</h2><p>继续来看示例3：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.io.Externalizable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\n\n&#x2F;**\n * @author \n *&#x2F;\npublic class ExternalizableTest &#123;\n\n\tpublic static void main(String[] args) throws Exception &#123;\n\n\t\tUser3 user &#x3D; new User3();\n\t\tuser.setUsername(&quot;Java技术&quot;);\n\t\tuser.setId(&quot;javastack&quot;);\n\t\tObjectOutput objectOutput &#x3D; new ObjectOutputStream(new FileOutputStream(new File(&quot;javastack&quot;)));\n\t\tobjectOutput.writeObject(user);\n\n\t\tObjectInput objectInput &#x3D; new ObjectInputStream(new FileInputStream(new File(&quot;javastack&quot;)));\n\t\tuser &#x3D; (User3) objectInput.readObject();\n\n\t\tSystem.out.println(user.getUsername());\n\t\tSystem.out.println(user.getId());\n\n\t\tobjectOutput.close();\n\t\tobjectInput.close();\n\t&#125;\n\n&#125;\n\n&#x2F;**\n * @author \n *&#x2F;\nclass User3 implements Externalizable &#123;\n\n\tprivate static final long serialVersionUID &#x3D; 1L;\n\n\tpublic User3() &#123;\n\n\t&#125;\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() &#123;\n\t\treturn username;\n\t&#125;\n\n\tpublic void setUsername(String username) &#123;\n\t\tthis.username &#x3D; username;\n\t&#125;\n\n\tpublic String getId() &#123;\n\t\treturn id;\n\t&#125;\n\n\tpublic void setId(String id) &#123;\n\t\tthis.id &#x3D; id;\n\t&#125;\n\n\t@Override\n\tpublic void writeExternal(ObjectOutput objectOutput) throws IOException &#123;\n\t\tobjectOutput.writeObject(id);\n\t&#125;\n\n\t@Override\n\tpublic void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException &#123;\n\t\tid &#x3D; (String) objectInput.readObject();\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>输出结果：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">null\njavastack<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>示例3的 id 被 transient 修改了，为什么还能序列化出来？那是因为 User3 实现了接口 Externalizable，而不是 Serializable。</p>\n<p>在 Java 中有两种实现序列化的方式，Serializable 和 Externalizable，可能大部分人只知道 Serializable 而不知道 Externalizable。</p>\n<p>这两种序列化方式的区别是：实现了 Serializable 接口是自动序列化的，实现 Externalizable 则需要手动序列化，通过 writeExternal 和 readExternal 方法手动进行，这也是为什么上面的 username 为 null 的原因了。</p>\n<h2 id=\"transient-关键字总结\"><a href=\"#transient-关键字总结\" class=\"headerlink\" title=\"transient 关键字总结\"></a>transient 关键字总结</h2><p>1）transient修饰的变量不能被序列化；</p>\n<p>2）transient只作用于实现 Serializable 接口；</p>\n<p>3）transient只能用来修饰普通成员变量字段；</p>\n<p>4）不管有没有 transient 修饰，静态变量都不能被序列化；</p>\n","excerpt":"","more":"<h2 id=\"先解释下什么是序列化\"><a href=\"#先解释下什么是序列化\" class=\"headerlink\" title=\"先解释下什么是序列化\"></a>先解释下什么是序列化</h2><p>我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。</p>\n<p>Java序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。</p>\n<p>更多序列化请参考：《<a href=\"https://mp.weixin.qq.com/s/wHmK1kKyne6gCkIxt0NERQ\">关于Java序列化你应该知道的一切</a>》这篇文章。</p>\n<h2 id=\"什么是-transient？\"><a href=\"#什么是-transient？\" class=\"headerlink\" title=\"什么是 transient？\"></a>什么是 transient？</h2><p>简单来说就是，被 transient 修饰的变量不能被序列化。</p>\n<p><strong>具体来看下面的示例1</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n&#x2F;**\n * @author \n *&#x2F;\npublic class TransientTest &#123;\n\n\tpublic static void main(String[] args) throws Exception &#123;\n\n\t\tUser user &#x3D; new User();\n\t\tuser.setUsername(&quot;Java技术&quot;);\n\t\tuser.setId(&quot;javastack&quot;);\n\n\t\tSystem.out.println(&quot;\\n序列化之前&quot;);\n\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());\n\t\tSystem.out.println(&quot;id: &quot; + user.getId());\n\n\t\tObjectOutputStream os &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;d:&#x2F;user.txt&quot;));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\n\t\tObjectInputStream is &#x3D; new ObjectInputStream(new FileInputStream(&quot;d:&#x2F;user.txt&quot;));\n\t\tuser &#x3D; (User) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(&quot;\\n序列化之后&quot;);\n\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());\n\t\tSystem.out.println(&quot;id: &quot; + user.getId());\n\n\t&#125;\n&#125;\n\n&#x2F;**\n * @author \n *&#x2F;\nclass User implements Serializable &#123;\n\n\tprivate static final long serialVersionUID &#x3D; 1L;\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() &#123;\n\t\treturn username;\n\t&#125;\n\n\tpublic void setUsername(String username) &#123;\n\t\tthis.username &#x3D; username;\n\t&#125;\n\n\tpublic String getId() &#123;\n\t\treturn id;\n\t&#125;\n\n\tpublic void setId(String id) &#123;\n\t\tthis.id &#x3D; id;\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>输出结果：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">序列化之前\nusername: Java技术\nid: javastack\n\n序列化之后\nusername: Java技术\nid: null<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>示例1在 id 字段上加了 transient 关键字修饰，反序列化出来之后值为 null，说明了被 transient 修饰的变量不能被序列化。</p>\n<h2 id=\"静态变量能被序列化吗？\"><a href=\"#静态变量能被序列化吗？\" class=\"headerlink\" title=\"静态变量能被序列化吗？\"></a>静态变量能被序列化吗？</h2><p>这个话题也是最近栈长的Java技术vip群里面讨论的，大家对这个知识点比较模糊，我就写了这篇文章测试总结一下。</p>\n<p><img src=\"http://img.javastack.cn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190214162351.png\"></p>\n<blockquote>\n<p>如果你也想加入我们的Java技术vip群和各位大牛一起讨论技术，那点击<a href=\"https://mp.weixin.qq.com/s/iqCLAduVzDqt19L6D4FCUQ\">这个链接</a>了解加入吧。</p>\n</blockquote>\n<p>那么，到底静态变量能被序列化吗？废话少说，先动手测试下吧！</p>\n<p>示例2：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\n&#x2F;**\n * @author \n *&#x2F;\npublic class TransientStaticTest &#123;\n\n\tpublic static void main(String[] args) throws Exception &#123;\n\n\t\tUser2 user &#x3D; new User2();\n\t\tUser2.username &#x3D; &quot;Java技术1&quot;;\n\t\tuser.setId(&quot;javastack&quot;);\n\n\t\tSystem.out.println(&quot;\\n序列化之前&quot;);\n\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());\n\t\tSystem.out.println(&quot;id: &quot; + user.getId());\n\n\t\tObjectOutputStream os &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;d:&#x2F;user.txt&quot;));\n\t\tos.writeObject(user);\n\t\tos.flush();\n\t\tos.close();\n\t\t\n\t\t&#x2F;&#x2F; 在反序列化出来之前，改变静态变量的值\n\t\tUser2.username &#x3D; &quot;Java技术2&quot;;\n\n\t\tObjectInputStream is &#x3D; new ObjectInputStream(new FileInputStream(&quot;d:&#x2F;user.txt&quot;));\n\t\tuser &#x3D; (User2) is.readObject();\n\t\tis.close();\n\n\t\tSystem.out.println(&quot;\\n序列化之后&quot;);\n\t\tSystem.out.println(&quot;username: &quot; + user.getUsername());\n\t\tSystem.out.println(&quot;id: &quot; + user.getId());\n\n\t&#125;\n&#125;\n\n&#x2F;**\n * @author \n *&#x2F;\nclass User2 implements Serializable &#123;\n\n\tprivate static final long serialVersionUID &#x3D; 1L;\n\n\tpublic static String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() &#123;\n\t\treturn username;\n\t&#125;\n\n\tpublic String getId() &#123;\n\t\treturn id;\n\t&#125;\n\n\tpublic void setId(String id) &#123;\n\t\tthis.id &#x3D; id;\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>输出结果：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">序列化之前\nusername: Java技术1\nid: javastack\n\n序列化之后\nusername: Java技术2\nid: null<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>示例2把 username 改为了 public static, 并在反序列化出来之前改变了静态变量的值，结果可以看出序列化之后的值并非序列化进去时的值。</p>\n<p>由以上结果分析可知，静态变量不能被序列化，示例2读取出来的是 username 在 JVM 内存中存储的值。</p>\n<h2 id=\"transient-真不能被序列化吗？\"><a href=\"#transient-真不能被序列化吗？\" class=\"headerlink\" title=\"transient 真不能被序列化吗？\"></a>transient 真不能被序列化吗？</h2><p>继续来看示例3：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.io.Externalizable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\n\n&#x2F;**\n * @author \n *&#x2F;\npublic class ExternalizableTest &#123;\n\n\tpublic static void main(String[] args) throws Exception &#123;\n\n\t\tUser3 user &#x3D; new User3();\n\t\tuser.setUsername(&quot;Java技术&quot;);\n\t\tuser.setId(&quot;javastack&quot;);\n\t\tObjectOutput objectOutput &#x3D; new ObjectOutputStream(new FileOutputStream(new File(&quot;javastack&quot;)));\n\t\tobjectOutput.writeObject(user);\n\n\t\tObjectInput objectInput &#x3D; new ObjectInputStream(new FileInputStream(new File(&quot;javastack&quot;)));\n\t\tuser &#x3D; (User3) objectInput.readObject();\n\n\t\tSystem.out.println(user.getUsername());\n\t\tSystem.out.println(user.getId());\n\n\t\tobjectOutput.close();\n\t\tobjectInput.close();\n\t&#125;\n\n&#125;\n\n&#x2F;**\n * @author \n *&#x2F;\nclass User3 implements Externalizable &#123;\n\n\tprivate static final long serialVersionUID &#x3D; 1L;\n\n\tpublic User3() &#123;\n\n\t&#125;\n\n\tprivate String username;\n\tprivate transient String id;\n\n\tpublic String getUsername() &#123;\n\t\treturn username;\n\t&#125;\n\n\tpublic void setUsername(String username) &#123;\n\t\tthis.username &#x3D; username;\n\t&#125;\n\n\tpublic String getId() &#123;\n\t\treturn id;\n\t&#125;\n\n\tpublic void setId(String id) &#123;\n\t\tthis.id &#x3D; id;\n\t&#125;\n\n\t@Override\n\tpublic void writeExternal(ObjectOutput objectOutput) throws IOException &#123;\n\t\tobjectOutput.writeObject(id);\n\t&#125;\n\n\t@Override\n\tpublic void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException &#123;\n\t\tid &#x3D; (String) objectInput.readObject();\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>输出结果：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">null\njavastack<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>示例3的 id 被 transient 修改了，为什么还能序列化出来？那是因为 User3 实现了接口 Externalizable，而不是 Serializable。</p>\n<p>在 Java 中有两种实现序列化的方式，Serializable 和 Externalizable，可能大部分人只知道 Serializable 而不知道 Externalizable。</p>\n<p>这两种序列化方式的区别是：实现了 Serializable 接口是自动序列化的，实现 Externalizable 则需要手动序列化，通过 writeExternal 和 readExternal 方法手动进行，这也是为什么上面的 username 为 null 的原因了。</p>\n<h2 id=\"transient-关键字总结\"><a href=\"#transient-关键字总结\" class=\"headerlink\" title=\"transient 关键字总结\"></a>transient 关键字总结</h2><p>1）transient修饰的变量不能被序列化；</p>\n<p>2）transient只作用于实现 Serializable 接口；</p>\n<p>3）transient只能用来修饰普通成员变量字段；</p>\n<p>4）不管有没有 transient 修饰，静态变量都不能被序列化；</p>\n"},{"title":"关于 Java 序列化你不知道的 5 件事","date":"2025-10-14T06:42:34.000Z","_content":"\n### 关于本系列\n\n大约一年前，一个负责管理应用程序所有用户设置的开发人员，决定将用户设置存储在一个 Hashtable中，然后将这个 Hashtable 序列化到磁盘，以便持久化。当用户更改设置时，便重新将 Hashtable 写到磁盘。\n\n这是一个优雅的、开放式的设置系统，但是，当团队决定从 Hashtable 迁移到 Java Collections 库中的HashMap 时，这个系统便面临崩溃。\n\nHashtable 和 HashMap 在磁盘上的格式是不相同、不兼容的。除非对每个持久化的用户设置运行某种类型的数据转换实用程序（极其庞大的任务），否则以后似乎只能一直用Hashtable 作为应用程序的存储格式。\n\n团队感到陷入僵局，但这只是因为他们不知道关于 Java 序列化的一个重要事实：Java 序列化允许随着时间的推移而改变类型。当我向他们展示如何自动进行序列化替换后，他们终于按计划完成了向 HashMap 的转变。\n\n本文是本系列的第一篇文章，这个系列专门揭示关于 Java 平台的一些有用的小知识 — 这些小知识不易理解，但对于解决 Java 编程挑战迟早有用。\n\n将 Java 对象序列化 API 作为开端是一个不错的选择，因为它从一开始就存在于 JDK 1.1 中。本文介绍的关于序列化的 5 件事情将说服您重新审视那些标准 Java API。\n\n### Java 序列化简介\n\nJava 对象序列化是 JDK 1.1 中引入的一组开创性特性之一，用于作为一种将 Java 对象的状态转换为字节数组，以便存储或传输的机制，以后，仍可以将字节数组转换回 Java 对象原有的状态。\n\n实际上，序列化的思想是 “冻结” 对象状态，传输对象状态（写到磁盘、通过网络传输等等），然后 “解冻” 状态，重新获得可用的 Java 对象。所有这些事情的发生有点像是魔术，这要归功于 ObjectInputStream/ObjectOutputStream 类、完全保真的元数据以及程序员愿意用Serializable 标识接口标记他们的类，从而 “参与” 这个过程。\n\n清单 1 显示一个实现 Serializable 的 Person 类。\n\n**清单 1. Serializable Person**\n\n\n```\npackage com.tedneward;\n\npublic class Person\n    implements java.io.Serializable\n{\n    public Person(String fn, String ln, int a)\n    {\n        this.firstName = fn; this.lastName = ln; this.age = a;\n    }\n\n    public String getFirstName() { return firstName; }\n    public String getLastName() { return lastName; }\n    public int getAge() { return age; }\n    public Person getSpouse() { return spouse; }\n\n    public void setFirstName(String value) { firstName = value; }\n    public void setLastName(String value) { lastName = value; }\n    public void setAge(int value) { age = value; }\n    public void setSpouse(Person value) { spouse = value; }\n\n    public String toString()\n    {\n        return \"[Person: firstName=\" + firstName + \n            \" lastName=\" + lastName +\n            \" age=\" + age +\n            \" spouse=\" + spouse.getFirstName() +\n            \"]\";\n    }    \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n\n}\n```\n\n将 Person 序列化后，很容易将对象状态写到磁盘，然后重新读出它，下面的 JUnit 4 单元测试对此做了演示。\n\n**清单 2. 对 Person 进行反序列化**\n\n\n```\npublic class SerTest\n{\n    @Test public void serializeToDisk()\n    {\n        try\n        {\n            com.tedneward.Person ted = new com.tedneward.Person(\"Ted\", \"Neward\", 39);\n            com.tedneward.Person charl = new com.tedneward.Person(\"Charlotte\",\n                \"Neward\", 38);\n\n            ted.setSpouse(charl); charl.setSpouse(ted);\n\n            FileOutputStream fos = new FileOutputStream(\"tempdata.ser\");\n            ObjectOutputStream oos = new ObjectOutputStream(fos);\n            oos.writeObject(ted);\n            oos.close();\n        }\n        catch (Exception ex)\n        {\n            fail(\"Exception thrown during test: \" + ex.toString());\n        }\n\n        try\n        {\n            FileInputStream fis = new FileInputStream(\"tempdata.ser\");\n            ObjectInputStream ois = new ObjectInputStream(fis);\n            com.tedneward.Person ted = (com.tedneward.Person) ois.readObject();\n            ois.close();\n\n            assertEquals(ted.getFirstName(）， \"Ted\");\n            assertEquals(ted.getSpouse().getFirstName(）， \"Charlotte\");\n\n            // Clean up the file\n            new File(\"tempdata.ser\").delete();\n        }\n        catch (Exception ex)\n        {\n            fail(\"Exception thrown during test: \" + ex.toString());\n        }\n    }\n}\n```\n\n到现在为止，还没有看到什么新鲜的或令人兴奋的事情，但是这是一个很好的出发点。我们将使用 Person 来发现您可能不 知道的关于 Java 对象序列化 的 5 件事。\n\n#### 1. 序列化允许重构\n\n序列化允许一定数量的类变种，甚至重构之后也是如此，ObjectInputStream 仍可以很好地将其读出来。\nJava Object Serialization 规范可以自动管理的关键任务是：\n\n- 将新字段添加到类中\n\n- 将字段从 static 改为非 static\n\n- 将字段从 transient 改为非 transient\n\n取决于所需的向后兼容程度，转换字段形式（从非 static 转换为 static 或从非 transient 转换为 transient）或者删除字段需要额外的消息传递。\n\n**重构序列化类**\n\n既然已经知道序列化允许重构，我们来看看当把新字段添加到 Person 类中时，会发生什么事情。\n\n如清单 3 所示，PersonV2 在原先 Person 类的基础上引入一个表示性别的新字段。\n\n**清单 3. 将新字段添加到序列化的 Person 中**\n\n\n```\nenum Gender\n{\n    MALE, FEMALE\n}\n\npublic class Person\n    implements java.io.Serializable\n{\n    public Person(String fn, String ln, int a, Gender g)\n    {\n        this.firstName = fn; this.lastName = ln; this.age = a; this.gender = g;\n    }\n\n    public String getFirstName() { return firstName; }\n    public String getLastName() { return lastName; }\n    public Gender getGender() { return gender; }\n    public int getAge() { return age; }\n    public Person getSpouse() { return spouse; }\n\n    public void setFirstName(String value) { firstName = value; }\n    public void setLastName(String value) { lastName = value; }\n    public void setGender(Gender value) { gender = value; }\n    public void setAge(int value) { age = value; }\n    public void setSpouse(Person value) { spouse = value; }\n\n    public String toString()\n    {\n        return \"[Person: firstName=\" + firstName + \n            \" lastName=\" + lastName +\n            \" gender=\" + gender +\n            \" age=\" + age +\n            \" spouse=\" + spouse.getFirstName() +\n            \"]\";\n    }    \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n    private Gender gender;\n}\n```\n\n序列化使用一个 hash，该 hash 是根据给定源文件中几乎所有东西 — 方法名称、字段名称、字段类型、访问修改方法等 — 计算出来的，序列化将该 hash 值与序列化流中的 hash 值相比较。\n\n为了使 Java 运行时相信两种类型实际上是一样的，第二版和随后版本的 Person 必须与第一版有相同的序列化版本 hash（存储为 private static final serialVersionUID 字段）。\n\n因此，我们需要 serialVersionUID 字段，它是通过对原始（或 V1）版本的 Person 类运行 JDK serialver命令计算出的。\n\n一旦有了 Person 的 serialVersionUID，不仅可以从原始对象 Person 的序列化数据创建 PersonV2 对象（当出现新字段时，新字段被设为缺省值，最常见的是“null”），还可以反过来做：即从 PersonV2 的数据通过反序列化得到 Person，这毫不奇怪。\n\n#### 2. 序列化并不安全\n\n让 Java 开发人员诧异并感到不快的是，序列化二进制格式完全编写在文档中，并且完全可逆。实际上，只需将二进制序列化流的内容转储到控制台，就足以看清类是什么样子，以及它包含什么内容。\n\n这对于安全性有着不良影响。例如，当通过 RMI 进行远程方法调用时，通过连接发送的对象中的任何 private 字段几乎都是以明文的方式出现在套接字流中，这显然容易招致哪怕最简单的安全问题。\n\n幸运的是，序列化允许 “hook” 序列化过程，并在序列化之前和反序列化之后保护（或模糊化）字段数据。可以通过在 Serializable 对象上提供一个 writeObject 方法来做到这一点。\n\n**模糊化序列化数据**\n\n假设 Person 类中的敏感数据是 age 字段。毕竟，女士忌谈年龄。 我们可以在序列化之前模糊化该数据，将数位循环左移一位，然后在反序列化之后复位。（您可以开发更安全的算法，当前这个算法只是作为一个例子。）\n\n为了 “hook” 序列化过程，我们将在 Person 上实现一个 writeObject 方法；为了 “hook” 反序列化过程，我们将在同一个类上实现一个readObject 方法。重要的是这两个方法的细节要正确 — 如果访问修改方法、参数或名称不同于清单 4 中的内容，那么代码将不被察觉地失败，Person 的 age 将暴露。\n\n**清单 4. 模糊化序列化数据**\n\n\n```\npublic class Person\n    implements java.io.Serializable\n{\n    public Person(String fn, String ln, int a)\n    {\n        this.firstName = fn; this.lastName = ln; this.age = a;\n    }\n\n    public String getFirstName() { return firstName; }\n    public String getLastName() { return lastName; }\n    public int getAge() { return age; }\n    public Person getSpouse() { return spouse; }\n\n    public void setFirstName(String value) { firstName = value; }\n    public void setLastName(String value) { lastName = value; }\n    public void setAge(int value) { age = value; }\n    public void setSpouse(Person value) { spouse = value; }\n\n    private void writeObject(java.io.ObjectOutputStream stream)\n        throws java.io.IOException\n    {\n        // \"Encrypt\"/obscure the sensitive data\n        age = age << 2;\n        stream.defaultWriteObject();\n    }\n\n    private void readObject(java.io.ObjectInputStream stream)\n        throws java.io.IOException, ClassNotFoundException\n    {\n        stream.defaultReadObject();\n\n        // \"Decrypt\"/de-obscure the sensitive data\n        age = age << 2;\n    }\n\n    public String toString()\n    {\n        return \"[Person: firstName=\" + firstName + \n            \" lastName=\" + lastName +\n            \" age=\" + age +\n            \" spouse=\" + (spouse!=null ? spouse.getFirstName() : \"[null]\") +\n            \"]\";\n    }      \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n}\n```\n\n如果需要查看被模糊化的数据，总是可以查看序列化数据流/文件。而且，由于该格式被完全文档化，即使不能访问类本身，也仍可以读取序列化流中的内容。\n\n#### 3. 序列化的数据可以被签名和密封\n\n上一个技巧假设您想模糊化序列化数据，而不是对其加密或者确保它不被修改。当然，通过使用 writeObject 和 readObject 可以实现密码加密和签名管理，但其实还有更好的方式。\n\n如果需要对整个对象进行加密和签名，最简单的是将它放在一个 javax.crypto.SealedObject 和/或 java.security.SignedObject 包装器中。两者都是可序列化的，所以将对象包装在 SealedObject 中可以围绕原对象创建一种“包装盒”。必须有对称密钥才能解密，而且密钥必须单独管理。同样，也可以将 SignedObject 用于数据验证，并且对称密钥也必须单独管理。\n\n结合使用这两种对象，便可以轻松地对序列化数据进行密封和签名，而不必强调关于数字签名验证或加密的细节。很简洁，是吧？\n\n#### 4. 序列化允许将代理放在流中\n\n很多情况下，类中包含一个核心数据元素，通过它可以派生或找到类中的其他字段。在此情况下，没有必要序列化整个对象。可以将字段标记为 transient，但是每当有方法访问一个字段时，类仍然必须显式地产生代码来检查它是否被初始化。\n\n如果首要问题是序列化，那么最好指定一个 flyweight 或代理放在流中。为原始 Person 提供一个 writeReplace 方法，可以序列化不同类型的对象来代替它。类似地，如果反序列化期间发现一个 readResolve 方法，那么将调用该方法，将替代对象提供给调用者。\n\n**打包和解包代理**\n\nwriteReplace 和 readResolve 方法使 Person 类可以将它的所有数据（或其中的核心数据）打包到一个 PersonProxy 中，将它放入到一个流中，然后在反序列化时再进行解包。\n\n**清单 5. 你完整了我，我代替了你**\n\n\n```\nclass PersonProxy\n    implements java.io.Serializable\n{\n    public PersonProxy(Person orig)\n    {\n        data = orig.getFirstName() + \",\" + orig.getLastName() + \",\" + orig.getAge();\n        if (orig.getSpouse() != null)\n        {\n            Person spouse = orig.getSpouse();\n            data = data + \",\" + spouse.getFirstName() + \",\" + spouse.getLastName() + \",\"  \n              + spouse.getAge();\n        }\n    }\n\n    public String data;\n    private Object readResolve()\n        throws java.io.ObjectStreamException\n    {\n        String[] pieces = data.split(\",\");\n        Person result = new Person(pieces[0], pieces[1], Integer.parseInt(pieces[2]));\n        if (pieces.length > 3)\n        {\n            result.setSpouse(new Person(pieces[3], pieces[4], Integer.parseInt\n              (pieces[5])));\n            result.getSpouse().setSpouse(result);\n        }\n        return result;\n    }\n}\n\npublic class Person\n    implements java.io.Serializable\n{\n    public Person(String fn, String ln, int a)\n    {\n        this.firstName = fn; this.lastName = ln; this.age = a;\n    }\n\n    public String getFirstName() { return firstName; }\n    public String getLastName() { return lastName; }\n    public int getAge() { return age; }\n    public Person getSpouse() { return spouse; }\n\n    private Object writeReplace()\n        throws java.io.ObjectStreamException\n    {\n        return new PersonProxy(this);\n    }\n\n    public void setFirstName(String value) { firstName = value; }\n    public void setLastName(String value) { lastName = value; }\n    public void setAge(int value) { age = value; }\n    public void setSpouse(Person value) { spouse = value; }   \n\n    public String toString()\n    {\n        return \"[Person: firstName=\" + firstName + \n            \" lastName=\" + lastName +\n            \" age=\" + age +\n            \" spouse=\" + spouse.getFirstName() +\n            \"]\";\n    }    \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n}\n```\n\n注意，PersonProxy 必须跟踪 Person 的所有数据。这通常意味着代理需要是 Person 的一个内部类，以便能访问 private 字段。有时候，代理还需要追踪其他对象引用并手动序列化它们，例如 Person 的 spouse。\n\n这种技巧是少数几种不需要读/写平衡的技巧之一。例如，一个类被重构成另一种类型后的版本可以提供一个 readResolve 方法，以便静默地将被序列化的对象转换成新类型。类似地，它可以采用 writeReplace 方法将旧类序列化成新版本。\n\n#### 5. 信任，但要验证\n\n认为序列化流中的数据总是与最初写到流中的数据一致，这没有问题。但是，正如一位美国前总统所说的，“信任，但要验证”。\n对于序列化的对象，这意味着验证字段，以确保在反序列化之后它们仍具有正确的值，“以防万一”。\n\n为此，可以实现 ObjectInputValidation接口，并覆盖 validateObject() 方法。如果调用该方法时发现某处有错误，则抛出一个 InvalidObjectException。\n\n### 结束语\n\nJava 对象序列化比大多数 Java 开发人员想象的更灵活，这使我们有更多的机会解决棘手的情况。\n\n幸运的是，像这样的编程妙招在 JVM 中随处可见。关键是要知道它们，在遇到难题的时候能用上它们。\n\n来源：www.topthink.com/topic/11361.html","source":"_posts/基础/关于 Java 序列化你不知道的 5 件事.md","raw":"---\ntitle: 关于 Java 序列化你不知道的 5 件事\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 基础\n---\n\n### 关于本系列\n\n大约一年前，一个负责管理应用程序所有用户设置的开发人员，决定将用户设置存储在一个 Hashtable中，然后将这个 Hashtable 序列化到磁盘，以便持久化。当用户更改设置时，便重新将 Hashtable 写到磁盘。\n\n这是一个优雅的、开放式的设置系统，但是，当团队决定从 Hashtable 迁移到 Java Collections 库中的HashMap 时，这个系统便面临崩溃。\n\nHashtable 和 HashMap 在磁盘上的格式是不相同、不兼容的。除非对每个持久化的用户设置运行某种类型的数据转换实用程序（极其庞大的任务），否则以后似乎只能一直用Hashtable 作为应用程序的存储格式。\n\n团队感到陷入僵局，但这只是因为他们不知道关于 Java 序列化的一个重要事实：Java 序列化允许随着时间的推移而改变类型。当我向他们展示如何自动进行序列化替换后，他们终于按计划完成了向 HashMap 的转变。\n\n本文是本系列的第一篇文章，这个系列专门揭示关于 Java 平台的一些有用的小知识 — 这些小知识不易理解，但对于解决 Java 编程挑战迟早有用。\n\n将 Java 对象序列化 API 作为开端是一个不错的选择，因为它从一开始就存在于 JDK 1.1 中。本文介绍的关于序列化的 5 件事情将说服您重新审视那些标准 Java API。\n\n### Java 序列化简介\n\nJava 对象序列化是 JDK 1.1 中引入的一组开创性特性之一，用于作为一种将 Java 对象的状态转换为字节数组，以便存储或传输的机制，以后，仍可以将字节数组转换回 Java 对象原有的状态。\n\n实际上，序列化的思想是 “冻结” 对象状态，传输对象状态（写到磁盘、通过网络传输等等），然后 “解冻” 状态，重新获得可用的 Java 对象。所有这些事情的发生有点像是魔术，这要归功于 ObjectInputStream/ObjectOutputStream 类、完全保真的元数据以及程序员愿意用Serializable 标识接口标记他们的类，从而 “参与” 这个过程。\n\n清单 1 显示一个实现 Serializable 的 Person 类。\n\n**清单 1. Serializable Person**\n\n\n```\npackage com.tedneward;\n\npublic class Person\n    implements java.io.Serializable\n{\n    public Person(String fn, String ln, int a)\n    {\n        this.firstName = fn; this.lastName = ln; this.age = a;\n    }\n\n    public String getFirstName() { return firstName; }\n    public String getLastName() { return lastName; }\n    public int getAge() { return age; }\n    public Person getSpouse() { return spouse; }\n\n    public void setFirstName(String value) { firstName = value; }\n    public void setLastName(String value) { lastName = value; }\n    public void setAge(int value) { age = value; }\n    public void setSpouse(Person value) { spouse = value; }\n\n    public String toString()\n    {\n        return \"[Person: firstName=\" + firstName + \n            \" lastName=\" + lastName +\n            \" age=\" + age +\n            \" spouse=\" + spouse.getFirstName() +\n            \"]\";\n    }    \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n\n}\n```\n\n将 Person 序列化后，很容易将对象状态写到磁盘，然后重新读出它，下面的 JUnit 4 单元测试对此做了演示。\n\n**清单 2. 对 Person 进行反序列化**\n\n\n```\npublic class SerTest\n{\n    @Test public void serializeToDisk()\n    {\n        try\n        {\n            com.tedneward.Person ted = new com.tedneward.Person(\"Ted\", \"Neward\", 39);\n            com.tedneward.Person charl = new com.tedneward.Person(\"Charlotte\",\n                \"Neward\", 38);\n\n            ted.setSpouse(charl); charl.setSpouse(ted);\n\n            FileOutputStream fos = new FileOutputStream(\"tempdata.ser\");\n            ObjectOutputStream oos = new ObjectOutputStream(fos);\n            oos.writeObject(ted);\n            oos.close();\n        }\n        catch (Exception ex)\n        {\n            fail(\"Exception thrown during test: \" + ex.toString());\n        }\n\n        try\n        {\n            FileInputStream fis = new FileInputStream(\"tempdata.ser\");\n            ObjectInputStream ois = new ObjectInputStream(fis);\n            com.tedneward.Person ted = (com.tedneward.Person) ois.readObject();\n            ois.close();\n\n            assertEquals(ted.getFirstName(）， \"Ted\");\n            assertEquals(ted.getSpouse().getFirstName(）， \"Charlotte\");\n\n            // Clean up the file\n            new File(\"tempdata.ser\").delete();\n        }\n        catch (Exception ex)\n        {\n            fail(\"Exception thrown during test: \" + ex.toString());\n        }\n    }\n}\n```\n\n到现在为止，还没有看到什么新鲜的或令人兴奋的事情，但是这是一个很好的出发点。我们将使用 Person 来发现您可能不 知道的关于 Java 对象序列化 的 5 件事。\n\n#### 1. 序列化允许重构\n\n序列化允许一定数量的类变种，甚至重构之后也是如此，ObjectInputStream 仍可以很好地将其读出来。\nJava Object Serialization 规范可以自动管理的关键任务是：\n\n- 将新字段添加到类中\n\n- 将字段从 static 改为非 static\n\n- 将字段从 transient 改为非 transient\n\n取决于所需的向后兼容程度，转换字段形式（从非 static 转换为 static 或从非 transient 转换为 transient）或者删除字段需要额外的消息传递。\n\n**重构序列化类**\n\n既然已经知道序列化允许重构，我们来看看当把新字段添加到 Person 类中时，会发生什么事情。\n\n如清单 3 所示，PersonV2 在原先 Person 类的基础上引入一个表示性别的新字段。\n\n**清单 3. 将新字段添加到序列化的 Person 中**\n\n\n```\nenum Gender\n{\n    MALE, FEMALE\n}\n\npublic class Person\n    implements java.io.Serializable\n{\n    public Person(String fn, String ln, int a, Gender g)\n    {\n        this.firstName = fn; this.lastName = ln; this.age = a; this.gender = g;\n    }\n\n    public String getFirstName() { return firstName; }\n    public String getLastName() { return lastName; }\n    public Gender getGender() { return gender; }\n    public int getAge() { return age; }\n    public Person getSpouse() { return spouse; }\n\n    public void setFirstName(String value) { firstName = value; }\n    public void setLastName(String value) { lastName = value; }\n    public void setGender(Gender value) { gender = value; }\n    public void setAge(int value) { age = value; }\n    public void setSpouse(Person value) { spouse = value; }\n\n    public String toString()\n    {\n        return \"[Person: firstName=\" + firstName + \n            \" lastName=\" + lastName +\n            \" gender=\" + gender +\n            \" age=\" + age +\n            \" spouse=\" + spouse.getFirstName() +\n            \"]\";\n    }    \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n    private Gender gender;\n}\n```\n\n序列化使用一个 hash，该 hash 是根据给定源文件中几乎所有东西 — 方法名称、字段名称、字段类型、访问修改方法等 — 计算出来的，序列化将该 hash 值与序列化流中的 hash 值相比较。\n\n为了使 Java 运行时相信两种类型实际上是一样的，第二版和随后版本的 Person 必须与第一版有相同的序列化版本 hash（存储为 private static final serialVersionUID 字段）。\n\n因此，我们需要 serialVersionUID 字段，它是通过对原始（或 V1）版本的 Person 类运行 JDK serialver命令计算出的。\n\n一旦有了 Person 的 serialVersionUID，不仅可以从原始对象 Person 的序列化数据创建 PersonV2 对象（当出现新字段时，新字段被设为缺省值，最常见的是“null”），还可以反过来做：即从 PersonV2 的数据通过反序列化得到 Person，这毫不奇怪。\n\n#### 2. 序列化并不安全\n\n让 Java 开发人员诧异并感到不快的是，序列化二进制格式完全编写在文档中，并且完全可逆。实际上，只需将二进制序列化流的内容转储到控制台，就足以看清类是什么样子，以及它包含什么内容。\n\n这对于安全性有着不良影响。例如，当通过 RMI 进行远程方法调用时，通过连接发送的对象中的任何 private 字段几乎都是以明文的方式出现在套接字流中，这显然容易招致哪怕最简单的安全问题。\n\n幸运的是，序列化允许 “hook” 序列化过程，并在序列化之前和反序列化之后保护（或模糊化）字段数据。可以通过在 Serializable 对象上提供一个 writeObject 方法来做到这一点。\n\n**模糊化序列化数据**\n\n假设 Person 类中的敏感数据是 age 字段。毕竟，女士忌谈年龄。 我们可以在序列化之前模糊化该数据，将数位循环左移一位，然后在反序列化之后复位。（您可以开发更安全的算法，当前这个算法只是作为一个例子。）\n\n为了 “hook” 序列化过程，我们将在 Person 上实现一个 writeObject 方法；为了 “hook” 反序列化过程，我们将在同一个类上实现一个readObject 方法。重要的是这两个方法的细节要正确 — 如果访问修改方法、参数或名称不同于清单 4 中的内容，那么代码将不被察觉地失败，Person 的 age 将暴露。\n\n**清单 4. 模糊化序列化数据**\n\n\n```\npublic class Person\n    implements java.io.Serializable\n{\n    public Person(String fn, String ln, int a)\n    {\n        this.firstName = fn; this.lastName = ln; this.age = a;\n    }\n\n    public String getFirstName() { return firstName; }\n    public String getLastName() { return lastName; }\n    public int getAge() { return age; }\n    public Person getSpouse() { return spouse; }\n\n    public void setFirstName(String value) { firstName = value; }\n    public void setLastName(String value) { lastName = value; }\n    public void setAge(int value) { age = value; }\n    public void setSpouse(Person value) { spouse = value; }\n\n    private void writeObject(java.io.ObjectOutputStream stream)\n        throws java.io.IOException\n    {\n        // \"Encrypt\"/obscure the sensitive data\n        age = age << 2;\n        stream.defaultWriteObject();\n    }\n\n    private void readObject(java.io.ObjectInputStream stream)\n        throws java.io.IOException, ClassNotFoundException\n    {\n        stream.defaultReadObject();\n\n        // \"Decrypt\"/de-obscure the sensitive data\n        age = age << 2;\n    }\n\n    public String toString()\n    {\n        return \"[Person: firstName=\" + firstName + \n            \" lastName=\" + lastName +\n            \" age=\" + age +\n            \" spouse=\" + (spouse!=null ? spouse.getFirstName() : \"[null]\") +\n            \"]\";\n    }      \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n}\n```\n\n如果需要查看被模糊化的数据，总是可以查看序列化数据流/文件。而且，由于该格式被完全文档化，即使不能访问类本身，也仍可以读取序列化流中的内容。\n\n#### 3. 序列化的数据可以被签名和密封\n\n上一个技巧假设您想模糊化序列化数据，而不是对其加密或者确保它不被修改。当然，通过使用 writeObject 和 readObject 可以实现密码加密和签名管理，但其实还有更好的方式。\n\n如果需要对整个对象进行加密和签名，最简单的是将它放在一个 javax.crypto.SealedObject 和/或 java.security.SignedObject 包装器中。两者都是可序列化的，所以将对象包装在 SealedObject 中可以围绕原对象创建一种“包装盒”。必须有对称密钥才能解密，而且密钥必须单独管理。同样，也可以将 SignedObject 用于数据验证，并且对称密钥也必须单独管理。\n\n结合使用这两种对象，便可以轻松地对序列化数据进行密封和签名，而不必强调关于数字签名验证或加密的细节。很简洁，是吧？\n\n#### 4. 序列化允许将代理放在流中\n\n很多情况下，类中包含一个核心数据元素，通过它可以派生或找到类中的其他字段。在此情况下，没有必要序列化整个对象。可以将字段标记为 transient，但是每当有方法访问一个字段时，类仍然必须显式地产生代码来检查它是否被初始化。\n\n如果首要问题是序列化，那么最好指定一个 flyweight 或代理放在流中。为原始 Person 提供一个 writeReplace 方法，可以序列化不同类型的对象来代替它。类似地，如果反序列化期间发现一个 readResolve 方法，那么将调用该方法，将替代对象提供给调用者。\n\n**打包和解包代理**\n\nwriteReplace 和 readResolve 方法使 Person 类可以将它的所有数据（或其中的核心数据）打包到一个 PersonProxy 中，将它放入到一个流中，然后在反序列化时再进行解包。\n\n**清单 5. 你完整了我，我代替了你**\n\n\n```\nclass PersonProxy\n    implements java.io.Serializable\n{\n    public PersonProxy(Person orig)\n    {\n        data = orig.getFirstName() + \",\" + orig.getLastName() + \",\" + orig.getAge();\n        if (orig.getSpouse() != null)\n        {\n            Person spouse = orig.getSpouse();\n            data = data + \",\" + spouse.getFirstName() + \",\" + spouse.getLastName() + \",\"  \n              + spouse.getAge();\n        }\n    }\n\n    public String data;\n    private Object readResolve()\n        throws java.io.ObjectStreamException\n    {\n        String[] pieces = data.split(\",\");\n        Person result = new Person(pieces[0], pieces[1], Integer.parseInt(pieces[2]));\n        if (pieces.length > 3)\n        {\n            result.setSpouse(new Person(pieces[3], pieces[4], Integer.parseInt\n              (pieces[5])));\n            result.getSpouse().setSpouse(result);\n        }\n        return result;\n    }\n}\n\npublic class Person\n    implements java.io.Serializable\n{\n    public Person(String fn, String ln, int a)\n    {\n        this.firstName = fn; this.lastName = ln; this.age = a;\n    }\n\n    public String getFirstName() { return firstName; }\n    public String getLastName() { return lastName; }\n    public int getAge() { return age; }\n    public Person getSpouse() { return spouse; }\n\n    private Object writeReplace()\n        throws java.io.ObjectStreamException\n    {\n        return new PersonProxy(this);\n    }\n\n    public void setFirstName(String value) { firstName = value; }\n    public void setLastName(String value) { lastName = value; }\n    public void setAge(int value) { age = value; }\n    public void setSpouse(Person value) { spouse = value; }   \n\n    public String toString()\n    {\n        return \"[Person: firstName=\" + firstName + \n            \" lastName=\" + lastName +\n            \" age=\" + age +\n            \" spouse=\" + spouse.getFirstName() +\n            \"]\";\n    }    \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n}\n```\n\n注意，PersonProxy 必须跟踪 Person 的所有数据。这通常意味着代理需要是 Person 的一个内部类，以便能访问 private 字段。有时候，代理还需要追踪其他对象引用并手动序列化它们，例如 Person 的 spouse。\n\n这种技巧是少数几种不需要读/写平衡的技巧之一。例如，一个类被重构成另一种类型后的版本可以提供一个 readResolve 方法，以便静默地将被序列化的对象转换成新类型。类似地，它可以采用 writeReplace 方法将旧类序列化成新版本。\n\n#### 5. 信任，但要验证\n\n认为序列化流中的数据总是与最初写到流中的数据一致，这没有问题。但是，正如一位美国前总统所说的，“信任，但要验证”。\n对于序列化的对象，这意味着验证字段，以确保在反序列化之后它们仍具有正确的值，“以防万一”。\n\n为此，可以实现 ObjectInputValidation接口，并覆盖 validateObject() 方法。如果调用该方法时发现某处有错误，则抛出一个 InvalidObjectException。\n\n### 结束语\n\nJava 对象序列化比大多数 Java 开发人员想象的更灵活，这使我们有更多的机会解决棘手的情况。\n\n幸运的是，像这样的编程妙招在 JVM 中随处可见。关键是要知道它们，在遇到难题的时候能用上它们。\n\n来源：www.topthink.com/topic/11361.html","slug":"基础/关于 Java 序列化你不知道的 5 件事","published":1,"updated":"2025-10-15T07:19:51.889Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076w0046qkd42f033a2v","content":"<h3 id=\"关于本系列\"><a href=\"#关于本系列\" class=\"headerlink\" title=\"关于本系列\"></a>关于本系列</h3><p>大约一年前，一个负责管理应用程序所有用户设置的开发人员，决定将用户设置存储在一个 Hashtable中，然后将这个 Hashtable 序列化到磁盘，以便持久化。当用户更改设置时，便重新将 Hashtable 写到磁盘。</p>\n<p>这是一个优雅的、开放式的设置系统，但是，当团队决定从 Hashtable 迁移到 Java Collections 库中的HashMap 时，这个系统便面临崩溃。</p>\n<p>Hashtable 和 HashMap 在磁盘上的格式是不相同、不兼容的。除非对每个持久化的用户设置运行某种类型的数据转换实用程序（极其庞大的任务），否则以后似乎只能一直用Hashtable 作为应用程序的存储格式。</p>\n<p>团队感到陷入僵局，但这只是因为他们不知道关于 Java 序列化的一个重要事实：Java 序列化允许随着时间的推移而改变类型。当我向他们展示如何自动进行序列化替换后，他们终于按计划完成了向 HashMap 的转变。</p>\n<p>本文是本系列的第一篇文章，这个系列专门揭示关于 Java 平台的一些有用的小知识 — 这些小知识不易理解，但对于解决 Java 编程挑战迟早有用。</p>\n<p>将 Java 对象序列化 API 作为开端是一个不错的选择，因为它从一开始就存在于 JDK 1.1 中。本文介绍的关于序列化的 5 件事情将说服您重新审视那些标准 Java API。</p>\n<h3 id=\"Java-序列化简介\"><a href=\"#Java-序列化简介\" class=\"headerlink\" title=\"Java 序列化简介\"></a>Java 序列化简介</h3><p>Java 对象序列化是 JDK 1.1 中引入的一组开创性特性之一，用于作为一种将 Java 对象的状态转换为字节数组，以便存储或传输的机制，以后，仍可以将字节数组转换回 Java 对象原有的状态。</p>\n<p>实际上，序列化的思想是 “冻结” 对象状态，传输对象状态（写到磁盘、通过网络传输等等），然后 “解冻” 状态，重新获得可用的 Java 对象。所有这些事情的发生有点像是魔术，这要归功于 ObjectInputStream&#x2F;ObjectOutputStream 类、完全保真的元数据以及程序员愿意用Serializable 标识接口标记他们的类，从而 “参与” 这个过程。</p>\n<p>清单 1 显示一个实现 Serializable 的 Person 类。</p>\n<p><strong>清单 1. Serializable Person</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package com.tedneward;\n\npublic class Person\n    implements java.io.Serializable\n&#123;\n    public Person(String fn, String ln, int a)\n    &#123;\n        this.firstName &#x3D; fn; this.lastName &#x3D; ln; this.age &#x3D; a;\n    &#125;\n\n    public String getFirstName() &#123; return firstName; &#125;\n    public String getLastName() &#123; return lastName; &#125;\n    public int getAge() &#123; return age; &#125;\n    public Person getSpouse() &#123; return spouse; &#125;\n\n    public void setFirstName(String value) &#123; firstName &#x3D; value; &#125;\n    public void setLastName(String value) &#123; lastName &#x3D; value; &#125;\n    public void setAge(int value) &#123; age &#x3D; value; &#125;\n    public void setSpouse(Person value) &#123; spouse &#x3D; value; &#125;\n\n    public String toString()\n    &#123;\n        return &quot;[Person: firstName&#x3D;&quot; + firstName + \n            &quot; lastName&#x3D;&quot; + lastName +\n            &quot; age&#x3D;&quot; + age +\n            &quot; spouse&#x3D;&quot; + spouse.getFirstName() +\n            &quot;]&quot;;\n    &#125;    \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>将 Person 序列化后，很容易将对象状态写到磁盘，然后重新读出它，下面的 JUnit 4 单元测试对此做了演示。</p>\n<p><strong>清单 2. 对 Person 进行反序列化</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class SerTest\n&#123;\n    @Test public void serializeToDisk()\n    &#123;\n        try\n        &#123;\n            com.tedneward.Person ted &#x3D; new com.tedneward.Person(&quot;Ted&quot;, &quot;Neward&quot;, 39);\n            com.tedneward.Person charl &#x3D; new com.tedneward.Person(&quot;Charlotte&quot;,\n                &quot;Neward&quot;, 38);\n\n            ted.setSpouse(charl); charl.setSpouse(ted);\n\n            FileOutputStream fos &#x3D; new FileOutputStream(&quot;tempdata.ser&quot;);\n            ObjectOutputStream oos &#x3D; new ObjectOutputStream(fos);\n            oos.writeObject(ted);\n            oos.close();\n        &#125;\n        catch (Exception ex)\n        &#123;\n            fail(&quot;Exception thrown during test: &quot; + ex.toString());\n        &#125;\n\n        try\n        &#123;\n            FileInputStream fis &#x3D; new FileInputStream(&quot;tempdata.ser&quot;);\n            ObjectInputStream ois &#x3D; new ObjectInputStream(fis);\n            com.tedneward.Person ted &#x3D; (com.tedneward.Person) ois.readObject();\n            ois.close();\n\n            assertEquals(ted.getFirstName(）， &quot;Ted&quot;);\n            assertEquals(ted.getSpouse().getFirstName(）， &quot;Charlotte&quot;);\n\n            &#x2F;&#x2F; Clean up the file\n            new File(&quot;tempdata.ser&quot;).delete();\n        &#125;\n        catch (Exception ex)\n        &#123;\n            fail(&quot;Exception thrown during test: &quot; + ex.toString());\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>到现在为止，还没有看到什么新鲜的或令人兴奋的事情，但是这是一个很好的出发点。我们将使用 Person 来发现您可能不 知道的关于 Java 对象序列化 的 5 件事。</p>\n<h4 id=\"1-序列化允许重构\"><a href=\"#1-序列化允许重构\" class=\"headerlink\" title=\"1. 序列化允许重构\"></a>1. 序列化允许重构</h4><p>序列化允许一定数量的类变种，甚至重构之后也是如此，ObjectInputStream 仍可以很好地将其读出来。<br>Java Object Serialization 规范可以自动管理的关键任务是：</p>\n<ul>\n<li><p>将新字段添加到类中</p>\n</li>\n<li><p>将字段从 static 改为非 static</p>\n</li>\n<li><p>将字段从 transient 改为非 transient</p>\n</li>\n</ul>\n<p>取决于所需的向后兼容程度，转换字段形式（从非 static 转换为 static 或从非 transient 转换为 transient）或者删除字段需要额外的消息传递。</p>\n<p><strong>重构序列化类</strong></p>\n<p>既然已经知道序列化允许重构，我们来看看当把新字段添加到 Person 类中时，会发生什么事情。</p>\n<p>如清单 3 所示，PersonV2 在原先 Person 类的基础上引入一个表示性别的新字段。</p>\n<p><strong>清单 3. 将新字段添加到序列化的 Person 中</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">enum Gender\n&#123;\n    MALE, FEMALE\n&#125;\n\npublic class Person\n    implements java.io.Serializable\n&#123;\n    public Person(String fn, String ln, int a, Gender g)\n    &#123;\n        this.firstName &#x3D; fn; this.lastName &#x3D; ln; this.age &#x3D; a; this.gender &#x3D; g;\n    &#125;\n\n    public String getFirstName() &#123; return firstName; &#125;\n    public String getLastName() &#123; return lastName; &#125;\n    public Gender getGender() &#123; return gender; &#125;\n    public int getAge() &#123; return age; &#125;\n    public Person getSpouse() &#123; return spouse; &#125;\n\n    public void setFirstName(String value) &#123; firstName &#x3D; value; &#125;\n    public void setLastName(String value) &#123; lastName &#x3D; value; &#125;\n    public void setGender(Gender value) &#123; gender &#x3D; value; &#125;\n    public void setAge(int value) &#123; age &#x3D; value; &#125;\n    public void setSpouse(Person value) &#123; spouse &#x3D; value; &#125;\n\n    public String toString()\n    &#123;\n        return &quot;[Person: firstName&#x3D;&quot; + firstName + \n            &quot; lastName&#x3D;&quot; + lastName +\n            &quot; gender&#x3D;&quot; + gender +\n            &quot; age&#x3D;&quot; + age +\n            &quot; spouse&#x3D;&quot; + spouse.getFirstName() +\n            &quot;]&quot;;\n    &#125;    \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n    private Gender gender;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>序列化使用一个 hash，该 hash 是根据给定源文件中几乎所有东西 — 方法名称、字段名称、字段类型、访问修改方法等 — 计算出来的，序列化将该 hash 值与序列化流中的 hash 值相比较。</p>\n<p>为了使 Java 运行时相信两种类型实际上是一样的，第二版和随后版本的 Person 必须与第一版有相同的序列化版本 hash（存储为 private static final serialVersionUID 字段）。</p>\n<p>因此，我们需要 serialVersionUID 字段，它是通过对原始（或 V1）版本的 Person 类运行 JDK serialver命令计算出的。</p>\n<p>一旦有了 Person 的 serialVersionUID，不仅可以从原始对象 Person 的序列化数据创建 PersonV2 对象（当出现新字段时，新字段被设为缺省值，最常见的是“null”），还可以反过来做：即从 PersonV2 的数据通过反序列化得到 Person，这毫不奇怪。</p>\n<h4 id=\"2-序列化并不安全\"><a href=\"#2-序列化并不安全\" class=\"headerlink\" title=\"2. 序列化并不安全\"></a>2. 序列化并不安全</h4><p>让 Java 开发人员诧异并感到不快的是，序列化二进制格式完全编写在文档中，并且完全可逆。实际上，只需将二进制序列化流的内容转储到控制台，就足以看清类是什么样子，以及它包含什么内容。</p>\n<p>这对于安全性有着不良影响。例如，当通过 RMI 进行远程方法调用时，通过连接发送的对象中的任何 private 字段几乎都是以明文的方式出现在套接字流中，这显然容易招致哪怕最简单的安全问题。</p>\n<p>幸运的是，序列化允许 “hook” 序列化过程，并在序列化之前和反序列化之后保护（或模糊化）字段数据。可以通过在 Serializable 对象上提供一个 writeObject 方法来做到这一点。</p>\n<p><strong>模糊化序列化数据</strong></p>\n<p>假设 Person 类中的敏感数据是 age 字段。毕竟，女士忌谈年龄。 我们可以在序列化之前模糊化该数据，将数位循环左移一位，然后在反序列化之后复位。（您可以开发更安全的算法，当前这个算法只是作为一个例子。）</p>\n<p>为了 “hook” 序列化过程，我们将在 Person 上实现一个 writeObject 方法；为了 “hook” 反序列化过程，我们将在同一个类上实现一个readObject 方法。重要的是这两个方法的细节要正确 — 如果访问修改方法、参数或名称不同于清单 4 中的内容，那么代码将不被察觉地失败，Person 的 age 将暴露。</p>\n<p><strong>清单 4. 模糊化序列化数据</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Person\n    implements java.io.Serializable\n&#123;\n    public Person(String fn, String ln, int a)\n    &#123;\n        this.firstName &#x3D; fn; this.lastName &#x3D; ln; this.age &#x3D; a;\n    &#125;\n\n    public String getFirstName() &#123; return firstName; &#125;\n    public String getLastName() &#123; return lastName; &#125;\n    public int getAge() &#123; return age; &#125;\n    public Person getSpouse() &#123; return spouse; &#125;\n\n    public void setFirstName(String value) &#123; firstName &#x3D; value; &#125;\n    public void setLastName(String value) &#123; lastName &#x3D; value; &#125;\n    public void setAge(int value) &#123; age &#x3D; value; &#125;\n    public void setSpouse(Person value) &#123; spouse &#x3D; value; &#125;\n\n    private void writeObject(java.io.ObjectOutputStream stream)\n        throws java.io.IOException\n    &#123;\n        &#x2F;&#x2F; &quot;Encrypt&quot;&#x2F;obscure the sensitive data\n        age &#x3D; age &lt;&lt; 2;\n        stream.defaultWriteObject();\n    &#125;\n\n    private void readObject(java.io.ObjectInputStream stream)\n        throws java.io.IOException, ClassNotFoundException\n    &#123;\n        stream.defaultReadObject();\n\n        &#x2F;&#x2F; &quot;Decrypt&quot;&#x2F;de-obscure the sensitive data\n        age &#x3D; age &lt;&lt; 2;\n    &#125;\n\n    public String toString()\n    &#123;\n        return &quot;[Person: firstName&#x3D;&quot; + firstName + \n            &quot; lastName&#x3D;&quot; + lastName +\n            &quot; age&#x3D;&quot; + age +\n            &quot; spouse&#x3D;&quot; + (spouse!&#x3D;null ? spouse.getFirstName() : &quot;[null]&quot;) +\n            &quot;]&quot;;\n    &#125;      \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果需要查看被模糊化的数据，总是可以查看序列化数据流&#x2F;文件。而且，由于该格式被完全文档化，即使不能访问类本身，也仍可以读取序列化流中的内容。</p>\n<h4 id=\"3-序列化的数据可以被签名和密封\"><a href=\"#3-序列化的数据可以被签名和密封\" class=\"headerlink\" title=\"3. 序列化的数据可以被签名和密封\"></a>3. 序列化的数据可以被签名和密封</h4><p>上一个技巧假设您想模糊化序列化数据，而不是对其加密或者确保它不被修改。当然，通过使用 writeObject 和 readObject 可以实现密码加密和签名管理，但其实还有更好的方式。</p>\n<p>如果需要对整个对象进行加密和签名，最简单的是将它放在一个 javax.crypto.SealedObject 和&#x2F;或 java.security.SignedObject 包装器中。两者都是可序列化的，所以将对象包装在 SealedObject 中可以围绕原对象创建一种“包装盒”。必须有对称密钥才能解密，而且密钥必须单独管理。同样，也可以将 SignedObject 用于数据验证，并且对称密钥也必须单独管理。</p>\n<p>结合使用这两种对象，便可以轻松地对序列化数据进行密封和签名，而不必强调关于数字签名验证或加密的细节。很简洁，是吧？</p>\n<h4 id=\"4-序列化允许将代理放在流中\"><a href=\"#4-序列化允许将代理放在流中\" class=\"headerlink\" title=\"4. 序列化允许将代理放在流中\"></a>4. 序列化允许将代理放在流中</h4><p>很多情况下，类中包含一个核心数据元素，通过它可以派生或找到类中的其他字段。在此情况下，没有必要序列化整个对象。可以将字段标记为 transient，但是每当有方法访问一个字段时，类仍然必须显式地产生代码来检查它是否被初始化。</p>\n<p>如果首要问题是序列化，那么最好指定一个 flyweight 或代理放在流中。为原始 Person 提供一个 writeReplace 方法，可以序列化不同类型的对象来代替它。类似地，如果反序列化期间发现一个 readResolve 方法，那么将调用该方法，将替代对象提供给调用者。</p>\n<p><strong>打包和解包代理</strong></p>\n<p>writeReplace 和 readResolve 方法使 Person 类可以将它的所有数据（或其中的核心数据）打包到一个 PersonProxy 中，将它放入到一个流中，然后在反序列化时再进行解包。</p>\n<p><strong>清单 5. 你完整了我，我代替了你</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class PersonProxy\n    implements java.io.Serializable\n&#123;\n    public PersonProxy(Person orig)\n    &#123;\n        data &#x3D; orig.getFirstName() + &quot;,&quot; + orig.getLastName() + &quot;,&quot; + orig.getAge();\n        if (orig.getSpouse() !&#x3D; null)\n        &#123;\n            Person spouse &#x3D; orig.getSpouse();\n            data &#x3D; data + &quot;,&quot; + spouse.getFirstName() + &quot;,&quot; + spouse.getLastName() + &quot;,&quot;  \n              + spouse.getAge();\n        &#125;\n    &#125;\n\n    public String data;\n    private Object readResolve()\n        throws java.io.ObjectStreamException\n    &#123;\n        String[] pieces &#x3D; data.split(&quot;,&quot;);\n        Person result &#x3D; new Person(pieces[0], pieces[1], Integer.parseInt(pieces[2]));\n        if (pieces.length &gt; 3)\n        &#123;\n            result.setSpouse(new Person(pieces[3], pieces[4], Integer.parseInt\n              (pieces[5])));\n            result.getSpouse().setSpouse(result);\n        &#125;\n        return result;\n    &#125;\n&#125;\n\npublic class Person\n    implements java.io.Serializable\n&#123;\n    public Person(String fn, String ln, int a)\n    &#123;\n        this.firstName &#x3D; fn; this.lastName &#x3D; ln; this.age &#x3D; a;\n    &#125;\n\n    public String getFirstName() &#123; return firstName; &#125;\n    public String getLastName() &#123; return lastName; &#125;\n    public int getAge() &#123; return age; &#125;\n    public Person getSpouse() &#123; return spouse; &#125;\n\n    private Object writeReplace()\n        throws java.io.ObjectStreamException\n    &#123;\n        return new PersonProxy(this);\n    &#125;\n\n    public void setFirstName(String value) &#123; firstName &#x3D; value; &#125;\n    public void setLastName(String value) &#123; lastName &#x3D; value; &#125;\n    public void setAge(int value) &#123; age &#x3D; value; &#125;\n    public void setSpouse(Person value) &#123; spouse &#x3D; value; &#125;   \n\n    public String toString()\n    &#123;\n        return &quot;[Person: firstName&#x3D;&quot; + firstName + \n            &quot; lastName&#x3D;&quot; + lastName +\n            &quot; age&#x3D;&quot; + age +\n            &quot; spouse&#x3D;&quot; + spouse.getFirstName() +\n            &quot;]&quot;;\n    &#125;    \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>注意，PersonProxy 必须跟踪 Person 的所有数据。这通常意味着代理需要是 Person 的一个内部类，以便能访问 private 字段。有时候，代理还需要追踪其他对象引用并手动序列化它们，例如 Person 的 spouse。</p>\n<p>这种技巧是少数几种不需要读&#x2F;写平衡的技巧之一。例如，一个类被重构成另一种类型后的版本可以提供一个 readResolve 方法，以便静默地将被序列化的对象转换成新类型。类似地，它可以采用 writeReplace 方法将旧类序列化成新版本。</p>\n<h4 id=\"5-信任，但要验证\"><a href=\"#5-信任，但要验证\" class=\"headerlink\" title=\"5. 信任，但要验证\"></a>5. 信任，但要验证</h4><p>认为序列化流中的数据总是与最初写到流中的数据一致，这没有问题。但是，正如一位美国前总统所说的，“信任，但要验证”。<br>对于序列化的对象，这意味着验证字段，以确保在反序列化之后它们仍具有正确的值，“以防万一”。</p>\n<p>为此，可以实现 ObjectInputValidation接口，并覆盖 validateObject() 方法。如果调用该方法时发现某处有错误，则抛出一个 InvalidObjectException。</p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>Java 对象序列化比大多数 Java 开发人员想象的更灵活，这使我们有更多的机会解决棘手的情况。</p>\n<p>幸运的是，像这样的编程妙招在 JVM 中随处可见。关键是要知道它们，在遇到难题的时候能用上它们。</p>\n<p>来源：<a href=\"http://www.topthink.com/topic/11361.html\">www.topthink.com/topic/11361.html</a></p>\n","excerpt":"","more":"<h3 id=\"关于本系列\"><a href=\"#关于本系列\" class=\"headerlink\" title=\"关于本系列\"></a>关于本系列</h3><p>大约一年前，一个负责管理应用程序所有用户设置的开发人员，决定将用户设置存储在一个 Hashtable中，然后将这个 Hashtable 序列化到磁盘，以便持久化。当用户更改设置时，便重新将 Hashtable 写到磁盘。</p>\n<p>这是一个优雅的、开放式的设置系统，但是，当团队决定从 Hashtable 迁移到 Java Collections 库中的HashMap 时，这个系统便面临崩溃。</p>\n<p>Hashtable 和 HashMap 在磁盘上的格式是不相同、不兼容的。除非对每个持久化的用户设置运行某种类型的数据转换实用程序（极其庞大的任务），否则以后似乎只能一直用Hashtable 作为应用程序的存储格式。</p>\n<p>团队感到陷入僵局，但这只是因为他们不知道关于 Java 序列化的一个重要事实：Java 序列化允许随着时间的推移而改变类型。当我向他们展示如何自动进行序列化替换后，他们终于按计划完成了向 HashMap 的转变。</p>\n<p>本文是本系列的第一篇文章，这个系列专门揭示关于 Java 平台的一些有用的小知识 — 这些小知识不易理解，但对于解决 Java 编程挑战迟早有用。</p>\n<p>将 Java 对象序列化 API 作为开端是一个不错的选择，因为它从一开始就存在于 JDK 1.1 中。本文介绍的关于序列化的 5 件事情将说服您重新审视那些标准 Java API。</p>\n<h3 id=\"Java-序列化简介\"><a href=\"#Java-序列化简介\" class=\"headerlink\" title=\"Java 序列化简介\"></a>Java 序列化简介</h3><p>Java 对象序列化是 JDK 1.1 中引入的一组开创性特性之一，用于作为一种将 Java 对象的状态转换为字节数组，以便存储或传输的机制，以后，仍可以将字节数组转换回 Java 对象原有的状态。</p>\n<p>实际上，序列化的思想是 “冻结” 对象状态，传输对象状态（写到磁盘、通过网络传输等等），然后 “解冻” 状态，重新获得可用的 Java 对象。所有这些事情的发生有点像是魔术，这要归功于 ObjectInputStream&#x2F;ObjectOutputStream 类、完全保真的元数据以及程序员愿意用Serializable 标识接口标记他们的类，从而 “参与” 这个过程。</p>\n<p>清单 1 显示一个实现 Serializable 的 Person 类。</p>\n<p><strong>清单 1. Serializable Person</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package com.tedneward;\n\npublic class Person\n    implements java.io.Serializable\n&#123;\n    public Person(String fn, String ln, int a)\n    &#123;\n        this.firstName &#x3D; fn; this.lastName &#x3D; ln; this.age &#x3D; a;\n    &#125;\n\n    public String getFirstName() &#123; return firstName; &#125;\n    public String getLastName() &#123; return lastName; &#125;\n    public int getAge() &#123; return age; &#125;\n    public Person getSpouse() &#123; return spouse; &#125;\n\n    public void setFirstName(String value) &#123; firstName &#x3D; value; &#125;\n    public void setLastName(String value) &#123; lastName &#x3D; value; &#125;\n    public void setAge(int value) &#123; age &#x3D; value; &#125;\n    public void setSpouse(Person value) &#123; spouse &#x3D; value; &#125;\n\n    public String toString()\n    &#123;\n        return &quot;[Person: firstName&#x3D;&quot; + firstName + \n            &quot; lastName&#x3D;&quot; + lastName +\n            &quot; age&#x3D;&quot; + age +\n            &quot; spouse&#x3D;&quot; + spouse.getFirstName() +\n            &quot;]&quot;;\n    &#125;    \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>将 Person 序列化后，很容易将对象状态写到磁盘，然后重新读出它，下面的 JUnit 4 单元测试对此做了演示。</p>\n<p><strong>清单 2. 对 Person 进行反序列化</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class SerTest\n&#123;\n    @Test public void serializeToDisk()\n    &#123;\n        try\n        &#123;\n            com.tedneward.Person ted &#x3D; new com.tedneward.Person(&quot;Ted&quot;, &quot;Neward&quot;, 39);\n            com.tedneward.Person charl &#x3D; new com.tedneward.Person(&quot;Charlotte&quot;,\n                &quot;Neward&quot;, 38);\n\n            ted.setSpouse(charl); charl.setSpouse(ted);\n\n            FileOutputStream fos &#x3D; new FileOutputStream(&quot;tempdata.ser&quot;);\n            ObjectOutputStream oos &#x3D; new ObjectOutputStream(fos);\n            oos.writeObject(ted);\n            oos.close();\n        &#125;\n        catch (Exception ex)\n        &#123;\n            fail(&quot;Exception thrown during test: &quot; + ex.toString());\n        &#125;\n\n        try\n        &#123;\n            FileInputStream fis &#x3D; new FileInputStream(&quot;tempdata.ser&quot;);\n            ObjectInputStream ois &#x3D; new ObjectInputStream(fis);\n            com.tedneward.Person ted &#x3D; (com.tedneward.Person) ois.readObject();\n            ois.close();\n\n            assertEquals(ted.getFirstName(）， &quot;Ted&quot;);\n            assertEquals(ted.getSpouse().getFirstName(）， &quot;Charlotte&quot;);\n\n            &#x2F;&#x2F; Clean up the file\n            new File(&quot;tempdata.ser&quot;).delete();\n        &#125;\n        catch (Exception ex)\n        &#123;\n            fail(&quot;Exception thrown during test: &quot; + ex.toString());\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>到现在为止，还没有看到什么新鲜的或令人兴奋的事情，但是这是一个很好的出发点。我们将使用 Person 来发现您可能不 知道的关于 Java 对象序列化 的 5 件事。</p>\n<h4 id=\"1-序列化允许重构\"><a href=\"#1-序列化允许重构\" class=\"headerlink\" title=\"1. 序列化允许重构\"></a>1. 序列化允许重构</h4><p>序列化允许一定数量的类变种，甚至重构之后也是如此，ObjectInputStream 仍可以很好地将其读出来。<br>Java Object Serialization 规范可以自动管理的关键任务是：</p>\n<ul>\n<li><p>将新字段添加到类中</p>\n</li>\n<li><p>将字段从 static 改为非 static</p>\n</li>\n<li><p>将字段从 transient 改为非 transient</p>\n</li>\n</ul>\n<p>取决于所需的向后兼容程度，转换字段形式（从非 static 转换为 static 或从非 transient 转换为 transient）或者删除字段需要额外的消息传递。</p>\n<p><strong>重构序列化类</strong></p>\n<p>既然已经知道序列化允许重构，我们来看看当把新字段添加到 Person 类中时，会发生什么事情。</p>\n<p>如清单 3 所示，PersonV2 在原先 Person 类的基础上引入一个表示性别的新字段。</p>\n<p><strong>清单 3. 将新字段添加到序列化的 Person 中</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">enum Gender\n&#123;\n    MALE, FEMALE\n&#125;\n\npublic class Person\n    implements java.io.Serializable\n&#123;\n    public Person(String fn, String ln, int a, Gender g)\n    &#123;\n        this.firstName &#x3D; fn; this.lastName &#x3D; ln; this.age &#x3D; a; this.gender &#x3D; g;\n    &#125;\n\n    public String getFirstName() &#123; return firstName; &#125;\n    public String getLastName() &#123; return lastName; &#125;\n    public Gender getGender() &#123; return gender; &#125;\n    public int getAge() &#123; return age; &#125;\n    public Person getSpouse() &#123; return spouse; &#125;\n\n    public void setFirstName(String value) &#123; firstName &#x3D; value; &#125;\n    public void setLastName(String value) &#123; lastName &#x3D; value; &#125;\n    public void setGender(Gender value) &#123; gender &#x3D; value; &#125;\n    public void setAge(int value) &#123; age &#x3D; value; &#125;\n    public void setSpouse(Person value) &#123; spouse &#x3D; value; &#125;\n\n    public String toString()\n    &#123;\n        return &quot;[Person: firstName&#x3D;&quot; + firstName + \n            &quot; lastName&#x3D;&quot; + lastName +\n            &quot; gender&#x3D;&quot; + gender +\n            &quot; age&#x3D;&quot; + age +\n            &quot; spouse&#x3D;&quot; + spouse.getFirstName() +\n            &quot;]&quot;;\n    &#125;    \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n    private Gender gender;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>序列化使用一个 hash，该 hash 是根据给定源文件中几乎所有东西 — 方法名称、字段名称、字段类型、访问修改方法等 — 计算出来的，序列化将该 hash 值与序列化流中的 hash 值相比较。</p>\n<p>为了使 Java 运行时相信两种类型实际上是一样的，第二版和随后版本的 Person 必须与第一版有相同的序列化版本 hash（存储为 private static final serialVersionUID 字段）。</p>\n<p>因此，我们需要 serialVersionUID 字段，它是通过对原始（或 V1）版本的 Person 类运行 JDK serialver命令计算出的。</p>\n<p>一旦有了 Person 的 serialVersionUID，不仅可以从原始对象 Person 的序列化数据创建 PersonV2 对象（当出现新字段时，新字段被设为缺省值，最常见的是“null”），还可以反过来做：即从 PersonV2 的数据通过反序列化得到 Person，这毫不奇怪。</p>\n<h4 id=\"2-序列化并不安全\"><a href=\"#2-序列化并不安全\" class=\"headerlink\" title=\"2. 序列化并不安全\"></a>2. 序列化并不安全</h4><p>让 Java 开发人员诧异并感到不快的是，序列化二进制格式完全编写在文档中，并且完全可逆。实际上，只需将二进制序列化流的内容转储到控制台，就足以看清类是什么样子，以及它包含什么内容。</p>\n<p>这对于安全性有着不良影响。例如，当通过 RMI 进行远程方法调用时，通过连接发送的对象中的任何 private 字段几乎都是以明文的方式出现在套接字流中，这显然容易招致哪怕最简单的安全问题。</p>\n<p>幸运的是，序列化允许 “hook” 序列化过程，并在序列化之前和反序列化之后保护（或模糊化）字段数据。可以通过在 Serializable 对象上提供一个 writeObject 方法来做到这一点。</p>\n<p><strong>模糊化序列化数据</strong></p>\n<p>假设 Person 类中的敏感数据是 age 字段。毕竟，女士忌谈年龄。 我们可以在序列化之前模糊化该数据，将数位循环左移一位，然后在反序列化之后复位。（您可以开发更安全的算法，当前这个算法只是作为一个例子。）</p>\n<p>为了 “hook” 序列化过程，我们将在 Person 上实现一个 writeObject 方法；为了 “hook” 反序列化过程，我们将在同一个类上实现一个readObject 方法。重要的是这两个方法的细节要正确 — 如果访问修改方法、参数或名称不同于清单 4 中的内容，那么代码将不被察觉地失败，Person 的 age 将暴露。</p>\n<p><strong>清单 4. 模糊化序列化数据</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Person\n    implements java.io.Serializable\n&#123;\n    public Person(String fn, String ln, int a)\n    &#123;\n        this.firstName &#x3D; fn; this.lastName &#x3D; ln; this.age &#x3D; a;\n    &#125;\n\n    public String getFirstName() &#123; return firstName; &#125;\n    public String getLastName() &#123; return lastName; &#125;\n    public int getAge() &#123; return age; &#125;\n    public Person getSpouse() &#123; return spouse; &#125;\n\n    public void setFirstName(String value) &#123; firstName &#x3D; value; &#125;\n    public void setLastName(String value) &#123; lastName &#x3D; value; &#125;\n    public void setAge(int value) &#123; age &#x3D; value; &#125;\n    public void setSpouse(Person value) &#123; spouse &#x3D; value; &#125;\n\n    private void writeObject(java.io.ObjectOutputStream stream)\n        throws java.io.IOException\n    &#123;\n        &#x2F;&#x2F; &quot;Encrypt&quot;&#x2F;obscure the sensitive data\n        age &#x3D; age &lt;&lt; 2;\n        stream.defaultWriteObject();\n    &#125;\n\n    private void readObject(java.io.ObjectInputStream stream)\n        throws java.io.IOException, ClassNotFoundException\n    &#123;\n        stream.defaultReadObject();\n\n        &#x2F;&#x2F; &quot;Decrypt&quot;&#x2F;de-obscure the sensitive data\n        age &#x3D; age &lt;&lt; 2;\n    &#125;\n\n    public String toString()\n    &#123;\n        return &quot;[Person: firstName&#x3D;&quot; + firstName + \n            &quot; lastName&#x3D;&quot; + lastName +\n            &quot; age&#x3D;&quot; + age +\n            &quot; spouse&#x3D;&quot; + (spouse!&#x3D;null ? spouse.getFirstName() : &quot;[null]&quot;) +\n            &quot;]&quot;;\n    &#125;      \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果需要查看被模糊化的数据，总是可以查看序列化数据流&#x2F;文件。而且，由于该格式被完全文档化，即使不能访问类本身，也仍可以读取序列化流中的内容。</p>\n<h4 id=\"3-序列化的数据可以被签名和密封\"><a href=\"#3-序列化的数据可以被签名和密封\" class=\"headerlink\" title=\"3. 序列化的数据可以被签名和密封\"></a>3. 序列化的数据可以被签名和密封</h4><p>上一个技巧假设您想模糊化序列化数据，而不是对其加密或者确保它不被修改。当然，通过使用 writeObject 和 readObject 可以实现密码加密和签名管理，但其实还有更好的方式。</p>\n<p>如果需要对整个对象进行加密和签名，最简单的是将它放在一个 javax.crypto.SealedObject 和&#x2F;或 java.security.SignedObject 包装器中。两者都是可序列化的，所以将对象包装在 SealedObject 中可以围绕原对象创建一种“包装盒”。必须有对称密钥才能解密，而且密钥必须单独管理。同样，也可以将 SignedObject 用于数据验证，并且对称密钥也必须单独管理。</p>\n<p>结合使用这两种对象，便可以轻松地对序列化数据进行密封和签名，而不必强调关于数字签名验证或加密的细节。很简洁，是吧？</p>\n<h4 id=\"4-序列化允许将代理放在流中\"><a href=\"#4-序列化允许将代理放在流中\" class=\"headerlink\" title=\"4. 序列化允许将代理放在流中\"></a>4. 序列化允许将代理放在流中</h4><p>很多情况下，类中包含一个核心数据元素，通过它可以派生或找到类中的其他字段。在此情况下，没有必要序列化整个对象。可以将字段标记为 transient，但是每当有方法访问一个字段时，类仍然必须显式地产生代码来检查它是否被初始化。</p>\n<p>如果首要问题是序列化，那么最好指定一个 flyweight 或代理放在流中。为原始 Person 提供一个 writeReplace 方法，可以序列化不同类型的对象来代替它。类似地，如果反序列化期间发现一个 readResolve 方法，那么将调用该方法，将替代对象提供给调用者。</p>\n<p><strong>打包和解包代理</strong></p>\n<p>writeReplace 和 readResolve 方法使 Person 类可以将它的所有数据（或其中的核心数据）打包到一个 PersonProxy 中，将它放入到一个流中，然后在反序列化时再进行解包。</p>\n<p><strong>清单 5. 你完整了我，我代替了你</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class PersonProxy\n    implements java.io.Serializable\n&#123;\n    public PersonProxy(Person orig)\n    &#123;\n        data &#x3D; orig.getFirstName() + &quot;,&quot; + orig.getLastName() + &quot;,&quot; + orig.getAge();\n        if (orig.getSpouse() !&#x3D; null)\n        &#123;\n            Person spouse &#x3D; orig.getSpouse();\n            data &#x3D; data + &quot;,&quot; + spouse.getFirstName() + &quot;,&quot; + spouse.getLastName() + &quot;,&quot;  \n              + spouse.getAge();\n        &#125;\n    &#125;\n\n    public String data;\n    private Object readResolve()\n        throws java.io.ObjectStreamException\n    &#123;\n        String[] pieces &#x3D; data.split(&quot;,&quot;);\n        Person result &#x3D; new Person(pieces[0], pieces[1], Integer.parseInt(pieces[2]));\n        if (pieces.length &gt; 3)\n        &#123;\n            result.setSpouse(new Person(pieces[3], pieces[4], Integer.parseInt\n              (pieces[5])));\n            result.getSpouse().setSpouse(result);\n        &#125;\n        return result;\n    &#125;\n&#125;\n\npublic class Person\n    implements java.io.Serializable\n&#123;\n    public Person(String fn, String ln, int a)\n    &#123;\n        this.firstName &#x3D; fn; this.lastName &#x3D; ln; this.age &#x3D; a;\n    &#125;\n\n    public String getFirstName() &#123; return firstName; &#125;\n    public String getLastName() &#123; return lastName; &#125;\n    public int getAge() &#123; return age; &#125;\n    public Person getSpouse() &#123; return spouse; &#125;\n\n    private Object writeReplace()\n        throws java.io.ObjectStreamException\n    &#123;\n        return new PersonProxy(this);\n    &#125;\n\n    public void setFirstName(String value) &#123; firstName &#x3D; value; &#125;\n    public void setLastName(String value) &#123; lastName &#x3D; value; &#125;\n    public void setAge(int value) &#123; age &#x3D; value; &#125;\n    public void setSpouse(Person value) &#123; spouse &#x3D; value; &#125;   \n\n    public String toString()\n    &#123;\n        return &quot;[Person: firstName&#x3D;&quot; + firstName + \n            &quot; lastName&#x3D;&quot; + lastName +\n            &quot; age&#x3D;&quot; + age +\n            &quot; spouse&#x3D;&quot; + spouse.getFirstName() +\n            &quot;]&quot;;\n    &#125;    \n\n    private String firstName;\n    private String lastName;\n    private int age;\n    private Person spouse;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>注意，PersonProxy 必须跟踪 Person 的所有数据。这通常意味着代理需要是 Person 的一个内部类，以便能访问 private 字段。有时候，代理还需要追踪其他对象引用并手动序列化它们，例如 Person 的 spouse。</p>\n<p>这种技巧是少数几种不需要读&#x2F;写平衡的技巧之一。例如，一个类被重构成另一种类型后的版本可以提供一个 readResolve 方法，以便静默地将被序列化的对象转换成新类型。类似地，它可以采用 writeReplace 方法将旧类序列化成新版本。</p>\n<h4 id=\"5-信任，但要验证\"><a href=\"#5-信任，但要验证\" class=\"headerlink\" title=\"5. 信任，但要验证\"></a>5. 信任，但要验证</h4><p>认为序列化流中的数据总是与最初写到流中的数据一致，这没有问题。但是，正如一位美国前总统所说的，“信任，但要验证”。<br>对于序列化的对象，这意味着验证字段，以确保在反序列化之后它们仍具有正确的值，“以防万一”。</p>\n<p>为此，可以实现 ObjectInputValidation接口，并覆盖 validateObject() 方法。如果调用该方法时发现某处有错误，则抛出一个 InvalidObjectException。</p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>Java 对象序列化比大多数 Java 开发人员想象的更灵活，这使我们有更多的机会解决棘手的情况。</p>\n<p>幸运的是，像这样的编程妙招在 JVM 中随处可见。关键是要知道它们，在遇到难题的时候能用上它们。</p>\n<p>来源：<a href=\"http://www.topthink.com/topic/11361.html\">www.topthink.com/topic/11361.html</a></p>\n"},{"title":"关于Java序列化你应该知道的一切","date":"2025-10-14T06:42:34.000Z","_content":"\n## 什么是序列化\n\n我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。\n\nJava序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。\n\n## 怎么序列化一个对象？\n\n要序列化一个对象，这个对象所在类就必须实现Java序列化的接口：java.io.Serializable。\n\n##### 1、类添加序列化接口\n```\nimport java.io.Serializable;\n\npublic class User implements Serializable{\n\n    private static final long serialVersionUID = -8475669200846811112L;\n\n    private String username;\n    private String address;\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"username='\" + username + '\\'' +\n                \", address='\" + address + '\\'' +\n                '}';\n    }\n    \n}\n```\n\n##### 2、序列化/反序列化\n\n可以借助commons-lang3工具包里面的类实现对象的序列化及反序列化，你没有必要自己写。\n\n```\nimport org.apache.commons.lang3.SerializationUtils;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        User user = new User();\n        user.setUsername(\"Java\");\n        user.setAddress(\"China\");\n        byte[] bytes = SerializationUtils.serialize(user);\n\n        User u = SerializationUtils.deserialize(bytes);\n        System.out.println(u);\n\n    }\n\n}\n```\n输出：\n```\nUser{username='Java', address='China'}\n```\n上例通过序列化对象字节到内存然后反序列化，当然里面也提供了序列化磁盘然后再反序列化的方法，原理都是一样的，只是目标地不一样。\n\n## 序列化注意事项\n\n- 序列化对象必须实现序列化接口。\n\n- 序列化对象里面的属性是对象的话也要实现序列化接口。\n\n- 类的对象序列化后，类的序列化ID不能轻易修改，不然反序列化会失败。\n\n- 类的对象序列化后，类的属性有增加或者删除不会影响序列化，只是值会丢失。\n\n- 如果父类序列化了，子类会继承父类的序列化，子类无需添加序列化接口。\n\n- 如果父类没有序列化，子类序列化了，子类中的属性能正常序列化，但父类的属性会丢失，不能序列化。\n\n- 用Java序列化的二进制字节数据只能由Java反序列化，不能被其他语言反序列化。如果要进行前后端或者不同语言之间的交互一般需要将对象转变成Json/Xml通用格式的数据，再恢复原来的对象。\n\n","source":"_posts/基础/关于Java序列化你应该知道的一切.md","raw":"---\ntitle: 关于Java序列化你应该知道的一切\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 基础\n---\n\n## 什么是序列化\n\n我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。\n\nJava序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。\n\n## 怎么序列化一个对象？\n\n要序列化一个对象，这个对象所在类就必须实现Java序列化的接口：java.io.Serializable。\n\n##### 1、类添加序列化接口\n```\nimport java.io.Serializable;\n\npublic class User implements Serializable{\n\n    private static final long serialVersionUID = -8475669200846811112L;\n\n    private String username;\n    private String address;\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"username='\" + username + '\\'' +\n                \", address='\" + address + '\\'' +\n                '}';\n    }\n    \n}\n```\n\n##### 2、序列化/反序列化\n\n可以借助commons-lang3工具包里面的类实现对象的序列化及反序列化，你没有必要自己写。\n\n```\nimport org.apache.commons.lang3.SerializationUtils;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        User user = new User();\n        user.setUsername(\"Java\");\n        user.setAddress(\"China\");\n        byte[] bytes = SerializationUtils.serialize(user);\n\n        User u = SerializationUtils.deserialize(bytes);\n        System.out.println(u);\n\n    }\n\n}\n```\n输出：\n```\nUser{username='Java', address='China'}\n```\n上例通过序列化对象字节到内存然后反序列化，当然里面也提供了序列化磁盘然后再反序列化的方法，原理都是一样的，只是目标地不一样。\n\n## 序列化注意事项\n\n- 序列化对象必须实现序列化接口。\n\n- 序列化对象里面的属性是对象的话也要实现序列化接口。\n\n- 类的对象序列化后，类的序列化ID不能轻易修改，不然反序列化会失败。\n\n- 类的对象序列化后，类的属性有增加或者删除不会影响序列化，只是值会丢失。\n\n- 如果父类序列化了，子类会继承父类的序列化，子类无需添加序列化接口。\n\n- 如果父类没有序列化，子类序列化了，子类中的属性能正常序列化，但父类的属性会丢失，不能序列化。\n\n- 用Java序列化的二进制字节数据只能由Java反序列化，不能被其他语言反序列化。如果要进行前后端或者不同语言之间的交互一般需要将对象转变成Json/Xml通用格式的数据，再恢复原来的对象。\n\n","slug":"基础/关于Java序列化你应该知道的一切","published":1,"updated":"2025-10-15T07:19:51.784Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076x0049qkd4954efqqm","content":"<h2 id=\"什么是序列化\"><a href=\"#什么是序列化\" class=\"headerlink\" title=\"什么是序列化\"></a>什么是序列化</h2><p>我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。</p>\n<p>Java序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。</p>\n<h2 id=\"怎么序列化一个对象？\"><a href=\"#怎么序列化一个对象？\" class=\"headerlink\" title=\"怎么序列化一个对象？\"></a>怎么序列化一个对象？</h2><p>要序列化一个对象，这个对象所在类就必须实现Java序列化的接口：java.io.Serializable。</p>\n<h5 id=\"1、类添加序列化接口\"><a href=\"#1、类添加序列化接口\" class=\"headerlink\" title=\"1、类添加序列化接口\"></a>1、类添加序列化接口</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.io.Serializable;\n\npublic class User implements Serializable&#123;\n\n    private static final long serialVersionUID &#x3D; -8475669200846811112L;\n\n    private String username;\n    private String address;\n\n    public String getUsername() &#123;\n        return username;\n    &#125;\n\n    public void setUsername(String username) &#123;\n        this.username &#x3D; username;\n    &#125;\n\n    public String getAddress() &#123;\n        return address;\n    &#125;\n\n    public void setAddress(String address) &#123;\n        this.address &#x3D; address;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;username&#x3D;&#39;&quot; + username + &#39;\\&#39;&#39; +\n                &quot;, address&#x3D;&#39;&quot; + address + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h5 id=\"2、序列化-反序列化\"><a href=\"#2、序列化-反序列化\" class=\"headerlink\" title=\"2、序列化&#x2F;反序列化\"></a>2、序列化&#x2F;反序列化</h5><p>可以借助commons-lang3工具包里面的类实现对象的序列化及反序列化，你没有必要自己写。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import org.apache.commons.lang3.SerializationUtils;\n\npublic class Test &#123;\n\n    public static void main(String[] args) &#123;\n        User user &#x3D; new User();\n        user.setUsername(&quot;Java&quot;);\n        user.setAddress(&quot;China&quot;);\n        byte[] bytes &#x3D; SerializationUtils.serialize(user);\n\n        User u &#x3D; SerializationUtils.deserialize(bytes);\n        System.out.println(u);\n\n    &#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">User&#123;username&#x3D;&#39;Java&#39;, address&#x3D;&#39;China&#39;&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>上例通过序列化对象字节到内存然后反序列化，当然里面也提供了序列化磁盘然后再反序列化的方法，原理都是一样的，只是目标地不一样。</p>\n<h2 id=\"序列化注意事项\"><a href=\"#序列化注意事项\" class=\"headerlink\" title=\"序列化注意事项\"></a>序列化注意事项</h2><ul>\n<li><p>序列化对象必须实现序列化接口。</p>\n</li>\n<li><p>序列化对象里面的属性是对象的话也要实现序列化接口。</p>\n</li>\n<li><p>类的对象序列化后，类的序列化ID不能轻易修改，不然反序列化会失败。</p>\n</li>\n<li><p>类的对象序列化后，类的属性有增加或者删除不会影响序列化，只是值会丢失。</p>\n</li>\n<li><p>如果父类序列化了，子类会继承父类的序列化，子类无需添加序列化接口。</p>\n</li>\n<li><p>如果父类没有序列化，子类序列化了，子类中的属性能正常序列化，但父类的属性会丢失，不能序列化。</p>\n</li>\n<li><p>用Java序列化的二进制字节数据只能由Java反序列化，不能被其他语言反序列化。如果要进行前后端或者不同语言之间的交互一般需要将对象转变成Json&#x2F;Xml通用格式的数据，再恢复原来的对象。</p>\n</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"什么是序列化\"><a href=\"#什么是序列化\" class=\"headerlink\" title=\"什么是序列化\"></a>什么是序列化</h2><p>我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。</p>\n<p>Java序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。</p>\n<h2 id=\"怎么序列化一个对象？\"><a href=\"#怎么序列化一个对象？\" class=\"headerlink\" title=\"怎么序列化一个对象？\"></a>怎么序列化一个对象？</h2><p>要序列化一个对象，这个对象所在类就必须实现Java序列化的接口：java.io.Serializable。</p>\n<h5 id=\"1、类添加序列化接口\"><a href=\"#1、类添加序列化接口\" class=\"headerlink\" title=\"1、类添加序列化接口\"></a>1、类添加序列化接口</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.io.Serializable;\n\npublic class User implements Serializable&#123;\n\n    private static final long serialVersionUID &#x3D; -8475669200846811112L;\n\n    private String username;\n    private String address;\n\n    public String getUsername() &#123;\n        return username;\n    &#125;\n\n    public void setUsername(String username) &#123;\n        this.username &#x3D; username;\n    &#125;\n\n    public String getAddress() &#123;\n        return address;\n    &#125;\n\n    public void setAddress(String address) &#123;\n        this.address &#x3D; address;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;username&#x3D;&#39;&quot; + username + &#39;\\&#39;&#39; +\n                &quot;, address&#x3D;&#39;&quot; + address + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h5 id=\"2、序列化-反序列化\"><a href=\"#2、序列化-反序列化\" class=\"headerlink\" title=\"2、序列化&#x2F;反序列化\"></a>2、序列化&#x2F;反序列化</h5><p>可以借助commons-lang3工具包里面的类实现对象的序列化及反序列化，你没有必要自己写。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import org.apache.commons.lang3.SerializationUtils;\n\npublic class Test &#123;\n\n    public static void main(String[] args) &#123;\n        User user &#x3D; new User();\n        user.setUsername(&quot;Java&quot;);\n        user.setAddress(&quot;China&quot;);\n        byte[] bytes &#x3D; SerializationUtils.serialize(user);\n\n        User u &#x3D; SerializationUtils.deserialize(bytes);\n        System.out.println(u);\n\n    &#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">User&#123;username&#x3D;&#39;Java&#39;, address&#x3D;&#39;China&#39;&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>上例通过序列化对象字节到内存然后反序列化，当然里面也提供了序列化磁盘然后再反序列化的方法，原理都是一样的，只是目标地不一样。</p>\n<h2 id=\"序列化注意事项\"><a href=\"#序列化注意事项\" class=\"headerlink\" title=\"序列化注意事项\"></a>序列化注意事项</h2><ul>\n<li><p>序列化对象必须实现序列化接口。</p>\n</li>\n<li><p>序列化对象里面的属性是对象的话也要实现序列化接口。</p>\n</li>\n<li><p>类的对象序列化后，类的序列化ID不能轻易修改，不然反序列化会失败。</p>\n</li>\n<li><p>类的对象序列化后，类的属性有增加或者删除不会影响序列化，只是值会丢失。</p>\n</li>\n<li><p>如果父类序列化了，子类会继承父类的序列化，子类无需添加序列化接口。</p>\n</li>\n<li><p>如果父类没有序列化，子类序列化了，子类中的属性能正常序列化，但父类的属性会丢失，不能序列化。</p>\n</li>\n<li><p>用Java序列化的二进制字节数据只能由Java反序列化，不能被其他语言反序列化。如果要进行前后端或者不同语言之间的交互一般需要将对象转变成Json&#x2F;Xml通用格式的数据，再恢复原来的对象。</p>\n</li>\n</ul>\n"},{"title":"坑爹的 Java 可变参数，把我整得够惨。","date":"2025-10-14T06:42:34.000Z","_content":"\n**什么是可变参数？**\n\n就是方法参数用 `Object... args` 三个点形式，一个参数可以接收多个参数。\n\n实际的代码就不帖了，来看这个示例吧：\n\n**示例1**\n\n```\npublic static void main(String[] args) {\n    test(\"name=%s&memo=%s\", \"Java技术\", \"666\");\n}\n\nprivate static void test(String text, Object... params) {\n    String result = String.format(text, params);\n    System.out.println(result);\n}\n```\n\n大家猜结果是什么？结果如我们想象：\n\n```\nname=Java技术&memo=666\n```\n\n**示例2**\n\n```\npublic static void main(String[] args) {\n    test(\"name=%s&memo=%s\", \"Java技术\");\n}\n\nprivate static void test(String text, Object... params) {\n    String result = String.format(text, params, \"666\");\n    System.out.println(result);\n}\n```\n\n我把 \"666\" 移到了子方法里面，放到了 format 最后，再来看下结果是什么。\n\n```\nname=[Ljava.lang.Object;@4cb2c100&memo=666\n```\n\n这并非是我想要的结果，把可变参数 params 数组对象地址作为值输出出来了，把我搞得够惨，最后我干掉了可变参数。。\n\nJDK里面很多有用到可变参数的，可实际开发中，并不建议使用可变参考，它带来的困扰和潜在的问题会远大于便利性，比如在方法重构、重写等也会带来很多问题。\n\n关于可变参数，也是有开发规范的，不能随便写。我找到了阿里巴巴的《Java开发手册》中关于可变参数的规约。\n\n> 相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object 。\n> \n> 说明：可变参数必须放置在参数列表的最后。 （ 提倡同学们尽量不用可变参数编程 ）\n> \n> 正例： public List<User> listUsers(String type, Long... ids) {...}\n\n\n\n","source":"_posts/基础/坑爹的 Java 可变参数，把我整得够惨。.md","raw":"---\ntitle: 坑爹的 Java 可变参数，把我整得够惨。\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 基础\n---\n\n**什么是可变参数？**\n\n就是方法参数用 `Object... args` 三个点形式，一个参数可以接收多个参数。\n\n实际的代码就不帖了，来看这个示例吧：\n\n**示例1**\n\n```\npublic static void main(String[] args) {\n    test(\"name=%s&memo=%s\", \"Java技术\", \"666\");\n}\n\nprivate static void test(String text, Object... params) {\n    String result = String.format(text, params);\n    System.out.println(result);\n}\n```\n\n大家猜结果是什么？结果如我们想象：\n\n```\nname=Java技术&memo=666\n```\n\n**示例2**\n\n```\npublic static void main(String[] args) {\n    test(\"name=%s&memo=%s\", \"Java技术\");\n}\n\nprivate static void test(String text, Object... params) {\n    String result = String.format(text, params, \"666\");\n    System.out.println(result);\n}\n```\n\n我把 \"666\" 移到了子方法里面，放到了 format 最后，再来看下结果是什么。\n\n```\nname=[Ljava.lang.Object;@4cb2c100&memo=666\n```\n\n这并非是我想要的结果，把可变参数 params 数组对象地址作为值输出出来了，把我搞得够惨，最后我干掉了可变参数。。\n\nJDK里面很多有用到可变参数的，可实际开发中，并不建议使用可变参考，它带来的困扰和潜在的问题会远大于便利性，比如在方法重构、重写等也会带来很多问题。\n\n关于可变参数，也是有开发规范的，不能随便写。我找到了阿里巴巴的《Java开发手册》中关于可变参数的规约。\n\n> 相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object 。\n> \n> 说明：可变参数必须放置在参数列表的最后。 （ 提倡同学们尽量不用可变参数编程 ）\n> \n> 正例： public List<User> listUsers(String type, Long... ids) {...}\n\n\n\n","slug":"基础/坑爹的 Java 可变参数，把我整得够惨。","published":1,"updated":"2025-10-15T07:19:51.805Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076x004cqkd4ez50c4c3","content":"<p><strong>什么是可变参数？</strong></p>\n<p>就是方法参数用 <code>Object... args</code> 三个点形式，一个参数可以接收多个参数。</p>\n<p>实际的代码就不帖了，来看这个示例吧：</p>\n<p><strong>示例1</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    test(&quot;name&#x3D;%s&amp;memo&#x3D;%s&quot;, &quot;Java技术&quot;, &quot;666&quot;);\n&#125;\n\nprivate static void test(String text, Object... params) &#123;\n    String result &#x3D; String.format(text, params);\n    System.out.println(result);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>大家猜结果是什么？结果如我们想象：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">name&#x3D;Java技术&amp;memo&#x3D;666<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><strong>示例2</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    test(&quot;name&#x3D;%s&amp;memo&#x3D;%s&quot;, &quot;Java技术&quot;);\n&#125;\n\nprivate static void test(String text, Object... params) &#123;\n    String result &#x3D; String.format(text, params, &quot;666&quot;);\n    System.out.println(result);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我把 “666” 移到了子方法里面，放到了 format 最后，再来看下结果是什么。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">name&#x3D;[Ljava.lang.Object;@4cb2c100&amp;memo&#x3D;666<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这并非是我想要的结果，把可变参数 params 数组对象地址作为值输出出来了，把我搞得够惨，最后我干掉了可变参数。。</p>\n<p>JDK里面很多有用到可变参数的，可实际开发中，并不建议使用可变参考，它带来的困扰和潜在的问题会远大于便利性，比如在方法重构、重写等也会带来很多问题。</p>\n<p>关于可变参数，也是有开发规范的，不能随便写。我找到了阿里巴巴的《Java开发手册》中关于可变参数的规约。</p>\n<blockquote>\n<p>相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object 。</p>\n<p>说明：可变参数必须放置在参数列表的最后。 （ 提倡同学们尽量不用可变参数编程 ）</p>\n<p>正例： public List<User> listUsers(String type, Long… ids) {…}</p>\n</blockquote>\n","excerpt":"","more":"<p><strong>什么是可变参数？</strong></p>\n<p>就是方法参数用 <code>Object... args</code> 三个点形式，一个参数可以接收多个参数。</p>\n<p>实际的代码就不帖了，来看这个示例吧：</p>\n<p><strong>示例1</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    test(&quot;name&#x3D;%s&amp;memo&#x3D;%s&quot;, &quot;Java技术&quot;, &quot;666&quot;);\n&#125;\n\nprivate static void test(String text, Object... params) &#123;\n    String result &#x3D; String.format(text, params);\n    System.out.println(result);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>大家猜结果是什么？结果如我们想象：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">name&#x3D;Java技术&amp;memo&#x3D;666<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><strong>示例2</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    test(&quot;name&#x3D;%s&amp;memo&#x3D;%s&quot;, &quot;Java技术&quot;);\n&#125;\n\nprivate static void test(String text, Object... params) &#123;\n    String result &#x3D; String.format(text, params, &quot;666&quot;);\n    System.out.println(result);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我把 “666” 移到了子方法里面，放到了 format 最后，再来看下结果是什么。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">name&#x3D;[Ljava.lang.Object;@4cb2c100&amp;memo&#x3D;666<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这并非是我想要的结果，把可变参数 params 数组对象地址作为值输出出来了，把我搞得够惨，最后我干掉了可变参数。。</p>\n<p>JDK里面很多有用到可变参数的，可实际开发中，并不建议使用可变参考，它带来的困扰和潜在的问题会远大于便利性，比如在方法重构、重写等也会带来很多问题。</p>\n<p>关于可变参数，也是有开发规范的，不能随便写。我找到了阿里巴巴的《Java开发手册》中关于可变参数的规约。</p>\n<blockquote>\n<p>相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object 。</p>\n<p>说明：可变参数必须放置在参数列表的最后。 （ 提倡同学们尽量不用可变参数编程 ）</p>\n<p>正例： public List<User> listUsers(String type, Long… ids) {…}</p>\n</blockquote>\n"},{"title":"字符串拼接 + 和 concat 的区别","date":"2025-10-14T06:42:34.000Z","_content":"\n+和concat都可以用来拼接字符串，但在使用上有什么区别呢，先来看看这个例子。\n\n```\npublic static void main(String[] args) {\n\t// example1\n\tString str1 = \"s1\";\n\tSystem.out.println(str1 + 100);//s1100\n\tSystem.out.println(100 + str1);//100s1\n\n\tString str2 = \"s2\";\n\tstr2 = str2.concat(\"a\").concat(\"bc\");\n\tSystem.out.println(str2);//s2abc\n\n\t// example2\n\tString str3 = \"s3\";\n\tSystem.out.println(str3 + null);//s3null\n\tSystem.out.println(null + str3);//nulls3\n\n\tString str4 = null;\n\tSystem.out.println(str4.concat(\"a\"));//NullPointerException\n\tSystem.out.println(\"a\".concat(str4));//NullPointerException\n}\n```\n\nconcat源码：\n\n```\npublic String concat(String str) {\n    int otherLen = str.length();\n    if (otherLen == 0) {\n        return this;\n    }\n    int len = value.length;\n    char buf[] = Arrays.copyOf(value, len + otherLen);\n    str.getChars(buf, len);\n    return new String(buf, true);\n}\n```\n\n看下生成的字节码：\n\n\n#### 所以可以得出以下结论：\n\n1. +可以是字符串或者数字及其他基本类型数据，而concat只能接收字符串。\n\n2. +左右可以为null，concat为会空指针。\n\n3. 如果拼接空字符串，concat会稍快，在速度上两者可以忽略不计，如果拼接更多字符串建议用StringBuilder。\n\n4. 从字节码来看+号编译后就是使用了StringBuiler来拼接，所以一行+++的语句就会创建一个StringBuilder，多条+++语句就会创建多个，所以为什么建议用StringBuilder的原因。\n\n","source":"_posts/基础/字符串拼接 + 和 concat 的区别.md","raw":"---\ntitle: 字符串拼接 + 和 concat 的区别\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 基础\n---\n\n+和concat都可以用来拼接字符串，但在使用上有什么区别呢，先来看看这个例子。\n\n```\npublic static void main(String[] args) {\n\t// example1\n\tString str1 = \"s1\";\n\tSystem.out.println(str1 + 100);//s1100\n\tSystem.out.println(100 + str1);//100s1\n\n\tString str2 = \"s2\";\n\tstr2 = str2.concat(\"a\").concat(\"bc\");\n\tSystem.out.println(str2);//s2abc\n\n\t// example2\n\tString str3 = \"s3\";\n\tSystem.out.println(str3 + null);//s3null\n\tSystem.out.println(null + str3);//nulls3\n\n\tString str4 = null;\n\tSystem.out.println(str4.concat(\"a\"));//NullPointerException\n\tSystem.out.println(\"a\".concat(str4));//NullPointerException\n}\n```\n\nconcat源码：\n\n```\npublic String concat(String str) {\n    int otherLen = str.length();\n    if (otherLen == 0) {\n        return this;\n    }\n    int len = value.length;\n    char buf[] = Arrays.copyOf(value, len + otherLen);\n    str.getChars(buf, len);\n    return new String(buf, true);\n}\n```\n\n看下生成的字节码：\n\n\n#### 所以可以得出以下结论：\n\n1. +可以是字符串或者数字及其他基本类型数据，而concat只能接收字符串。\n\n2. +左右可以为null，concat为会空指针。\n\n3. 如果拼接空字符串，concat会稍快，在速度上两者可以忽略不计，如果拼接更多字符串建议用StringBuilder。\n\n4. 从字节码来看+号编译后就是使用了StringBuiler来拼接，所以一行+++的语句就会创建一个StringBuilder，多条+++语句就会创建多个，所以为什么建议用StringBuilder的原因。\n\n","slug":"基础/字符串拼接 + 和 concat 的区别","published":1,"updated":"2025-10-15T07:19:51.789Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076y004fqkd4aol40svf","content":"<p>+和concat都可以用来拼接字符串，但在使用上有什么区别呢，先来看看这个例子。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n\t&#x2F;&#x2F; example1\n\tString str1 &#x3D; &quot;s1&quot;;\n\tSystem.out.println(str1 + 100);&#x2F;&#x2F;s1100\n\tSystem.out.println(100 + str1);&#x2F;&#x2F;100s1\n\n\tString str2 &#x3D; &quot;s2&quot;;\n\tstr2 &#x3D; str2.concat(&quot;a&quot;).concat(&quot;bc&quot;);\n\tSystem.out.println(str2);&#x2F;&#x2F;s2abc\n\n\t&#x2F;&#x2F; example2\n\tString str3 &#x3D; &quot;s3&quot;;\n\tSystem.out.println(str3 + null);&#x2F;&#x2F;s3null\n\tSystem.out.println(null + str3);&#x2F;&#x2F;nulls3\n\n\tString str4 &#x3D; null;\n\tSystem.out.println(str4.concat(&quot;a&quot;));&#x2F;&#x2F;NullPointerException\n\tSystem.out.println(&quot;a&quot;.concat(str4));&#x2F;&#x2F;NullPointerException\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>concat源码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public String concat(String str) &#123;\n    int otherLen &#x3D; str.length();\n    if (otherLen &#x3D;&#x3D; 0) &#123;\n        return this;\n    &#125;\n    int len &#x3D; value.length;\n    char buf[] &#x3D; Arrays.copyOf(value, len + otherLen);\n    str.getChars(buf, len);\n    return new String(buf, true);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>看下生成的字节码：</p>\n<h4 id=\"所以可以得出以下结论：\"><a href=\"#所以可以得出以下结论：\" class=\"headerlink\" title=\"所以可以得出以下结论：\"></a>所以可以得出以下结论：</h4><ol>\n<li><p>+可以是字符串或者数字及其他基本类型数据，而concat只能接收字符串。</p>\n</li>\n<li><p>+左右可以为null，concat为会空指针。</p>\n</li>\n<li><p>如果拼接空字符串，concat会稍快，在速度上两者可以忽略不计，如果拼接更多字符串建议用StringBuilder。</p>\n</li>\n<li><p>从字节码来看+号编译后就是使用了StringBuiler来拼接，所以一行+++的语句就会创建一个StringBuilder，多条+++语句就会创建多个，所以为什么建议用StringBuilder的原因。</p>\n</li>\n</ol>\n","excerpt":"","more":"<p>+和concat都可以用来拼接字符串，但在使用上有什么区别呢，先来看看这个例子。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n\t&#x2F;&#x2F; example1\n\tString str1 &#x3D; &quot;s1&quot;;\n\tSystem.out.println(str1 + 100);&#x2F;&#x2F;s1100\n\tSystem.out.println(100 + str1);&#x2F;&#x2F;100s1\n\n\tString str2 &#x3D; &quot;s2&quot;;\n\tstr2 &#x3D; str2.concat(&quot;a&quot;).concat(&quot;bc&quot;);\n\tSystem.out.println(str2);&#x2F;&#x2F;s2abc\n\n\t&#x2F;&#x2F; example2\n\tString str3 &#x3D; &quot;s3&quot;;\n\tSystem.out.println(str3 + null);&#x2F;&#x2F;s3null\n\tSystem.out.println(null + str3);&#x2F;&#x2F;nulls3\n\n\tString str4 &#x3D; null;\n\tSystem.out.println(str4.concat(&quot;a&quot;));&#x2F;&#x2F;NullPointerException\n\tSystem.out.println(&quot;a&quot;.concat(str4));&#x2F;&#x2F;NullPointerException\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>concat源码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public String concat(String str) &#123;\n    int otherLen &#x3D; str.length();\n    if (otherLen &#x3D;&#x3D; 0) &#123;\n        return this;\n    &#125;\n    int len &#x3D; value.length;\n    char buf[] &#x3D; Arrays.copyOf(value, len + otherLen);\n    str.getChars(buf, len);\n    return new String(buf, true);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>看下生成的字节码：</p>\n<h4 id=\"所以可以得出以下结论：\"><a href=\"#所以可以得出以下结论：\" class=\"headerlink\" title=\"所以可以得出以下结论：\"></a>所以可以得出以下结论：</h4><ol>\n<li><p>+可以是字符串或者数字及其他基本类型数据，而concat只能接收字符串。</p>\n</li>\n<li><p>+左右可以为null，concat为会空指针。</p>\n</li>\n<li><p>如果拼接空字符串，concat会稍快，在速度上两者可以忽略不计，如果拼接更多字符串建议用StringBuilder。</p>\n</li>\n<li><p>从字节码来看+号编译后就是使用了StringBuiler来拼接，所以一行+++的语句就会创建一个StringBuilder，多条+++语句就会创建多个，所以为什么建议用StringBuilder的原因。</p>\n</li>\n</ol>\n"},{"title":"常见的 3 种 Class 级别的错误","date":"2025-10-14T06:42:34.000Z","_content":"\n## ClassNotFoundException\n\n很明显，这个错误是`找不到类异常`，即在当前classpath路径下找不到这个类。\n\nClassNotFoundException继承了Exception，是必须捕获的异常，所以这个异常一般发生在显示加载类的时候，如下面两种方式显示来加载类并要捕获异常。\n\n```\npublic static void main(String[] args) {\n    try {\n        Class.forName(\"com.User\");\n    } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n    }\n\n    try {\n        Test.class.getClassLoader().loadClass(\"com.User\");\n    } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n    }\n\n}\n```\n当无法找到对应的类时都会抛出ClassNotFoundException异常。\n\n```\njava.lang.ClassNotFoundException: com.User\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\tat com.test.user.Test.main(Test.java:15)\n```\n\n## NoClassDefFoundError\n\n这是虚拟机隐式加载类出现的异常。\n\n这个异常继承了Error类，一般发生在引用的类不存在，即类、方法或者属性引用了某个类或者接口，如果目标引用不存在就会抛出这个异常。\n\n```\nimport org.jdom2.input.DOMBuilder;\npublic class MyDomBuilder extends DOMBuilder{\n\n}\n```\n```\npublic static void main(String[] args) {\n    MyDomBuilder builder = new MyDomBuilder();\n}\n```\nMyDomBuilder继承了DOMBuilder，如果把DOMBuilder所属的jar包范围设置为provided，即运行时找不到DOMBuilder类就会报错。\n```\nException in thread \"main\" java.lang.NoClassDefFoundError: org/jdom2/input/DOMBuilder\n\tat java.lang.ClassLoader.defineClass1(Native Method)\n\tat java.lang.ClassLoader.defineClass(ClassLoader.java:763)\n\tat java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\n\tat java.net.URLClassLoader.defineClass(URLClassLoader.java:467)\n\tat java.net.URLClassLoader.access$100(URLClassLoader.java:73)\n\tat java.net.URLClassLoader$1.run(URLClassLoader.java:368)\n\tat java.net.URLClassLoader$1.run(URLClassLoader.java:362)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:361)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\tat com.test.user.Test.main(Test.java:8)\nCaused by: java.lang.ClassNotFoundException: org.jdom2.input.DOMBuilder\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\t... 13 more\n```\n先报出ClassNotFoundException，然后引发NoClassDefFoundError。\n\n所以，以上两个错误都要确保加载类或者引用类都要在classpath路径下。\n\n## ClassCastException\n\n类转换异常，这个错误一般发生在一个对象强制转换类型的时候，如将一个String强制转换成Integer就会报这个错。\n\n这个异常继承了运行时异常RuntimeException，不需要捕获的异常。为了避免报这个错，在转换之间可以先用instanceof判断下是不是该类的引用再转换。如果是集合类型，最好指定集合里面的泛型。\n\n\n```\npublic static void main(String[] args) {\n    Object str = \"123\";\n    Integer i = (Integer)str;\n}\n```\n\n字符串\"123\"强制转换成Integer，然后报错。\n\n```\nException in thread \"main\" java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer\n\tat com.test.user.Test.main(Test.java:9)\n```\n\n","source":"_posts/基础/常见的 3 种 Class 级别的错误.md","raw":"---\ntitle: 常见的 3 种 Class 级别的错误\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 基础\n---\n\n## ClassNotFoundException\n\n很明显，这个错误是`找不到类异常`，即在当前classpath路径下找不到这个类。\n\nClassNotFoundException继承了Exception，是必须捕获的异常，所以这个异常一般发生在显示加载类的时候，如下面两种方式显示来加载类并要捕获异常。\n\n```\npublic static void main(String[] args) {\n    try {\n        Class.forName(\"com.User\");\n    } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n    }\n\n    try {\n        Test.class.getClassLoader().loadClass(\"com.User\");\n    } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n    }\n\n}\n```\n当无法找到对应的类时都会抛出ClassNotFoundException异常。\n\n```\njava.lang.ClassNotFoundException: com.User\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\tat com.test.user.Test.main(Test.java:15)\n```\n\n## NoClassDefFoundError\n\n这是虚拟机隐式加载类出现的异常。\n\n这个异常继承了Error类，一般发生在引用的类不存在，即类、方法或者属性引用了某个类或者接口，如果目标引用不存在就会抛出这个异常。\n\n```\nimport org.jdom2.input.DOMBuilder;\npublic class MyDomBuilder extends DOMBuilder{\n\n}\n```\n```\npublic static void main(String[] args) {\n    MyDomBuilder builder = new MyDomBuilder();\n}\n```\nMyDomBuilder继承了DOMBuilder，如果把DOMBuilder所属的jar包范围设置为provided，即运行时找不到DOMBuilder类就会报错。\n```\nException in thread \"main\" java.lang.NoClassDefFoundError: org/jdom2/input/DOMBuilder\n\tat java.lang.ClassLoader.defineClass1(Native Method)\n\tat java.lang.ClassLoader.defineClass(ClassLoader.java:763)\n\tat java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\n\tat java.net.URLClassLoader.defineClass(URLClassLoader.java:467)\n\tat java.net.URLClassLoader.access$100(URLClassLoader.java:73)\n\tat java.net.URLClassLoader$1.run(URLClassLoader.java:368)\n\tat java.net.URLClassLoader$1.run(URLClassLoader.java:362)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:361)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\tat com.test.user.Test.main(Test.java:8)\nCaused by: java.lang.ClassNotFoundException: org.jdom2.input.DOMBuilder\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\t... 13 more\n```\n先报出ClassNotFoundException，然后引发NoClassDefFoundError。\n\n所以，以上两个错误都要确保加载类或者引用类都要在classpath路径下。\n\n## ClassCastException\n\n类转换异常，这个错误一般发生在一个对象强制转换类型的时候，如将一个String强制转换成Integer就会报这个错。\n\n这个异常继承了运行时异常RuntimeException，不需要捕获的异常。为了避免报这个错，在转换之间可以先用instanceof判断下是不是该类的引用再转换。如果是集合类型，最好指定集合里面的泛型。\n\n\n```\npublic static void main(String[] args) {\n    Object str = \"123\";\n    Integer i = (Integer)str;\n}\n```\n\n字符串\"123\"强制转换成Integer，然后报错。\n\n```\nException in thread \"main\" java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer\n\tat com.test.user.Test.main(Test.java:9)\n```\n\n","slug":"基础/常见的 3 种 Class 级别的错误","published":1,"updated":"2025-10-15T07:19:51.893Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076y004iqkd415ts7h45","content":"<h2 id=\"ClassNotFoundException\"><a href=\"#ClassNotFoundException\" class=\"headerlink\" title=\"ClassNotFoundException\"></a>ClassNotFoundException</h2><p>很明显，这个错误是<code>找不到类异常</code>，即在当前classpath路径下找不到这个类。</p>\n<p>ClassNotFoundException继承了Exception，是必须捕获的异常，所以这个异常一般发生在显示加载类的时候，如下面两种方式显示来加载类并要捕获异常。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    try &#123;\n        Class.forName(&quot;com.User&quot;);\n    &#125; catch (ClassNotFoundException e) &#123;\n        e.printStackTrace();\n    &#125;\n\n    try &#123;\n        Test.class.getClassLoader().loadClass(&quot;com.User&quot;);\n    &#125; catch (ClassNotFoundException e) &#123;\n        e.printStackTrace();\n    &#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>当无法找到对应的类时都会抛出ClassNotFoundException异常。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">java.lang.ClassNotFoundException: com.User\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\tat com.test.user.Test.main(Test.java:15)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"NoClassDefFoundError\"><a href=\"#NoClassDefFoundError\" class=\"headerlink\" title=\"NoClassDefFoundError\"></a>NoClassDefFoundError</h2><p>这是虚拟机隐式加载类出现的异常。</p>\n<p>这个异常继承了Error类，一般发生在引用的类不存在，即类、方法或者属性引用了某个类或者接口，如果目标引用不存在就会抛出这个异常。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import org.jdom2.input.DOMBuilder;\npublic class MyDomBuilder extends DOMBuilder&#123;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    MyDomBuilder builder &#x3D; new MyDomBuilder();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>MyDomBuilder继承了DOMBuilder，如果把DOMBuilder所属的jar包范围设置为provided，即运行时找不到DOMBuilder类就会报错。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org&#x2F;jdom2&#x2F;input&#x2F;DOMBuilder\n\tat java.lang.ClassLoader.defineClass1(Native Method)\n\tat java.lang.ClassLoader.defineClass(ClassLoader.java:763)\n\tat java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\n\tat java.net.URLClassLoader.defineClass(URLClassLoader.java:467)\n\tat java.net.URLClassLoader.access$100(URLClassLoader.java:73)\n\tat java.net.URLClassLoader$1.run(URLClassLoader.java:368)\n\tat java.net.URLClassLoader$1.run(URLClassLoader.java:362)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:361)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\tat com.test.user.Test.main(Test.java:8)\nCaused by: java.lang.ClassNotFoundException: org.jdom2.input.DOMBuilder\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\t... 13 more<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>先报出ClassNotFoundException，然后引发NoClassDefFoundError。</p>\n<p>所以，以上两个错误都要确保加载类或者引用类都要在classpath路径下。</p>\n<h2 id=\"ClassCastException\"><a href=\"#ClassCastException\" class=\"headerlink\" title=\"ClassCastException\"></a>ClassCastException</h2><p>类转换异常，这个错误一般发生在一个对象强制转换类型的时候，如将一个String强制转换成Integer就会报这个错。</p>\n<p>这个异常继承了运行时异常RuntimeException，不需要捕获的异常。为了避免报这个错，在转换之间可以先用instanceof判断下是不是该类的引用再转换。如果是集合类型，最好指定集合里面的泛型。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    Object str &#x3D; &quot;123&quot;;\n    Integer i &#x3D; (Integer)str;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>字符串”123”强制转换成Integer，然后报错。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer\n\tat com.test.user.Test.main(Test.java:9)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n","excerpt":"","more":"<h2 id=\"ClassNotFoundException\"><a href=\"#ClassNotFoundException\" class=\"headerlink\" title=\"ClassNotFoundException\"></a>ClassNotFoundException</h2><p>很明显，这个错误是<code>找不到类异常</code>，即在当前classpath路径下找不到这个类。</p>\n<p>ClassNotFoundException继承了Exception，是必须捕获的异常，所以这个异常一般发生在显示加载类的时候，如下面两种方式显示来加载类并要捕获异常。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    try &#123;\n        Class.forName(&quot;com.User&quot;);\n    &#125; catch (ClassNotFoundException e) &#123;\n        e.printStackTrace();\n    &#125;\n\n    try &#123;\n        Test.class.getClassLoader().loadClass(&quot;com.User&quot;);\n    &#125; catch (ClassNotFoundException e) &#123;\n        e.printStackTrace();\n    &#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>当无法找到对应的类时都会抛出ClassNotFoundException异常。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">java.lang.ClassNotFoundException: com.User\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\tat com.test.user.Test.main(Test.java:15)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"NoClassDefFoundError\"><a href=\"#NoClassDefFoundError\" class=\"headerlink\" title=\"NoClassDefFoundError\"></a>NoClassDefFoundError</h2><p>这是虚拟机隐式加载类出现的异常。</p>\n<p>这个异常继承了Error类，一般发生在引用的类不存在，即类、方法或者属性引用了某个类或者接口，如果目标引用不存在就会抛出这个异常。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import org.jdom2.input.DOMBuilder;\npublic class MyDomBuilder extends DOMBuilder&#123;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    MyDomBuilder builder &#x3D; new MyDomBuilder();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>MyDomBuilder继承了DOMBuilder，如果把DOMBuilder所属的jar包范围设置为provided，即运行时找不到DOMBuilder类就会报错。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org&#x2F;jdom2&#x2F;input&#x2F;DOMBuilder\n\tat java.lang.ClassLoader.defineClass1(Native Method)\n\tat java.lang.ClassLoader.defineClass(ClassLoader.java:763)\n\tat java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\n\tat java.net.URLClassLoader.defineClass(URLClassLoader.java:467)\n\tat java.net.URLClassLoader.access$100(URLClassLoader.java:73)\n\tat java.net.URLClassLoader$1.run(URLClassLoader.java:368)\n\tat java.net.URLClassLoader$1.run(URLClassLoader.java:362)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:361)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\tat com.test.user.Test.main(Test.java:8)\nCaused by: java.lang.ClassNotFoundException: org.jdom2.input.DOMBuilder\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\t... 13 more<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>先报出ClassNotFoundException，然后引发NoClassDefFoundError。</p>\n<p>所以，以上两个错误都要确保加载类或者引用类都要在classpath路径下。</p>\n<h2 id=\"ClassCastException\"><a href=\"#ClassCastException\" class=\"headerlink\" title=\"ClassCastException\"></a>ClassCastException</h2><p>类转换异常，这个错误一般发生在一个对象强制转换类型的时候，如将一个String强制转换成Integer就会报这个错。</p>\n<p>这个异常继承了运行时异常RuntimeException，不需要捕获的异常。为了避免报这个错，在转换之间可以先用instanceof判断下是不是该类的引用再转换。如果是集合类型，最好指定集合里面的泛型。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n    Object str &#x3D; &quot;123&quot;;\n    Integer i &#x3D; (Integer)str;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>字符串”123”强制转换成Integer，然后报错。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer\n\tat com.test.user.Test.main(Test.java:9)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n"},{"title":"深入浅出 Java 中的包装类","date":"2025-10-14T06:42:34.000Z","_content":"\n![](http://img.javastack.cn/18-6-5/61544442.jpg)\n\n#### 什么是包装类型\n\nJava 设计当初就提供了 8 种 基本数据类型及对应的 8 种包装数据类型。我们知道 Java 是一种面向对象编程的高级语言，所以包装类型正是为了解决基本数据类型无法面向对象编程所提供的。\n\n**下面是基本数据类型与对应的包装类型。**\n\n基本数据类型 | 包装类型\n---|---\nbyte | Byte\nboolean | Boolean\nshort | Short\nchar | Character\nint | Integer\nlong | Long\nfloat | Float\ndouble | Double\n\n**下面是包装类型的继承结构图。**\n\n![](http://img.javastack.cn/18-6-5/80489463.jpg)\n\n从以上图表可以对基本类型和包装类型有一个全面的了解。\n\n#### 包装类应用场景\n\n**1、集合类泛型只能是包装类；**\n\n```\n// 编译报错\nList<int> list1 = new ArrayList<>();\n\n// 正常\nList<Integer> list2 = new ArrayList<>();\n```\n\n**2、成员变量不能有默认值；**\n\n```\nprivate int status;\n```\n\n基本数据类型的成员变量都有默认值，如以上代码 status 默认值为 0，如果定义中 0 代表失败，那样就会有问题，这样只能使用包装类 Integer，它的默认值为 null,所以就不会有默认值影响。\n\n**3、方法参数允许定义空值；**\n\n```\nprivate static void test1(int status){\n\tSystem.out.println(status);\n}\n```\n\n看以上代码，方法参数定义的是基本数据类型 int，所以必须得传一个数字过来，不能传 null，很多场合我们希望是能传递 null 的，所以这种场合用包装类比较合适。\n\n还有更多应用场景就不一一例举了，欢迎留言共同探讨包装类的更多的应用场景。\n\n#### 自动装箱、拆箱\n\nJava 5 增加了自动装箱、拆箱机制，提供基本数据类型和包装类型的相互转换操作。\n\n\n**自动装箱**\n\n自动装箱即自动将基本数据类型转换成包装类型，在 Java 5 之前，要将基本数据类型转换成包装类型只能这样做，看下面的代码。\n\n```\nInteger i1 = new Integer(8);\n\nInteger i2 = Integer.valueOf(8);\n\n// 自动装箱\nInteger i3 = 8;\n```\n\n以上 3 种都可以进行转换，但在 Java 5 之前第 3 种方法是编译失败的，第 3 种方法也正是现在的自动装箱功能。另外，第一种构造器方法也不推荐使用了，已经标为废弃了。\n\n其实自动装箱的原理就是调用包装类的 valueOf 方法，如第 2 个方法中的 Integer.valueOf 方法。\n\n**自动拆箱**\n\n自动拆箱即自动将包装类型转换成基本数据类型，与自动装箱相反，有装就有拆，很好理解。\n\n```\n// 自动拆箱\nint i4 = i3;\n\nint i5 = i3.intValue();\n```\n\n继续上面的例子，把 i3 赋值给 i4 就是实现的自动拆箱功能，自动装箱的原理就是调用包装类的 xxValue 方法，如 i5 中的 Integer 的 intValue 方法。\n\n自动装箱、拆箱不只是体现在以上的例子，在方法接收参数、对象设置参数时都能自动装箱拆箱。\n\n**需要注意的是，关于 Integer，-128 ~ 127 会有缓存，对比这个范围的值的对象是一个坑，这个在阿里巴巴规范中也有提及。** 详细请参考《[IntegerCache的妙用和陷阱](https://mp.weixin.qq.com/s/PnVkrMzYeOiepPKjl4MKVA)》这篇文章。\n\n","source":"_posts/基础/深入浅出 Java 中的包装类.md","raw":"---\ntitle: 深入浅出 Java 中的包装类\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 基础\n---\n\n![](http://img.javastack.cn/18-6-5/61544442.jpg)\n\n#### 什么是包装类型\n\nJava 设计当初就提供了 8 种 基本数据类型及对应的 8 种包装数据类型。我们知道 Java 是一种面向对象编程的高级语言，所以包装类型正是为了解决基本数据类型无法面向对象编程所提供的。\n\n**下面是基本数据类型与对应的包装类型。**\n\n基本数据类型 | 包装类型\n---|---\nbyte | Byte\nboolean | Boolean\nshort | Short\nchar | Character\nint | Integer\nlong | Long\nfloat | Float\ndouble | Double\n\n**下面是包装类型的继承结构图。**\n\n![](http://img.javastack.cn/18-6-5/80489463.jpg)\n\n从以上图表可以对基本类型和包装类型有一个全面的了解。\n\n#### 包装类应用场景\n\n**1、集合类泛型只能是包装类；**\n\n```\n// 编译报错\nList<int> list1 = new ArrayList<>();\n\n// 正常\nList<Integer> list2 = new ArrayList<>();\n```\n\n**2、成员变量不能有默认值；**\n\n```\nprivate int status;\n```\n\n基本数据类型的成员变量都有默认值，如以上代码 status 默认值为 0，如果定义中 0 代表失败，那样就会有问题，这样只能使用包装类 Integer，它的默认值为 null,所以就不会有默认值影响。\n\n**3、方法参数允许定义空值；**\n\n```\nprivate static void test1(int status){\n\tSystem.out.println(status);\n}\n```\n\n看以上代码，方法参数定义的是基本数据类型 int，所以必须得传一个数字过来，不能传 null，很多场合我们希望是能传递 null 的，所以这种场合用包装类比较合适。\n\n还有更多应用场景就不一一例举了，欢迎留言共同探讨包装类的更多的应用场景。\n\n#### 自动装箱、拆箱\n\nJava 5 增加了自动装箱、拆箱机制，提供基本数据类型和包装类型的相互转换操作。\n\n\n**自动装箱**\n\n自动装箱即自动将基本数据类型转换成包装类型，在 Java 5 之前，要将基本数据类型转换成包装类型只能这样做，看下面的代码。\n\n```\nInteger i1 = new Integer(8);\n\nInteger i2 = Integer.valueOf(8);\n\n// 自动装箱\nInteger i3 = 8;\n```\n\n以上 3 种都可以进行转换，但在 Java 5 之前第 3 种方法是编译失败的，第 3 种方法也正是现在的自动装箱功能。另外，第一种构造器方法也不推荐使用了，已经标为废弃了。\n\n其实自动装箱的原理就是调用包装类的 valueOf 方法，如第 2 个方法中的 Integer.valueOf 方法。\n\n**自动拆箱**\n\n自动拆箱即自动将包装类型转换成基本数据类型，与自动装箱相反，有装就有拆，很好理解。\n\n```\n// 自动拆箱\nint i4 = i3;\n\nint i5 = i3.intValue();\n```\n\n继续上面的例子，把 i3 赋值给 i4 就是实现的自动拆箱功能，自动装箱的原理就是调用包装类的 xxValue 方法，如 i5 中的 Integer 的 intValue 方法。\n\n自动装箱、拆箱不只是体现在以上的例子，在方法接收参数、对象设置参数时都能自动装箱拆箱。\n\n**需要注意的是，关于 Integer，-128 ~ 127 会有缓存，对比这个范围的值的对象是一个坑，这个在阿里巴巴规范中也有提及。** 详细请参考《[IntegerCache的妙用和陷阱](https://mp.weixin.qq.com/s/PnVkrMzYeOiepPKjl4MKVA)》这篇文章。\n\n","slug":"基础/深入浅出 Java 中的包装类","published":1,"updated":"2025-10-15T07:19:51.843Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076y004lqkd494h1csj8","content":"<p><img src=\"http://img.javastack.cn/18-6-5/61544442.jpg\"></p>\n<h4 id=\"什么是包装类型\"><a href=\"#什么是包装类型\" class=\"headerlink\" title=\"什么是包装类型\"></a>什么是包装类型</h4><p>Java 设计当初就提供了 8 种 基本数据类型及对应的 8 种包装数据类型。我们知道 Java 是一种面向对象编程的高级语言，所以包装类型正是为了解决基本数据类型无法面向对象编程所提供的。</p>\n<p><strong>下面是基本数据类型与对应的包装类型。</strong></p>\n<table>\n<thead>\n<tr>\n<th>基本数据类型</th>\n<th>包装类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>byte</td>\n<td>Byte</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>Boolean</td>\n</tr>\n<tr>\n<td>short</td>\n<td>Short</td>\n</tr>\n<tr>\n<td>char</td>\n<td>Character</td>\n</tr>\n<tr>\n<td>int</td>\n<td>Integer</td>\n</tr>\n<tr>\n<td>long</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>float</td>\n<td>Float</td>\n</tr>\n<tr>\n<td>double</td>\n<td>Double</td>\n</tr>\n</tbody></table>\n<p><strong>下面是包装类型的继承结构图。</strong></p>\n<p><img src=\"http://img.javastack.cn/18-6-5/80489463.jpg\"></p>\n<p>从以上图表可以对基本类型和包装类型有一个全面的了解。</p>\n<h4 id=\"包装类应用场景\"><a href=\"#包装类应用场景\" class=\"headerlink\" title=\"包装类应用场景\"></a>包装类应用场景</h4><p><strong>1、集合类泛型只能是包装类；</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 编译报错\nList&lt;int&gt; list1 &#x3D; new ArrayList&lt;&gt;();\n\n&#x2F;&#x2F; 正常\nList&lt;Integer&gt; list2 &#x3D; new ArrayList&lt;&gt;();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>2、成员变量不能有默认值；</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private int status;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>基本数据类型的成员变量都有默认值，如以上代码 status 默认值为 0，如果定义中 0 代表失败，那样就会有问题，这样只能使用包装类 Integer，它的默认值为 null,所以就不会有默认值影响。</p>\n<p><strong>3、方法参数允许定义空值；</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void test1(int status)&#123;\n\tSystem.out.println(status);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>看以上代码，方法参数定义的是基本数据类型 int，所以必须得传一个数字过来，不能传 null，很多场合我们希望是能传递 null 的，所以这种场合用包装类比较合适。</p>\n<p>还有更多应用场景就不一一例举了，欢迎留言共同探讨包装类的更多的应用场景。</p>\n<h4 id=\"自动装箱、拆箱\"><a href=\"#自动装箱、拆箱\" class=\"headerlink\" title=\"自动装箱、拆箱\"></a>自动装箱、拆箱</h4><p>Java 5 增加了自动装箱、拆箱机制，提供基本数据类型和包装类型的相互转换操作。</p>\n<p><strong>自动装箱</strong></p>\n<p>自动装箱即自动将基本数据类型转换成包装类型，在 Java 5 之前，要将基本数据类型转换成包装类型只能这样做，看下面的代码。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Integer i1 &#x3D; new Integer(8);\n\nInteger i2 &#x3D; Integer.valueOf(8);\n\n&#x2F;&#x2F; 自动装箱\nInteger i3 &#x3D; 8;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上 3 种都可以进行转换，但在 Java 5 之前第 3 种方法是编译失败的，第 3 种方法也正是现在的自动装箱功能。另外，第一种构造器方法也不推荐使用了，已经标为废弃了。</p>\n<p>其实自动装箱的原理就是调用包装类的 valueOf 方法，如第 2 个方法中的 Integer.valueOf 方法。</p>\n<p><strong>自动拆箱</strong></p>\n<p>自动拆箱即自动将包装类型转换成基本数据类型，与自动装箱相反，有装就有拆，很好理解。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 自动拆箱\nint i4 &#x3D; i3;\n\nint i5 &#x3D; i3.intValue();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>继续上面的例子，把 i3 赋值给 i4 就是实现的自动拆箱功能，自动装箱的原理就是调用包装类的 xxValue 方法，如 i5 中的 Integer 的 intValue 方法。</p>\n<p>自动装箱、拆箱不只是体现在以上的例子，在方法接收参数、对象设置参数时都能自动装箱拆箱。</p>\n<p><strong>需要注意的是，关于 Integer，-128 ~ 127 会有缓存，对比这个范围的值的对象是一个坑，这个在阿里巴巴规范中也有提及。</strong> 详细请参考《<a href=\"https://mp.weixin.qq.com/s/PnVkrMzYeOiepPKjl4MKVA\">IntegerCache的妙用和陷阱</a>》这篇文章。</p>\n","excerpt":"","more":"<p><img src=\"http://img.javastack.cn/18-6-5/61544442.jpg\"></p>\n<h4 id=\"什么是包装类型\"><a href=\"#什么是包装类型\" class=\"headerlink\" title=\"什么是包装类型\"></a>什么是包装类型</h4><p>Java 设计当初就提供了 8 种 基本数据类型及对应的 8 种包装数据类型。我们知道 Java 是一种面向对象编程的高级语言，所以包装类型正是为了解决基本数据类型无法面向对象编程所提供的。</p>\n<p><strong>下面是基本数据类型与对应的包装类型。</strong></p>\n<table>\n<thead>\n<tr>\n<th>基本数据类型</th>\n<th>包装类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>byte</td>\n<td>Byte</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>Boolean</td>\n</tr>\n<tr>\n<td>short</td>\n<td>Short</td>\n</tr>\n<tr>\n<td>char</td>\n<td>Character</td>\n</tr>\n<tr>\n<td>int</td>\n<td>Integer</td>\n</tr>\n<tr>\n<td>long</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>float</td>\n<td>Float</td>\n</tr>\n<tr>\n<td>double</td>\n<td>Double</td>\n</tr>\n</tbody></table>\n<p><strong>下面是包装类型的继承结构图。</strong></p>\n<p><img src=\"http://img.javastack.cn/18-6-5/80489463.jpg\"></p>\n<p>从以上图表可以对基本类型和包装类型有一个全面的了解。</p>\n<h4 id=\"包装类应用场景\"><a href=\"#包装类应用场景\" class=\"headerlink\" title=\"包装类应用场景\"></a>包装类应用场景</h4><p><strong>1、集合类泛型只能是包装类；</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 编译报错\nList&lt;int&gt; list1 &#x3D; new ArrayList&lt;&gt;();\n\n&#x2F;&#x2F; 正常\nList&lt;Integer&gt; list2 &#x3D; new ArrayList&lt;&gt;();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>2、成员变量不能有默认值；</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private int status;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>基本数据类型的成员变量都有默认值，如以上代码 status 默认值为 0，如果定义中 0 代表失败，那样就会有问题，这样只能使用包装类 Integer，它的默认值为 null,所以就不会有默认值影响。</p>\n<p><strong>3、方法参数允许定义空值；</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void test1(int status)&#123;\n\tSystem.out.println(status);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>看以上代码，方法参数定义的是基本数据类型 int，所以必须得传一个数字过来，不能传 null，很多场合我们希望是能传递 null 的，所以这种场合用包装类比较合适。</p>\n<p>还有更多应用场景就不一一例举了，欢迎留言共同探讨包装类的更多的应用场景。</p>\n<h4 id=\"自动装箱、拆箱\"><a href=\"#自动装箱、拆箱\" class=\"headerlink\" title=\"自动装箱、拆箱\"></a>自动装箱、拆箱</h4><p>Java 5 增加了自动装箱、拆箱机制，提供基本数据类型和包装类型的相互转换操作。</p>\n<p><strong>自动装箱</strong></p>\n<p>自动装箱即自动将基本数据类型转换成包装类型，在 Java 5 之前，要将基本数据类型转换成包装类型只能这样做，看下面的代码。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Integer i1 &#x3D; new Integer(8);\n\nInteger i2 &#x3D; Integer.valueOf(8);\n\n&#x2F;&#x2F; 自动装箱\nInteger i3 &#x3D; 8;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上 3 种都可以进行转换，但在 Java 5 之前第 3 种方法是编译失败的，第 3 种方法也正是现在的自动装箱功能。另外，第一种构造器方法也不推荐使用了，已经标为废弃了。</p>\n<p>其实自动装箱的原理就是调用包装类的 valueOf 方法，如第 2 个方法中的 Integer.valueOf 方法。</p>\n<p><strong>自动拆箱</strong></p>\n<p>自动拆箱即自动将包装类型转换成基本数据类型，与自动装箱相反，有装就有拆，很好理解。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 自动拆箱\nint i4 &#x3D; i3;\n\nint i5 &#x3D; i3.intValue();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>继续上面的例子，把 i3 赋值给 i4 就是实现的自动拆箱功能，自动装箱的原理就是调用包装类的 xxValue 方法，如 i5 中的 Integer 的 intValue 方法。</p>\n<p>自动装箱、拆箱不只是体现在以上的例子，在方法接收参数、对象设置参数时都能自动装箱拆箱。</p>\n<p><strong>需要注意的是，关于 Integer，-128 ~ 127 会有缓存，对比这个范围的值的对象是一个坑，这个在阿里巴巴规范中也有提及。</strong> 详细请参考《<a href=\"https://mp.weixin.qq.com/s/PnVkrMzYeOiepPKjl4MKVA\">IntegerCache的妙用和陷阱</a>》这篇文章。</p>\n"},{"title":"通用唯一标识码 UUID 的介绍及使用。","date":"2025-10-14T06:42:34.000Z","_content":"\n#### 什么是UUID？\n\nUUID全称：Universally Unique Identifier，即通用唯一识别码。\n\nUUID是由一组32位数的16进制数字所构成，是故UUID理论上的总数为16^32 = 2^128，约等于3.4 x 10^38。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。\n\nUUID的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的32个字符，如：550e8400-e29b-41d4-a716-446655440000。\n\n#### UUID的作用\n\nUUID的是让分布式系统中的所有元素都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。如此一来，每个人都可以创建不与其它人冲突的UUID。在这样的情况下，就不需考虑数据库创建时的名称重复问题。目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID），而其他重要的应用，则有Linux ext2/ext3文件系统、LUKS加密分区、GNOME、KDE、Mac OS X等等。\n\n#### UUID的组成\n\nUUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。\n\n**UUID由以下几部分的组合：**\n\n- 当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。\n\n- 时钟序列。\n\n- 全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。\n\nUUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。\n\n#### UUID的生成\n\n```\npublic static void main(String[] args) throws Exception {\n\tSystem.out.println(UUID.randomUUID());\n}\n```\n\n> 批量生成UUID网站：http://www.uuid.online/","source":"_posts/基础/通用唯一标识码 UUID 的介绍及使用。.md","raw":"---\ntitle: 通用唯一标识码 UUID 的介绍及使用。\ndate: 2025-10-14 14:42:34\ncategory: 后端\ntags: 基础\n---\n\n#### 什么是UUID？\n\nUUID全称：Universally Unique Identifier，即通用唯一识别码。\n\nUUID是由一组32位数的16进制数字所构成，是故UUID理论上的总数为16^32 = 2^128，约等于3.4 x 10^38。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。\n\nUUID的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的32个字符，如：550e8400-e29b-41d4-a716-446655440000。\n\n#### UUID的作用\n\nUUID的是让分布式系统中的所有元素都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。如此一来，每个人都可以创建不与其它人冲突的UUID。在这样的情况下，就不需考虑数据库创建时的名称重复问题。目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID），而其他重要的应用，则有Linux ext2/ext3文件系统、LUKS加密分区、GNOME、KDE、Mac OS X等等。\n\n#### UUID的组成\n\nUUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。\n\n**UUID由以下几部分的组合：**\n\n- 当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。\n\n- 时钟序列。\n\n- 全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。\n\nUUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。\n\n#### UUID的生成\n\n```\npublic static void main(String[] args) throws Exception {\n\tSystem.out.println(UUID.randomUUID());\n}\n```\n\n> 批量生成UUID网站：http://www.uuid.online/","slug":"基础/通用唯一标识码 UUID 的介绍及使用。","published":1,"updated":"2025-10-15T07:19:51.883Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076z004oqkd4c1mr7a2v","content":"<h4 id=\"什么是UUID？\"><a href=\"#什么是UUID？\" class=\"headerlink\" title=\"什么是UUID？\"></a>什么是UUID？</h4><p>UUID全称：Universally Unique Identifier，即通用唯一识别码。</p>\n<p>UUID是由一组32位数的16进制数字所构成，是故UUID理论上的总数为16^32 &#x3D; 2^128，约等于3.4 x 10^38。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。</p>\n<p>UUID的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的32个字符，如：550e8400-e29b-41d4-a716-446655440000。</p>\n<h4 id=\"UUID的作用\"><a href=\"#UUID的作用\" class=\"headerlink\" title=\"UUID的作用\"></a>UUID的作用</h4><p>UUID的是让分布式系统中的所有元素都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。如此一来，每个人都可以创建不与其它人冲突的UUID。在这样的情况下，就不需考虑数据库创建时的名称重复问题。目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID），而其他重要的应用，则有Linux ext2&#x2F;ext3文件系统、LUKS加密分区、GNOME、KDE、Mac OS X等等。</p>\n<h4 id=\"UUID的组成\"><a href=\"#UUID的组成\" class=\"headerlink\" title=\"UUID的组成\"></a>UUID的组成</h4><p>UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。</p>\n<p><strong>UUID由以下几部分的组合：</strong></p>\n<ul>\n<li><p>当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。</p>\n</li>\n<li><p>时钟序列。</p>\n</li>\n<li><p>全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。</p>\n</li>\n</ul>\n<p>UUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。</p>\n<h4 id=\"UUID的生成\"><a href=\"#UUID的生成\" class=\"headerlink\" title=\"UUID的生成\"></a>UUID的生成</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) throws Exception &#123;\n\tSystem.out.println(UUID.randomUUID());\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>批量生成UUID网站：<a href=\"http://www.uuid.online/\">http://www.uuid.online/</a></p>\n</blockquote>\n","excerpt":"","more":"<h4 id=\"什么是UUID？\"><a href=\"#什么是UUID？\" class=\"headerlink\" title=\"什么是UUID？\"></a>什么是UUID？</h4><p>UUID全称：Universally Unique Identifier，即通用唯一识别码。</p>\n<p>UUID是由一组32位数的16进制数字所构成，是故UUID理论上的总数为16^32 &#x3D; 2^128，约等于3.4 x 10^38。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。</p>\n<p>UUID的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的32个字符，如：550e8400-e29b-41d4-a716-446655440000。</p>\n<h4 id=\"UUID的作用\"><a href=\"#UUID的作用\" class=\"headerlink\" title=\"UUID的作用\"></a>UUID的作用</h4><p>UUID的是让分布式系统中的所有元素都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。如此一来，每个人都可以创建不与其它人冲突的UUID。在这样的情况下，就不需考虑数据库创建时的名称重复问题。目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID），而其他重要的应用，则有Linux ext2&#x2F;ext3文件系统、LUKS加密分区、GNOME、KDE、Mac OS X等等。</p>\n<h4 id=\"UUID的组成\"><a href=\"#UUID的组成\" class=\"headerlink\" title=\"UUID的组成\"></a>UUID的组成</h4><p>UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。</p>\n<p><strong>UUID由以下几部分的组合：</strong></p>\n<ul>\n<li><p>当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。</p>\n</li>\n<li><p>时钟序列。</p>\n</li>\n<li><p>全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。</p>\n</li>\n</ul>\n<p>UUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。</p>\n<h4 id=\"UUID的生成\"><a href=\"#UUID的生成\" class=\"headerlink\" title=\"UUID的生成\"></a>UUID的生成</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) throws Exception &#123;\n\tSystem.out.println(UUID.randomUUID());\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>批量生成UUID网站：<a href=\"http://www.uuid.online/\">http://www.uuid.online/</a></p>\n</blockquote>\n"},{"title":"HashMap 和 Hashtable 的 6 个区别","date":"2025-10-15T03:36:33.000Z","_content":"\nHashMap 和 Hashtable 是 Java 开发程序员必须要掌握的，也是在各种 Java 面试场合中必须会问到的。\n\n但你对这两者的区别了解有多少呢？\n\n现在，栈长我给大家总结一下，或许有你不明朗的地方，在栈长的指点下都会拨开迷雾见晴天。\n\n## 1、线程安全\n\nHashtable 是线程安全的，HashMap 不是线程安全的。\n\n为什么说 HashTable 是线程安全的？\n\n来看下 Hashtable 的源码，Hashtable 所有的元素操作都是 synchronized 修饰的，而 HashMap 并没有。\n\n```\npublic synchronized V put(K key, V value);\npublic synchronized V get(Object key);\n...\n```\n\n## 2、性能优劣\n\n既然 Hashtable 是线程安全的，每个方法都要阻塞其他线程，所以 Hashtable 性能较差，HashMap 性能较好，使用更广。\n\n如果要线程安全又要保证性能，建议使用 JUC 包下的 ConcurrentHashMap。\n\n## 3、NULL\n\nHashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。\n\n那么问题来了，为什么 Hashtable 是不允许 KEY 和 VALUE 为 null, 而 HashMap 则可以？\n\n**Hashtable put 方法逻辑：**\n\n```\n public synchronized V put(K key, V value) {\n        // Make sure the value is not null\n        if (value == null) {\n            throw new NullPointerException();\n        }\n\n        // Makes sure the key is not already in the hashtable.\n        Entry<?,?> tab[] = table;\n        int hash = key.hashCode();\n        \n        ...\n    \n}        \n```\n\n**HashMap hash 方法逻辑：**\n\n```\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n可以看出 Hashtable key 为 null 会直接抛出空指针异常，value 为 null 手动抛出空指针异常，而 HashMap 的逻辑对 null 作了特殊处理。\n\n## 4、实现方式\n\nHashtable 的继承源码：\n\n```\npublic class Hashtable<K,V>\n    extends Dictionary<K,V>\n    implements Map<K,V>, Cloneable, java.io.Serializable\n```\n\nHashMap 的继承源码：\n\n```\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable\n```\n\n可以看出两者继承的类不一样，Hashtable 继承了 Dictionary类，而 HashMap 继承的是 AbstractMap 类。\n\nDictionary 是 JDK 1.0 添加的，貌似没人用过这个，栈长我也没用过。。\n\n## 5、容量扩容\n\nHashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。\n\n```\n/**\n * Constructs a new, empty hashtable with a default initial capacity (11)\n * and load factor (0.75).\n */\npublic Hashtable() {\n    this(11, 0.75f);\n}\n\n/**\n * Constructs an empty <tt>HashMap</tt> with the default initial capacity\n * (16) and the default load factor (0.75).\n */\npublic HashMap() {\n    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted\n}\n```\n\n当现有容量大于总容量 * 负载因子时，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 + 1。\n\n## 6、迭代器\n\nHashMap 中的 Iterator 迭代器是 fail-fast 的，而 Hashtable 的 Enumerator 不是 fail-fast 的。\n\n所以，当其他线程改变了HashMap 的结构，如：增加、删除元素，将会抛出 ConcurrentModificationException 异常，而 Hashtable 则不会。\n\n**可以来看下这个区别的演示：**\n\n```\n/**\n* \n**/\npublic static void main(String[] args) {\n    Map<String, String> hashtable = new Hashtable<>();\n    hashtable.put(\"t1\", \"1\");\n    hashtable.put(\"t2\", \"2\");\n    hashtable.put(\"t3\", \"3\");\n\n    Enumeration<Map.Entry<String, String>> iterator1 = (Enumeration<Map.Entry<String, String>>) hashtable.entrySet().iterator();\n    hashtable.remove(iterator1.nextElement().getKey());\n    while (iterator1.hasMoreElements()) {\n        System.out.println(iterator1.nextElement());\n    }\n\n    Map<String, String> hashMap = new HashMap<>();\n    hashMap.put(\"h1\", \"1\");\n    hashMap.put(\"h2\", \"2\");\n    hashMap.put(\"h3\", \"3\");\n\n    Iterator<Map.Entry<String, String>> iterator2 = hashMap.entrySet().iterator();\n    hashMap.remove(iterator2.next().getKey());\n    while (iterator2.hasNext()) {\n        System.out.println(iterator2.next());\n    }\n\n}\n```\n\n输出信息：\n\n```\nt2=2\nt1=1\nException in thread \"main\" java.util.ConcurrentModificationException\n\tat java.util.HashMap$HashIterator.nextNode(HashMap.java:1442)\n\tat java.util.HashMap$EntryIterator.next(HashMap.java:1476)\n\tat java.util.HashMap$EntryIterator.next(HashMap.java:1474)\n\tat cn.javastack.Test.main(Test.java:37)\n```\n\n看到了吧？\n\n所以，这条同样也是 Enumeration 和 Iterator 的区别。 \n\n最后一点有几个人知道？知道的给栈长点个赞回应一下，不知道的有收获的也点一个赞支持一下吧。\n\n有收获？转发给更多的人吧！\n\n","source":"_posts/集合/HashMap 和 Hashtable 的 6 个区别.md","raw":"---\ntitle: HashMap 和 Hashtable 的 6 个区别\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 集合\n---\n\nHashMap 和 Hashtable 是 Java 开发程序员必须要掌握的，也是在各种 Java 面试场合中必须会问到的。\n\n但你对这两者的区别了解有多少呢？\n\n现在，栈长我给大家总结一下，或许有你不明朗的地方，在栈长的指点下都会拨开迷雾见晴天。\n\n## 1、线程安全\n\nHashtable 是线程安全的，HashMap 不是线程安全的。\n\n为什么说 HashTable 是线程安全的？\n\n来看下 Hashtable 的源码，Hashtable 所有的元素操作都是 synchronized 修饰的，而 HashMap 并没有。\n\n```\npublic synchronized V put(K key, V value);\npublic synchronized V get(Object key);\n...\n```\n\n## 2、性能优劣\n\n既然 Hashtable 是线程安全的，每个方法都要阻塞其他线程，所以 Hashtable 性能较差，HashMap 性能较好，使用更广。\n\n如果要线程安全又要保证性能，建议使用 JUC 包下的 ConcurrentHashMap。\n\n## 3、NULL\n\nHashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。\n\n那么问题来了，为什么 Hashtable 是不允许 KEY 和 VALUE 为 null, 而 HashMap 则可以？\n\n**Hashtable put 方法逻辑：**\n\n```\n public synchronized V put(K key, V value) {\n        // Make sure the value is not null\n        if (value == null) {\n            throw new NullPointerException();\n        }\n\n        // Makes sure the key is not already in the hashtable.\n        Entry<?,?> tab[] = table;\n        int hash = key.hashCode();\n        \n        ...\n    \n}        \n```\n\n**HashMap hash 方法逻辑：**\n\n```\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n可以看出 Hashtable key 为 null 会直接抛出空指针异常，value 为 null 手动抛出空指针异常，而 HashMap 的逻辑对 null 作了特殊处理。\n\n## 4、实现方式\n\nHashtable 的继承源码：\n\n```\npublic class Hashtable<K,V>\n    extends Dictionary<K,V>\n    implements Map<K,V>, Cloneable, java.io.Serializable\n```\n\nHashMap 的继承源码：\n\n```\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable\n```\n\n可以看出两者继承的类不一样，Hashtable 继承了 Dictionary类，而 HashMap 继承的是 AbstractMap 类。\n\nDictionary 是 JDK 1.0 添加的，貌似没人用过这个，栈长我也没用过。。\n\n## 5、容量扩容\n\nHashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。\n\n```\n/**\n * Constructs a new, empty hashtable with a default initial capacity (11)\n * and load factor (0.75).\n */\npublic Hashtable() {\n    this(11, 0.75f);\n}\n\n/**\n * Constructs an empty <tt>HashMap</tt> with the default initial capacity\n * (16) and the default load factor (0.75).\n */\npublic HashMap() {\n    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted\n}\n```\n\n当现有容量大于总容量 * 负载因子时，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 + 1。\n\n## 6、迭代器\n\nHashMap 中的 Iterator 迭代器是 fail-fast 的，而 Hashtable 的 Enumerator 不是 fail-fast 的。\n\n所以，当其他线程改变了HashMap 的结构，如：增加、删除元素，将会抛出 ConcurrentModificationException 异常，而 Hashtable 则不会。\n\n**可以来看下这个区别的演示：**\n\n```\n/**\n* \n**/\npublic static void main(String[] args) {\n    Map<String, String> hashtable = new Hashtable<>();\n    hashtable.put(\"t1\", \"1\");\n    hashtable.put(\"t2\", \"2\");\n    hashtable.put(\"t3\", \"3\");\n\n    Enumeration<Map.Entry<String, String>> iterator1 = (Enumeration<Map.Entry<String, String>>) hashtable.entrySet().iterator();\n    hashtable.remove(iterator1.nextElement().getKey());\n    while (iterator1.hasMoreElements()) {\n        System.out.println(iterator1.nextElement());\n    }\n\n    Map<String, String> hashMap = new HashMap<>();\n    hashMap.put(\"h1\", \"1\");\n    hashMap.put(\"h2\", \"2\");\n    hashMap.put(\"h3\", \"3\");\n\n    Iterator<Map.Entry<String, String>> iterator2 = hashMap.entrySet().iterator();\n    hashMap.remove(iterator2.next().getKey());\n    while (iterator2.hasNext()) {\n        System.out.println(iterator2.next());\n    }\n\n}\n```\n\n输出信息：\n\n```\nt2=2\nt1=1\nException in thread \"main\" java.util.ConcurrentModificationException\n\tat java.util.HashMap$HashIterator.nextNode(HashMap.java:1442)\n\tat java.util.HashMap$EntryIterator.next(HashMap.java:1476)\n\tat java.util.HashMap$EntryIterator.next(HashMap.java:1474)\n\tat cn.javastack.Test.main(Test.java:37)\n```\n\n看到了吧？\n\n所以，这条同样也是 Enumeration 和 Iterator 的区别。 \n\n最后一点有几个人知道？知道的给栈长点个赞回应一下，不知道的有收获的也点一个赞支持一下吧。\n\n有收获？转发给更多的人吧！\n\n","slug":"集合/HashMap 和 Hashtable 的 6 个区别","published":1,"updated":"2025-10-15T07:21:29.813Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu076z004rqkd4fpic9h04","content":"<p>HashMap 和 Hashtable 是 Java 开发程序员必须要掌握的，也是在各种 Java 面试场合中必须会问到的。</p>\n<p>但你对这两者的区别了解有多少呢？</p>\n<p>现在，栈长我给大家总结一下，或许有你不明朗的地方，在栈长的指点下都会拨开迷雾见晴天。</p>\n<h2 id=\"1、线程安全\"><a href=\"#1、线程安全\" class=\"headerlink\" title=\"1、线程安全\"></a>1、线程安全</h2><p>Hashtable 是线程安全的，HashMap 不是线程安全的。</p>\n<p>为什么说 HashTable 是线程安全的？</p>\n<p>来看下 Hashtable 的源码，Hashtable 所有的元素操作都是 synchronized 修饰的，而 HashMap 并没有。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public synchronized V put(K key, V value);\npublic synchronized V get(Object key);\n...<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"2、性能优劣\"><a href=\"#2、性能优劣\" class=\"headerlink\" title=\"2、性能优劣\"></a>2、性能优劣</h2><p>既然 Hashtable 是线程安全的，每个方法都要阻塞其他线程，所以 Hashtable 性能较差，HashMap 性能较好，使用更广。</p>\n<p>如果要线程安全又要保证性能，建议使用 JUC 包下的 ConcurrentHashMap。</p>\n<h2 id=\"3、NULL\"><a href=\"#3、NULL\" class=\"headerlink\" title=\"3、NULL\"></a>3、NULL</h2><p>Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。</p>\n<p>那么问题来了，为什么 Hashtable 是不允许 KEY 和 VALUE 为 null, 而 HashMap 则可以？</p>\n<p><strong>Hashtable put 方法逻辑：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"> public synchronized V put(K key, V value) &#123;\n        &#x2F;&#x2F; Make sure the value is not null\n        if (value &#x3D;&#x3D; null) &#123;\n            throw new NullPointerException();\n        &#125;\n\n        &#x2F;&#x2F; Makes sure the key is not already in the hashtable.\n        Entry&lt;?,?&gt; tab[] &#x3D; table;\n        int hash &#x3D; key.hashCode();\n        \n        ...\n    \n&#125;        <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>HashMap hash 方法逻辑：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">static final int hash(Object key) &#123;\n    int h;\n    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出 Hashtable key 为 null 会直接抛出空指针异常，value 为 null 手动抛出空指针异常，而 HashMap 的逻辑对 null 作了特殊处理。</p>\n<h2 id=\"4、实现方式\"><a href=\"#4、实现方式\" class=\"headerlink\" title=\"4、实现方式\"></a>4、实现方式</h2><p>Hashtable 的继承源码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Hashtable&lt;K,V&gt;\n    extends Dictionary&lt;K,V&gt;\n    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>HashMap 的继承源码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;\n    implements Map&lt;K,V&gt;, Cloneable, Serializable<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>可以看出两者继承的类不一样，Hashtable 继承了 Dictionary类，而 HashMap 继承的是 AbstractMap 类。</p>\n<p>Dictionary 是 JDK 1.0 添加的，貌似没人用过这个，栈长我也没用过。。</p>\n<h2 id=\"5、容量扩容\"><a href=\"#5、容量扩容\" class=\"headerlink\" title=\"5、容量扩容\"></a>5、容量扩容</h2><p>HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * Constructs a new, empty hashtable with a default initial capacity (11)\n * and load factor (0.75).\n *&#x2F;\npublic Hashtable() &#123;\n    this(11, 0.75f);\n&#125;\n\n&#x2F;**\n * Constructs an empty &lt;tt&gt;HashMap&lt;&#x2F;tt&gt; with the default initial capacity\n * (16) and the default load factor (0.75).\n *&#x2F;\npublic HashMap() &#123;\n    this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR; &#x2F;&#x2F; all other fields defaulted\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当现有容量大于总容量 * 负载因子时，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 + 1。</p>\n<h2 id=\"6、迭代器\"><a href=\"#6、迭代器\" class=\"headerlink\" title=\"6、迭代器\"></a>6、迭代器</h2><p>HashMap 中的 Iterator 迭代器是 fail-fast 的，而 Hashtable 的 Enumerator 不是 fail-fast 的。</p>\n<p>所以，当其他线程改变了HashMap 的结构，如：增加、删除元素，将会抛出 ConcurrentModificationException 异常，而 Hashtable 则不会。</p>\n<p><strong>可以来看下这个区别的演示：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n* \n**&#x2F;\npublic static void main(String[] args) &#123;\n    Map&lt;String, String&gt; hashtable &#x3D; new Hashtable&lt;&gt;();\n    hashtable.put(&quot;t1&quot;, &quot;1&quot;);\n    hashtable.put(&quot;t2&quot;, &quot;2&quot;);\n    hashtable.put(&quot;t3&quot;, &quot;3&quot;);\n\n    Enumeration&lt;Map.Entry&lt;String, String&gt;&gt; iterator1 &#x3D; (Enumeration&lt;Map.Entry&lt;String, String&gt;&gt;) hashtable.entrySet().iterator();\n    hashtable.remove(iterator1.nextElement().getKey());\n    while (iterator1.hasMoreElements()) &#123;\n        System.out.println(iterator1.nextElement());\n    &#125;\n\n    Map&lt;String, String&gt; hashMap &#x3D; new HashMap&lt;&gt;();\n    hashMap.put(&quot;h1&quot;, &quot;1&quot;);\n    hashMap.put(&quot;h2&quot;, &quot;2&quot;);\n    hashMap.put(&quot;h3&quot;, &quot;3&quot;);\n\n    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator2 &#x3D; hashMap.entrySet().iterator();\n    hashMap.remove(iterator2.next().getKey());\n    while (iterator2.hasNext()) &#123;\n        System.out.println(iterator2.next());\n    &#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出信息：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">t2&#x3D;2\nt1&#x3D;1\nException in thread &quot;main&quot; java.util.ConcurrentModificationException\n\tat java.util.HashMap$HashIterator.nextNode(HashMap.java:1442)\n\tat java.util.HashMap$EntryIterator.next(HashMap.java:1476)\n\tat java.util.HashMap$EntryIterator.next(HashMap.java:1474)\n\tat cn.javastack.Test.main(Test.java:37)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>看到了吧？</p>\n<p>所以，这条同样也是 Enumeration 和 Iterator 的区别。 </p>\n<p>最后一点有几个人知道？知道的给栈长点个赞回应一下，不知道的有收获的也点一个赞支持一下吧。</p>\n<p>有收获？转发给更多的人吧！</p>\n","excerpt":"","more":"<p>HashMap 和 Hashtable 是 Java 开发程序员必须要掌握的，也是在各种 Java 面试场合中必须会问到的。</p>\n<p>但你对这两者的区别了解有多少呢？</p>\n<p>现在，栈长我给大家总结一下，或许有你不明朗的地方，在栈长的指点下都会拨开迷雾见晴天。</p>\n<h2 id=\"1、线程安全\"><a href=\"#1、线程安全\" class=\"headerlink\" title=\"1、线程安全\"></a>1、线程安全</h2><p>Hashtable 是线程安全的，HashMap 不是线程安全的。</p>\n<p>为什么说 HashTable 是线程安全的？</p>\n<p>来看下 Hashtable 的源码，Hashtable 所有的元素操作都是 synchronized 修饰的，而 HashMap 并没有。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public synchronized V put(K key, V value);\npublic synchronized V get(Object key);\n...<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"2、性能优劣\"><a href=\"#2、性能优劣\" class=\"headerlink\" title=\"2、性能优劣\"></a>2、性能优劣</h2><p>既然 Hashtable 是线程安全的，每个方法都要阻塞其他线程，所以 Hashtable 性能较差，HashMap 性能较好，使用更广。</p>\n<p>如果要线程安全又要保证性能，建议使用 JUC 包下的 ConcurrentHashMap。</p>\n<h2 id=\"3、NULL\"><a href=\"#3、NULL\" class=\"headerlink\" title=\"3、NULL\"></a>3、NULL</h2><p>Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。</p>\n<p>那么问题来了，为什么 Hashtable 是不允许 KEY 和 VALUE 为 null, 而 HashMap 则可以？</p>\n<p><strong>Hashtable put 方法逻辑：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"> public synchronized V put(K key, V value) &#123;\n        &#x2F;&#x2F; Make sure the value is not null\n        if (value &#x3D;&#x3D; null) &#123;\n            throw new NullPointerException();\n        &#125;\n\n        &#x2F;&#x2F; Makes sure the key is not already in the hashtable.\n        Entry&lt;?,?&gt; tab[] &#x3D; table;\n        int hash &#x3D; key.hashCode();\n        \n        ...\n    \n&#125;        <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>HashMap hash 方法逻辑：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">static final int hash(Object key) &#123;\n    int h;\n    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出 Hashtable key 为 null 会直接抛出空指针异常，value 为 null 手动抛出空指针异常，而 HashMap 的逻辑对 null 作了特殊处理。</p>\n<h2 id=\"4、实现方式\"><a href=\"#4、实现方式\" class=\"headerlink\" title=\"4、实现方式\"></a>4、实现方式</h2><p>Hashtable 的继承源码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Hashtable&lt;K,V&gt;\n    extends Dictionary&lt;K,V&gt;\n    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>HashMap 的继承源码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;\n    implements Map&lt;K,V&gt;, Cloneable, Serializable<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>可以看出两者继承的类不一样，Hashtable 继承了 Dictionary类，而 HashMap 继承的是 AbstractMap 类。</p>\n<p>Dictionary 是 JDK 1.0 添加的，貌似没人用过这个，栈长我也没用过。。</p>\n<h2 id=\"5、容量扩容\"><a href=\"#5、容量扩容\" class=\"headerlink\" title=\"5、容量扩容\"></a>5、容量扩容</h2><p>HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * Constructs a new, empty hashtable with a default initial capacity (11)\n * and load factor (0.75).\n *&#x2F;\npublic Hashtable() &#123;\n    this(11, 0.75f);\n&#125;\n\n&#x2F;**\n * Constructs an empty &lt;tt&gt;HashMap&lt;&#x2F;tt&gt; with the default initial capacity\n * (16) and the default load factor (0.75).\n *&#x2F;\npublic HashMap() &#123;\n    this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR; &#x2F;&#x2F; all other fields defaulted\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当现有容量大于总容量 * 负载因子时，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 + 1。</p>\n<h2 id=\"6、迭代器\"><a href=\"#6、迭代器\" class=\"headerlink\" title=\"6、迭代器\"></a>6、迭代器</h2><p>HashMap 中的 Iterator 迭代器是 fail-fast 的，而 Hashtable 的 Enumerator 不是 fail-fast 的。</p>\n<p>所以，当其他线程改变了HashMap 的结构，如：增加、删除元素，将会抛出 ConcurrentModificationException 异常，而 Hashtable 则不会。</p>\n<p><strong>可以来看下这个区别的演示：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n* \n**&#x2F;\npublic static void main(String[] args) &#123;\n    Map&lt;String, String&gt; hashtable &#x3D; new Hashtable&lt;&gt;();\n    hashtable.put(&quot;t1&quot;, &quot;1&quot;);\n    hashtable.put(&quot;t2&quot;, &quot;2&quot;);\n    hashtable.put(&quot;t3&quot;, &quot;3&quot;);\n\n    Enumeration&lt;Map.Entry&lt;String, String&gt;&gt; iterator1 &#x3D; (Enumeration&lt;Map.Entry&lt;String, String&gt;&gt;) hashtable.entrySet().iterator();\n    hashtable.remove(iterator1.nextElement().getKey());\n    while (iterator1.hasMoreElements()) &#123;\n        System.out.println(iterator1.nextElement());\n    &#125;\n\n    Map&lt;String, String&gt; hashMap &#x3D; new HashMap&lt;&gt;();\n    hashMap.put(&quot;h1&quot;, &quot;1&quot;);\n    hashMap.put(&quot;h2&quot;, &quot;2&quot;);\n    hashMap.put(&quot;h3&quot;, &quot;3&quot;);\n\n    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator2 &#x3D; hashMap.entrySet().iterator();\n    hashMap.remove(iterator2.next().getKey());\n    while (iterator2.hasNext()) &#123;\n        System.out.println(iterator2.next());\n    &#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出信息：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">t2&#x3D;2\nt1&#x3D;1\nException in thread &quot;main&quot; java.util.ConcurrentModificationException\n\tat java.util.HashMap$HashIterator.nextNode(HashMap.java:1442)\n\tat java.util.HashMap$EntryIterator.next(HashMap.java:1476)\n\tat java.util.HashMap$EntryIterator.next(HashMap.java:1474)\n\tat cn.javastack.Test.main(Test.java:37)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>看到了吧？</p>\n<p>所以，这条同样也是 Enumeration 和 Iterator 的区别。 </p>\n<p>最后一点有几个人知道？知道的给栈长点个赞回应一下，不知道的有收获的也点一个赞支持一下吧。</p>\n<p>有收获？转发给更多的人吧！</p>\n"},{"title":"Hashtable 为什么不叫 HashTable？","date":"2025-10-15T03:36:33.000Z","_content":"\n> 什么是驼峰命名规则，来看下面的关键字：\n> \n> - HashMap\n> - ArrayList\n> - ConcurrentHashMap\n> \n> 简单来说就是，标识符的每个单词首字母必须大写，看起来像是驼峰的形状。\n\n当时就很好奇，Hashtable 为什么不是 HashTable 呢？作为一名初级的 Java 程序员都应该知道的基本的驼峰命名规则，为什么 JDK 代码里面还有这种不规范的命名呢？\n\n我想大家应该都比较好奇，我特意去查了下资料，没有查到官方的说法，不过在 stackoverflow 上看到了同样的这个问题。\n\n原贴如下：\n\n> https://stackoverflow.com/questions/12506706/why-is-the-t-in-hash-tablehashtable-in-java-not-capitalized\n\n![](http://qianniu.javastack.cn/18-12-6/56236009.jpg)\n\n最佳答案是：\n\n> Hashtable was created in Java v1. The consistent naming conventions for collections were established later, in Java2, when the other classes were published as part of the brand new Java Collection Framework.\n> \n> Which btw made Hashtable obsolete, so it should not be used in new code.\n> \n> Hope that helps.\n\n意思就是：\n\n> Hashtable 是在 Java 1.0 的时候创建的，而集合的统一规范命名是在后来的 Java 2 开始约定的，当时其他一部分集合类的发布构成了新的集合框架。\n> \n> 顺便说一下，这样就使得 Hashtable 过时了，所以不应该在新代码中继续使用它。\n\n栈长看了下，Hashtable 确实是 JDK1.0 添加的，最早的一个集合类，这样也说得过去。那为什么不在后面的 JDK 版本中修复它呢？可能是为了考虑兼容使用 JDK 老版本的系统吧。所以就将错就错封存在了 JDK，直到现在 JDK 11 了也还没有修复或者考虑删除它。\n\n另外，关于《[HashMap 和 Hashtable 的 6 个区别](https://mp.weixin.qq.com/s/EGqKMndXiJDIMeRQwxBd_w)》，有人留言说可以使用 currenthashtable。\n\n![](http://qianniu.javastack.cn/18-12-6/79250944.jpg)\n\n栈长又去证实了下，没有 currenthashtable 和 concurrenthashtable 这个类，所有 concurrent* 开头的并发类和接口都在这里了。\n\n![](http://qianniu.javastack.cn/18-12-6/49796932.jpg)\n\n好了，关于 Hashtable 的迷惑就此全都解开了。\n\n有收获？转发给更多的人吧！\n\n","source":"_posts/集合/Hashtable 为什么不叫 HashTable？.md","raw":"---\ntitle: Hashtable 为什么不叫 HashTable？\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 集合\n---\n\n> 什么是驼峰命名规则，来看下面的关键字：\n> \n> - HashMap\n> - ArrayList\n> - ConcurrentHashMap\n> \n> 简单来说就是，标识符的每个单词首字母必须大写，看起来像是驼峰的形状。\n\n当时就很好奇，Hashtable 为什么不是 HashTable 呢？作为一名初级的 Java 程序员都应该知道的基本的驼峰命名规则，为什么 JDK 代码里面还有这种不规范的命名呢？\n\n我想大家应该都比较好奇，我特意去查了下资料，没有查到官方的说法，不过在 stackoverflow 上看到了同样的这个问题。\n\n原贴如下：\n\n> https://stackoverflow.com/questions/12506706/why-is-the-t-in-hash-tablehashtable-in-java-not-capitalized\n\n![](http://qianniu.javastack.cn/18-12-6/56236009.jpg)\n\n最佳答案是：\n\n> Hashtable was created in Java v1. The consistent naming conventions for collections were established later, in Java2, when the other classes were published as part of the brand new Java Collection Framework.\n> \n> Which btw made Hashtable obsolete, so it should not be used in new code.\n> \n> Hope that helps.\n\n意思就是：\n\n> Hashtable 是在 Java 1.0 的时候创建的，而集合的统一规范命名是在后来的 Java 2 开始约定的，当时其他一部分集合类的发布构成了新的集合框架。\n> \n> 顺便说一下，这样就使得 Hashtable 过时了，所以不应该在新代码中继续使用它。\n\n栈长看了下，Hashtable 确实是 JDK1.0 添加的，最早的一个集合类，这样也说得过去。那为什么不在后面的 JDK 版本中修复它呢？可能是为了考虑兼容使用 JDK 老版本的系统吧。所以就将错就错封存在了 JDK，直到现在 JDK 11 了也还没有修复或者考虑删除它。\n\n另外，关于《[HashMap 和 Hashtable 的 6 个区别](https://mp.weixin.qq.com/s/EGqKMndXiJDIMeRQwxBd_w)》，有人留言说可以使用 currenthashtable。\n\n![](http://qianniu.javastack.cn/18-12-6/79250944.jpg)\n\n栈长又去证实了下，没有 currenthashtable 和 concurrenthashtable 这个类，所有 concurrent* 开头的并发类和接口都在这里了。\n\n![](http://qianniu.javastack.cn/18-12-6/49796932.jpg)\n\n好了，关于 Hashtable 的迷惑就此全都解开了。\n\n有收获？转发给更多的人吧！\n\n","slug":"集合/Hashtable 为什么不叫 HashTable？","published":1,"updated":"2025-10-15T07:21:29.809Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu0770004uqkd4eb9b9k23","content":"<blockquote>\n<p>什么是驼峰命名规则，来看下面的关键字：</p>\n<ul>\n<li>HashMap</li>\n<li>ArrayList</li>\n<li>ConcurrentHashMap</li>\n</ul>\n<p>简单来说就是，标识符的每个单词首字母必须大写，看起来像是驼峰的形状。</p>\n</blockquote>\n<p>当时就很好奇，Hashtable 为什么不是 HashTable 呢？作为一名初级的 Java 程序员都应该知道的基本的驼峰命名规则，为什么 JDK 代码里面还有这种不规范的命名呢？</p>\n<p>我想大家应该都比较好奇，我特意去查了下资料，没有查到官方的说法，不过在 stackoverflow 上看到了同样的这个问题。</p>\n<p>原贴如下：</p>\n<blockquote>\n<p><a href=\"https://stackoverflow.com/questions/12506706/why-is-the-t-in-hash-tablehashtable-in-java-not-capitalized\">https://stackoverflow.com/questions/12506706/why-is-the-t-in-hash-tablehashtable-in-java-not-capitalized</a></p>\n</blockquote>\n<p><img src=\"http://qianniu.javastack.cn/18-12-6/56236009.jpg\"></p>\n<p>最佳答案是：</p>\n<blockquote>\n<p>Hashtable was created in Java v1. The consistent naming conventions for collections were established later, in Java2, when the other classes were published as part of the brand new Java Collection Framework.</p>\n<p>Which btw made Hashtable obsolete, so it should not be used in new code.</p>\n<p>Hope that helps.</p>\n</blockquote>\n<p>意思就是：</p>\n<blockquote>\n<p>Hashtable 是在 Java 1.0 的时候创建的，而集合的统一规范命名是在后来的 Java 2 开始约定的，当时其他一部分集合类的发布构成了新的集合框架。</p>\n<p>顺便说一下，这样就使得 Hashtable 过时了，所以不应该在新代码中继续使用它。</p>\n</blockquote>\n<p>栈长看了下，Hashtable 确实是 JDK1.0 添加的，最早的一个集合类，这样也说得过去。那为什么不在后面的 JDK 版本中修复它呢？可能是为了考虑兼容使用 JDK 老版本的系统吧。所以就将错就错封存在了 JDK，直到现在 JDK 11 了也还没有修复或者考虑删除它。</p>\n<p>另外，关于《<a href=\"https://mp.weixin.qq.com/s/EGqKMndXiJDIMeRQwxBd_w\">HashMap 和 Hashtable 的 6 个区别</a>》，有人留言说可以使用 currenthashtable。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-12-6/79250944.jpg\"></p>\n<p>栈长又去证实了下，没有 currenthashtable 和 concurrenthashtable 这个类，所有 concurrent* 开头的并发类和接口都在这里了。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-12-6/49796932.jpg\"></p>\n<p>好了，关于 Hashtable 的迷惑就此全都解开了。</p>\n<p>有收获？转发给更多的人吧！</p>\n","excerpt":"","more":"<blockquote>\n<p>什么是驼峰命名规则，来看下面的关键字：</p>\n<ul>\n<li>HashMap</li>\n<li>ArrayList</li>\n<li>ConcurrentHashMap</li>\n</ul>\n<p>简单来说就是，标识符的每个单词首字母必须大写，看起来像是驼峰的形状。</p>\n</blockquote>\n<p>当时就很好奇，Hashtable 为什么不是 HashTable 呢？作为一名初级的 Java 程序员都应该知道的基本的驼峰命名规则，为什么 JDK 代码里面还有这种不规范的命名呢？</p>\n<p>我想大家应该都比较好奇，我特意去查了下资料，没有查到官方的说法，不过在 stackoverflow 上看到了同样的这个问题。</p>\n<p>原贴如下：</p>\n<blockquote>\n<p><a href=\"https://stackoverflow.com/questions/12506706/why-is-the-t-in-hash-tablehashtable-in-java-not-capitalized\">https://stackoverflow.com/questions/12506706/why-is-the-t-in-hash-tablehashtable-in-java-not-capitalized</a></p>\n</blockquote>\n<p><img src=\"http://qianniu.javastack.cn/18-12-6/56236009.jpg\"></p>\n<p>最佳答案是：</p>\n<blockquote>\n<p>Hashtable was created in Java v1. The consistent naming conventions for collections were established later, in Java2, when the other classes were published as part of the brand new Java Collection Framework.</p>\n<p>Which btw made Hashtable obsolete, so it should not be used in new code.</p>\n<p>Hope that helps.</p>\n</blockquote>\n<p>意思就是：</p>\n<blockquote>\n<p>Hashtable 是在 Java 1.0 的时候创建的，而集合的统一规范命名是在后来的 Java 2 开始约定的，当时其他一部分集合类的发布构成了新的集合框架。</p>\n<p>顺便说一下，这样就使得 Hashtable 过时了，所以不应该在新代码中继续使用它。</p>\n</blockquote>\n<p>栈长看了下，Hashtable 确实是 JDK1.0 添加的，最早的一个集合类，这样也说得过去。那为什么不在后面的 JDK 版本中修复它呢？可能是为了考虑兼容使用 JDK 老版本的系统吧。所以就将错就错封存在了 JDK，直到现在 JDK 11 了也还没有修复或者考虑删除它。</p>\n<p>另外，关于《<a href=\"https://mp.weixin.qq.com/s/EGqKMndXiJDIMeRQwxBd_w\">HashMap 和 Hashtable 的 6 个区别</a>》，有人留言说可以使用 currenthashtable。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-12-6/79250944.jpg\"></p>\n<p>栈长又去证实了下，没有 currenthashtable 和 concurrenthashtable 这个类，所有 concurrent* 开头的并发类和接口都在这里了。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-12-6/49796932.jpg\"></p>\n<p>好了，关于 Hashtable 的迷惑就此全都解开了。</p>\n<p>有收获？转发给更多的人吧！</p>\n"},{"title":"Java 中初始化 List 集合的 6 种方式!","date":"2025-10-15T03:36:33.000Z","_content":"\nList 是 Java 开发中经常会使用的集合，你们知道有哪些方式可以初始化一个 List 吗？这其中不缺乏一些坑，今天栈长我给大家一一普及一下。\n\n## 1、常规方式\n\n```\nList<String> languages = new ArrayList<>();\nlanguages.add(\"Java\");\nlanguages.add(\"PHP\");\nlanguages.add(\"Python\");\nSystem.out.println(languages);\n```\n\n这种就是我们平常用的最多最平常的方式了，没什么好说的，后面缺失的泛型类型在 JDK 7 之后就可以不用写具体的类型了，改进后会自动推断类型。\n\n## 2、Arrays 工具类\n\n```\nList<String> jdks = asList(\"JDK6\", \"JDK8\", \"JDK10\");\nSystem.out.println(jdks);\n```\n\n注意，上面的 asList 是 Arrays 的静态方法，这里使用了静态导入。这种方式添加的是不可变的 List, 即不能添加、删除等操作，需要警惕。。\n\n> import static java.util.Arrays.asList;\n\n如果要可变，那就使用 ArrayList 再包装一下，如下面所示。\n\n```\nList<String> numbers = new ArrayList<>(Arrays.asList(\"1\", \"2\", \"3\"));\nnumbers.add(\"4\");\nSystem.out.println(numbers);\n```\n\n包装一下，这就是可变的 ArrayList 了。\n\n## 3、Collections 工具类\n\n```\nList<String> apples = Collections.nCopies(3, \"apple\");\nSystem.out.println(apples);\n```\n\n这种方式添加的是不可变的、复制某个元素N遍的工具类，以上程序输出：\n\n```\n[apple, apple, apple]\n```\n\n老规则，如果要可变，使用 ArrayList 包装一遍。\n\n```\nList<String> dogs = new ArrayList<>(Collections.nCopies(3, \"dog\"));\ndogs.add(\"dog\");\nSystem.out.println(dogs);\n```\n\n还有初始化单个对象的 List 工具类，这种方式也是不可变的，集合内只能有一个元素，这种也用得很少啊。\n\n```\nList<String> cat = Collections.singletonList(\"cat\");\nSystem.out.println(cat);\n```\n\n还有一个创建空 List 的工具类，没有默认容量，节省空间，但不知道实际工作中有什么鸟用。\n\n```\nList<String> cat = Collections.emptyList(\"cat\");\n```\n\n## 4、匿名内部类\n\n```\nList<String> names = new ArrayList<>() {{\n    add(\"Tom\");\n    add(\"Sally\");\n    add(\"John\");\n}};\nSystem.out.println(names);\n```\n\n这种使用了匿名内部类的方式，一气喝成，是不是很高大上？栈长我曾经也使用过这种方式，不过我觉得这种看似高级，实现也没什么卵用。\n\n## 5、JDK8 Stream\n\n```\nList<String> colors = Stream.of(\"blue\", \"red\", \"yellow\").collect(toList());\nSystem.out.println(colors);\n```\n\nStream 是 JDK 8 推出来的新概念，比集合还要更强大，还可以和集合互相转换。\n\n上面同样使用了静态导入：\n\n> import static java.util.stream.Collectors.toList;\n\n\n\n## 6、JDK 9 List.of\n\n```\nList<String> cups = List.of(\"A\", \"B\", \"C\");\nSystem.out.println(cups);\n```\n\n这是 JDK 9 里面新增的 List 接口里面的静态方法，同样也是不可变的。\n\n在接口中实现静态方法和默认方法是 JDK 8 中添加的新特性，具体看这篇文章《[JDK 8 新特性之接口默认方法与静态方法\n](https://mp.weixin.qq.com/s/_V6oyDle4PrpzL65x_8K5w)》。\n\n好了，今天栈长就给大家介绍到这里了，这 6 种，你知道几种？另外，Map, Set 也有类似的初始化的方法，大家有兴趣的可以试一下。\n\n你还知道哪些绝招呢？欢迎留言分享一下。。。\n\n","source":"_posts/集合/Java 中初始化 List 集合的 6 种方式!.md","raw":"---\ntitle: Java 中初始化 List 集合的 6 种方式!\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 集合\n---\n\nList 是 Java 开发中经常会使用的集合，你们知道有哪些方式可以初始化一个 List 吗？这其中不缺乏一些坑，今天栈长我给大家一一普及一下。\n\n## 1、常规方式\n\n```\nList<String> languages = new ArrayList<>();\nlanguages.add(\"Java\");\nlanguages.add(\"PHP\");\nlanguages.add(\"Python\");\nSystem.out.println(languages);\n```\n\n这种就是我们平常用的最多最平常的方式了，没什么好说的，后面缺失的泛型类型在 JDK 7 之后就可以不用写具体的类型了，改进后会自动推断类型。\n\n## 2、Arrays 工具类\n\n```\nList<String> jdks = asList(\"JDK6\", \"JDK8\", \"JDK10\");\nSystem.out.println(jdks);\n```\n\n注意，上面的 asList 是 Arrays 的静态方法，这里使用了静态导入。这种方式添加的是不可变的 List, 即不能添加、删除等操作，需要警惕。。\n\n> import static java.util.Arrays.asList;\n\n如果要可变，那就使用 ArrayList 再包装一下，如下面所示。\n\n```\nList<String> numbers = new ArrayList<>(Arrays.asList(\"1\", \"2\", \"3\"));\nnumbers.add(\"4\");\nSystem.out.println(numbers);\n```\n\n包装一下，这就是可变的 ArrayList 了。\n\n## 3、Collections 工具类\n\n```\nList<String> apples = Collections.nCopies(3, \"apple\");\nSystem.out.println(apples);\n```\n\n这种方式添加的是不可变的、复制某个元素N遍的工具类，以上程序输出：\n\n```\n[apple, apple, apple]\n```\n\n老规则，如果要可变，使用 ArrayList 包装一遍。\n\n```\nList<String> dogs = new ArrayList<>(Collections.nCopies(3, \"dog\"));\ndogs.add(\"dog\");\nSystem.out.println(dogs);\n```\n\n还有初始化单个对象的 List 工具类，这种方式也是不可变的，集合内只能有一个元素，这种也用得很少啊。\n\n```\nList<String> cat = Collections.singletonList(\"cat\");\nSystem.out.println(cat);\n```\n\n还有一个创建空 List 的工具类，没有默认容量，节省空间，但不知道实际工作中有什么鸟用。\n\n```\nList<String> cat = Collections.emptyList(\"cat\");\n```\n\n## 4、匿名内部类\n\n```\nList<String> names = new ArrayList<>() {{\n    add(\"Tom\");\n    add(\"Sally\");\n    add(\"John\");\n}};\nSystem.out.println(names);\n```\n\n这种使用了匿名内部类的方式，一气喝成，是不是很高大上？栈长我曾经也使用过这种方式，不过我觉得这种看似高级，实现也没什么卵用。\n\n## 5、JDK8 Stream\n\n```\nList<String> colors = Stream.of(\"blue\", \"red\", \"yellow\").collect(toList());\nSystem.out.println(colors);\n```\n\nStream 是 JDK 8 推出来的新概念，比集合还要更强大，还可以和集合互相转换。\n\n上面同样使用了静态导入：\n\n> import static java.util.stream.Collectors.toList;\n\n\n\n## 6、JDK 9 List.of\n\n```\nList<String> cups = List.of(\"A\", \"B\", \"C\");\nSystem.out.println(cups);\n```\n\n这是 JDK 9 里面新增的 List 接口里面的静态方法，同样也是不可变的。\n\n在接口中实现静态方法和默认方法是 JDK 8 中添加的新特性，具体看这篇文章《[JDK 8 新特性之接口默认方法与静态方法\n](https://mp.weixin.qq.com/s/_V6oyDle4PrpzL65x_8K5w)》。\n\n好了，今天栈长就给大家介绍到这里了，这 6 种，你知道几种？另外，Map, Set 也有类似的初始化的方法，大家有兴趣的可以试一下。\n\n你还知道哪些绝招呢？欢迎留言分享一下。。。\n\n","slug":"集合/Java 中初始化 List 集合的 6 种方式!","published":1,"updated":"2025-10-15T07:21:29.764Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu0770004yqkd4gdt57lbu","content":"<p>List 是 Java 开发中经常会使用的集合，你们知道有哪些方式可以初始化一个 List 吗？这其中不缺乏一些坑，今天栈长我给大家一一普及一下。</p>\n<h2 id=\"1、常规方式\"><a href=\"#1、常规方式\" class=\"headerlink\" title=\"1、常规方式\"></a>1、常规方式</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; languages &#x3D; new ArrayList&lt;&gt;();\nlanguages.add(&quot;Java&quot;);\nlanguages.add(&quot;PHP&quot;);\nlanguages.add(&quot;Python&quot;);\nSystem.out.println(languages);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这种就是我们平常用的最多最平常的方式了，没什么好说的，后面缺失的泛型类型在 JDK 7 之后就可以不用写具体的类型了，改进后会自动推断类型。</p>\n<h2 id=\"2、Arrays-工具类\"><a href=\"#2、Arrays-工具类\" class=\"headerlink\" title=\"2、Arrays 工具类\"></a>2、Arrays 工具类</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; jdks &#x3D; asList(&quot;JDK6&quot;, &quot;JDK8&quot;, &quot;JDK10&quot;);\nSystem.out.println(jdks);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>注意，上面的 asList 是 Arrays 的静态方法，这里使用了静态导入。这种方式添加的是不可变的 List, 即不能添加、删除等操作，需要警惕。。</p>\n<blockquote>\n<p>import static java.util.Arrays.asList;</p>\n</blockquote>\n<p>如果要可变，那就使用 ArrayList 再包装一下，如下面所示。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; numbers &#x3D; new ArrayList&lt;&gt;(Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;));\nnumbers.add(&quot;4&quot;);\nSystem.out.println(numbers);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>包装一下，这就是可变的 ArrayList 了。</p>\n<h2 id=\"3、Collections-工具类\"><a href=\"#3、Collections-工具类\" class=\"headerlink\" title=\"3、Collections 工具类\"></a>3、Collections 工具类</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; apples &#x3D; Collections.nCopies(3, &quot;apple&quot;);\nSystem.out.println(apples);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>这种方式添加的是不可变的、复制某个元素N遍的工具类，以上程序输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">[apple, apple, apple]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>老规则，如果要可变，使用 ArrayList 包装一遍。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; dogs &#x3D; new ArrayList&lt;&gt;(Collections.nCopies(3, &quot;dog&quot;));\ndogs.add(&quot;dog&quot;);\nSystem.out.println(dogs);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>还有初始化单个对象的 List 工具类，这种方式也是不可变的，集合内只能有一个元素，这种也用得很少啊。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; cat &#x3D; Collections.singletonList(&quot;cat&quot;);\nSystem.out.println(cat);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>还有一个创建空 List 的工具类，没有默认容量，节省空间，但不知道实际工作中有什么鸟用。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; cat &#x3D; Collections.emptyList(&quot;cat&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"4、匿名内部类\"><a href=\"#4、匿名内部类\" class=\"headerlink\" title=\"4、匿名内部类\"></a>4、匿名内部类</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;() &#123;&#123;\n    add(&quot;Tom&quot;);\n    add(&quot;Sally&quot;);\n    add(&quot;John&quot;);\n&#125;&#125;;\nSystem.out.println(names);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这种使用了匿名内部类的方式，一气喝成，是不是很高大上？栈长我曾经也使用过这种方式，不过我觉得这种看似高级，实现也没什么卵用。</p>\n<h2 id=\"5、JDK8-Stream\"><a href=\"#5、JDK8-Stream\" class=\"headerlink\" title=\"5、JDK8 Stream\"></a>5、JDK8 Stream</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; colors &#x3D; Stream.of(&quot;blue&quot;, &quot;red&quot;, &quot;yellow&quot;).collect(toList());\nSystem.out.println(colors);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>Stream 是 JDK 8 推出来的新概念，比集合还要更强大，还可以和集合互相转换。</p>\n<p>上面同样使用了静态导入：</p>\n<blockquote>\n<p>import static java.util.stream.Collectors.toList;</p>\n</blockquote>\n<h2 id=\"6、JDK-9-List-of\"><a href=\"#6、JDK-9-List-of\" class=\"headerlink\" title=\"6、JDK 9 List.of\"></a>6、JDK 9 List.of</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; cups &#x3D; List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);\nSystem.out.println(cups);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>这是 JDK 9 里面新增的 List 接口里面的静态方法，同样也是不可变的。</p>\n<p>在接口中实现静态方法和默认方法是 JDK 8 中添加的新特性，具体看这篇文章《<a href=\"https://mp.weixin.qq.com/s/_V6oyDle4PrpzL65x_8K5w\">JDK 8 新特性之接口默认方法与静态方法\n</a>》。</p>\n<p>好了，今天栈长就给大家介绍到这里了，这 6 种，你知道几种？另外，Map, Set 也有类似的初始化的方法，大家有兴趣的可以试一下。</p>\n<p>你还知道哪些绝招呢？欢迎留言分享一下。。。</p>\n","excerpt":"","more":"<p>List 是 Java 开发中经常会使用的集合，你们知道有哪些方式可以初始化一个 List 吗？这其中不缺乏一些坑，今天栈长我给大家一一普及一下。</p>\n<h2 id=\"1、常规方式\"><a href=\"#1、常规方式\" class=\"headerlink\" title=\"1、常规方式\"></a>1、常规方式</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; languages &#x3D; new ArrayList&lt;&gt;();\nlanguages.add(&quot;Java&quot;);\nlanguages.add(&quot;PHP&quot;);\nlanguages.add(&quot;Python&quot;);\nSystem.out.println(languages);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这种就是我们平常用的最多最平常的方式了，没什么好说的，后面缺失的泛型类型在 JDK 7 之后就可以不用写具体的类型了，改进后会自动推断类型。</p>\n<h2 id=\"2、Arrays-工具类\"><a href=\"#2、Arrays-工具类\" class=\"headerlink\" title=\"2、Arrays 工具类\"></a>2、Arrays 工具类</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; jdks &#x3D; asList(&quot;JDK6&quot;, &quot;JDK8&quot;, &quot;JDK10&quot;);\nSystem.out.println(jdks);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>注意，上面的 asList 是 Arrays 的静态方法，这里使用了静态导入。这种方式添加的是不可变的 List, 即不能添加、删除等操作，需要警惕。。</p>\n<blockquote>\n<p>import static java.util.Arrays.asList;</p>\n</blockquote>\n<p>如果要可变，那就使用 ArrayList 再包装一下，如下面所示。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; numbers &#x3D; new ArrayList&lt;&gt;(Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;));\nnumbers.add(&quot;4&quot;);\nSystem.out.println(numbers);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>包装一下，这就是可变的 ArrayList 了。</p>\n<h2 id=\"3、Collections-工具类\"><a href=\"#3、Collections-工具类\" class=\"headerlink\" title=\"3、Collections 工具类\"></a>3、Collections 工具类</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; apples &#x3D; Collections.nCopies(3, &quot;apple&quot;);\nSystem.out.println(apples);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>这种方式添加的是不可变的、复制某个元素N遍的工具类，以上程序输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">[apple, apple, apple]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>老规则，如果要可变，使用 ArrayList 包装一遍。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; dogs &#x3D; new ArrayList&lt;&gt;(Collections.nCopies(3, &quot;dog&quot;));\ndogs.add(&quot;dog&quot;);\nSystem.out.println(dogs);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>还有初始化单个对象的 List 工具类，这种方式也是不可变的，集合内只能有一个元素，这种也用得很少啊。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; cat &#x3D; Collections.singletonList(&quot;cat&quot;);\nSystem.out.println(cat);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>还有一个创建空 List 的工具类，没有默认容量，节省空间，但不知道实际工作中有什么鸟用。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; cat &#x3D; Collections.emptyList(&quot;cat&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"4、匿名内部类\"><a href=\"#4、匿名内部类\" class=\"headerlink\" title=\"4、匿名内部类\"></a>4、匿名内部类</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;() &#123;&#123;\n    add(&quot;Tom&quot;);\n    add(&quot;Sally&quot;);\n    add(&quot;John&quot;);\n&#125;&#125;;\nSystem.out.println(names);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这种使用了匿名内部类的方式，一气喝成，是不是很高大上？栈长我曾经也使用过这种方式，不过我觉得这种看似高级，实现也没什么卵用。</p>\n<h2 id=\"5、JDK8-Stream\"><a href=\"#5、JDK8-Stream\" class=\"headerlink\" title=\"5、JDK8 Stream\"></a>5、JDK8 Stream</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; colors &#x3D; Stream.of(&quot;blue&quot;, &quot;red&quot;, &quot;yellow&quot;).collect(toList());\nSystem.out.println(colors);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>Stream 是 JDK 8 推出来的新概念，比集合还要更强大，还可以和集合互相转换。</p>\n<p>上面同样使用了静态导入：</p>\n<blockquote>\n<p>import static java.util.stream.Collectors.toList;</p>\n</blockquote>\n<h2 id=\"6、JDK-9-List-of\"><a href=\"#6、JDK-9-List-of\" class=\"headerlink\" title=\"6、JDK 9 List.of\"></a>6、JDK 9 List.of</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; cups &#x3D; List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);\nSystem.out.println(cups);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>这是 JDK 9 里面新增的 List 接口里面的静态方法，同样也是不可变的。</p>\n<p>在接口中实现静态方法和默认方法是 JDK 8 中添加的新特性，具体看这篇文章《<a href=\"https://mp.weixin.qq.com/s/_V6oyDle4PrpzL65x_8K5w\">JDK 8 新特性之接口默认方法与静态方法\n</a>》。</p>\n<p>好了，今天栈长就给大家介绍到这里了，这 6 种，你知道几种？另外，Map, Set 也有类似的初始化的方法，大家有兴趣的可以试一下。</p>\n<p>你还知道哪些绝招呢？欢迎留言分享一下。。。</p>\n"},{"title":"HashMap, ConcurrentHashMap 原理及源码","date":"2025-10-15T03:36:33.000Z","_content":"\n\n网上关于 HashMap 和 ConcurrentHashMap 的文章确实不少，不过缺斤少两的文章比较多，所以才想自己也写一篇，把细节说清楚说透，尤其像 Java8 中的 ConcurrentHashMap，大部分文章都说不清楚。终归是希望能降低大家学习的成本，不希望大家到处找各种不是很靠谱的文章，看完一篇又一篇，可是还是模模糊糊。\n\n**阅读建议：** 四节基本上可以进行独立阅读，建议初学者可按照以下顺序进行阅读，可适当降低阅读门槛。\n\n> Java7 HashMap -> Java7 ConcurrentHashMap -> Java8 HashMap -> Java8 ConcurrentHashMap \n\n**阅读前提：** 本文分析的是源码，所以至少读者要熟悉它们的接口使用，同时，对于并发，读者至少要知道 CAS、ReentrantLock、UNSAFE 操作这几个基本的知识，文中不会对这些知识进行介绍。Java8 用到了红黑树，不过本文不会进行展开，感兴趣的读者请自行查找相关资料。\n\n## Java7 HashMap\n\nHashMap 是最简单的，一来我们非常熟悉，二来就是它不支持并发操作，所以源码也非常简单。\n\n首先，我们用下面这张图来介绍 HashMap 的结构。\n\n![](http://qianniu.javastack.cn/18-12-4/65827660.jpg)\n\n这个仅仅是示意图，因为没有考虑到数组要扩容的情况，具体的后面再说。\n\n大方向上，HashMap 里面是一个**数组**，然后数组中每个元素是一个**单向链表**。\n\n上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。\n\ncapacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。\n\nloadFactor：负载因子，默认为 0.75。\n\nthreshold：扩容的阈值，等于 capacity * loadFactor\n\n#### put 过程分析\n\n还是比较简单的，跟着代码走一遍吧。\n\n```\npublic V put(K key, V value) {\n    // 当插入第一个元素的时候，需要先初始化数组大小\n    if (table == EMPTY_TABLE) {\n        inflateTable(threshold);\n    }\n    // 如果 key 为 null，感兴趣的可以往里看，最终会将这个 entry 放到 table[0] 中\n    if (key == null)\n        return putForNullKey(value);\n    // 1. 求 key 的 hash 值\n    int hash = hash(key);\n    // 2. 找到对应的数组下标\n    int i = indexFor(hash, table.length);\n    // 3. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在，\n    //    如果有，直接覆盖，put 方法返回旧值就结束了\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n \n    modCount++;\n    // 4. 不存在重复的 key，将此 entry 添加到链表中，细节后面说\n    addEntry(hash, key, value, i);\n    return null;\n}\n```\n\n###### 数组初始化\n\n在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值。\n\n```\nprivate void inflateTable(int toSize) {\n    // 保证数组大小一定是 2 的 n 次方。\n    // 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32\n    int capacity = roundUpToPowerOf2(toSize);\n    // 计算扩容阈值：capacity * loadFactor\n    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);\n    // 算是初始化数组吧\n    table = new Entry[capacity];\n    initHashSeedAsNeeded(capacity); //ignore\n}\n```\n\n这里有一个将数组大小保持为 2 的 n 次方的做法，Java7 和 Java8 的 HashMap 和 ConcurrentHashMap 都有相应的要求，只不过实现的代码稍微有些不同，后面再看到的时候就知道了。\n\n###### 计算具体数组位置\n\n这个简单，我们自己也能 YY 一个：使用 key 的 hash 值对数组长度进行取模就可以了。\n\n```\nstatic int indexFor(int hash, int length) {\n    // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\";\n    return hash & (length-1);\n}\n```\n\n这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。\n\n###### 添加节点到链表中\n\n找到数组下标后，会先进行 key 判重，如果没有重复，就准备将新值放入到链表的表头。\n\n```\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    // 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容\n    if ((size >= threshold) && (null != table[bucketIndex])) {\n        // 扩容，后面会介绍一下\n        resize(2 * table.length);\n        // 扩容以后，重新计算 hash 值\n        hash = (null != key) ? hash(key) : 0;\n        // 重新计算扩容后的新的下标\n        bucketIndex = indexFor(hash, table.length);\n    }\n    // 往下看\n    createEntry(hash, key, value, bucketIndex);\n}\n\n// 这个很简单，其实就是将新值放到链表的表头，然后 size++\nvoid createEntry(int hash, K key, V value, int bucketIndex) {\n    Entry<K,V> e = table[bucketIndex];\n    table[bucketIndex] = new Entry<>(hash, key, value, e);\n    size++;\n}\n```\n\n这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。\n\n###### 数组扩容\n\n前面我们看到，在插入新值的时候，如果当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。\n\n```\nvoid resize(int newCapacity) {\n    Entry[] oldTable = table;\n    int oldCapacity = oldTable.length;\n    if (oldCapacity == MAXIMUM_CAPACITY) {\n        threshold = Integer.MAX_VALUE;\n        return;\n    }\n    // 新的数组\n    Entry[] newTable = new Entry[newCapacity];\n    // 将原来数组中的值迁移到新的更大的数组中\n    transfer(newTable, initHashSeedAsNeeded(newCapacity));\n    table = newTable;\n    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n}\n```\n\n扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。\n\n由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。代码比较简单，这里就不展开了。\n\n#### get 过程分析\n\n相对于 put 过程，get 过程是非常简单的。\n\n1. 根据 key 计算 hash 值。\n2. 找到相应的数组下标：hash & (length – 1)。\n3. 遍历该数组位置处的链表，直到找到相等(==或equals)的 key。\n\n```\npublic V get(Object key) {\n    // 之前说过，key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了\n    if (key == null)\n        return getForNullKey();\n    // \n    Entry<K,V> entry = getEntry(key);\n \n    return null == entry ? null : entry.getValue();\n}\n```\n\ngetEntry(key):\n\n```\nfinal Entry<K,V> getEntry(Object key) {\n    if (size == 0) {\n        return null;\n    }\n \n    int hash = (key == null) ? 0 : hash(key);\n    // 确定数组下标，然后从头开始遍历链表，直到找到为止\n    for (Entry<K,V> e = table[indexFor(hash, table.length)];\n         e != null;\n         e = e.next) {\n        Object k;\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k))))\n            return e;\n    }\n    return null;\n}\n```\n\n## Java7 ConcurrentHashMap\n\nConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。\n\n整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为**分段锁**。注意，行文中，我很多地方用了 **“槽”** 来代表一个 segment。\n\n简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。推荐阅读：[史上最全 Java 多线程面试题及答案](https://mp.weixin.qq.com/s/0CI9od4DIxRrmOGFJw0SuQ)。\n\n![](http://qianniu.javastack.cn/18-12-4/75121838.jpg)\n\n**concurrencyLevel：** 并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。\n\n再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。推荐阅读：[几种线程安全的Map解析](https://mp.weixin.qq.com/s/5Y5_6qn2g6kIVmQia_0R6g)。\n\n#### 初始化\n\ninitialCapacity：初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。\n\nloadFactor：负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。\n\n```\npublic ConcurrentHashMap(int initialCapacity,\n                         float loadFactor, int concurrencyLevel) {\n    if (!(loadFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0)\n        throw new IllegalArgumentException();\n    if (concurrencyLevel > MAX_SEGMENTS)\n        concurrencyLevel = MAX_SEGMENTS;\n    // Find power-of-two sizes best matching arguments\n    int sshift = 0;\n    int ssize = 1;\n    // 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方\n    while (ssize < concurrencyLevel) {\n        ++sshift;\n        ssize <<= 1;\n    }\n    // 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4\n    // 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值\n    this.segmentShift = 32 - sshift;\n    this.segmentMask = ssize - 1;\n \n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n \n    // initialCapacity 是设置整个 map 初始的大小，\n    // 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小\n    // 如 initialCapacity 为 64，那么每个 Segment 或称之为\"槽\"可以分到 4 个\n    int c = initialCapacity / ssize;\n    if (c * ssize < initialCapacity)\n        ++c;\n    // 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，\n    // 插入一个元素不至于扩容，插入第二个的时候才会扩容\n    int cap = MIN_SEGMENT_TABLE_CAPACITY; \n    while (cap < c)\n        cap <<= 1;\n \n    // 创建 Segment 数组，\n    // 并创建数组的第一个元素 segment[0]\n    Segment<K,V> s0 =\n        new Segment<K,V>(loadFactor, (int)(cap * loadFactor),\n                         (HashEntry<K,V>[])new HashEntry[cap]);\n    Segment<K,V>[] ss = (Segment<K,V>[])new Segment[ssize];\n    // 往数组写入 segment[0]\n    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]\n    this.segments = ss;\n}\n```\n\n初始化完成，我们得到了一个 Segment 数组。\n\n我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后：\n\n- Segment 数组长度为 16，不可以扩容\n- Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容\n- 这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍\n- 当前 segmentShift 的值为 32 – 4 = 28，segmentMask 为 16 – 1 = 15，姑且把它们简单翻译为移位数和掩码，这两个值马上就会用到。\n\n#### put 过程分析\n\n我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。\n\n```\npublic V put(K key, V value) {\n    Segment<K,V> s;\n    if (value == null)\n        throw new NullPointerException();\n    // 1. 计算 key 的 hash 值\n    int hash = hash(key);\n    // 2. 根据 hash 值找到 Segment 数组中的位置 j\n    //    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下低 4 位，\n    //    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的最后 4 位，也就是槽的数组下标\n    int j = (hash >>> segmentShift) & segmentMask;\n    // 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，\n    // ensureSegment(j) 对 segment[j] 进行初始化\n    if ((s = (Segment<K,V>)UNSAFE.getObject          // nonvolatile; recheck\n         (segments, (j << SSHIFT) + SBASE)) == null) //  in ensureSegment\n        s = ensureSegment(j);\n    // 3. 插入新值到 槽 s 中\n    return s.put(key, hash, value, false);\n}\n```\n\n第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。\n\nSegment 内部是由 **数组+链表** 组成的。\n\n```\nfinal V put(K key, int hash, V value, boolean onlyIfAbsent) {\n    // 在往该 segment 写入前，需要先获取该 segment 的独占锁\n    //    先看主流程，后面还会具体介绍这部分内容\n    HashEntry<K,V> node = tryLock() ? null :\n        scanAndLockForPut(key, hash, value);\n    V oldValue;\n    try {\n        // 这个是 segment 内部的数组\n        HashEntry<K,V>[] tab = table;\n        // 再利用 hash 值，求应该放置的数组下标\n        int index = (tab.length - 1) & hash;\n        // first 是数组该位置处的链表的表头\n        HashEntry<K,V> first = entryAt(tab, index);\n \n        // 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况\n        for (HashEntry<K,V> e = first;;) {\n            if (e != null) {\n                K k;\n                if ((k = e.key) == key ||\n                    (e.hash == hash && key.equals(k))) {\n                    oldValue = e.value;\n                    if (!onlyIfAbsent) {\n                        // 覆盖旧值\n                        e.value = value;\n                        ++modCount;\n                    }\n                    break;\n                }\n                // 继续顺着链表走\n                e = e.next;\n            }\n            else {\n                // node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。\n                // 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。\n                if (node != null)\n                    node.setNext(first);\n                else\n                    node = new HashEntry<K,V>(hash, key, value, first);\n \n                int c = count + 1;\n                // 如果超过了该 segment 的阈值，这个 segment 需要扩容\n                if (c > threshold && tab.length < MAXIMUM_CAPACITY)\n                    rehash(node); // 扩容后面也会具体分析\n                else\n                    // 没有达到阈值，将 node 放到数组 tab 的 index 位置，\n                    // 其实就是将新的节点设置成原链表的表头\n                    setEntryAt(tab, index, node);\n                ++modCount;\n                count = c;\n                oldValue = null;\n                break;\n            }\n        }\n    } finally {\n        // 解锁\n        unlock();\n    }\n    return oldValue;\n}\n```\n\n整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。\n\n到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。\n\n###### 初始化槽: ensureSegment\n\nConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。\n\n这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。\n\n```\nprivate Segment<K,V> ensureSegment(int k) {\n    final Segment<K,V>[] ss = this.segments;\n    long u = (k << SSHIFT) + SBASE; // raw offset\n    Segment<K,V> seg;\n    if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) {\n        // 这里看到为什么之前要初始化 segment[0] 了，\n        // 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]\n        // 为什么要用“当前”，因为 segment[0] 可能早就扩容过了\n        Segment<K,V> proto = ss[0];\n        int cap = proto.table.length;\n        float lf = proto.loadFactor;\n        int threshold = (int)(cap * lf);\n \n        // 初始化 segment[k] 内部的数组\n        HashEntry<K,V>[] tab = (HashEntry<K,V>[])new HashEntry[cap];\n        if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))\n            == null) { // 再次检查一遍该槽是否被其他线程初始化了。\n \n            Segment<K,V> s = new Segment<K,V>(lf, threshold, tab);\n            // 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出\n            while ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))\n                   == null) {\n                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))\n                    break;\n            }\n        }\n    }\n    return seg;\n}\n```\n\n总的来说，ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。\n\n> 如果当前线程 CAS 失败，这里的 while 循环是为了将 seg 赋值返回。\n\n###### 获取写入锁: scanAndLockForPut\n\n前面我们看到，在往某个 segment 中 put 的时候，首先会调用 node = tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。\n\n下面我们来具体分析这个方法中是怎么控制加锁的。\n\n```\nprivate HashEntry<K,V> scanAndLockForPut(K key, int hash, V value) {\n    HashEntry<K,V> first = entryForHash(this, hash);\n    HashEntry<K,V> e = first;\n    HashEntry<K,V> node = null;\n    int retries = -1; // negative while locating node\n \n    // 循环获取锁\n    while (!tryLock()) {\n        HashEntry<K,V> f; // to recheck first below\n        if (retries < 0) {\n            if (e == null) {\n                if (node == null) // speculatively create node\n                    // 进到这里说明数组该位置的链表是空的，没有任何元素\n                    // 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置\n                    node = new HashEntry<K,V>(hash, key, value, null);\n                retries = 0;\n            }\n            else if (key.equals(e.key))\n                retries = 0;\n            else\n                // 顺着链表往下走\n                e = e.next;\n        }\n        // 重试次数如果超过 MAX_SCAN_RETRIES（单核1多核64），那么不抢了，进入到阻塞队列等待锁\n        //    lock() 是阻塞方法，直到获取锁后返回\n        else if (++retries > MAX_SCAN_RETRIES) {\n            lock();\n            break;\n        }\n        else if ((retries & 1) == 0 &&\n                 // 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头\n                 //     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法\n                 (f = entryForHash(this, hash)) != first) {\n            e = first = f; // re-traverse if entry changed\n            retries = -1;\n        }\n    }\n    return node;\n}\n```\n\n这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。\n\n这个方法就是看似复杂，但是其实就是做了一件事，那就是**获取该 segment 的独占锁**，如果需要的话顺便实例化了一下 node。\n\n###### 扩容: rehash\n\n重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry\\[] 进行扩容，扩容后，容量为原来的 2 倍。\n\n首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。\n\n该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。\n\n```\n// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。\nprivate void rehash(HashEntry<K,V> node) {\n    HashEntry<K,V>[] oldTable = table;\n    int oldCapacity = oldTable.length;\n    // 2 倍\n    int newCapacity = oldCapacity << 1;\n    threshold = (int)(newCapacity * loadFactor);\n    // 创建新数组\n    HashEntry<K,V>[] newTable =\n        (HashEntry<K,V>[]) new HashEntry[newCapacity];\n    // 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’\n    int sizeMask = newCapacity - 1;\n \n    // 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置\n    for (int i = 0; i < oldCapacity ; i++) {\n        // e 是链表的第一个元素\n        HashEntry<K,V> e = oldTable[i];\n        if (e != null) {\n            HashEntry<K,V> next = e.next;\n            // 计算应该放置在新数组中的位置，\n            // 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19\n            int idx = e.hash & sizeMask;\n            if (next == null)   // 该位置处只有一个元素，那比较好办\n                newTable[idx] = e;\n            else { // Reuse consecutive sequence at same slot\n                // e 是链表表头\n                HashEntry<K,V> lastRun = e;\n                // idx 是当前链表的头结点 e 的新位置\n                int lastIdx = idx;\n \n                // 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的\n                for (HashEntry<K,V> last = next;\n                     last != null;\n                     last = last.next) {\n                    int k = last.hash & sizeMask;\n                    if (k != lastIdx) {\n                        lastIdx = k;\n                        lastRun = last;\n                    }\n                }\n                // 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置\n                newTable[lastIdx] = lastRun;\n                // 下面的操作是处理 lastRun 之前的节点，\n                //    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中\n                for (HashEntry<K,V> p = e; p != lastRun; p = p.next) {\n                    V v = p.value;\n                    int h = p.hash;\n                    int k = h & sizeMask;\n                    HashEntry<K,V> n = newTable[k];\n                    newTable[k] = new HashEntry<K,V>(h, p.key, v, n);\n                }\n            }\n        }\n    }\n    // 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部\n    int nodeIndex = node.hash & sizeMask; // add the new node\n    node.setNext(newTable[nodeIndex]);\n    newTable[nodeIndex] = node;\n    table = newTable;\n}\n```\n\n这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢？\n\n仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。\n\n我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。**不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1/6 的节点需要克隆。**\n\n#### get 过程分析\n\n相对于 put 来说，get 真的不要太简单。\n\n1. 计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”\n2. 槽中也是一个数组，根据 hash 找到数组中具体的位置\n3. 到这里是链表了，顺着链表进行查找即可\n\n```\npublic V get(Object key) {\n    Segment<K,V> s; // manually integrate access methods to reduce overhead\n    HashEntry<K,V>[] tab;\n    // 1. hash 值\n    int h = hash(key);\n    long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;\n    // 2. 根据 hash 找到对应的 segment\n    if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&\n        (tab = s.table) != null) {\n        // 3. 找到segment 内部数组相应位置的链表，遍历\n        for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile\n                 (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);\n             e != null; e = e.next) {\n            K k;\n            if ((k = e.key) == key || (e.hash == h && key.equals(k)))\n                return e.value;\n        }\n    }\n    return null;\n}\n```\n\n#### 并发问题分析\n\n现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。\n\n添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。推荐阅读：[30 个 Java 集合面试问题及答案](https://mp.weixin.qq.com/s/Q5F604CUM_0x2co9mvADxw)。\n\n- **put 操作的线程安全性**\n\n1. 初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。\n1. 添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。\n3. 扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。\n\n- **remove 操作的线程安全性**\n\nremove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。\n\nget 操作需要遍历链表，但是 remove 操作会”破坏”链表。\n\n如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。\n\n如果 remove 先破坏了一个节点，分两种情况考虑。\n\n1、如果此节点是头结点，那么需要将头结点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。\n\n2、如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。推荐阅读：[史上最全 Java 多线程面试题及答案](https://mp.weixin.qq.com/s/0CI9od4DIxRrmOGFJw0SuQ)。\n\n## Java8 HashMap\n\nJava8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 **数组+链表+红黑树** 组成。\n\n根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 **O(n)**。\n\n为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。\n\n来一张图简单示意一下吧：\n\n![](http://qianniu.javastack.cn/18-12-4/75398751.jpg)\n\n> 注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。\n\n下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。\n\nJava7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 **Node**，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 **TreeNode**。\n\n我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。推荐阅读：[30 个 Java 集合面试问题及答案](https://mp.weixin.qq.com/s/Q5F604CUM_0x2co9mvADxw)。\n\n#### put 过程分析\n\n```\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n \n// 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作\n// 第四个参数 evict 我们这里不关心\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度\n    // 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n \n    else {// 数组该位置有数据\n        Node<K,V> e; K k;\n        // 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是\"相等\"，如果是，取出这个节点\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        // 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            // 到这里，说明数组该位置上是一个链表\n            for (int binCount = 0; ; ++binCount) {\n                // 插入到链表的最后面(Java7 是插入到链表的最前面)\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    // TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 9 个\n                    // 会触发下面的 treeifyBin，也就是将链表转换为红黑树\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                // 如果在该链表中找到了\"相等\"的 key(== 或 equals)\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    // 此时 break，那么 e 为链表中[与要插入的新值的 key \"相等\"]的 node\n                    break;\n                p = e;\n            }\n        }\n        // e!=null 说明存在旧值的key与要插入的key\"相等\"\n        // 对于我们分析的put操作，下面这个 if 其实就是进行 \"值覆盖\"，然后返回旧值\n        if (e != null) {\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    // 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。\n\n###### 数组扩容\n\nresize() 方法用于**初始化数组或数组扩容**，每次扩容后，容量为原来的 2 倍，并进行数据迁移。\n\n```\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) { // 对应数组扩容\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        // 将数组大小扩大一倍\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            // 将阈值扩大一倍\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候\n        newCap = oldThr;\n    else {// 对应使用 new HashMap() 初始化后，第一次 put 的时候\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n \n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n \n    // 用新的数组大小初始化新的数组\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab; // 如果是初始化数组，到这里就结束了，返回 newTab 即可\n \n    if (oldTab != null) {\n        // 开始遍历原数组，进行数据迁移。\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                // 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                // 如果是红黑树，具体我们就不展开了\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { \n                    // 这块是处理链表的情况，\n                    // 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序\n                    // loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    if (loTail != null) {\n                        loTail.next = null;\n                        // 第一条链表\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        // 第二条链表的新的位置是 j + oldCap，这个很好理解\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n#### get 过程分析\n\n相对于 put 来说，get 真的太简单了。\n\n1. 计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash & (length-1)\n2. 判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步\n3. 判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步\n4. 遍历链表，直到找到相等(==或equals)的 key.\n\n```\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n```\n\n```\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        // 判断第一个节点是不是就是需要的\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        if ((e = first.next) != null) {\n            // 判断是否是红黑树\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n \n            // 链表遍历\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n```\n\n## Java8 ConcurrentHashMap\n\nJava7 中实现的 ConcurrentHashMap 说实话还是比较复杂的，Java8 对 ConcurrentHashMap 进行了比较大的改动。建议读者可以参考 Java8 中 HashMap 相对于 Java7 HashMap 的改动，对于 ConcurrentHashMap，Java8 也引入了红黑树。\n\n说实话，Java8 ConcurrentHashMap 源码真心不简单，最难的在于扩容，数据迁移操作不容易看懂。\n\n我们先用一个示意图来描述下其结构：\n\n![](http://qianniu.javastack.cn/18-12-4/335817.jpg)\n\n结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。推荐阅读：[几种线程安全的Map解析](https://mp.weixin.qq.com/s/5Y5_6qn2g6kIVmQia_0R6g)。\n\n#### 初始化\n\n```\n// 这构造函数里，什么都不干\npublic ConcurrentHashMap() {\n}\npublic ConcurrentHashMap(int initialCapacity) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException();\n    int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ?\n               MAXIMUM_CAPACITY :\n               tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));\n    this.sizeCtl = cap;\n}\n```\n\n这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl = 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。\n\nsizeCtl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。\n\n如果你爱折腾，也可以看下另一个有三个参数的构造方法，这里我就不说了，大部分时候，我们会使用无参构造函数进行实例化，我们也按照这个思路来进行源码分析吧。\n\n#### put 过程分析\n\n仔细地一行一行代码看下去：\n\n```\npublic V put(K key, V value) {\n    return putVal(key, value, false);\n}\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n    if (key == null || value == null) throw new NullPointerException();\n    // 得到 hash 值\n    int hash = spread(key.hashCode());\n    // 用于记录相应链表的长度\n    int binCount = 0;\n    for (Node<K,V>[] tab = table;;) {\n        Node<K,V> f; int n, i, fh;\n        // 如果数组\"空\"，进行数组初始化\n        if (tab == null || (n = tab.length) == 0)\n            // 初始化数组，后面会详细介绍\n            tab = initTable();\n \n        // 找该 hash 值对应的数组下标，得到第一个节点 f\n        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n            // 如果数组该位置为空，\n            //    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了\n            //          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了\n            if (casTabAt(tab, i, null,\n                         new Node<K,V>(hash, key, value, null)))\n                break;                   // no lock when adding to empty bin\n        }\n        // hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容\n        else if ((fh = f.hash) == MOVED)\n            // 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了\n            tab = helpTransfer(tab, f);\n \n        else { // 到这里就是说，f 是该位置的头结点，而且不为空\n \n            V oldVal = null;\n            // 获取数组该位置的头结点的监视器锁\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    if (fh >= 0) { // 头结点的 hash 值大于 0，说明是链表\n                        // 用于累加，记录链表的长度\n                        binCount = 1;\n                        // 遍历链表\n                        for (Node<K,V> e = f;; ++binCount) {\n                            K ek;\n                            // 如果发现了\"相等\"的 key，判断是否要进行值覆盖，然后也就可以 break 了\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                 (ek != null && key.equals(ek)))) {\n                                oldVal = e.val;\n                                if (!onlyIfAbsent)\n                                    e.val = value;\n                                break;\n                            }\n                            // 到了链表的最末端，将这个新值放到链表的最后面\n                            Node<K,V> pred = e;\n                            if ((e = e.next) == null) {\n                                pred.next = new Node<K,V>(hash, key,\n                                                          value, null);\n                                break;\n                            }\n                        }\n                    }\n                    else if (f instanceof TreeBin) { // 红黑树\n                        Node<K,V> p;\n                        binCount = 2;\n                        // 调用红黑树的插值方法插入新节点\n                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                       value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n            // binCount != 0 说明上面在做链表操作\n            if (binCount != 0) {\n                // 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8\n                if (binCount >= TREEIFY_THRESHOLD)\n                    // 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，\n                    // 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树\n                    //    具体源码我们就不看了，扩容部分后面说\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    // \n    addCount(1L, binCount);\n    return null;\n}\n```\n\nput 的主流程看完了，但是至少留下了几个问题，第一个是初始化，第二个是扩容，第三个是帮助数据迁移，这些我们都会在后面进行一一介绍。\n\n###### 初始化数组：initTable\n\n这个比较简单，主要就是初始化一个合适大小的数组，然后会设置 sizeCtl。\n\n初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。\n\n```\nprivate final Node<K,V>[] initTable() {\n    Node<K,V>[] tab; int sc;\n    while ((tab = table) == null || tab.length == 0) {\n        // 初始化的\"功劳\"被其他线程\"抢去\"了\n        if ((sc = sizeCtl) < 0)\n            Thread.yield(); // lost initialization race; just spin\n        // CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁\n        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n            try {\n                if ((tab = table) == null || tab.length == 0) {\n                    // DEFAULT_CAPACITY 默认初始容量是 16\n                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;\n                    // 初始化数组，长度为 16 或初始化时提供的长度\n                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                    // 将这个数组赋值给 table，table 是 volatile 的\n                    table = tab = nt;\n                    // 如果 n 为 16 的话，那么这里 sc = 12\n                    // 其实就是 0.75 * n\n                    sc = n - (n >>> 2);\n                }\n            } finally {\n                // 设置 sizeCtl 为 sc，我们就当是 12 吧\n                sizeCtl = sc;\n            }\n            break;\n        }\n    }\n    return tab;\n}\n```\n\n###### 链表转红黑树: treeifyBin\n\n前面我们在 put 源码分析也说过，treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。\n\n```\nprivate final void treeifyBin(Node<K,V>[] tab, int index) {\n    Node<K,V> b; int n, sc;\n    if (tab != null) {\n        // MIN_TREEIFY_CAPACITY 为 64\n        // 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容\n        if ((n = tab.length) < MIN_TREEIFY_CAPACITY)\n            // 后面我们再详细分析这个方法\n            tryPresize(n << 1);\n        // b 是头结点\n        else if ((b = tabAt(tab, index)) != null && b.hash >= 0) {\n            // 加锁\n            synchronized (b) {\n \n                if (tabAt(tab, index) == b) {\n                    // 下面就是遍历链表，建立一颗红黑树\n                    TreeNode<K,V> hd = null, tl = null;\n                    for (Node<K,V> e = b; e != null; e = e.next) {\n                        TreeNode<K,V> p =\n                            new TreeNode<K,V>(e.hash, e.key, e.val,\n                                              null, null);\n                        if ((p.prev = tl) == null)\n                            hd = p;\n                        else\n                            tl.next = p;\n                        tl = p;\n                    }\n                    // 将红黑树设置到数组相应位置中\n                    setTabAt(tab, index, new TreeBin<K,V>(hd));\n                }\n            }\n        }\n    }\n}\n```\n\n\n#### 扩容：tryPresize\n\n如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。\n\n这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。\n\n这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。\n\n```\n// 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了\nprivate final void tryPresize(int size) {\n    // c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。\n    int c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY :\n        tableSizeFor(size + (size >>> 1) + 1);\n    int sc;\n    while ((sc = sizeCtl) >= 0) {\n        Node<K,V>[] tab = table; int n;\n \n        // 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码\n        if (tab == null || (n = tab.length) == 0) {\n            n = (sc > c) ? sc : c;\n            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n                try {\n                    if (table == tab) {\n                        @SuppressWarnings(\"unchecked\")\n                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                        table = nt;\n                        sc = n - (n >>> 2); // 0.75 * n\n                    }\n                } finally {\n                    sizeCtl = sc;\n                }\n            }\n        }\n        else if (c <= sc || n >= MAXIMUM_CAPACITY)\n            break;\n        else if (tab == table) {\n            // 我没看懂 rs 的真正含义是什么，不过也关系不大\n            int rs = resizeStamp(n);\n \n            if (sc < 0) {\n                Node<K,V>[] nt;\n                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||\n                    transferIndex <= 0)\n                    break;\n                // 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法\n                //    此时 nextTab 不为 null\n                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))\n                    transfer(tab, nt);\n            }\n            // 1. 将 sizeCtl 设置为 (rs << RESIZE_STAMP_SHIFT) + 2)\n            //     我是没看懂这个值真正的意义是什么？不过可以计算出来的是，结果是一个比较大的负数\n            //  调用 transfer 方法，此时 nextTab 参数为 null\n            else if (U.compareAndSwapInt(this, SIZECTL, sc,\n                                         (rs << RESIZE_STAMP_SHIFT) + 2))\n                transfer(tab, null);\n        }\n    }\n}\n```\n\n这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。\n\n所以，可能的操作就是执行 **1 次 transfer(tab, null) + 多次 transfer(tab, nt)**，这里怎么结束循环的需要看完 transfer 源码才清楚。推荐阅读：[30 个 Java 集合面试问题及答案](https://mp.weixin.qq.com/s/Q5F604CUM_0x2co9mvADxw)。\n\n###### 数据迁移：transfer\n\n下面这个方法很点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。\n\n虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。\n\n此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。\n\n阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 stride，简单理解就是步长，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。\n\n第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后从后往前的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。\n\n```\nprivate final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {\n    int n = tab.length, stride;\n \n    // stride 在单核下直接等于 n，多核模式下为 (n>>>3)/NCPU，最小值是 16\n    // stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，\n    //   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务\n    if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)\n        stride = MIN_TRANSFER_STRIDE; // subdivide range\n \n    // 如果 nextTab 为 null，先进行一次初始化\n    //    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null\n    //       之后参与迁移的线程调用此方法时，nextTab 不会为 null\n    if (nextTab == null) {\n        try {\n            // 容量翻倍\n            Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];\n            nextTab = nt;\n        } catch (Throwable ex) {      // try to cope with OOME\n            sizeCtl = Integer.MAX_VALUE;\n            return;\n        }\n        // nextTable 是 ConcurrentHashMap 中的属性\n        nextTable = nextTab;\n        // transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置\n        transferIndex = n;\n    }\n \n    int nextn = nextTab.length;\n \n    // ForwardingNode 翻译过来就是正在被迁移的 Node\n    // 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED\n    // 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，\n    //    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了\n    //    所以它其实相当于是一个标志。\n    ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);\n \n \n    // advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了\n    boolean advance = true;\n    boolean finishing = false; // to ensure sweep before committing nextTab\n \n    /*\n     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看\n     * \n     */\n \n    // i 是位置索引，bound 是边界，注意是从后往前\n    for (int i = 0, bound = 0;;) {\n        Node<K,V> f; int fh;\n \n        // 下面这个 while 真的是不好理解\n        // advance 为 true 表示可以进行下一个位置的迁移了\n        //   简单理解结局：i 指向了 transferIndex，bound 指向了 transferIndex-stride\n        while (advance) {\n            int nextIndex, nextBound;\n            if (--i >= bound || finishing)\n                advance = false;\n \n            // 将 transferIndex 值赋给 nextIndex\n            // 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了\n            else if ((nextIndex = transferIndex) <= 0) {\n                i = -1;\n                advance = false;\n            }\n            else if (U.compareAndSwapInt\n                     (this, TRANSFERINDEX, nextIndex,\n                      nextBound = (nextIndex > stride ?\n                                   nextIndex - stride : 0))) {\n                // 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前\n                bound = nextBound;\n                i = nextIndex - 1;\n                advance = false;\n            }\n        }\n        if (i < 0 || i >= n || i + n >= nextn) {\n            int sc;\n            if (finishing) {\n                // 所有的迁移操作已经完成\n                nextTable = null;\n                // 将新的 nextTab 赋值给 table 属性，完成迁移\n                table = nextTab;\n                // 重新计算 sizeCtl：n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍\n                sizeCtl = (n << 1) - (n >>> 1);\n                return;\n            }\n \n            // 之前我们说过，sizeCtl 在迁移前会设置为 (rs << RESIZE_STAMP_SHIFT) + 2\n            // 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，\n            // 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务\n            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {\n                // 任务结束，方法退出\n                if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)\n                    return;\n \n                // 到这里，说明 (sc - 2) == resizeStamp(n) << RESIZE_STAMP_SHIFT，\n                // 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing){} 分支了\n                finishing = advance = true;\n                i = n; // recheck before commit\n            }\n        }\n        // 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“\n        else if ((f = tabAt(tab, i)) == null)\n            advance = casTabAt(tab, i, null, fwd);\n        // 该位置处是一个 ForwardingNode，代表该位置已经迁移过了\n        else if ((fh = f.hash) == MOVED)\n            advance = true; // already processed\n        else {\n            // 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    Node<K,V> ln, hn;\n                    // 头结点的 hash 大于 0，说明是链表的 Node 节点\n                    if (fh >= 0) {\n                        // 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，\n                        // 需要将链表一分为二，\n                        //   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的\n                        //   lastRun 之前的节点需要进行克隆，然后分到两个链表中\n                        int runBit = fh & n;\n                        Node<K,V> lastRun = f;\n                        for (Node<K,V> p = f.next; p != null; p = p.next) {\n                            int b = p.hash & n;\n                            if (b != runBit) {\n                                runBit = b;\n                                lastRun = p;\n                            }\n                        }\n                        if (runBit == 0) {\n                            ln = lastRun;\n                            hn = null;\n                        }\n                        else {\n                            hn = lastRun;\n                            ln = null;\n                        }\n                        for (Node<K,V> p = f; p != lastRun; p = p.next) {\n                            int ph = p.hash; K pk = p.key; V pv = p.val;\n                            if ((ph & n) == 0)\n                                ln = new Node<K,V>(ph, pk, pv, ln);\n                            else\n                                hn = new Node<K,V>(ph, pk, pv, hn);\n                        }\n                        // 其中的一个链表放在新数组的位置 i\n                        setTabAt(nextTab, i, ln);\n                        // 另一个链表放在新数组的位置 i+n\n                        setTabAt(nextTab, i + n, hn);\n                        // 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，\n                        //    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了\n                        setTabAt(tab, i, fwd);\n                        // advance 设置为 true，代表该位置已经迁移完毕\n                        advance = true;\n                    }\n                    else if (f instanceof TreeBin) {\n                        // 红黑树的迁移\n                        TreeBin<K,V> t = (TreeBin<K,V>)f;\n                        TreeNode<K,V> lo = null, loTail = null;\n                        TreeNode<K,V> hi = null, hiTail = null;\n                        int lc = 0, hc = 0;\n                        for (Node<K,V> e = t.first; e != null; e = e.next) {\n                            int h = e.hash;\n                            TreeNode<K,V> p = new TreeNode<K,V>\n                                (h, e.key, e.val, null, null);\n                            if ((h & n) == 0) {\n                                if ((p.prev = loTail) == null)\n                                    lo = p;\n                                else\n                                    loTail.next = p;\n                                loTail = p;\n                                ++lc;\n                            }\n                            else {\n                                if ((p.prev = hiTail) == null)\n                                    hi = p;\n                                else\n                                    hiTail.next = p;\n                                hiTail = p;\n                                ++hc;\n                            }\n                        }\n                        // 如果一分为二后，节点数少于 8，那么将红黑树转换回链表\n                        ln = (lc <= UNTREEIFY_THRESHOLD) ? untreeify(lo) :\n                            (hc != 0) ? new TreeBin<K,V>(lo) : t;\n                        hn = (hc <= UNTREEIFY_THRESHOLD) ? untreeify(hi) :\n                            (lc != 0) ? new TreeBin<K,V>(hi) : t;\n \n                        // 将 ln 放置在新数组的位置 i\n                        setTabAt(nextTab, i, ln);\n                        // 将 hn 放置在新数组的位置 i+n\n                        setTabAt(nextTab, i + n, hn);\n                        // 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，\n                        //    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了\n                        setTabAt(tab, i, fwd);\n                        // advance 设置为 true，代表该位置已经迁移完毕\n                        advance = true;\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。\n\n这个时候，再回去仔细看 tryPresize 方法可能就会更加清晰一些了。\n\n#### get 过程分析\n\nget 方法从来都是最简单的，这里也不例外：\n\n1.计算 hash 值\n\n2.根据 hash 值找到数组对应位置: (n – 1) & h\n\n3.根据该位置处结点性质进行相应查找\n\n- 如果该位置为 null，那么直接返回 null 就可以了\n- 如果该位置处的节点刚好就是我们需要的，返回该节点的值即可\n- 如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法\n- 如果以上 3 条都不满足，那就是链表，进行遍历比对即可。\n\n```\npublic V get(Object key) {\n    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;\n    int h = spread(key.hashCode());\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (e = tabAt(tab, (n - 1) & h)) != null) {\n        // 判断头结点是否就是我们需要的节点\n        if ((eh = e.hash) == h) {\n            if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                return e.val;\n        }\n        // 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树\n        else if (eh < 0)\n            // 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)\n            return (p = e.find(h, key)) != null ? p.val : null;\n \n        // 遍历链表\n        while ((e = e.next) != null) {\n            if (e.hash == h &&\n                ((ek = e.key) == key || (ek != null && key.equals(ek))))\n                return e.val;\n        }\n    }\n    return null;\n}\n```\n\n简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，ForwardingNode.find(int h, Object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了，所以限于篇幅这里也不展开说了。\n\n## 总结\n\n其实也不是很难嘛，虽然没有像之前的 AQS 和线程池一样一行一行源码进行分析，但还是把所有初学者可能会糊涂的地方都进行了深入的介绍，只要是稍微有点基础的读者，应该是很容易就能看懂 HashMap 和 ConcurrentHashMap 源码了。\n\n看源码不算是目的吧，深入地了解 Doug Lea 的设计思路，我觉得还挺有趣的，大师就是大师，代码写得真的是好啊。\n\n我发现很多人都以为我写博客主要是源码分析，说真的，我对于源码分析没有那么大热情，主要都是为了用源码说事罢了，可能之后的文章还是会有比较多的源码分析成分，大家该怎么看就怎么看吧。\n\n不要脸地自以为本文的质量还是挺高的，信息量比较大，如果你觉得有写得不好的地方，或者说看完本文你还是没看懂它们，那么请提出来~~~\n\n","source":"_posts/集合/HashMap, ConcurrentHashMap 原理及源码.md","raw":"---\ntitle: HashMap, ConcurrentHashMap 原理及源码\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 集合\n---\n\n\n网上关于 HashMap 和 ConcurrentHashMap 的文章确实不少，不过缺斤少两的文章比较多，所以才想自己也写一篇，把细节说清楚说透，尤其像 Java8 中的 ConcurrentHashMap，大部分文章都说不清楚。终归是希望能降低大家学习的成本，不希望大家到处找各种不是很靠谱的文章，看完一篇又一篇，可是还是模模糊糊。\n\n**阅读建议：** 四节基本上可以进行独立阅读，建议初学者可按照以下顺序进行阅读，可适当降低阅读门槛。\n\n> Java7 HashMap -> Java7 ConcurrentHashMap -> Java8 HashMap -> Java8 ConcurrentHashMap \n\n**阅读前提：** 本文分析的是源码，所以至少读者要熟悉它们的接口使用，同时，对于并发，读者至少要知道 CAS、ReentrantLock、UNSAFE 操作这几个基本的知识，文中不会对这些知识进行介绍。Java8 用到了红黑树，不过本文不会进行展开，感兴趣的读者请自行查找相关资料。\n\n## Java7 HashMap\n\nHashMap 是最简单的，一来我们非常熟悉，二来就是它不支持并发操作，所以源码也非常简单。\n\n首先，我们用下面这张图来介绍 HashMap 的结构。\n\n![](http://qianniu.javastack.cn/18-12-4/65827660.jpg)\n\n这个仅仅是示意图，因为没有考虑到数组要扩容的情况，具体的后面再说。\n\n大方向上，HashMap 里面是一个**数组**，然后数组中每个元素是一个**单向链表**。\n\n上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。\n\ncapacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。\n\nloadFactor：负载因子，默认为 0.75。\n\nthreshold：扩容的阈值，等于 capacity * loadFactor\n\n#### put 过程分析\n\n还是比较简单的，跟着代码走一遍吧。\n\n```\npublic V put(K key, V value) {\n    // 当插入第一个元素的时候，需要先初始化数组大小\n    if (table == EMPTY_TABLE) {\n        inflateTable(threshold);\n    }\n    // 如果 key 为 null，感兴趣的可以往里看，最终会将这个 entry 放到 table[0] 中\n    if (key == null)\n        return putForNullKey(value);\n    // 1. 求 key 的 hash 值\n    int hash = hash(key);\n    // 2. 找到对应的数组下标\n    int i = indexFor(hash, table.length);\n    // 3. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在，\n    //    如果有，直接覆盖，put 方法返回旧值就结束了\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n \n    modCount++;\n    // 4. 不存在重复的 key，将此 entry 添加到链表中，细节后面说\n    addEntry(hash, key, value, i);\n    return null;\n}\n```\n\n###### 数组初始化\n\n在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值。\n\n```\nprivate void inflateTable(int toSize) {\n    // 保证数组大小一定是 2 的 n 次方。\n    // 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32\n    int capacity = roundUpToPowerOf2(toSize);\n    // 计算扩容阈值：capacity * loadFactor\n    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);\n    // 算是初始化数组吧\n    table = new Entry[capacity];\n    initHashSeedAsNeeded(capacity); //ignore\n}\n```\n\n这里有一个将数组大小保持为 2 的 n 次方的做法，Java7 和 Java8 的 HashMap 和 ConcurrentHashMap 都有相应的要求，只不过实现的代码稍微有些不同，后面再看到的时候就知道了。\n\n###### 计算具体数组位置\n\n这个简单，我们自己也能 YY 一个：使用 key 的 hash 值对数组长度进行取模就可以了。\n\n```\nstatic int indexFor(int hash, int length) {\n    // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\";\n    return hash & (length-1);\n}\n```\n\n这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。\n\n###### 添加节点到链表中\n\n找到数组下标后，会先进行 key 判重，如果没有重复，就准备将新值放入到链表的表头。\n\n```\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    // 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容\n    if ((size >= threshold) && (null != table[bucketIndex])) {\n        // 扩容，后面会介绍一下\n        resize(2 * table.length);\n        // 扩容以后，重新计算 hash 值\n        hash = (null != key) ? hash(key) : 0;\n        // 重新计算扩容后的新的下标\n        bucketIndex = indexFor(hash, table.length);\n    }\n    // 往下看\n    createEntry(hash, key, value, bucketIndex);\n}\n\n// 这个很简单，其实就是将新值放到链表的表头，然后 size++\nvoid createEntry(int hash, K key, V value, int bucketIndex) {\n    Entry<K,V> e = table[bucketIndex];\n    table[bucketIndex] = new Entry<>(hash, key, value, e);\n    size++;\n}\n```\n\n这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。\n\n###### 数组扩容\n\n前面我们看到，在插入新值的时候，如果当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。\n\n```\nvoid resize(int newCapacity) {\n    Entry[] oldTable = table;\n    int oldCapacity = oldTable.length;\n    if (oldCapacity == MAXIMUM_CAPACITY) {\n        threshold = Integer.MAX_VALUE;\n        return;\n    }\n    // 新的数组\n    Entry[] newTable = new Entry[newCapacity];\n    // 将原来数组中的值迁移到新的更大的数组中\n    transfer(newTable, initHashSeedAsNeeded(newCapacity));\n    table = newTable;\n    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n}\n```\n\n扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。\n\n由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。代码比较简单，这里就不展开了。\n\n#### get 过程分析\n\n相对于 put 过程，get 过程是非常简单的。\n\n1. 根据 key 计算 hash 值。\n2. 找到相应的数组下标：hash & (length – 1)。\n3. 遍历该数组位置处的链表，直到找到相等(==或equals)的 key。\n\n```\npublic V get(Object key) {\n    // 之前说过，key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了\n    if (key == null)\n        return getForNullKey();\n    // \n    Entry<K,V> entry = getEntry(key);\n \n    return null == entry ? null : entry.getValue();\n}\n```\n\ngetEntry(key):\n\n```\nfinal Entry<K,V> getEntry(Object key) {\n    if (size == 0) {\n        return null;\n    }\n \n    int hash = (key == null) ? 0 : hash(key);\n    // 确定数组下标，然后从头开始遍历链表，直到找到为止\n    for (Entry<K,V> e = table[indexFor(hash, table.length)];\n         e != null;\n         e = e.next) {\n        Object k;\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k))))\n            return e;\n    }\n    return null;\n}\n```\n\n## Java7 ConcurrentHashMap\n\nConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。\n\n整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为**分段锁**。注意，行文中，我很多地方用了 **“槽”** 来代表一个 segment。\n\n简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。推荐阅读：[史上最全 Java 多线程面试题及答案](https://mp.weixin.qq.com/s/0CI9od4DIxRrmOGFJw0SuQ)。\n\n![](http://qianniu.javastack.cn/18-12-4/75121838.jpg)\n\n**concurrencyLevel：** 并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。\n\n再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。推荐阅读：[几种线程安全的Map解析](https://mp.weixin.qq.com/s/5Y5_6qn2g6kIVmQia_0R6g)。\n\n#### 初始化\n\ninitialCapacity：初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。\n\nloadFactor：负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。\n\n```\npublic ConcurrentHashMap(int initialCapacity,\n                         float loadFactor, int concurrencyLevel) {\n    if (!(loadFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0)\n        throw new IllegalArgumentException();\n    if (concurrencyLevel > MAX_SEGMENTS)\n        concurrencyLevel = MAX_SEGMENTS;\n    // Find power-of-two sizes best matching arguments\n    int sshift = 0;\n    int ssize = 1;\n    // 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方\n    while (ssize < concurrencyLevel) {\n        ++sshift;\n        ssize <<= 1;\n    }\n    // 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4\n    // 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值\n    this.segmentShift = 32 - sshift;\n    this.segmentMask = ssize - 1;\n \n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n \n    // initialCapacity 是设置整个 map 初始的大小，\n    // 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小\n    // 如 initialCapacity 为 64，那么每个 Segment 或称之为\"槽\"可以分到 4 个\n    int c = initialCapacity / ssize;\n    if (c * ssize < initialCapacity)\n        ++c;\n    // 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，\n    // 插入一个元素不至于扩容，插入第二个的时候才会扩容\n    int cap = MIN_SEGMENT_TABLE_CAPACITY; \n    while (cap < c)\n        cap <<= 1;\n \n    // 创建 Segment 数组，\n    // 并创建数组的第一个元素 segment[0]\n    Segment<K,V> s0 =\n        new Segment<K,V>(loadFactor, (int)(cap * loadFactor),\n                         (HashEntry<K,V>[])new HashEntry[cap]);\n    Segment<K,V>[] ss = (Segment<K,V>[])new Segment[ssize];\n    // 往数组写入 segment[0]\n    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]\n    this.segments = ss;\n}\n```\n\n初始化完成，我们得到了一个 Segment 数组。\n\n我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后：\n\n- Segment 数组长度为 16，不可以扩容\n- Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容\n- 这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍\n- 当前 segmentShift 的值为 32 – 4 = 28，segmentMask 为 16 – 1 = 15，姑且把它们简单翻译为移位数和掩码，这两个值马上就会用到。\n\n#### put 过程分析\n\n我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。\n\n```\npublic V put(K key, V value) {\n    Segment<K,V> s;\n    if (value == null)\n        throw new NullPointerException();\n    // 1. 计算 key 的 hash 值\n    int hash = hash(key);\n    // 2. 根据 hash 值找到 Segment 数组中的位置 j\n    //    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下低 4 位，\n    //    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的最后 4 位，也就是槽的数组下标\n    int j = (hash >>> segmentShift) & segmentMask;\n    // 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，\n    // ensureSegment(j) 对 segment[j] 进行初始化\n    if ((s = (Segment<K,V>)UNSAFE.getObject          // nonvolatile; recheck\n         (segments, (j << SSHIFT) + SBASE)) == null) //  in ensureSegment\n        s = ensureSegment(j);\n    // 3. 插入新值到 槽 s 中\n    return s.put(key, hash, value, false);\n}\n```\n\n第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。\n\nSegment 内部是由 **数组+链表** 组成的。\n\n```\nfinal V put(K key, int hash, V value, boolean onlyIfAbsent) {\n    // 在往该 segment 写入前，需要先获取该 segment 的独占锁\n    //    先看主流程，后面还会具体介绍这部分内容\n    HashEntry<K,V> node = tryLock() ? null :\n        scanAndLockForPut(key, hash, value);\n    V oldValue;\n    try {\n        // 这个是 segment 内部的数组\n        HashEntry<K,V>[] tab = table;\n        // 再利用 hash 值，求应该放置的数组下标\n        int index = (tab.length - 1) & hash;\n        // first 是数组该位置处的链表的表头\n        HashEntry<K,V> first = entryAt(tab, index);\n \n        // 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况\n        for (HashEntry<K,V> e = first;;) {\n            if (e != null) {\n                K k;\n                if ((k = e.key) == key ||\n                    (e.hash == hash && key.equals(k))) {\n                    oldValue = e.value;\n                    if (!onlyIfAbsent) {\n                        // 覆盖旧值\n                        e.value = value;\n                        ++modCount;\n                    }\n                    break;\n                }\n                // 继续顺着链表走\n                e = e.next;\n            }\n            else {\n                // node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。\n                // 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。\n                if (node != null)\n                    node.setNext(first);\n                else\n                    node = new HashEntry<K,V>(hash, key, value, first);\n \n                int c = count + 1;\n                // 如果超过了该 segment 的阈值，这个 segment 需要扩容\n                if (c > threshold && tab.length < MAXIMUM_CAPACITY)\n                    rehash(node); // 扩容后面也会具体分析\n                else\n                    // 没有达到阈值，将 node 放到数组 tab 的 index 位置，\n                    // 其实就是将新的节点设置成原链表的表头\n                    setEntryAt(tab, index, node);\n                ++modCount;\n                count = c;\n                oldValue = null;\n                break;\n            }\n        }\n    } finally {\n        // 解锁\n        unlock();\n    }\n    return oldValue;\n}\n```\n\n整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。\n\n到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。\n\n###### 初始化槽: ensureSegment\n\nConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。\n\n这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。\n\n```\nprivate Segment<K,V> ensureSegment(int k) {\n    final Segment<K,V>[] ss = this.segments;\n    long u = (k << SSHIFT) + SBASE; // raw offset\n    Segment<K,V> seg;\n    if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) {\n        // 这里看到为什么之前要初始化 segment[0] 了，\n        // 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]\n        // 为什么要用“当前”，因为 segment[0] 可能早就扩容过了\n        Segment<K,V> proto = ss[0];\n        int cap = proto.table.length;\n        float lf = proto.loadFactor;\n        int threshold = (int)(cap * lf);\n \n        // 初始化 segment[k] 内部的数组\n        HashEntry<K,V>[] tab = (HashEntry<K,V>[])new HashEntry[cap];\n        if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))\n            == null) { // 再次检查一遍该槽是否被其他线程初始化了。\n \n            Segment<K,V> s = new Segment<K,V>(lf, threshold, tab);\n            // 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出\n            while ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))\n                   == null) {\n                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))\n                    break;\n            }\n        }\n    }\n    return seg;\n}\n```\n\n总的来说，ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。\n\n> 如果当前线程 CAS 失败，这里的 while 循环是为了将 seg 赋值返回。\n\n###### 获取写入锁: scanAndLockForPut\n\n前面我们看到，在往某个 segment 中 put 的时候，首先会调用 node = tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。\n\n下面我们来具体分析这个方法中是怎么控制加锁的。\n\n```\nprivate HashEntry<K,V> scanAndLockForPut(K key, int hash, V value) {\n    HashEntry<K,V> first = entryForHash(this, hash);\n    HashEntry<K,V> e = first;\n    HashEntry<K,V> node = null;\n    int retries = -1; // negative while locating node\n \n    // 循环获取锁\n    while (!tryLock()) {\n        HashEntry<K,V> f; // to recheck first below\n        if (retries < 0) {\n            if (e == null) {\n                if (node == null) // speculatively create node\n                    // 进到这里说明数组该位置的链表是空的，没有任何元素\n                    // 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置\n                    node = new HashEntry<K,V>(hash, key, value, null);\n                retries = 0;\n            }\n            else if (key.equals(e.key))\n                retries = 0;\n            else\n                // 顺着链表往下走\n                e = e.next;\n        }\n        // 重试次数如果超过 MAX_SCAN_RETRIES（单核1多核64），那么不抢了，进入到阻塞队列等待锁\n        //    lock() 是阻塞方法，直到获取锁后返回\n        else if (++retries > MAX_SCAN_RETRIES) {\n            lock();\n            break;\n        }\n        else if ((retries & 1) == 0 &&\n                 // 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头\n                 //     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法\n                 (f = entryForHash(this, hash)) != first) {\n            e = first = f; // re-traverse if entry changed\n            retries = -1;\n        }\n    }\n    return node;\n}\n```\n\n这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。\n\n这个方法就是看似复杂，但是其实就是做了一件事，那就是**获取该 segment 的独占锁**，如果需要的话顺便实例化了一下 node。\n\n###### 扩容: rehash\n\n重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry\\[] 进行扩容，扩容后，容量为原来的 2 倍。\n\n首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。\n\n该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。\n\n```\n// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。\nprivate void rehash(HashEntry<K,V> node) {\n    HashEntry<K,V>[] oldTable = table;\n    int oldCapacity = oldTable.length;\n    // 2 倍\n    int newCapacity = oldCapacity << 1;\n    threshold = (int)(newCapacity * loadFactor);\n    // 创建新数组\n    HashEntry<K,V>[] newTable =\n        (HashEntry<K,V>[]) new HashEntry[newCapacity];\n    // 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’\n    int sizeMask = newCapacity - 1;\n \n    // 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置\n    for (int i = 0; i < oldCapacity ; i++) {\n        // e 是链表的第一个元素\n        HashEntry<K,V> e = oldTable[i];\n        if (e != null) {\n            HashEntry<K,V> next = e.next;\n            // 计算应该放置在新数组中的位置，\n            // 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19\n            int idx = e.hash & sizeMask;\n            if (next == null)   // 该位置处只有一个元素，那比较好办\n                newTable[idx] = e;\n            else { // Reuse consecutive sequence at same slot\n                // e 是链表表头\n                HashEntry<K,V> lastRun = e;\n                // idx 是当前链表的头结点 e 的新位置\n                int lastIdx = idx;\n \n                // 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的\n                for (HashEntry<K,V> last = next;\n                     last != null;\n                     last = last.next) {\n                    int k = last.hash & sizeMask;\n                    if (k != lastIdx) {\n                        lastIdx = k;\n                        lastRun = last;\n                    }\n                }\n                // 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置\n                newTable[lastIdx] = lastRun;\n                // 下面的操作是处理 lastRun 之前的节点，\n                //    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中\n                for (HashEntry<K,V> p = e; p != lastRun; p = p.next) {\n                    V v = p.value;\n                    int h = p.hash;\n                    int k = h & sizeMask;\n                    HashEntry<K,V> n = newTable[k];\n                    newTable[k] = new HashEntry<K,V>(h, p.key, v, n);\n                }\n            }\n        }\n    }\n    // 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部\n    int nodeIndex = node.hash & sizeMask; // add the new node\n    node.setNext(newTable[nodeIndex]);\n    newTable[nodeIndex] = node;\n    table = newTable;\n}\n```\n\n这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢？\n\n仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。\n\n我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。**不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1/6 的节点需要克隆。**\n\n#### get 过程分析\n\n相对于 put 来说，get 真的不要太简单。\n\n1. 计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”\n2. 槽中也是一个数组，根据 hash 找到数组中具体的位置\n3. 到这里是链表了，顺着链表进行查找即可\n\n```\npublic V get(Object key) {\n    Segment<K,V> s; // manually integrate access methods to reduce overhead\n    HashEntry<K,V>[] tab;\n    // 1. hash 值\n    int h = hash(key);\n    long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;\n    // 2. 根据 hash 找到对应的 segment\n    if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&\n        (tab = s.table) != null) {\n        // 3. 找到segment 内部数组相应位置的链表，遍历\n        for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile\n                 (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);\n             e != null; e = e.next) {\n            K k;\n            if ((k = e.key) == key || (e.hash == h && key.equals(k)))\n                return e.value;\n        }\n    }\n    return null;\n}\n```\n\n#### 并发问题分析\n\n现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。\n\n添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。推荐阅读：[30 个 Java 集合面试问题及答案](https://mp.weixin.qq.com/s/Q5F604CUM_0x2co9mvADxw)。\n\n- **put 操作的线程安全性**\n\n1. 初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。\n1. 添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。\n3. 扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。\n\n- **remove 操作的线程安全性**\n\nremove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。\n\nget 操作需要遍历链表，但是 remove 操作会”破坏”链表。\n\n如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。\n\n如果 remove 先破坏了一个节点，分两种情况考虑。\n\n1、如果此节点是头结点，那么需要将头结点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。\n\n2、如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。推荐阅读：[史上最全 Java 多线程面试题及答案](https://mp.weixin.qq.com/s/0CI9od4DIxRrmOGFJw0SuQ)。\n\n## Java8 HashMap\n\nJava8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 **数组+链表+红黑树** 组成。\n\n根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 **O(n)**。\n\n为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。\n\n来一张图简单示意一下吧：\n\n![](http://qianniu.javastack.cn/18-12-4/75398751.jpg)\n\n> 注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。\n\n下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。\n\nJava7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 **Node**，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 **TreeNode**。\n\n我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。推荐阅读：[30 个 Java 集合面试问题及答案](https://mp.weixin.qq.com/s/Q5F604CUM_0x2co9mvADxw)。\n\n#### put 过程分析\n\n```\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n \n// 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作\n// 第四个参数 evict 我们这里不关心\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度\n    // 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n \n    else {// 数组该位置有数据\n        Node<K,V> e; K k;\n        // 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是\"相等\"，如果是，取出这个节点\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        // 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树\n        else if (p instanceof TreeNode)\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            // 到这里，说明数组该位置上是一个链表\n            for (int binCount = 0; ; ++binCount) {\n                // 插入到链表的最后面(Java7 是插入到链表的最前面)\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    // TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 9 个\n                    // 会触发下面的 treeifyBin，也就是将链表转换为红黑树\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                // 如果在该链表中找到了\"相等\"的 key(== 或 equals)\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    // 此时 break，那么 e 为链表中[与要插入的新值的 key \"相等\"]的 node\n                    break;\n                p = e;\n            }\n        }\n        // e!=null 说明存在旧值的key与要插入的key\"相等\"\n        // 对于我们分析的put操作，下面这个 if 其实就是进行 \"值覆盖\"，然后返回旧值\n        if (e != null) {\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    // 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。\n\n###### 数组扩容\n\nresize() 方法用于**初始化数组或数组扩容**，每次扩容后，容量为原来的 2 倍，并进行数据迁移。\n\n```\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) { // 对应数组扩容\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        // 将数组大小扩大一倍\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            // 将阈值扩大一倍\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候\n        newCap = oldThr;\n    else {// 对应使用 new HashMap() 初始化后，第一次 put 的时候\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n \n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n \n    // 用新的数组大小初始化新的数组\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab; // 如果是初始化数组，到这里就结束了，返回 newTab 即可\n \n    if (oldTab != null) {\n        // 开始遍历原数组，进行数据迁移。\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                // 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                // 如果是红黑树，具体我们就不展开了\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { \n                    // 这块是处理链表的情况，\n                    // 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序\n                    // loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    if (loTail != null) {\n                        loTail.next = null;\n                        // 第一条链表\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        // 第二条链表的新的位置是 j + oldCap，这个很好理解\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n#### get 过程分析\n\n相对于 put 来说，get 真的太简单了。\n\n1. 计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash & (length-1)\n2. 判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步\n3. 判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步\n4. 遍历链表，直到找到相等(==或equals)的 key.\n\n```\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n```\n\n```\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        // 判断第一个节点是不是就是需要的\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        if ((e = first.next) != null) {\n            // 判断是否是红黑树\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n \n            // 链表遍历\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n```\n\n## Java8 ConcurrentHashMap\n\nJava7 中实现的 ConcurrentHashMap 说实话还是比较复杂的，Java8 对 ConcurrentHashMap 进行了比较大的改动。建议读者可以参考 Java8 中 HashMap 相对于 Java7 HashMap 的改动，对于 ConcurrentHashMap，Java8 也引入了红黑树。\n\n说实话，Java8 ConcurrentHashMap 源码真心不简单，最难的在于扩容，数据迁移操作不容易看懂。\n\n我们先用一个示意图来描述下其结构：\n\n![](http://qianniu.javastack.cn/18-12-4/335817.jpg)\n\n结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。推荐阅读：[几种线程安全的Map解析](https://mp.weixin.qq.com/s/5Y5_6qn2g6kIVmQia_0R6g)。\n\n#### 初始化\n\n```\n// 这构造函数里，什么都不干\npublic ConcurrentHashMap() {\n}\npublic ConcurrentHashMap(int initialCapacity) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException();\n    int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ?\n               MAXIMUM_CAPACITY :\n               tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));\n    this.sizeCtl = cap;\n}\n```\n\n这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl = 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。\n\nsizeCtl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。\n\n如果你爱折腾，也可以看下另一个有三个参数的构造方法，这里我就不说了，大部分时候，我们会使用无参构造函数进行实例化，我们也按照这个思路来进行源码分析吧。\n\n#### put 过程分析\n\n仔细地一行一行代码看下去：\n\n```\npublic V put(K key, V value) {\n    return putVal(key, value, false);\n}\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n    if (key == null || value == null) throw new NullPointerException();\n    // 得到 hash 值\n    int hash = spread(key.hashCode());\n    // 用于记录相应链表的长度\n    int binCount = 0;\n    for (Node<K,V>[] tab = table;;) {\n        Node<K,V> f; int n, i, fh;\n        // 如果数组\"空\"，进行数组初始化\n        if (tab == null || (n = tab.length) == 0)\n            // 初始化数组，后面会详细介绍\n            tab = initTable();\n \n        // 找该 hash 值对应的数组下标，得到第一个节点 f\n        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n            // 如果数组该位置为空，\n            //    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了\n            //          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了\n            if (casTabAt(tab, i, null,\n                         new Node<K,V>(hash, key, value, null)))\n                break;                   // no lock when adding to empty bin\n        }\n        // hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容\n        else if ((fh = f.hash) == MOVED)\n            // 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了\n            tab = helpTransfer(tab, f);\n \n        else { // 到这里就是说，f 是该位置的头结点，而且不为空\n \n            V oldVal = null;\n            // 获取数组该位置的头结点的监视器锁\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    if (fh >= 0) { // 头结点的 hash 值大于 0，说明是链表\n                        // 用于累加，记录链表的长度\n                        binCount = 1;\n                        // 遍历链表\n                        for (Node<K,V> e = f;; ++binCount) {\n                            K ek;\n                            // 如果发现了\"相等\"的 key，判断是否要进行值覆盖，然后也就可以 break 了\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                 (ek != null && key.equals(ek)))) {\n                                oldVal = e.val;\n                                if (!onlyIfAbsent)\n                                    e.val = value;\n                                break;\n                            }\n                            // 到了链表的最末端，将这个新值放到链表的最后面\n                            Node<K,V> pred = e;\n                            if ((e = e.next) == null) {\n                                pred.next = new Node<K,V>(hash, key,\n                                                          value, null);\n                                break;\n                            }\n                        }\n                    }\n                    else if (f instanceof TreeBin) { // 红黑树\n                        Node<K,V> p;\n                        binCount = 2;\n                        // 调用红黑树的插值方法插入新节点\n                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                       value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n            // binCount != 0 说明上面在做链表操作\n            if (binCount != 0) {\n                // 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8\n                if (binCount >= TREEIFY_THRESHOLD)\n                    // 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，\n                    // 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树\n                    //    具体源码我们就不看了，扩容部分后面说\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    // \n    addCount(1L, binCount);\n    return null;\n}\n```\n\nput 的主流程看完了，但是至少留下了几个问题，第一个是初始化，第二个是扩容，第三个是帮助数据迁移，这些我们都会在后面进行一一介绍。\n\n###### 初始化数组：initTable\n\n这个比较简单，主要就是初始化一个合适大小的数组，然后会设置 sizeCtl。\n\n初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。\n\n```\nprivate final Node<K,V>[] initTable() {\n    Node<K,V>[] tab; int sc;\n    while ((tab = table) == null || tab.length == 0) {\n        // 初始化的\"功劳\"被其他线程\"抢去\"了\n        if ((sc = sizeCtl) < 0)\n            Thread.yield(); // lost initialization race; just spin\n        // CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁\n        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n            try {\n                if ((tab = table) == null || tab.length == 0) {\n                    // DEFAULT_CAPACITY 默认初始容量是 16\n                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;\n                    // 初始化数组，长度为 16 或初始化时提供的长度\n                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                    // 将这个数组赋值给 table，table 是 volatile 的\n                    table = tab = nt;\n                    // 如果 n 为 16 的话，那么这里 sc = 12\n                    // 其实就是 0.75 * n\n                    sc = n - (n >>> 2);\n                }\n            } finally {\n                // 设置 sizeCtl 为 sc，我们就当是 12 吧\n                sizeCtl = sc;\n            }\n            break;\n        }\n    }\n    return tab;\n}\n```\n\n###### 链表转红黑树: treeifyBin\n\n前面我们在 put 源码分析也说过，treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。\n\n```\nprivate final void treeifyBin(Node<K,V>[] tab, int index) {\n    Node<K,V> b; int n, sc;\n    if (tab != null) {\n        // MIN_TREEIFY_CAPACITY 为 64\n        // 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容\n        if ((n = tab.length) < MIN_TREEIFY_CAPACITY)\n            // 后面我们再详细分析这个方法\n            tryPresize(n << 1);\n        // b 是头结点\n        else if ((b = tabAt(tab, index)) != null && b.hash >= 0) {\n            // 加锁\n            synchronized (b) {\n \n                if (tabAt(tab, index) == b) {\n                    // 下面就是遍历链表，建立一颗红黑树\n                    TreeNode<K,V> hd = null, tl = null;\n                    for (Node<K,V> e = b; e != null; e = e.next) {\n                        TreeNode<K,V> p =\n                            new TreeNode<K,V>(e.hash, e.key, e.val,\n                                              null, null);\n                        if ((p.prev = tl) == null)\n                            hd = p;\n                        else\n                            tl.next = p;\n                        tl = p;\n                    }\n                    // 将红黑树设置到数组相应位置中\n                    setTabAt(tab, index, new TreeBin<K,V>(hd));\n                }\n            }\n        }\n    }\n}\n```\n\n\n#### 扩容：tryPresize\n\n如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。\n\n这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。\n\n这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。\n\n```\n// 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了\nprivate final void tryPresize(int size) {\n    // c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。\n    int c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY :\n        tableSizeFor(size + (size >>> 1) + 1);\n    int sc;\n    while ((sc = sizeCtl) >= 0) {\n        Node<K,V>[] tab = table; int n;\n \n        // 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码\n        if (tab == null || (n = tab.length) == 0) {\n            n = (sc > c) ? sc : c;\n            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n                try {\n                    if (table == tab) {\n                        @SuppressWarnings(\"unchecked\")\n                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                        table = nt;\n                        sc = n - (n >>> 2); // 0.75 * n\n                    }\n                } finally {\n                    sizeCtl = sc;\n                }\n            }\n        }\n        else if (c <= sc || n >= MAXIMUM_CAPACITY)\n            break;\n        else if (tab == table) {\n            // 我没看懂 rs 的真正含义是什么，不过也关系不大\n            int rs = resizeStamp(n);\n \n            if (sc < 0) {\n                Node<K,V>[] nt;\n                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||\n                    transferIndex <= 0)\n                    break;\n                // 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法\n                //    此时 nextTab 不为 null\n                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))\n                    transfer(tab, nt);\n            }\n            // 1. 将 sizeCtl 设置为 (rs << RESIZE_STAMP_SHIFT) + 2)\n            //     我是没看懂这个值真正的意义是什么？不过可以计算出来的是，结果是一个比较大的负数\n            //  调用 transfer 方法，此时 nextTab 参数为 null\n            else if (U.compareAndSwapInt(this, SIZECTL, sc,\n                                         (rs << RESIZE_STAMP_SHIFT) + 2))\n                transfer(tab, null);\n        }\n    }\n}\n```\n\n这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。\n\n所以，可能的操作就是执行 **1 次 transfer(tab, null) + 多次 transfer(tab, nt)**，这里怎么结束循环的需要看完 transfer 源码才清楚。推荐阅读：[30 个 Java 集合面试问题及答案](https://mp.weixin.qq.com/s/Q5F604CUM_0x2co9mvADxw)。\n\n###### 数据迁移：transfer\n\n下面这个方法很点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。\n\n虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。\n\n此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。\n\n阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 stride，简单理解就是步长，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。\n\n第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后从后往前的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。\n\n```\nprivate final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {\n    int n = tab.length, stride;\n \n    // stride 在单核下直接等于 n，多核模式下为 (n>>>3)/NCPU，最小值是 16\n    // stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，\n    //   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务\n    if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)\n        stride = MIN_TRANSFER_STRIDE; // subdivide range\n \n    // 如果 nextTab 为 null，先进行一次初始化\n    //    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null\n    //       之后参与迁移的线程调用此方法时，nextTab 不会为 null\n    if (nextTab == null) {\n        try {\n            // 容量翻倍\n            Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];\n            nextTab = nt;\n        } catch (Throwable ex) {      // try to cope with OOME\n            sizeCtl = Integer.MAX_VALUE;\n            return;\n        }\n        // nextTable 是 ConcurrentHashMap 中的属性\n        nextTable = nextTab;\n        // transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置\n        transferIndex = n;\n    }\n \n    int nextn = nextTab.length;\n \n    // ForwardingNode 翻译过来就是正在被迁移的 Node\n    // 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED\n    // 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，\n    //    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了\n    //    所以它其实相当于是一个标志。\n    ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);\n \n \n    // advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了\n    boolean advance = true;\n    boolean finishing = false; // to ensure sweep before committing nextTab\n \n    /*\n     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看\n     * \n     */\n \n    // i 是位置索引，bound 是边界，注意是从后往前\n    for (int i = 0, bound = 0;;) {\n        Node<K,V> f; int fh;\n \n        // 下面这个 while 真的是不好理解\n        // advance 为 true 表示可以进行下一个位置的迁移了\n        //   简单理解结局：i 指向了 transferIndex，bound 指向了 transferIndex-stride\n        while (advance) {\n            int nextIndex, nextBound;\n            if (--i >= bound || finishing)\n                advance = false;\n \n            // 将 transferIndex 值赋给 nextIndex\n            // 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了\n            else if ((nextIndex = transferIndex) <= 0) {\n                i = -1;\n                advance = false;\n            }\n            else if (U.compareAndSwapInt\n                     (this, TRANSFERINDEX, nextIndex,\n                      nextBound = (nextIndex > stride ?\n                                   nextIndex - stride : 0))) {\n                // 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前\n                bound = nextBound;\n                i = nextIndex - 1;\n                advance = false;\n            }\n        }\n        if (i < 0 || i >= n || i + n >= nextn) {\n            int sc;\n            if (finishing) {\n                // 所有的迁移操作已经完成\n                nextTable = null;\n                // 将新的 nextTab 赋值给 table 属性，完成迁移\n                table = nextTab;\n                // 重新计算 sizeCtl：n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍\n                sizeCtl = (n << 1) - (n >>> 1);\n                return;\n            }\n \n            // 之前我们说过，sizeCtl 在迁移前会设置为 (rs << RESIZE_STAMP_SHIFT) + 2\n            // 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，\n            // 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务\n            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {\n                // 任务结束，方法退出\n                if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)\n                    return;\n \n                // 到这里，说明 (sc - 2) == resizeStamp(n) << RESIZE_STAMP_SHIFT，\n                // 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing){} 分支了\n                finishing = advance = true;\n                i = n; // recheck before commit\n            }\n        }\n        // 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“\n        else if ((f = tabAt(tab, i)) == null)\n            advance = casTabAt(tab, i, null, fwd);\n        // 该位置处是一个 ForwardingNode，代表该位置已经迁移过了\n        else if ((fh = f.hash) == MOVED)\n            advance = true; // already processed\n        else {\n            // 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    Node<K,V> ln, hn;\n                    // 头结点的 hash 大于 0，说明是链表的 Node 节点\n                    if (fh >= 0) {\n                        // 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，\n                        // 需要将链表一分为二，\n                        //   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的\n                        //   lastRun 之前的节点需要进行克隆，然后分到两个链表中\n                        int runBit = fh & n;\n                        Node<K,V> lastRun = f;\n                        for (Node<K,V> p = f.next; p != null; p = p.next) {\n                            int b = p.hash & n;\n                            if (b != runBit) {\n                                runBit = b;\n                                lastRun = p;\n                            }\n                        }\n                        if (runBit == 0) {\n                            ln = lastRun;\n                            hn = null;\n                        }\n                        else {\n                            hn = lastRun;\n                            ln = null;\n                        }\n                        for (Node<K,V> p = f; p != lastRun; p = p.next) {\n                            int ph = p.hash; K pk = p.key; V pv = p.val;\n                            if ((ph & n) == 0)\n                                ln = new Node<K,V>(ph, pk, pv, ln);\n                            else\n                                hn = new Node<K,V>(ph, pk, pv, hn);\n                        }\n                        // 其中的一个链表放在新数组的位置 i\n                        setTabAt(nextTab, i, ln);\n                        // 另一个链表放在新数组的位置 i+n\n                        setTabAt(nextTab, i + n, hn);\n                        // 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，\n                        //    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了\n                        setTabAt(tab, i, fwd);\n                        // advance 设置为 true，代表该位置已经迁移完毕\n                        advance = true;\n                    }\n                    else if (f instanceof TreeBin) {\n                        // 红黑树的迁移\n                        TreeBin<K,V> t = (TreeBin<K,V>)f;\n                        TreeNode<K,V> lo = null, loTail = null;\n                        TreeNode<K,V> hi = null, hiTail = null;\n                        int lc = 0, hc = 0;\n                        for (Node<K,V> e = t.first; e != null; e = e.next) {\n                            int h = e.hash;\n                            TreeNode<K,V> p = new TreeNode<K,V>\n                                (h, e.key, e.val, null, null);\n                            if ((h & n) == 0) {\n                                if ((p.prev = loTail) == null)\n                                    lo = p;\n                                else\n                                    loTail.next = p;\n                                loTail = p;\n                                ++lc;\n                            }\n                            else {\n                                if ((p.prev = hiTail) == null)\n                                    hi = p;\n                                else\n                                    hiTail.next = p;\n                                hiTail = p;\n                                ++hc;\n                            }\n                        }\n                        // 如果一分为二后，节点数少于 8，那么将红黑树转换回链表\n                        ln = (lc <= UNTREEIFY_THRESHOLD) ? untreeify(lo) :\n                            (hc != 0) ? new TreeBin<K,V>(lo) : t;\n                        hn = (hc <= UNTREEIFY_THRESHOLD) ? untreeify(hi) :\n                            (lc != 0) ? new TreeBin<K,V>(hi) : t;\n \n                        // 将 ln 放置在新数组的位置 i\n                        setTabAt(nextTab, i, ln);\n                        // 将 hn 放置在新数组的位置 i+n\n                        setTabAt(nextTab, i + n, hn);\n                        // 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，\n                        //    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了\n                        setTabAt(tab, i, fwd);\n                        // advance 设置为 true，代表该位置已经迁移完毕\n                        advance = true;\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。\n\n这个时候，再回去仔细看 tryPresize 方法可能就会更加清晰一些了。\n\n#### get 过程分析\n\nget 方法从来都是最简单的，这里也不例外：\n\n1.计算 hash 值\n\n2.根据 hash 值找到数组对应位置: (n – 1) & h\n\n3.根据该位置处结点性质进行相应查找\n\n- 如果该位置为 null，那么直接返回 null 就可以了\n- 如果该位置处的节点刚好就是我们需要的，返回该节点的值即可\n- 如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法\n- 如果以上 3 条都不满足，那就是链表，进行遍历比对即可。\n\n```\npublic V get(Object key) {\n    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;\n    int h = spread(key.hashCode());\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (e = tabAt(tab, (n - 1) & h)) != null) {\n        // 判断头结点是否就是我们需要的节点\n        if ((eh = e.hash) == h) {\n            if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                return e.val;\n        }\n        // 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树\n        else if (eh < 0)\n            // 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)\n            return (p = e.find(h, key)) != null ? p.val : null;\n \n        // 遍历链表\n        while ((e = e.next) != null) {\n            if (e.hash == h &&\n                ((ek = e.key) == key || (ek != null && key.equals(ek))))\n                return e.val;\n        }\n    }\n    return null;\n}\n```\n\n简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，ForwardingNode.find(int h, Object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了，所以限于篇幅这里也不展开说了。\n\n## 总结\n\n其实也不是很难嘛，虽然没有像之前的 AQS 和线程池一样一行一行源码进行分析，但还是把所有初学者可能会糊涂的地方都进行了深入的介绍，只要是稍微有点基础的读者，应该是很容易就能看懂 HashMap 和 ConcurrentHashMap 源码了。\n\n看源码不算是目的吧，深入地了解 Doug Lea 的设计思路，我觉得还挺有趣的，大师就是大师，代码写得真的是好啊。\n\n我发现很多人都以为我写博客主要是源码分析，说真的，我对于源码分析没有那么大热情，主要都是为了用源码说事罢了，可能之后的文章还是会有比较多的源码分析成分，大家该怎么看就怎么看吧。\n\n不要脸地自以为本文的质量还是挺高的，信息量比较大，如果你觉得有写得不好的地方，或者说看完本文你还是没看懂它们，那么请提出来~~~\n\n","slug":"集合/HashMap, ConcurrentHashMap 原理及源码","published":1,"updated":"2025-10-15T07:21:29.773Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu07710051qkd4az5ndksw","content":"<p>网上关于 HashMap 和 ConcurrentHashMap 的文章确实不少，不过缺斤少两的文章比较多，所以才想自己也写一篇，把细节说清楚说透，尤其像 Java8 中的 ConcurrentHashMap，大部分文章都说不清楚。终归是希望能降低大家学习的成本，不希望大家到处找各种不是很靠谱的文章，看完一篇又一篇，可是还是模模糊糊。</p>\n<p><strong>阅读建议：</strong> 四节基本上可以进行独立阅读，建议初学者可按照以下顺序进行阅读，可适当降低阅读门槛。</p>\n<blockquote>\n<p>Java7 HashMap -&gt; Java7 ConcurrentHashMap -&gt; Java8 HashMap -&gt; Java8 ConcurrentHashMap </p>\n</blockquote>\n<p><strong>阅读前提：</strong> 本文分析的是源码，所以至少读者要熟悉它们的接口使用，同时，对于并发，读者至少要知道 CAS、ReentrantLock、UNSAFE 操作这几个基本的知识，文中不会对这些知识进行介绍。Java8 用到了红黑树，不过本文不会进行展开，感兴趣的读者请自行查找相关资料。</p>\n<h2 id=\"Java7-HashMap\"><a href=\"#Java7-HashMap\" class=\"headerlink\" title=\"Java7 HashMap\"></a>Java7 HashMap</h2><p>HashMap 是最简单的，一来我们非常熟悉，二来就是它不支持并发操作，所以源码也非常简单。</p>\n<p>首先，我们用下面这张图来介绍 HashMap 的结构。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-12-4/65827660.jpg\"></p>\n<p>这个仅仅是示意图，因为没有考虑到数组要扩容的情况，具体的后面再说。</p>\n<p>大方向上，HashMap 里面是一个<strong>数组</strong>，然后数组中每个元素是一个<strong>单向链表</strong>。</p>\n<p>上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。</p>\n<p>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</p>\n<p>loadFactor：负载因子，默认为 0.75。</p>\n<p>threshold：扩容的阈值，等于 capacity * loadFactor</p>\n<h4 id=\"put-过程分析\"><a href=\"#put-过程分析\" class=\"headerlink\" title=\"put 过程分析\"></a>put 过程分析</h4><p>还是比较简单的，跟着代码走一遍吧。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public V put(K key, V value) &#123;\n    &#x2F;&#x2F; 当插入第一个元素的时候，需要先初始化数组大小\n    if (table &#x3D;&#x3D; EMPTY_TABLE) &#123;\n        inflateTable(threshold);\n    &#125;\n    &#x2F;&#x2F; 如果 key 为 null，感兴趣的可以往里看，最终会将这个 entry 放到 table[0] 中\n    if (key &#x3D;&#x3D; null)\n        return putForNullKey(value);\n    &#x2F;&#x2F; 1. 求 key 的 hash 值\n    int hash &#x3D; hash(key);\n    &#x2F;&#x2F; 2. 找到对应的数组下标\n    int i &#x3D; indexFor(hash, table.length);\n    &#x2F;&#x2F; 3. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在，\n    &#x2F;&#x2F;    如果有，直接覆盖，put 方法返回旧值就结束了\n    for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;\n        Object k;\n        if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))) &#123;\n            V oldValue &#x3D; e.value;\n            e.value &#x3D; value;\n            e.recordAccess(this);\n            return oldValue;\n        &#125;\n    &#125;\n \n    modCount++;\n    &#x2F;&#x2F; 4. 不存在重复的 key，将此 entry 添加到链表中，细节后面说\n    addEntry(hash, key, value, i);\n    return null;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h6 id=\"数组初始化\"><a href=\"#数组初始化\" class=\"headerlink\" title=\"数组初始化\"></a>数组初始化</h6><p>在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private void inflateTable(int toSize) &#123;\n    &#x2F;&#x2F; 保证数组大小一定是 2 的 n 次方。\n    &#x2F;&#x2F; 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32\n    int capacity &#x3D; roundUpToPowerOf2(toSize);\n    &#x2F;&#x2F; 计算扩容阈值：capacity * loadFactor\n    threshold &#x3D; (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);\n    &#x2F;&#x2F; 算是初始化数组吧\n    table &#x3D; new Entry[capacity];\n    initHashSeedAsNeeded(capacity); &#x2F;&#x2F;ignore\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里有一个将数组大小保持为 2 的 n 次方的做法，Java7 和 Java8 的 HashMap 和 ConcurrentHashMap 都有相应的要求，只不过实现的代码稍微有些不同，后面再看到的时候就知道了。</p>\n<h6 id=\"计算具体数组位置\"><a href=\"#计算具体数组位置\" class=\"headerlink\" title=\"计算具体数组位置\"></a>计算具体数组位置</h6><p>这个简单，我们自己也能 YY 一个：使用 key 的 hash 值对数组长度进行取模就可以了。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">static int indexFor(int hash, int length) &#123;\n    &#x2F;&#x2F; assert Integer.bitCount(length) &#x3D;&#x3D; 1 : &quot;length must be a non-zero power of 2&quot;;\n    return hash &amp; (length-1);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。</p>\n<h6 id=\"添加节点到链表中\"><a href=\"#添加节点到链表中\" class=\"headerlink\" title=\"添加节点到链表中\"></a>添加节点到链表中</h6><p>找到数组下标后，会先进行 key 判重，如果没有重复，就准备将新值放入到链表的表头。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">void addEntry(int hash, K key, V value, int bucketIndex) &#123;\n    &#x2F;&#x2F; 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容\n    if ((size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[bucketIndex])) &#123;\n        &#x2F;&#x2F; 扩容，后面会介绍一下\n        resize(2 * table.length);\n        &#x2F;&#x2F; 扩容以后，重新计算 hash 值\n        hash &#x3D; (null !&#x3D; key) ? hash(key) : 0;\n        &#x2F;&#x2F; 重新计算扩容后的新的下标\n        bucketIndex &#x3D; indexFor(hash, table.length);\n    &#125;\n    &#x2F;&#x2F; 往下看\n    createEntry(hash, key, value, bucketIndex);\n&#125;\n\n&#x2F;&#x2F; 这个很简单，其实就是将新值放到链表的表头，然后 size++\nvoid createEntry(int hash, K key, V value, int bucketIndex) &#123;\n    Entry&lt;K,V&gt; e &#x3D; table[bucketIndex];\n    table[bucketIndex] &#x3D; new Entry&lt;&gt;(hash, key, value, e);\n    size++;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。</p>\n<h6 id=\"数组扩容\"><a href=\"#数组扩容\" class=\"headerlink\" title=\"数组扩容\"></a>数组扩容</h6><p>前面我们看到，在插入新值的时候，如果当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">void resize(int newCapacity) &#123;\n    Entry[] oldTable &#x3D; table;\n    int oldCapacity &#x3D; oldTable.length;\n    if (oldCapacity &#x3D;&#x3D; MAXIMUM_CAPACITY) &#123;\n        threshold &#x3D; Integer.MAX_VALUE;\n        return;\n    &#125;\n    &#x2F;&#x2F; 新的数组\n    Entry[] newTable &#x3D; new Entry[newCapacity];\n    &#x2F;&#x2F; 将原来数组中的值迁移到新的更大的数组中\n    transfer(newTable, initHashSeedAsNeeded(newCapacity));\n    table &#x3D; newTable;\n    threshold &#x3D; (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</p>\n<p>由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。代码比较简单，这里就不展开了。</p>\n<h4 id=\"get-过程分析\"><a href=\"#get-过程分析\" class=\"headerlink\" title=\"get 过程分析\"></a>get 过程分析</h4><p>相对于 put 过程，get 过程是非常简单的。</p>\n<ol>\n<li>根据 key 计算 hash 值。</li>\n<li>找到相应的数组下标：hash &amp; (length – 1)。</li>\n<li>遍历该数组位置处的链表，直到找到相等(&#x3D;&#x3D;或equals)的 key。</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public V get(Object key) &#123;\n    &#x2F;&#x2F; 之前说过，key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了\n    if (key &#x3D;&#x3D; null)\n        return getForNullKey();\n    &#x2F;&#x2F; \n    Entry&lt;K,V&gt; entry &#x3D; getEntry(key);\n \n    return null &#x3D;&#x3D; entry ? null : entry.getValue();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>getEntry(key):</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final Entry&lt;K,V&gt; getEntry(Object key) &#123;\n    if (size &#x3D;&#x3D; 0) &#123;\n        return null;\n    &#125;\n \n    int hash &#x3D; (key &#x3D;&#x3D; null) ? 0 : hash(key);\n    &#x2F;&#x2F; 确定数组下标，然后从头开始遍历链表，直到找到为止\n    for (Entry&lt;K,V&gt; e &#x3D; table[indexFor(hash, table.length)];\n         e !&#x3D; null;\n         e &#x3D; e.next) &#123;\n        Object k;\n        if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n            ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n            return e;\n    &#125;\n    return null;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"Java7-ConcurrentHashMap\"><a href=\"#Java7-ConcurrentHashMap\" class=\"headerlink\" title=\"Java7 ConcurrentHashMap\"></a>Java7 ConcurrentHashMap</h2><p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。</p>\n<p>整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为<strong>分段锁</strong>。注意，行文中，我很多地方用了 <strong>“槽”</strong> 来代表一个 segment。</p>\n<p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。推荐阅读：<a href=\"https://mp.weixin.qq.com/s/0CI9od4DIxRrmOGFJw0SuQ\">史上最全 Java 多线程面试题及答案</a>。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-12-4/75121838.jpg\"></p>\n<p><strong>concurrencyLevel：</strong> 并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</p>\n<p>再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。推荐阅读：<a href=\"https://mp.weixin.qq.com/s/5Y5_6qn2g6kIVmQia_0R6g\">几种线程安全的Map解析</a>。</p>\n<h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><p>initialCapacity：初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。</p>\n<p>loadFactor：负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public ConcurrentHashMap(int initialCapacity,\n                         float loadFactor, int concurrencyLevel) &#123;\n    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0)\n        throw new IllegalArgumentException();\n    if (concurrencyLevel &gt; MAX_SEGMENTS)\n        concurrencyLevel &#x3D; MAX_SEGMENTS;\n    &#x2F;&#x2F; Find power-of-two sizes best matching arguments\n    int sshift &#x3D; 0;\n    int ssize &#x3D; 1;\n    &#x2F;&#x2F; 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方\n    while (ssize &lt; concurrencyLevel) &#123;\n        ++sshift;\n        ssize &lt;&lt;&#x3D; 1;\n    &#125;\n    &#x2F;&#x2F; 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4\n    &#x2F;&#x2F; 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值\n    this.segmentShift &#x3D; 32 - sshift;\n    this.segmentMask &#x3D; ssize - 1;\n \n    if (initialCapacity &gt; MAXIMUM_CAPACITY)\n        initialCapacity &#x3D; MAXIMUM_CAPACITY;\n \n    &#x2F;&#x2F; initialCapacity 是设置整个 map 初始的大小，\n    &#x2F;&#x2F; 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小\n    &#x2F;&#x2F; 如 initialCapacity 为 64，那么每个 Segment 或称之为&quot;槽&quot;可以分到 4 个\n    int c &#x3D; initialCapacity &#x2F; ssize;\n    if (c * ssize &lt; initialCapacity)\n        ++c;\n    &#x2F;&#x2F; 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，\n    &#x2F;&#x2F; 插入一个元素不至于扩容，插入第二个的时候才会扩容\n    int cap &#x3D; MIN_SEGMENT_TABLE_CAPACITY; \n    while (cap &lt; c)\n        cap &lt;&lt;&#x3D; 1;\n \n    &#x2F;&#x2F; 创建 Segment 数组，\n    &#x2F;&#x2F; 并创建数组的第一个元素 segment[0]\n    Segment&lt;K,V&gt; s0 &#x3D;\n        new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),\n                         (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);\n    Segment&lt;K,V&gt;[] ss &#x3D; (Segment&lt;K,V&gt;[])new Segment[ssize];\n    &#x2F;&#x2F; 往数组写入 segment[0]\n    UNSAFE.putOrderedObject(ss, SBASE, s0); &#x2F;&#x2F; ordered write of segments[0]\n    this.segments &#x3D; ss;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>初始化完成，我们得到了一个 Segment 数组。</p>\n<p>我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后：</p>\n<ul>\n<li>Segment 数组长度为 16，不可以扩容</li>\n<li>Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容</li>\n<li>这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍</li>\n<li>当前 segmentShift 的值为 32 – 4 &#x3D; 28，segmentMask 为 16 – 1 &#x3D; 15，姑且把它们简单翻译为移位数和掩码，这两个值马上就会用到。</li>\n</ul>\n<h4 id=\"put-过程分析-1\"><a href=\"#put-过程分析-1\" class=\"headerlink\" title=\"put 过程分析\"></a>put 过程分析</h4><p>我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public V put(K key, V value) &#123;\n    Segment&lt;K,V&gt; s;\n    if (value &#x3D;&#x3D; null)\n        throw new NullPointerException();\n    &#x2F;&#x2F; 1. 计算 key 的 hash 值\n    int hash &#x3D; hash(key);\n    &#x2F;&#x2F; 2. 根据 hash 值找到 Segment 数组中的位置 j\n    &#x2F;&#x2F;    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下低 4 位，\n    &#x2F;&#x2F;    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的最后 4 位，也就是槽的数组下标\n    int j &#x3D; (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;\n    &#x2F;&#x2F; 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，\n    &#x2F;&#x2F; ensureSegment(j) 对 segment[j] 进行初始化\n    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObject          &#x2F;&#x2F; nonvolatile; recheck\n         (segments, (j &lt;&lt; SSHIFT) + SBASE)) &#x3D;&#x3D; null) &#x2F;&#x2F;  in ensureSegment\n        s &#x3D; ensureSegment(j);\n    &#x2F;&#x2F; 3. 插入新值到 槽 s 中\n    return s.put(key, hash, value, false);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。</p>\n<p>Segment 内部是由 <strong>数组+链表</strong> 组成的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;\n    &#x2F;&#x2F; 在往该 segment 写入前，需要先获取该 segment 的独占锁\n    &#x2F;&#x2F;    先看主流程，后面还会具体介绍这部分内容\n    HashEntry&lt;K,V&gt; node &#x3D; tryLock() ? null :\n        scanAndLockForPut(key, hash, value);\n    V oldValue;\n    try &#123;\n        &#x2F;&#x2F; 这个是 segment 内部的数组\n        HashEntry&lt;K,V&gt;[] tab &#x3D; table;\n        &#x2F;&#x2F; 再利用 hash 值，求应该放置的数组下标\n        int index &#x3D; (tab.length - 1) &amp; hash;\n        &#x2F;&#x2F; first 是数组该位置处的链表的表头\n        HashEntry&lt;K,V&gt; first &#x3D; entryAt(tab, index);\n \n        &#x2F;&#x2F; 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况\n        for (HashEntry&lt;K,V&gt; e &#x3D; first;;) &#123;\n            if (e !&#x3D; null) &#123;\n                K k;\n                if ((k &#x3D; e.key) &#x3D;&#x3D; key ||\n                    (e.hash &#x3D;&#x3D; hash &amp;&amp; key.equals(k))) &#123;\n                    oldValue &#x3D; e.value;\n                    if (!onlyIfAbsent) &#123;\n                        &#x2F;&#x2F; 覆盖旧值\n                        e.value &#x3D; value;\n                        ++modCount;\n                    &#125;\n                    break;\n                &#125;\n                &#x2F;&#x2F; 继续顺着链表走\n                e &#x3D; e.next;\n            &#125;\n            else &#123;\n                &#x2F;&#x2F; node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。\n                &#x2F;&#x2F; 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。\n                if (node !&#x3D; null)\n                    node.setNext(first);\n                else\n                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, first);\n \n                int c &#x3D; count + 1;\n                &#x2F;&#x2F; 如果超过了该 segment 的阈值，这个 segment 需要扩容\n                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)\n                    rehash(node); &#x2F;&#x2F; 扩容后面也会具体分析\n                else\n                    &#x2F;&#x2F; 没有达到阈值，将 node 放到数组 tab 的 index 位置，\n                    &#x2F;&#x2F; 其实就是将新的节点设置成原链表的表头\n                    setEntryAt(tab, index, node);\n                ++modCount;\n                count &#x3D; c;\n                oldValue &#x3D; null;\n                break;\n            &#125;\n        &#125;\n    &#125; finally &#123;\n        &#x2F;&#x2F; 解锁\n        unlock();\n    &#125;\n    return oldValue;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。</p>\n<p>到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。</p>\n<h6 id=\"初始化槽-ensureSegment\"><a href=\"#初始化槽-ensureSegment\" class=\"headerlink\" title=\"初始化槽: ensureSegment\"></a>初始化槽: ensureSegment</h6><p>ConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。</p>\n<p>这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private Segment&lt;K,V&gt; ensureSegment(int k) &#123;\n    final Segment&lt;K,V&gt;[] ss &#x3D; this.segments;\n    long u &#x3D; (k &lt;&lt; SSHIFT) + SBASE; &#x2F;&#x2F; raw offset\n    Segment&lt;K,V&gt; seg;\n    if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) &#x3D;&#x3D; null) &#123;\n        &#x2F;&#x2F; 这里看到为什么之前要初始化 segment[0] 了，\n        &#x2F;&#x2F; 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]\n        &#x2F;&#x2F; 为什么要用“当前”，因为 segment[0] 可能早就扩容过了\n        Segment&lt;K,V&gt; proto &#x3D; ss[0];\n        int cap &#x3D; proto.table.length;\n        float lf &#x3D; proto.loadFactor;\n        int threshold &#x3D; (int)(cap * lf);\n \n        &#x2F;&#x2F; 初始化 segment[k] 内部的数组\n        HashEntry&lt;K,V&gt;[] tab &#x3D; (HashEntry&lt;K,V&gt;[])new HashEntry[cap];\n        if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))\n            &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 再次检查一遍该槽是否被其他线程初始化了。\n \n            Segment&lt;K,V&gt; s &#x3D; new Segment&lt;K,V&gt;(lf, threshold, tab);\n            &#x2F;&#x2F; 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出\n            while ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))\n                   &#x3D;&#x3D; null) &#123;\n                if (UNSAFE.compareAndSwapObject(ss, u, null, seg &#x3D; s))\n                    break;\n            &#125;\n        &#125;\n    &#125;\n    return seg;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>总的来说，ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。</p>\n<blockquote>\n<p>如果当前线程 CAS 失败，这里的 while 循环是为了将 seg 赋值返回。</p>\n</blockquote>\n<h6 id=\"获取写入锁-scanAndLockForPut\"><a href=\"#获取写入锁-scanAndLockForPut\" class=\"headerlink\" title=\"获取写入锁: scanAndLockForPut\"></a>获取写入锁: scanAndLockForPut</h6><p>前面我们看到，在往某个 segment 中 put 的时候，首先会调用 node &#x3D; tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。</p>\n<p>下面我们来具体分析这个方法中是怎么控制加锁的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;\n    HashEntry&lt;K,V&gt; first &#x3D; entryForHash(this, hash);\n    HashEntry&lt;K,V&gt; e &#x3D; first;\n    HashEntry&lt;K,V&gt; node &#x3D; null;\n    int retries &#x3D; -1; &#x2F;&#x2F; negative while locating node\n \n    &#x2F;&#x2F; 循环获取锁\n    while (!tryLock()) &#123;\n        HashEntry&lt;K,V&gt; f; &#x2F;&#x2F; to recheck first below\n        if (retries &lt; 0) &#123;\n            if (e &#x3D;&#x3D; null) &#123;\n                if (node &#x3D;&#x3D; null) &#x2F;&#x2F; speculatively create node\n                    &#x2F;&#x2F; 进到这里说明数组该位置的链表是空的，没有任何元素\n                    &#x2F;&#x2F; 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置\n                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, null);\n                retries &#x3D; 0;\n            &#125;\n            else if (key.equals(e.key))\n                retries &#x3D; 0;\n            else\n                &#x2F;&#x2F; 顺着链表往下走\n                e &#x3D; e.next;\n        &#125;\n        &#x2F;&#x2F; 重试次数如果超过 MAX_SCAN_RETRIES（单核1多核64），那么不抢了，进入到阻塞队列等待锁\n        &#x2F;&#x2F;    lock() 是阻塞方法，直到获取锁后返回\n        else if (++retries &gt; MAX_SCAN_RETRIES) &#123;\n            lock();\n            break;\n        &#125;\n        else if ((retries &amp; 1) &#x3D;&#x3D; 0 &amp;&amp;\n                 &#x2F;&#x2F; 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头\n                 &#x2F;&#x2F;     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法\n                 (f &#x3D; entryForHash(this, hash)) !&#x3D; first) &#123;\n            e &#x3D; first &#x3D; f; &#x2F;&#x2F; re-traverse if entry changed\n            retries &#x3D; -1;\n        &#125;\n    &#125;\n    return node;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。</p>\n<p>这个方法就是看似复杂，但是其实就是做了一件事，那就是<strong>获取该 segment 的独占锁</strong>，如果需要的话顺便实例化了一下 node。</p>\n<h6 id=\"扩容-rehash\"><a href=\"#扩容-rehash\" class=\"headerlink\" title=\"扩容: rehash\"></a>扩容: rehash</h6><p>重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry[] 进行扩容，扩容后，容量为原来的 2 倍。</p>\n<p>首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。</p>\n<p>该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。\nprivate void rehash(HashEntry&lt;K,V&gt; node) &#123;\n    HashEntry&lt;K,V&gt;[] oldTable &#x3D; table;\n    int oldCapacity &#x3D; oldTable.length;\n    &#x2F;&#x2F; 2 倍\n    int newCapacity &#x3D; oldCapacity &lt;&lt; 1;\n    threshold &#x3D; (int)(newCapacity * loadFactor);\n    &#x2F;&#x2F; 创建新数组\n    HashEntry&lt;K,V&gt;[] newTable &#x3D;\n        (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];\n    &#x2F;&#x2F; 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’\n    int sizeMask &#x3D; newCapacity - 1;\n \n    &#x2F;&#x2F; 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置\n    for (int i &#x3D; 0; i &lt; oldCapacity ; i++) &#123;\n        &#x2F;&#x2F; e 是链表的第一个元素\n        HashEntry&lt;K,V&gt; e &#x3D; oldTable[i];\n        if (e !&#x3D; null) &#123;\n            HashEntry&lt;K,V&gt; next &#x3D; e.next;\n            &#x2F;&#x2F; 计算应该放置在新数组中的位置，\n            &#x2F;&#x2F; 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 &#x3D; 19\n            int idx &#x3D; e.hash &amp; sizeMask;\n            if (next &#x3D;&#x3D; null)   &#x2F;&#x2F; 该位置处只有一个元素，那比较好办\n                newTable[idx] &#x3D; e;\n            else &#123; &#x2F;&#x2F; Reuse consecutive sequence at same slot\n                &#x2F;&#x2F; e 是链表表头\n                HashEntry&lt;K,V&gt; lastRun &#x3D; e;\n                &#x2F;&#x2F; idx 是当前链表的头结点 e 的新位置\n                int lastIdx &#x3D; idx;\n \n                &#x2F;&#x2F; 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的\n                for (HashEntry&lt;K,V&gt; last &#x3D; next;\n                     last !&#x3D; null;\n                     last &#x3D; last.next) &#123;\n                    int k &#x3D; last.hash &amp; sizeMask;\n                    if (k !&#x3D; lastIdx) &#123;\n                        lastIdx &#x3D; k;\n                        lastRun &#x3D; last;\n                    &#125;\n                &#125;\n                &#x2F;&#x2F; 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置\n                newTable[lastIdx] &#x3D; lastRun;\n                &#x2F;&#x2F; 下面的操作是处理 lastRun 之前的节点，\n                &#x2F;&#x2F;    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中\n                for (HashEntry&lt;K,V&gt; p &#x3D; e; p !&#x3D; lastRun; p &#x3D; p.next) &#123;\n                    V v &#x3D; p.value;\n                    int h &#x3D; p.hash;\n                    int k &#x3D; h &amp; sizeMask;\n                    HashEntry&lt;K,V&gt; n &#x3D; newTable[k];\n                    newTable[k] &#x3D; new HashEntry&lt;K,V&gt;(h, p.key, v, n);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部\n    int nodeIndex &#x3D; node.hash &amp; sizeMask; &#x2F;&#x2F; add the new node\n    node.setNext(newTable[nodeIndex]);\n    newTable[nodeIndex] &#x3D; node;\n    table &#x3D; newTable;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢？</p>\n<p>仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。</p>\n<p>我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。<strong>不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1&#x2F;6 的节点需要克隆。</strong></p>\n<h4 id=\"get-过程分析-1\"><a href=\"#get-过程分析-1\" class=\"headerlink\" title=\"get 过程分析\"></a>get 过程分析</h4><p>相对于 put 来说，get 真的不要太简单。</p>\n<ol>\n<li>计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”</li>\n<li>槽中也是一个数组，根据 hash 找到数组中具体的位置</li>\n<li>到这里是链表了，顺着链表进行查找即可</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public V get(Object key) &#123;\n    Segment&lt;K,V&gt; s; &#x2F;&#x2F; manually integrate access methods to reduce overhead\n    HashEntry&lt;K,V&gt;[] tab;\n    &#x2F;&#x2F; 1. hash 值\n    int h &#x3D; hash(key);\n    long u &#x3D; (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;\n    &#x2F;&#x2F; 2. 根据 hash 找到对应的 segment\n    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) !&#x3D; null &amp;&amp;\n        (tab &#x3D; s.table) !&#x3D; null) &#123;\n        &#x2F;&#x2F; 3. 找到segment 内部数组相应位置的链表，遍历\n        for (HashEntry&lt;K,V&gt; e &#x3D; (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile\n                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);\n             e !&#x3D; null; e &#x3D; e.next) &#123;\n            K k;\n            if ((k &#x3D; e.key) &#x3D;&#x3D; key || (e.hash &#x3D;&#x3D; h &amp;&amp; key.equals(k)))\n                return e.value;\n        &#125;\n    &#125;\n    return null;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"并发问题分析\"><a href=\"#并发问题分析\" class=\"headerlink\" title=\"并发问题分析\"></a>并发问题分析</h4><p>现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。</p>\n<p>添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。推荐阅读：<a href=\"https://mp.weixin.qq.com/s/Q5F604CUM_0x2co9mvADxw\">30 个 Java 集合面试问题及答案</a>。</p>\n<ul>\n<li><strong>put 操作的线程安全性</strong></li>\n</ul>\n<ol>\n<li>初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。</li>\n<li>添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。</li>\n<li>扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。</li>\n</ol>\n<ul>\n<li><strong>remove 操作的线程安全性</strong></li>\n</ul>\n<p>remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。</p>\n<p>get 操作需要遍历链表，但是 remove 操作会”破坏”链表。</p>\n<p>如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。</p>\n<p>如果 remove 先破坏了一个节点，分两种情况考虑。</p>\n<p>1、如果此节点是头结点，那么需要将头结点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。</p>\n<p>2、如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。推荐阅读：<a href=\"https://mp.weixin.qq.com/s/0CI9od4DIxRrmOGFJw0SuQ\">史上最全 Java 多线程面试题及答案</a>。</p>\n<h2 id=\"Java8-HashMap\"><a href=\"#Java8-HashMap\" class=\"headerlink\" title=\"Java8 HashMap\"></a>Java8 HashMap</h2><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 <strong>数组+链表+红黑树</strong> 组成。</p>\n<p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 **O(n)**。</p>\n<p>为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p>\n<p>来一张图简单示意一下吧：</p>\n<p><img src=\"http://qianniu.javastack.cn/18-12-4/75398751.jpg\"></p>\n<blockquote>\n<p>注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。</p>\n</blockquote>\n<p>下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。</p>\n<p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 <strong>Node</strong>，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 <strong>TreeNode</strong>。</p>\n<p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。推荐阅读：<a href=\"https://mp.weixin.qq.com/s/Q5F604CUM_0x2co9mvADxw\">30 个 Java 集合面试问题及答案</a>。</p>\n<h4 id=\"put-过程分析-2\"><a href=\"#put-过程分析-2\" class=\"headerlink\" title=\"put 过程分析\"></a>put 过程分析</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">public V put(K key, V value) &#123;\n    return putVal(hash(key), key, value, false, true);\n&#125;\n \n&#x2F;&#x2F; 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作\n&#x2F;&#x2F; 第四个参数 evict 我们这里不关心\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n    &#x2F;&#x2F; 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度\n    &#x2F;&#x2F; 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量\n    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)\n        n &#x3D; (tab &#x3D; resize()).length;\n    &#x2F;&#x2F; 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了\n    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)\n        tab[i] &#x3D; newNode(hash, key, value, null);\n \n    else &#123;&#x2F;&#x2F; 数组该位置有数据\n        Node&lt;K,V&gt; e; K k;\n        &#x2F;&#x2F; 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点\n        if (p.hash &#x3D;&#x3D; hash &amp;&amp;\n            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n            e &#x3D; p;\n        &#x2F;&#x2F; 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树\n        else if (p instanceof TreeNode)\n            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n        else &#123;\n            &#x2F;&#x2F; 到这里，说明数组该位置上是一个链表\n            for (int binCount &#x3D; 0; ; ++binCount) &#123;\n                &#x2F;&#x2F; 插入到链表的最后面(Java7 是插入到链表的最前面)\n                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;\n                    p.next &#x3D; newNode(hash, key, value, null);\n                    &#x2F;&#x2F; TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 9 个\n                    &#x2F;&#x2F; 会触发下面的 treeifyBin，也就是将链表转换为红黑树\n                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                &#125;\n                &#x2F;&#x2F; 如果在该链表中找到了&quot;相等&quot;的 key(&#x3D;&#x3D; 或 equals)\n                if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n                    &#x2F;&#x2F; 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node\n                    break;\n                p &#x3D; e;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; e!&#x3D;null 说明存在旧值的key与要插入的key&quot;相等&quot;\n        &#x2F;&#x2F; 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值\n        if (e !&#x3D; null) &#123;\n            V oldValue &#x3D; e.value;\n            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)\n                e.value &#x3D; value;\n            afterNodeAccess(e);\n            return oldValue;\n        &#125;\n    &#125;\n    ++modCount;\n    &#x2F;&#x2F; 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容\n    if (++size &gt; threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。</p>\n<h6 id=\"数组扩容-1\"><a href=\"#数组扩容-1\" class=\"headerlink\" title=\"数组扩容\"></a>数组扩容</h6><p>resize() 方法用于<strong>初始化数组或数组扩容</strong>，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final Node&lt;K,V&gt;[] resize() &#123;\n    Node&lt;K,V&gt;[] oldTab &#x3D; table;\n    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;\n    int oldThr &#x3D; threshold;\n    int newCap, newThr &#x3D; 0;\n    if (oldCap &gt; 0) &#123; &#x2F;&#x2F; 对应数组扩容\n        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;\n            threshold &#x3D; Integer.MAX_VALUE;\n            return oldTab;\n        &#125;\n        &#x2F;&#x2F; 将数组大小扩大一倍\n        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)\n            &#x2F;&#x2F; 将阈值扩大一倍\n            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold\n    &#125;\n    else if (oldThr &gt; 0) &#x2F;&#x2F; 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候\n        newCap &#x3D; oldThr;\n    else &#123;&#x2F;&#x2F; 对应使用 new HashMap() 初始化后，第一次 put 的时候\n        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;\n        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    &#125;\n \n    if (newThr &#x3D;&#x3D; 0) &#123;\n        float ft &#x3D; (float)newCap * loadFactor;\n        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    &#125;\n    threshold &#x3D; newThr;\n \n    &#x2F;&#x2F; 用新的数组大小初始化新的数组\n    Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];\n    table &#x3D; newTab; &#x2F;&#x2F; 如果是初始化数组，到这里就结束了，返回 newTab 即可\n \n    if (oldTab !&#x3D; null) &#123;\n        &#x2F;&#x2F; 开始遍历原数组，进行数据迁移。\n        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;\n            Node&lt;K,V&gt; e;\n            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;\n                oldTab[j] &#x3D; null;\n                &#x2F;&#x2F; 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了\n                if (e.next &#x3D;&#x3D; null)\n                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;\n                &#x2F;&#x2F; 如果是红黑树，具体我们就不展开了\n                else if (e instanceof TreeNode)\n                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                else &#123; \n                    &#x2F;&#x2F; 这块是处理链表的情况，\n                    &#x2F;&#x2F; 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序\n                    &#x2F;&#x2F; loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的\n                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;\n                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;\n                    Node&lt;K,V&gt; next;\n                    do &#123;\n                        next &#x3D; e.next;\n                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;\n                            if (loTail &#x3D;&#x3D; null)\n                                loHead &#x3D; e;\n                            else\n                                loTail.next &#x3D; e;\n                            loTail &#x3D; e;\n                        &#125;\n                        else &#123;\n                            if (hiTail &#x3D;&#x3D; null)\n                                hiHead &#x3D; e;\n                            else\n                                hiTail.next &#x3D; e;\n                            hiTail &#x3D; e;\n                        &#125;\n                    &#125; while ((e &#x3D; next) !&#x3D; null);\n                    if (loTail !&#x3D; null) &#123;\n                        loTail.next &#x3D; null;\n                        &#x2F;&#x2F; 第一条链表\n                        newTab[j] &#x3D; loHead;\n                    &#125;\n                    if (hiTail !&#x3D; null) &#123;\n                        hiTail.next &#x3D; null;\n                        &#x2F;&#x2F; 第二条链表的新的位置是 j + oldCap，这个很好理解\n                        newTab[j + oldCap] &#x3D; hiHead;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return newTab;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"get-过程分析-2\"><a href=\"#get-过程分析-2\" class=\"headerlink\" title=\"get 过程分析\"></a>get 过程分析</h4><p>相对于 put 来说，get 真的太简单了。</p>\n<ol>\n<li>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</li>\n<li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</li>\n<li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</li>\n<li>遍历链表，直到找到相等(&#x3D;&#x3D;或equals)的 key.</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public V get(Object key) &#123;\n    Node&lt;K,V&gt; e;\n    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;\n    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;\n        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;\n        &#x2F;&#x2F; 判断第一个节点是不是就是需要的\n        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node\n            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n            return first;\n        if ((e &#x3D; first.next) !&#x3D; null) &#123;\n            &#x2F;&#x2F; 判断是否是红黑树\n            if (first instanceof TreeNode)\n                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);\n \n            &#x2F;&#x2F; 链表遍历\n            do &#123;\n                if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n                    return e;\n            &#125; while ((e &#x3D; e.next) !&#x3D; null);\n        &#125;\n    &#125;\n    return null;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"Java8-ConcurrentHashMap\"><a href=\"#Java8-ConcurrentHashMap\" class=\"headerlink\" title=\"Java8 ConcurrentHashMap\"></a>Java8 ConcurrentHashMap</h2><p>Java7 中实现的 ConcurrentHashMap 说实话还是比较复杂的，Java8 对 ConcurrentHashMap 进行了比较大的改动。建议读者可以参考 Java8 中 HashMap 相对于 Java7 HashMap 的改动，对于 ConcurrentHashMap，Java8 也引入了红黑树。</p>\n<p>说实话，Java8 ConcurrentHashMap 源码真心不简单，最难的在于扩容，数据迁移操作不容易看懂。</p>\n<p>我们先用一个示意图来描述下其结构：</p>\n<p><img src=\"http://qianniu.javastack.cn/18-12-4/335817.jpg\"></p>\n<p>结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。推荐阅读：<a href=\"https://mp.weixin.qq.com/s/5Y5_6qn2g6kIVmQia_0R6g\">几种线程安全的Map解析</a>。</p>\n<h4 id=\"初始化-1\"><a href=\"#初始化-1\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 这构造函数里，什么都不干\npublic ConcurrentHashMap() &#123;\n&#125;\npublic ConcurrentHashMap(int initialCapacity) &#123;\n    if (initialCapacity &lt; 0)\n        throw new IllegalArgumentException();\n    int cap &#x3D; ((initialCapacity &gt;&#x3D; (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?\n               MAXIMUM_CAPACITY :\n               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));\n    this.sizeCtl &#x3D; cap;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl &#x3D; 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。</p>\n<p>sizeCtl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。</p>\n<p>如果你爱折腾，也可以看下另一个有三个参数的构造方法，这里我就不说了，大部分时候，我们会使用无参构造函数进行实例化，我们也按照这个思路来进行源码分析吧。</p>\n<h4 id=\"put-过程分析-3\"><a href=\"#put-过程分析-3\" class=\"headerlink\" title=\"put 过程分析\"></a>put 过程分析</h4><p>仔细地一行一行代码看下去：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public V put(K key, V value) &#123;\n    return putVal(key, value, false);\n&#125;\nfinal V putVal(K key, V value, boolean onlyIfAbsent) &#123;\n    if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();\n    &#x2F;&#x2F; 得到 hash 值\n    int hash &#x3D; spread(key.hashCode());\n    &#x2F;&#x2F; 用于记录相应链表的长度\n    int binCount &#x3D; 0;\n    for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;\n        Node&lt;K,V&gt; f; int n, i, fh;\n        &#x2F;&#x2F; 如果数组&quot;空&quot;，进行数组初始化\n        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)\n            &#x2F;&#x2F; 初始化数组，后面会详细介绍\n            tab &#x3D; initTable();\n \n        &#x2F;&#x2F; 找该 hash 值对应的数组下标，得到第一个节点 f\n        else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;\n            &#x2F;&#x2F; 如果数组该位置为空，\n            &#x2F;&#x2F;    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了\n            &#x2F;&#x2F;          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了\n            if (casTabAt(tab, i, null,\n                         new Node&lt;K,V&gt;(hash, key, value, null)))\n                break;                   &#x2F;&#x2F; no lock when adding to empty bin\n        &#125;\n        &#x2F;&#x2F; hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容\n        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)\n            &#x2F;&#x2F; 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了\n            tab &#x3D; helpTransfer(tab, f);\n \n        else &#123; &#x2F;&#x2F; 到这里就是说，f 是该位置的头结点，而且不为空\n \n            V oldVal &#x3D; null;\n            &#x2F;&#x2F; 获取数组该位置的头结点的监视器锁\n            synchronized (f) &#123;\n                if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;\n                    if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 头结点的 hash 值大于 0，说明是链表\n                        &#x2F;&#x2F; 用于累加，记录链表的长度\n                        binCount &#x3D; 1;\n                        &#x2F;&#x2F; 遍历链表\n                        for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;\n                            K ek;\n                            &#x2F;&#x2F; 如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了\n                            if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                                ((ek &#x3D; e.key) &#x3D;&#x3D; key ||\n                                 (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;\n                                oldVal &#x3D; e.val;\n                                if (!onlyIfAbsent)\n                                    e.val &#x3D; value;\n                                break;\n                            &#125;\n                            &#x2F;&#x2F; 到了链表的最末端，将这个新值放到链表的最后面\n                            Node&lt;K,V&gt; pred &#x3D; e;\n                            if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;\n                                pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,\n                                                          value, null);\n                                break;\n                            &#125;\n                        &#125;\n                    &#125;\n                    else if (f instanceof TreeBin) &#123; &#x2F;&#x2F; 红黑树\n                        Node&lt;K,V&gt; p;\n                        binCount &#x3D; 2;\n                        &#x2F;&#x2F; 调用红黑树的插值方法插入新节点\n                        if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,\n                                                       value)) !&#x3D; null) &#123;\n                            oldVal &#x3D; p.val;\n                            if (!onlyIfAbsent)\n                                p.val &#x3D; value;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n            &#x2F;&#x2F; binCount !&#x3D; 0 说明上面在做链表操作\n            if (binCount !&#x3D; 0) &#123;\n                &#x2F;&#x2F; 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8\n                if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)\n                    &#x2F;&#x2F; 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，\n                    &#x2F;&#x2F; 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树\n                    &#x2F;&#x2F;    具体源码我们就不看了，扩容部分后面说\n                    treeifyBin(tab, i);\n                if (oldVal !&#x3D; null)\n                    return oldVal;\n                break;\n            &#125;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; \n    addCount(1L, binCount);\n    return null;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>put 的主流程看完了，但是至少留下了几个问题，第一个是初始化，第二个是扩容，第三个是帮助数据迁移，这些我们都会在后面进行一一介绍。</p>\n<h6 id=\"初始化数组：initTable\"><a href=\"#初始化数组：initTable\" class=\"headerlink\" title=\"初始化数组：initTable\"></a>初始化数组：initTable</h6><p>这个比较简单，主要就是初始化一个合适大小的数组，然后会设置 sizeCtl。</p>\n<p>初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private final Node&lt;K,V&gt;[] initTable() &#123;\n    Node&lt;K,V&gt;[] tab; int sc;\n    while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;\n        &#x2F;&#x2F; 初始化的&quot;功劳&quot;被其他线程&quot;抢去&quot;了\n        if ((sc &#x3D; sizeCtl) &lt; 0)\n            Thread.yield(); &#x2F;&#x2F; lost initialization race; just spin\n        &#x2F;&#x2F; CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁\n        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;\n            try &#123;\n                if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;\n                    &#x2F;&#x2F; DEFAULT_CAPACITY 默认初始容量是 16\n                    int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;\n                    &#x2F;&#x2F; 初始化数组，长度为 16 或初始化时提供的长度\n                    Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];\n                    &#x2F;&#x2F; 将这个数组赋值给 table，table 是 volatile 的\n                    table &#x3D; tab &#x3D; nt;\n                    &#x2F;&#x2F; 如果 n 为 16 的话，那么这里 sc &#x3D; 12\n                    &#x2F;&#x2F; 其实就是 0.75 * n\n                    sc &#x3D; n - (n &gt;&gt;&gt; 2);\n                &#125;\n            &#125; finally &#123;\n                &#x2F;&#x2F; 设置 sizeCtl 为 sc，我们就当是 12 吧\n                sizeCtl &#x3D; sc;\n            &#125;\n            break;\n        &#125;\n    &#125;\n    return tab;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h6 id=\"链表转红黑树-treeifyBin\"><a href=\"#链表转红黑树-treeifyBin\" class=\"headerlink\" title=\"链表转红黑树: treeifyBin\"></a>链表转红黑树: treeifyBin</h6><p>前面我们在 put 源码分析也说过，treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;\n    Node&lt;K,V&gt; b; int n, sc;\n    if (tab !&#x3D; null) &#123;\n        &#x2F;&#x2F; MIN_TREEIFY_CAPACITY 为 64\n        &#x2F;&#x2F; 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容\n        if ((n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)\n            &#x2F;&#x2F; 后面我们再详细分析这个方法\n            tryPresize(n &lt;&lt; 1);\n        &#x2F;&#x2F; b 是头结点\n        else if ((b &#x3D; tabAt(tab, index)) !&#x3D; null &amp;&amp; b.hash &gt;&#x3D; 0) &#123;\n            &#x2F;&#x2F; 加锁\n            synchronized (b) &#123;\n \n                if (tabAt(tab, index) &#x3D;&#x3D; b) &#123;\n                    &#x2F;&#x2F; 下面就是遍历链表，建立一颗红黑树\n                    TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;\n                    for (Node&lt;K,V&gt; e &#x3D; b; e !&#x3D; null; e &#x3D; e.next) &#123;\n                        TreeNode&lt;K,V&gt; p &#x3D;\n                            new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,\n                                              null, null);\n                        if ((p.prev &#x3D; tl) &#x3D;&#x3D; null)\n                            hd &#x3D; p;\n                        else\n                            tl.next &#x3D; p;\n                        tl &#x3D; p;\n                    &#125;\n                    &#x2F;&#x2F; 将红黑树设置到数组相应位置中\n                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<h4 id=\"扩容：tryPresize\"><a href=\"#扩容：tryPresize\" class=\"headerlink\" title=\"扩容：tryPresize\"></a>扩容：tryPresize</h4><p>如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。</p>\n<p>这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。</p>\n<p>这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了\nprivate final void tryPresize(int size) &#123;\n    &#x2F;&#x2F; c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。\n    int c &#x3D; (size &gt;&#x3D; (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :\n        tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);\n    int sc;\n    while ((sc &#x3D; sizeCtl) &gt;&#x3D; 0) &#123;\n        Node&lt;K,V&gt;[] tab &#x3D; table; int n;\n \n        &#x2F;&#x2F; 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码\n        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0) &#123;\n            n &#x3D; (sc &gt; c) ? sc : c;\n            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;\n                try &#123;\n                    if (table &#x3D;&#x3D; tab) &#123;\n                        @SuppressWarnings(&quot;unchecked&quot;)\n                        Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];\n                        table &#x3D; nt;\n                        sc &#x3D; n - (n &gt;&gt;&gt; 2); &#x2F;&#x2F; 0.75 * n\n                    &#125;\n                &#125; finally &#123;\n                    sizeCtl &#x3D; sc;\n                &#125;\n            &#125;\n        &#125;\n        else if (c &lt;&#x3D; sc || n &gt;&#x3D; MAXIMUM_CAPACITY)\n            break;\n        else if (tab &#x3D;&#x3D; table) &#123;\n            &#x2F;&#x2F; 我没看懂 rs 的真正含义是什么，不过也关系不大\n            int rs &#x3D; resizeStamp(n);\n \n            if (sc &lt; 0) &#123;\n                Node&lt;K,V&gt;[] nt;\n                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||\n                    sc &#x3D;&#x3D; rs + MAX_RESIZERS || (nt &#x3D; nextTable) &#x3D;&#x3D; null ||\n                    transferIndex &lt;&#x3D; 0)\n                    break;\n                &#x2F;&#x2F; 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法\n                &#x2F;&#x2F;    此时 nextTab 不为 null\n                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))\n                    transfer(tab, nt);\n            &#125;\n            &#x2F;&#x2F; 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)\n            &#x2F;&#x2F;     我是没看懂这个值真正的意义是什么？不过可以计算出来的是，结果是一个比较大的负数\n            &#x2F;&#x2F;  调用 transfer 方法，此时 nextTab 参数为 null\n            else if (U.compareAndSwapInt(this, SIZECTL, sc,\n                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))\n                transfer(tab, null);\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。</p>\n<p>所以，可能的操作就是执行 **1 次 transfer(tab, null) + 多次 transfer(tab, nt)**，这里怎么结束循环的需要看完 transfer 源码才清楚。推荐阅读：<a href=\"https://mp.weixin.qq.com/s/Q5F604CUM_0x2co9mvADxw\">30 个 Java 集合面试问题及答案</a>。</p>\n<h6 id=\"数据迁移：transfer\"><a href=\"#数据迁移：transfer\" class=\"headerlink\" title=\"数据迁移：transfer\"></a>数据迁移：transfer</h6><p>下面这个方法很点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。</p>\n<p>虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。</p>\n<p>此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。</p>\n<p>阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 stride，简单理解就是步长，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。</p>\n<p>第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后从后往前的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;\n    int n &#x3D; tab.length, stride;\n \n    &#x2F;&#x2F; stride 在单核下直接等于 n，多核模式下为 (n&gt;&gt;&gt;3)&#x2F;NCPU，最小值是 16\n    &#x2F;&#x2F; stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，\n    &#x2F;&#x2F;   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务\n    if ((stride &#x3D; (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) &#x2F; NCPU : n) &lt; MIN_TRANSFER_STRIDE)\n        stride &#x3D; MIN_TRANSFER_STRIDE; &#x2F;&#x2F; subdivide range\n \n    &#x2F;&#x2F; 如果 nextTab 为 null，先进行一次初始化\n    &#x2F;&#x2F;    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null\n    &#x2F;&#x2F;       之后参与迁移的线程调用此方法时，nextTab 不会为 null\n    if (nextTab &#x3D;&#x3D; null) &#123;\n        try &#123;\n            &#x2F;&#x2F; 容量翻倍\n            Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];\n            nextTab &#x3D; nt;\n        &#125; catch (Throwable ex) &#123;      &#x2F;&#x2F; try to cope with OOME\n            sizeCtl &#x3D; Integer.MAX_VALUE;\n            return;\n        &#125;\n        &#x2F;&#x2F; nextTable 是 ConcurrentHashMap 中的属性\n        nextTable &#x3D; nextTab;\n        &#x2F;&#x2F; transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置\n        transferIndex &#x3D; n;\n    &#125;\n \n    int nextn &#x3D; nextTab.length;\n \n    &#x2F;&#x2F; ForwardingNode 翻译过来就是正在被迁移的 Node\n    &#x2F;&#x2F; 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED\n    &#x2F;&#x2F; 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，\n    &#x2F;&#x2F;    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了\n    &#x2F;&#x2F;    所以它其实相当于是一个标志。\n    ForwardingNode&lt;K,V&gt; fwd &#x3D; new ForwardingNode&lt;K,V&gt;(nextTab);\n \n \n    &#x2F;&#x2F; advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了\n    boolean advance &#x3D; true;\n    boolean finishing &#x3D; false; &#x2F;&#x2F; to ensure sweep before committing nextTab\n \n    &#x2F;*\n     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看\n     * \n     *&#x2F;\n \n    &#x2F;&#x2F; i 是位置索引，bound 是边界，注意是从后往前\n    for (int i &#x3D; 0, bound &#x3D; 0;;) &#123;\n        Node&lt;K,V&gt; f; int fh;\n \n        &#x2F;&#x2F; 下面这个 while 真的是不好理解\n        &#x2F;&#x2F; advance 为 true 表示可以进行下一个位置的迁移了\n        &#x2F;&#x2F;   简单理解结局：i 指向了 transferIndex，bound 指向了 transferIndex-stride\n        while (advance) &#123;\n            int nextIndex, nextBound;\n            if (--i &gt;&#x3D; bound || finishing)\n                advance &#x3D; false;\n \n            &#x2F;&#x2F; 将 transferIndex 值赋给 nextIndex\n            &#x2F;&#x2F; 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了\n            else if ((nextIndex &#x3D; transferIndex) &lt;&#x3D; 0) &#123;\n                i &#x3D; -1;\n                advance &#x3D; false;\n            &#125;\n            else if (U.compareAndSwapInt\n                     (this, TRANSFERINDEX, nextIndex,\n                      nextBound &#x3D; (nextIndex &gt; stride ?\n                                   nextIndex - stride : 0))) &#123;\n                &#x2F;&#x2F; 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前\n                bound &#x3D; nextBound;\n                i &#x3D; nextIndex - 1;\n                advance &#x3D; false;\n            &#125;\n        &#125;\n        if (i &lt; 0 || i &gt;&#x3D; n || i + n &gt;&#x3D; nextn) &#123;\n            int sc;\n            if (finishing) &#123;\n                &#x2F;&#x2F; 所有的迁移操作已经完成\n                nextTable &#x3D; null;\n                &#x2F;&#x2F; 将新的 nextTab 赋值给 table 属性，完成迁移\n                table &#x3D; nextTab;\n                &#x2F;&#x2F; 重新计算 sizeCtl：n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍\n                sizeCtl &#x3D; (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);\n                return;\n            &#125;\n \n            &#x2F;&#x2F; 之前我们说过，sizeCtl 在迁移前会设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2\n            &#x2F;&#x2F; 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，\n            &#x2F;&#x2F; 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务\n            if (U.compareAndSwapInt(this, SIZECTL, sc &#x3D; sizeCtl, sc - 1)) &#123;\n                &#x2F;&#x2F; 任务结束，方法退出\n                if ((sc - 2) !&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)\n                    return;\n \n                &#x2F;&#x2F; 到这里，说明 (sc - 2) &#x3D;&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，\n                &#x2F;&#x2F; 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing)&#123;&#125; 分支了\n                finishing &#x3D; advance &#x3D; true;\n                i &#x3D; n; &#x2F;&#x2F; recheck before commit\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“\n        else if ((f &#x3D; tabAt(tab, i)) &#x3D;&#x3D; null)\n            advance &#x3D; casTabAt(tab, i, null, fwd);\n        &#x2F;&#x2F; 该位置处是一个 ForwardingNode，代表该位置已经迁移过了\n        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)\n            advance &#x3D; true; &#x2F;&#x2F; already processed\n        else &#123;\n            &#x2F;&#x2F; 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作\n            synchronized (f) &#123;\n                if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;\n                    Node&lt;K,V&gt; ln, hn;\n                    &#x2F;&#x2F; 头结点的 hash 大于 0，说明是链表的 Node 节点\n                    if (fh &gt;&#x3D; 0) &#123;\n                        &#x2F;&#x2F; 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，\n                        &#x2F;&#x2F; 需要将链表一分为二，\n                        &#x2F;&#x2F;   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的\n                        &#x2F;&#x2F;   lastRun 之前的节点需要进行克隆，然后分到两个链表中\n                        int runBit &#x3D; fh &amp; n;\n                        Node&lt;K,V&gt; lastRun &#x3D; f;\n                        for (Node&lt;K,V&gt; p &#x3D; f.next; p !&#x3D; null; p &#x3D; p.next) &#123;\n                            int b &#x3D; p.hash &amp; n;\n                            if (b !&#x3D; runBit) &#123;\n                                runBit &#x3D; b;\n                                lastRun &#x3D; p;\n                            &#125;\n                        &#125;\n                        if (runBit &#x3D;&#x3D; 0) &#123;\n                            ln &#x3D; lastRun;\n                            hn &#x3D; null;\n                        &#125;\n                        else &#123;\n                            hn &#x3D; lastRun;\n                            ln &#x3D; null;\n                        &#125;\n                        for (Node&lt;K,V&gt; p &#x3D; f; p !&#x3D; lastRun; p &#x3D; p.next) &#123;\n                            int ph &#x3D; p.hash; K pk &#x3D; p.key; V pv &#x3D; p.val;\n                            if ((ph &amp; n) &#x3D;&#x3D; 0)\n                                ln &#x3D; new Node&lt;K,V&gt;(ph, pk, pv, ln);\n                            else\n                                hn &#x3D; new Node&lt;K,V&gt;(ph, pk, pv, hn);\n                        &#125;\n                        &#x2F;&#x2F; 其中的一个链表放在新数组的位置 i\n                        setTabAt(nextTab, i, ln);\n                        &#x2F;&#x2F; 另一个链表放在新数组的位置 i+n\n                        setTabAt(nextTab, i + n, hn);\n                        &#x2F;&#x2F; 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，\n                        &#x2F;&#x2F;    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了\n                        setTabAt(tab, i, fwd);\n                        &#x2F;&#x2F; advance 设置为 true，代表该位置已经迁移完毕\n                        advance &#x3D; true;\n                    &#125;\n                    else if (f instanceof TreeBin) &#123;\n                        &#x2F;&#x2F; 红黑树的迁移\n                        TreeBin&lt;K,V&gt; t &#x3D; (TreeBin&lt;K,V&gt;)f;\n                        TreeNode&lt;K,V&gt; lo &#x3D; null, loTail &#x3D; null;\n                        TreeNode&lt;K,V&gt; hi &#x3D; null, hiTail &#x3D; null;\n                        int lc &#x3D; 0, hc &#x3D; 0;\n                        for (Node&lt;K,V&gt; e &#x3D; t.first; e !&#x3D; null; e &#x3D; e.next) &#123;\n                            int h &#x3D; e.hash;\n                            TreeNode&lt;K,V&gt; p &#x3D; new TreeNode&lt;K,V&gt;\n                                (h, e.key, e.val, null, null);\n                            if ((h &amp; n) &#x3D;&#x3D; 0) &#123;\n                                if ((p.prev &#x3D; loTail) &#x3D;&#x3D; null)\n                                    lo &#x3D; p;\n                                else\n                                    loTail.next &#x3D; p;\n                                loTail &#x3D; p;\n                                ++lc;\n                            &#125;\n                            else &#123;\n                                if ((p.prev &#x3D; hiTail) &#x3D;&#x3D; null)\n                                    hi &#x3D; p;\n                                else\n                                    hiTail.next &#x3D; p;\n                                hiTail &#x3D; p;\n                                ++hc;\n                            &#125;\n                        &#125;\n                        &#x2F;&#x2F; 如果一分为二后，节点数少于 8，那么将红黑树转换回链表\n                        ln &#x3D; (lc &lt;&#x3D; UNTREEIFY_THRESHOLD) ? untreeify(lo) :\n                            (hc !&#x3D; 0) ? new TreeBin&lt;K,V&gt;(lo) : t;\n                        hn &#x3D; (hc &lt;&#x3D; UNTREEIFY_THRESHOLD) ? untreeify(hi) :\n                            (lc !&#x3D; 0) ? new TreeBin&lt;K,V&gt;(hi) : t;\n \n                        &#x2F;&#x2F; 将 ln 放置在新数组的位置 i\n                        setTabAt(nextTab, i, ln);\n                        &#x2F;&#x2F; 将 hn 放置在新数组的位置 i+n\n                        setTabAt(nextTab, i + n, hn);\n                        &#x2F;&#x2F; 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，\n                        &#x2F;&#x2F;    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了\n                        setTabAt(tab, i, fwd);\n                        &#x2F;&#x2F; advance 设置为 true，代表该位置已经迁移完毕\n                        advance &#x3D; true;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。</p>\n<p>这个时候，再回去仔细看 tryPresize 方法可能就会更加清晰一些了。</p>\n<h4 id=\"get-过程分析-3\"><a href=\"#get-过程分析-3\" class=\"headerlink\" title=\"get 过程分析\"></a>get 过程分析</h4><p>get 方法从来都是最简单的，这里也不例外：</p>\n<p>1.计算 hash 值</p>\n<p>2.根据 hash 值找到数组对应位置: (n – 1) &amp; h</p>\n<p>3.根据该位置处结点性质进行相应查找</p>\n<ul>\n<li>如果该位置为 null，那么直接返回 null 就可以了</li>\n<li>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</li>\n<li>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法</li>\n<li>如果以上 3 条都不满足，那就是链表，进行遍历比对即可。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public V get(Object key) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;\n    int h &#x3D; spread(key.hashCode());\n    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;\n        (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123;\n        &#x2F;&#x2F; 判断头结点是否就是我们需要的节点\n        if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123;\n            if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek)))\n                return e.val;\n        &#125;\n        &#x2F;&#x2F; 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树\n        else if (eh &lt; 0)\n            &#x2F;&#x2F; 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)\n            return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;\n \n        &#x2F;&#x2F; 遍历链表\n        while ((e &#x3D; e.next) !&#x3D; null) &#123;\n            if (e.hash &#x3D;&#x3D; h &amp;&amp;\n                ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))\n                return e.val;\n        &#125;\n    &#125;\n    return null;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，ForwardingNode.find(int h, Object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了，所以限于篇幅这里也不展开说了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其实也不是很难嘛，虽然没有像之前的 AQS 和线程池一样一行一行源码进行分析，但还是把所有初学者可能会糊涂的地方都进行了深入的介绍，只要是稍微有点基础的读者，应该是很容易就能看懂 HashMap 和 ConcurrentHashMap 源码了。</p>\n<p>看源码不算是目的吧，深入地了解 Doug Lea 的设计思路，我觉得还挺有趣的，大师就是大师，代码写得真的是好啊。</p>\n<p>我发现很多人都以为我写博客主要是源码分析，说真的，我对于源码分析没有那么大热情，主要都是为了用源码说事罢了，可能之后的文章还是会有比较多的源码分析成分，大家该怎么看就怎么看吧。</p>\n<p>不要脸地自以为本文的质量还是挺高的，信息量比较大，如果你觉得有写得不好的地方，或者说看完本文你还是没看懂它们，那么请提出来~~~</p>\n","excerpt":"","more":"<p>网上关于 HashMap 和 ConcurrentHashMap 的文章确实不少，不过缺斤少两的文章比较多，所以才想自己也写一篇，把细节说清楚说透，尤其像 Java8 中的 ConcurrentHashMap，大部分文章都说不清楚。终归是希望能降低大家学习的成本，不希望大家到处找各种不是很靠谱的文章，看完一篇又一篇，可是还是模模糊糊。</p>\n<p><strong>阅读建议：</strong> 四节基本上可以进行独立阅读，建议初学者可按照以下顺序进行阅读，可适当降低阅读门槛。</p>\n<blockquote>\n<p>Java7 HashMap -&gt; Java7 ConcurrentHashMap -&gt; Java8 HashMap -&gt; Java8 ConcurrentHashMap </p>\n</blockquote>\n<p><strong>阅读前提：</strong> 本文分析的是源码，所以至少读者要熟悉它们的接口使用，同时，对于并发，读者至少要知道 CAS、ReentrantLock、UNSAFE 操作这几个基本的知识，文中不会对这些知识进行介绍。Java8 用到了红黑树，不过本文不会进行展开，感兴趣的读者请自行查找相关资料。</p>\n<h2 id=\"Java7-HashMap\"><a href=\"#Java7-HashMap\" class=\"headerlink\" title=\"Java7 HashMap\"></a>Java7 HashMap</h2><p>HashMap 是最简单的，一来我们非常熟悉，二来就是它不支持并发操作，所以源码也非常简单。</p>\n<p>首先，我们用下面这张图来介绍 HashMap 的结构。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-12-4/65827660.jpg\"></p>\n<p>这个仅仅是示意图，因为没有考虑到数组要扩容的情况，具体的后面再说。</p>\n<p>大方向上，HashMap 里面是一个<strong>数组</strong>，然后数组中每个元素是一个<strong>单向链表</strong>。</p>\n<p>上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。</p>\n<p>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</p>\n<p>loadFactor：负载因子，默认为 0.75。</p>\n<p>threshold：扩容的阈值，等于 capacity * loadFactor</p>\n<h4 id=\"put-过程分析\"><a href=\"#put-过程分析\" class=\"headerlink\" title=\"put 过程分析\"></a>put 过程分析</h4><p>还是比较简单的，跟着代码走一遍吧。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public V put(K key, V value) &#123;\n    &#x2F;&#x2F; 当插入第一个元素的时候，需要先初始化数组大小\n    if (table &#x3D;&#x3D; EMPTY_TABLE) &#123;\n        inflateTable(threshold);\n    &#125;\n    &#x2F;&#x2F; 如果 key 为 null，感兴趣的可以往里看，最终会将这个 entry 放到 table[0] 中\n    if (key &#x3D;&#x3D; null)\n        return putForNullKey(value);\n    &#x2F;&#x2F; 1. 求 key 的 hash 值\n    int hash &#x3D; hash(key);\n    &#x2F;&#x2F; 2. 找到对应的数组下标\n    int i &#x3D; indexFor(hash, table.length);\n    &#x2F;&#x2F; 3. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在，\n    &#x2F;&#x2F;    如果有，直接覆盖，put 方法返回旧值就结束了\n    for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;\n        Object k;\n        if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))) &#123;\n            V oldValue &#x3D; e.value;\n            e.value &#x3D; value;\n            e.recordAccess(this);\n            return oldValue;\n        &#125;\n    &#125;\n \n    modCount++;\n    &#x2F;&#x2F; 4. 不存在重复的 key，将此 entry 添加到链表中，细节后面说\n    addEntry(hash, key, value, i);\n    return null;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h6 id=\"数组初始化\"><a href=\"#数组初始化\" class=\"headerlink\" title=\"数组初始化\"></a>数组初始化</h6><p>在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private void inflateTable(int toSize) &#123;\n    &#x2F;&#x2F; 保证数组大小一定是 2 的 n 次方。\n    &#x2F;&#x2F; 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32\n    int capacity &#x3D; roundUpToPowerOf2(toSize);\n    &#x2F;&#x2F; 计算扩容阈值：capacity * loadFactor\n    threshold &#x3D; (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);\n    &#x2F;&#x2F; 算是初始化数组吧\n    table &#x3D; new Entry[capacity];\n    initHashSeedAsNeeded(capacity); &#x2F;&#x2F;ignore\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里有一个将数组大小保持为 2 的 n 次方的做法，Java7 和 Java8 的 HashMap 和 ConcurrentHashMap 都有相应的要求，只不过实现的代码稍微有些不同，后面再看到的时候就知道了。</p>\n<h6 id=\"计算具体数组位置\"><a href=\"#计算具体数组位置\" class=\"headerlink\" title=\"计算具体数组位置\"></a>计算具体数组位置</h6><p>这个简单，我们自己也能 YY 一个：使用 key 的 hash 值对数组长度进行取模就可以了。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">static int indexFor(int hash, int length) &#123;\n    &#x2F;&#x2F; assert Integer.bitCount(length) &#x3D;&#x3D; 1 : &quot;length must be a non-zero power of 2&quot;;\n    return hash &amp; (length-1);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。</p>\n<h6 id=\"添加节点到链表中\"><a href=\"#添加节点到链表中\" class=\"headerlink\" title=\"添加节点到链表中\"></a>添加节点到链表中</h6><p>找到数组下标后，会先进行 key 判重，如果没有重复，就准备将新值放入到链表的表头。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">void addEntry(int hash, K key, V value, int bucketIndex) &#123;\n    &#x2F;&#x2F; 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容\n    if ((size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[bucketIndex])) &#123;\n        &#x2F;&#x2F; 扩容，后面会介绍一下\n        resize(2 * table.length);\n        &#x2F;&#x2F; 扩容以后，重新计算 hash 值\n        hash &#x3D; (null !&#x3D; key) ? hash(key) : 0;\n        &#x2F;&#x2F; 重新计算扩容后的新的下标\n        bucketIndex &#x3D; indexFor(hash, table.length);\n    &#125;\n    &#x2F;&#x2F; 往下看\n    createEntry(hash, key, value, bucketIndex);\n&#125;\n\n&#x2F;&#x2F; 这个很简单，其实就是将新值放到链表的表头，然后 size++\nvoid createEntry(int hash, K key, V value, int bucketIndex) &#123;\n    Entry&lt;K,V&gt; e &#x3D; table[bucketIndex];\n    table[bucketIndex] &#x3D; new Entry&lt;&gt;(hash, key, value, e);\n    size++;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。</p>\n<h6 id=\"数组扩容\"><a href=\"#数组扩容\" class=\"headerlink\" title=\"数组扩容\"></a>数组扩容</h6><p>前面我们看到，在插入新值的时候，如果当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">void resize(int newCapacity) &#123;\n    Entry[] oldTable &#x3D; table;\n    int oldCapacity &#x3D; oldTable.length;\n    if (oldCapacity &#x3D;&#x3D; MAXIMUM_CAPACITY) &#123;\n        threshold &#x3D; Integer.MAX_VALUE;\n        return;\n    &#125;\n    &#x2F;&#x2F; 新的数组\n    Entry[] newTable &#x3D; new Entry[newCapacity];\n    &#x2F;&#x2F; 将原来数组中的值迁移到新的更大的数组中\n    transfer(newTable, initHashSeedAsNeeded(newCapacity));\n    table &#x3D; newTable;\n    threshold &#x3D; (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</p>\n<p>由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。代码比较简单，这里就不展开了。</p>\n<h4 id=\"get-过程分析\"><a href=\"#get-过程分析\" class=\"headerlink\" title=\"get 过程分析\"></a>get 过程分析</h4><p>相对于 put 过程，get 过程是非常简单的。</p>\n<ol>\n<li>根据 key 计算 hash 值。</li>\n<li>找到相应的数组下标：hash &amp; (length – 1)。</li>\n<li>遍历该数组位置处的链表，直到找到相等(&#x3D;&#x3D;或equals)的 key。</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public V get(Object key) &#123;\n    &#x2F;&#x2F; 之前说过，key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了\n    if (key &#x3D;&#x3D; null)\n        return getForNullKey();\n    &#x2F;&#x2F; \n    Entry&lt;K,V&gt; entry &#x3D; getEntry(key);\n \n    return null &#x3D;&#x3D; entry ? null : entry.getValue();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>getEntry(key):</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final Entry&lt;K,V&gt; getEntry(Object key) &#123;\n    if (size &#x3D;&#x3D; 0) &#123;\n        return null;\n    &#125;\n \n    int hash &#x3D; (key &#x3D;&#x3D; null) ? 0 : hash(key);\n    &#x2F;&#x2F; 确定数组下标，然后从头开始遍历链表，直到找到为止\n    for (Entry&lt;K,V&gt; e &#x3D; table[indexFor(hash, table.length)];\n         e !&#x3D; null;\n         e &#x3D; e.next) &#123;\n        Object k;\n        if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n            ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n            return e;\n    &#125;\n    return null;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"Java7-ConcurrentHashMap\"><a href=\"#Java7-ConcurrentHashMap\" class=\"headerlink\" title=\"Java7 ConcurrentHashMap\"></a>Java7 ConcurrentHashMap</h2><p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。</p>\n<p>整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为<strong>分段锁</strong>。注意，行文中，我很多地方用了 <strong>“槽”</strong> 来代表一个 segment。</p>\n<p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。推荐阅读：<a href=\"https://mp.weixin.qq.com/s/0CI9od4DIxRrmOGFJw0SuQ\">史上最全 Java 多线程面试题及答案</a>。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-12-4/75121838.jpg\"></p>\n<p><strong>concurrencyLevel：</strong> 并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</p>\n<p>再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。推荐阅读：<a href=\"https://mp.weixin.qq.com/s/5Y5_6qn2g6kIVmQia_0R6g\">几种线程安全的Map解析</a>。</p>\n<h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><p>initialCapacity：初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。</p>\n<p>loadFactor：负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public ConcurrentHashMap(int initialCapacity,\n                         float loadFactor, int concurrencyLevel) &#123;\n    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0)\n        throw new IllegalArgumentException();\n    if (concurrencyLevel &gt; MAX_SEGMENTS)\n        concurrencyLevel &#x3D; MAX_SEGMENTS;\n    &#x2F;&#x2F; Find power-of-two sizes best matching arguments\n    int sshift &#x3D; 0;\n    int ssize &#x3D; 1;\n    &#x2F;&#x2F; 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方\n    while (ssize &lt; concurrencyLevel) &#123;\n        ++sshift;\n        ssize &lt;&lt;&#x3D; 1;\n    &#125;\n    &#x2F;&#x2F; 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4\n    &#x2F;&#x2F; 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值\n    this.segmentShift &#x3D; 32 - sshift;\n    this.segmentMask &#x3D; ssize - 1;\n \n    if (initialCapacity &gt; MAXIMUM_CAPACITY)\n        initialCapacity &#x3D; MAXIMUM_CAPACITY;\n \n    &#x2F;&#x2F; initialCapacity 是设置整个 map 初始的大小，\n    &#x2F;&#x2F; 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小\n    &#x2F;&#x2F; 如 initialCapacity 为 64，那么每个 Segment 或称之为&quot;槽&quot;可以分到 4 个\n    int c &#x3D; initialCapacity &#x2F; ssize;\n    if (c * ssize &lt; initialCapacity)\n        ++c;\n    &#x2F;&#x2F; 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，\n    &#x2F;&#x2F; 插入一个元素不至于扩容，插入第二个的时候才会扩容\n    int cap &#x3D; MIN_SEGMENT_TABLE_CAPACITY; \n    while (cap &lt; c)\n        cap &lt;&lt;&#x3D; 1;\n \n    &#x2F;&#x2F; 创建 Segment 数组，\n    &#x2F;&#x2F; 并创建数组的第一个元素 segment[0]\n    Segment&lt;K,V&gt; s0 &#x3D;\n        new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),\n                         (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);\n    Segment&lt;K,V&gt;[] ss &#x3D; (Segment&lt;K,V&gt;[])new Segment[ssize];\n    &#x2F;&#x2F; 往数组写入 segment[0]\n    UNSAFE.putOrderedObject(ss, SBASE, s0); &#x2F;&#x2F; ordered write of segments[0]\n    this.segments &#x3D; ss;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>初始化完成，我们得到了一个 Segment 数组。</p>\n<p>我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后：</p>\n<ul>\n<li>Segment 数组长度为 16，不可以扩容</li>\n<li>Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容</li>\n<li>这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍</li>\n<li>当前 segmentShift 的值为 32 – 4 &#x3D; 28，segmentMask 为 16 – 1 &#x3D; 15，姑且把它们简单翻译为移位数和掩码，这两个值马上就会用到。</li>\n</ul>\n<h4 id=\"put-过程分析-1\"><a href=\"#put-过程分析-1\" class=\"headerlink\" title=\"put 过程分析\"></a>put 过程分析</h4><p>我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public V put(K key, V value) &#123;\n    Segment&lt;K,V&gt; s;\n    if (value &#x3D;&#x3D; null)\n        throw new NullPointerException();\n    &#x2F;&#x2F; 1. 计算 key 的 hash 值\n    int hash &#x3D; hash(key);\n    &#x2F;&#x2F; 2. 根据 hash 值找到 Segment 数组中的位置 j\n    &#x2F;&#x2F;    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下低 4 位，\n    &#x2F;&#x2F;    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的最后 4 位，也就是槽的数组下标\n    int j &#x3D; (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;\n    &#x2F;&#x2F; 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，\n    &#x2F;&#x2F; ensureSegment(j) 对 segment[j] 进行初始化\n    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObject          &#x2F;&#x2F; nonvolatile; recheck\n         (segments, (j &lt;&lt; SSHIFT) + SBASE)) &#x3D;&#x3D; null) &#x2F;&#x2F;  in ensureSegment\n        s &#x3D; ensureSegment(j);\n    &#x2F;&#x2F; 3. 插入新值到 槽 s 中\n    return s.put(key, hash, value, false);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。</p>\n<p>Segment 内部是由 <strong>数组+链表</strong> 组成的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;\n    &#x2F;&#x2F; 在往该 segment 写入前，需要先获取该 segment 的独占锁\n    &#x2F;&#x2F;    先看主流程，后面还会具体介绍这部分内容\n    HashEntry&lt;K,V&gt; node &#x3D; tryLock() ? null :\n        scanAndLockForPut(key, hash, value);\n    V oldValue;\n    try &#123;\n        &#x2F;&#x2F; 这个是 segment 内部的数组\n        HashEntry&lt;K,V&gt;[] tab &#x3D; table;\n        &#x2F;&#x2F; 再利用 hash 值，求应该放置的数组下标\n        int index &#x3D; (tab.length - 1) &amp; hash;\n        &#x2F;&#x2F; first 是数组该位置处的链表的表头\n        HashEntry&lt;K,V&gt; first &#x3D; entryAt(tab, index);\n \n        &#x2F;&#x2F; 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况\n        for (HashEntry&lt;K,V&gt; e &#x3D; first;;) &#123;\n            if (e !&#x3D; null) &#123;\n                K k;\n                if ((k &#x3D; e.key) &#x3D;&#x3D; key ||\n                    (e.hash &#x3D;&#x3D; hash &amp;&amp; key.equals(k))) &#123;\n                    oldValue &#x3D; e.value;\n                    if (!onlyIfAbsent) &#123;\n                        &#x2F;&#x2F; 覆盖旧值\n                        e.value &#x3D; value;\n                        ++modCount;\n                    &#125;\n                    break;\n                &#125;\n                &#x2F;&#x2F; 继续顺着链表走\n                e &#x3D; e.next;\n            &#125;\n            else &#123;\n                &#x2F;&#x2F; node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。\n                &#x2F;&#x2F; 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。\n                if (node !&#x3D; null)\n                    node.setNext(first);\n                else\n                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, first);\n \n                int c &#x3D; count + 1;\n                &#x2F;&#x2F; 如果超过了该 segment 的阈值，这个 segment 需要扩容\n                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)\n                    rehash(node); &#x2F;&#x2F; 扩容后面也会具体分析\n                else\n                    &#x2F;&#x2F; 没有达到阈值，将 node 放到数组 tab 的 index 位置，\n                    &#x2F;&#x2F; 其实就是将新的节点设置成原链表的表头\n                    setEntryAt(tab, index, node);\n                ++modCount;\n                count &#x3D; c;\n                oldValue &#x3D; null;\n                break;\n            &#125;\n        &#125;\n    &#125; finally &#123;\n        &#x2F;&#x2F; 解锁\n        unlock();\n    &#125;\n    return oldValue;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。</p>\n<p>到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。</p>\n<h6 id=\"初始化槽-ensureSegment\"><a href=\"#初始化槽-ensureSegment\" class=\"headerlink\" title=\"初始化槽: ensureSegment\"></a>初始化槽: ensureSegment</h6><p>ConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。</p>\n<p>这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private Segment&lt;K,V&gt; ensureSegment(int k) &#123;\n    final Segment&lt;K,V&gt;[] ss &#x3D; this.segments;\n    long u &#x3D; (k &lt;&lt; SSHIFT) + SBASE; &#x2F;&#x2F; raw offset\n    Segment&lt;K,V&gt; seg;\n    if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) &#x3D;&#x3D; null) &#123;\n        &#x2F;&#x2F; 这里看到为什么之前要初始化 segment[0] 了，\n        &#x2F;&#x2F; 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]\n        &#x2F;&#x2F; 为什么要用“当前”，因为 segment[0] 可能早就扩容过了\n        Segment&lt;K,V&gt; proto &#x3D; ss[0];\n        int cap &#x3D; proto.table.length;\n        float lf &#x3D; proto.loadFactor;\n        int threshold &#x3D; (int)(cap * lf);\n \n        &#x2F;&#x2F; 初始化 segment[k] 内部的数组\n        HashEntry&lt;K,V&gt;[] tab &#x3D; (HashEntry&lt;K,V&gt;[])new HashEntry[cap];\n        if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))\n            &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 再次检查一遍该槽是否被其他线程初始化了。\n \n            Segment&lt;K,V&gt; s &#x3D; new Segment&lt;K,V&gt;(lf, threshold, tab);\n            &#x2F;&#x2F; 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出\n            while ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))\n                   &#x3D;&#x3D; null) &#123;\n                if (UNSAFE.compareAndSwapObject(ss, u, null, seg &#x3D; s))\n                    break;\n            &#125;\n        &#125;\n    &#125;\n    return seg;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>总的来说，ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。</p>\n<blockquote>\n<p>如果当前线程 CAS 失败，这里的 while 循环是为了将 seg 赋值返回。</p>\n</blockquote>\n<h6 id=\"获取写入锁-scanAndLockForPut\"><a href=\"#获取写入锁-scanAndLockForPut\" class=\"headerlink\" title=\"获取写入锁: scanAndLockForPut\"></a>获取写入锁: scanAndLockForPut</h6><p>前面我们看到，在往某个 segment 中 put 的时候，首先会调用 node &#x3D; tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。</p>\n<p>下面我们来具体分析这个方法中是怎么控制加锁的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;\n    HashEntry&lt;K,V&gt; first &#x3D; entryForHash(this, hash);\n    HashEntry&lt;K,V&gt; e &#x3D; first;\n    HashEntry&lt;K,V&gt; node &#x3D; null;\n    int retries &#x3D; -1; &#x2F;&#x2F; negative while locating node\n \n    &#x2F;&#x2F; 循环获取锁\n    while (!tryLock()) &#123;\n        HashEntry&lt;K,V&gt; f; &#x2F;&#x2F; to recheck first below\n        if (retries &lt; 0) &#123;\n            if (e &#x3D;&#x3D; null) &#123;\n                if (node &#x3D;&#x3D; null) &#x2F;&#x2F; speculatively create node\n                    &#x2F;&#x2F; 进到这里说明数组该位置的链表是空的，没有任何元素\n                    &#x2F;&#x2F; 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置\n                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, null);\n                retries &#x3D; 0;\n            &#125;\n            else if (key.equals(e.key))\n                retries &#x3D; 0;\n            else\n                &#x2F;&#x2F; 顺着链表往下走\n                e &#x3D; e.next;\n        &#125;\n        &#x2F;&#x2F; 重试次数如果超过 MAX_SCAN_RETRIES（单核1多核64），那么不抢了，进入到阻塞队列等待锁\n        &#x2F;&#x2F;    lock() 是阻塞方法，直到获取锁后返回\n        else if (++retries &gt; MAX_SCAN_RETRIES) &#123;\n            lock();\n            break;\n        &#125;\n        else if ((retries &amp; 1) &#x3D;&#x3D; 0 &amp;&amp;\n                 &#x2F;&#x2F; 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头\n                 &#x2F;&#x2F;     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法\n                 (f &#x3D; entryForHash(this, hash)) !&#x3D; first) &#123;\n            e &#x3D; first &#x3D; f; &#x2F;&#x2F; re-traverse if entry changed\n            retries &#x3D; -1;\n        &#125;\n    &#125;\n    return node;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。</p>\n<p>这个方法就是看似复杂，但是其实就是做了一件事，那就是<strong>获取该 segment 的独占锁</strong>，如果需要的话顺便实例化了一下 node。</p>\n<h6 id=\"扩容-rehash\"><a href=\"#扩容-rehash\" class=\"headerlink\" title=\"扩容: rehash\"></a>扩容: rehash</h6><p>重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry[] 进行扩容，扩容后，容量为原来的 2 倍。</p>\n<p>首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。</p>\n<p>该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。\nprivate void rehash(HashEntry&lt;K,V&gt; node) &#123;\n    HashEntry&lt;K,V&gt;[] oldTable &#x3D; table;\n    int oldCapacity &#x3D; oldTable.length;\n    &#x2F;&#x2F; 2 倍\n    int newCapacity &#x3D; oldCapacity &lt;&lt; 1;\n    threshold &#x3D; (int)(newCapacity * loadFactor);\n    &#x2F;&#x2F; 创建新数组\n    HashEntry&lt;K,V&gt;[] newTable &#x3D;\n        (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];\n    &#x2F;&#x2F; 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’\n    int sizeMask &#x3D; newCapacity - 1;\n \n    &#x2F;&#x2F; 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置\n    for (int i &#x3D; 0; i &lt; oldCapacity ; i++) &#123;\n        &#x2F;&#x2F; e 是链表的第一个元素\n        HashEntry&lt;K,V&gt; e &#x3D; oldTable[i];\n        if (e !&#x3D; null) &#123;\n            HashEntry&lt;K,V&gt; next &#x3D; e.next;\n            &#x2F;&#x2F; 计算应该放置在新数组中的位置，\n            &#x2F;&#x2F; 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 &#x3D; 19\n            int idx &#x3D; e.hash &amp; sizeMask;\n            if (next &#x3D;&#x3D; null)   &#x2F;&#x2F; 该位置处只有一个元素，那比较好办\n                newTable[idx] &#x3D; e;\n            else &#123; &#x2F;&#x2F; Reuse consecutive sequence at same slot\n                &#x2F;&#x2F; e 是链表表头\n                HashEntry&lt;K,V&gt; lastRun &#x3D; e;\n                &#x2F;&#x2F; idx 是当前链表的头结点 e 的新位置\n                int lastIdx &#x3D; idx;\n \n                &#x2F;&#x2F; 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的\n                for (HashEntry&lt;K,V&gt; last &#x3D; next;\n                     last !&#x3D; null;\n                     last &#x3D; last.next) &#123;\n                    int k &#x3D; last.hash &amp; sizeMask;\n                    if (k !&#x3D; lastIdx) &#123;\n                        lastIdx &#x3D; k;\n                        lastRun &#x3D; last;\n                    &#125;\n                &#125;\n                &#x2F;&#x2F; 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置\n                newTable[lastIdx] &#x3D; lastRun;\n                &#x2F;&#x2F; 下面的操作是处理 lastRun 之前的节点，\n                &#x2F;&#x2F;    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中\n                for (HashEntry&lt;K,V&gt; p &#x3D; e; p !&#x3D; lastRun; p &#x3D; p.next) &#123;\n                    V v &#x3D; p.value;\n                    int h &#x3D; p.hash;\n                    int k &#x3D; h &amp; sizeMask;\n                    HashEntry&lt;K,V&gt; n &#x3D; newTable[k];\n                    newTable[k] &#x3D; new HashEntry&lt;K,V&gt;(h, p.key, v, n);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部\n    int nodeIndex &#x3D; node.hash &amp; sizeMask; &#x2F;&#x2F; add the new node\n    node.setNext(newTable[nodeIndex]);\n    newTable[nodeIndex] &#x3D; node;\n    table &#x3D; newTable;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢？</p>\n<p>仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。</p>\n<p>我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。<strong>不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1&#x2F;6 的节点需要克隆。</strong></p>\n<h4 id=\"get-过程分析-1\"><a href=\"#get-过程分析-1\" class=\"headerlink\" title=\"get 过程分析\"></a>get 过程分析</h4><p>相对于 put 来说，get 真的不要太简单。</p>\n<ol>\n<li>计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”</li>\n<li>槽中也是一个数组，根据 hash 找到数组中具体的位置</li>\n<li>到这里是链表了，顺着链表进行查找即可</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public V get(Object key) &#123;\n    Segment&lt;K,V&gt; s; &#x2F;&#x2F; manually integrate access methods to reduce overhead\n    HashEntry&lt;K,V&gt;[] tab;\n    &#x2F;&#x2F; 1. hash 值\n    int h &#x3D; hash(key);\n    long u &#x3D; (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;\n    &#x2F;&#x2F; 2. 根据 hash 找到对应的 segment\n    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) !&#x3D; null &amp;&amp;\n        (tab &#x3D; s.table) !&#x3D; null) &#123;\n        &#x2F;&#x2F; 3. 找到segment 内部数组相应位置的链表，遍历\n        for (HashEntry&lt;K,V&gt; e &#x3D; (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile\n                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);\n             e !&#x3D; null; e &#x3D; e.next) &#123;\n            K k;\n            if ((k &#x3D; e.key) &#x3D;&#x3D; key || (e.hash &#x3D;&#x3D; h &amp;&amp; key.equals(k)))\n                return e.value;\n        &#125;\n    &#125;\n    return null;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"并发问题分析\"><a href=\"#并发问题分析\" class=\"headerlink\" title=\"并发问题分析\"></a>并发问题分析</h4><p>现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。</p>\n<p>添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。推荐阅读：<a href=\"https://mp.weixin.qq.com/s/Q5F604CUM_0x2co9mvADxw\">30 个 Java 集合面试问题及答案</a>。</p>\n<ul>\n<li><strong>put 操作的线程安全性</strong></li>\n</ul>\n<ol>\n<li>初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。</li>\n<li>添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。</li>\n<li>扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。</li>\n</ol>\n<ul>\n<li><strong>remove 操作的线程安全性</strong></li>\n</ul>\n<p>remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。</p>\n<p>get 操作需要遍历链表，但是 remove 操作会”破坏”链表。</p>\n<p>如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。</p>\n<p>如果 remove 先破坏了一个节点，分两种情况考虑。</p>\n<p>1、如果此节点是头结点，那么需要将头结点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。</p>\n<p>2、如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。推荐阅读：<a href=\"https://mp.weixin.qq.com/s/0CI9od4DIxRrmOGFJw0SuQ\">史上最全 Java 多线程面试题及答案</a>。</p>\n<h2 id=\"Java8-HashMap\"><a href=\"#Java8-HashMap\" class=\"headerlink\" title=\"Java8 HashMap\"></a>Java8 HashMap</h2><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 <strong>数组+链表+红黑树</strong> 组成。</p>\n<p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 **O(n)**。</p>\n<p>为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p>\n<p>来一张图简单示意一下吧：</p>\n<p><img src=\"http://qianniu.javastack.cn/18-12-4/75398751.jpg\"></p>\n<blockquote>\n<p>注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。</p>\n</blockquote>\n<p>下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。</p>\n<p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 <strong>Node</strong>，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 <strong>TreeNode</strong>。</p>\n<p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。推荐阅读：<a href=\"https://mp.weixin.qq.com/s/Q5F604CUM_0x2co9mvADxw\">30 个 Java 集合面试问题及答案</a>。</p>\n<h4 id=\"put-过程分析-2\"><a href=\"#put-过程分析-2\" class=\"headerlink\" title=\"put 过程分析\"></a>put 过程分析</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">public V put(K key, V value) &#123;\n    return putVal(hash(key), key, value, false, true);\n&#125;\n \n&#x2F;&#x2F; 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作\n&#x2F;&#x2F; 第四个参数 evict 我们这里不关心\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n    &#x2F;&#x2F; 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度\n    &#x2F;&#x2F; 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量\n    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)\n        n &#x3D; (tab &#x3D; resize()).length;\n    &#x2F;&#x2F; 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了\n    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)\n        tab[i] &#x3D; newNode(hash, key, value, null);\n \n    else &#123;&#x2F;&#x2F; 数组该位置有数据\n        Node&lt;K,V&gt; e; K k;\n        &#x2F;&#x2F; 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点\n        if (p.hash &#x3D;&#x3D; hash &amp;&amp;\n            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n            e &#x3D; p;\n        &#x2F;&#x2F; 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树\n        else if (p instanceof TreeNode)\n            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n        else &#123;\n            &#x2F;&#x2F; 到这里，说明数组该位置上是一个链表\n            for (int binCount &#x3D; 0; ; ++binCount) &#123;\n                &#x2F;&#x2F; 插入到链表的最后面(Java7 是插入到链表的最前面)\n                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;\n                    p.next &#x3D; newNode(hash, key, value, null);\n                    &#x2F;&#x2F; TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 9 个\n                    &#x2F;&#x2F; 会触发下面的 treeifyBin，也就是将链表转换为红黑树\n                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                &#125;\n                &#x2F;&#x2F; 如果在该链表中找到了&quot;相等&quot;的 key(&#x3D;&#x3D; 或 equals)\n                if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n                    &#x2F;&#x2F; 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node\n                    break;\n                p &#x3D; e;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; e!&#x3D;null 说明存在旧值的key与要插入的key&quot;相等&quot;\n        &#x2F;&#x2F; 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值\n        if (e !&#x3D; null) &#123;\n            V oldValue &#x3D; e.value;\n            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)\n                e.value &#x3D; value;\n            afterNodeAccess(e);\n            return oldValue;\n        &#125;\n    &#125;\n    ++modCount;\n    &#x2F;&#x2F; 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容\n    if (++size &gt; threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。</p>\n<h6 id=\"数组扩容-1\"><a href=\"#数组扩容-1\" class=\"headerlink\" title=\"数组扩容\"></a>数组扩容</h6><p>resize() 方法用于<strong>初始化数组或数组扩容</strong>，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final Node&lt;K,V&gt;[] resize() &#123;\n    Node&lt;K,V&gt;[] oldTab &#x3D; table;\n    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;\n    int oldThr &#x3D; threshold;\n    int newCap, newThr &#x3D; 0;\n    if (oldCap &gt; 0) &#123; &#x2F;&#x2F; 对应数组扩容\n        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;\n            threshold &#x3D; Integer.MAX_VALUE;\n            return oldTab;\n        &#125;\n        &#x2F;&#x2F; 将数组大小扩大一倍\n        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)\n            &#x2F;&#x2F; 将阈值扩大一倍\n            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold\n    &#125;\n    else if (oldThr &gt; 0) &#x2F;&#x2F; 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候\n        newCap &#x3D; oldThr;\n    else &#123;&#x2F;&#x2F; 对应使用 new HashMap() 初始化后，第一次 put 的时候\n        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;\n        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    &#125;\n \n    if (newThr &#x3D;&#x3D; 0) &#123;\n        float ft &#x3D; (float)newCap * loadFactor;\n        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    &#125;\n    threshold &#x3D; newThr;\n \n    &#x2F;&#x2F; 用新的数组大小初始化新的数组\n    Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];\n    table &#x3D; newTab; &#x2F;&#x2F; 如果是初始化数组，到这里就结束了，返回 newTab 即可\n \n    if (oldTab !&#x3D; null) &#123;\n        &#x2F;&#x2F; 开始遍历原数组，进行数据迁移。\n        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;\n            Node&lt;K,V&gt; e;\n            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;\n                oldTab[j] &#x3D; null;\n                &#x2F;&#x2F; 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了\n                if (e.next &#x3D;&#x3D; null)\n                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;\n                &#x2F;&#x2F; 如果是红黑树，具体我们就不展开了\n                else if (e instanceof TreeNode)\n                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                else &#123; \n                    &#x2F;&#x2F; 这块是处理链表的情况，\n                    &#x2F;&#x2F; 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序\n                    &#x2F;&#x2F; loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的\n                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;\n                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;\n                    Node&lt;K,V&gt; next;\n                    do &#123;\n                        next &#x3D; e.next;\n                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;\n                            if (loTail &#x3D;&#x3D; null)\n                                loHead &#x3D; e;\n                            else\n                                loTail.next &#x3D; e;\n                            loTail &#x3D; e;\n                        &#125;\n                        else &#123;\n                            if (hiTail &#x3D;&#x3D; null)\n                                hiHead &#x3D; e;\n                            else\n                                hiTail.next &#x3D; e;\n                            hiTail &#x3D; e;\n                        &#125;\n                    &#125; while ((e &#x3D; next) !&#x3D; null);\n                    if (loTail !&#x3D; null) &#123;\n                        loTail.next &#x3D; null;\n                        &#x2F;&#x2F; 第一条链表\n                        newTab[j] &#x3D; loHead;\n                    &#125;\n                    if (hiTail !&#x3D; null) &#123;\n                        hiTail.next &#x3D; null;\n                        &#x2F;&#x2F; 第二条链表的新的位置是 j + oldCap，这个很好理解\n                        newTab[j + oldCap] &#x3D; hiHead;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return newTab;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"get-过程分析-2\"><a href=\"#get-过程分析-2\" class=\"headerlink\" title=\"get 过程分析\"></a>get 过程分析</h4><p>相对于 put 来说，get 真的太简单了。</p>\n<ol>\n<li>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</li>\n<li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</li>\n<li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</li>\n<li>遍历链表，直到找到相等(&#x3D;&#x3D;或equals)的 key.</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public V get(Object key) &#123;\n    Node&lt;K,V&gt; e;\n    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;\n    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;\n        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;\n        &#x2F;&#x2F; 判断第一个节点是不是就是需要的\n        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node\n            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n            return first;\n        if ((e &#x3D; first.next) !&#x3D; null) &#123;\n            &#x2F;&#x2F; 判断是否是红黑树\n            if (first instanceof TreeNode)\n                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);\n \n            &#x2F;&#x2F; 链表遍历\n            do &#123;\n                if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n                    return e;\n            &#125; while ((e &#x3D; e.next) !&#x3D; null);\n        &#125;\n    &#125;\n    return null;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"Java8-ConcurrentHashMap\"><a href=\"#Java8-ConcurrentHashMap\" class=\"headerlink\" title=\"Java8 ConcurrentHashMap\"></a>Java8 ConcurrentHashMap</h2><p>Java7 中实现的 ConcurrentHashMap 说实话还是比较复杂的，Java8 对 ConcurrentHashMap 进行了比较大的改动。建议读者可以参考 Java8 中 HashMap 相对于 Java7 HashMap 的改动，对于 ConcurrentHashMap，Java8 也引入了红黑树。</p>\n<p>说实话，Java8 ConcurrentHashMap 源码真心不简单，最难的在于扩容，数据迁移操作不容易看懂。</p>\n<p>我们先用一个示意图来描述下其结构：</p>\n<p><img src=\"http://qianniu.javastack.cn/18-12-4/335817.jpg\"></p>\n<p>结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。推荐阅读：<a href=\"https://mp.weixin.qq.com/s/5Y5_6qn2g6kIVmQia_0R6g\">几种线程安全的Map解析</a>。</p>\n<h4 id=\"初始化-1\"><a href=\"#初始化-1\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 这构造函数里，什么都不干\npublic ConcurrentHashMap() &#123;\n&#125;\npublic ConcurrentHashMap(int initialCapacity) &#123;\n    if (initialCapacity &lt; 0)\n        throw new IllegalArgumentException();\n    int cap &#x3D; ((initialCapacity &gt;&#x3D; (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?\n               MAXIMUM_CAPACITY :\n               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));\n    this.sizeCtl &#x3D; cap;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl &#x3D; 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。</p>\n<p>sizeCtl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。</p>\n<p>如果你爱折腾，也可以看下另一个有三个参数的构造方法，这里我就不说了，大部分时候，我们会使用无参构造函数进行实例化，我们也按照这个思路来进行源码分析吧。</p>\n<h4 id=\"put-过程分析-3\"><a href=\"#put-过程分析-3\" class=\"headerlink\" title=\"put 过程分析\"></a>put 过程分析</h4><p>仔细地一行一行代码看下去：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public V put(K key, V value) &#123;\n    return putVal(key, value, false);\n&#125;\nfinal V putVal(K key, V value, boolean onlyIfAbsent) &#123;\n    if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();\n    &#x2F;&#x2F; 得到 hash 值\n    int hash &#x3D; spread(key.hashCode());\n    &#x2F;&#x2F; 用于记录相应链表的长度\n    int binCount &#x3D; 0;\n    for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;\n        Node&lt;K,V&gt; f; int n, i, fh;\n        &#x2F;&#x2F; 如果数组&quot;空&quot;，进行数组初始化\n        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)\n            &#x2F;&#x2F; 初始化数组，后面会详细介绍\n            tab &#x3D; initTable();\n \n        &#x2F;&#x2F; 找该 hash 值对应的数组下标，得到第一个节点 f\n        else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;\n            &#x2F;&#x2F; 如果数组该位置为空，\n            &#x2F;&#x2F;    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了\n            &#x2F;&#x2F;          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了\n            if (casTabAt(tab, i, null,\n                         new Node&lt;K,V&gt;(hash, key, value, null)))\n                break;                   &#x2F;&#x2F; no lock when adding to empty bin\n        &#125;\n        &#x2F;&#x2F; hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容\n        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)\n            &#x2F;&#x2F; 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了\n            tab &#x3D; helpTransfer(tab, f);\n \n        else &#123; &#x2F;&#x2F; 到这里就是说，f 是该位置的头结点，而且不为空\n \n            V oldVal &#x3D; null;\n            &#x2F;&#x2F; 获取数组该位置的头结点的监视器锁\n            synchronized (f) &#123;\n                if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;\n                    if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 头结点的 hash 值大于 0，说明是链表\n                        &#x2F;&#x2F; 用于累加，记录链表的长度\n                        binCount &#x3D; 1;\n                        &#x2F;&#x2F; 遍历链表\n                        for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;\n                            K ek;\n                            &#x2F;&#x2F; 如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了\n                            if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                                ((ek &#x3D; e.key) &#x3D;&#x3D; key ||\n                                 (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;\n                                oldVal &#x3D; e.val;\n                                if (!onlyIfAbsent)\n                                    e.val &#x3D; value;\n                                break;\n                            &#125;\n                            &#x2F;&#x2F; 到了链表的最末端，将这个新值放到链表的最后面\n                            Node&lt;K,V&gt; pred &#x3D; e;\n                            if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;\n                                pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,\n                                                          value, null);\n                                break;\n                            &#125;\n                        &#125;\n                    &#125;\n                    else if (f instanceof TreeBin) &#123; &#x2F;&#x2F; 红黑树\n                        Node&lt;K,V&gt; p;\n                        binCount &#x3D; 2;\n                        &#x2F;&#x2F; 调用红黑树的插值方法插入新节点\n                        if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,\n                                                       value)) !&#x3D; null) &#123;\n                            oldVal &#x3D; p.val;\n                            if (!onlyIfAbsent)\n                                p.val &#x3D; value;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n            &#x2F;&#x2F; binCount !&#x3D; 0 说明上面在做链表操作\n            if (binCount !&#x3D; 0) &#123;\n                &#x2F;&#x2F; 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8\n                if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)\n                    &#x2F;&#x2F; 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，\n                    &#x2F;&#x2F; 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树\n                    &#x2F;&#x2F;    具体源码我们就不看了，扩容部分后面说\n                    treeifyBin(tab, i);\n                if (oldVal !&#x3D; null)\n                    return oldVal;\n                break;\n            &#125;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; \n    addCount(1L, binCount);\n    return null;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>put 的主流程看完了，但是至少留下了几个问题，第一个是初始化，第二个是扩容，第三个是帮助数据迁移，这些我们都会在后面进行一一介绍。</p>\n<h6 id=\"初始化数组：initTable\"><a href=\"#初始化数组：initTable\" class=\"headerlink\" title=\"初始化数组：initTable\"></a>初始化数组：initTable</h6><p>这个比较简单，主要就是初始化一个合适大小的数组，然后会设置 sizeCtl。</p>\n<p>初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private final Node&lt;K,V&gt;[] initTable() &#123;\n    Node&lt;K,V&gt;[] tab; int sc;\n    while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;\n        &#x2F;&#x2F; 初始化的&quot;功劳&quot;被其他线程&quot;抢去&quot;了\n        if ((sc &#x3D; sizeCtl) &lt; 0)\n            Thread.yield(); &#x2F;&#x2F; lost initialization race; just spin\n        &#x2F;&#x2F; CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁\n        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;\n            try &#123;\n                if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;\n                    &#x2F;&#x2F; DEFAULT_CAPACITY 默认初始容量是 16\n                    int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;\n                    &#x2F;&#x2F; 初始化数组，长度为 16 或初始化时提供的长度\n                    Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];\n                    &#x2F;&#x2F; 将这个数组赋值给 table，table 是 volatile 的\n                    table &#x3D; tab &#x3D; nt;\n                    &#x2F;&#x2F; 如果 n 为 16 的话，那么这里 sc &#x3D; 12\n                    &#x2F;&#x2F; 其实就是 0.75 * n\n                    sc &#x3D; n - (n &gt;&gt;&gt; 2);\n                &#125;\n            &#125; finally &#123;\n                &#x2F;&#x2F; 设置 sizeCtl 为 sc，我们就当是 12 吧\n                sizeCtl &#x3D; sc;\n            &#125;\n            break;\n        &#125;\n    &#125;\n    return tab;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h6 id=\"链表转红黑树-treeifyBin\"><a href=\"#链表转红黑树-treeifyBin\" class=\"headerlink\" title=\"链表转红黑树: treeifyBin\"></a>链表转红黑树: treeifyBin</h6><p>前面我们在 put 源码分析也说过，treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;\n    Node&lt;K,V&gt; b; int n, sc;\n    if (tab !&#x3D; null) &#123;\n        &#x2F;&#x2F; MIN_TREEIFY_CAPACITY 为 64\n        &#x2F;&#x2F; 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容\n        if ((n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)\n            &#x2F;&#x2F; 后面我们再详细分析这个方法\n            tryPresize(n &lt;&lt; 1);\n        &#x2F;&#x2F; b 是头结点\n        else if ((b &#x3D; tabAt(tab, index)) !&#x3D; null &amp;&amp; b.hash &gt;&#x3D; 0) &#123;\n            &#x2F;&#x2F; 加锁\n            synchronized (b) &#123;\n \n                if (tabAt(tab, index) &#x3D;&#x3D; b) &#123;\n                    &#x2F;&#x2F; 下面就是遍历链表，建立一颗红黑树\n                    TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;\n                    for (Node&lt;K,V&gt; e &#x3D; b; e !&#x3D; null; e &#x3D; e.next) &#123;\n                        TreeNode&lt;K,V&gt; p &#x3D;\n                            new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,\n                                              null, null);\n                        if ((p.prev &#x3D; tl) &#x3D;&#x3D; null)\n                            hd &#x3D; p;\n                        else\n                            tl.next &#x3D; p;\n                        tl &#x3D; p;\n                    &#125;\n                    &#x2F;&#x2F; 将红黑树设置到数组相应位置中\n                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<h4 id=\"扩容：tryPresize\"><a href=\"#扩容：tryPresize\" class=\"headerlink\" title=\"扩容：tryPresize\"></a>扩容：tryPresize</h4><p>如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。</p>\n<p>这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。</p>\n<p>这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了\nprivate final void tryPresize(int size) &#123;\n    &#x2F;&#x2F; c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。\n    int c &#x3D; (size &gt;&#x3D; (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :\n        tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);\n    int sc;\n    while ((sc &#x3D; sizeCtl) &gt;&#x3D; 0) &#123;\n        Node&lt;K,V&gt;[] tab &#x3D; table; int n;\n \n        &#x2F;&#x2F; 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码\n        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0) &#123;\n            n &#x3D; (sc &gt; c) ? sc : c;\n            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;\n                try &#123;\n                    if (table &#x3D;&#x3D; tab) &#123;\n                        @SuppressWarnings(&quot;unchecked&quot;)\n                        Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];\n                        table &#x3D; nt;\n                        sc &#x3D; n - (n &gt;&gt;&gt; 2); &#x2F;&#x2F; 0.75 * n\n                    &#125;\n                &#125; finally &#123;\n                    sizeCtl &#x3D; sc;\n                &#125;\n            &#125;\n        &#125;\n        else if (c &lt;&#x3D; sc || n &gt;&#x3D; MAXIMUM_CAPACITY)\n            break;\n        else if (tab &#x3D;&#x3D; table) &#123;\n            &#x2F;&#x2F; 我没看懂 rs 的真正含义是什么，不过也关系不大\n            int rs &#x3D; resizeStamp(n);\n \n            if (sc &lt; 0) &#123;\n                Node&lt;K,V&gt;[] nt;\n                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||\n                    sc &#x3D;&#x3D; rs + MAX_RESIZERS || (nt &#x3D; nextTable) &#x3D;&#x3D; null ||\n                    transferIndex &lt;&#x3D; 0)\n                    break;\n                &#x2F;&#x2F; 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法\n                &#x2F;&#x2F;    此时 nextTab 不为 null\n                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))\n                    transfer(tab, nt);\n            &#125;\n            &#x2F;&#x2F; 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)\n            &#x2F;&#x2F;     我是没看懂这个值真正的意义是什么？不过可以计算出来的是，结果是一个比较大的负数\n            &#x2F;&#x2F;  调用 transfer 方法，此时 nextTab 参数为 null\n            else if (U.compareAndSwapInt(this, SIZECTL, sc,\n                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))\n                transfer(tab, null);\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。</p>\n<p>所以，可能的操作就是执行 **1 次 transfer(tab, null) + 多次 transfer(tab, nt)**，这里怎么结束循环的需要看完 transfer 源码才清楚。推荐阅读：<a href=\"https://mp.weixin.qq.com/s/Q5F604CUM_0x2co9mvADxw\">30 个 Java 集合面试问题及答案</a>。</p>\n<h6 id=\"数据迁移：transfer\"><a href=\"#数据迁移：transfer\" class=\"headerlink\" title=\"数据迁移：transfer\"></a>数据迁移：transfer</h6><p>下面这个方法很点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。</p>\n<p>虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。</p>\n<p>此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。</p>\n<p>阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 stride，简单理解就是步长，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。</p>\n<p>第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后从后往前的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;\n    int n &#x3D; tab.length, stride;\n \n    &#x2F;&#x2F; stride 在单核下直接等于 n，多核模式下为 (n&gt;&gt;&gt;3)&#x2F;NCPU，最小值是 16\n    &#x2F;&#x2F; stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，\n    &#x2F;&#x2F;   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务\n    if ((stride &#x3D; (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) &#x2F; NCPU : n) &lt; MIN_TRANSFER_STRIDE)\n        stride &#x3D; MIN_TRANSFER_STRIDE; &#x2F;&#x2F; subdivide range\n \n    &#x2F;&#x2F; 如果 nextTab 为 null，先进行一次初始化\n    &#x2F;&#x2F;    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null\n    &#x2F;&#x2F;       之后参与迁移的线程调用此方法时，nextTab 不会为 null\n    if (nextTab &#x3D;&#x3D; null) &#123;\n        try &#123;\n            &#x2F;&#x2F; 容量翻倍\n            Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];\n            nextTab &#x3D; nt;\n        &#125; catch (Throwable ex) &#123;      &#x2F;&#x2F; try to cope with OOME\n            sizeCtl &#x3D; Integer.MAX_VALUE;\n            return;\n        &#125;\n        &#x2F;&#x2F; nextTable 是 ConcurrentHashMap 中的属性\n        nextTable &#x3D; nextTab;\n        &#x2F;&#x2F; transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置\n        transferIndex &#x3D; n;\n    &#125;\n \n    int nextn &#x3D; nextTab.length;\n \n    &#x2F;&#x2F; ForwardingNode 翻译过来就是正在被迁移的 Node\n    &#x2F;&#x2F; 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED\n    &#x2F;&#x2F; 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，\n    &#x2F;&#x2F;    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了\n    &#x2F;&#x2F;    所以它其实相当于是一个标志。\n    ForwardingNode&lt;K,V&gt; fwd &#x3D; new ForwardingNode&lt;K,V&gt;(nextTab);\n \n \n    &#x2F;&#x2F; advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了\n    boolean advance &#x3D; true;\n    boolean finishing &#x3D; false; &#x2F;&#x2F; to ensure sweep before committing nextTab\n \n    &#x2F;*\n     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看\n     * \n     *&#x2F;\n \n    &#x2F;&#x2F; i 是位置索引，bound 是边界，注意是从后往前\n    for (int i &#x3D; 0, bound &#x3D; 0;;) &#123;\n        Node&lt;K,V&gt; f; int fh;\n \n        &#x2F;&#x2F; 下面这个 while 真的是不好理解\n        &#x2F;&#x2F; advance 为 true 表示可以进行下一个位置的迁移了\n        &#x2F;&#x2F;   简单理解结局：i 指向了 transferIndex，bound 指向了 transferIndex-stride\n        while (advance) &#123;\n            int nextIndex, nextBound;\n            if (--i &gt;&#x3D; bound || finishing)\n                advance &#x3D; false;\n \n            &#x2F;&#x2F; 将 transferIndex 值赋给 nextIndex\n            &#x2F;&#x2F; 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了\n            else if ((nextIndex &#x3D; transferIndex) &lt;&#x3D; 0) &#123;\n                i &#x3D; -1;\n                advance &#x3D; false;\n            &#125;\n            else if (U.compareAndSwapInt\n                     (this, TRANSFERINDEX, nextIndex,\n                      nextBound &#x3D; (nextIndex &gt; stride ?\n                                   nextIndex - stride : 0))) &#123;\n                &#x2F;&#x2F; 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前\n                bound &#x3D; nextBound;\n                i &#x3D; nextIndex - 1;\n                advance &#x3D; false;\n            &#125;\n        &#125;\n        if (i &lt; 0 || i &gt;&#x3D; n || i + n &gt;&#x3D; nextn) &#123;\n            int sc;\n            if (finishing) &#123;\n                &#x2F;&#x2F; 所有的迁移操作已经完成\n                nextTable &#x3D; null;\n                &#x2F;&#x2F; 将新的 nextTab 赋值给 table 属性，完成迁移\n                table &#x3D; nextTab;\n                &#x2F;&#x2F; 重新计算 sizeCtl：n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍\n                sizeCtl &#x3D; (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);\n                return;\n            &#125;\n \n            &#x2F;&#x2F; 之前我们说过，sizeCtl 在迁移前会设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2\n            &#x2F;&#x2F; 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，\n            &#x2F;&#x2F; 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务\n            if (U.compareAndSwapInt(this, SIZECTL, sc &#x3D; sizeCtl, sc - 1)) &#123;\n                &#x2F;&#x2F; 任务结束，方法退出\n                if ((sc - 2) !&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)\n                    return;\n \n                &#x2F;&#x2F; 到这里，说明 (sc - 2) &#x3D;&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，\n                &#x2F;&#x2F; 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing)&#123;&#125; 分支了\n                finishing &#x3D; advance &#x3D; true;\n                i &#x3D; n; &#x2F;&#x2F; recheck before commit\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“\n        else if ((f &#x3D; tabAt(tab, i)) &#x3D;&#x3D; null)\n            advance &#x3D; casTabAt(tab, i, null, fwd);\n        &#x2F;&#x2F; 该位置处是一个 ForwardingNode，代表该位置已经迁移过了\n        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)\n            advance &#x3D; true; &#x2F;&#x2F; already processed\n        else &#123;\n            &#x2F;&#x2F; 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作\n            synchronized (f) &#123;\n                if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;\n                    Node&lt;K,V&gt; ln, hn;\n                    &#x2F;&#x2F; 头结点的 hash 大于 0，说明是链表的 Node 节点\n                    if (fh &gt;&#x3D; 0) &#123;\n                        &#x2F;&#x2F; 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，\n                        &#x2F;&#x2F; 需要将链表一分为二，\n                        &#x2F;&#x2F;   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的\n                        &#x2F;&#x2F;   lastRun 之前的节点需要进行克隆，然后分到两个链表中\n                        int runBit &#x3D; fh &amp; n;\n                        Node&lt;K,V&gt; lastRun &#x3D; f;\n                        for (Node&lt;K,V&gt; p &#x3D; f.next; p !&#x3D; null; p &#x3D; p.next) &#123;\n                            int b &#x3D; p.hash &amp; n;\n                            if (b !&#x3D; runBit) &#123;\n                                runBit &#x3D; b;\n                                lastRun &#x3D; p;\n                            &#125;\n                        &#125;\n                        if (runBit &#x3D;&#x3D; 0) &#123;\n                            ln &#x3D; lastRun;\n                            hn &#x3D; null;\n                        &#125;\n                        else &#123;\n                            hn &#x3D; lastRun;\n                            ln &#x3D; null;\n                        &#125;\n                        for (Node&lt;K,V&gt; p &#x3D; f; p !&#x3D; lastRun; p &#x3D; p.next) &#123;\n                            int ph &#x3D; p.hash; K pk &#x3D; p.key; V pv &#x3D; p.val;\n                            if ((ph &amp; n) &#x3D;&#x3D; 0)\n                                ln &#x3D; new Node&lt;K,V&gt;(ph, pk, pv, ln);\n                            else\n                                hn &#x3D; new Node&lt;K,V&gt;(ph, pk, pv, hn);\n                        &#125;\n                        &#x2F;&#x2F; 其中的一个链表放在新数组的位置 i\n                        setTabAt(nextTab, i, ln);\n                        &#x2F;&#x2F; 另一个链表放在新数组的位置 i+n\n                        setTabAt(nextTab, i + n, hn);\n                        &#x2F;&#x2F; 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，\n                        &#x2F;&#x2F;    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了\n                        setTabAt(tab, i, fwd);\n                        &#x2F;&#x2F; advance 设置为 true，代表该位置已经迁移完毕\n                        advance &#x3D; true;\n                    &#125;\n                    else if (f instanceof TreeBin) &#123;\n                        &#x2F;&#x2F; 红黑树的迁移\n                        TreeBin&lt;K,V&gt; t &#x3D; (TreeBin&lt;K,V&gt;)f;\n                        TreeNode&lt;K,V&gt; lo &#x3D; null, loTail &#x3D; null;\n                        TreeNode&lt;K,V&gt; hi &#x3D; null, hiTail &#x3D; null;\n                        int lc &#x3D; 0, hc &#x3D; 0;\n                        for (Node&lt;K,V&gt; e &#x3D; t.first; e !&#x3D; null; e &#x3D; e.next) &#123;\n                            int h &#x3D; e.hash;\n                            TreeNode&lt;K,V&gt; p &#x3D; new TreeNode&lt;K,V&gt;\n                                (h, e.key, e.val, null, null);\n                            if ((h &amp; n) &#x3D;&#x3D; 0) &#123;\n                                if ((p.prev &#x3D; loTail) &#x3D;&#x3D; null)\n                                    lo &#x3D; p;\n                                else\n                                    loTail.next &#x3D; p;\n                                loTail &#x3D; p;\n                                ++lc;\n                            &#125;\n                            else &#123;\n                                if ((p.prev &#x3D; hiTail) &#x3D;&#x3D; null)\n                                    hi &#x3D; p;\n                                else\n                                    hiTail.next &#x3D; p;\n                                hiTail &#x3D; p;\n                                ++hc;\n                            &#125;\n                        &#125;\n                        &#x2F;&#x2F; 如果一分为二后，节点数少于 8，那么将红黑树转换回链表\n                        ln &#x3D; (lc &lt;&#x3D; UNTREEIFY_THRESHOLD) ? untreeify(lo) :\n                            (hc !&#x3D; 0) ? new TreeBin&lt;K,V&gt;(lo) : t;\n                        hn &#x3D; (hc &lt;&#x3D; UNTREEIFY_THRESHOLD) ? untreeify(hi) :\n                            (lc !&#x3D; 0) ? new TreeBin&lt;K,V&gt;(hi) : t;\n \n                        &#x2F;&#x2F; 将 ln 放置在新数组的位置 i\n                        setTabAt(nextTab, i, ln);\n                        &#x2F;&#x2F; 将 hn 放置在新数组的位置 i+n\n                        setTabAt(nextTab, i + n, hn);\n                        &#x2F;&#x2F; 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，\n                        &#x2F;&#x2F;    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了\n                        setTabAt(tab, i, fwd);\n                        &#x2F;&#x2F; advance 设置为 true，代表该位置已经迁移完毕\n                        advance &#x3D; true;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。</p>\n<p>这个时候，再回去仔细看 tryPresize 方法可能就会更加清晰一些了。</p>\n<h4 id=\"get-过程分析-3\"><a href=\"#get-过程分析-3\" class=\"headerlink\" title=\"get 过程分析\"></a>get 过程分析</h4><p>get 方法从来都是最简单的，这里也不例外：</p>\n<p>1.计算 hash 值</p>\n<p>2.根据 hash 值找到数组对应位置: (n – 1) &amp; h</p>\n<p>3.根据该位置处结点性质进行相应查找</p>\n<ul>\n<li>如果该位置为 null，那么直接返回 null 就可以了</li>\n<li>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</li>\n<li>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法</li>\n<li>如果以上 3 条都不满足，那就是链表，进行遍历比对即可。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public V get(Object key) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;\n    int h &#x3D; spread(key.hashCode());\n    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;\n        (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123;\n        &#x2F;&#x2F; 判断头结点是否就是我们需要的节点\n        if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123;\n            if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek)))\n                return e.val;\n        &#125;\n        &#x2F;&#x2F; 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树\n        else if (eh &lt; 0)\n            &#x2F;&#x2F; 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)\n            return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;\n \n        &#x2F;&#x2F; 遍历链表\n        while ((e &#x3D; e.next) !&#x3D; null) &#123;\n            if (e.hash &#x3D;&#x3D; h &amp;&amp;\n                ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))\n                return e.val;\n        &#125;\n    &#125;\n    return null;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，ForwardingNode.find(int h, Object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了，所以限于篇幅这里也不展开说了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其实也不是很难嘛，虽然没有像之前的 AQS 和线程池一样一行一行源码进行分析，但还是把所有初学者可能会糊涂的地方都进行了深入的介绍，只要是稍微有点基础的读者，应该是很容易就能看懂 HashMap 和 ConcurrentHashMap 源码了。</p>\n<p>看源码不算是目的吧，深入地了解 Doug Lea 的设计思路，我觉得还挺有趣的，大师就是大师，代码写得真的是好啊。</p>\n<p>我发现很多人都以为我写博客主要是源码分析，说真的，我对于源码分析没有那么大热情，主要都是为了用源码说事罢了，可能之后的文章还是会有比较多的源码分析成分，大家该怎么看就怎么看吧。</p>\n<p>不要脸地自以为本文的质量还是挺高的，信息量比较大，如果你觉得有写得不好的地方，或者说看完本文你还是没看懂它们，那么请提出来~~~</p>\n"},{"title":"Java 10 局部变量类型推断介绍及实战","date":"2025-10-15T03:36:33.000Z","_content":"现在 Java 9 被遗弃了直接升级到了 Java 10，之前也发过 Java 10 新特性的文章，现在是开始实战 Java 10 的时候了。\n\n今天要实战的是 Java 10 中最重要的特性：局部变量类型推断，大家都知道是 `var` 关键字，但具体怎么使用，及要注意什么要点呢？\n\n我们通过几个例子来讲解局部变量类型推断这个新特性！\n\n\n### 什么是局部变量类型推断\n\n```\nvar javastack = \"javastack\";\nSystem.out.println(javastack);\n```\n\n大家看出来了，局部变量类型推断就是左边的类型直接使用 `var` 定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型，如上面的 `String` 。\n\n```\nvar javastack = \"javastack\";\n```\n\n就等于：\n\n```\nString javastack = \"javastack\";\n```\n\n### 局部变量类型推断使用示例\n\n既然叫局部变量类型推断，以只能用在局部变量中，下面给出更多使用示例。\n\n**1、字面量定义局部变量**\n\n```\nprivate static void testVar() {\n\tvar javastack = \"javastack\";\n\tSystem.out.println(javastack);\n}\n```\n\n**2、接收方法返回值定义局部变量**\n\n\n```\nprivate static void testMethod() {\n\tvar javastack = getJavastack();\n\tSystem.out.println(javastack);\n}\n\npublic static String getJavastack() {\n\treturn \"javastack\";\n}\n```\n\n**3、循环中定义局部变量**\n\n```\nprivate static void testLoop() {\n\tfor (var i = 0; i < 3; i++) {\n\t\tfor (var m = 10; m < 15; m++) {\n\t\t\tSystem.out.println(i + m);\n\t\t}\n\t}\n}\n```\n\n**4、泛型结合局部变量**\n\n```\nprivate static void testGeneric() {\n\t// 表达式1\n\tList<String> list1 = new ArrayList<>();\n\tlist1.add(\"javastack\");\n\n\t// 表达式2\n\tvar list2 = new ArrayList<>();\n\tlist2.add(2018);\n\n\t// 表达式3\n\tvar list3 = new ArrayList<String>();\n\tlist3.add(\"javastack\");\n}\n```\n\n表达式1后面 `<>` 里面 jdk 1.7+开始是不用带具体类型的，在接口中指明就行了。\n\n表达式2中如果使用 `var` 的话，`<>` 里面默认会是 `Object` 的，所以可以添加任意类型。\n\n表达式3中在 `<>` 强制使用了 String 来指定泛型。\n\n\n### 局部变量类型推断不能用在以下场景\n\n**1、类成员变量类型**\n\n```\n// 编译报错\nprivate var javastack = \"Java技术\";\n```\n\n**2、方法返回类型**\n\n```\n/**\n * 编译报错\n * @return\n */\npublic static var getJavastack(){\n \treturn \"Java技术\";\n}\n```\n\n**3、Lambda 表达式**\n\n```\nprivate static void testLambda() {\n\tRunnable runnable = () -> System.out.println(\"javastack\");\n\n\t// 编译报错\n\t// var runnable = () -> System.out.println(\"javastack\");\n}\n```\n\n以上 3 种场景是肯定不能使用 `var` 的，其他场合有待验证。\n\n\n### 局部变量类型推断优缺点\n\n**优点：简化代码**\n\n```\nCopyOnWriteArrayList list1 = new CopyOnWriteArrayList();\nConcurrentModificationException cme1 = new ConcurrentModificationException();\nDefaultServiceUnavailableRetryStrategy strategy1 = new\n\t\tDefaultServiceUnavailableRetryStrategy();\n\nvar list2 = new CopyOnWriteArrayList<>();\nvar cme2 = new ConcurrentModificationException();\nvar strategy2 = new DefaultServiceUnavailableRetryStrategy();\n```\n\n从以上代码可以看出，很长的定义类型会显得代码很冗长，使用 var 大大简化了代码编写，同时类型统一显得代码很对齐。\n\n**缺点：掩盖类型**\n\n```\nvar token = new JsonParserDelegate(parser).currentToken();\n```\n\n看以上代码，不进去看返回结果类型，谁知道返回的类型是什么？所以这种情况最好别使用 `var`，而使用具体的抽象类、接口或者实例类型。\n\n### var关键字原理\n\nvar其实就是 Java 10 增加的一种语法糖而已，在编译期间会自动推断实际类型，其编译后的字节码和实际类型一致，如以下例子所示。\n\n\n```\nprivate static void testByteCode() {\n\tString javastack1 = \"javastack\";\n\tvar javastack2 = \"javastack\";\n}\n```\n\n编译成字节码后：\n\n```\nprivate static testByteCode()V\nL0\nLINENUMBER 22 L0\nLDC \"javastack\"\nASTORE 0\nL1\nLINENUMBER 23 L1\nLDC \"javastack\"\nASTORE 1\nL2\nLINENUMBER 24 L2\nRETURN\nL3\nLOCALVARIABLE javastack1 Ljava/lang/String; L1 L3 0\nLOCALVARIABLE javastack2 Ljava/lang/String; L2 L3 1\nMAXSTACK = 1\nMAXLOCALS = 2\n```\n\n可以看出 `javastack1` 和 `javastack2` 都是虚拟机所认识的的本地变量类型：`java.lang.String`，虚拟机并不认识 var,  所以 `var` 并不神奇。\n\nOK，本次 Java 10 局部变量类型推断实战文章就到这里了，后续带来更多的 Java 10 的实战方面的文章。\n\n\n","source":"_posts/新特性/Java10/Java 10 局部变量类型推断介绍及实战.md","raw":"---\ntitle: Java 10 局部变量类型推断介绍及实战\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n现在 Java 9 被遗弃了直接升级到了 Java 10，之前也发过 Java 10 新特性的文章，现在是开始实战 Java 10 的时候了。\n\n今天要实战的是 Java 10 中最重要的特性：局部变量类型推断，大家都知道是 `var` 关键字，但具体怎么使用，及要注意什么要点呢？\n\n我们通过几个例子来讲解局部变量类型推断这个新特性！\n\n\n### 什么是局部变量类型推断\n\n```\nvar javastack = \"javastack\";\nSystem.out.println(javastack);\n```\n\n大家看出来了，局部变量类型推断就是左边的类型直接使用 `var` 定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型，如上面的 `String` 。\n\n```\nvar javastack = \"javastack\";\n```\n\n就等于：\n\n```\nString javastack = \"javastack\";\n```\n\n### 局部变量类型推断使用示例\n\n既然叫局部变量类型推断，以只能用在局部变量中，下面给出更多使用示例。\n\n**1、字面量定义局部变量**\n\n```\nprivate static void testVar() {\n\tvar javastack = \"javastack\";\n\tSystem.out.println(javastack);\n}\n```\n\n**2、接收方法返回值定义局部变量**\n\n\n```\nprivate static void testMethod() {\n\tvar javastack = getJavastack();\n\tSystem.out.println(javastack);\n}\n\npublic static String getJavastack() {\n\treturn \"javastack\";\n}\n```\n\n**3、循环中定义局部变量**\n\n```\nprivate static void testLoop() {\n\tfor (var i = 0; i < 3; i++) {\n\t\tfor (var m = 10; m < 15; m++) {\n\t\t\tSystem.out.println(i + m);\n\t\t}\n\t}\n}\n```\n\n**4、泛型结合局部变量**\n\n```\nprivate static void testGeneric() {\n\t// 表达式1\n\tList<String> list1 = new ArrayList<>();\n\tlist1.add(\"javastack\");\n\n\t// 表达式2\n\tvar list2 = new ArrayList<>();\n\tlist2.add(2018);\n\n\t// 表达式3\n\tvar list3 = new ArrayList<String>();\n\tlist3.add(\"javastack\");\n}\n```\n\n表达式1后面 `<>` 里面 jdk 1.7+开始是不用带具体类型的，在接口中指明就行了。\n\n表达式2中如果使用 `var` 的话，`<>` 里面默认会是 `Object` 的，所以可以添加任意类型。\n\n表达式3中在 `<>` 强制使用了 String 来指定泛型。\n\n\n### 局部变量类型推断不能用在以下场景\n\n**1、类成员变量类型**\n\n```\n// 编译报错\nprivate var javastack = \"Java技术\";\n```\n\n**2、方法返回类型**\n\n```\n/**\n * 编译报错\n * @return\n */\npublic static var getJavastack(){\n \treturn \"Java技术\";\n}\n```\n\n**3、Lambda 表达式**\n\n```\nprivate static void testLambda() {\n\tRunnable runnable = () -> System.out.println(\"javastack\");\n\n\t// 编译报错\n\t// var runnable = () -> System.out.println(\"javastack\");\n}\n```\n\n以上 3 种场景是肯定不能使用 `var` 的，其他场合有待验证。\n\n\n### 局部变量类型推断优缺点\n\n**优点：简化代码**\n\n```\nCopyOnWriteArrayList list1 = new CopyOnWriteArrayList();\nConcurrentModificationException cme1 = new ConcurrentModificationException();\nDefaultServiceUnavailableRetryStrategy strategy1 = new\n\t\tDefaultServiceUnavailableRetryStrategy();\n\nvar list2 = new CopyOnWriteArrayList<>();\nvar cme2 = new ConcurrentModificationException();\nvar strategy2 = new DefaultServiceUnavailableRetryStrategy();\n```\n\n从以上代码可以看出，很长的定义类型会显得代码很冗长，使用 var 大大简化了代码编写，同时类型统一显得代码很对齐。\n\n**缺点：掩盖类型**\n\n```\nvar token = new JsonParserDelegate(parser).currentToken();\n```\n\n看以上代码，不进去看返回结果类型，谁知道返回的类型是什么？所以这种情况最好别使用 `var`，而使用具体的抽象类、接口或者实例类型。\n\n### var关键字原理\n\nvar其实就是 Java 10 增加的一种语法糖而已，在编译期间会自动推断实际类型，其编译后的字节码和实际类型一致，如以下例子所示。\n\n\n```\nprivate static void testByteCode() {\n\tString javastack1 = \"javastack\";\n\tvar javastack2 = \"javastack\";\n}\n```\n\n编译成字节码后：\n\n```\nprivate static testByteCode()V\nL0\nLINENUMBER 22 L0\nLDC \"javastack\"\nASTORE 0\nL1\nLINENUMBER 23 L1\nLDC \"javastack\"\nASTORE 1\nL2\nLINENUMBER 24 L2\nRETURN\nL3\nLOCALVARIABLE javastack1 Ljava/lang/String; L1 L3 0\nLOCALVARIABLE javastack2 Ljava/lang/String; L2 L3 1\nMAXSTACK = 1\nMAXLOCALS = 2\n```\n\n可以看出 `javastack1` 和 `javastack2` 都是虚拟机所认识的的本地变量类型：`java.lang.String`，虚拟机并不认识 var,  所以 `var` 并不神奇。\n\nOK，本次 Java 10 局部变量类型推断实战文章就到这里了，后续带来更多的 Java 10 的实战方面的文章。\n\n\n","slug":"新特性/Java10/Java 10 局部变量类型推断介绍及实战","published":1,"updated":"2025-10-15T07:20:51.453Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu07710054qkd46z658v2m","content":"<p>现在 Java 9 被遗弃了直接升级到了 Java 10，之前也发过 Java 10 新特性的文章，现在是开始实战 Java 10 的时候了。</p>\n<p>今天要实战的是 Java 10 中最重要的特性：局部变量类型推断，大家都知道是 <code>var</code> 关键字，但具体怎么使用，及要注意什么要点呢？</p>\n<p>我们通过几个例子来讲解局部变量类型推断这个新特性！</p>\n<h3 id=\"什么是局部变量类型推断\"><a href=\"#什么是局部变量类型推断\" class=\"headerlink\" title=\"什么是局部变量类型推断\"></a>什么是局部变量类型推断</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">var javastack &#x3D; &quot;javastack&quot;;\nSystem.out.println(javastack);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>大家看出来了，局部变量类型推断就是左边的类型直接使用 <code>var</code> 定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型，如上面的 <code>String</code> 。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var javastack &#x3D; &quot;javastack&quot;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>就等于：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">String javastack &#x3D; &quot;javastack&quot;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"局部变量类型推断使用示例\"><a href=\"#局部变量类型推断使用示例\" class=\"headerlink\" title=\"局部变量类型推断使用示例\"></a>局部变量类型推断使用示例</h3><p>既然叫局部变量类型推断，以只能用在局部变量中，下面给出更多使用示例。</p>\n<p><strong>1、字面量定义局部变量</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testVar() &#123;\n\tvar javastack &#x3D; &quot;javastack&quot;;\n\tSystem.out.println(javastack);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>2、接收方法返回值定义局部变量</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testMethod() &#123;\n\tvar javastack &#x3D; getJavastack();\n\tSystem.out.println(javastack);\n&#125;\n\npublic static String getJavastack() &#123;\n\treturn &quot;javastack&quot;;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>3、循环中定义局部变量</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testLoop() &#123;\n\tfor (var i &#x3D; 0; i &lt; 3; i++) &#123;\n\t\tfor (var m &#x3D; 10; m &lt; 15; m++) &#123;\n\t\t\tSystem.out.println(i + m);\n\t\t&#125;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>4、泛型结合局部变量</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testGeneric() &#123;\n\t&#x2F;&#x2F; 表达式1\n\tList&lt;String&gt; list1 &#x3D; new ArrayList&lt;&gt;();\n\tlist1.add(&quot;javastack&quot;);\n\n\t&#x2F;&#x2F; 表达式2\n\tvar list2 &#x3D; new ArrayList&lt;&gt;();\n\tlist2.add(2018);\n\n\t&#x2F;&#x2F; 表达式3\n\tvar list3 &#x3D; new ArrayList&lt;String&gt;();\n\tlist3.add(&quot;javastack&quot;);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>表达式1后面 <code>&lt;&gt;</code> 里面 jdk 1.7+开始是不用带具体类型的，在接口中指明就行了。</p>\n<p>表达式2中如果使用 <code>var</code> 的话，<code>&lt;&gt;</code> 里面默认会是 <code>Object</code> 的，所以可以添加任意类型。</p>\n<p>表达式3中在 <code>&lt;&gt;</code> 强制使用了 String 来指定泛型。</p>\n<h3 id=\"局部变量类型推断不能用在以下场景\"><a href=\"#局部变量类型推断不能用在以下场景\" class=\"headerlink\" title=\"局部变量类型推断不能用在以下场景\"></a>局部变量类型推断不能用在以下场景</h3><p><strong>1、类成员变量类型</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 编译报错\nprivate var javastack &#x3D; &quot;Java技术&quot;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><strong>2、方法返回类型</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * 编译报错\n * @return\n *&#x2F;\npublic static var getJavastack()&#123;\n \treturn &quot;Java技术&quot;;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>3、Lambda 表达式</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testLambda() &#123;\n\tRunnable runnable &#x3D; () -&gt; System.out.println(&quot;javastack&quot;);\n\n\t&#x2F;&#x2F; 编译报错\n\t&#x2F;&#x2F; var runnable &#x3D; () -&gt; System.out.println(&quot;javastack&quot;);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上 3 种场景是肯定不能使用 <code>var</code> 的，其他场合有待验证。</p>\n<h3 id=\"局部变量类型推断优缺点\"><a href=\"#局部变量类型推断优缺点\" class=\"headerlink\" title=\"局部变量类型推断优缺点\"></a>局部变量类型推断优缺点</h3><p><strong>优点：简化代码</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">CopyOnWriteArrayList list1 &#x3D; new CopyOnWriteArrayList();\nConcurrentModificationException cme1 &#x3D; new ConcurrentModificationException();\nDefaultServiceUnavailableRetryStrategy strategy1 &#x3D; new\n\t\tDefaultServiceUnavailableRetryStrategy();\n\nvar list2 &#x3D; new CopyOnWriteArrayList&lt;&gt;();\nvar cme2 &#x3D; new ConcurrentModificationException();\nvar strategy2 &#x3D; new DefaultServiceUnavailableRetryStrategy();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>从以上代码可以看出，很长的定义类型会显得代码很冗长，使用 var 大大简化了代码编写，同时类型统一显得代码很对齐。</p>\n<p><strong>缺点：掩盖类型</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var token &#x3D; new JsonParserDelegate(parser).currentToken();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>看以上代码，不进去看返回结果类型，谁知道返回的类型是什么？所以这种情况最好别使用 <code>var</code>，而使用具体的抽象类、接口或者实例类型。</p>\n<h3 id=\"var关键字原理\"><a href=\"#var关键字原理\" class=\"headerlink\" title=\"var关键字原理\"></a>var关键字原理</h3><p>var其实就是 Java 10 增加的一种语法糖而已，在编译期间会自动推断实际类型，其编译后的字节码和实际类型一致，如以下例子所示。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testByteCode() &#123;\n\tString javastack1 &#x3D; &quot;javastack&quot;;\n\tvar javastack2 &#x3D; &quot;javastack&quot;;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>编译成字节码后：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static testByteCode()V\nL0\nLINENUMBER 22 L0\nLDC &quot;javastack&quot;\nASTORE 0\nL1\nLINENUMBER 23 L1\nLDC &quot;javastack&quot;\nASTORE 1\nL2\nLINENUMBER 24 L2\nRETURN\nL3\nLOCALVARIABLE javastack1 Ljava&#x2F;lang&#x2F;String; L1 L3 0\nLOCALVARIABLE javastack2 Ljava&#x2F;lang&#x2F;String; L2 L3 1\nMAXSTACK &#x3D; 1\nMAXLOCALS &#x3D; 2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出 <code>javastack1</code> 和 <code>javastack2</code> 都是虚拟机所认识的的本地变量类型：<code>java.lang.String</code>，虚拟机并不认识 var,  所以 <code>var</code> 并不神奇。</p>\n<p>OK，本次 Java 10 局部变量类型推断实战文章就到这里了，后续带来更多的 Java 10 的实战方面的文章。</p>\n","excerpt":"","more":"<p>现在 Java 9 被遗弃了直接升级到了 Java 10，之前也发过 Java 10 新特性的文章，现在是开始实战 Java 10 的时候了。</p>\n<p>今天要实战的是 Java 10 中最重要的特性：局部变量类型推断，大家都知道是 <code>var</code> 关键字，但具体怎么使用，及要注意什么要点呢？</p>\n<p>我们通过几个例子来讲解局部变量类型推断这个新特性！</p>\n<h3 id=\"什么是局部变量类型推断\"><a href=\"#什么是局部变量类型推断\" class=\"headerlink\" title=\"什么是局部变量类型推断\"></a>什么是局部变量类型推断</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">var javastack &#x3D; &quot;javastack&quot;;\nSystem.out.println(javastack);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>大家看出来了，局部变量类型推断就是左边的类型直接使用 <code>var</code> 定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型，如上面的 <code>String</code> 。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var javastack &#x3D; &quot;javastack&quot;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>就等于：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">String javastack &#x3D; &quot;javastack&quot;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"局部变量类型推断使用示例\"><a href=\"#局部变量类型推断使用示例\" class=\"headerlink\" title=\"局部变量类型推断使用示例\"></a>局部变量类型推断使用示例</h3><p>既然叫局部变量类型推断，以只能用在局部变量中，下面给出更多使用示例。</p>\n<p><strong>1、字面量定义局部变量</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testVar() &#123;\n\tvar javastack &#x3D; &quot;javastack&quot;;\n\tSystem.out.println(javastack);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>2、接收方法返回值定义局部变量</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testMethod() &#123;\n\tvar javastack &#x3D; getJavastack();\n\tSystem.out.println(javastack);\n&#125;\n\npublic static String getJavastack() &#123;\n\treturn &quot;javastack&quot;;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>3、循环中定义局部变量</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testLoop() &#123;\n\tfor (var i &#x3D; 0; i &lt; 3; i++) &#123;\n\t\tfor (var m &#x3D; 10; m &lt; 15; m++) &#123;\n\t\t\tSystem.out.println(i + m);\n\t\t&#125;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>4、泛型结合局部变量</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testGeneric() &#123;\n\t&#x2F;&#x2F; 表达式1\n\tList&lt;String&gt; list1 &#x3D; new ArrayList&lt;&gt;();\n\tlist1.add(&quot;javastack&quot;);\n\n\t&#x2F;&#x2F; 表达式2\n\tvar list2 &#x3D; new ArrayList&lt;&gt;();\n\tlist2.add(2018);\n\n\t&#x2F;&#x2F; 表达式3\n\tvar list3 &#x3D; new ArrayList&lt;String&gt;();\n\tlist3.add(&quot;javastack&quot;);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>表达式1后面 <code>&lt;&gt;</code> 里面 jdk 1.7+开始是不用带具体类型的，在接口中指明就行了。</p>\n<p>表达式2中如果使用 <code>var</code> 的话，<code>&lt;&gt;</code> 里面默认会是 <code>Object</code> 的，所以可以添加任意类型。</p>\n<p>表达式3中在 <code>&lt;&gt;</code> 强制使用了 String 来指定泛型。</p>\n<h3 id=\"局部变量类型推断不能用在以下场景\"><a href=\"#局部变量类型推断不能用在以下场景\" class=\"headerlink\" title=\"局部变量类型推断不能用在以下场景\"></a>局部变量类型推断不能用在以下场景</h3><p><strong>1、类成员变量类型</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 编译报错\nprivate var javastack &#x3D; &quot;Java技术&quot;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><strong>2、方法返回类型</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * 编译报错\n * @return\n *&#x2F;\npublic static var getJavastack()&#123;\n \treturn &quot;Java技术&quot;;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>3、Lambda 表达式</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testLambda() &#123;\n\tRunnable runnable &#x3D; () -&gt; System.out.println(&quot;javastack&quot;);\n\n\t&#x2F;&#x2F; 编译报错\n\t&#x2F;&#x2F; var runnable &#x3D; () -&gt; System.out.println(&quot;javastack&quot;);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上 3 种场景是肯定不能使用 <code>var</code> 的，其他场合有待验证。</p>\n<h3 id=\"局部变量类型推断优缺点\"><a href=\"#局部变量类型推断优缺点\" class=\"headerlink\" title=\"局部变量类型推断优缺点\"></a>局部变量类型推断优缺点</h3><p><strong>优点：简化代码</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">CopyOnWriteArrayList list1 &#x3D; new CopyOnWriteArrayList();\nConcurrentModificationException cme1 &#x3D; new ConcurrentModificationException();\nDefaultServiceUnavailableRetryStrategy strategy1 &#x3D; new\n\t\tDefaultServiceUnavailableRetryStrategy();\n\nvar list2 &#x3D; new CopyOnWriteArrayList&lt;&gt;();\nvar cme2 &#x3D; new ConcurrentModificationException();\nvar strategy2 &#x3D; new DefaultServiceUnavailableRetryStrategy();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>从以上代码可以看出，很长的定义类型会显得代码很冗长，使用 var 大大简化了代码编写，同时类型统一显得代码很对齐。</p>\n<p><strong>缺点：掩盖类型</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var token &#x3D; new JsonParserDelegate(parser).currentToken();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>看以上代码，不进去看返回结果类型，谁知道返回的类型是什么？所以这种情况最好别使用 <code>var</code>，而使用具体的抽象类、接口或者实例类型。</p>\n<h3 id=\"var关键字原理\"><a href=\"#var关键字原理\" class=\"headerlink\" title=\"var关键字原理\"></a>var关键字原理</h3><p>var其实就是 Java 10 增加的一种语法糖而已，在编译期间会自动推断实际类型，其编译后的字节码和实际类型一致，如以下例子所示。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testByteCode() &#123;\n\tString javastack1 &#x3D; &quot;javastack&quot;;\n\tvar javastack2 &#x3D; &quot;javastack&quot;;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>编译成字节码后：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static testByteCode()V\nL0\nLINENUMBER 22 L0\nLDC &quot;javastack&quot;\nASTORE 0\nL1\nLINENUMBER 23 L1\nLDC &quot;javastack&quot;\nASTORE 1\nL2\nLINENUMBER 24 L2\nRETURN\nL3\nLOCALVARIABLE javastack1 Ljava&#x2F;lang&#x2F;String; L1 L3 0\nLOCALVARIABLE javastack2 Ljava&#x2F;lang&#x2F;String; L2 L3 1\nMAXSTACK &#x3D; 1\nMAXLOCALS &#x3D; 2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出 <code>javastack1</code> 和 <code>javastack2</code> 都是虚拟机所认识的的本地变量类型：<code>java.lang.String</code>，虚拟机并不认识 var,  所以 <code>var</code> 并不神奇。</p>\n<p>OK，本次 Java 10 局部变量类型推断实战文章就到这里了，后续带来更多的 Java 10 的实战方面的文章。</p>\n"},{"title":"Java 10 的 10 个新特性，将彻底改变你写代码的方式","date":"2025-10-15T03:36:33.000Z","_content":"\n![image](http://img.javastack.cn/18-3-8/94675270.jpg)\n\nJava 9才发布几个月，很多玩意都没整明白，现在Java 10又快要来了。。\n\n这时候我真尼玛想说：线上用的JDK 7 甚至JDK 6，JDK 8 还没用熟，JDK 9 才发布不久不知道啥玩意，JDK 10……\n\n刚学Java的同学是不是感觉一脸蒙逼？！！！\n\n就连我这个老司机也同样感觉如此！\n\nJava 更新越来越快，我们做技术的也要跟上步伐，不然总会慢别人一拍，这新东西从国外到国内应用一般要好几年的时间，如果我们提前了解并应用这些新技术对自己不是坏事。\n\n### Java 10的新特性\n\n说了这么多，看Java 10都会有哪些特性来改变我们写代码的方式呢？！\n\n#### 1.局部变量类型推断\n\n局部变量类型推断可以说是Java 10中最值得注意的特性，这是Java语言开发人员为了简化Java应用程序的编写而采取的又一步，如下图所示。\n\n![image](http://img.javastack.cn/18-3-8/56770623.jpg)\n\n这个新功能将为Java增加一些语法糖 - 简化它并改善开发者体验。新的语法将减少与编写Java相关的冗长度，同时保持对静态类型安全性的承诺。\n\n局部变量类型推断将引入\"var\"关键字，也就是你可以随意定义变量而不必指定变量的类型，如：\n\n```\nList <String> list = new ArrayList <String>（）; \nStream <String> stream = getStream（）;\n```\n\n将被下面这个新语法所取代：\n\n```\nvar list = new ArrayList <String>（）; \nvar stream = getStream（）;\n```\n\n看完是不是有点JS的即视感？？？越来越像JS了吗？！虽然类型推断在Java中不是一个新概念，但在局部变量中确是很大的一个改进。\n\n说到类型推断，从JDK 5引进泛型，到JDK 7的\"<>\"操作符允许不绑定类型而初始化List，再到JDK 8的Lambda表达式，再到现在JDK 10的局部变量类型推断，Java类型推断正大刀阔斧的向前发展。\n\n```\n// 该运算符允许在没有绑定ArrayList <>的类型的情况下初始化列表\nList <String> list = new LinkedList <>（）;\n```\n\n**局部变量类型推荐仅限于如下使用场景：**\n\n- 局部变量初始化\n- for循环内部索引变量\n- 传统的for循环声明变量\n\n**Java官方表示，它不能用于以下几个地方：**\n\n- 方法参数\n- 构造函数参数\n- 方法返回类型\n- 字段\n- 捕获表达式（或任何其他类型的变量声明）\n\n#### 2.GC改进和其他内务管理\n\nJDK 10中有2个JEP专门用于改进当前的垃圾收集元素。\n\n第一个垃圾收集器接口是（JEP 304），它将引入一个纯净的垃圾收集器接口，以帮助改进不同垃圾收集器的源代码隔离。\n\n预定用于Java 10的第二个JEP是针对G1的并行完全GC（JEP 307），其重点在于通过完全GC并行来改善G1最坏情况的等待时间。G1是Java 9中的默认GC，并且此JEP的目标是使G1平行。\n\n#### 3.线程本地握手（JEP 312）\n\nJDK 10将引入一种在线程上执行回调的新方法，因此这将会很方便能停止单个线程而不是停止全部线程或者一个都不停。\n\n#### 4.备用内存设备上的堆分配（JEP 316）\n\n允许HotSpot VM在备用内存设备上分配Java对象堆内存，该内存设备将由用户指定。\n\n#### 5.其他Unicode语言 - 标记扩展（JEP 314）\n\n目标是增强java.util.Locale及其相关的API，以便实现语言标记语法的其他Unicode扩展（BCP 47）。\n\n#### 6.基于Java的实验性JIT编译器（JEP 317）\n\nOracle希望将其Java JIT编译器Graal用作Linux / x64平台上的实验性JIT编译器。\n\n#### 7.根证书（JEP 319）\n\n这个的目标是在Oracle的Java SE中开源根证书。\n\n#### 8.根证书认证程序（CA）\n\n这将使OpenJDK对开发人员更具吸引力，它还旨在减少OpenJDK和Oracle JDK构建之间的差异。\n\n#### 9.将JDK生态整合到单个存储库中（JEP 296）\n\n此JEP的主要目标是执行一些内存管理，并将JDK生态的众多存储库组合到一个存储库中。\n\n#### 10.删除Native-Header生成工具（javah）（JEP 313）\n\n从JDK中移除了javah工具，这个很简单并且很重要。\n\n### 尝鲜\n\n就像所有其他JDK版本一样，Oracle已经发布了一个Java 10初始候选版本，Java开发者可以下载此版本用来测试新功能。如果你对Java 10抱有期待想提早尝试，那么现在就开始吧！\n\n> 尝鲜地址：http://openjdk.java.net/projects/jdk/10/\n\n#### 最后的感悟\n\n对于第一点新特性来说确实是一个大的跨越，其他特性或多或少都能带给开发者福音。但最终Java 10会是什么样，或许还会增加更多实用性的新功能或者优化，我们还得期待！\n\n现在要做的就是，赶紧熟悉JDK 8，现在已经是很多互联网企业标配了。如果还在使用JDK4-7，那真的是要OUT了。。\n\n在不久的将来，Java 10将彻底改变你写代码的方式！\n\n","source":"_posts/新特性/Java10/Java 10 的 10 个新特性，将彻底改变你写代码的方式.md","raw":"---\ntitle: Java 10 的 10 个新特性，将彻底改变你写代码的方式\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n\n![image](http://img.javastack.cn/18-3-8/94675270.jpg)\n\nJava 9才发布几个月，很多玩意都没整明白，现在Java 10又快要来了。。\n\n这时候我真尼玛想说：线上用的JDK 7 甚至JDK 6，JDK 8 还没用熟，JDK 9 才发布不久不知道啥玩意，JDK 10……\n\n刚学Java的同学是不是感觉一脸蒙逼？！！！\n\n就连我这个老司机也同样感觉如此！\n\nJava 更新越来越快，我们做技术的也要跟上步伐，不然总会慢别人一拍，这新东西从国外到国内应用一般要好几年的时间，如果我们提前了解并应用这些新技术对自己不是坏事。\n\n### Java 10的新特性\n\n说了这么多，看Java 10都会有哪些特性来改变我们写代码的方式呢？！\n\n#### 1.局部变量类型推断\n\n局部变量类型推断可以说是Java 10中最值得注意的特性，这是Java语言开发人员为了简化Java应用程序的编写而采取的又一步，如下图所示。\n\n![image](http://img.javastack.cn/18-3-8/56770623.jpg)\n\n这个新功能将为Java增加一些语法糖 - 简化它并改善开发者体验。新的语法将减少与编写Java相关的冗长度，同时保持对静态类型安全性的承诺。\n\n局部变量类型推断将引入\"var\"关键字，也就是你可以随意定义变量而不必指定变量的类型，如：\n\n```\nList <String> list = new ArrayList <String>（）; \nStream <String> stream = getStream（）;\n```\n\n将被下面这个新语法所取代：\n\n```\nvar list = new ArrayList <String>（）; \nvar stream = getStream（）;\n```\n\n看完是不是有点JS的即视感？？？越来越像JS了吗？！虽然类型推断在Java中不是一个新概念，但在局部变量中确是很大的一个改进。\n\n说到类型推断，从JDK 5引进泛型，到JDK 7的\"<>\"操作符允许不绑定类型而初始化List，再到JDK 8的Lambda表达式，再到现在JDK 10的局部变量类型推断，Java类型推断正大刀阔斧的向前发展。\n\n```\n// 该运算符允许在没有绑定ArrayList <>的类型的情况下初始化列表\nList <String> list = new LinkedList <>（）;\n```\n\n**局部变量类型推荐仅限于如下使用场景：**\n\n- 局部变量初始化\n- for循环内部索引变量\n- 传统的for循环声明变量\n\n**Java官方表示，它不能用于以下几个地方：**\n\n- 方法参数\n- 构造函数参数\n- 方法返回类型\n- 字段\n- 捕获表达式（或任何其他类型的变量声明）\n\n#### 2.GC改进和其他内务管理\n\nJDK 10中有2个JEP专门用于改进当前的垃圾收集元素。\n\n第一个垃圾收集器接口是（JEP 304），它将引入一个纯净的垃圾收集器接口，以帮助改进不同垃圾收集器的源代码隔离。\n\n预定用于Java 10的第二个JEP是针对G1的并行完全GC（JEP 307），其重点在于通过完全GC并行来改善G1最坏情况的等待时间。G1是Java 9中的默认GC，并且此JEP的目标是使G1平行。\n\n#### 3.线程本地握手（JEP 312）\n\nJDK 10将引入一种在线程上执行回调的新方法，因此这将会很方便能停止单个线程而不是停止全部线程或者一个都不停。\n\n#### 4.备用内存设备上的堆分配（JEP 316）\n\n允许HotSpot VM在备用内存设备上分配Java对象堆内存，该内存设备将由用户指定。\n\n#### 5.其他Unicode语言 - 标记扩展（JEP 314）\n\n目标是增强java.util.Locale及其相关的API，以便实现语言标记语法的其他Unicode扩展（BCP 47）。\n\n#### 6.基于Java的实验性JIT编译器（JEP 317）\n\nOracle希望将其Java JIT编译器Graal用作Linux / x64平台上的实验性JIT编译器。\n\n#### 7.根证书（JEP 319）\n\n这个的目标是在Oracle的Java SE中开源根证书。\n\n#### 8.根证书认证程序（CA）\n\n这将使OpenJDK对开发人员更具吸引力，它还旨在减少OpenJDK和Oracle JDK构建之间的差异。\n\n#### 9.将JDK生态整合到单个存储库中（JEP 296）\n\n此JEP的主要目标是执行一些内存管理，并将JDK生态的众多存储库组合到一个存储库中。\n\n#### 10.删除Native-Header生成工具（javah）（JEP 313）\n\n从JDK中移除了javah工具，这个很简单并且很重要。\n\n### 尝鲜\n\n就像所有其他JDK版本一样，Oracle已经发布了一个Java 10初始候选版本，Java开发者可以下载此版本用来测试新功能。如果你对Java 10抱有期待想提早尝试，那么现在就开始吧！\n\n> 尝鲜地址：http://openjdk.java.net/projects/jdk/10/\n\n#### 最后的感悟\n\n对于第一点新特性来说确实是一个大的跨越，其他特性或多或少都能带给开发者福音。但最终Java 10会是什么样，或许还会增加更多实用性的新功能或者优化，我们还得期待！\n\n现在要做的就是，赶紧熟悉JDK 8，现在已经是很多互联网企业标配了。如果还在使用JDK4-7，那真的是要OUT了。。\n\n在不久的将来，Java 10将彻底改变你写代码的方式！\n\n","slug":"新特性/Java10/Java 10 的 10 个新特性，将彻底改变你写代码的方式","published":1,"updated":"2025-10-15T07:20:51.431Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu07720058qkd43z0c8xvf","content":"<p><img src=\"http://img.javastack.cn/18-3-8/94675270.jpg\" alt=\"image\"></p>\n<p>Java 9才发布几个月，很多玩意都没整明白，现在Java 10又快要来了。。</p>\n<p>这时候我真尼玛想说：线上用的JDK 7 甚至JDK 6，JDK 8 还没用熟，JDK 9 才发布不久不知道啥玩意，JDK 10……</p>\n<p>刚学Java的同学是不是感觉一脸蒙逼？！！！</p>\n<p>就连我这个老司机也同样感觉如此！</p>\n<p>Java 更新越来越快，我们做技术的也要跟上步伐，不然总会慢别人一拍，这新东西从国外到国内应用一般要好几年的时间，如果我们提前了解并应用这些新技术对自己不是坏事。</p>\n<h3 id=\"Java-10的新特性\"><a href=\"#Java-10的新特性\" class=\"headerlink\" title=\"Java 10的新特性\"></a>Java 10的新特性</h3><p>说了这么多，看Java 10都会有哪些特性来改变我们写代码的方式呢？！</p>\n<h4 id=\"1-局部变量类型推断\"><a href=\"#1-局部变量类型推断\" class=\"headerlink\" title=\"1.局部变量类型推断\"></a>1.局部变量类型推断</h4><p>局部变量类型推断可以说是Java 10中最值得注意的特性，这是Java语言开发人员为了简化Java应用程序的编写而采取的又一步，如下图所示。</p>\n<p><img src=\"http://img.javastack.cn/18-3-8/56770623.jpg\" alt=\"image\"></p>\n<p>这个新功能将为Java增加一些语法糖 - 简化它并改善开发者体验。新的语法将减少与编写Java相关的冗长度，同时保持对静态类型安全性的承诺。</p>\n<p>局部变量类型推断将引入”var”关键字，也就是你可以随意定义变量而不必指定变量的类型，如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">List &lt;String&gt; list &#x3D; new ArrayList &lt;String&gt;（）; \nStream &lt;String&gt; stream &#x3D; getStream（）;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>将被下面这个新语法所取代：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var list &#x3D; new ArrayList &lt;String&gt;（）; \nvar stream &#x3D; getStream（）;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>看完是不是有点JS的即视感？？？越来越像JS了吗？！虽然类型推断在Java中不是一个新概念，但在局部变量中确是很大的一个改进。</p>\n<p>说到类型推断，从JDK 5引进泛型，到JDK 7的”&lt;&gt;”操作符允许不绑定类型而初始化List，再到JDK 8的Lambda表达式，再到现在JDK 10的局部变量类型推断，Java类型推断正大刀阔斧的向前发展。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 该运算符允许在没有绑定ArrayList &lt;&gt;的类型的情况下初始化列表\nList &lt;String&gt; list &#x3D; new LinkedList &lt;&gt;（）;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><strong>局部变量类型推荐仅限于如下使用场景：</strong></p>\n<ul>\n<li>局部变量初始化</li>\n<li>for循环内部索引变量</li>\n<li>传统的for循环声明变量</li>\n</ul>\n<p><strong>Java官方表示，它不能用于以下几个地方：</strong></p>\n<ul>\n<li>方法参数</li>\n<li>构造函数参数</li>\n<li>方法返回类型</li>\n<li>字段</li>\n<li>捕获表达式（或任何其他类型的变量声明）</li>\n</ul>\n<h4 id=\"2-GC改进和其他内务管理\"><a href=\"#2-GC改进和其他内务管理\" class=\"headerlink\" title=\"2.GC改进和其他内务管理\"></a>2.GC改进和其他内务管理</h4><p>JDK 10中有2个JEP专门用于改进当前的垃圾收集元素。</p>\n<p>第一个垃圾收集器接口是（JEP 304），它将引入一个纯净的垃圾收集器接口，以帮助改进不同垃圾收集器的源代码隔离。</p>\n<p>预定用于Java 10的第二个JEP是针对G1的并行完全GC（JEP 307），其重点在于通过完全GC并行来改善G1最坏情况的等待时间。G1是Java 9中的默认GC，并且此JEP的目标是使G1平行。</p>\n<h4 id=\"3-线程本地握手（JEP-312）\"><a href=\"#3-线程本地握手（JEP-312）\" class=\"headerlink\" title=\"3.线程本地握手（JEP 312）\"></a>3.线程本地握手（JEP 312）</h4><p>JDK 10将引入一种在线程上执行回调的新方法，因此这将会很方便能停止单个线程而不是停止全部线程或者一个都不停。</p>\n<h4 id=\"4-备用内存设备上的堆分配（JEP-316）\"><a href=\"#4-备用内存设备上的堆分配（JEP-316）\" class=\"headerlink\" title=\"4.备用内存设备上的堆分配（JEP 316）\"></a>4.备用内存设备上的堆分配（JEP 316）</h4><p>允许HotSpot VM在备用内存设备上分配Java对象堆内存，该内存设备将由用户指定。</p>\n<h4 id=\"5-其他Unicode语言-标记扩展（JEP-314）\"><a href=\"#5-其他Unicode语言-标记扩展（JEP-314）\" class=\"headerlink\" title=\"5.其他Unicode语言 - 标记扩展（JEP 314）\"></a>5.其他Unicode语言 - 标记扩展（JEP 314）</h4><p>目标是增强java.util.Locale及其相关的API，以便实现语言标记语法的其他Unicode扩展（BCP 47）。</p>\n<h4 id=\"6-基于Java的实验性JIT编译器（JEP-317）\"><a href=\"#6-基于Java的实验性JIT编译器（JEP-317）\" class=\"headerlink\" title=\"6.基于Java的实验性JIT编译器（JEP 317）\"></a>6.基于Java的实验性JIT编译器（JEP 317）</h4><p>Oracle希望将其Java JIT编译器Graal用作Linux &#x2F; x64平台上的实验性JIT编译器。</p>\n<h4 id=\"7-根证书（JEP-319）\"><a href=\"#7-根证书（JEP-319）\" class=\"headerlink\" title=\"7.根证书（JEP 319）\"></a>7.根证书（JEP 319）</h4><p>这个的目标是在Oracle的Java SE中开源根证书。</p>\n<h4 id=\"8-根证书认证程序（CA）\"><a href=\"#8-根证书认证程序（CA）\" class=\"headerlink\" title=\"8.根证书认证程序（CA）\"></a>8.根证书认证程序（CA）</h4><p>这将使OpenJDK对开发人员更具吸引力，它还旨在减少OpenJDK和Oracle JDK构建之间的差异。</p>\n<h4 id=\"9-将JDK生态整合到单个存储库中（JEP-296）\"><a href=\"#9-将JDK生态整合到单个存储库中（JEP-296）\" class=\"headerlink\" title=\"9.将JDK生态整合到单个存储库中（JEP 296）\"></a>9.将JDK生态整合到单个存储库中（JEP 296）</h4><p>此JEP的主要目标是执行一些内存管理，并将JDK生态的众多存储库组合到一个存储库中。</p>\n<h4 id=\"10-删除Native-Header生成工具（javah）（JEP-313）\"><a href=\"#10-删除Native-Header生成工具（javah）（JEP-313）\" class=\"headerlink\" title=\"10.删除Native-Header生成工具（javah）（JEP 313）\"></a>10.删除Native-Header生成工具（javah）（JEP 313）</h4><p>从JDK中移除了javah工具，这个很简单并且很重要。</p>\n<h3 id=\"尝鲜\"><a href=\"#尝鲜\" class=\"headerlink\" title=\"尝鲜\"></a>尝鲜</h3><p>就像所有其他JDK版本一样，Oracle已经发布了一个Java 10初始候选版本，Java开发者可以下载此版本用来测试新功能。如果你对Java 10抱有期待想提早尝试，那么现在就开始吧！</p>\n<blockquote>\n<p>尝鲜地址：<a href=\"http://openjdk.java.net/projects/jdk/10/\">http://openjdk.java.net/projects/jdk/10/</a></p>\n</blockquote>\n<h4 id=\"最后的感悟\"><a href=\"#最后的感悟\" class=\"headerlink\" title=\"最后的感悟\"></a>最后的感悟</h4><p>对于第一点新特性来说确实是一个大的跨越，其他特性或多或少都能带给开发者福音。但最终Java 10会是什么样，或许还会增加更多实用性的新功能或者优化，我们还得期待！</p>\n<p>现在要做的就是，赶紧熟悉JDK 8，现在已经是很多互联网企业标配了。如果还在使用JDK4-7，那真的是要OUT了。。</p>\n<p>在不久的将来，Java 10将彻底改变你写代码的方式！</p>\n","excerpt":"","more":"<p><img src=\"http://img.javastack.cn/18-3-8/94675270.jpg\" alt=\"image\"></p>\n<p>Java 9才发布几个月，很多玩意都没整明白，现在Java 10又快要来了。。</p>\n<p>这时候我真尼玛想说：线上用的JDK 7 甚至JDK 6，JDK 8 还没用熟，JDK 9 才发布不久不知道啥玩意，JDK 10……</p>\n<p>刚学Java的同学是不是感觉一脸蒙逼？！！！</p>\n<p>就连我这个老司机也同样感觉如此！</p>\n<p>Java 更新越来越快，我们做技术的也要跟上步伐，不然总会慢别人一拍，这新东西从国外到国内应用一般要好几年的时间，如果我们提前了解并应用这些新技术对自己不是坏事。</p>\n<h3 id=\"Java-10的新特性\"><a href=\"#Java-10的新特性\" class=\"headerlink\" title=\"Java 10的新特性\"></a>Java 10的新特性</h3><p>说了这么多，看Java 10都会有哪些特性来改变我们写代码的方式呢？！</p>\n<h4 id=\"1-局部变量类型推断\"><a href=\"#1-局部变量类型推断\" class=\"headerlink\" title=\"1.局部变量类型推断\"></a>1.局部变量类型推断</h4><p>局部变量类型推断可以说是Java 10中最值得注意的特性，这是Java语言开发人员为了简化Java应用程序的编写而采取的又一步，如下图所示。</p>\n<p><img src=\"http://img.javastack.cn/18-3-8/56770623.jpg\" alt=\"image\"></p>\n<p>这个新功能将为Java增加一些语法糖 - 简化它并改善开发者体验。新的语法将减少与编写Java相关的冗长度，同时保持对静态类型安全性的承诺。</p>\n<p>局部变量类型推断将引入”var”关键字，也就是你可以随意定义变量而不必指定变量的类型，如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">List &lt;String&gt; list &#x3D; new ArrayList &lt;String&gt;（）; \nStream &lt;String&gt; stream &#x3D; getStream（）;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>将被下面这个新语法所取代：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var list &#x3D; new ArrayList &lt;String&gt;（）; \nvar stream &#x3D; getStream（）;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>看完是不是有点JS的即视感？？？越来越像JS了吗？！虽然类型推断在Java中不是一个新概念，但在局部变量中确是很大的一个改进。</p>\n<p>说到类型推断，从JDK 5引进泛型，到JDK 7的”&lt;&gt;”操作符允许不绑定类型而初始化List，再到JDK 8的Lambda表达式，再到现在JDK 10的局部变量类型推断，Java类型推断正大刀阔斧的向前发展。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 该运算符允许在没有绑定ArrayList &lt;&gt;的类型的情况下初始化列表\nList &lt;String&gt; list &#x3D; new LinkedList &lt;&gt;（）;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><strong>局部变量类型推荐仅限于如下使用场景：</strong></p>\n<ul>\n<li>局部变量初始化</li>\n<li>for循环内部索引变量</li>\n<li>传统的for循环声明变量</li>\n</ul>\n<p><strong>Java官方表示，它不能用于以下几个地方：</strong></p>\n<ul>\n<li>方法参数</li>\n<li>构造函数参数</li>\n<li>方法返回类型</li>\n<li>字段</li>\n<li>捕获表达式（或任何其他类型的变量声明）</li>\n</ul>\n<h4 id=\"2-GC改进和其他内务管理\"><a href=\"#2-GC改进和其他内务管理\" class=\"headerlink\" title=\"2.GC改进和其他内务管理\"></a>2.GC改进和其他内务管理</h4><p>JDK 10中有2个JEP专门用于改进当前的垃圾收集元素。</p>\n<p>第一个垃圾收集器接口是（JEP 304），它将引入一个纯净的垃圾收集器接口，以帮助改进不同垃圾收集器的源代码隔离。</p>\n<p>预定用于Java 10的第二个JEP是针对G1的并行完全GC（JEP 307），其重点在于通过完全GC并行来改善G1最坏情况的等待时间。G1是Java 9中的默认GC，并且此JEP的目标是使G1平行。</p>\n<h4 id=\"3-线程本地握手（JEP-312）\"><a href=\"#3-线程本地握手（JEP-312）\" class=\"headerlink\" title=\"3.线程本地握手（JEP 312）\"></a>3.线程本地握手（JEP 312）</h4><p>JDK 10将引入一种在线程上执行回调的新方法，因此这将会很方便能停止单个线程而不是停止全部线程或者一个都不停。</p>\n<h4 id=\"4-备用内存设备上的堆分配（JEP-316）\"><a href=\"#4-备用内存设备上的堆分配（JEP-316）\" class=\"headerlink\" title=\"4.备用内存设备上的堆分配（JEP 316）\"></a>4.备用内存设备上的堆分配（JEP 316）</h4><p>允许HotSpot VM在备用内存设备上分配Java对象堆内存，该内存设备将由用户指定。</p>\n<h4 id=\"5-其他Unicode语言-标记扩展（JEP-314）\"><a href=\"#5-其他Unicode语言-标记扩展（JEP-314）\" class=\"headerlink\" title=\"5.其他Unicode语言 - 标记扩展（JEP 314）\"></a>5.其他Unicode语言 - 标记扩展（JEP 314）</h4><p>目标是增强java.util.Locale及其相关的API，以便实现语言标记语法的其他Unicode扩展（BCP 47）。</p>\n<h4 id=\"6-基于Java的实验性JIT编译器（JEP-317）\"><a href=\"#6-基于Java的实验性JIT编译器（JEP-317）\" class=\"headerlink\" title=\"6.基于Java的实验性JIT编译器（JEP 317）\"></a>6.基于Java的实验性JIT编译器（JEP 317）</h4><p>Oracle希望将其Java JIT编译器Graal用作Linux &#x2F; x64平台上的实验性JIT编译器。</p>\n<h4 id=\"7-根证书（JEP-319）\"><a href=\"#7-根证书（JEP-319）\" class=\"headerlink\" title=\"7.根证书（JEP 319）\"></a>7.根证书（JEP 319）</h4><p>这个的目标是在Oracle的Java SE中开源根证书。</p>\n<h4 id=\"8-根证书认证程序（CA）\"><a href=\"#8-根证书认证程序（CA）\" class=\"headerlink\" title=\"8.根证书认证程序（CA）\"></a>8.根证书认证程序（CA）</h4><p>这将使OpenJDK对开发人员更具吸引力，它还旨在减少OpenJDK和Oracle JDK构建之间的差异。</p>\n<h4 id=\"9-将JDK生态整合到单个存储库中（JEP-296）\"><a href=\"#9-将JDK生态整合到单个存储库中（JEP-296）\" class=\"headerlink\" title=\"9.将JDK生态整合到单个存储库中（JEP 296）\"></a>9.将JDK生态整合到单个存储库中（JEP 296）</h4><p>此JEP的主要目标是执行一些内存管理，并将JDK生态的众多存储库组合到一个存储库中。</p>\n<h4 id=\"10-删除Native-Header生成工具（javah）（JEP-313）\"><a href=\"#10-删除Native-Header生成工具（javah）（JEP-313）\" class=\"headerlink\" title=\"10.删除Native-Header生成工具（javah）（JEP 313）\"></a>10.删除Native-Header生成工具（javah）（JEP 313）</h4><p>从JDK中移除了javah工具，这个很简单并且很重要。</p>\n<h3 id=\"尝鲜\"><a href=\"#尝鲜\" class=\"headerlink\" title=\"尝鲜\"></a>尝鲜</h3><p>就像所有其他JDK版本一样，Oracle已经发布了一个Java 10初始候选版本，Java开发者可以下载此版本用来测试新功能。如果你对Java 10抱有期待想提早尝试，那么现在就开始吧！</p>\n<blockquote>\n<p>尝鲜地址：<a href=\"http://openjdk.java.net/projects/jdk/10/\">http://openjdk.java.net/projects/jdk/10/</a></p>\n</blockquote>\n<h4 id=\"最后的感悟\"><a href=\"#最后的感悟\" class=\"headerlink\" title=\"最后的感悟\"></a>最后的感悟</h4><p>对于第一点新特性来说确实是一个大的跨越，其他特性或多或少都能带给开发者福音。但最终Java 10会是什么样，或许还会增加更多实用性的新功能或者优化，我们还得期待！</p>\n<p>现在要做的就是，赶紧熟悉JDK 8，现在已经是很多互联网企业标配了。如果还在使用JDK4-7，那真的是要OUT了。。</p>\n<p>在不久的将来，Java 10将彻底改变你写代码的方式！</p>\n"},{"title":"Java 11 正式发布，这 8 个新特性教你写出更牛逼的代码","date":"2025-10-15T03:36:33.000Z","_content":"\n美国时间 09 月 25 日，Oralce 正式发布了 Java 11，这是据 Java 8 以后支持的首个长期版本。\n\n为什么说是长期版本，看下面的官方发布的支持路线图表。\n\n![](http://qianniu.javastack.cn/18-9-26/91229065.jpg)\n\n可以看出 Java 8 扩展支持到 2025 年，而 Java 11 扩展支持到 2026 年。\n\n现在大部分都在用 Java 8，Java 9 和 10 目前很少有人在用，至少我没有发现有公司在生产环境应用的，那就是找死。\n\n现在 Java 11 长期支持，也已经包含了 9 和 10 的全部功能，9 和 10 自然就活到头了。。\n\n那么我们来看下 从 Java 9 - 11 都有哪些重要的新特性呢？\n\n#### 1、本地变量类型推断\n\n这个博主已经写过一篇文章，详细的介绍了 Java 10 带来的这个新特性。\n\n什么是局部变量类型推断？\n\n```\nvar javastack = \"javastack\";\nSystem.out.println(javastack);\n```\n\n大家看出来了，局部变量类型推断就是左边的类型直接使用 `var` 定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型，如上面的 `String` 。\n\n```\nvar javastack = \"javastack\";\n```\n\n就等于：\n\n```\nString javastack = \"javastack\";\n```\n\n更多使用详情请参考这篇文章《[Java 10 实战第 1 篇：局部变量类型推断](https://mp.weixin.qq.com/s/4zUtQPUn5LYw43IRLm0Dwg)》，这里不再重复了。\n\n\n#### 2、字符串加强\n\nJava 11 增加了一系列的字符串处理方法，如以下所示。\n\n```\n// 判断字符串是否为空白\n\" \".isBlank();                // true\n\n// 去除首尾空格\n\" Javastack \".strip();          // \"Javastack\"\n\n// 去除尾部空格 \n\" Javastack \".stripTrailing();  // \" Javastack\"\n\n// 去除首部空格 \n\" Javastack \".stripLeading();   // \"Javastack \"\n\n// 复制字符串\n\"Java\".repeat(3);             // \"JavaJavaJava\"\n\n// 行数统计\n\"A\\nB\\nC\".lines().count();    // 3\n```\n\n#### 3、集合加强\n\n自 Java 9 开始，Jdk 里面为集合（List/ Set/ Map）都添加了 `of` 和 `copyOf` 方法，它们两个都用来创建不可变的集合，来看下它们的使用和区别。\n\n**示例1：**\n\n```\nvar list = List.of(\"Java\", \"Python\", \"C\");\nvar copy = List.copyOf(list);\nSystem.out.println(list == copy);   // true\n```\n\n**示例2：**\n\n```\nvar list = new ArrayList<String>();\nvar copy = List.copyOf(list);\nSystem.out.println(list == copy);   // false\n```\n\n示例1和2代码差不多，为什么一个为true,一个为false?\n\n来看下它们的源码：\n\n```\nstatic <E> List<E> of(E... elements) {\n    switch (elements.length) { // implicit null check of elements\n        case 0:\n            return ImmutableCollections.emptyList();\n        case 1:\n            return new ImmutableCollections.List12<>(elements[0]);\n        case 2:\n            return new ImmutableCollections.List12<>(elements[0], elements[1]);\n        default:\n            return new ImmutableCollections.ListN<>(elements);\n    }\n}\n\nstatic <E> List<E> copyOf(Collection<? extends E> coll) {\n    return ImmutableCollections.listCopy(coll);\n}\n\nstatic <E> List<E> listCopy(Collection<? extends E> coll) {\n    if (coll instanceof AbstractImmutableList && coll.getClass() != SubList.class) {\n        return (List<E>)coll;\n    } else {\n        return (List<E>)List.of(coll.toArray());\n    }\n}\n```\n\n可以看出 `copyOf` 方法会先判断来源集合是不是 `AbstractImmutableList` 类型的，如果是，就直接返回，如果不是，则调用 `of` 创建一个新的集合。\n\n示例2因为用的 new 创建的集合，不属于不可变 `AbstractImmutableList` 类的子类，所以 `copyOf` 方法又创建了一个新的实例，所以为false.\n\n> 注意：使用 of 和 copyOf 创建的集合为不可变集合，不能进行添加、删除、替换、排序等操作，不然会报 `java.lang.UnsupportedOperationException` 异常。\n\n上面演示了 List 的 of 和 copyOf 方法，Set 和 Map 接口都有。\n\n#### 4、Stream 加强\n\nStream 是 Java 8 中的新特性，Java 9 开始对 Stream 增加了以下 4 个新方法。\n\n1) 增加单个参数构造方法，可为null\n\n```\nStream.ofNullable(null).count(); // 0\n```\n\n2) 增加 takeWhile 和 dropWhile 方法\n\n```\nStream.of(1, 2, 3, 2, 1)\n    .takeWhile(n -> n < 3)\n    .collect(Collectors.toList());  // [1, 2]\n```\n\n从开始计算，当 n < 3 时就截止。\n    \n```\nStream.of(1, 2, 3, 2, 1)\n    .dropWhile(n -> n < 3)\n    .collect(Collectors.toList());  // [3, 2, 1]\n```\n\n这个和上面的相反，一旦 n < 3 不成立就开始计算。\n\n3）iterate重载\n\n这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。\n\n如果你对 JDK 8 中的 Stream 还不熟悉，可以看之前分享的这一系列教程。\n\n#### 5、Optional 加强\n\nOpthonal 也增加了几个非常酷的方法，现在可以很方便的将一个 Optional 转换成一个 Stream, 或者当一个空 Optional 时给它一个替代的。\n\n```\nOptional.of(\"javastack\").orElseThrow();     // javastack\nOptional.of(\"javastack\").stream().count();  // 1\nOptional.ofNullable(null)\n    .or(() -> Optional.of(\"javastack\"))\n    .get();   // javastack\n```\n\n#### 6、InputStream 加强\n\nInputStream 终于有了一个非常有用的方法：transferTo，可以用来将数据直接传输到 OutputStream，这是在处理原始数据流时非常常见的一种用法，如下示例。\n\n```\nvar classLoader = ClassLoader.getSystemClassLoader();\nvar inputStream = classLoader.getResourceAsStream(\"javastack.txt\");\nvar javastack = File.createTempFile(\"javastack2\", \"txt\");\ntry (var outputStream = new FileOutputStream(javastack)) {\n    inputStream.transferTo(outputStream);\n}\n```\n\n#### 7、HTTP Client API\n\n这是 Java 9 开始引入的一个处理 HTTP 请求的的孵化 HTTP Client  API，该 API 支持同步和异步，而在 Java 11 中已经为正式可用状态，你可以在 `java.net` 包中找到这个 API。\n\n来看一下 HTTP Client 的用法：\n\n```\nvar request = HttpRequest.newBuilder()\n    .uri(URI.create(\"https://javastack.cn\"))\n    .GET()\n    .build();\nvar client = HttpClient.newHttpClient();\n\n// 同步\nHttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\nSystem.out.println(response.body());\n\n// 异步\nclient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n    .thenApply(HttpResponse::body)\n    .thenAccept(System.out::println);\n```\n\n上面的 `.GET()` 可以省略，默认请求方式为 Get！\n\n更多使用示例可以看这个 API，后续有机会再做演示。\n\n现在 Java 自带了这个 HTTP Client API，我们以后还有必要用 Apache 的 HttpClient 工具包吗？\n\n#### 8、化繁为简，一个命令编译运行源代码\n\n看下面的代码。\n\n```\n// 编译\njavac Javastack.java\n\n// 运行\njava Javastack\n```\n\n在我们的认知里面，要运行一个 Java 源代码必须先编译，再运行，两步执行动作。而在未来的 Java 11 版本中，通过一个 `java` 命令就直接搞定了，如以下所示。\n\n```\njava Javastack.java\n```\n\n#### 更多新特性\n\n- Flow API for reactive programming\n- Java Module System\n- Application Class Data Sharing\n- Dynamic Class-File Constants\n- Java REPL (JShell)\n- Flight Recorder\n- Unicode 10\n- G1: Full Parallel Garbage Collector\n- ZGC: Scalable Low-Latency Garbage Collector\n- Epsilon: No-Op Garbage Collector\n- Deprecate the Nashorn JavaScript Engine\n- ...\n\n#### 历史新特性文章\n\n- Java 11 要来了，编译运行一个命令搞定\n- JDK 11 发布计划来了，已确定 3个 新特性\n- Java 10 实战第 1 篇：局部变量类型推断\n- JDK 5 ~ 10 新特性倾情整理\n- JDK 10 的 10 个新特性\n- JDK 10 最重要的 5 个新特性\n- JDK 9 的 9 个新特性\n- JDK 9 新特性实战：简化流关闭新姿势\n- JDK 8 的排序大法\n- JDK 8 新特性之 Lambda 表达式\n- JDK 8 新特性之函数式接口\n- JDK 8 新特性之方法引用\n- JDK 8 新特性之接口默认方法与静态方法\n- JDK 8 新特性之 Optional\n- JDK 8 新特性之重复注解\n- JDK 8 新特性之 Stream 流\n- JDK 8 新特性之 Stream 流（一）基础体验\n- JDK 8 新特性之 Stream 流（二）关键知识点\n- JDK 8 新特性之 Stream 流（三）缩减操作\n- JDK 8 新特性之 Stream 流（四）并行流\n- JDK 8 新特性之 Stream 流（五）映射\n- JDK 8 新特性之 Stream 流（六）收集缩\n- JDK 8 新特性之 Stream 流（七）流与迭代器\n- JDK 8 新特性之扩展篇\n\n\n#### 结束语\n\n现在许多人还在使用 Java 8 或者 7，不过 8 在 2019 年初就会结束免费更新。现在 11 是长期支持版本，正是学习和上手 11 的好时机，写这篇文章希望能对你有所启发。\n\n如果你喜欢的我的文章，对你有帮助，点赞转发支持一下吧~\n\n","source":"_posts/新特性/Java11/Java 11 正式发布，这 8 个新特性教你写出更牛逼的代码.md","raw":"---\ntitle: Java 11 正式发布，这 8 个新特性教你写出更牛逼的代码\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n\n美国时间 09 月 25 日，Oralce 正式发布了 Java 11，这是据 Java 8 以后支持的首个长期版本。\n\n为什么说是长期版本，看下面的官方发布的支持路线图表。\n\n![](http://qianniu.javastack.cn/18-9-26/91229065.jpg)\n\n可以看出 Java 8 扩展支持到 2025 年，而 Java 11 扩展支持到 2026 年。\n\n现在大部分都在用 Java 8，Java 9 和 10 目前很少有人在用，至少我没有发现有公司在生产环境应用的，那就是找死。\n\n现在 Java 11 长期支持，也已经包含了 9 和 10 的全部功能，9 和 10 自然就活到头了。。\n\n那么我们来看下 从 Java 9 - 11 都有哪些重要的新特性呢？\n\n#### 1、本地变量类型推断\n\n这个博主已经写过一篇文章，详细的介绍了 Java 10 带来的这个新特性。\n\n什么是局部变量类型推断？\n\n```\nvar javastack = \"javastack\";\nSystem.out.println(javastack);\n```\n\n大家看出来了，局部变量类型推断就是左边的类型直接使用 `var` 定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型，如上面的 `String` 。\n\n```\nvar javastack = \"javastack\";\n```\n\n就等于：\n\n```\nString javastack = \"javastack\";\n```\n\n更多使用详情请参考这篇文章《[Java 10 实战第 1 篇：局部变量类型推断](https://mp.weixin.qq.com/s/4zUtQPUn5LYw43IRLm0Dwg)》，这里不再重复了。\n\n\n#### 2、字符串加强\n\nJava 11 增加了一系列的字符串处理方法，如以下所示。\n\n```\n// 判断字符串是否为空白\n\" \".isBlank();                // true\n\n// 去除首尾空格\n\" Javastack \".strip();          // \"Javastack\"\n\n// 去除尾部空格 \n\" Javastack \".stripTrailing();  // \" Javastack\"\n\n// 去除首部空格 \n\" Javastack \".stripLeading();   // \"Javastack \"\n\n// 复制字符串\n\"Java\".repeat(3);             // \"JavaJavaJava\"\n\n// 行数统计\n\"A\\nB\\nC\".lines().count();    // 3\n```\n\n#### 3、集合加强\n\n自 Java 9 开始，Jdk 里面为集合（List/ Set/ Map）都添加了 `of` 和 `copyOf` 方法，它们两个都用来创建不可变的集合，来看下它们的使用和区别。\n\n**示例1：**\n\n```\nvar list = List.of(\"Java\", \"Python\", \"C\");\nvar copy = List.copyOf(list);\nSystem.out.println(list == copy);   // true\n```\n\n**示例2：**\n\n```\nvar list = new ArrayList<String>();\nvar copy = List.copyOf(list);\nSystem.out.println(list == copy);   // false\n```\n\n示例1和2代码差不多，为什么一个为true,一个为false?\n\n来看下它们的源码：\n\n```\nstatic <E> List<E> of(E... elements) {\n    switch (elements.length) { // implicit null check of elements\n        case 0:\n            return ImmutableCollections.emptyList();\n        case 1:\n            return new ImmutableCollections.List12<>(elements[0]);\n        case 2:\n            return new ImmutableCollections.List12<>(elements[0], elements[1]);\n        default:\n            return new ImmutableCollections.ListN<>(elements);\n    }\n}\n\nstatic <E> List<E> copyOf(Collection<? extends E> coll) {\n    return ImmutableCollections.listCopy(coll);\n}\n\nstatic <E> List<E> listCopy(Collection<? extends E> coll) {\n    if (coll instanceof AbstractImmutableList && coll.getClass() != SubList.class) {\n        return (List<E>)coll;\n    } else {\n        return (List<E>)List.of(coll.toArray());\n    }\n}\n```\n\n可以看出 `copyOf` 方法会先判断来源集合是不是 `AbstractImmutableList` 类型的，如果是，就直接返回，如果不是，则调用 `of` 创建一个新的集合。\n\n示例2因为用的 new 创建的集合，不属于不可变 `AbstractImmutableList` 类的子类，所以 `copyOf` 方法又创建了一个新的实例，所以为false.\n\n> 注意：使用 of 和 copyOf 创建的集合为不可变集合，不能进行添加、删除、替换、排序等操作，不然会报 `java.lang.UnsupportedOperationException` 异常。\n\n上面演示了 List 的 of 和 copyOf 方法，Set 和 Map 接口都有。\n\n#### 4、Stream 加强\n\nStream 是 Java 8 中的新特性，Java 9 开始对 Stream 增加了以下 4 个新方法。\n\n1) 增加单个参数构造方法，可为null\n\n```\nStream.ofNullable(null).count(); // 0\n```\n\n2) 增加 takeWhile 和 dropWhile 方法\n\n```\nStream.of(1, 2, 3, 2, 1)\n    .takeWhile(n -> n < 3)\n    .collect(Collectors.toList());  // [1, 2]\n```\n\n从开始计算，当 n < 3 时就截止。\n    \n```\nStream.of(1, 2, 3, 2, 1)\n    .dropWhile(n -> n < 3)\n    .collect(Collectors.toList());  // [3, 2, 1]\n```\n\n这个和上面的相反，一旦 n < 3 不成立就开始计算。\n\n3）iterate重载\n\n这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。\n\n如果你对 JDK 8 中的 Stream 还不熟悉，可以看之前分享的这一系列教程。\n\n#### 5、Optional 加强\n\nOpthonal 也增加了几个非常酷的方法，现在可以很方便的将一个 Optional 转换成一个 Stream, 或者当一个空 Optional 时给它一个替代的。\n\n```\nOptional.of(\"javastack\").orElseThrow();     // javastack\nOptional.of(\"javastack\").stream().count();  // 1\nOptional.ofNullable(null)\n    .or(() -> Optional.of(\"javastack\"))\n    .get();   // javastack\n```\n\n#### 6、InputStream 加强\n\nInputStream 终于有了一个非常有用的方法：transferTo，可以用来将数据直接传输到 OutputStream，这是在处理原始数据流时非常常见的一种用法，如下示例。\n\n```\nvar classLoader = ClassLoader.getSystemClassLoader();\nvar inputStream = classLoader.getResourceAsStream(\"javastack.txt\");\nvar javastack = File.createTempFile(\"javastack2\", \"txt\");\ntry (var outputStream = new FileOutputStream(javastack)) {\n    inputStream.transferTo(outputStream);\n}\n```\n\n#### 7、HTTP Client API\n\n这是 Java 9 开始引入的一个处理 HTTP 请求的的孵化 HTTP Client  API，该 API 支持同步和异步，而在 Java 11 中已经为正式可用状态，你可以在 `java.net` 包中找到这个 API。\n\n来看一下 HTTP Client 的用法：\n\n```\nvar request = HttpRequest.newBuilder()\n    .uri(URI.create(\"https://javastack.cn\"))\n    .GET()\n    .build();\nvar client = HttpClient.newHttpClient();\n\n// 同步\nHttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\nSystem.out.println(response.body());\n\n// 异步\nclient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n    .thenApply(HttpResponse::body)\n    .thenAccept(System.out::println);\n```\n\n上面的 `.GET()` 可以省略，默认请求方式为 Get！\n\n更多使用示例可以看这个 API，后续有机会再做演示。\n\n现在 Java 自带了这个 HTTP Client API，我们以后还有必要用 Apache 的 HttpClient 工具包吗？\n\n#### 8、化繁为简，一个命令编译运行源代码\n\n看下面的代码。\n\n```\n// 编译\njavac Javastack.java\n\n// 运行\njava Javastack\n```\n\n在我们的认知里面，要运行一个 Java 源代码必须先编译，再运行，两步执行动作。而在未来的 Java 11 版本中，通过一个 `java` 命令就直接搞定了，如以下所示。\n\n```\njava Javastack.java\n```\n\n#### 更多新特性\n\n- Flow API for reactive programming\n- Java Module System\n- Application Class Data Sharing\n- Dynamic Class-File Constants\n- Java REPL (JShell)\n- Flight Recorder\n- Unicode 10\n- G1: Full Parallel Garbage Collector\n- ZGC: Scalable Low-Latency Garbage Collector\n- Epsilon: No-Op Garbage Collector\n- Deprecate the Nashorn JavaScript Engine\n- ...\n\n#### 历史新特性文章\n\n- Java 11 要来了，编译运行一个命令搞定\n- JDK 11 发布计划来了，已确定 3个 新特性\n- Java 10 实战第 1 篇：局部变量类型推断\n- JDK 5 ~ 10 新特性倾情整理\n- JDK 10 的 10 个新特性\n- JDK 10 最重要的 5 个新特性\n- JDK 9 的 9 个新特性\n- JDK 9 新特性实战：简化流关闭新姿势\n- JDK 8 的排序大法\n- JDK 8 新特性之 Lambda 表达式\n- JDK 8 新特性之函数式接口\n- JDK 8 新特性之方法引用\n- JDK 8 新特性之接口默认方法与静态方法\n- JDK 8 新特性之 Optional\n- JDK 8 新特性之重复注解\n- JDK 8 新特性之 Stream 流\n- JDK 8 新特性之 Stream 流（一）基础体验\n- JDK 8 新特性之 Stream 流（二）关键知识点\n- JDK 8 新特性之 Stream 流（三）缩减操作\n- JDK 8 新特性之 Stream 流（四）并行流\n- JDK 8 新特性之 Stream 流（五）映射\n- JDK 8 新特性之 Stream 流（六）收集缩\n- JDK 8 新特性之 Stream 流（七）流与迭代器\n- JDK 8 新特性之扩展篇\n\n\n#### 结束语\n\n现在许多人还在使用 Java 8 或者 7，不过 8 在 2019 年初就会结束免费更新。现在 11 是长期支持版本，正是学习和上手 11 的好时机，写这篇文章希望能对你有所启发。\n\n如果你喜欢的我的文章，对你有帮助，点赞转发支持一下吧~\n\n","slug":"新特性/Java11/Java 11 正式发布，这 8 个新特性教你写出更牛逼的代码","published":1,"updated":"2025-10-15T07:20:51.502Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu0773005bqkd4boqfh6mo","content":"<p>美国时间 09 月 25 日，Oralce 正式发布了 Java 11，这是据 Java 8 以后支持的首个长期版本。</p>\n<p>为什么说是长期版本，看下面的官方发布的支持路线图表。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-9-26/91229065.jpg\"></p>\n<p>可以看出 Java 8 扩展支持到 2025 年，而 Java 11 扩展支持到 2026 年。</p>\n<p>现在大部分都在用 Java 8，Java 9 和 10 目前很少有人在用，至少我没有发现有公司在生产环境应用的，那就是找死。</p>\n<p>现在 Java 11 长期支持，也已经包含了 9 和 10 的全部功能，9 和 10 自然就活到头了。。</p>\n<p>那么我们来看下 从 Java 9 - 11 都有哪些重要的新特性呢？</p>\n<h4 id=\"1、本地变量类型推断\"><a href=\"#1、本地变量类型推断\" class=\"headerlink\" title=\"1、本地变量类型推断\"></a>1、本地变量类型推断</h4><p>这个博主已经写过一篇文章，详细的介绍了 Java 10 带来的这个新特性。</p>\n<p>什么是局部变量类型推断？</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var javastack &#x3D; &quot;javastack&quot;;\nSystem.out.println(javastack);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>大家看出来了，局部变量类型推断就是左边的类型直接使用 <code>var</code> 定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型，如上面的 <code>String</code> 。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var javastack &#x3D; &quot;javastack&quot;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>就等于：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">String javastack &#x3D; &quot;javastack&quot;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>更多使用详情请参考这篇文章《<a href=\"https://mp.weixin.qq.com/s/4zUtQPUn5LYw43IRLm0Dwg\">Java 10 实战第 1 篇：局部变量类型推断</a>》，这里不再重复了。</p>\n<h4 id=\"2、字符串加强\"><a href=\"#2、字符串加强\" class=\"headerlink\" title=\"2、字符串加强\"></a>2、字符串加强</h4><p>Java 11 增加了一系列的字符串处理方法，如以下所示。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 判断字符串是否为空白\n&quot; &quot;.isBlank();                &#x2F;&#x2F; true\n\n&#x2F;&#x2F; 去除首尾空格\n&quot; Javastack &quot;.strip();          &#x2F;&#x2F; &quot;Javastack&quot;\n\n&#x2F;&#x2F; 去除尾部空格 \n&quot; Javastack &quot;.stripTrailing();  &#x2F;&#x2F; &quot; Javastack&quot;\n\n&#x2F;&#x2F; 去除首部空格 \n&quot; Javastack &quot;.stripLeading();   &#x2F;&#x2F; &quot;Javastack &quot;\n\n&#x2F;&#x2F; 复制字符串\n&quot;Java&quot;.repeat(3);             &#x2F;&#x2F; &quot;JavaJavaJava&quot;\n\n&#x2F;&#x2F; 行数统计\n&quot;A\\nB\\nC&quot;.lines().count();    &#x2F;&#x2F; 3<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"3、集合加强\"><a href=\"#3、集合加强\" class=\"headerlink\" title=\"3、集合加强\"></a>3、集合加强</h4><p>自 Java 9 开始，Jdk 里面为集合（List&#x2F; Set&#x2F; Map）都添加了 <code>of</code> 和 <code>copyOf</code> 方法，它们两个都用来创建不可变的集合，来看下它们的使用和区别。</p>\n<p><strong>示例1：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var list &#x3D; List.of(&quot;Java&quot;, &quot;Python&quot;, &quot;C&quot;);\nvar copy &#x3D; List.copyOf(list);\nSystem.out.println(list &#x3D;&#x3D; copy);   &#x2F;&#x2F; true<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>示例2：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var list &#x3D; new ArrayList&lt;String&gt;();\nvar copy &#x3D; List.copyOf(list);\nSystem.out.println(list &#x3D;&#x3D; copy);   &#x2F;&#x2F; false<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>示例1和2代码差不多，为什么一个为true,一个为false?</p>\n<p>来看下它们的源码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">static &lt;E&gt; List&lt;E&gt; of(E... elements) &#123;\n    switch (elements.length) &#123; &#x2F;&#x2F; implicit null check of elements\n        case 0:\n            return ImmutableCollections.emptyList();\n        case 1:\n            return new ImmutableCollections.List12&lt;&gt;(elements[0]);\n        case 2:\n            return new ImmutableCollections.List12&lt;&gt;(elements[0], elements[1]);\n        default:\n            return new ImmutableCollections.ListN&lt;&gt;(elements);\n    &#125;\n&#125;\n\nstatic &lt;E&gt; List&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) &#123;\n    return ImmutableCollections.listCopy(coll);\n&#125;\n\nstatic &lt;E&gt; List&lt;E&gt; listCopy(Collection&lt;? extends E&gt; coll) &#123;\n    if (coll instanceof AbstractImmutableList &amp;&amp; coll.getClass() !&#x3D; SubList.class) &#123;\n        return (List&lt;E&gt;)coll;\n    &#125; else &#123;\n        return (List&lt;E&gt;)List.of(coll.toArray());\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出 <code>copyOf</code> 方法会先判断来源集合是不是 <code>AbstractImmutableList</code> 类型的，如果是，就直接返回，如果不是，则调用 <code>of</code> 创建一个新的集合。</p>\n<p>示例2因为用的 new 创建的集合，不属于不可变 <code>AbstractImmutableList</code> 类的子类，所以 <code>copyOf</code> 方法又创建了一个新的实例，所以为false.</p>\n<blockquote>\n<p>注意：使用 of 和 copyOf 创建的集合为不可变集合，不能进行添加、删除、替换、排序等操作，不然会报 <code>java.lang.UnsupportedOperationException</code> 异常。</p>\n</blockquote>\n<p>上面演示了 List 的 of 和 copyOf 方法，Set 和 Map 接口都有。</p>\n<h4 id=\"4、Stream-加强\"><a href=\"#4、Stream-加强\" class=\"headerlink\" title=\"4、Stream 加强\"></a>4、Stream 加强</h4><p>Stream 是 Java 8 中的新特性，Java 9 开始对 Stream 增加了以下 4 个新方法。</p>\n<ol>\n<li>增加单个参数构造方法，可为null</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Stream.ofNullable(null).count(); &#x2F;&#x2F; 0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ol start=\"2\">\n<li>增加 takeWhile 和 dropWhile 方法</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Stream.of(1, 2, 3, 2, 1)\n    .takeWhile(n -&gt; n &lt; 3)\n    .collect(Collectors.toList());  &#x2F;&#x2F; [1, 2]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>从开始计算，当 n &lt; 3 时就截止。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Stream.of(1, 2, 3, 2, 1)\n    .dropWhile(n -&gt; n &lt; 3)\n    .collect(Collectors.toList());  &#x2F;&#x2F; [3, 2, 1]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>这个和上面的相反，一旦 n &lt; 3 不成立就开始计算。</p>\n<p>3）iterate重载</p>\n<p>这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。</p>\n<p>如果你对 JDK 8 中的 Stream 还不熟悉，可以看之前分享的这一系列教程。</p>\n<h4 id=\"5、Optional-加强\"><a href=\"#5、Optional-加强\" class=\"headerlink\" title=\"5、Optional 加强\"></a>5、Optional 加强</h4><p>Opthonal 也增加了几个非常酷的方法，现在可以很方便的将一个 Optional 转换成一个 Stream, 或者当一个空 Optional 时给它一个替代的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Optional.of(&quot;javastack&quot;).orElseThrow();     &#x2F;&#x2F; javastack\nOptional.of(&quot;javastack&quot;).stream().count();  &#x2F;&#x2F; 1\nOptional.ofNullable(null)\n    .or(() -&gt; Optional.of(&quot;javastack&quot;))\n    .get();   &#x2F;&#x2F; javastack<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"6、InputStream-加强\"><a href=\"#6、InputStream-加强\" class=\"headerlink\" title=\"6、InputStream 加强\"></a>6、InputStream 加强</h4><p>InputStream 终于有了一个非常有用的方法：transferTo，可以用来将数据直接传输到 OutputStream，这是在处理原始数据流时非常常见的一种用法，如下示例。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var classLoader &#x3D; ClassLoader.getSystemClassLoader();\nvar inputStream &#x3D; classLoader.getResourceAsStream(&quot;javastack.txt&quot;);\nvar javastack &#x3D; File.createTempFile(&quot;javastack2&quot;, &quot;txt&quot;);\ntry (var outputStream &#x3D; new FileOutputStream(javastack)) &#123;\n    inputStream.transferTo(outputStream);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"7、HTTP-Client-API\"><a href=\"#7、HTTP-Client-API\" class=\"headerlink\" title=\"7、HTTP Client API\"></a>7、HTTP Client API</h4><p>这是 Java 9 开始引入的一个处理 HTTP 请求的的孵化 HTTP Client  API，该 API 支持同步和异步，而在 Java 11 中已经为正式可用状态，你可以在 <code>java.net</code> 包中找到这个 API。</p>\n<p>来看一下 HTTP Client 的用法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var request &#x3D; HttpRequest.newBuilder()\n    .uri(URI.create(&quot;https:&#x2F;&#x2F;javastack.cn&quot;))\n    .GET()\n    .build();\nvar client &#x3D; HttpClient.newHttpClient();\n\n&#x2F;&#x2F; 同步\nHttpResponse&lt;String&gt; response &#x3D; client.send(request, HttpResponse.BodyHandlers.ofString());\nSystem.out.println(response.body());\n\n&#x2F;&#x2F; 异步\nclient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n    .thenApply(HttpResponse::body)\n    .thenAccept(System.out::println);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>上面的 <code>.GET()</code> 可以省略，默认请求方式为 Get！</p>\n<p>更多使用示例可以看这个 API，后续有机会再做演示。</p>\n<p>现在 Java 自带了这个 HTTP Client API，我们以后还有必要用 Apache 的 HttpClient 工具包吗？</p>\n<h4 id=\"8、化繁为简，一个命令编译运行源代码\"><a href=\"#8、化繁为简，一个命令编译运行源代码\" class=\"headerlink\" title=\"8、化繁为简，一个命令编译运行源代码\"></a>8、化繁为简，一个命令编译运行源代码</h4><p>看下面的代码。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 编译\njavac Javastack.java\n\n&#x2F;&#x2F; 运行\njava Javastack<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在我们的认知里面，要运行一个 Java 源代码必须先编译，再运行，两步执行动作。而在未来的 Java 11 版本中，通过一个 <code>java</code> 命令就直接搞定了，如以下所示。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">java Javastack.java<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"更多新特性\"><a href=\"#更多新特性\" class=\"headerlink\" title=\"更多新特性\"></a>更多新特性</h4><ul>\n<li>Flow API for reactive programming</li>\n<li>Java Module System</li>\n<li>Application Class Data Sharing</li>\n<li>Dynamic Class-File Constants</li>\n<li>Java REPL (JShell)</li>\n<li>Flight Recorder</li>\n<li>Unicode 10</li>\n<li>G1: Full Parallel Garbage Collector</li>\n<li>ZGC: Scalable Low-Latency Garbage Collector</li>\n<li>Epsilon: No-Op Garbage Collector</li>\n<li>Deprecate the Nashorn JavaScript Engine</li>\n<li>…</li>\n</ul>\n<h4 id=\"历史新特性文章\"><a href=\"#历史新特性文章\" class=\"headerlink\" title=\"历史新特性文章\"></a>历史新特性文章</h4><ul>\n<li>Java 11 要来了，编译运行一个命令搞定</li>\n<li>JDK 11 发布计划来了，已确定 3个 新特性</li>\n<li>Java 10 实战第 1 篇：局部变量类型推断</li>\n<li>JDK 5 ~ 10 新特性倾情整理</li>\n<li>JDK 10 的 10 个新特性</li>\n<li>JDK 10 最重要的 5 个新特性</li>\n<li>JDK 9 的 9 个新特性</li>\n<li>JDK 9 新特性实战：简化流关闭新姿势</li>\n<li>JDK 8 的排序大法</li>\n<li>JDK 8 新特性之 Lambda 表达式</li>\n<li>JDK 8 新特性之函数式接口</li>\n<li>JDK 8 新特性之方法引用</li>\n<li>JDK 8 新特性之接口默认方法与静态方法</li>\n<li>JDK 8 新特性之 Optional</li>\n<li>JDK 8 新特性之重复注解</li>\n<li>JDK 8 新特性之 Stream 流</li>\n<li>JDK 8 新特性之 Stream 流（一）基础体验</li>\n<li>JDK 8 新特性之 Stream 流（二）关键知识点</li>\n<li>JDK 8 新特性之 Stream 流（三）缩减操作</li>\n<li>JDK 8 新特性之 Stream 流（四）并行流</li>\n<li>JDK 8 新特性之 Stream 流（五）映射</li>\n<li>JDK 8 新特性之 Stream 流（六）收集缩</li>\n<li>JDK 8 新特性之 Stream 流（七）流与迭代器</li>\n<li>JDK 8 新特性之扩展篇</li>\n</ul>\n<h4 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h4><p>现在许多人还在使用 Java 8 或者 7，不过 8 在 2019 年初就会结束免费更新。现在 11 是长期支持版本，正是学习和上手 11 的好时机，写这篇文章希望能对你有所启发。</p>\n<p>如果你喜欢的我的文章，对你有帮助，点赞转发支持一下吧~</p>\n","excerpt":"","more":"<p>美国时间 09 月 25 日，Oralce 正式发布了 Java 11，这是据 Java 8 以后支持的首个长期版本。</p>\n<p>为什么说是长期版本，看下面的官方发布的支持路线图表。</p>\n<p><img src=\"http://qianniu.javastack.cn/18-9-26/91229065.jpg\"></p>\n<p>可以看出 Java 8 扩展支持到 2025 年，而 Java 11 扩展支持到 2026 年。</p>\n<p>现在大部分都在用 Java 8，Java 9 和 10 目前很少有人在用，至少我没有发现有公司在生产环境应用的，那就是找死。</p>\n<p>现在 Java 11 长期支持，也已经包含了 9 和 10 的全部功能，9 和 10 自然就活到头了。。</p>\n<p>那么我们来看下 从 Java 9 - 11 都有哪些重要的新特性呢？</p>\n<h4 id=\"1、本地变量类型推断\"><a href=\"#1、本地变量类型推断\" class=\"headerlink\" title=\"1、本地变量类型推断\"></a>1、本地变量类型推断</h4><p>这个博主已经写过一篇文章，详细的介绍了 Java 10 带来的这个新特性。</p>\n<p>什么是局部变量类型推断？</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var javastack &#x3D; &quot;javastack&quot;;\nSystem.out.println(javastack);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>大家看出来了，局部变量类型推断就是左边的类型直接使用 <code>var</code> 定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型，如上面的 <code>String</code> 。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var javastack &#x3D; &quot;javastack&quot;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>就等于：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">String javastack &#x3D; &quot;javastack&quot;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>更多使用详情请参考这篇文章《<a href=\"https://mp.weixin.qq.com/s/4zUtQPUn5LYw43IRLm0Dwg\">Java 10 实战第 1 篇：局部变量类型推断</a>》，这里不再重复了。</p>\n<h4 id=\"2、字符串加强\"><a href=\"#2、字符串加强\" class=\"headerlink\" title=\"2、字符串加强\"></a>2、字符串加强</h4><p>Java 11 增加了一系列的字符串处理方法，如以下所示。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 判断字符串是否为空白\n&quot; &quot;.isBlank();                &#x2F;&#x2F; true\n\n&#x2F;&#x2F; 去除首尾空格\n&quot; Javastack &quot;.strip();          &#x2F;&#x2F; &quot;Javastack&quot;\n\n&#x2F;&#x2F; 去除尾部空格 \n&quot; Javastack &quot;.stripTrailing();  &#x2F;&#x2F; &quot; Javastack&quot;\n\n&#x2F;&#x2F; 去除首部空格 \n&quot; Javastack &quot;.stripLeading();   &#x2F;&#x2F; &quot;Javastack &quot;\n\n&#x2F;&#x2F; 复制字符串\n&quot;Java&quot;.repeat(3);             &#x2F;&#x2F; &quot;JavaJavaJava&quot;\n\n&#x2F;&#x2F; 行数统计\n&quot;A\\nB\\nC&quot;.lines().count();    &#x2F;&#x2F; 3<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"3、集合加强\"><a href=\"#3、集合加强\" class=\"headerlink\" title=\"3、集合加强\"></a>3、集合加强</h4><p>自 Java 9 开始，Jdk 里面为集合（List&#x2F; Set&#x2F; Map）都添加了 <code>of</code> 和 <code>copyOf</code> 方法，它们两个都用来创建不可变的集合，来看下它们的使用和区别。</p>\n<p><strong>示例1：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var list &#x3D; List.of(&quot;Java&quot;, &quot;Python&quot;, &quot;C&quot;);\nvar copy &#x3D; List.copyOf(list);\nSystem.out.println(list &#x3D;&#x3D; copy);   &#x2F;&#x2F; true<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>示例2：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var list &#x3D; new ArrayList&lt;String&gt;();\nvar copy &#x3D; List.copyOf(list);\nSystem.out.println(list &#x3D;&#x3D; copy);   &#x2F;&#x2F; false<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>示例1和2代码差不多，为什么一个为true,一个为false?</p>\n<p>来看下它们的源码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">static &lt;E&gt; List&lt;E&gt; of(E... elements) &#123;\n    switch (elements.length) &#123; &#x2F;&#x2F; implicit null check of elements\n        case 0:\n            return ImmutableCollections.emptyList();\n        case 1:\n            return new ImmutableCollections.List12&lt;&gt;(elements[0]);\n        case 2:\n            return new ImmutableCollections.List12&lt;&gt;(elements[0], elements[1]);\n        default:\n            return new ImmutableCollections.ListN&lt;&gt;(elements);\n    &#125;\n&#125;\n\nstatic &lt;E&gt; List&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) &#123;\n    return ImmutableCollections.listCopy(coll);\n&#125;\n\nstatic &lt;E&gt; List&lt;E&gt; listCopy(Collection&lt;? extends E&gt; coll) &#123;\n    if (coll instanceof AbstractImmutableList &amp;&amp; coll.getClass() !&#x3D; SubList.class) &#123;\n        return (List&lt;E&gt;)coll;\n    &#125; else &#123;\n        return (List&lt;E&gt;)List.of(coll.toArray());\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出 <code>copyOf</code> 方法会先判断来源集合是不是 <code>AbstractImmutableList</code> 类型的，如果是，就直接返回，如果不是，则调用 <code>of</code> 创建一个新的集合。</p>\n<p>示例2因为用的 new 创建的集合，不属于不可变 <code>AbstractImmutableList</code> 类的子类，所以 <code>copyOf</code> 方法又创建了一个新的实例，所以为false.</p>\n<blockquote>\n<p>注意：使用 of 和 copyOf 创建的集合为不可变集合，不能进行添加、删除、替换、排序等操作，不然会报 <code>java.lang.UnsupportedOperationException</code> 异常。</p>\n</blockquote>\n<p>上面演示了 List 的 of 和 copyOf 方法，Set 和 Map 接口都有。</p>\n<h4 id=\"4、Stream-加强\"><a href=\"#4、Stream-加强\" class=\"headerlink\" title=\"4、Stream 加强\"></a>4、Stream 加强</h4><p>Stream 是 Java 8 中的新特性，Java 9 开始对 Stream 增加了以下 4 个新方法。</p>\n<ol>\n<li>增加单个参数构造方法，可为null</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Stream.ofNullable(null).count(); &#x2F;&#x2F; 0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ol start=\"2\">\n<li>增加 takeWhile 和 dropWhile 方法</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Stream.of(1, 2, 3, 2, 1)\n    .takeWhile(n -&gt; n &lt; 3)\n    .collect(Collectors.toList());  &#x2F;&#x2F; [1, 2]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>从开始计算，当 n &lt; 3 时就截止。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Stream.of(1, 2, 3, 2, 1)\n    .dropWhile(n -&gt; n &lt; 3)\n    .collect(Collectors.toList());  &#x2F;&#x2F; [3, 2, 1]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>这个和上面的相反，一旦 n &lt; 3 不成立就开始计算。</p>\n<p>3）iterate重载</p>\n<p>这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。</p>\n<p>如果你对 JDK 8 中的 Stream 还不熟悉，可以看之前分享的这一系列教程。</p>\n<h4 id=\"5、Optional-加强\"><a href=\"#5、Optional-加强\" class=\"headerlink\" title=\"5、Optional 加强\"></a>5、Optional 加强</h4><p>Opthonal 也增加了几个非常酷的方法，现在可以很方便的将一个 Optional 转换成一个 Stream, 或者当一个空 Optional 时给它一个替代的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Optional.of(&quot;javastack&quot;).orElseThrow();     &#x2F;&#x2F; javastack\nOptional.of(&quot;javastack&quot;).stream().count();  &#x2F;&#x2F; 1\nOptional.ofNullable(null)\n    .or(() -&gt; Optional.of(&quot;javastack&quot;))\n    .get();   &#x2F;&#x2F; javastack<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"6、InputStream-加强\"><a href=\"#6、InputStream-加强\" class=\"headerlink\" title=\"6、InputStream 加强\"></a>6、InputStream 加强</h4><p>InputStream 终于有了一个非常有用的方法：transferTo，可以用来将数据直接传输到 OutputStream，这是在处理原始数据流时非常常见的一种用法，如下示例。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var classLoader &#x3D; ClassLoader.getSystemClassLoader();\nvar inputStream &#x3D; classLoader.getResourceAsStream(&quot;javastack.txt&quot;);\nvar javastack &#x3D; File.createTempFile(&quot;javastack2&quot;, &quot;txt&quot;);\ntry (var outputStream &#x3D; new FileOutputStream(javastack)) &#123;\n    inputStream.transferTo(outputStream);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"7、HTTP-Client-API\"><a href=\"#7、HTTP-Client-API\" class=\"headerlink\" title=\"7、HTTP Client API\"></a>7、HTTP Client API</h4><p>这是 Java 9 开始引入的一个处理 HTTP 请求的的孵化 HTTP Client  API，该 API 支持同步和异步，而在 Java 11 中已经为正式可用状态，你可以在 <code>java.net</code> 包中找到这个 API。</p>\n<p>来看一下 HTTP Client 的用法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var request &#x3D; HttpRequest.newBuilder()\n    .uri(URI.create(&quot;https:&#x2F;&#x2F;javastack.cn&quot;))\n    .GET()\n    .build();\nvar client &#x3D; HttpClient.newHttpClient();\n\n&#x2F;&#x2F; 同步\nHttpResponse&lt;String&gt; response &#x3D; client.send(request, HttpResponse.BodyHandlers.ofString());\nSystem.out.println(response.body());\n\n&#x2F;&#x2F; 异步\nclient.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n    .thenApply(HttpResponse::body)\n    .thenAccept(System.out::println);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>上面的 <code>.GET()</code> 可以省略，默认请求方式为 Get！</p>\n<p>更多使用示例可以看这个 API，后续有机会再做演示。</p>\n<p>现在 Java 自带了这个 HTTP Client API，我们以后还有必要用 Apache 的 HttpClient 工具包吗？</p>\n<h4 id=\"8、化繁为简，一个命令编译运行源代码\"><a href=\"#8、化繁为简，一个命令编译运行源代码\" class=\"headerlink\" title=\"8、化繁为简，一个命令编译运行源代码\"></a>8、化繁为简，一个命令编译运行源代码</h4><p>看下面的代码。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 编译\njavac Javastack.java\n\n&#x2F;&#x2F; 运行\njava Javastack<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在我们的认知里面，要运行一个 Java 源代码必须先编译，再运行，两步执行动作。而在未来的 Java 11 版本中，通过一个 <code>java</code> 命令就直接搞定了，如以下所示。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">java Javastack.java<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"更多新特性\"><a href=\"#更多新特性\" class=\"headerlink\" title=\"更多新特性\"></a>更多新特性</h4><ul>\n<li>Flow API for reactive programming</li>\n<li>Java Module System</li>\n<li>Application Class Data Sharing</li>\n<li>Dynamic Class-File Constants</li>\n<li>Java REPL (JShell)</li>\n<li>Flight Recorder</li>\n<li>Unicode 10</li>\n<li>G1: Full Parallel Garbage Collector</li>\n<li>ZGC: Scalable Low-Latency Garbage Collector</li>\n<li>Epsilon: No-Op Garbage Collector</li>\n<li>Deprecate the Nashorn JavaScript Engine</li>\n<li>…</li>\n</ul>\n<h4 id=\"历史新特性文章\"><a href=\"#历史新特性文章\" class=\"headerlink\" title=\"历史新特性文章\"></a>历史新特性文章</h4><ul>\n<li>Java 11 要来了，编译运行一个命令搞定</li>\n<li>JDK 11 发布计划来了，已确定 3个 新特性</li>\n<li>Java 10 实战第 1 篇：局部变量类型推断</li>\n<li>JDK 5 ~ 10 新特性倾情整理</li>\n<li>JDK 10 的 10 个新特性</li>\n<li>JDK 10 最重要的 5 个新特性</li>\n<li>JDK 9 的 9 个新特性</li>\n<li>JDK 9 新特性实战：简化流关闭新姿势</li>\n<li>JDK 8 的排序大法</li>\n<li>JDK 8 新特性之 Lambda 表达式</li>\n<li>JDK 8 新特性之函数式接口</li>\n<li>JDK 8 新特性之方法引用</li>\n<li>JDK 8 新特性之接口默认方法与静态方法</li>\n<li>JDK 8 新特性之 Optional</li>\n<li>JDK 8 新特性之重复注解</li>\n<li>JDK 8 新特性之 Stream 流</li>\n<li>JDK 8 新特性之 Stream 流（一）基础体验</li>\n<li>JDK 8 新特性之 Stream 流（二）关键知识点</li>\n<li>JDK 8 新特性之 Stream 流（三）缩减操作</li>\n<li>JDK 8 新特性之 Stream 流（四）并行流</li>\n<li>JDK 8 新特性之 Stream 流（五）映射</li>\n<li>JDK 8 新特性之 Stream 流（六）收集缩</li>\n<li>JDK 8 新特性之 Stream 流（七）流与迭代器</li>\n<li>JDK 8 新特性之扩展篇</li>\n</ul>\n<h4 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h4><p>现在许多人还在使用 Java 8 或者 7，不过 8 在 2019 年初就会结束免费更新。现在 11 是长期支持版本，正是学习和上手 11 的好时机，写这篇文章希望能对你有所启发。</p>\n<p>如果你喜欢的我的文章，对你有帮助，点赞转发支持一下吧~</p>\n"},{"title":"Java8 之新特性扩展篇","date":"2025-10-15T03:36:33.000Z","_content":"\n之前分篇章讲了一些JKD8中添加的新特性，还有一些新特性这里也一并讲下。\n\n## BASE64\n\nbase64编码解码已经被加入到了jdk8中了。\n\n```\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\n\npublic class Base64Test {\n\tpublic static void main(String[] args) {\n\t\tString text = \"hello javastack\";\n\n\t\tString encoded = Base64.getEncoder().encodeToString(text.getBytes(StandardCharsets.UTF_8));\n\t\tSystem.out.println(encoded);\n\n\t\tString decoded = new String(Base64.getDecoder().decode(encoded), StandardCharsets.UTF_8);\n\t\tSystem.out.println(decoded);\n\t}\n}\n```\n\n## Date/Time API(JSR 310)\n\n新的时间、日期。\n\n\n```\nClock clock = Clock.systemUTC();\nSystem.out.println(clock.instant());\nSystem.out.println(clock.millis());\n```\n\n\n输出：\n\n```\n2017-09-06T07:26:18.541Z\n1504682778593\n```\n\n可以代替`System.currentTimeMillis()`方法。\n\n另外，可以看下LocalDate、LocalTime、LocalDateTime、Duration的用法。\n\n## Nashorn JavaScript引擎\n\n可以运行js代码的引擎。\n\n\n```\nScriptEngineManager manager = new ScriptEngineManager();\nScriptEngine engine = manager.getEngineByName(\"JavaScript\");\n\nSystem.out.println(engine.getClass().getName());\nSystem.out.println(\"Result:\" + engine.eval(\"function f() { return 10; }; f() * 24;\"));\n```\n输出：\n\n```\njdk.nashorn.api.scripting.NashornScriptEngine\nResult:240.0\n```\n\n## JVM内存取消永久代\n\nJDK8使用了Metaspace（JEP 122）替换永久代（PermGen space）。参数使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize。\n\n还有一些别的新特性，个人觉得某些新特性用处不是很大。\n","source":"_posts/新特性/Java8/Java8 之新特性扩展篇.md","raw":"---\ntitle: Java8 之新特性扩展篇\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n\n之前分篇章讲了一些JKD8中添加的新特性，还有一些新特性这里也一并讲下。\n\n## BASE64\n\nbase64编码解码已经被加入到了jdk8中了。\n\n```\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\n\npublic class Base64Test {\n\tpublic static void main(String[] args) {\n\t\tString text = \"hello javastack\";\n\n\t\tString encoded = Base64.getEncoder().encodeToString(text.getBytes(StandardCharsets.UTF_8));\n\t\tSystem.out.println(encoded);\n\n\t\tString decoded = new String(Base64.getDecoder().decode(encoded), StandardCharsets.UTF_8);\n\t\tSystem.out.println(decoded);\n\t}\n}\n```\n\n## Date/Time API(JSR 310)\n\n新的时间、日期。\n\n\n```\nClock clock = Clock.systemUTC();\nSystem.out.println(clock.instant());\nSystem.out.println(clock.millis());\n```\n\n\n输出：\n\n```\n2017-09-06T07:26:18.541Z\n1504682778593\n```\n\n可以代替`System.currentTimeMillis()`方法。\n\n另外，可以看下LocalDate、LocalTime、LocalDateTime、Duration的用法。\n\n## Nashorn JavaScript引擎\n\n可以运行js代码的引擎。\n\n\n```\nScriptEngineManager manager = new ScriptEngineManager();\nScriptEngine engine = manager.getEngineByName(\"JavaScript\");\n\nSystem.out.println(engine.getClass().getName());\nSystem.out.println(\"Result:\" + engine.eval(\"function f() { return 10; }; f() * 24;\"));\n```\n输出：\n\n```\njdk.nashorn.api.scripting.NashornScriptEngine\nResult:240.0\n```\n\n## JVM内存取消永久代\n\nJDK8使用了Metaspace（JEP 122）替换永久代（PermGen space）。参数使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize。\n\n还有一些别的新特性，个人觉得某些新特性用处不是很大。\n","slug":"新特性/Java8/Java8 之新特性扩展篇","published":1,"updated":"2025-10-15T07:20:51.461Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu0774005fqkd4eze9657b","content":"<p>之前分篇章讲了一些JKD8中添加的新特性，还有一些新特性这里也一并讲下。</p>\n<h2 id=\"BASE64\"><a href=\"#BASE64\" class=\"headerlink\" title=\"BASE64\"></a>BASE64</h2><p>base64编码解码已经被加入到了jdk8中了。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.nio.charset.StandardCharsets;\nimport java.util.Base64;\n\npublic class Base64Test &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tString text &#x3D; &quot;hello javastack&quot;;\n\n\t\tString encoded &#x3D; Base64.getEncoder().encodeToString(text.getBytes(StandardCharsets.UTF_8));\n\t\tSystem.out.println(encoded);\n\n\t\tString decoded &#x3D; new String(Base64.getDecoder().decode(encoded), StandardCharsets.UTF_8);\n\t\tSystem.out.println(decoded);\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"Date-Time-API-JSR-310\"><a href=\"#Date-Time-API-JSR-310\" class=\"headerlink\" title=\"Date&#x2F;Time API(JSR 310)\"></a>Date&#x2F;Time API(JSR 310)</h2><p>新的时间、日期。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Clock clock &#x3D; Clock.systemUTC();\nSystem.out.println(clock.instant());\nSystem.out.println(clock.millis());<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">2017-09-06T07:26:18.541Z\n1504682778593<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>可以代替<code>System.currentTimeMillis()</code>方法。</p>\n<p>另外，可以看下LocalDate、LocalTime、LocalDateTime、Duration的用法。</p>\n<h2 id=\"Nashorn-JavaScript引擎\"><a href=\"#Nashorn-JavaScript引擎\" class=\"headerlink\" title=\"Nashorn JavaScript引擎\"></a>Nashorn JavaScript引擎</h2><p>可以运行js代码的引擎。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ScriptEngineManager manager &#x3D; new ScriptEngineManager();\nScriptEngine engine &#x3D; manager.getEngineByName(&quot;JavaScript&quot;);\n\nSystem.out.println(engine.getClass().getName());\nSystem.out.println(&quot;Result:&quot; + engine.eval(&quot;function f() &#123; return 10; &#125;; f() * 24;&quot;));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">jdk.nashorn.api.scripting.NashornScriptEngine\nResult:240.0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"JVM内存取消永久代\"><a href=\"#JVM内存取消永久代\" class=\"headerlink\" title=\"JVM内存取消永久代\"></a>JVM内存取消永久代</h2><p>JDK8使用了Metaspace（JEP 122）替换永久代（PermGen space）。参数使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize。</p>\n<p>还有一些别的新特性，个人觉得某些新特性用处不是很大。</p>\n","excerpt":"","more":"<p>之前分篇章讲了一些JKD8中添加的新特性，还有一些新特性这里也一并讲下。</p>\n<h2 id=\"BASE64\"><a href=\"#BASE64\" class=\"headerlink\" title=\"BASE64\"></a>BASE64</h2><p>base64编码解码已经被加入到了jdk8中了。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.nio.charset.StandardCharsets;\nimport java.util.Base64;\n\npublic class Base64Test &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tString text &#x3D; &quot;hello javastack&quot;;\n\n\t\tString encoded &#x3D; Base64.getEncoder().encodeToString(text.getBytes(StandardCharsets.UTF_8));\n\t\tSystem.out.println(encoded);\n\n\t\tString decoded &#x3D; new String(Base64.getDecoder().decode(encoded), StandardCharsets.UTF_8);\n\t\tSystem.out.println(decoded);\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"Date-Time-API-JSR-310\"><a href=\"#Date-Time-API-JSR-310\" class=\"headerlink\" title=\"Date&#x2F;Time API(JSR 310)\"></a>Date&#x2F;Time API(JSR 310)</h2><p>新的时间、日期。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Clock clock &#x3D; Clock.systemUTC();\nSystem.out.println(clock.instant());\nSystem.out.println(clock.millis());<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">2017-09-06T07:26:18.541Z\n1504682778593<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>可以代替<code>System.currentTimeMillis()</code>方法。</p>\n<p>另外，可以看下LocalDate、LocalTime、LocalDateTime、Duration的用法。</p>\n<h2 id=\"Nashorn-JavaScript引擎\"><a href=\"#Nashorn-JavaScript引擎\" class=\"headerlink\" title=\"Nashorn JavaScript引擎\"></a>Nashorn JavaScript引擎</h2><p>可以运行js代码的引擎。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ScriptEngineManager manager &#x3D; new ScriptEngineManager();\nScriptEngine engine &#x3D; manager.getEngineByName(&quot;JavaScript&quot;);\n\nSystem.out.println(engine.getClass().getName());\nSystem.out.println(&quot;Result:&quot; + engine.eval(&quot;function f() &#123; return 10; &#125;; f() * 24;&quot;));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">jdk.nashorn.api.scripting.NashornScriptEngine\nResult:240.0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"JVM内存取消永久代\"><a href=\"#JVM内存取消永久代\" class=\"headerlink\" title=\"JVM内存取消永久代\"></a>JVM内存取消永久代</h2><p>JDK8使用了Metaspace（JEP 122）替换永久代（PermGen space）。参数使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize。</p>\n<p>还有一些别的新特性，个人觉得某些新特性用处不是很大。</p>\n"},{"title":"Java 11 已发布，String 还能这样玩","date":"2025-10-15T03:36:33.000Z","_content":"\n在文章《[Java 11 正式发布，这 8 个逆天新特性教你写出更牛逼的代码](https://mp.weixin.qq.com/s/SXEqAmfbmK4NklihukbE-Q)》中，我有介绍到 Java 11 的八个新特性，其中关于 String 加强部分，我觉得有点意思，这里单独再拉出来讲。\n\n**Java 11 增加了一系列的字符串处理方法，如以下所示。**\n\n```\n// 判断字符串是否为空白\n\" \".isBlank();                // true\n\n// 去除首尾空格\n\" Javastack \".strip();          // \"Javastack\"\n\n// 去除尾部空格 \n\" Javastack \".stripTrailing();  // \" Javastack\"\n\n// 去除首部空格 \n\" Javastack \".stripLeading();   // \"Javastack \"\n\n// 复制字符串\n\"Java\".repeat(3);             // \"JavaJavaJava\"\n\n// 行数统计\n\"A\\nB\\nC\".lines().count();    // 3\n```\n\n最有意思的是 `repeat` 和 `lines` 方法了，来看下还能怎么玩！\n\n#### repeat\n\nrepeat 方法的作用就是重复一个字符串 N 遍，可以用来代替工具类：`org.apache.commons.lang3.StringUtils#repeat(java.lang.String, int)`，来看下 `repeat` 的源码。\n\n```\npublic String repeat(int count) {\n    if (count < 0) {\n        throw new IllegalArgumentException(\"count is negative: \" + count);\n    }\n    if (count == 1) {\n        return this;\n    }\n    final int len = value.length;\n    if (len == 0 || count == 0) {\n        return \"\";\n    }\n    if (len == 1) {\n        final byte[] single = new byte[count];\n        Arrays.fill(single, value[0]);\n        return new String(single, coder);\n    }\n    if (Integer.MAX_VALUE / count < len) {\n        throw new OutOfMemoryError(\"Repeating \" + len + \" bytes String \" + count +\n                \" times will produce a String exceeding maximum size.\");\n    }\n    final int limit = len * count;\n    final byte[] multiple = new byte[limit];\n    System.arraycopy(value, 0, multiple, 0, len);\n    int copied = len;\n    for (; copied < limit - copied; copied <<= 1) {\n        System.arraycopy(multiple, 0, multiple, copied, copied);\n    }\n    System.arraycopy(multiple, 0, multiple, copied, limit - copied);\n    return new String(multiple, coder);\n}\n```\n\n来看下更多的用法。\n\n```\nString str = \"Java\";\n\n// 小于0：java.lang.IllegalArgumentException\nSystem.out.println(str.repeat(-2));\n\n// 等于0：空白串（\"\"）\nSystem.out.println(str.repeat(0));\n\n// JavaJavaJava\nSystem.out.println(str.repeat(3));\n\n// java.lang.OutOfMemoryError\nSystem.out.println(str.repeat(Integer.MAX_VALUE));\n```\n\n所以说 repeat 并不是可以无限增长的，有使用限制的，达到一定量就会报内存溢出异常。\n\n#### lines\n\n```\npublic Stream<String> lines() {\n    return isLatin1() ? StringLatin1.lines(value)\n                      : StringUTF16.lines(value);\n}\n```\nlines 方法返回一个字符串 Stream, 可以识别 `\\n` 和 `\\r` 换行符换行。\n\n```\n// 4\nSystem.out.println(\"A\\nB\\nC\\rD\".lines().count());\n```\n\n是不是很好？在将来肯定有武之地！如批量读取文件内容到一个 Stream 中，就能很好的识别行结束符了。\n\n\n\n","source":"_posts/新特性/Java11/Java 11 已发布，String 还能这样玩.md","raw":"---\ntitle: Java 11 已发布，String 还能这样玩\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n\n在文章《[Java 11 正式发布，这 8 个逆天新特性教你写出更牛逼的代码](https://mp.weixin.qq.com/s/SXEqAmfbmK4NklihukbE-Q)》中，我有介绍到 Java 11 的八个新特性，其中关于 String 加强部分，我觉得有点意思，这里单独再拉出来讲。\n\n**Java 11 增加了一系列的字符串处理方法，如以下所示。**\n\n```\n// 判断字符串是否为空白\n\" \".isBlank();                // true\n\n// 去除首尾空格\n\" Javastack \".strip();          // \"Javastack\"\n\n// 去除尾部空格 \n\" Javastack \".stripTrailing();  // \" Javastack\"\n\n// 去除首部空格 \n\" Javastack \".stripLeading();   // \"Javastack \"\n\n// 复制字符串\n\"Java\".repeat(3);             // \"JavaJavaJava\"\n\n// 行数统计\n\"A\\nB\\nC\".lines().count();    // 3\n```\n\n最有意思的是 `repeat` 和 `lines` 方法了，来看下还能怎么玩！\n\n#### repeat\n\nrepeat 方法的作用就是重复一个字符串 N 遍，可以用来代替工具类：`org.apache.commons.lang3.StringUtils#repeat(java.lang.String, int)`，来看下 `repeat` 的源码。\n\n```\npublic String repeat(int count) {\n    if (count < 0) {\n        throw new IllegalArgumentException(\"count is negative: \" + count);\n    }\n    if (count == 1) {\n        return this;\n    }\n    final int len = value.length;\n    if (len == 0 || count == 0) {\n        return \"\";\n    }\n    if (len == 1) {\n        final byte[] single = new byte[count];\n        Arrays.fill(single, value[0]);\n        return new String(single, coder);\n    }\n    if (Integer.MAX_VALUE / count < len) {\n        throw new OutOfMemoryError(\"Repeating \" + len + \" bytes String \" + count +\n                \" times will produce a String exceeding maximum size.\");\n    }\n    final int limit = len * count;\n    final byte[] multiple = new byte[limit];\n    System.arraycopy(value, 0, multiple, 0, len);\n    int copied = len;\n    for (; copied < limit - copied; copied <<= 1) {\n        System.arraycopy(multiple, 0, multiple, copied, copied);\n    }\n    System.arraycopy(multiple, 0, multiple, copied, limit - copied);\n    return new String(multiple, coder);\n}\n```\n\n来看下更多的用法。\n\n```\nString str = \"Java\";\n\n// 小于0：java.lang.IllegalArgumentException\nSystem.out.println(str.repeat(-2));\n\n// 等于0：空白串（\"\"）\nSystem.out.println(str.repeat(0));\n\n// JavaJavaJava\nSystem.out.println(str.repeat(3));\n\n// java.lang.OutOfMemoryError\nSystem.out.println(str.repeat(Integer.MAX_VALUE));\n```\n\n所以说 repeat 并不是可以无限增长的，有使用限制的，达到一定量就会报内存溢出异常。\n\n#### lines\n\n```\npublic Stream<String> lines() {\n    return isLatin1() ? StringLatin1.lines(value)\n                      : StringUTF16.lines(value);\n}\n```\nlines 方法返回一个字符串 Stream, 可以识别 `\\n` 和 `\\r` 换行符换行。\n\n```\n// 4\nSystem.out.println(\"A\\nB\\nC\\rD\".lines().count());\n```\n\n是不是很好？在将来肯定有武之地！如批量读取文件内容到一个 Stream 中，就能很好的识别行结束符了。\n\n\n\n","slug":"新特性/Java11/Java 11 已发布，String 还能这样玩","published":1,"updated":"2025-10-15T07:20:51.427Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu0775005iqkd44ykeei73","content":"<p>在文章《<a href=\"https://mp.weixin.qq.com/s/SXEqAmfbmK4NklihukbE-Q\">Java 11 正式发布，这 8 个逆天新特性教你写出更牛逼的代码</a>》中，我有介绍到 Java 11 的八个新特性，其中关于 String 加强部分，我觉得有点意思，这里单独再拉出来讲。</p>\n<p><strong>Java 11 增加了一系列的字符串处理方法，如以下所示。</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 判断字符串是否为空白\n&quot; &quot;.isBlank();                &#x2F;&#x2F; true\n\n&#x2F;&#x2F; 去除首尾空格\n&quot; Javastack &quot;.strip();          &#x2F;&#x2F; &quot;Javastack&quot;\n\n&#x2F;&#x2F; 去除尾部空格 \n&quot; Javastack &quot;.stripTrailing();  &#x2F;&#x2F; &quot; Javastack&quot;\n\n&#x2F;&#x2F; 去除首部空格 \n&quot; Javastack &quot;.stripLeading();   &#x2F;&#x2F; &quot;Javastack &quot;\n\n&#x2F;&#x2F; 复制字符串\n&quot;Java&quot;.repeat(3);             &#x2F;&#x2F; &quot;JavaJavaJava&quot;\n\n&#x2F;&#x2F; 行数统计\n&quot;A\\nB\\nC&quot;.lines().count();    &#x2F;&#x2F; 3<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>最有意思的是 <code>repeat</code> 和 <code>lines</code> 方法了，来看下还能怎么玩！</p>\n<h4 id=\"repeat\"><a href=\"#repeat\" class=\"headerlink\" title=\"repeat\"></a>repeat</h4><p>repeat 方法的作用就是重复一个字符串 N 遍，可以用来代替工具类：<code>org.apache.commons.lang3.StringUtils#repeat(java.lang.String, int)</code>，来看下 <code>repeat</code> 的源码。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public String repeat(int count) &#123;\n    if (count &lt; 0) &#123;\n        throw new IllegalArgumentException(&quot;count is negative: &quot; + count);\n    &#125;\n    if (count &#x3D;&#x3D; 1) &#123;\n        return this;\n    &#125;\n    final int len &#x3D; value.length;\n    if (len &#x3D;&#x3D; 0 || count &#x3D;&#x3D; 0) &#123;\n        return &quot;&quot;;\n    &#125;\n    if (len &#x3D;&#x3D; 1) &#123;\n        final byte[] single &#x3D; new byte[count];\n        Arrays.fill(single, value[0]);\n        return new String(single, coder);\n    &#125;\n    if (Integer.MAX_VALUE &#x2F; count &lt; len) &#123;\n        throw new OutOfMemoryError(&quot;Repeating &quot; + len + &quot; bytes String &quot; + count +\n                &quot; times will produce a String exceeding maximum size.&quot;);\n    &#125;\n    final int limit &#x3D; len * count;\n    final byte[] multiple &#x3D; new byte[limit];\n    System.arraycopy(value, 0, multiple, 0, len);\n    int copied &#x3D; len;\n    for (; copied &lt; limit - copied; copied &lt;&lt;&#x3D; 1) &#123;\n        System.arraycopy(multiple, 0, multiple, copied, copied);\n    &#125;\n    System.arraycopy(multiple, 0, multiple, copied, limit - copied);\n    return new String(multiple, coder);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>来看下更多的用法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">String str &#x3D; &quot;Java&quot;;\n\n&#x2F;&#x2F; 小于0：java.lang.IllegalArgumentException\nSystem.out.println(str.repeat(-2));\n\n&#x2F;&#x2F; 等于0：空白串（&quot;&quot;）\nSystem.out.println(str.repeat(0));\n\n&#x2F;&#x2F; JavaJavaJava\nSystem.out.println(str.repeat(3));\n\n&#x2F;&#x2F; java.lang.OutOfMemoryError\nSystem.out.println(str.repeat(Integer.MAX_VALUE));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>所以说 repeat 并不是可以无限增长的，有使用限制的，达到一定量就会报内存溢出异常。</p>\n<h4 id=\"lines\"><a href=\"#lines\" class=\"headerlink\" title=\"lines\"></a>lines</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">public Stream&lt;String&gt; lines() &#123;\n    return isLatin1() ? StringLatin1.lines(value)\n                      : StringUTF16.lines(value);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>lines 方法返回一个字符串 Stream, 可以识别 <code>\\n</code> 和 <code>\\r</code> 换行符换行。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 4\nSystem.out.println(&quot;A\\nB\\nC\\rD&quot;.lines().count());<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>是不是很好？在将来肯定有武之地！如批量读取文件内容到一个 Stream 中，就能很好的识别行结束符了。</p>\n","excerpt":"","more":"<p>在文章《<a href=\"https://mp.weixin.qq.com/s/SXEqAmfbmK4NklihukbE-Q\">Java 11 正式发布，这 8 个逆天新特性教你写出更牛逼的代码</a>》中，我有介绍到 Java 11 的八个新特性，其中关于 String 加强部分，我觉得有点意思，这里单独再拉出来讲。</p>\n<p><strong>Java 11 增加了一系列的字符串处理方法，如以下所示。</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 判断字符串是否为空白\n&quot; &quot;.isBlank();                &#x2F;&#x2F; true\n\n&#x2F;&#x2F; 去除首尾空格\n&quot; Javastack &quot;.strip();          &#x2F;&#x2F; &quot;Javastack&quot;\n\n&#x2F;&#x2F; 去除尾部空格 \n&quot; Javastack &quot;.stripTrailing();  &#x2F;&#x2F; &quot; Javastack&quot;\n\n&#x2F;&#x2F; 去除首部空格 \n&quot; Javastack &quot;.stripLeading();   &#x2F;&#x2F; &quot;Javastack &quot;\n\n&#x2F;&#x2F; 复制字符串\n&quot;Java&quot;.repeat(3);             &#x2F;&#x2F; &quot;JavaJavaJava&quot;\n\n&#x2F;&#x2F; 行数统计\n&quot;A\\nB\\nC&quot;.lines().count();    &#x2F;&#x2F; 3<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>最有意思的是 <code>repeat</code> 和 <code>lines</code> 方法了，来看下还能怎么玩！</p>\n<h4 id=\"repeat\"><a href=\"#repeat\" class=\"headerlink\" title=\"repeat\"></a>repeat</h4><p>repeat 方法的作用就是重复一个字符串 N 遍，可以用来代替工具类：<code>org.apache.commons.lang3.StringUtils#repeat(java.lang.String, int)</code>，来看下 <code>repeat</code> 的源码。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public String repeat(int count) &#123;\n    if (count &lt; 0) &#123;\n        throw new IllegalArgumentException(&quot;count is negative: &quot; + count);\n    &#125;\n    if (count &#x3D;&#x3D; 1) &#123;\n        return this;\n    &#125;\n    final int len &#x3D; value.length;\n    if (len &#x3D;&#x3D; 0 || count &#x3D;&#x3D; 0) &#123;\n        return &quot;&quot;;\n    &#125;\n    if (len &#x3D;&#x3D; 1) &#123;\n        final byte[] single &#x3D; new byte[count];\n        Arrays.fill(single, value[0]);\n        return new String(single, coder);\n    &#125;\n    if (Integer.MAX_VALUE &#x2F; count &lt; len) &#123;\n        throw new OutOfMemoryError(&quot;Repeating &quot; + len + &quot; bytes String &quot; + count +\n                &quot; times will produce a String exceeding maximum size.&quot;);\n    &#125;\n    final int limit &#x3D; len * count;\n    final byte[] multiple &#x3D; new byte[limit];\n    System.arraycopy(value, 0, multiple, 0, len);\n    int copied &#x3D; len;\n    for (; copied &lt; limit - copied; copied &lt;&lt;&#x3D; 1) &#123;\n        System.arraycopy(multiple, 0, multiple, copied, copied);\n    &#125;\n    System.arraycopy(multiple, 0, multiple, copied, limit - copied);\n    return new String(multiple, coder);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>来看下更多的用法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">String str &#x3D; &quot;Java&quot;;\n\n&#x2F;&#x2F; 小于0：java.lang.IllegalArgumentException\nSystem.out.println(str.repeat(-2));\n\n&#x2F;&#x2F; 等于0：空白串（&quot;&quot;）\nSystem.out.println(str.repeat(0));\n\n&#x2F;&#x2F; JavaJavaJava\nSystem.out.println(str.repeat(3));\n\n&#x2F;&#x2F; java.lang.OutOfMemoryError\nSystem.out.println(str.repeat(Integer.MAX_VALUE));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>所以说 repeat 并不是可以无限增长的，有使用限制的，达到一定量就会报内存溢出异常。</p>\n<h4 id=\"lines\"><a href=\"#lines\" class=\"headerlink\" title=\"lines\"></a>lines</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">public Stream&lt;String&gt; lines() &#123;\n    return isLatin1() ? StringLatin1.lines(value)\n                      : StringUTF16.lines(value);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>lines 方法返回一个字符串 Stream, 可以识别 <code>\\n</code> 和 <code>\\r</code> 换行符换行。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 4\nSystem.out.println(&quot;A\\nB\\nC\\rD&quot;.lines().count());<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>是不是很好？在将来肯定有武之地！如批量读取文件内容到一个 Stream 中，就能很好的识别行结束符了。</p>\n"},{"title":"Java8 新特性之Lambda表达式","date":"2025-10-15T03:36:33.000Z","_content":"\n## 什么是Lambda表达式\n\nJava 8的一个大亮点是引入Lambda表达式，使用它设计的代码会更加简洁。当开发者在编写Lambda表达式时，也会随之被编译成一个函数式接口。\n\n## Lambda语法\n\n一行执行语句的写法：\n\n```\n(parameters) -> expression\n```\n\n如果有多行执行语句，可以加上`{}`\n```\n(parameters) -> { statements; }\n```\n\n如：\n\n```\npublic int add(int x, int y) {\n    return x + y;\n}\n```\n\n转换成Lambda表达式有以下几种写法：\n\n```\n// 指定参数类型及return\n(int x, int y) -> { return x + y; }\n\n// 指定参数类型，不指定return\n(int x, int y) -> x + y;\n\n// 不指定参数类型和return，编译器会自动推断\n(x, y) -> x + y; \n\n```\n\n## Lambda用途\n\n#### 1、只有一个抽象方法的函数式接口\n\nLambda表达式的目标类型是函数式接口，什么是函数式接口之后会讲。\n\n下面拿创建线程来举例，用lambda表达式可以有以下几种写法。\n\n```\npublic static void main(String[] args) {\n\tnew Thread(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tSystem.out.println(\"t1\");\n\t\t}\n\t}).start();\n\n\tRunnable runnable = () -> System.out.println(\"t2\");\n\tnew Thread(runnable).start();\n\n\tnew Thread(() -> System.out.println(\"t3\")).start();\n\n\tnew Thread(() -> run(\"t4\")).start();\n\n\tnew Thread(() -> {\n\t\tString str = \"t5\";\n\t\tSystem.out.println(str);\n\t}).start();\n\n}\n\nprivate static void run(String str) {\n\tSystem.out.println(str);\n}\n```\n\n最后输出：\n\n```\nt1\nt2\nt3\nt4\nt5\n```\n\n#### 2、集合批量操作\n\n下面打印list集合的两种写法是等价的。\n\n```\nList<String> list = Arrays.asList(\"a\",\"b\",\"c\");\nfor(String str : list){\n\tSystem.out.println(str);\n}\n\nlist.forEach((e) -> System.out.println(e));\n```\n\n#### 3、流操作\n\n下面是流查询list集合中等于`\"a\"`的数量。\n\n```\nlist.stream().filter((e) -> \"a\".equals(e)).count();\n```\n\n更多的Lambda表达式及关于流更多内容之后陆续会讲到。\n\n","source":"_posts/新特性/Java8/Java8 新特性之Lambda表达式.md","raw":"---\ntitle: Java8 新特性之Lambda表达式\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n\n## 什么是Lambda表达式\n\nJava 8的一个大亮点是引入Lambda表达式，使用它设计的代码会更加简洁。当开发者在编写Lambda表达式时，也会随之被编译成一个函数式接口。\n\n## Lambda语法\n\n一行执行语句的写法：\n\n```\n(parameters) -> expression\n```\n\n如果有多行执行语句，可以加上`{}`\n```\n(parameters) -> { statements; }\n```\n\n如：\n\n```\npublic int add(int x, int y) {\n    return x + y;\n}\n```\n\n转换成Lambda表达式有以下几种写法：\n\n```\n// 指定参数类型及return\n(int x, int y) -> { return x + y; }\n\n// 指定参数类型，不指定return\n(int x, int y) -> x + y;\n\n// 不指定参数类型和return，编译器会自动推断\n(x, y) -> x + y; \n\n```\n\n## Lambda用途\n\n#### 1、只有一个抽象方法的函数式接口\n\nLambda表达式的目标类型是函数式接口，什么是函数式接口之后会讲。\n\n下面拿创建线程来举例，用lambda表达式可以有以下几种写法。\n\n```\npublic static void main(String[] args) {\n\tnew Thread(new Runnable() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tSystem.out.println(\"t1\");\n\t\t}\n\t}).start();\n\n\tRunnable runnable = () -> System.out.println(\"t2\");\n\tnew Thread(runnable).start();\n\n\tnew Thread(() -> System.out.println(\"t3\")).start();\n\n\tnew Thread(() -> run(\"t4\")).start();\n\n\tnew Thread(() -> {\n\t\tString str = \"t5\";\n\t\tSystem.out.println(str);\n\t}).start();\n\n}\n\nprivate static void run(String str) {\n\tSystem.out.println(str);\n}\n```\n\n最后输出：\n\n```\nt1\nt2\nt3\nt4\nt5\n```\n\n#### 2、集合批量操作\n\n下面打印list集合的两种写法是等价的。\n\n```\nList<String> list = Arrays.asList(\"a\",\"b\",\"c\");\nfor(String str : list){\n\tSystem.out.println(str);\n}\n\nlist.forEach((e) -> System.out.println(e));\n```\n\n#### 3、流操作\n\n下面是流查询list集合中等于`\"a\"`的数量。\n\n```\nlist.stream().filter((e) -> \"a\".equals(e)).count();\n```\n\n更多的Lambda表达式及关于流更多内容之后陆续会讲到。\n\n","slug":"新特性/Java8/Java8 新特性之Lambda表达式","published":1,"updated":"2025-10-15T07:20:51.510Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu0775005lqkd4g5wg2nkh","content":"<h2 id=\"什么是Lambda表达式\"><a href=\"#什么是Lambda表达式\" class=\"headerlink\" title=\"什么是Lambda表达式\"></a>什么是Lambda表达式</h2><p>Java 8的一个大亮点是引入Lambda表达式，使用它设计的代码会更加简洁。当开发者在编写Lambda表达式时，也会随之被编译成一个函数式接口。</p>\n<h2 id=\"Lambda语法\"><a href=\"#Lambda语法\" class=\"headerlink\" title=\"Lambda语法\"></a>Lambda语法</h2><p>一行执行语句的写法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">(parameters) -&gt; expression<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果有多行执行语句，可以加上<code>&#123;&#125;</code></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">(parameters) -&gt; &#123; statements; &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public int add(int x, int y) &#123;\n    return x + y;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>转换成Lambda表达式有以下几种写法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 指定参数类型及return\n(int x, int y) -&gt; &#123; return x + y; &#125;\n\n&#x2F;&#x2F; 指定参数类型，不指定return\n(int x, int y) -&gt; x + y;\n\n&#x2F;&#x2F; 不指定参数类型和return，编译器会自动推断\n(x, y) -&gt; x + y; \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"Lambda用途\"><a href=\"#Lambda用途\" class=\"headerlink\" title=\"Lambda用途\"></a>Lambda用途</h2><h4 id=\"1、只有一个抽象方法的函数式接口\"><a href=\"#1、只有一个抽象方法的函数式接口\" class=\"headerlink\" title=\"1、只有一个抽象方法的函数式接口\"></a>1、只有一个抽象方法的函数式接口</h4><p>Lambda表达式的目标类型是函数式接口，什么是函数式接口之后会讲。</p>\n<p>下面拿创建线程来举例，用lambda表达式可以有以下几种写法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n\tnew Thread(new Runnable() &#123;\n\t\t@Override\n\t\tpublic void run() &#123;\n\t\t\tSystem.out.println(&quot;t1&quot;);\n\t\t&#125;\n\t&#125;).start();\n\n\tRunnable runnable &#x3D; () -&gt; System.out.println(&quot;t2&quot;);\n\tnew Thread(runnable).start();\n\n\tnew Thread(() -&gt; System.out.println(&quot;t3&quot;)).start();\n\n\tnew Thread(() -&gt; run(&quot;t4&quot;)).start();\n\n\tnew Thread(() -&gt; &#123;\n\t\tString str &#x3D; &quot;t5&quot;;\n\t\tSystem.out.println(str);\n\t&#125;).start();\n\n&#125;\n\nprivate static void run(String str) &#123;\n\tSystem.out.println(str);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>最后输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">t1\nt2\nt3\nt4\nt5<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"2、集合批量操作\"><a href=\"#2、集合批量操作\" class=\"headerlink\" title=\"2、集合批量操作\"></a>2、集合批量操作</h4><p>下面打印list集合的两种写法是等价的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; list &#x3D; Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);\nfor(String str : list)&#123;\n\tSystem.out.println(str);\n&#125;\n\nlist.forEach((e) -&gt; System.out.println(e));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"3、流操作\"><a href=\"#3、流操作\" class=\"headerlink\" title=\"3、流操作\"></a>3、流操作</h4><p>下面是流查询list集合中等于<code>&quot;a&quot;</code>的数量。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">list.stream().filter((e) -&gt; &quot;a&quot;.equals(e)).count();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>更多的Lambda表达式及关于流更多内容之后陆续会讲到。</p>\n","excerpt":"","more":"<h2 id=\"什么是Lambda表达式\"><a href=\"#什么是Lambda表达式\" class=\"headerlink\" title=\"什么是Lambda表达式\"></a>什么是Lambda表达式</h2><p>Java 8的一个大亮点是引入Lambda表达式，使用它设计的代码会更加简洁。当开发者在编写Lambda表达式时，也会随之被编译成一个函数式接口。</p>\n<h2 id=\"Lambda语法\"><a href=\"#Lambda语法\" class=\"headerlink\" title=\"Lambda语法\"></a>Lambda语法</h2><p>一行执行语句的写法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">(parameters) -&gt; expression<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果有多行执行语句，可以加上<code>&#123;&#125;</code></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">(parameters) -&gt; &#123; statements; &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public int add(int x, int y) &#123;\n    return x + y;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>转换成Lambda表达式有以下几种写法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 指定参数类型及return\n(int x, int y) -&gt; &#123; return x + y; &#125;\n\n&#x2F;&#x2F; 指定参数类型，不指定return\n(int x, int y) -&gt; x + y;\n\n&#x2F;&#x2F; 不指定参数类型和return，编译器会自动推断\n(x, y) -&gt; x + y; \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"Lambda用途\"><a href=\"#Lambda用途\" class=\"headerlink\" title=\"Lambda用途\"></a>Lambda用途</h2><h4 id=\"1、只有一个抽象方法的函数式接口\"><a href=\"#1、只有一个抽象方法的函数式接口\" class=\"headerlink\" title=\"1、只有一个抽象方法的函数式接口\"></a>1、只有一个抽象方法的函数式接口</h4><p>Lambda表达式的目标类型是函数式接口，什么是函数式接口之后会讲。</p>\n<p>下面拿创建线程来举例，用lambda表达式可以有以下几种写法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n\tnew Thread(new Runnable() &#123;\n\t\t@Override\n\t\tpublic void run() &#123;\n\t\t\tSystem.out.println(&quot;t1&quot;);\n\t\t&#125;\n\t&#125;).start();\n\n\tRunnable runnable &#x3D; () -&gt; System.out.println(&quot;t2&quot;);\n\tnew Thread(runnable).start();\n\n\tnew Thread(() -&gt; System.out.println(&quot;t3&quot;)).start();\n\n\tnew Thread(() -&gt; run(&quot;t4&quot;)).start();\n\n\tnew Thread(() -&gt; &#123;\n\t\tString str &#x3D; &quot;t5&quot;;\n\t\tSystem.out.println(str);\n\t&#125;).start();\n\n&#125;\n\nprivate static void run(String str) &#123;\n\tSystem.out.println(str);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>最后输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">t1\nt2\nt3\nt4\nt5<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"2、集合批量操作\"><a href=\"#2、集合批量操作\" class=\"headerlink\" title=\"2、集合批量操作\"></a>2、集合批量操作</h4><p>下面打印list集合的两种写法是等价的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; list &#x3D; Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);\nfor(String str : list)&#123;\n\tSystem.out.println(str);\n&#125;\n\nlist.forEach((e) -&gt; System.out.println(e));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"3、流操作\"><a href=\"#3、流操作\" class=\"headerlink\" title=\"3、流操作\"></a>3、流操作</h4><p>下面是流查询list集合中等于<code>&quot;a&quot;</code>的数量。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">list.stream().filter((e) -&gt; &quot;a&quot;.equals(e)).count();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>更多的Lambda表达式及关于流更多内容之后陆续会讲到。</p>\n"},{"title":"JJava8 新特性之Optional","date":"2025-10-15T03:36:33.000Z","_content":"\n## Optional是什么\n\n`java.util.Optional`\n\nJdk8提供`Optional`，一个可以包含null值的容器对象，可以用来代替xx != null的判断。\n\n## Optional常用方法\n\n### of\n\n\n```\npublic static <T> Optional<T> of(T value) {\n    return new Optional<>(value);\n}\n```\n\n为value创建一个Optional对象，如果value为空则 会报出NullPointerException异常。\n\n### ofNullable\n\n```\npublic static <T> Optional<T> ofNullable(T value) {\n    return value == null ? empty() : of(value);\n}\n```\n\n为value创建一个Optional对象，但可以允许value为null值。\n\n### isPresent\n\n```\npublic boolean isPresent() {\n    return value != null;\n}\n```\n\n判断当前value是否为null,如果不为null则返回true，否则false。\n\n### ifPresent\n\n如果不为null值就执行函数式接口的内容。\n\n```\npublic void ifPresent(Consumer<? super T> consumer) {\n    if (value != null)\n        consumer.accept(value);\n}\n```\n\n### get\n\n\n```\npublic T get() {\n    if (value == null) {\n        throw new NoSuchElementException(\"No value present\");\n    }\n    return value;\n}\n```\n\n返回当前的值，如果为空则报异常。\n\n### orElse\n\n返回当前值，如果为null则返回other。\n\n```\npublic T orElse(T other) {\n    return value != null ? value : other;\n}\n```\n\n### orElseGet\n\norElseGet和orElse类似，只是orElseGet支持函数式接口来生成other值。\n\n```\npublic T orElseGet(Supplier<? extends T> other) {\n    return value != null ? value : other.get();\n}\n```\n\n### orElseThrow\n\n如果有值则返回，没有则用函数式接口抛出生成的异常。\n\n```\npublic <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {\n    if (value != null) {\n        return value;\n    } else {\n        throw exceptionSupplier.get();\n    }\n}\n```\n\n## 示例\n\n```\npublic static void main(String[] args) {\n\ttestOf();\n\ttestNullable();\n}\n\n\nprivate static void testNullable() {\n\tUser user = null;\n\tUser john = new User(\"john\", 18);\n\tUser dick = new User(\"dick\", 12);\n\n\tSystem.out.println(Optional.ofNullable(user).orElse(john));\n\tSystem.out.println(Optional.ofNullable(john).get());\n\tSystem.out.println(Optional.ofNullable(dick).orElse(john));\n\tSystem.out.println(Optional.ofNullable(user).orElseGet(() -> john));\n\n\tSystem.out.println();\n}\n\nprivate static void testOf() {\n\ttry {\n\t\tUser user1 = new User();\n\t\tOptional<User> userOptional1 = Optional.of(user1);\n\t\tif (userOptional1.isPresent()) {\n\t\t\tSystem.out.println(\"user is not null\");\n\t\t}\n\n\t\tUser user2 = null;\n\t\tOptional<User> userOptional2 = Optional.of(user2);//NullPointerException\n\t\tif (userOptional2.isPresent()) {\n\t\t\tSystem.out.println(\"user is not null\");\n\t\t}\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n\tSystem.out.println();\n}\n```\n\n`Optional`在jdk8中有大量使用，比如像Stream流中，但`Optional`用在null判断感觉也没什么鸟用。。\n\n在Spring4中也可以用Optional来代替autowired(require=false)的情况，参考历史Spring系列文章。\n\n\n\n\n\n\n","source":"_posts/新特性/Java8/Java8 新特性之Optional.md","raw":"---\ntitle: JJava8 新特性之Optional\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n\n## Optional是什么\n\n`java.util.Optional`\n\nJdk8提供`Optional`，一个可以包含null值的容器对象，可以用来代替xx != null的判断。\n\n## Optional常用方法\n\n### of\n\n\n```\npublic static <T> Optional<T> of(T value) {\n    return new Optional<>(value);\n}\n```\n\n为value创建一个Optional对象，如果value为空则 会报出NullPointerException异常。\n\n### ofNullable\n\n```\npublic static <T> Optional<T> ofNullable(T value) {\n    return value == null ? empty() : of(value);\n}\n```\n\n为value创建一个Optional对象，但可以允许value为null值。\n\n### isPresent\n\n```\npublic boolean isPresent() {\n    return value != null;\n}\n```\n\n判断当前value是否为null,如果不为null则返回true，否则false。\n\n### ifPresent\n\n如果不为null值就执行函数式接口的内容。\n\n```\npublic void ifPresent(Consumer<? super T> consumer) {\n    if (value != null)\n        consumer.accept(value);\n}\n```\n\n### get\n\n\n```\npublic T get() {\n    if (value == null) {\n        throw new NoSuchElementException(\"No value present\");\n    }\n    return value;\n}\n```\n\n返回当前的值，如果为空则报异常。\n\n### orElse\n\n返回当前值，如果为null则返回other。\n\n```\npublic T orElse(T other) {\n    return value != null ? value : other;\n}\n```\n\n### orElseGet\n\norElseGet和orElse类似，只是orElseGet支持函数式接口来生成other值。\n\n```\npublic T orElseGet(Supplier<? extends T> other) {\n    return value != null ? value : other.get();\n}\n```\n\n### orElseThrow\n\n如果有值则返回，没有则用函数式接口抛出生成的异常。\n\n```\npublic <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {\n    if (value != null) {\n        return value;\n    } else {\n        throw exceptionSupplier.get();\n    }\n}\n```\n\n## 示例\n\n```\npublic static void main(String[] args) {\n\ttestOf();\n\ttestNullable();\n}\n\n\nprivate static void testNullable() {\n\tUser user = null;\n\tUser john = new User(\"john\", 18);\n\tUser dick = new User(\"dick\", 12);\n\n\tSystem.out.println(Optional.ofNullable(user).orElse(john));\n\tSystem.out.println(Optional.ofNullable(john).get());\n\tSystem.out.println(Optional.ofNullable(dick).orElse(john));\n\tSystem.out.println(Optional.ofNullable(user).orElseGet(() -> john));\n\n\tSystem.out.println();\n}\n\nprivate static void testOf() {\n\ttry {\n\t\tUser user1 = new User();\n\t\tOptional<User> userOptional1 = Optional.of(user1);\n\t\tif (userOptional1.isPresent()) {\n\t\t\tSystem.out.println(\"user is not null\");\n\t\t}\n\n\t\tUser user2 = null;\n\t\tOptional<User> userOptional2 = Optional.of(user2);//NullPointerException\n\t\tif (userOptional2.isPresent()) {\n\t\t\tSystem.out.println(\"user is not null\");\n\t\t}\n\t} catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n\tSystem.out.println();\n}\n```\n\n`Optional`在jdk8中有大量使用，比如像Stream流中，但`Optional`用在null判断感觉也没什么鸟用。。\n\n在Spring4中也可以用Optional来代替autowired(require=false)的情况，参考历史Spring系列文章。\n\n\n\n\n\n\n","slug":"新特性/Java8/Java8 新特性之Optional","published":1,"updated":"2025-10-15T07:20:51.398Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu0775005oqkd47g96fnmy","content":"<h2 id=\"Optional是什么\"><a href=\"#Optional是什么\" class=\"headerlink\" title=\"Optional是什么\"></a>Optional是什么</h2><p><code>java.util.Optional</code></p>\n<p>Jdk8提供<code>Optional</code>，一个可以包含null值的容器对象，可以用来代替xx !&#x3D; null的判断。</p>\n<h2 id=\"Optional常用方法\"><a href=\"#Optional常用方法\" class=\"headerlink\" title=\"Optional常用方法\"></a>Optional常用方法</h2><h3 id=\"of\"><a href=\"#of\" class=\"headerlink\" title=\"of\"></a>of</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">public static &lt;T&gt; Optional&lt;T&gt; of(T value) &#123;\n    return new Optional&lt;&gt;(value);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>为value创建一个Optional对象，如果value为空则 会报出NullPointerException异常。</p>\n<h3 id=\"ofNullable\"><a href=\"#ofNullable\" class=\"headerlink\" title=\"ofNullable\"></a>ofNullable</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) &#123;\n    return value &#x3D;&#x3D; null ? empty() : of(value);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>为value创建一个Optional对象，但可以允许value为null值。</p>\n<h3 id=\"isPresent\"><a href=\"#isPresent\" class=\"headerlink\" title=\"isPresent\"></a>isPresent</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">public boolean isPresent() &#123;\n    return value !&#x3D; null;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>判断当前value是否为null,如果不为null则返回true，否则false。</p>\n<h3 id=\"ifPresent\"><a href=\"#ifPresent\" class=\"headerlink\" title=\"ifPresent\"></a>ifPresent</h3><p>如果不为null值就执行函数式接口的内容。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public void ifPresent(Consumer&lt;? super T&gt; consumer) &#123;\n    if (value !&#x3D; null)\n        consumer.accept(value);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">public T get() &#123;\n    if (value &#x3D;&#x3D; null) &#123;\n        throw new NoSuchElementException(&quot;No value present&quot;);\n    &#125;\n    return value;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>返回当前的值，如果为空则报异常。</p>\n<h3 id=\"orElse\"><a href=\"#orElse\" class=\"headerlink\" title=\"orElse\"></a>orElse</h3><p>返回当前值，如果为null则返回other。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public T orElse(T other) &#123;\n    return value !&#x3D; null ? value : other;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"orElseGet\"><a href=\"#orElseGet\" class=\"headerlink\" title=\"orElseGet\"></a>orElseGet</h3><p>orElseGet和orElse类似，只是orElseGet支持函数式接口来生成other值。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public T orElseGet(Supplier&lt;? extends T&gt; other) &#123;\n    return value !&#x3D; null ? value : other.get();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"orElseThrow\"><a href=\"#orElseThrow\" class=\"headerlink\" title=\"orElseThrow\"></a>orElseThrow</h3><p>如果有值则返回，没有则用函数式接口抛出生成的异常。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X &#123;\n    if (value !&#x3D; null) &#123;\n        return value;\n    &#125; else &#123;\n        throw exceptionSupplier.get();\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n\ttestOf();\n\ttestNullable();\n&#125;\n\n\nprivate static void testNullable() &#123;\n\tUser user &#x3D; null;\n\tUser john &#x3D; new User(&quot;john&quot;, 18);\n\tUser dick &#x3D; new User(&quot;dick&quot;, 12);\n\n\tSystem.out.println(Optional.ofNullable(user).orElse(john));\n\tSystem.out.println(Optional.ofNullable(john).get());\n\tSystem.out.println(Optional.ofNullable(dick).orElse(john));\n\tSystem.out.println(Optional.ofNullable(user).orElseGet(() -&gt; john));\n\n\tSystem.out.println();\n&#125;\n\nprivate static void testOf() &#123;\n\ttry &#123;\n\t\tUser user1 &#x3D; new User();\n\t\tOptional&lt;User&gt; userOptional1 &#x3D; Optional.of(user1);\n\t\tif (userOptional1.isPresent()) &#123;\n\t\t\tSystem.out.println(&quot;user is not null&quot;);\n\t\t&#125;\n\n\t\tUser user2 &#x3D; null;\n\t\tOptional&lt;User&gt; userOptional2 &#x3D; Optional.of(user2);&#x2F;&#x2F;NullPointerException\n\t\tif (userOptional2.isPresent()) &#123;\n\t\t\tSystem.out.println(&quot;user is not null&quot;);\n\t\t&#125;\n\t&#125; catch (Exception e) &#123;\n\t\te.printStackTrace();\n\t&#125;\n\tSystem.out.println();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>Optional</code>在jdk8中有大量使用，比如像Stream流中，但<code>Optional</code>用在null判断感觉也没什么鸟用。。</p>\n<p>在Spring4中也可以用Optional来代替autowired(require&#x3D;false)的情况，参考历史Spring系列文章。</p>\n","excerpt":"","more":"<h2 id=\"Optional是什么\"><a href=\"#Optional是什么\" class=\"headerlink\" title=\"Optional是什么\"></a>Optional是什么</h2><p><code>java.util.Optional</code></p>\n<p>Jdk8提供<code>Optional</code>，一个可以包含null值的容器对象，可以用来代替xx !&#x3D; null的判断。</p>\n<h2 id=\"Optional常用方法\"><a href=\"#Optional常用方法\" class=\"headerlink\" title=\"Optional常用方法\"></a>Optional常用方法</h2><h3 id=\"of\"><a href=\"#of\" class=\"headerlink\" title=\"of\"></a>of</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">public static &lt;T&gt; Optional&lt;T&gt; of(T value) &#123;\n    return new Optional&lt;&gt;(value);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>为value创建一个Optional对象，如果value为空则 会报出NullPointerException异常。</p>\n<h3 id=\"ofNullable\"><a href=\"#ofNullable\" class=\"headerlink\" title=\"ofNullable\"></a>ofNullable</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) &#123;\n    return value &#x3D;&#x3D; null ? empty() : of(value);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>为value创建一个Optional对象，但可以允许value为null值。</p>\n<h3 id=\"isPresent\"><a href=\"#isPresent\" class=\"headerlink\" title=\"isPresent\"></a>isPresent</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">public boolean isPresent() &#123;\n    return value !&#x3D; null;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>判断当前value是否为null,如果不为null则返回true，否则false。</p>\n<h3 id=\"ifPresent\"><a href=\"#ifPresent\" class=\"headerlink\" title=\"ifPresent\"></a>ifPresent</h3><p>如果不为null值就执行函数式接口的内容。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public void ifPresent(Consumer&lt;? super T&gt; consumer) &#123;\n    if (value !&#x3D; null)\n        consumer.accept(value);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">public T get() &#123;\n    if (value &#x3D;&#x3D; null) &#123;\n        throw new NoSuchElementException(&quot;No value present&quot;);\n    &#125;\n    return value;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>返回当前的值，如果为空则报异常。</p>\n<h3 id=\"orElse\"><a href=\"#orElse\" class=\"headerlink\" title=\"orElse\"></a>orElse</h3><p>返回当前值，如果为null则返回other。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public T orElse(T other) &#123;\n    return value !&#x3D; null ? value : other;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"orElseGet\"><a href=\"#orElseGet\" class=\"headerlink\" title=\"orElseGet\"></a>orElseGet</h3><p>orElseGet和orElse类似，只是orElseGet支持函数式接口来生成other值。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public T orElseGet(Supplier&lt;? extends T&gt; other) &#123;\n    return value !&#x3D; null ? value : other.get();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"orElseThrow\"><a href=\"#orElseThrow\" class=\"headerlink\" title=\"orElseThrow\"></a>orElseThrow</h3><p>如果有值则返回，没有则用函数式接口抛出生成的异常。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X &#123;\n    if (value !&#x3D; null) &#123;\n        return value;\n    &#125; else &#123;\n        throw exceptionSupplier.get();\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n\ttestOf();\n\ttestNullable();\n&#125;\n\n\nprivate static void testNullable() &#123;\n\tUser user &#x3D; null;\n\tUser john &#x3D; new User(&quot;john&quot;, 18);\n\tUser dick &#x3D; new User(&quot;dick&quot;, 12);\n\n\tSystem.out.println(Optional.ofNullable(user).orElse(john));\n\tSystem.out.println(Optional.ofNullable(john).get());\n\tSystem.out.println(Optional.ofNullable(dick).orElse(john));\n\tSystem.out.println(Optional.ofNullable(user).orElseGet(() -&gt; john));\n\n\tSystem.out.println();\n&#125;\n\nprivate static void testOf() &#123;\n\ttry &#123;\n\t\tUser user1 &#x3D; new User();\n\t\tOptional&lt;User&gt; userOptional1 &#x3D; Optional.of(user1);\n\t\tif (userOptional1.isPresent()) &#123;\n\t\t\tSystem.out.println(&quot;user is not null&quot;);\n\t\t&#125;\n\n\t\tUser user2 &#x3D; null;\n\t\tOptional&lt;User&gt; userOptional2 &#x3D; Optional.of(user2);&#x2F;&#x2F;NullPointerException\n\t\tif (userOptional2.isPresent()) &#123;\n\t\t\tSystem.out.println(&quot;user is not null&quot;);\n\t\t&#125;\n\t&#125; catch (Exception e) &#123;\n\t\te.printStackTrace();\n\t&#125;\n\tSystem.out.println();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>Optional</code>在jdk8中有大量使用，比如像Stream流中，但<code>Optional</code>用在null判断感觉也没什么鸟用。。</p>\n<p>在Spring4中也可以用Optional来代替autowired(require&#x3D;false)的情况，参考历史Spring系列文章。</p>\n"},{"title":"Java8 新特性之函数式接口","date":"2025-10-15T03:36:33.000Z","_content":"\n## 什么是函数式接口\n\n先来看看传统的创建线程是怎么写的\n\n\n```\nThread t1 = new Thread(new Runnable() {\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"t1\");\n\t}\n});\nt1.start();\n```\n\n再来看看使用了函数式接口是怎么写的\n\n\n```\nThread t2 = new Thread(() -> System.out.println(\"t2\"));\nt2.start();\n```\n\nRunnable接口直接可以使用Lambda表达式来编写，这是因为Runnable接口是一个函数式接口，来看看Runnable的源码。\n\n```\n@FunctionalInterface\npublic interface Runnable {\n\n    public abstract void run();\n    \n}\n```\n发现该接口加上了函数式接口的定义注解：`@FunctionalInterface`，表明该接口是一个函数式接口。\n\n\n```\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface FunctionalInterface {\n    \n}\n```\n\n\n在JDK8中，除了Runnbale接口，还有像Comparator、Callable等接口都加上了该注解定义为函数式接口。\n\n## 内置函数式接口\n\nJDK8提供了几个内置的函数式接口，用在了许多API的地方，都可以拿来用，可以满足大部分应用。\n\n```\n//Consumer<T> - T作为输入，执行某种动作但没有返回值\nConsumer<String> con = (x) -> {\n\tSystem.out.println(x);\n};\ncon.accept(\"hello world\");\n\n//Supplier<T> - 没有任何输入，返回T\nSupplier<String> supp = () -> {\n\treturn \"Supplier\";\n};\nSystem.out.println(supp.get());\n\n//Predicate<T> -T作为输入，返回的boolean值作为输出\nPredicate<String> pre = (x) -> {\n\tSystem.out.print(x);\n\treturn x.startsWith(\"op\");\n};\nSystem.out.println(\": \" + pre.test(\"op, hello World\"));\n\n// Function<T, R> -T作为输入，返回的R作为输出\nFunction<String, String> function = (x) -> {\n\tSystem.out.print(x + \": \");\n\treturn \"Function\";\n};\nSystem.out.println(function.apply(\"hello world\"));\n\n//BinaryOperator<T> -两个T作为输入，返回一个T作为输出，对于“reduce”操作很有用\nBinaryOperator<String> bina = (x, y) -> {\n\tSystem.out.print(x + \" \" + y);\n\treturn \"BinaryOperator\";\n};\nSystem.out.println(\"  \" + bina.apply(\"hello \", \"world\"));\n```\n\n\n\n## 自定义函数式接口\n\n#### 1、自定义一个函数式接口\n\n```\n@FunctionalInterface\npublic interface CalcInterface<N, V> {\t\n\tV operation(N n1, N n2);\n}\n```\n\n这里只有一个抽象方法，@FunctionalInterface注解可以不用写，至于为什么可以往下看。\n\n#### 2、新建一个引用函数式接口的类\n\n```\npublic static class NumberOperation<N extends Number, V extends Number> {\n\n\tprivate N n1;\n\tprivate N n2;\n\n\tpublic NumberOperation(N n1, N n2) {\n\t\tthis.n1 = n1;\n\t\tthis.n2 = n2;\n\t}\n\n\tpublic V calc(CalcInterface<N, V> ci) {\n\t\tV v = ci.operation(n1, n2);\n\t\treturn v;\n\t}\n\n}\n```\n\n#### 3、测试函数式接口\n\n```\nprivate static void testOperationFnInterface() {\n        NumberOperation<Integer, Integer> np = new NumberOperation(13, 10);\n    \n\tCalcInterface<Integer, Integer> addOper1 = (n1, n2) -> {\n\t\treturn n1 + n2;\n\t};\n\tCalcInterface<Integer, Integer> multiOper1 = (n1, n2) -> {\n\t\treturn n1 * n2;\n\t};\n\tSystem.out.println(np.calc1(addOper1));\n\tSystem.out.println(np.calc1(multiOper1));\n\t\n\t// 上面的可以简写为\n\tSystem.out.println(np.calc1((n1, n2) -> n1 + n2));\n\tSystem.out.println(np.calc1((n1, n2) -> n1 * n2));\n}\n```\n\n最后输出：\n\n```\n23\n130\n23\n130\n```\n\n## 函数式接口规范\n\n1、@FunctionalInterface标识为一个函数式接口只能用在只有一个抽象方法的接口上。\n\n2、接口中的静态方法、默认方法、覆盖了Object类的方法都不算抽象方法。\n\n3、@FunctionalInterface注解不是必须的，如果该接口只有一个抽象方法可以不写，它默认就符合函数式接口，但建议都写上该注解，编译器会检查该接口是否符合函数式接口的规范。\n\n\n## 举例说明\n\n正确的函数式接口。\n\n```\n@FunctionalInterface\npublic interface CalcInterface<N, V> {\t\n\tV operation(N n1, N n2);\n}\n```\n\n加了几个符合函数式的方法也没事，编译器也不会报错。\n\n```\n@FunctionalInterface\npublic interface CalcInterface<N, V> {\t\t\n\n\tV operation(N n1, N n2);\n   \n\tpublic boolean equals(Object object);\n\n\tpublic default void defaultMethod() {\n\n\t}\n\n\tpublic static void staticMethod() {\n\n\t}\n}\n```\n\n这个没用@FunctionalInterface函数式接口，有两个抽象方法，不能用于Lambda表达式。\n\n```\npublic interface CalcInterface<N, V> {\t\n\tV operation(N n1, N n2);\n\tV operation2(N n1, N n2);\n}\n```\n\n这个有两个抽象方法的用@FunctionalInterface注解的函数式接口编译会报错。\n\n```\n@FunctionalInterface\npublic interface CalcInterface<N, V> {\t\n\tV operation(N n1, N n2);\n\tV operation2(N n1, N n2);\n}\n```\n\n这个没有一个抽象方法，编译报错。\n\n```\npublic interface CalcInterface<N, V> {\t\n}\n```\n","source":"_posts/新特性/Java8/Java8 新特性之函数式接口.md","raw":"---\ntitle: Java8 新特性之函数式接口\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n\n## 什么是函数式接口\n\n先来看看传统的创建线程是怎么写的\n\n\n```\nThread t1 = new Thread(new Runnable() {\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"t1\");\n\t}\n});\nt1.start();\n```\n\n再来看看使用了函数式接口是怎么写的\n\n\n```\nThread t2 = new Thread(() -> System.out.println(\"t2\"));\nt2.start();\n```\n\nRunnable接口直接可以使用Lambda表达式来编写，这是因为Runnable接口是一个函数式接口，来看看Runnable的源码。\n\n```\n@FunctionalInterface\npublic interface Runnable {\n\n    public abstract void run();\n    \n}\n```\n发现该接口加上了函数式接口的定义注解：`@FunctionalInterface`，表明该接口是一个函数式接口。\n\n\n```\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface FunctionalInterface {\n    \n}\n```\n\n\n在JDK8中，除了Runnbale接口，还有像Comparator、Callable等接口都加上了该注解定义为函数式接口。\n\n## 内置函数式接口\n\nJDK8提供了几个内置的函数式接口，用在了许多API的地方，都可以拿来用，可以满足大部分应用。\n\n```\n//Consumer<T> - T作为输入，执行某种动作但没有返回值\nConsumer<String> con = (x) -> {\n\tSystem.out.println(x);\n};\ncon.accept(\"hello world\");\n\n//Supplier<T> - 没有任何输入，返回T\nSupplier<String> supp = () -> {\n\treturn \"Supplier\";\n};\nSystem.out.println(supp.get());\n\n//Predicate<T> -T作为输入，返回的boolean值作为输出\nPredicate<String> pre = (x) -> {\n\tSystem.out.print(x);\n\treturn x.startsWith(\"op\");\n};\nSystem.out.println(\": \" + pre.test(\"op, hello World\"));\n\n// Function<T, R> -T作为输入，返回的R作为输出\nFunction<String, String> function = (x) -> {\n\tSystem.out.print(x + \": \");\n\treturn \"Function\";\n};\nSystem.out.println(function.apply(\"hello world\"));\n\n//BinaryOperator<T> -两个T作为输入，返回一个T作为输出，对于“reduce”操作很有用\nBinaryOperator<String> bina = (x, y) -> {\n\tSystem.out.print(x + \" \" + y);\n\treturn \"BinaryOperator\";\n};\nSystem.out.println(\"  \" + bina.apply(\"hello \", \"world\"));\n```\n\n\n\n## 自定义函数式接口\n\n#### 1、自定义一个函数式接口\n\n```\n@FunctionalInterface\npublic interface CalcInterface<N, V> {\t\n\tV operation(N n1, N n2);\n}\n```\n\n这里只有一个抽象方法，@FunctionalInterface注解可以不用写，至于为什么可以往下看。\n\n#### 2、新建一个引用函数式接口的类\n\n```\npublic static class NumberOperation<N extends Number, V extends Number> {\n\n\tprivate N n1;\n\tprivate N n2;\n\n\tpublic NumberOperation(N n1, N n2) {\n\t\tthis.n1 = n1;\n\t\tthis.n2 = n2;\n\t}\n\n\tpublic V calc(CalcInterface<N, V> ci) {\n\t\tV v = ci.operation(n1, n2);\n\t\treturn v;\n\t}\n\n}\n```\n\n#### 3、测试函数式接口\n\n```\nprivate static void testOperationFnInterface() {\n        NumberOperation<Integer, Integer> np = new NumberOperation(13, 10);\n    \n\tCalcInterface<Integer, Integer> addOper1 = (n1, n2) -> {\n\t\treturn n1 + n2;\n\t};\n\tCalcInterface<Integer, Integer> multiOper1 = (n1, n2) -> {\n\t\treturn n1 * n2;\n\t};\n\tSystem.out.println(np.calc1(addOper1));\n\tSystem.out.println(np.calc1(multiOper1));\n\t\n\t// 上面的可以简写为\n\tSystem.out.println(np.calc1((n1, n2) -> n1 + n2));\n\tSystem.out.println(np.calc1((n1, n2) -> n1 * n2));\n}\n```\n\n最后输出：\n\n```\n23\n130\n23\n130\n```\n\n## 函数式接口规范\n\n1、@FunctionalInterface标识为一个函数式接口只能用在只有一个抽象方法的接口上。\n\n2、接口中的静态方法、默认方法、覆盖了Object类的方法都不算抽象方法。\n\n3、@FunctionalInterface注解不是必须的，如果该接口只有一个抽象方法可以不写，它默认就符合函数式接口，但建议都写上该注解，编译器会检查该接口是否符合函数式接口的规范。\n\n\n## 举例说明\n\n正确的函数式接口。\n\n```\n@FunctionalInterface\npublic interface CalcInterface<N, V> {\t\n\tV operation(N n1, N n2);\n}\n```\n\n加了几个符合函数式的方法也没事，编译器也不会报错。\n\n```\n@FunctionalInterface\npublic interface CalcInterface<N, V> {\t\t\n\n\tV operation(N n1, N n2);\n   \n\tpublic boolean equals(Object object);\n\n\tpublic default void defaultMethod() {\n\n\t}\n\n\tpublic static void staticMethod() {\n\n\t}\n}\n```\n\n这个没用@FunctionalInterface函数式接口，有两个抽象方法，不能用于Lambda表达式。\n\n```\npublic interface CalcInterface<N, V> {\t\n\tV operation(N n1, N n2);\n\tV operation2(N n1, N n2);\n}\n```\n\n这个有两个抽象方法的用@FunctionalInterface注解的函数式接口编译会报错。\n\n```\n@FunctionalInterface\npublic interface CalcInterface<N, V> {\t\n\tV operation(N n1, N n2);\n\tV operation2(N n1, N n2);\n}\n```\n\n这个没有一个抽象方法，编译报错。\n\n```\npublic interface CalcInterface<N, V> {\t\n}\n```\n","slug":"新特性/Java8/Java8 新特性之函数式接口","published":1,"updated":"2025-10-15T07:20:51.515Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu0776005rqkd4aqhv9mgk","content":"<h2 id=\"什么是函数式接口\"><a href=\"#什么是函数式接口\" class=\"headerlink\" title=\"什么是函数式接口\"></a>什么是函数式接口</h2><p>先来看看传统的创建线程是怎么写的</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Thread t1 &#x3D; new Thread(new Runnable() &#123;\n\t@Override\n\tpublic void run() &#123;\n\t\tSystem.out.println(&quot;t1&quot;);\n\t&#125;\n&#125;);\nt1.start();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>再来看看使用了函数式接口是怎么写的</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Thread t2 &#x3D; new Thread(() -&gt; System.out.println(&quot;t2&quot;));\nt2.start();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>Runnable接口直接可以使用Lambda表达式来编写，这是因为Runnable接口是一个函数式接口，来看看Runnable的源码。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@FunctionalInterface\npublic interface Runnable &#123;\n\n    public abstract void run();\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>发现该接口加上了函数式接口的定义注解：<code>@FunctionalInterface</code>，表明该接口是一个函数式接口。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface FunctionalInterface &#123;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<p>在JDK8中，除了Runnbale接口，还有像Comparator、Callable等接口都加上了该注解定义为函数式接口。</p>\n<h2 id=\"内置函数式接口\"><a href=\"#内置函数式接口\" class=\"headerlink\" title=\"内置函数式接口\"></a>内置函数式接口</h2><p>JDK8提供了几个内置的函数式接口，用在了许多API的地方，都可以拿来用，可以满足大部分应用。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;Consumer&lt;T&gt; - T作为输入，执行某种动作但没有返回值\nConsumer&lt;String&gt; con &#x3D; (x) -&gt; &#123;\n\tSystem.out.println(x);\n&#125;;\ncon.accept(&quot;hello world&quot;);\n\n&#x2F;&#x2F;Supplier&lt;T&gt; - 没有任何输入，返回T\nSupplier&lt;String&gt; supp &#x3D; () -&gt; &#123;\n\treturn &quot;Supplier&quot;;\n&#125;;\nSystem.out.println(supp.get());\n\n&#x2F;&#x2F;Predicate&lt;T&gt; -T作为输入，返回的boolean值作为输出\nPredicate&lt;String&gt; pre &#x3D; (x) -&gt; &#123;\n\tSystem.out.print(x);\n\treturn x.startsWith(&quot;op&quot;);\n&#125;;\nSystem.out.println(&quot;: &quot; + pre.test(&quot;op, hello World&quot;));\n\n&#x2F;&#x2F; Function&lt;T, R&gt; -T作为输入，返回的R作为输出\nFunction&lt;String, String&gt; function &#x3D; (x) -&gt; &#123;\n\tSystem.out.print(x + &quot;: &quot;);\n\treturn &quot;Function&quot;;\n&#125;;\nSystem.out.println(function.apply(&quot;hello world&quot;));\n\n&#x2F;&#x2F;BinaryOperator&lt;T&gt; -两个T作为输入，返回一个T作为输出，对于“reduce”操作很有用\nBinaryOperator&lt;String&gt; bina &#x3D; (x, y) -&gt; &#123;\n\tSystem.out.print(x + &quot; &quot; + y);\n\treturn &quot;BinaryOperator&quot;;\n&#125;;\nSystem.out.println(&quot;  &quot; + bina.apply(&quot;hello &quot;, &quot;world&quot;));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"自定义函数式接口\"><a href=\"#自定义函数式接口\" class=\"headerlink\" title=\"自定义函数式接口\"></a>自定义函数式接口</h2><h4 id=\"1、自定义一个函数式接口\"><a href=\"#1、自定义一个函数式接口\" class=\"headerlink\" title=\"1、自定义一个函数式接口\"></a>1、自定义一个函数式接口</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">@FunctionalInterface\npublic interface CalcInterface&lt;N, V&gt; &#123;\t\n\tV operation(N n1, N n2);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里只有一个抽象方法，@FunctionalInterface注解可以不用写，至于为什么可以往下看。</p>\n<h4 id=\"2、新建一个引用函数式接口的类\"><a href=\"#2、新建一个引用函数式接口的类\" class=\"headerlink\" title=\"2、新建一个引用函数式接口的类\"></a>2、新建一个引用函数式接口的类</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">public static class NumberOperation&lt;N extends Number, V extends Number&gt; &#123;\n\n\tprivate N n1;\n\tprivate N n2;\n\n\tpublic NumberOperation(N n1, N n2) &#123;\n\t\tthis.n1 &#x3D; n1;\n\t\tthis.n2 &#x3D; n2;\n\t&#125;\n\n\tpublic V calc(CalcInterface&lt;N, V&gt; ci) &#123;\n\t\tV v &#x3D; ci.operation(n1, n2);\n\t\treturn v;\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"3、测试函数式接口\"><a href=\"#3、测试函数式接口\" class=\"headerlink\" title=\"3、测试函数式接口\"></a>3、测试函数式接口</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testOperationFnInterface() &#123;\n        NumberOperation&lt;Integer, Integer&gt; np &#x3D; new NumberOperation(13, 10);\n    \n\tCalcInterface&lt;Integer, Integer&gt; addOper1 &#x3D; (n1, n2) -&gt; &#123;\n\t\treturn n1 + n2;\n\t&#125;;\n\tCalcInterface&lt;Integer, Integer&gt; multiOper1 &#x3D; (n1, n2) -&gt; &#123;\n\t\treturn n1 * n2;\n\t&#125;;\n\tSystem.out.println(np.calc1(addOper1));\n\tSystem.out.println(np.calc1(multiOper1));\n\t\n\t&#x2F;&#x2F; 上面的可以简写为\n\tSystem.out.println(np.calc1((n1, n2) -&gt; n1 + n2));\n\tSystem.out.println(np.calc1((n1, n2) -&gt; n1 * n2));\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>最后输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">23\n130\n23\n130<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"函数式接口规范\"><a href=\"#函数式接口规范\" class=\"headerlink\" title=\"函数式接口规范\"></a>函数式接口规范</h2><p>1、@FunctionalInterface标识为一个函数式接口只能用在只有一个抽象方法的接口上。</p>\n<p>2、接口中的静态方法、默认方法、覆盖了Object类的方法都不算抽象方法。</p>\n<p>3、@FunctionalInterface注解不是必须的，如果该接口只有一个抽象方法可以不写，它默认就符合函数式接口，但建议都写上该注解，编译器会检查该接口是否符合函数式接口的规范。</p>\n<h2 id=\"举例说明\"><a href=\"#举例说明\" class=\"headerlink\" title=\"举例说明\"></a>举例说明</h2><p>正确的函数式接口。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@FunctionalInterface\npublic interface CalcInterface&lt;N, V&gt; &#123;\t\n\tV operation(N n1, N n2);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>加了几个符合函数式的方法也没事，编译器也不会报错。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@FunctionalInterface\npublic interface CalcInterface&lt;N, V&gt; &#123;\t\t\n\n\tV operation(N n1, N n2);\n   \n\tpublic boolean equals(Object object);\n\n\tpublic default void defaultMethod() &#123;\n\n\t&#125;\n\n\tpublic static void staticMethod() &#123;\n\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个没用@FunctionalInterface函数式接口，有两个抽象方法，不能用于Lambda表达式。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface CalcInterface&lt;N, V&gt; &#123;\t\n\tV operation(N n1, N n2);\n\tV operation2(N n1, N n2);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个有两个抽象方法的用@FunctionalInterface注解的函数式接口编译会报错。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@FunctionalInterface\npublic interface CalcInterface&lt;N, V&gt; &#123;\t\n\tV operation(N n1, N n2);\n\tV operation2(N n1, N n2);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个没有一个抽象方法，编译报错。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface CalcInterface&lt;N, V&gt; &#123;\t\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n","excerpt":"","more":"<h2 id=\"什么是函数式接口\"><a href=\"#什么是函数式接口\" class=\"headerlink\" title=\"什么是函数式接口\"></a>什么是函数式接口</h2><p>先来看看传统的创建线程是怎么写的</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Thread t1 &#x3D; new Thread(new Runnable() &#123;\n\t@Override\n\tpublic void run() &#123;\n\t\tSystem.out.println(&quot;t1&quot;);\n\t&#125;\n&#125;);\nt1.start();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>再来看看使用了函数式接口是怎么写的</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Thread t2 &#x3D; new Thread(() -&gt; System.out.println(&quot;t2&quot;));\nt2.start();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>Runnable接口直接可以使用Lambda表达式来编写，这是因为Runnable接口是一个函数式接口，来看看Runnable的源码。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@FunctionalInterface\npublic interface Runnable &#123;\n\n    public abstract void run();\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>发现该接口加上了函数式接口的定义注解：<code>@FunctionalInterface</code>，表明该接口是一个函数式接口。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface FunctionalInterface &#123;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<p>在JDK8中，除了Runnbale接口，还有像Comparator、Callable等接口都加上了该注解定义为函数式接口。</p>\n<h2 id=\"内置函数式接口\"><a href=\"#内置函数式接口\" class=\"headerlink\" title=\"内置函数式接口\"></a>内置函数式接口</h2><p>JDK8提供了几个内置的函数式接口，用在了许多API的地方，都可以拿来用，可以满足大部分应用。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;Consumer&lt;T&gt; - T作为输入，执行某种动作但没有返回值\nConsumer&lt;String&gt; con &#x3D; (x) -&gt; &#123;\n\tSystem.out.println(x);\n&#125;;\ncon.accept(&quot;hello world&quot;);\n\n&#x2F;&#x2F;Supplier&lt;T&gt; - 没有任何输入，返回T\nSupplier&lt;String&gt; supp &#x3D; () -&gt; &#123;\n\treturn &quot;Supplier&quot;;\n&#125;;\nSystem.out.println(supp.get());\n\n&#x2F;&#x2F;Predicate&lt;T&gt; -T作为输入，返回的boolean值作为输出\nPredicate&lt;String&gt; pre &#x3D; (x) -&gt; &#123;\n\tSystem.out.print(x);\n\treturn x.startsWith(&quot;op&quot;);\n&#125;;\nSystem.out.println(&quot;: &quot; + pre.test(&quot;op, hello World&quot;));\n\n&#x2F;&#x2F; Function&lt;T, R&gt; -T作为输入，返回的R作为输出\nFunction&lt;String, String&gt; function &#x3D; (x) -&gt; &#123;\n\tSystem.out.print(x + &quot;: &quot;);\n\treturn &quot;Function&quot;;\n&#125;;\nSystem.out.println(function.apply(&quot;hello world&quot;));\n\n&#x2F;&#x2F;BinaryOperator&lt;T&gt; -两个T作为输入，返回一个T作为输出，对于“reduce”操作很有用\nBinaryOperator&lt;String&gt; bina &#x3D; (x, y) -&gt; &#123;\n\tSystem.out.print(x + &quot; &quot; + y);\n\treturn &quot;BinaryOperator&quot;;\n&#125;;\nSystem.out.println(&quot;  &quot; + bina.apply(&quot;hello &quot;, &quot;world&quot;));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"自定义函数式接口\"><a href=\"#自定义函数式接口\" class=\"headerlink\" title=\"自定义函数式接口\"></a>自定义函数式接口</h2><h4 id=\"1、自定义一个函数式接口\"><a href=\"#1、自定义一个函数式接口\" class=\"headerlink\" title=\"1、自定义一个函数式接口\"></a>1、自定义一个函数式接口</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">@FunctionalInterface\npublic interface CalcInterface&lt;N, V&gt; &#123;\t\n\tV operation(N n1, N n2);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里只有一个抽象方法，@FunctionalInterface注解可以不用写，至于为什么可以往下看。</p>\n<h4 id=\"2、新建一个引用函数式接口的类\"><a href=\"#2、新建一个引用函数式接口的类\" class=\"headerlink\" title=\"2、新建一个引用函数式接口的类\"></a>2、新建一个引用函数式接口的类</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">public static class NumberOperation&lt;N extends Number, V extends Number&gt; &#123;\n\n\tprivate N n1;\n\tprivate N n2;\n\n\tpublic NumberOperation(N n1, N n2) &#123;\n\t\tthis.n1 &#x3D; n1;\n\t\tthis.n2 &#x3D; n2;\n\t&#125;\n\n\tpublic V calc(CalcInterface&lt;N, V&gt; ci) &#123;\n\t\tV v &#x3D; ci.operation(n1, n2);\n\t\treturn v;\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"3、测试函数式接口\"><a href=\"#3、测试函数式接口\" class=\"headerlink\" title=\"3、测试函数式接口\"></a>3、测试函数式接口</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testOperationFnInterface() &#123;\n        NumberOperation&lt;Integer, Integer&gt; np &#x3D; new NumberOperation(13, 10);\n    \n\tCalcInterface&lt;Integer, Integer&gt; addOper1 &#x3D; (n1, n2) -&gt; &#123;\n\t\treturn n1 + n2;\n\t&#125;;\n\tCalcInterface&lt;Integer, Integer&gt; multiOper1 &#x3D; (n1, n2) -&gt; &#123;\n\t\treturn n1 * n2;\n\t&#125;;\n\tSystem.out.println(np.calc1(addOper1));\n\tSystem.out.println(np.calc1(multiOper1));\n\t\n\t&#x2F;&#x2F; 上面的可以简写为\n\tSystem.out.println(np.calc1((n1, n2) -&gt; n1 + n2));\n\tSystem.out.println(np.calc1((n1, n2) -&gt; n1 * n2));\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>最后输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">23\n130\n23\n130<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"函数式接口规范\"><a href=\"#函数式接口规范\" class=\"headerlink\" title=\"函数式接口规范\"></a>函数式接口规范</h2><p>1、@FunctionalInterface标识为一个函数式接口只能用在只有一个抽象方法的接口上。</p>\n<p>2、接口中的静态方法、默认方法、覆盖了Object类的方法都不算抽象方法。</p>\n<p>3、@FunctionalInterface注解不是必须的，如果该接口只有一个抽象方法可以不写，它默认就符合函数式接口，但建议都写上该注解，编译器会检查该接口是否符合函数式接口的规范。</p>\n<h2 id=\"举例说明\"><a href=\"#举例说明\" class=\"headerlink\" title=\"举例说明\"></a>举例说明</h2><p>正确的函数式接口。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@FunctionalInterface\npublic interface CalcInterface&lt;N, V&gt; &#123;\t\n\tV operation(N n1, N n2);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>加了几个符合函数式的方法也没事，编译器也不会报错。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@FunctionalInterface\npublic interface CalcInterface&lt;N, V&gt; &#123;\t\t\n\n\tV operation(N n1, N n2);\n   \n\tpublic boolean equals(Object object);\n\n\tpublic default void defaultMethod() &#123;\n\n\t&#125;\n\n\tpublic static void staticMethod() &#123;\n\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个没用@FunctionalInterface函数式接口，有两个抽象方法，不能用于Lambda表达式。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface CalcInterface&lt;N, V&gt; &#123;\t\n\tV operation(N n1, N n2);\n\tV operation2(N n1, N n2);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个有两个抽象方法的用@FunctionalInterface注解的函数式接口编译会报错。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@FunctionalInterface\npublic interface CalcInterface&lt;N, V&gt; &#123;\t\n\tV operation(N n1, N n2);\n\tV operation2(N n1, N n2);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个没有一个抽象方法，编译报错。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface CalcInterface&lt;N, V&gt; &#123;\t\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n"},{"title":"Java8 新特性之方法引用","date":"2025-10-15T03:36:33.000Z","_content":"\n## 什么是方法引用\n\n方法引用是只需要使用方法的名字，而具体调用交给函数式接口，需要和Lambda表达式配合使用。\n\n如：\n\n\n```\nList<String> list = Arrays.asList(\"a\",\"b\",\"c\");\nlist.forEach(str -> System.out.print(str));\nlist.forEach(System.out::print);\n```\n\n上面两种写法是等价的。\n\n\n## 方法引用分类\n\n### 1、构造器方法引用\n\n格式：`Class::new`，调用默认构造器。\n\n### 2、类静态方法引用\n\n格式：`Class::static_method`\n\n### 3、类普通方法引用\n\n格式：`Class::method`，方法不能带参数。\n\n### 4、实例方法引用\n\n格式：`instance::method`\n\n## 示例\n\n往User类添加方法引用方法：\n\n\n```\npublic static User create(Supplier<User> supplier){\n\treturn supplier.get();\n}\n\npublic static void updateUsername(User user){\n\tuser.setUsername(user.getUsername() + \" updated.\");\n}\n\npublic void updateAge(){\n\tthis.setAge(this.getAge() + 10);\n}\n\npublic void changeAge(User user){\n\tuser.setAge(user.getAge() + 10);\n}\n```\n\n方法引用测试：\n\n```\npublic static void main(String[] args) {\n\tList<User> list = initList();\n\n\t// 1、构造器方法引用\n\tUser newUser = User.create(User::new);\n\tnewUser.setAge(1);\n\tnewUser.setUsername(\"new\");\n\tSystem.out.println(newUser);\n\n\t// 2、类静态方法引用\n\tlist.forEach(User::updateUsername);\n\n\t// 3、类普通方法引用\n\tlist.forEach(User::updateAge);\n\n\t// 4、实例方法引用\n\tUser user = new User();\n\tlist.forEach(user::changeAge);\n\n\tlist.forEach(System.out::println);\n}\n\nprivate static List<User> initList() {\n\tList<User> list = new ArrayList<>();\n\tlist.add(new User(\"oaby\", 23));\n\tlist.add(new User(\"tom\", 11));\n\tlist.add(new User(\"john\", 16));\n\tlist.add(new User(\"jennis\", 26));\n\tlist.add(new User(\"tin\", 26));\n\tlist.add(new User(\"army\", 26));\n\tlist.add(new User(\"mack\", 19));\n\tlist.add(new User(\"jobs\", 65));\n\tlist.add(new User(\"jordan\", 23));\n\treturn list;\n}\n```\n输出结果：\n\n```\nUser [username=new, age=1]\nUser [username=oaby updated., age=43]\nUser [username=tom updated., age=31]\nUser [username=john updated., age=36]\nUser [username=jennis updated., age=46]\nUser [username=tin updated., age=46]\nUser [username=army updated., age=46]\nUser [username=mack updated., age=39]\nUser [username=jobs updated., age=85]\nUser [username=jordan updated., age=43]\n```\n\n可以看出方法引用都生效了，username和age都相应更新了。\n","source":"_posts/新特性/Java8/Java8 新特性之方法引用.md","raw":"---\ntitle: Java8 新特性之方法引用\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n\n## 什么是方法引用\n\n方法引用是只需要使用方法的名字，而具体调用交给函数式接口，需要和Lambda表达式配合使用。\n\n如：\n\n\n```\nList<String> list = Arrays.asList(\"a\",\"b\",\"c\");\nlist.forEach(str -> System.out.print(str));\nlist.forEach(System.out::print);\n```\n\n上面两种写法是等价的。\n\n\n## 方法引用分类\n\n### 1、构造器方法引用\n\n格式：`Class::new`，调用默认构造器。\n\n### 2、类静态方法引用\n\n格式：`Class::static_method`\n\n### 3、类普通方法引用\n\n格式：`Class::method`，方法不能带参数。\n\n### 4、实例方法引用\n\n格式：`instance::method`\n\n## 示例\n\n往User类添加方法引用方法：\n\n\n```\npublic static User create(Supplier<User> supplier){\n\treturn supplier.get();\n}\n\npublic static void updateUsername(User user){\n\tuser.setUsername(user.getUsername() + \" updated.\");\n}\n\npublic void updateAge(){\n\tthis.setAge(this.getAge() + 10);\n}\n\npublic void changeAge(User user){\n\tuser.setAge(user.getAge() + 10);\n}\n```\n\n方法引用测试：\n\n```\npublic static void main(String[] args) {\n\tList<User> list = initList();\n\n\t// 1、构造器方法引用\n\tUser newUser = User.create(User::new);\n\tnewUser.setAge(1);\n\tnewUser.setUsername(\"new\");\n\tSystem.out.println(newUser);\n\n\t// 2、类静态方法引用\n\tlist.forEach(User::updateUsername);\n\n\t// 3、类普通方法引用\n\tlist.forEach(User::updateAge);\n\n\t// 4、实例方法引用\n\tUser user = new User();\n\tlist.forEach(user::changeAge);\n\n\tlist.forEach(System.out::println);\n}\n\nprivate static List<User> initList() {\n\tList<User> list = new ArrayList<>();\n\tlist.add(new User(\"oaby\", 23));\n\tlist.add(new User(\"tom\", 11));\n\tlist.add(new User(\"john\", 16));\n\tlist.add(new User(\"jennis\", 26));\n\tlist.add(new User(\"tin\", 26));\n\tlist.add(new User(\"army\", 26));\n\tlist.add(new User(\"mack\", 19));\n\tlist.add(new User(\"jobs\", 65));\n\tlist.add(new User(\"jordan\", 23));\n\treturn list;\n}\n```\n输出结果：\n\n```\nUser [username=new, age=1]\nUser [username=oaby updated., age=43]\nUser [username=tom updated., age=31]\nUser [username=john updated., age=36]\nUser [username=jennis updated., age=46]\nUser [username=tin updated., age=46]\nUser [username=army updated., age=46]\nUser [username=mack updated., age=39]\nUser [username=jobs updated., age=85]\nUser [username=jordan updated., age=43]\n```\n\n可以看出方法引用都生效了，username和age都相应更新了。\n","slug":"新特性/Java8/Java8 新特性之方法引用","published":1,"updated":"2025-10-15T07:20:51.389Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu0776005uqkd4b4172lae","content":"<h2 id=\"什么是方法引用\"><a href=\"#什么是方法引用\" class=\"headerlink\" title=\"什么是方法引用\"></a>什么是方法引用</h2><p>方法引用是只需要使用方法的名字，而具体调用交给函数式接口，需要和Lambda表达式配合使用。</p>\n<p>如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; list &#x3D; Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);\nlist.forEach(str -&gt; System.out.print(str));\nlist.forEach(System.out::print);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>上面两种写法是等价的。</p>\n<h2 id=\"方法引用分类\"><a href=\"#方法引用分类\" class=\"headerlink\" title=\"方法引用分类\"></a>方法引用分类</h2><h3 id=\"1、构造器方法引用\"><a href=\"#1、构造器方法引用\" class=\"headerlink\" title=\"1、构造器方法引用\"></a>1、构造器方法引用</h3><p>格式：<code>Class::new</code>，调用默认构造器。</p>\n<h3 id=\"2、类静态方法引用\"><a href=\"#2、类静态方法引用\" class=\"headerlink\" title=\"2、类静态方法引用\"></a>2、类静态方法引用</h3><p>格式：<code>Class::static_method</code></p>\n<h3 id=\"3、类普通方法引用\"><a href=\"#3、类普通方法引用\" class=\"headerlink\" title=\"3、类普通方法引用\"></a>3、类普通方法引用</h3><p>格式：<code>Class::method</code>，方法不能带参数。</p>\n<h3 id=\"4、实例方法引用\"><a href=\"#4、实例方法引用\" class=\"headerlink\" title=\"4、实例方法引用\"></a>4、实例方法引用</h3><p>格式：<code>instance::method</code></p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>往User类添加方法引用方法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static User create(Supplier&lt;User&gt; supplier)&#123;\n\treturn supplier.get();\n&#125;\n\npublic static void updateUsername(User user)&#123;\n\tuser.setUsername(user.getUsername() + &quot; updated.&quot;);\n&#125;\n\npublic void updateAge()&#123;\n\tthis.setAge(this.getAge() + 10);\n&#125;\n\npublic void changeAge(User user)&#123;\n\tuser.setAge(user.getAge() + 10);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>方法引用测试：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n\tList&lt;User&gt; list &#x3D; initList();\n\n\t&#x2F;&#x2F; 1、构造器方法引用\n\tUser newUser &#x3D; User.create(User::new);\n\tnewUser.setAge(1);\n\tnewUser.setUsername(&quot;new&quot;);\n\tSystem.out.println(newUser);\n\n\t&#x2F;&#x2F; 2、类静态方法引用\n\tlist.forEach(User::updateUsername);\n\n\t&#x2F;&#x2F; 3、类普通方法引用\n\tlist.forEach(User::updateAge);\n\n\t&#x2F;&#x2F; 4、实例方法引用\n\tUser user &#x3D; new User();\n\tlist.forEach(user::changeAge);\n\n\tlist.forEach(System.out::println);\n&#125;\n\nprivate static List&lt;User&gt; initList() &#123;\n\tList&lt;User&gt; list &#x3D; new ArrayList&lt;&gt;();\n\tlist.add(new User(&quot;oaby&quot;, 23));\n\tlist.add(new User(&quot;tom&quot;, 11));\n\tlist.add(new User(&quot;john&quot;, 16));\n\tlist.add(new User(&quot;jennis&quot;, 26));\n\tlist.add(new User(&quot;tin&quot;, 26));\n\tlist.add(new User(&quot;army&quot;, 26));\n\tlist.add(new User(&quot;mack&quot;, 19));\n\tlist.add(new User(&quot;jobs&quot;, 65));\n\tlist.add(new User(&quot;jordan&quot;, 23));\n\treturn list;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>输出结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">User [username&#x3D;new, age&#x3D;1]\nUser [username&#x3D;oaby updated., age&#x3D;43]\nUser [username&#x3D;tom updated., age&#x3D;31]\nUser [username&#x3D;john updated., age&#x3D;36]\nUser [username&#x3D;jennis updated., age&#x3D;46]\nUser [username&#x3D;tin updated., age&#x3D;46]\nUser [username&#x3D;army updated., age&#x3D;46]\nUser [username&#x3D;mack updated., age&#x3D;39]\nUser [username&#x3D;jobs updated., age&#x3D;85]\nUser [username&#x3D;jordan updated., age&#x3D;43]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出方法引用都生效了，username和age都相应更新了。</p>\n","excerpt":"","more":"<h2 id=\"什么是方法引用\"><a href=\"#什么是方法引用\" class=\"headerlink\" title=\"什么是方法引用\"></a>什么是方法引用</h2><p>方法引用是只需要使用方法的名字，而具体调用交给函数式接口，需要和Lambda表达式配合使用。</p>\n<p>如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; list &#x3D; Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);\nlist.forEach(str -&gt; System.out.print(str));\nlist.forEach(System.out::print);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>上面两种写法是等价的。</p>\n<h2 id=\"方法引用分类\"><a href=\"#方法引用分类\" class=\"headerlink\" title=\"方法引用分类\"></a>方法引用分类</h2><h3 id=\"1、构造器方法引用\"><a href=\"#1、构造器方法引用\" class=\"headerlink\" title=\"1、构造器方法引用\"></a>1、构造器方法引用</h3><p>格式：<code>Class::new</code>，调用默认构造器。</p>\n<h3 id=\"2、类静态方法引用\"><a href=\"#2、类静态方法引用\" class=\"headerlink\" title=\"2、类静态方法引用\"></a>2、类静态方法引用</h3><p>格式：<code>Class::static_method</code></p>\n<h3 id=\"3、类普通方法引用\"><a href=\"#3、类普通方法引用\" class=\"headerlink\" title=\"3、类普通方法引用\"></a>3、类普通方法引用</h3><p>格式：<code>Class::method</code>，方法不能带参数。</p>\n<h3 id=\"4、实例方法引用\"><a href=\"#4、实例方法引用\" class=\"headerlink\" title=\"4、实例方法引用\"></a>4、实例方法引用</h3><p>格式：<code>instance::method</code></p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>往User类添加方法引用方法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static User create(Supplier&lt;User&gt; supplier)&#123;\n\treturn supplier.get();\n&#125;\n\npublic static void updateUsername(User user)&#123;\n\tuser.setUsername(user.getUsername() + &quot; updated.&quot;);\n&#125;\n\npublic void updateAge()&#123;\n\tthis.setAge(this.getAge() + 10);\n&#125;\n\npublic void changeAge(User user)&#123;\n\tuser.setAge(user.getAge() + 10);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>方法引用测试：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n\tList&lt;User&gt; list &#x3D; initList();\n\n\t&#x2F;&#x2F; 1、构造器方法引用\n\tUser newUser &#x3D; User.create(User::new);\n\tnewUser.setAge(1);\n\tnewUser.setUsername(&quot;new&quot;);\n\tSystem.out.println(newUser);\n\n\t&#x2F;&#x2F; 2、类静态方法引用\n\tlist.forEach(User::updateUsername);\n\n\t&#x2F;&#x2F; 3、类普通方法引用\n\tlist.forEach(User::updateAge);\n\n\t&#x2F;&#x2F; 4、实例方法引用\n\tUser user &#x3D; new User();\n\tlist.forEach(user::changeAge);\n\n\tlist.forEach(System.out::println);\n&#125;\n\nprivate static List&lt;User&gt; initList() &#123;\n\tList&lt;User&gt; list &#x3D; new ArrayList&lt;&gt;();\n\tlist.add(new User(&quot;oaby&quot;, 23));\n\tlist.add(new User(&quot;tom&quot;, 11));\n\tlist.add(new User(&quot;john&quot;, 16));\n\tlist.add(new User(&quot;jennis&quot;, 26));\n\tlist.add(new User(&quot;tin&quot;, 26));\n\tlist.add(new User(&quot;army&quot;, 26));\n\tlist.add(new User(&quot;mack&quot;, 19));\n\tlist.add(new User(&quot;jobs&quot;, 65));\n\tlist.add(new User(&quot;jordan&quot;, 23));\n\treturn list;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>输出结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">User [username&#x3D;new, age&#x3D;1]\nUser [username&#x3D;oaby updated., age&#x3D;43]\nUser [username&#x3D;tom updated., age&#x3D;31]\nUser [username&#x3D;john updated., age&#x3D;36]\nUser [username&#x3D;jennis updated., age&#x3D;46]\nUser [username&#x3D;tin updated., age&#x3D;46]\nUser [username&#x3D;army updated., age&#x3D;46]\nUser [username&#x3D;mack updated., age&#x3D;39]\nUser [username&#x3D;jobs updated., age&#x3D;85]\nUser [username&#x3D;jordan updated., age&#x3D;43]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出方法引用都生效了，username和age都相应更新了。</p>\n"},{"title":"Java8 新特性之接口默认方法与静态方法","date":"2025-10-15T03:36:33.000Z","_content":"\n## 接口默认方法与静态方法\n\n有这样一些场景，如果一个接口要添加一个方法，那所有的接口实现类都要去实现，而某些实现类根本就不需要实现这个方法也要写一个空实现，所以接口默认方法就是为了解决这个问题。\n\n接口静态方法类似于默认方法，但是我们不能在实现类中覆盖它们，可以避免默认方法在实现类中被覆盖实现。\n\n之前讲过的JDK8的list.foreache方法，看下源码，其实也是java.lang.Iterable接口的默认方法。\n\n```\ndefault void forEach(Consumer<? super T> action) {\n    Objects.requireNonNull(action);\n    for (T t : this) {\n        action.accept(t);\n    }\n}\n```\n\n## 简单的例子\n\n默认方法以`default`修饰，静态方法用`static`。\n\n```\npublic static void main(String[] args) {\n\tIUserInterface userInterface = new UserServiceImpl();\n\tSystem.out.println(userInterface.getDefaultUser1());\n\tSystem.out.println(IUserInterface.getDefaultUser2());\n}\n\ninterface IUserInterface {\n\n\tdefault User getDefaultUser1() {\n\t\treturn new User(\"Susan1\", 11);\n\t}\n\n\tstatic User getDefaultUser2() {\n\t\treturn new User(\"Susan2\", 22);\n\t}\n\n}\n\nstatic class UserServiceImpl implements IUserInterface {\n\n}\n```\n\n## 注意要点\n\n1、接口默认方法、静态方法可以有多个。\n\n2、默认方法通过实例调用，静态方法通过接口名调用。\n\n3、`default`默认方法关键字只能用在接口中。\n\n4、默认方法可以被继承，如果继承了多个接口，多个接口都定义了多个同样的默认方法，实现类需要重写默认方法不然会报错。\n\n5、静态方法不能被继承及覆盖，所以只被具体所在的接口调用。\n\n\n\n\n\n","source":"_posts/新特性/Java8/Java8 新特性之接口默认方法与静态方法.md","raw":"---\ntitle: Java8 新特性之接口默认方法与静态方法\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n\n## 接口默认方法与静态方法\n\n有这样一些场景，如果一个接口要添加一个方法，那所有的接口实现类都要去实现，而某些实现类根本就不需要实现这个方法也要写一个空实现，所以接口默认方法就是为了解决这个问题。\n\n接口静态方法类似于默认方法，但是我们不能在实现类中覆盖它们，可以避免默认方法在实现类中被覆盖实现。\n\n之前讲过的JDK8的list.foreache方法，看下源码，其实也是java.lang.Iterable接口的默认方法。\n\n```\ndefault void forEach(Consumer<? super T> action) {\n    Objects.requireNonNull(action);\n    for (T t : this) {\n        action.accept(t);\n    }\n}\n```\n\n## 简单的例子\n\n默认方法以`default`修饰，静态方法用`static`。\n\n```\npublic static void main(String[] args) {\n\tIUserInterface userInterface = new UserServiceImpl();\n\tSystem.out.println(userInterface.getDefaultUser1());\n\tSystem.out.println(IUserInterface.getDefaultUser2());\n}\n\ninterface IUserInterface {\n\n\tdefault User getDefaultUser1() {\n\t\treturn new User(\"Susan1\", 11);\n\t}\n\n\tstatic User getDefaultUser2() {\n\t\treturn new User(\"Susan2\", 22);\n\t}\n\n}\n\nstatic class UserServiceImpl implements IUserInterface {\n\n}\n```\n\n## 注意要点\n\n1、接口默认方法、静态方法可以有多个。\n\n2、默认方法通过实例调用，静态方法通过接口名调用。\n\n3、`default`默认方法关键字只能用在接口中。\n\n4、默认方法可以被继承，如果继承了多个接口，多个接口都定义了多个同样的默认方法，实现类需要重写默认方法不然会报错。\n\n5、静态方法不能被继承及覆盖，所以只被具体所在的接口调用。\n\n\n\n\n\n","slug":"新特性/Java8/Java8 新特性之接口默认方法与静态方法","published":1,"updated":"2025-10-15T07:20:51.412Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu0776005xqkd415qc4dkv","content":"<h2 id=\"接口默认方法与静态方法\"><a href=\"#接口默认方法与静态方法\" class=\"headerlink\" title=\"接口默认方法与静态方法\"></a>接口默认方法与静态方法</h2><p>有这样一些场景，如果一个接口要添加一个方法，那所有的接口实现类都要去实现，而某些实现类根本就不需要实现这个方法也要写一个空实现，所以接口默认方法就是为了解决这个问题。</p>\n<p>接口静态方法类似于默认方法，但是我们不能在实现类中覆盖它们，可以避免默认方法在实现类中被覆盖实现。</p>\n<p>之前讲过的JDK8的list.foreache方法，看下源码，其实也是java.lang.Iterable接口的默认方法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">default void forEach(Consumer&lt;? super T&gt; action) &#123;\n    Objects.requireNonNull(action);\n    for (T t : this) &#123;\n        action.accept(t);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h2><p>默认方法以<code>default</code>修饰，静态方法用<code>static</code>。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n\tIUserInterface userInterface &#x3D; new UserServiceImpl();\n\tSystem.out.println(userInterface.getDefaultUser1());\n\tSystem.out.println(IUserInterface.getDefaultUser2());\n&#125;\n\ninterface IUserInterface &#123;\n\n\tdefault User getDefaultUser1() &#123;\n\t\treturn new User(&quot;Susan1&quot;, 11);\n\t&#125;\n\n\tstatic User getDefaultUser2() &#123;\n\t\treturn new User(&quot;Susan2&quot;, 22);\n\t&#125;\n\n&#125;\n\nstatic class UserServiceImpl implements IUserInterface &#123;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"注意要点\"><a href=\"#注意要点\" class=\"headerlink\" title=\"注意要点\"></a>注意要点</h2><p>1、接口默认方法、静态方法可以有多个。</p>\n<p>2、默认方法通过实例调用，静态方法通过接口名调用。</p>\n<p>3、<code>default</code>默认方法关键字只能用在接口中。</p>\n<p>4、默认方法可以被继承，如果继承了多个接口，多个接口都定义了多个同样的默认方法，实现类需要重写默认方法不然会报错。</p>\n<p>5、静态方法不能被继承及覆盖，所以只被具体所在的接口调用。</p>\n","excerpt":"","more":"<h2 id=\"接口默认方法与静态方法\"><a href=\"#接口默认方法与静态方法\" class=\"headerlink\" title=\"接口默认方法与静态方法\"></a>接口默认方法与静态方法</h2><p>有这样一些场景，如果一个接口要添加一个方法，那所有的接口实现类都要去实现，而某些实现类根本就不需要实现这个方法也要写一个空实现，所以接口默认方法就是为了解决这个问题。</p>\n<p>接口静态方法类似于默认方法，但是我们不能在实现类中覆盖它们，可以避免默认方法在实现类中被覆盖实现。</p>\n<p>之前讲过的JDK8的list.foreache方法，看下源码，其实也是java.lang.Iterable接口的默认方法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">default void forEach(Consumer&lt;? super T&gt; action) &#123;\n    Objects.requireNonNull(action);\n    for (T t : this) &#123;\n        action.accept(t);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h2><p>默认方法以<code>default</code>修饰，静态方法用<code>static</code>。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n\tIUserInterface userInterface &#x3D; new UserServiceImpl();\n\tSystem.out.println(userInterface.getDefaultUser1());\n\tSystem.out.println(IUserInterface.getDefaultUser2());\n&#125;\n\ninterface IUserInterface &#123;\n\n\tdefault User getDefaultUser1() &#123;\n\t\treturn new User(&quot;Susan1&quot;, 11);\n\t&#125;\n\n\tstatic User getDefaultUser2() &#123;\n\t\treturn new User(&quot;Susan2&quot;, 22);\n\t&#125;\n\n&#125;\n\nstatic class UserServiceImpl implements IUserInterface &#123;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"注意要点\"><a href=\"#注意要点\" class=\"headerlink\" title=\"注意要点\"></a>注意要点</h2><p>1、接口默认方法、静态方法可以有多个。</p>\n<p>2、默认方法通过实例调用，静态方法通过接口名调用。</p>\n<p>3、<code>default</code>默认方法关键字只能用在接口中。</p>\n<p>4、默认方法可以被继承，如果继承了多个接口，多个接口都定义了多个同样的默认方法，实现类需要重写默认方法不然会报错。</p>\n<p>5、静态方法不能被继承及覆盖，所以只被具体所在的接口调用。</p>\n"},{"title":"Java8 新特性之重复注解","date":"2025-10-15T03:36:33.000Z","_content":"\n## 什么是重复注解\n\n下面是JDK8中的重复注解（`java.lang.annotation.Repeatable`）定义的源码。\n\n```\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.ANNOTATION_TYPE)\npublic @interface Repeatable {\n    Class<? extends Annotation> value();\n}\n```\n\n重复注解，即一个注解可以在一个类、方法或者字段上同时使用多次，如Spring中可以使用多个扫描组件来扫描多个包的注解。\n\n```\n@ComponentScan\n@ComponentScan\npublic class Configuration{\n    \n}\n```\n\n**ComponentScan**\n\n```\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@Documented\n@Repeatable(ComponentScans.class)\npublic @interface ComponentScan {\n```\n\n**ComponentScans**\n\n```\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@Documented\n@Repeatable(ComponentScans.class)\npublic @interface ComponentScan {\n...\n```\n\n## 重复注解实现\n\n下面来演示下重复注解的实现。\n\n\n```\npublic static void main(String[] args) {\n\tfor (Token token : UserToken.class.getAnnotationsByType(Token.class)) {\n\t\tSystem.out.println(token.value());\n\t}\n}\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Tokens {\n\tToken[] value();\n}\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Repeatable(Tokens.class)\npublic @interface Token {\n\tString value();\n}\n\n@Token(\"666666\")\n@Token(\"888888\")\npublic interface UserToken {\n}\n```\n\n输出结果：\n\n```\n666666\n888888\n```\n\n","source":"_posts/新特性/Java8/Java8 新特性之重复注解.md","raw":"---\ntitle: Java8 新特性之重复注解\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n\n## 什么是重复注解\n\n下面是JDK8中的重复注解（`java.lang.annotation.Repeatable`）定义的源码。\n\n```\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.ANNOTATION_TYPE)\npublic @interface Repeatable {\n    Class<? extends Annotation> value();\n}\n```\n\n重复注解，即一个注解可以在一个类、方法或者字段上同时使用多次，如Spring中可以使用多个扫描组件来扫描多个包的注解。\n\n```\n@ComponentScan\n@ComponentScan\npublic class Configuration{\n    \n}\n```\n\n**ComponentScan**\n\n```\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@Documented\n@Repeatable(ComponentScans.class)\npublic @interface ComponentScan {\n```\n\n**ComponentScans**\n\n```\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@Documented\n@Repeatable(ComponentScans.class)\npublic @interface ComponentScan {\n...\n```\n\n## 重复注解实现\n\n下面来演示下重复注解的实现。\n\n\n```\npublic static void main(String[] args) {\n\tfor (Token token : UserToken.class.getAnnotationsByType(Token.class)) {\n\t\tSystem.out.println(token.value());\n\t}\n}\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Tokens {\n\tToken[] value();\n}\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Repeatable(Tokens.class)\npublic @interface Token {\n\tString value();\n}\n\n@Token(\"666666\")\n@Token(\"888888\")\npublic interface UserToken {\n}\n```\n\n输出结果：\n\n```\n666666\n888888\n```\n\n","slug":"新特性/Java8/Java8 新特性之重复注解","published":1,"updated":"2025-10-15T07:20:51.456Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu07770060qkd42y7u2124","content":"<h2 id=\"什么是重复注解\"><a href=\"#什么是重复注解\" class=\"headerlink\" title=\"什么是重复注解\"></a>什么是重复注解</h2><p>下面是JDK8中的重复注解（<code>java.lang.annotation.Repeatable</code>）定义的源码。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.ANNOTATION_TYPE)\npublic @interface Repeatable &#123;\n    Class&lt;? extends Annotation&gt; value();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>重复注解，即一个注解可以在一个类、方法或者字段上同时使用多次，如Spring中可以使用多个扫描组件来扫描多个包的注解。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@ComponentScan\n@ComponentScan\npublic class Configuration&#123;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>ComponentScan</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@Documented\n@Repeatable(ComponentScans.class)\npublic @interface ComponentScan &#123;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>ComponentScans</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@Documented\n@Repeatable(ComponentScans.class)\npublic @interface ComponentScan &#123;\n...<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"重复注解实现\"><a href=\"#重复注解实现\" class=\"headerlink\" title=\"重复注解实现\"></a>重复注解实现</h2><p>下面来演示下重复注解的实现。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n\tfor (Token token : UserToken.class.getAnnotationsByType(Token.class)) &#123;\n\t\tSystem.out.println(token.value());\n\t&#125;\n&#125;\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Tokens &#123;\n\tToken[] value();\n&#125;\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Repeatable(Tokens.class)\npublic @interface Token &#123;\n\tString value();\n&#125;\n\n@Token(&quot;666666&quot;)\n@Token(&quot;888888&quot;)\npublic interface UserToken &#123;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">666666\n888888<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n","excerpt":"","more":"<h2 id=\"什么是重复注解\"><a href=\"#什么是重复注解\" class=\"headerlink\" title=\"什么是重复注解\"></a>什么是重复注解</h2><p>下面是JDK8中的重复注解（<code>java.lang.annotation.Repeatable</code>）定义的源码。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.ANNOTATION_TYPE)\npublic @interface Repeatable &#123;\n    Class&lt;? extends Annotation&gt; value();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>重复注解，即一个注解可以在一个类、方法或者字段上同时使用多次，如Spring中可以使用多个扫描组件来扫描多个包的注解。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@ComponentScan\n@ComponentScan\npublic class Configuration&#123;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>ComponentScan</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@Documented\n@Repeatable(ComponentScans.class)\npublic @interface ComponentScan &#123;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>ComponentScans</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@Documented\n@Repeatable(ComponentScans.class)\npublic @interface ComponentScan &#123;\n...<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"重复注解实现\"><a href=\"#重复注解实现\" class=\"headerlink\" title=\"重复注解实现\"></a>重复注解实现</h2><p>下面来演示下重复注解的实现。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) &#123;\n\tfor (Token token : UserToken.class.getAnnotationsByType(Token.class)) &#123;\n\t\tSystem.out.println(token.value());\n\t&#125;\n&#125;\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Tokens &#123;\n\tToken[] value();\n&#125;\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Repeatable(Tokens.class)\npublic @interface Token &#123;\n\tString value();\n&#125;\n\n@Token(&quot;666666&quot;)\n@Token(&quot;888888&quot;)\npublic interface UserToken &#123;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">666666\n888888<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n"},{"title":"Java 12 骚操作， String居然还能这样玩","date":"2025-10-15T03:36:33.000Z","_content":"\nJava 13 都快要来了，12必须跟栈长学起！\n\n[Java 13 即将发布，新特性必须抢先看！](https://mp.weixin.qq.com/s/Gg6KKz7vhDRpzeMR8CG4DA)\n\n\nJava 12 已经发布数月了：[Java 12 正式发布，8大新特性！](https://mp.weixin.qq.com/s/IXOoSTq6qi4ZH63gCaKa3A)，今天我再来分享下在 Java 12 中关于 String 的三个骚操作，绝逼有用。\n\n更多关于 Java 的资讯、干货教程、以及好消息，请关注，第一时间推送。\n\n坐稳了，准备起飞！\n\n## 1、transform\n\ntransform：即字符串转换，来看下 transform 的实现源码：\n\n```\npublic <R> R transform(Function<? super String, ? extends R> f) {\n    return f.apply(this);\n}\n```\n\n传入一个函数式接口 Function，接受一个值，返回一个值，参考：[Java 8 新特性之函数式接口](https://mp.weixin.qq.com/s/nC3f17zZlXC08XNJWA-FBw)。\n\n废话少说，直接上手就是干：\n\n```\nprivate static void testTransform() {\n    System.out.println(\"======test java 12 transform======\");\n    List<String> list1 = List.of(\"Java\", \" Python\", \" C++ \");\n    List<String> list2 = new ArrayList<>();\n\n    list1.forEach(element ->\n            list2.add(element.transform(String::strip)\n                    .transform(String::toUpperCase)\n                    .transform((e) -> \"Hi,\" + e))\n    );\n\n    list2.forEach(System.out::println);\n}\n```\n\n结果输出：\n\n```\n======test java 12 transform======\nHi,JAVA\nHi,PYTHON\nHi,C++\n```\n\n示例是对一个字符串连续转换了三遍，代码很简单，大家都能领会的。\n\n## 2、indent\n\n直接看示例吧：\n\n```\nprivate static void testIndent() {\n    System.out.println(\"======test java 12 indent======\");\n    String result = \"Java\\n Python\\nC++\".indent(3);\n    System.out.println(result);\n}\n```\n\n结果输出：\n\n```\n======test java 12 indent======\n   Java\n    Python\n   C++\n```\n\n换行符 \\n 后前缩进 N 个空格，为 0 或负数不缩进。\n\n以下是 indent 的核心源码：\n\n```\nprivate String indent(int n, boolean removeBlanks) {\n    Stream<String> stream = removeBlanks ? lines(Integer.MAX_VALUE, Integer.MAX_VALUE)\n                                         : lines();\n    if (n > 0) {\n        final String spaces = \" \".repeat(n);\n        stream = stream.map(s -> spaces + s);\n    } else if (n == Integer.MIN_VALUE) {\n        stream = stream.map(s -> s.stripLeading());\n    } else if (n < 0) {\n        stream = stream.map(s -> s.substring(Math.min(-n, s.indexOfNonWhitespace())));\n    }\n    return stream.collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n}\n```\n\n其实就是调用了 lines() 方法来创建一个 Stream，然后再往前拼接指定数量的空格。\n\n参考：《[Java 11 已发布，String 还能这样玩！](https://mp.weixin.qq.com/s/OZKvkG5OhMXf4lTklZQzGQ)》这篇文章对 lines() 的介绍。\n\n## 3、describeConstable\n\n```\nprivate static void testDescribeConstable() {\n    System.out.println(\"======test java 12 describeConstable======\");\n    String name = \"Java技术\";\n    Optional<String> optional = name.describeConstable();\n    System.out.println(optional.get());\n}\n```\n\n结果输出：\n\n```\n======test java 12 describeConstable======\nJava技术\n```\n\nJava 12, String 实现了 Constable 接口：\n\n> java.lang.constant.Constable\n\n这个接口就有一个方法，源码如下：\n\n```\npublic interface Constable {\n\n    Optional<? extends ConstantDesc> describeConstable();\n    \n}\n```\n\nJava 12 String 的实现源码：\n\n```\n@Override\npublic Optional<String> describeConstable() {\n    return Optional.of(this);\n}\n```\n\n很简单，其实就是调用 Optional.of 方法返回一个 Optional 类型，Optional不懂的可以参考这篇文章：[Java 8 新特性之 Optional](https://mp.weixin.qq.com/s/uXw4eTZqLfj871FlciPh6Q)。\n\n好了，今天的分享就到这，收藏转发一下吧，多学习了解，日后必定有用！\n\n历史 Java 新特性干货分享：\n\n![](http://img.javastack.cn/20190613135450.png)\n![](http://img.javastack.cn/20190613135537.png)\n\n\n\nJava 12 新特性继续更新中……\n\n ","source":"_posts/新特性/Java12/Java 12 骚操作， String居然还能这样玩.md","raw":"---\ntitle: Java 12 骚操作， String居然还能这样玩\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n\nJava 13 都快要来了，12必须跟栈长学起！\n\n[Java 13 即将发布，新特性必须抢先看！](https://mp.weixin.qq.com/s/Gg6KKz7vhDRpzeMR8CG4DA)\n\n\nJava 12 已经发布数月了：[Java 12 正式发布，8大新特性！](https://mp.weixin.qq.com/s/IXOoSTq6qi4ZH63gCaKa3A)，今天我再来分享下在 Java 12 中关于 String 的三个骚操作，绝逼有用。\n\n更多关于 Java 的资讯、干货教程、以及好消息，请关注，第一时间推送。\n\n坐稳了，准备起飞！\n\n## 1、transform\n\ntransform：即字符串转换，来看下 transform 的实现源码：\n\n```\npublic <R> R transform(Function<? super String, ? extends R> f) {\n    return f.apply(this);\n}\n```\n\n传入一个函数式接口 Function，接受一个值，返回一个值，参考：[Java 8 新特性之函数式接口](https://mp.weixin.qq.com/s/nC3f17zZlXC08XNJWA-FBw)。\n\n废话少说，直接上手就是干：\n\n```\nprivate static void testTransform() {\n    System.out.println(\"======test java 12 transform======\");\n    List<String> list1 = List.of(\"Java\", \" Python\", \" C++ \");\n    List<String> list2 = new ArrayList<>();\n\n    list1.forEach(element ->\n            list2.add(element.transform(String::strip)\n                    .transform(String::toUpperCase)\n                    .transform((e) -> \"Hi,\" + e))\n    );\n\n    list2.forEach(System.out::println);\n}\n```\n\n结果输出：\n\n```\n======test java 12 transform======\nHi,JAVA\nHi,PYTHON\nHi,C++\n```\n\n示例是对一个字符串连续转换了三遍，代码很简单，大家都能领会的。\n\n## 2、indent\n\n直接看示例吧：\n\n```\nprivate static void testIndent() {\n    System.out.println(\"======test java 12 indent======\");\n    String result = \"Java\\n Python\\nC++\".indent(3);\n    System.out.println(result);\n}\n```\n\n结果输出：\n\n```\n======test java 12 indent======\n   Java\n    Python\n   C++\n```\n\n换行符 \\n 后前缩进 N 个空格，为 0 或负数不缩进。\n\n以下是 indent 的核心源码：\n\n```\nprivate String indent(int n, boolean removeBlanks) {\n    Stream<String> stream = removeBlanks ? lines(Integer.MAX_VALUE, Integer.MAX_VALUE)\n                                         : lines();\n    if (n > 0) {\n        final String spaces = \" \".repeat(n);\n        stream = stream.map(s -> spaces + s);\n    } else if (n == Integer.MIN_VALUE) {\n        stream = stream.map(s -> s.stripLeading());\n    } else if (n < 0) {\n        stream = stream.map(s -> s.substring(Math.min(-n, s.indexOfNonWhitespace())));\n    }\n    return stream.collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n}\n```\n\n其实就是调用了 lines() 方法来创建一个 Stream，然后再往前拼接指定数量的空格。\n\n参考：《[Java 11 已发布，String 还能这样玩！](https://mp.weixin.qq.com/s/OZKvkG5OhMXf4lTklZQzGQ)》这篇文章对 lines() 的介绍。\n\n## 3、describeConstable\n\n```\nprivate static void testDescribeConstable() {\n    System.out.println(\"======test java 12 describeConstable======\");\n    String name = \"Java技术\";\n    Optional<String> optional = name.describeConstable();\n    System.out.println(optional.get());\n}\n```\n\n结果输出：\n\n```\n======test java 12 describeConstable======\nJava技术\n```\n\nJava 12, String 实现了 Constable 接口：\n\n> java.lang.constant.Constable\n\n这个接口就有一个方法，源码如下：\n\n```\npublic interface Constable {\n\n    Optional<? extends ConstantDesc> describeConstable();\n    \n}\n```\n\nJava 12 String 的实现源码：\n\n```\n@Override\npublic Optional<String> describeConstable() {\n    return Optional.of(this);\n}\n```\n\n很简单，其实就是调用 Optional.of 方法返回一个 Optional 类型，Optional不懂的可以参考这篇文章：[Java 8 新特性之 Optional](https://mp.weixin.qq.com/s/uXw4eTZqLfj871FlciPh6Q)。\n\n好了，今天的分享就到这，收藏转发一下吧，多学习了解，日后必定有用！\n\n历史 Java 新特性干货分享：\n\n![](http://img.javastack.cn/20190613135450.png)\n![](http://img.javastack.cn/20190613135537.png)\n\n\n\nJava 12 新特性继续更新中……\n\n ","slug":"新特性/Java12/Java 12 骚操作， String居然还能这样玩","published":1,"updated":"2025-10-15T07:20:51.435Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu07770063qkd4ef5d5z3h","content":"<p>Java 13 都快要来了，12必须跟栈长学起！</p>\n<p><a href=\"https://mp.weixin.qq.com/s/Gg6KKz7vhDRpzeMR8CG4DA\">Java 13 即将发布，新特性必须抢先看！</a></p>\n<p>Java 12 已经发布数月了：<a href=\"https://mp.weixin.qq.com/s/IXOoSTq6qi4ZH63gCaKa3A\">Java 12 正式发布，8大新特性！</a>，今天我再来分享下在 Java 12 中关于 String 的三个骚操作，绝逼有用。</p>\n<p>更多关于 Java 的资讯、干货教程、以及好消息，请关注，第一时间推送。</p>\n<p>坐稳了，准备起飞！</p>\n<h2 id=\"1、transform\"><a href=\"#1、transform\" class=\"headerlink\" title=\"1、transform\"></a>1、transform</h2><p>transform：即字符串转换，来看下 transform 的实现源码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public &lt;R&gt; R transform(Function&lt;? super String, ? extends R&gt; f) &#123;\n    return f.apply(this);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>传入一个函数式接口 Function，接受一个值，返回一个值，参考：<a href=\"https://mp.weixin.qq.com/s/nC3f17zZlXC08XNJWA-FBw\">Java 8 新特性之函数式接口</a>。</p>\n<p>废话少说，直接上手就是干：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testTransform() &#123;\n    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;test java 12 transform&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n    List&lt;String&gt; list1 &#x3D; List.of(&quot;Java&quot;, &quot; Python&quot;, &quot; C++ &quot;);\n    List&lt;String&gt; list2 &#x3D; new ArrayList&lt;&gt;();\n\n    list1.forEach(element -&gt;\n            list2.add(element.transform(String::strip)\n                    .transform(String::toUpperCase)\n                    .transform((e) -&gt; &quot;Hi,&quot; + e))\n    );\n\n    list2.forEach(System.out::println);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>结果输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;test java 12 transform&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nHi,JAVA\nHi,PYTHON\nHi,C++<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>示例是对一个字符串连续转换了三遍，代码很简单，大家都能领会的。</p>\n<h2 id=\"2、indent\"><a href=\"#2、indent\" class=\"headerlink\" title=\"2、indent\"></a>2、indent</h2><p>直接看示例吧：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testIndent() &#123;\n    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;test java 12 indent&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n    String result &#x3D; &quot;Java\\n Python\\nC++&quot;.indent(3);\n    System.out.println(result);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>结果输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;test java 12 indent&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n   Java\n    Python\n   C++<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>换行符 \\n 后前缩进 N 个空格，为 0 或负数不缩进。</p>\n<p>以下是 indent 的核心源码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private String indent(int n, boolean removeBlanks) &#123;\n    Stream&lt;String&gt; stream &#x3D; removeBlanks ? lines(Integer.MAX_VALUE, Integer.MAX_VALUE)\n                                         : lines();\n    if (n &gt; 0) &#123;\n        final String spaces &#x3D; &quot; &quot;.repeat(n);\n        stream &#x3D; stream.map(s -&gt; spaces + s);\n    &#125; else if (n &#x3D;&#x3D; Integer.MIN_VALUE) &#123;\n        stream &#x3D; stream.map(s -&gt; s.stripLeading());\n    &#125; else if (n &lt; 0) &#123;\n        stream &#x3D; stream.map(s -&gt; s.substring(Math.min(-n, s.indexOfNonWhitespace())));\n    &#125;\n    return stream.collect(Collectors.joining(&quot;\\n&quot;, &quot;&quot;, &quot;\\n&quot;));\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其实就是调用了 lines() 方法来创建一个 Stream，然后再往前拼接指定数量的空格。</p>\n<p>参考：《<a href=\"https://mp.weixin.qq.com/s/OZKvkG5OhMXf4lTklZQzGQ\">Java 11 已发布，String 还能这样玩！</a>》这篇文章对 lines() 的介绍。</p>\n<h2 id=\"3、describeConstable\"><a href=\"#3、describeConstable\" class=\"headerlink\" title=\"3、describeConstable\"></a>3、describeConstable</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testDescribeConstable() &#123;\n    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;test java 12 describeConstable&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n    String name &#x3D; &quot;Java技术&quot;;\n    Optional&lt;String&gt; optional &#x3D; name.describeConstable();\n    System.out.println(optional.get());\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>结果输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;test java 12 describeConstable&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nJava技术<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>Java 12, String 实现了 Constable 接口：</p>\n<blockquote>\n<p>java.lang.constant.Constable</p>\n</blockquote>\n<p>这个接口就有一个方法，源码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface Constable &#123;\n\n    Optional&lt;? extends ConstantDesc&gt; describeConstable();\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>Java 12 String 的实现源码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Override\npublic Optional&lt;String&gt; describeConstable() &#123;\n    return Optional.of(this);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>很简单，其实就是调用 Optional.of 方法返回一个 Optional 类型，Optional不懂的可以参考这篇文章：<a href=\"https://mp.weixin.qq.com/s/uXw4eTZqLfj871FlciPh6Q\">Java 8 新特性之 Optional</a>。</p>\n<p>好了，今天的分享就到这，收藏转发一下吧，多学习了解，日后必定有用！</p>\n<p>历史 Java 新特性干货分享：</p>\n<p><img src=\"http://img.javastack.cn/20190613135450.png\"><br><img src=\"http://img.javastack.cn/20190613135537.png\"></p>\n<p>Java 12 新特性继续更新中……</p>\n","excerpt":"","more":"<p>Java 13 都快要来了，12必须跟栈长学起！</p>\n<p><a href=\"https://mp.weixin.qq.com/s/Gg6KKz7vhDRpzeMR8CG4DA\">Java 13 即将发布，新特性必须抢先看！</a></p>\n<p>Java 12 已经发布数月了：<a href=\"https://mp.weixin.qq.com/s/IXOoSTq6qi4ZH63gCaKa3A\">Java 12 正式发布，8大新特性！</a>，今天我再来分享下在 Java 12 中关于 String 的三个骚操作，绝逼有用。</p>\n<p>更多关于 Java 的资讯、干货教程、以及好消息，请关注，第一时间推送。</p>\n<p>坐稳了，准备起飞！</p>\n<h2 id=\"1、transform\"><a href=\"#1、transform\" class=\"headerlink\" title=\"1、transform\"></a>1、transform</h2><p>transform：即字符串转换，来看下 transform 的实现源码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public &lt;R&gt; R transform(Function&lt;? super String, ? extends R&gt; f) &#123;\n    return f.apply(this);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>传入一个函数式接口 Function，接受一个值，返回一个值，参考：<a href=\"https://mp.weixin.qq.com/s/nC3f17zZlXC08XNJWA-FBw\">Java 8 新特性之函数式接口</a>。</p>\n<p>废话少说，直接上手就是干：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testTransform() &#123;\n    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;test java 12 transform&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n    List&lt;String&gt; list1 &#x3D; List.of(&quot;Java&quot;, &quot; Python&quot;, &quot; C++ &quot;);\n    List&lt;String&gt; list2 &#x3D; new ArrayList&lt;&gt;();\n\n    list1.forEach(element -&gt;\n            list2.add(element.transform(String::strip)\n                    .transform(String::toUpperCase)\n                    .transform((e) -&gt; &quot;Hi,&quot; + e))\n    );\n\n    list2.forEach(System.out::println);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>结果输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;test java 12 transform&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nHi,JAVA\nHi,PYTHON\nHi,C++<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>示例是对一个字符串连续转换了三遍，代码很简单，大家都能领会的。</p>\n<h2 id=\"2、indent\"><a href=\"#2、indent\" class=\"headerlink\" title=\"2、indent\"></a>2、indent</h2><p>直接看示例吧：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testIndent() &#123;\n    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;test java 12 indent&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n    String result &#x3D; &quot;Java\\n Python\\nC++&quot;.indent(3);\n    System.out.println(result);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>结果输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;test java 12 indent&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n   Java\n    Python\n   C++<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>换行符 \\n 后前缩进 N 个空格，为 0 或负数不缩进。</p>\n<p>以下是 indent 的核心源码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private String indent(int n, boolean removeBlanks) &#123;\n    Stream&lt;String&gt; stream &#x3D; removeBlanks ? lines(Integer.MAX_VALUE, Integer.MAX_VALUE)\n                                         : lines();\n    if (n &gt; 0) &#123;\n        final String spaces &#x3D; &quot; &quot;.repeat(n);\n        stream &#x3D; stream.map(s -&gt; spaces + s);\n    &#125; else if (n &#x3D;&#x3D; Integer.MIN_VALUE) &#123;\n        stream &#x3D; stream.map(s -&gt; s.stripLeading());\n    &#125; else if (n &lt; 0) &#123;\n        stream &#x3D; stream.map(s -&gt; s.substring(Math.min(-n, s.indexOfNonWhitespace())));\n    &#125;\n    return stream.collect(Collectors.joining(&quot;\\n&quot;, &quot;&quot;, &quot;\\n&quot;));\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其实就是调用了 lines() 方法来创建一个 Stream，然后再往前拼接指定数量的空格。</p>\n<p>参考：《<a href=\"https://mp.weixin.qq.com/s/OZKvkG5OhMXf4lTklZQzGQ\">Java 11 已发布，String 还能这样玩！</a>》这篇文章对 lines() 的介绍。</p>\n<h2 id=\"3、describeConstable\"><a href=\"#3、describeConstable\" class=\"headerlink\" title=\"3、describeConstable\"></a>3、describeConstable</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testDescribeConstable() &#123;\n    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;test java 12 describeConstable&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n    String name &#x3D; &quot;Java技术&quot;;\n    Optional&lt;String&gt; optional &#x3D; name.describeConstable();\n    System.out.println(optional.get());\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>结果输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;test java 12 describeConstable&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nJava技术<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>Java 12, String 实现了 Constable 接口：</p>\n<blockquote>\n<p>java.lang.constant.Constable</p>\n</blockquote>\n<p>这个接口就有一个方法，源码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface Constable &#123;\n\n    Optional&lt;? extends ConstantDesc&gt; describeConstable();\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>Java 12 String 的实现源码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@Override\npublic Optional&lt;String&gt; describeConstable() &#123;\n    return Optional.of(this);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>很简单，其实就是调用 Optional.of 方法返回一个 Optional 类型，Optional不懂的可以参考这篇文章：<a href=\"https://mp.weixin.qq.com/s/uXw4eTZqLfj871FlciPh6Q\">Java 8 新特性之 Optional</a>。</p>\n<p>好了，今天的分享就到这，收藏转发一下吧，多学习了解，日后必定有用！</p>\n<p>历史 Java 新特性干货分享：</p>\n<p><img src=\"http://img.javastack.cn/20190613135450.png\"><br><img src=\"http://img.javastack.cn/20190613135537.png\"></p>\n<p>Java 12 新特性继续更新中……</p>\n"},{"title":"Java 12 骚操作， switch居然还能这样玩！","date":"2025-10-15T03:36:33.000Z","_content":"\nJava 13 都快要来了，12必须跟栈长学起！\n\n[Java 13 即将发布，新特性必须抢先看！](https://mp.weixin.qq.com/s/Gg6KKz7vhDRpzeMR8CG4DA)\n\n\n**那么在 Java 12 中可以怎样玩 switch?**\n\n先来定义一个枚举类：\n\n```\npublic enum Status {\n    OPEN, INIT, PROCESS, PENDING, CLOSE;\n}\n```\n\nJava 12 之前是这样用的：\n\n```\nprivate static void testSwitch1(Status status) {\n    int result = 0;\n    switch (status) {\n        case OPEN:\n            result = 1;\n            break;\n        case PROCESS:\n            result = 2;\n            break;\n        case PENDING:\n            result = 2;\n            break;\n        case CLOSE:\n            result = 3;\n            break;\n        default:\n            throw new RuntimeException(\"状态不正确\");\n    }\n    System.out.println(\"result is \" + result);\n}\n```\n\nJava 12 后可以这样用：\n\n```\nprivate static void testSwitch2(Status status) {\n    var result = switch (status) {\n        case OPEN -> 1;\n        case PROCESS, PENDING -> 2;\n        case CLOSE -> 3;\n        default -> throw new RuntimeException(\"状态不正确\");\n    };\n    System.out.println(\"result is \" + result);\n}\n```\n\n示例代码看了都懂吧，是不是很骚？\n\nJava 12 switch 有以下几点特色：\n\n- 箭头语法 ->，类似 Java 8 中的 Lambda 表达式；\n- 可以直接返回值给一个变量，并且可以不用 break 关键字；\n- case 条件，多个可以写在一行，用逗号分开；\n- 可以省略 break 关键字；\n\n当然你也可以使用 break 关键字，后面跟值：\n\n```\nprivate static void testSwitch3(Status status) {\n    var result = switch (status) {\n        case OPEN -> {\n            break 1;\n        }\n        case PROCESS, PENDING -> {\n            break 2;\n        }\n        case CLOSE -> {\n            break 3;\n        }\n        default -> {\n            break 5;\n        }\n    };\n    System.out.println(\"result is \" + result);\n}\n```\n\n不推荐用这种，在编译器也会显示灰色，并提示你更改。\n\n最后，这个新特性是 Java 12 预览版中的特性：`JEP 325: Switch Expressions (Preview)`，要使用这个新特性，请切换至 Java 12 预览版。\n\n> 参考 https://openjdk.java.net/jeps/325\n\n好了，今天的分享就到这，收藏转发一下吧，多学习了解，日后必定有用！\n\n历史 Java 新特性干货分享：\n\n![](http://img.javastack.cn/20190613135450.png)\n![](http://img.javastack.cn/20190613135537.png)\n\n\n\n","source":"_posts/新特性/Java12/Java 12 骚操作， switch居然还能这样玩！.md","raw":"---\ntitle: Java 12 骚操作， switch居然还能这样玩！\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n\nJava 13 都快要来了，12必须跟栈长学起！\n\n[Java 13 即将发布，新特性必须抢先看！](https://mp.weixin.qq.com/s/Gg6KKz7vhDRpzeMR8CG4DA)\n\n\n**那么在 Java 12 中可以怎样玩 switch?**\n\n先来定义一个枚举类：\n\n```\npublic enum Status {\n    OPEN, INIT, PROCESS, PENDING, CLOSE;\n}\n```\n\nJava 12 之前是这样用的：\n\n```\nprivate static void testSwitch1(Status status) {\n    int result = 0;\n    switch (status) {\n        case OPEN:\n            result = 1;\n            break;\n        case PROCESS:\n            result = 2;\n            break;\n        case PENDING:\n            result = 2;\n            break;\n        case CLOSE:\n            result = 3;\n            break;\n        default:\n            throw new RuntimeException(\"状态不正确\");\n    }\n    System.out.println(\"result is \" + result);\n}\n```\n\nJava 12 后可以这样用：\n\n```\nprivate static void testSwitch2(Status status) {\n    var result = switch (status) {\n        case OPEN -> 1;\n        case PROCESS, PENDING -> 2;\n        case CLOSE -> 3;\n        default -> throw new RuntimeException(\"状态不正确\");\n    };\n    System.out.println(\"result is \" + result);\n}\n```\n\n示例代码看了都懂吧，是不是很骚？\n\nJava 12 switch 有以下几点特色：\n\n- 箭头语法 ->，类似 Java 8 中的 Lambda 表达式；\n- 可以直接返回值给一个变量，并且可以不用 break 关键字；\n- case 条件，多个可以写在一行，用逗号分开；\n- 可以省略 break 关键字；\n\n当然你也可以使用 break 关键字，后面跟值：\n\n```\nprivate static void testSwitch3(Status status) {\n    var result = switch (status) {\n        case OPEN -> {\n            break 1;\n        }\n        case PROCESS, PENDING -> {\n            break 2;\n        }\n        case CLOSE -> {\n            break 3;\n        }\n        default -> {\n            break 5;\n        }\n    };\n    System.out.println(\"result is \" + result);\n}\n```\n\n不推荐用这种，在编译器也会显示灰色，并提示你更改。\n\n最后，这个新特性是 Java 12 预览版中的特性：`JEP 325: Switch Expressions (Preview)`，要使用这个新特性，请切换至 Java 12 预览版。\n\n> 参考 https://openjdk.java.net/jeps/325\n\n好了，今天的分享就到这，收藏转发一下吧，多学习了解，日后必定有用！\n\n历史 Java 新特性干货分享：\n\n![](http://img.javastack.cn/20190613135450.png)\n![](http://img.javastack.cn/20190613135537.png)\n\n\n\n","slug":"新特性/Java12/Java 12 骚操作， switch居然还能这样玩！","published":1,"updated":"2025-10-15T07:20:51.408Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu07770066qkd4giprgphe","content":"<p>Java 13 都快要来了，12必须跟栈长学起！</p>\n<p><a href=\"https://mp.weixin.qq.com/s/Gg6KKz7vhDRpzeMR8CG4DA\">Java 13 即将发布，新特性必须抢先看！</a></p>\n<p><strong>那么在 Java 12 中可以怎样玩 switch?</strong></p>\n<p>先来定义一个枚举类：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public enum Status &#123;\n    OPEN, INIT, PROCESS, PENDING, CLOSE;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>Java 12 之前是这样用的：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testSwitch1(Status status) &#123;\n    int result &#x3D; 0;\n    switch (status) &#123;\n        case OPEN:\n            result &#x3D; 1;\n            break;\n        case PROCESS:\n            result &#x3D; 2;\n            break;\n        case PENDING:\n            result &#x3D; 2;\n            break;\n        case CLOSE:\n            result &#x3D; 3;\n            break;\n        default:\n            throw new RuntimeException(&quot;状态不正确&quot;);\n    &#125;\n    System.out.println(&quot;result is &quot; + result);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>Java 12 后可以这样用：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testSwitch2(Status status) &#123;\n    var result &#x3D; switch (status) &#123;\n        case OPEN -&gt; 1;\n        case PROCESS, PENDING -&gt; 2;\n        case CLOSE -&gt; 3;\n        default -&gt; throw new RuntimeException(&quot;状态不正确&quot;);\n    &#125;;\n    System.out.println(&quot;result is &quot; + result);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>示例代码看了都懂吧，是不是很骚？</p>\n<p>Java 12 switch 有以下几点特色：</p>\n<ul>\n<li>箭头语法 -&gt;，类似 Java 8 中的 Lambda 表达式；</li>\n<li>可以直接返回值给一个变量，并且可以不用 break 关键字；</li>\n<li>case 条件，多个可以写在一行，用逗号分开；</li>\n<li>可以省略 break 关键字；</li>\n</ul>\n<p>当然你也可以使用 break 关键字，后面跟值：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testSwitch3(Status status) &#123;\n    var result &#x3D; switch (status) &#123;\n        case OPEN -&gt; &#123;\n            break 1;\n        &#125;\n        case PROCESS, PENDING -&gt; &#123;\n            break 2;\n        &#125;\n        case CLOSE -&gt; &#123;\n            break 3;\n        &#125;\n        default -&gt; &#123;\n            break 5;\n        &#125;\n    &#125;;\n    System.out.println(&quot;result is &quot; + result);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>不推荐用这种，在编译器也会显示灰色，并提示你更改。</p>\n<p>最后，这个新特性是 Java 12 预览版中的特性：<code>JEP 325: Switch Expressions (Preview)</code>，要使用这个新特性，请切换至 Java 12 预览版。</p>\n<blockquote>\n<p>参考 <a href=\"https://openjdk.java.net/jeps/325\">https://openjdk.java.net/jeps/325</a></p>\n</blockquote>\n<p>好了，今天的分享就到这，收藏转发一下吧，多学习了解，日后必定有用！</p>\n<p>历史 Java 新特性干货分享：</p>\n<p><img src=\"http://img.javastack.cn/20190613135450.png\"><br><img src=\"http://img.javastack.cn/20190613135537.png\"></p>\n","excerpt":"","more":"<p>Java 13 都快要来了，12必须跟栈长学起！</p>\n<p><a href=\"https://mp.weixin.qq.com/s/Gg6KKz7vhDRpzeMR8CG4DA\">Java 13 即将发布，新特性必须抢先看！</a></p>\n<p><strong>那么在 Java 12 中可以怎样玩 switch?</strong></p>\n<p>先来定义一个枚举类：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public enum Status &#123;\n    OPEN, INIT, PROCESS, PENDING, CLOSE;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>Java 12 之前是这样用的：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testSwitch1(Status status) &#123;\n    int result &#x3D; 0;\n    switch (status) &#123;\n        case OPEN:\n            result &#x3D; 1;\n            break;\n        case PROCESS:\n            result &#x3D; 2;\n            break;\n        case PENDING:\n            result &#x3D; 2;\n            break;\n        case CLOSE:\n            result &#x3D; 3;\n            break;\n        default:\n            throw new RuntimeException(&quot;状态不正确&quot;);\n    &#125;\n    System.out.println(&quot;result is &quot; + result);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>Java 12 后可以这样用：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testSwitch2(Status status) &#123;\n    var result &#x3D; switch (status) &#123;\n        case OPEN -&gt; 1;\n        case PROCESS, PENDING -&gt; 2;\n        case CLOSE -&gt; 3;\n        default -&gt; throw new RuntimeException(&quot;状态不正确&quot;);\n    &#125;;\n    System.out.println(&quot;result is &quot; + result);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>示例代码看了都懂吧，是不是很骚？</p>\n<p>Java 12 switch 有以下几点特色：</p>\n<ul>\n<li>箭头语法 -&gt;，类似 Java 8 中的 Lambda 表达式；</li>\n<li>可以直接返回值给一个变量，并且可以不用 break 关键字；</li>\n<li>case 条件，多个可以写在一行，用逗号分开；</li>\n<li>可以省略 break 关键字；</li>\n</ul>\n<p>当然你也可以使用 break 关键字，后面跟值：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void testSwitch3(Status status) &#123;\n    var result &#x3D; switch (status) &#123;\n        case OPEN -&gt; &#123;\n            break 1;\n        &#125;\n        case PROCESS, PENDING -&gt; &#123;\n            break 2;\n        &#125;\n        case CLOSE -&gt; &#123;\n            break 3;\n        &#125;\n        default -&gt; &#123;\n            break 5;\n        &#125;\n    &#125;;\n    System.out.println(&quot;result is &quot; + result);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>不推荐用这种，在编译器也会显示灰色，并提示你更改。</p>\n<p>最后，这个新特性是 Java 12 预览版中的特性：<code>JEP 325: Switch Expressions (Preview)</code>，要使用这个新特性，请切换至 Java 12 预览版。</p>\n<blockquote>\n<p>参考 <a href=\"https://openjdk.java.net/jeps/325\">https://openjdk.java.net/jeps/325</a></p>\n</blockquote>\n<p>好了，今天的分享就到这，收藏转发一下吧，多学习了解，日后必定有用！</p>\n<p>历史 Java 新特性干货分享：</p>\n<p><img src=\"http://img.javastack.cn/20190613135450.png\"><br><img src=\"http://img.javastack.cn/20190613135537.png\"></p>\n"},{"title":"Java 12 骚操作， 文件比对居然还能这样玩！","date":"2025-10-15T03:36:33.000Z","_content":"Java 13 都快要来了，12必须跟栈长学起！\n\n[Java 13 即将发布，新特性必须抢先看！](https://mp.weixin.qq.com/s/Gg6KKz7vhDRpzeMR8CG4DA)\n\n之前分享了一些 Java 12 的骚操作，今天继续，今天要分享的是 Java 12 中的文件比对骚操作。\n\n**我们或多或少会遇到这样的需求：怎么比对两个文件中的内容一样？**\n\n你会把两个文件中的内容拉出来一个个字符对比，然后提交一大堆不怎么优雅的代码？\n\n这样你就太 OUT 了！\n\n在 Java 12 中，仅需要 1 行代码即可搞定！\n\n来看示例代码：\n\n```\npublic static void main(String[] args) throws IOException {\n    Path dir = Paths.get(\"d:/\");\n\n    Path path1 = dir.resolve(\"javastack1.txt\");\n\n    Path path2 = dir.resolve(\"javastack2.txt\");\n\n    long result = Files.mismatch(path1, path2);\n\n    System.out.println(result);\n}\n```\n\n**Files.mismatch 一行搞定！**\n\njavastack1 和 javastack2 的内容都是：\n\n```\nwww.javastack.cn\n```\n\n这时候输出结果：-1。\n\n现在把 javastack2 的内容改成：\n\n```\nhttp://www.javastack.cn\n```\n\n这时候输出结果：0。\n\n再把 javastack2 的内容改成：\n\n```\nwww.javastack.cn/\n```\n\n这时候输出结果：16。\n\n**Files.mismatch**\n\nFiles.mismatch方法源码如下：\n\n```\npublic static long mismatch(Path path, Path path2) throws IOException {\n    if (isSameFile(path, path2)) {\n        return -1;\n    }\n    byte[] buffer1 = new byte[BUFFER_SIZE];\n    byte[] buffer2 = new byte[BUFFER_SIZE];\n    try (InputStream in1 = Files.newInputStream(path);\n         InputStream in2 = Files.newInputStream(path2);) {\n        long totalRead = 0;\n        while (true) {\n            int nRead1 = in1.readNBytes(buffer1, 0, BUFFER_SIZE);\n            int nRead2 = in2.readNBytes(buffer2, 0, BUFFER_SIZE);\n\n            int i = Arrays.mismatch(buffer1, 0, nRead1, buffer2, 0, nRead2);\n            if (i > -1) {\n                return totalRead + i;\n            }\n            if (nRead1 < BUFFER_SIZE) {\n                // we've reached the end of the files, but found no mismatch\n                return -1;\n            }\n            totalRead += nRead1;\n        }\n    }\n}\n```\n\n- 返回-1：同一文件，或者两个文件内容一样\n- 返回其他数字：文件内容对比差异的位置，从0开始\n\n**所以，只要返回 -1，说明文件内容相同。**\n\n好了，今天的分享就到这，记住了，别说我没告诉你。。\n\n收藏转发一下吧，多学习了解，日后必定有用！\n\n历史 Java 新特性干货分享：\n\n![](http://img.javastack.cn/20190613135450.png)\n![](http://img.javastack.cn/20190613135537.png)\n\n\n\n","source":"_posts/新特性/Java12/Java 12 骚操作， 文件比对居然还能这样玩！.md","raw":"---\ntitle: Java 12 骚操作， 文件比对居然还能这样玩！\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\nJava 13 都快要来了，12必须跟栈长学起！\n\n[Java 13 即将发布，新特性必须抢先看！](https://mp.weixin.qq.com/s/Gg6KKz7vhDRpzeMR8CG4DA)\n\n之前分享了一些 Java 12 的骚操作，今天继续，今天要分享的是 Java 12 中的文件比对骚操作。\n\n**我们或多或少会遇到这样的需求：怎么比对两个文件中的内容一样？**\n\n你会把两个文件中的内容拉出来一个个字符对比，然后提交一大堆不怎么优雅的代码？\n\n这样你就太 OUT 了！\n\n在 Java 12 中，仅需要 1 行代码即可搞定！\n\n来看示例代码：\n\n```\npublic static void main(String[] args) throws IOException {\n    Path dir = Paths.get(\"d:/\");\n\n    Path path1 = dir.resolve(\"javastack1.txt\");\n\n    Path path2 = dir.resolve(\"javastack2.txt\");\n\n    long result = Files.mismatch(path1, path2);\n\n    System.out.println(result);\n}\n```\n\n**Files.mismatch 一行搞定！**\n\njavastack1 和 javastack2 的内容都是：\n\n```\nwww.javastack.cn\n```\n\n这时候输出结果：-1。\n\n现在把 javastack2 的内容改成：\n\n```\nhttp://www.javastack.cn\n```\n\n这时候输出结果：0。\n\n再把 javastack2 的内容改成：\n\n```\nwww.javastack.cn/\n```\n\n这时候输出结果：16。\n\n**Files.mismatch**\n\nFiles.mismatch方法源码如下：\n\n```\npublic static long mismatch(Path path, Path path2) throws IOException {\n    if (isSameFile(path, path2)) {\n        return -1;\n    }\n    byte[] buffer1 = new byte[BUFFER_SIZE];\n    byte[] buffer2 = new byte[BUFFER_SIZE];\n    try (InputStream in1 = Files.newInputStream(path);\n         InputStream in2 = Files.newInputStream(path2);) {\n        long totalRead = 0;\n        while (true) {\n            int nRead1 = in1.readNBytes(buffer1, 0, BUFFER_SIZE);\n            int nRead2 = in2.readNBytes(buffer2, 0, BUFFER_SIZE);\n\n            int i = Arrays.mismatch(buffer1, 0, nRead1, buffer2, 0, nRead2);\n            if (i > -1) {\n                return totalRead + i;\n            }\n            if (nRead1 < BUFFER_SIZE) {\n                // we've reached the end of the files, but found no mismatch\n                return -1;\n            }\n            totalRead += nRead1;\n        }\n    }\n}\n```\n\n- 返回-1：同一文件，或者两个文件内容一样\n- 返回其他数字：文件内容对比差异的位置，从0开始\n\n**所以，只要返回 -1，说明文件内容相同。**\n\n好了，今天的分享就到这，记住了，别说我没告诉你。。\n\n收藏转发一下吧，多学习了解，日后必定有用！\n\n历史 Java 新特性干货分享：\n\n![](http://img.javastack.cn/20190613135450.png)\n![](http://img.javastack.cn/20190613135537.png)\n\n\n\n","slug":"新特性/Java12/Java 12 骚操作， 文件比对居然还能这样玩！","published":1,"updated":"2025-10-15T07:20:51.380Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu07770069qkd4ga92fel1","content":"<p>Java 13 都快要来了，12必须跟栈长学起！</p>\n<p><a href=\"https://mp.weixin.qq.com/s/Gg6KKz7vhDRpzeMR8CG4DA\">Java 13 即将发布，新特性必须抢先看！</a></p>\n<p>之前分享了一些 Java 12 的骚操作，今天继续，今天要分享的是 Java 12 中的文件比对骚操作。</p>\n<p><strong>我们或多或少会遇到这样的需求：怎么比对两个文件中的内容一样？</strong></p>\n<p>你会把两个文件中的内容拉出来一个个字符对比，然后提交一大堆不怎么优雅的代码？</p>\n<p>这样你就太 OUT 了！</p>\n<p>在 Java 12 中，仅需要 1 行代码即可搞定！</p>\n<p>来看示例代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) throws IOException &#123;\n    Path dir &#x3D; Paths.get(&quot;d:&#x2F;&quot;);\n\n    Path path1 &#x3D; dir.resolve(&quot;javastack1.txt&quot;);\n\n    Path path2 &#x3D; dir.resolve(&quot;javastack2.txt&quot;);\n\n    long result &#x3D; Files.mismatch(path1, path2);\n\n    System.out.println(result);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>Files.mismatch 一行搞定！</strong></p>\n<p>javastack1 和 javastack2 的内容都是：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">www.javastack.cn<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这时候输出结果：-1。</p>\n<p>现在把 javastack2 的内容改成：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">http:&#x2F;&#x2F;www.javastack.cn<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这时候输出结果：0。</p>\n<p>再把 javastack2 的内容改成：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">www.javastack.cn&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这时候输出结果：16。</p>\n<p><strong>Files.mismatch</strong></p>\n<p>Files.mismatch方法源码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static long mismatch(Path path, Path path2) throws IOException &#123;\n    if (isSameFile(path, path2)) &#123;\n        return -1;\n    &#125;\n    byte[] buffer1 &#x3D; new byte[BUFFER_SIZE];\n    byte[] buffer2 &#x3D; new byte[BUFFER_SIZE];\n    try (InputStream in1 &#x3D; Files.newInputStream(path);\n         InputStream in2 &#x3D; Files.newInputStream(path2);) &#123;\n        long totalRead &#x3D; 0;\n        while (true) &#123;\n            int nRead1 &#x3D; in1.readNBytes(buffer1, 0, BUFFER_SIZE);\n            int nRead2 &#x3D; in2.readNBytes(buffer2, 0, BUFFER_SIZE);\n\n            int i &#x3D; Arrays.mismatch(buffer1, 0, nRead1, buffer2, 0, nRead2);\n            if (i &gt; -1) &#123;\n                return totalRead + i;\n            &#125;\n            if (nRead1 &lt; BUFFER_SIZE) &#123;\n                &#x2F;&#x2F; we&#39;ve reached the end of the files, but found no mismatch\n                return -1;\n            &#125;\n            totalRead +&#x3D; nRead1;\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>返回-1：同一文件，或者两个文件内容一样</li>\n<li>返回其他数字：文件内容对比差异的位置，从0开始</li>\n</ul>\n<p><strong>所以，只要返回 -1，说明文件内容相同。</strong></p>\n<p>好了，今天的分享就到这，记住了，别说我没告诉你。。</p>\n<p>收藏转发一下吧，多学习了解，日后必定有用！</p>\n<p>历史 Java 新特性干货分享：</p>\n<p><img src=\"http://img.javastack.cn/20190613135450.png\"><br><img src=\"http://img.javastack.cn/20190613135537.png\"></p>\n","excerpt":"","more":"<p>Java 13 都快要来了，12必须跟栈长学起！</p>\n<p><a href=\"https://mp.weixin.qq.com/s/Gg6KKz7vhDRpzeMR8CG4DA\">Java 13 即将发布，新特性必须抢先看！</a></p>\n<p>之前分享了一些 Java 12 的骚操作，今天继续，今天要分享的是 Java 12 中的文件比对骚操作。</p>\n<p><strong>我们或多或少会遇到这样的需求：怎么比对两个文件中的内容一样？</strong></p>\n<p>你会把两个文件中的内容拉出来一个个字符对比，然后提交一大堆不怎么优雅的代码？</p>\n<p>这样你就太 OUT 了！</p>\n<p>在 Java 12 中，仅需要 1 行代码即可搞定！</p>\n<p>来看示例代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static void main(String[] args) throws IOException &#123;\n    Path dir &#x3D; Paths.get(&quot;d:&#x2F;&quot;);\n\n    Path path1 &#x3D; dir.resolve(&quot;javastack1.txt&quot;);\n\n    Path path2 &#x3D; dir.resolve(&quot;javastack2.txt&quot;);\n\n    long result &#x3D; Files.mismatch(path1, path2);\n\n    System.out.println(result);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>Files.mismatch 一行搞定！</strong></p>\n<p>javastack1 和 javastack2 的内容都是：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">www.javastack.cn<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这时候输出结果：-1。</p>\n<p>现在把 javastack2 的内容改成：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">http:&#x2F;&#x2F;www.javastack.cn<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这时候输出结果：0。</p>\n<p>再把 javastack2 的内容改成：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">www.javastack.cn&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这时候输出结果：16。</p>\n<p><strong>Files.mismatch</strong></p>\n<p>Files.mismatch方法源码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static long mismatch(Path path, Path path2) throws IOException &#123;\n    if (isSameFile(path, path2)) &#123;\n        return -1;\n    &#125;\n    byte[] buffer1 &#x3D; new byte[BUFFER_SIZE];\n    byte[] buffer2 &#x3D; new byte[BUFFER_SIZE];\n    try (InputStream in1 &#x3D; Files.newInputStream(path);\n         InputStream in2 &#x3D; Files.newInputStream(path2);) &#123;\n        long totalRead &#x3D; 0;\n        while (true) &#123;\n            int nRead1 &#x3D; in1.readNBytes(buffer1, 0, BUFFER_SIZE);\n            int nRead2 &#x3D; in2.readNBytes(buffer2, 0, BUFFER_SIZE);\n\n            int i &#x3D; Arrays.mismatch(buffer1, 0, nRead1, buffer2, 0, nRead2);\n            if (i &gt; -1) &#123;\n                return totalRead + i;\n            &#125;\n            if (nRead1 &lt; BUFFER_SIZE) &#123;\n                &#x2F;&#x2F; we&#39;ve reached the end of the files, but found no mismatch\n                return -1;\n            &#125;\n            totalRead +&#x3D; nRead1;\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>返回-1：同一文件，或者两个文件内容一样</li>\n<li>返回其他数字：文件内容对比差异的位置，从0开始</li>\n</ul>\n<p><strong>所以，只要返回 -1，说明文件内容相同。</strong></p>\n<p>好了，今天的分享就到这，记住了，别说我没告诉你。。</p>\n<p>收藏转发一下吧，多学习了解，日后必定有用！</p>\n<p>历史 Java 新特性干货分享：</p>\n<p><img src=\"http://img.javastack.cn/20190613135450.png\"><br><img src=\"http://img.javastack.cn/20190613135537.png\"></p>\n"},{"title":"Java9 简化流关闭新姿势","date":"2025-10-15T03:36:33.000Z","_content":"![](http://img.javastack.cn/18-2-27/87594869.jpg)\n\n做Java开发的都知道，每个资源的打开都需要对应的关闭操作，不然就会使资源一直占用而造成资源浪费，从而降低系统性能。\n\n关于资源的关闭操作，从JDK7-JDK9有了不少的提升及简化。\n\n#### JDK6\n\n在JDK6及之前，每个资源都需要我们手动写代码关闭，如：\n\n```\nFileInputStream fis = null;\nbyte[] buffer = new byte[1024];\ntry {\n\tfis = new FileInputStream(new File(\"E:\\\\Java技术.txt\"));\n\twhile (fis.read(buffer) > 0) {\n\t\tSystem.out.println(new String(buffer));\n\t}\n} catch (Exception e) {\n\te.printStackTrace();\n} finally {\n\tif (fis != null) {\n\t\ttry {\n\t\t\tfis.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n资源打开使用完后，必须在finally块中进行手动关闭！我们有的同事，做一个查询功能点，打开了连接查询完后没有手动关闭，最后造成连接池超出最大连接数而使系统功能堵塞。\n\n#### JDK7\n\nJDK7发布后，添加了新特性：try-with-resources语句。所有需要关闭的资源只要实现了`java.lang.AutoCloseable`（java.io.Closeable就实现了这个接口）接口就在会程序结束后自动关闭。\n\n如上面的读取文件的流程序用JDK7来写：\n\n```\nbyte[] buffer = new byte[1024];\ntry (FileInputStream fis = new FileInputStream(new File(\"E:\\\\Java技术.txt\"))) {\n\twhile (fis.read(buffer) > 0) {\n\t\tSystem.out.println(new String(buffer));\n\t}\n} catch (Exception e) {\n\te.printStackTrace();\n}\n```\n\n所有的资源在`try()`里面定义，并去掉了finally模块。\n\n下面我们来写一个自定义的流来看看是否自动关闭了。\n\n**定义一个自定义输入输出流**\n\n```\nclass MyInputStream implements AutoCloseable {\n\n\tvoid read(String content) {\n\t\tSystem.out.println(\"read content \" + content);\n\t}\n\n\t@Override\n\tpublic void close() throws Exception {\n\t\tSystem.out.println(\"input stream is closed.\");\n\t}\n\n}\n\nclass MyOutputStream implements AutoCloseable {\n\n\tvoid write(String content) {\n\t\tSystem.out.println(\"write content \" + content);\n\t}\n\n\t@Override\n\tpublic void close() throws Exception {\n\t\tSystem.out.println(\"out stream is closed.\");\n\t}\n\n}\n```\n\n**单个资源自动关闭**\n\n```\ntry (MyInputStream mis = new MyInputStream()) {\n\tmis.read(\"7_2\");\n} catch (Exception e) {\n\te.printStackTrace();\n}\n```\n\n输出：\n\n> read content 7_2\\\n> input stream is closed.\n\n**多个资源自动关闭**\n\n`try()`里面可以定义多个资源，它们的关闭顺序是最后在`try()`定义的资源先关闭。\n\n```\ntry (MyInputStream mis = new MyInputStream(); MyOutputStream mos = new MyOutputStream()) {\n\tmis.read(\"7_3\");\n\tmos.write(\"7_3\");\n} catch (Exception e) {\n\te.printStackTrace();\n}\n```\n\n输出：\n\n> read content 7_3\\\n> write content 7_3\\\n> out stream is closed.\\\n> input stream is closed.\n\n#### JDK9\n\nJDK9发布后，又简化了try-with-resources语句的用法。\n\n`try()`里面可以是一个变量，但必须是final的或者等同final才行。如下面的mis，mos定义成局部变量可以不用final，局部变量可以等同于final，但定义成成员变量就必须是用final修饰的，不然会编译错误。\n\n```\nMyInputStream mis = new MyInputStream();\nMyOutputStream mos = new MyOutputStream();\ntry (mis; mos) {\n\tmis.read(\"1.9\");\n\tmos.write(\"1.9\");\n} catch (Exception e) {\n\te.printStackTrace();\n}\n```\n\n输出：\n\n> read content 1.9\\\n> write content 1.9\\\n> out stream is closed.\\\n> input stream is closed.\n\n再来看个例子：\n\n```\nConnection dbCon = DriverManager.getConnection(\"url\", \"user\", \"password\");\ntry (dbCon; ResultSet rs = dbCon.createStatement().executeQuery(\"select * from emp\")) {\n    while (rs.next()) {\n        System.out.println(\"In loadDataFromDB() =====>>>>>>>>>>>> \" + rs.getString(1));\n    }\n} catch (SQLException e) {\n    System.out.println(\"Exception occurs while reading the data from DB ->\" + e.getMessage());\n}\n```\n\ndbCon和rs都能被自动关闭。\n\nJKD9虽然简化了，但感觉还是没有什么质的变化，实际用途我们可能不希望关心资源的关闭，或者在方法结束之后如果是局部变量它就能自动关闭。或许是我站的高度不够，官方有其他的考量，但JDK9的这一点变化还是非常有用的。\n\n更多JDK9的新功能实战陆续更新，如果觉得有用，分享到朋友圈给更多的人吧！\n\n","source":"_posts/新特性/Java9/Java9 简化流关闭新姿势.md","raw":"---\ntitle: Java9 简化流关闭新姿势\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n![](http://img.javastack.cn/18-2-27/87594869.jpg)\n\n做Java开发的都知道，每个资源的打开都需要对应的关闭操作，不然就会使资源一直占用而造成资源浪费，从而降低系统性能。\n\n关于资源的关闭操作，从JDK7-JDK9有了不少的提升及简化。\n\n#### JDK6\n\n在JDK6及之前，每个资源都需要我们手动写代码关闭，如：\n\n```\nFileInputStream fis = null;\nbyte[] buffer = new byte[1024];\ntry {\n\tfis = new FileInputStream(new File(\"E:\\\\Java技术.txt\"));\n\twhile (fis.read(buffer) > 0) {\n\t\tSystem.out.println(new String(buffer));\n\t}\n} catch (Exception e) {\n\te.printStackTrace();\n} finally {\n\tif (fis != null) {\n\t\ttry {\n\t\t\tfis.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n资源打开使用完后，必须在finally块中进行手动关闭！我们有的同事，做一个查询功能点，打开了连接查询完后没有手动关闭，最后造成连接池超出最大连接数而使系统功能堵塞。\n\n#### JDK7\n\nJDK7发布后，添加了新特性：try-with-resources语句。所有需要关闭的资源只要实现了`java.lang.AutoCloseable`（java.io.Closeable就实现了这个接口）接口就在会程序结束后自动关闭。\n\n如上面的读取文件的流程序用JDK7来写：\n\n```\nbyte[] buffer = new byte[1024];\ntry (FileInputStream fis = new FileInputStream(new File(\"E:\\\\Java技术.txt\"))) {\n\twhile (fis.read(buffer) > 0) {\n\t\tSystem.out.println(new String(buffer));\n\t}\n} catch (Exception e) {\n\te.printStackTrace();\n}\n```\n\n所有的资源在`try()`里面定义，并去掉了finally模块。\n\n下面我们来写一个自定义的流来看看是否自动关闭了。\n\n**定义一个自定义输入输出流**\n\n```\nclass MyInputStream implements AutoCloseable {\n\n\tvoid read(String content) {\n\t\tSystem.out.println(\"read content \" + content);\n\t}\n\n\t@Override\n\tpublic void close() throws Exception {\n\t\tSystem.out.println(\"input stream is closed.\");\n\t}\n\n}\n\nclass MyOutputStream implements AutoCloseable {\n\n\tvoid write(String content) {\n\t\tSystem.out.println(\"write content \" + content);\n\t}\n\n\t@Override\n\tpublic void close() throws Exception {\n\t\tSystem.out.println(\"out stream is closed.\");\n\t}\n\n}\n```\n\n**单个资源自动关闭**\n\n```\ntry (MyInputStream mis = new MyInputStream()) {\n\tmis.read(\"7_2\");\n} catch (Exception e) {\n\te.printStackTrace();\n}\n```\n\n输出：\n\n> read content 7_2\\\n> input stream is closed.\n\n**多个资源自动关闭**\n\n`try()`里面可以定义多个资源，它们的关闭顺序是最后在`try()`定义的资源先关闭。\n\n```\ntry (MyInputStream mis = new MyInputStream(); MyOutputStream mos = new MyOutputStream()) {\n\tmis.read(\"7_3\");\n\tmos.write(\"7_3\");\n} catch (Exception e) {\n\te.printStackTrace();\n}\n```\n\n输出：\n\n> read content 7_3\\\n> write content 7_3\\\n> out stream is closed.\\\n> input stream is closed.\n\n#### JDK9\n\nJDK9发布后，又简化了try-with-resources语句的用法。\n\n`try()`里面可以是一个变量，但必须是final的或者等同final才行。如下面的mis，mos定义成局部变量可以不用final，局部变量可以等同于final，但定义成成员变量就必须是用final修饰的，不然会编译错误。\n\n```\nMyInputStream mis = new MyInputStream();\nMyOutputStream mos = new MyOutputStream();\ntry (mis; mos) {\n\tmis.read(\"1.9\");\n\tmos.write(\"1.9\");\n} catch (Exception e) {\n\te.printStackTrace();\n}\n```\n\n输出：\n\n> read content 1.9\\\n> write content 1.9\\\n> out stream is closed.\\\n> input stream is closed.\n\n再来看个例子：\n\n```\nConnection dbCon = DriverManager.getConnection(\"url\", \"user\", \"password\");\ntry (dbCon; ResultSet rs = dbCon.createStatement().executeQuery(\"select * from emp\")) {\n    while (rs.next()) {\n        System.out.println(\"In loadDataFromDB() =====>>>>>>>>>>>> \" + rs.getString(1));\n    }\n} catch (SQLException e) {\n    System.out.println(\"Exception occurs while reading the data from DB ->\" + e.getMessage());\n}\n```\n\ndbCon和rs都能被自动关闭。\n\nJKD9虽然简化了，但感觉还是没有什么质的变化，实际用途我们可能不希望关心资源的关闭，或者在方法结束之后如果是局部变量它就能自动关闭。或许是我站的高度不够，官方有其他的考量，但JDK9的这一点变化还是非常有用的。\n\n更多JDK9的新功能实战陆续更新，如果觉得有用，分享到朋友圈给更多的人吧！\n\n","slug":"新特性/Java9/Java9 简化流关闭新姿势","published":1,"updated":"2025-10-15T07:20:51.394Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu0778006cqkd47kih04u2","content":"<p><img src=\"http://img.javastack.cn/18-2-27/87594869.jpg\"></p>\n<p>做Java开发的都知道，每个资源的打开都需要对应的关闭操作，不然就会使资源一直占用而造成资源浪费，从而降低系统性能。</p>\n<p>关于资源的关闭操作，从JDK7-JDK9有了不少的提升及简化。</p>\n<h4 id=\"JDK6\"><a href=\"#JDK6\" class=\"headerlink\" title=\"JDK6\"></a>JDK6</h4><p>在JDK6及之前，每个资源都需要我们手动写代码关闭，如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">FileInputStream fis &#x3D; null;\nbyte[] buffer &#x3D; new byte[1024];\ntry &#123;\n\tfis &#x3D; new FileInputStream(new File(&quot;E:\\\\Java技术.txt&quot;));\n\twhile (fis.read(buffer) &gt; 0) &#123;\n\t\tSystem.out.println(new String(buffer));\n\t&#125;\n&#125; catch (Exception e) &#123;\n\te.printStackTrace();\n&#125; finally &#123;\n\tif (fis !&#x3D; null) &#123;\n\t\ttry &#123;\n\t\t\tfis.close();\n\t\t&#125; catch (IOException e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>资源打开使用完后，必须在finally块中进行手动关闭！我们有的同事，做一个查询功能点，打开了连接查询完后没有手动关闭，最后造成连接池超出最大连接数而使系统功能堵塞。</p>\n<h4 id=\"JDK7\"><a href=\"#JDK7\" class=\"headerlink\" title=\"JDK7\"></a>JDK7</h4><p>JDK7发布后，添加了新特性：try-with-resources语句。所有需要关闭的资源只要实现了<code>java.lang.AutoCloseable</code>（java.io.Closeable就实现了这个接口）接口就在会程序结束后自动关闭。</p>\n<p>如上面的读取文件的流程序用JDK7来写：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">byte[] buffer &#x3D; new byte[1024];\ntry (FileInputStream fis &#x3D; new FileInputStream(new File(&quot;E:\\\\Java技术.txt&quot;))) &#123;\n\twhile (fis.read(buffer) &gt; 0) &#123;\n\t\tSystem.out.println(new String(buffer));\n\t&#125;\n&#125; catch (Exception e) &#123;\n\te.printStackTrace();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>所有的资源在<code>try()</code>里面定义，并去掉了finally模块。</p>\n<p>下面我们来写一个自定义的流来看看是否自动关闭了。</p>\n<p><strong>定义一个自定义输入输出流</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class MyInputStream implements AutoCloseable &#123;\n\n\tvoid read(String content) &#123;\n\t\tSystem.out.println(&quot;read content &quot; + content);\n\t&#125;\n\n\t@Override\n\tpublic void close() throws Exception &#123;\n\t\tSystem.out.println(&quot;input stream is closed.&quot;);\n\t&#125;\n\n&#125;\n\nclass MyOutputStream implements AutoCloseable &#123;\n\n\tvoid write(String content) &#123;\n\t\tSystem.out.println(&quot;write content &quot; + content);\n\t&#125;\n\n\t@Override\n\tpublic void close() throws Exception &#123;\n\t\tSystem.out.println(&quot;out stream is closed.&quot;);\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>单个资源自动关闭</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">try (MyInputStream mis &#x3D; new MyInputStream()) &#123;\n\tmis.read(&quot;7_2&quot;);\n&#125; catch (Exception e) &#123;\n\te.printStackTrace();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出：</p>\n<blockquote>\n<p>read content 7_2<br>input stream is closed.</p>\n</blockquote>\n<p><strong>多个资源自动关闭</strong></p>\n<p><code>try()</code>里面可以定义多个资源，它们的关闭顺序是最后在<code>try()</code>定义的资源先关闭。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">try (MyInputStream mis &#x3D; new MyInputStream(); MyOutputStream mos &#x3D; new MyOutputStream()) &#123;\n\tmis.read(&quot;7_3&quot;);\n\tmos.write(&quot;7_3&quot;);\n&#125; catch (Exception e) &#123;\n\te.printStackTrace();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出：</p>\n<blockquote>\n<p>read content 7_3<br>write content 7_3<br>out stream is closed.<br>input stream is closed.</p>\n</blockquote>\n<h4 id=\"JDK9\"><a href=\"#JDK9\" class=\"headerlink\" title=\"JDK9\"></a>JDK9</h4><p>JDK9发布后，又简化了try-with-resources语句的用法。</p>\n<p><code>try()</code>里面可以是一个变量，但必须是final的或者等同final才行。如下面的mis，mos定义成局部变量可以不用final，局部变量可以等同于final，但定义成成员变量就必须是用final修饰的，不然会编译错误。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">MyInputStream mis &#x3D; new MyInputStream();\nMyOutputStream mos &#x3D; new MyOutputStream();\ntry (mis; mos) &#123;\n\tmis.read(&quot;1.9&quot;);\n\tmos.write(&quot;1.9&quot;);\n&#125; catch (Exception e) &#123;\n\te.printStackTrace();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出：</p>\n<blockquote>\n<p>read content 1.9<br>write content 1.9<br>out stream is closed.<br>input stream is closed.</p>\n</blockquote>\n<p>再来看个例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Connection dbCon &#x3D; DriverManager.getConnection(&quot;url&quot;, &quot;user&quot;, &quot;password&quot;);\ntry (dbCon; ResultSet rs &#x3D; dbCon.createStatement().executeQuery(&quot;select * from emp&quot;)) &#123;\n    while (rs.next()) &#123;\n        System.out.println(&quot;In loadDataFromDB() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + rs.getString(1));\n    &#125;\n&#125; catch (SQLException e) &#123;\n    System.out.println(&quot;Exception occurs while reading the data from DB -&gt;&quot; + e.getMessage());\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>dbCon和rs都能被自动关闭。</p>\n<p>JKD9虽然简化了，但感觉还是没有什么质的变化，实际用途我们可能不希望关心资源的关闭，或者在方法结束之后如果是局部变量它就能自动关闭。或许是我站的高度不够，官方有其他的考量，但JDK9的这一点变化还是非常有用的。</p>\n<p>更多JDK9的新功能实战陆续更新，如果觉得有用，分享到朋友圈给更多的人吧！</p>\n","excerpt":"","more":"<p><img src=\"http://img.javastack.cn/18-2-27/87594869.jpg\"></p>\n<p>做Java开发的都知道，每个资源的打开都需要对应的关闭操作，不然就会使资源一直占用而造成资源浪费，从而降低系统性能。</p>\n<p>关于资源的关闭操作，从JDK7-JDK9有了不少的提升及简化。</p>\n<h4 id=\"JDK6\"><a href=\"#JDK6\" class=\"headerlink\" title=\"JDK6\"></a>JDK6</h4><p>在JDK6及之前，每个资源都需要我们手动写代码关闭，如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">FileInputStream fis &#x3D; null;\nbyte[] buffer &#x3D; new byte[1024];\ntry &#123;\n\tfis &#x3D; new FileInputStream(new File(&quot;E:\\\\Java技术.txt&quot;));\n\twhile (fis.read(buffer) &gt; 0) &#123;\n\t\tSystem.out.println(new String(buffer));\n\t&#125;\n&#125; catch (Exception e) &#123;\n\te.printStackTrace();\n&#125; finally &#123;\n\tif (fis !&#x3D; null) &#123;\n\t\ttry &#123;\n\t\t\tfis.close();\n\t\t&#125; catch (IOException e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>资源打开使用完后，必须在finally块中进行手动关闭！我们有的同事，做一个查询功能点，打开了连接查询完后没有手动关闭，最后造成连接池超出最大连接数而使系统功能堵塞。</p>\n<h4 id=\"JDK7\"><a href=\"#JDK7\" class=\"headerlink\" title=\"JDK7\"></a>JDK7</h4><p>JDK7发布后，添加了新特性：try-with-resources语句。所有需要关闭的资源只要实现了<code>java.lang.AutoCloseable</code>（java.io.Closeable就实现了这个接口）接口就在会程序结束后自动关闭。</p>\n<p>如上面的读取文件的流程序用JDK7来写：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">byte[] buffer &#x3D; new byte[1024];\ntry (FileInputStream fis &#x3D; new FileInputStream(new File(&quot;E:\\\\Java技术.txt&quot;))) &#123;\n\twhile (fis.read(buffer) &gt; 0) &#123;\n\t\tSystem.out.println(new String(buffer));\n\t&#125;\n&#125; catch (Exception e) &#123;\n\te.printStackTrace();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>所有的资源在<code>try()</code>里面定义，并去掉了finally模块。</p>\n<p>下面我们来写一个自定义的流来看看是否自动关闭了。</p>\n<p><strong>定义一个自定义输入输出流</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class MyInputStream implements AutoCloseable &#123;\n\n\tvoid read(String content) &#123;\n\t\tSystem.out.println(&quot;read content &quot; + content);\n\t&#125;\n\n\t@Override\n\tpublic void close() throws Exception &#123;\n\t\tSystem.out.println(&quot;input stream is closed.&quot;);\n\t&#125;\n\n&#125;\n\nclass MyOutputStream implements AutoCloseable &#123;\n\n\tvoid write(String content) &#123;\n\t\tSystem.out.println(&quot;write content &quot; + content);\n\t&#125;\n\n\t@Override\n\tpublic void close() throws Exception &#123;\n\t\tSystem.out.println(&quot;out stream is closed.&quot;);\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>单个资源自动关闭</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">try (MyInputStream mis &#x3D; new MyInputStream()) &#123;\n\tmis.read(&quot;7_2&quot;);\n&#125; catch (Exception e) &#123;\n\te.printStackTrace();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出：</p>\n<blockquote>\n<p>read content 7_2<br>input stream is closed.</p>\n</blockquote>\n<p><strong>多个资源自动关闭</strong></p>\n<p><code>try()</code>里面可以定义多个资源，它们的关闭顺序是最后在<code>try()</code>定义的资源先关闭。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">try (MyInputStream mis &#x3D; new MyInputStream(); MyOutputStream mos &#x3D; new MyOutputStream()) &#123;\n\tmis.read(&quot;7_3&quot;);\n\tmos.write(&quot;7_3&quot;);\n&#125; catch (Exception e) &#123;\n\te.printStackTrace();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出：</p>\n<blockquote>\n<p>read content 7_3<br>write content 7_3<br>out stream is closed.<br>input stream is closed.</p>\n</blockquote>\n<h4 id=\"JDK9\"><a href=\"#JDK9\" class=\"headerlink\" title=\"JDK9\"></a>JDK9</h4><p>JDK9发布后，又简化了try-with-resources语句的用法。</p>\n<p><code>try()</code>里面可以是一个变量，但必须是final的或者等同final才行。如下面的mis，mos定义成局部变量可以不用final，局部变量可以等同于final，但定义成成员变量就必须是用final修饰的，不然会编译错误。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">MyInputStream mis &#x3D; new MyInputStream();\nMyOutputStream mos &#x3D; new MyOutputStream();\ntry (mis; mos) &#123;\n\tmis.read(&quot;1.9&quot;);\n\tmos.write(&quot;1.9&quot;);\n&#125; catch (Exception e) &#123;\n\te.printStackTrace();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出：</p>\n<blockquote>\n<p>read content 1.9<br>write content 1.9<br>out stream is closed.<br>input stream is closed.</p>\n</blockquote>\n<p>再来看个例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Connection dbCon &#x3D; DriverManager.getConnection(&quot;url&quot;, &quot;user&quot;, &quot;password&quot;);\ntry (dbCon; ResultSet rs &#x3D; dbCon.createStatement().executeQuery(&quot;select * from emp&quot;)) &#123;\n    while (rs.next()) &#123;\n        System.out.println(&quot;In loadDataFromDB() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + rs.getString(1));\n    &#125;\n&#125; catch (SQLException e) &#123;\n    System.out.println(&quot;Exception occurs while reading the data from DB -&gt;&quot; + e.getMessage());\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>dbCon和rs都能被自动关闭。</p>\n<p>JKD9虽然简化了，但感觉还是没有什么质的变化，实际用途我们可能不希望关心资源的关闭，或者在方法结束之后如果是局部变量它就能自动关闭。或许是我站的高度不够，官方有其他的考量，但JDK9的这一点变化还是非常有用的。</p>\n<p>更多JDK9的新功能实战陆续更新，如果觉得有用，分享到朋友圈给更多的人吧！</p>\n"},{"title":"Java 8 创建 Stream 的 10 种方式，我保证你受益无穷!","date":"2025-10-15T03:36:33.000Z","_content":"\n![](http://img.javastack.cn/20190613135450.png)\n![](http://img.javastack.cn/20190613135537.png)\n\n\n今天来分享下在 Java 8 中创建 Stream 的 10 种方式，我就整理了 10 种，其实还有更多，仅供大家参考学习下。\n\n## 1、Stream.of 可变参数\n\n```\nStream<String> stream1 = Stream.of(\"A\", \"B\", \"C\");\nSystem.out.println(\"stream1:\" + stream1.collect(joining()));\n```\n\n程序输出：\n\n> stream1:ABC\n\n## 2、Stream.of 数组\n\n```\nString[] values = new String[]{\"A\", \"B\", \"C\"};\nStream<String> stream2 = Stream.of(values);\nSystem.out.println(\"stream2:\" + stream2.collect(joining()));\n```\n\n程序输出：\n\n> stream2:ABC\n\n看 Stream.of 源码，上面这两种方式其实就是第三种方式的包装版。\n\n```\npublic static<T> Stream<T> of(T... values) {\n    return Arrays.stream(values);\n}\n```\n\n我们直接使用源码中的方式也是一样的。\n\n## 3、Arrays.stream\n\n```\nString[] values = new String[]{\"A\", \"B\", \"C\"};\nStream<String> stream3 = Arrays.stream(values);\nSystem.out.println(\"stream3:\" + stream3.collect(joining()));\n```\n\n程序输出：\n\n> stream3:ABC\n\n## 4、List\n\n```\nList<String> list = Arrays.asList(\"A\", \"B\", \"C\");\nStream<String> stream4 = list.stream();\nSystem.out.println(\"stream4:\" + stream4.collect(joining()));\n```\n\n程序输出：\n\n> stream4:ABC\n\n## 5、Set\n\n```\nSet<String> set = new HashSet<>(Arrays.asList(\"A\", \"B\", \"C\"));\nStream<String> stream5 = set.stream();\nSystem.out.println(\"stream5:\" + stream5.collect(joining()));\n```\n\n程序输出：\n\n> stream5:ABC\n\n## 6、Map\n\n```\nMap<String, String> map = new HashMap<>();\nmap.put(\"1\", \"A\");\nmap.put(\"2\", \"B\");\nmap.put(\"3\", \"C\");\nStream<String> stream6 = map.values().stream();\nSystem.out.println(\"stream6:\" + stream6.collect(joining()));\n```\n\n程序输出：\n\n> stream6:ABC\n\n## 7、Stream.iterate\n\n```\nStream<String> stream7 = Stream.iterate(\"A\", e -> String.valueOf((char) (e.charAt(0) + 1))).limit(3);\nSystem.out.println(\"stream7:\" + stream7.collect(joining()));\n```\n\n程序输出：\n\n> stream7:ABC\n\n## 8、Pattern\n\n```\nString value = \"A B C\";\nStream<String> stream8 = Pattern.compile(\"\\\\W\").splitAsStream(value);\nSystem.out.println(\"stream8:\" + stream8.collect(joining()));\n```\n\n程序输出：\n\n> stream8:ABC\n\n## 9、Files.lines\n\n```\ntry {\n    Stream<String> stream9 = Files.lines(Paths.get(\"d:/data.txt\"));\n    System.out.println(\"stream9:\" + stream9.collect(joining()));\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\ndata.txt文件内容如下：\n\n```\nA\nB\nC\n```\n\n程序输出：\n\n> stream9:ABC\n\n## 10、Stream.generate\n\n```\nStream<String> stream10 = Stream.generate(() -> \"A\").limit(3);\nSystem.out.println(\"stream10:\" + stream10.collect(joining()));\n```\n\n程序输出：\n\n> stream10:AAA\n\n好了，这是栈长整理的 10 种创建 Stream 的方式，是不是很骚？如果你还知道其他的骚操作，可以留言告诉大家，让大家记住你的头像和ID。\n\n\n \n","source":"_posts/新特性/Java8/Stream/Java 8 创建 Stream 的 10 种方式，我保证你受益无穷!.md","raw":"---\ntitle: Java 8 创建 Stream 的 10 种方式，我保证你受益无穷!\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n\n![](http://img.javastack.cn/20190613135450.png)\n![](http://img.javastack.cn/20190613135537.png)\n\n\n今天来分享下在 Java 8 中创建 Stream 的 10 种方式，我就整理了 10 种，其实还有更多，仅供大家参考学习下。\n\n## 1、Stream.of 可变参数\n\n```\nStream<String> stream1 = Stream.of(\"A\", \"B\", \"C\");\nSystem.out.println(\"stream1:\" + stream1.collect(joining()));\n```\n\n程序输出：\n\n> stream1:ABC\n\n## 2、Stream.of 数组\n\n```\nString[] values = new String[]{\"A\", \"B\", \"C\"};\nStream<String> stream2 = Stream.of(values);\nSystem.out.println(\"stream2:\" + stream2.collect(joining()));\n```\n\n程序输出：\n\n> stream2:ABC\n\n看 Stream.of 源码，上面这两种方式其实就是第三种方式的包装版。\n\n```\npublic static<T> Stream<T> of(T... values) {\n    return Arrays.stream(values);\n}\n```\n\n我们直接使用源码中的方式也是一样的。\n\n## 3、Arrays.stream\n\n```\nString[] values = new String[]{\"A\", \"B\", \"C\"};\nStream<String> stream3 = Arrays.stream(values);\nSystem.out.println(\"stream3:\" + stream3.collect(joining()));\n```\n\n程序输出：\n\n> stream3:ABC\n\n## 4、List\n\n```\nList<String> list = Arrays.asList(\"A\", \"B\", \"C\");\nStream<String> stream4 = list.stream();\nSystem.out.println(\"stream4:\" + stream4.collect(joining()));\n```\n\n程序输出：\n\n> stream4:ABC\n\n## 5、Set\n\n```\nSet<String> set = new HashSet<>(Arrays.asList(\"A\", \"B\", \"C\"));\nStream<String> stream5 = set.stream();\nSystem.out.println(\"stream5:\" + stream5.collect(joining()));\n```\n\n程序输出：\n\n> stream5:ABC\n\n## 6、Map\n\n```\nMap<String, String> map = new HashMap<>();\nmap.put(\"1\", \"A\");\nmap.put(\"2\", \"B\");\nmap.put(\"3\", \"C\");\nStream<String> stream6 = map.values().stream();\nSystem.out.println(\"stream6:\" + stream6.collect(joining()));\n```\n\n程序输出：\n\n> stream6:ABC\n\n## 7、Stream.iterate\n\n```\nStream<String> stream7 = Stream.iterate(\"A\", e -> String.valueOf((char) (e.charAt(0) + 1))).limit(3);\nSystem.out.println(\"stream7:\" + stream7.collect(joining()));\n```\n\n程序输出：\n\n> stream7:ABC\n\n## 8、Pattern\n\n```\nString value = \"A B C\";\nStream<String> stream8 = Pattern.compile(\"\\\\W\").splitAsStream(value);\nSystem.out.println(\"stream8:\" + stream8.collect(joining()));\n```\n\n程序输出：\n\n> stream8:ABC\n\n## 9、Files.lines\n\n```\ntry {\n    Stream<String> stream9 = Files.lines(Paths.get(\"d:/data.txt\"));\n    System.out.println(\"stream9:\" + stream9.collect(joining()));\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\ndata.txt文件内容如下：\n\n```\nA\nB\nC\n```\n\n程序输出：\n\n> stream9:ABC\n\n## 10、Stream.generate\n\n```\nStream<String> stream10 = Stream.generate(() -> \"A\").limit(3);\nSystem.out.println(\"stream10:\" + stream10.collect(joining()));\n```\n\n程序输出：\n\n> stream10:AAA\n\n好了，这是栈长整理的 10 种创建 Stream 的方式，是不是很骚？如果你还知道其他的骚操作，可以留言告诉大家，让大家记住你的头像和ID。\n\n\n \n","slug":"新特性/Java8/Stream/Java 8 创建 Stream 的 10 种方式，我保证你受益无穷!","published":1,"updated":"2025-10-15T07:20:51.449Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu0778006fqkd4ae9z6hs8","content":"<p><img src=\"http://img.javastack.cn/20190613135450.png\"><br><img src=\"http://img.javastack.cn/20190613135537.png\"></p>\n<p>今天来分享下在 Java 8 中创建 Stream 的 10 种方式，我就整理了 10 种，其实还有更多，仅供大家参考学习下。</p>\n<h2 id=\"1、Stream-of-可变参数\"><a href=\"#1、Stream-of-可变参数\" class=\"headerlink\" title=\"1、Stream.of 可变参数\"></a>1、Stream.of 可变参数</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">Stream&lt;String&gt; stream1 &#x3D; Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);\nSystem.out.println(&quot;stream1:&quot; + stream1.collect(joining()));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<blockquote>\n<p>stream1:ABC</p>\n</blockquote>\n<h2 id=\"2、Stream-of-数组\"><a href=\"#2、Stream-of-数组\" class=\"headerlink\" title=\"2、Stream.of 数组\"></a>2、Stream.of 数组</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">String[] values &#x3D; new String[]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;;\nStream&lt;String&gt; stream2 &#x3D; Stream.of(values);\nSystem.out.println(&quot;stream2:&quot; + stream2.collect(joining()));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<blockquote>\n<p>stream2:ABC</p>\n</blockquote>\n<p>看 Stream.of 源码，上面这两种方式其实就是第三种方式的包装版。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static&lt;T&gt; Stream&lt;T&gt; of(T... values) &#123;\n    return Arrays.stream(values);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>我们直接使用源码中的方式也是一样的。</p>\n<h2 id=\"3、Arrays-stream\"><a href=\"#3、Arrays-stream\" class=\"headerlink\" title=\"3、Arrays.stream\"></a>3、Arrays.stream</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">String[] values &#x3D; new String[]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;;\nStream&lt;String&gt; stream3 &#x3D; Arrays.stream(values);\nSystem.out.println(&quot;stream3:&quot; + stream3.collect(joining()));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<blockquote>\n<p>stream3:ABC</p>\n</blockquote>\n<h2 id=\"4、List\"><a href=\"#4、List\" class=\"headerlink\" title=\"4、List\"></a>4、List</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; list &#x3D; Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);\nStream&lt;String&gt; stream4 &#x3D; list.stream();\nSystem.out.println(&quot;stream4:&quot; + stream4.collect(joining()));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<blockquote>\n<p>stream4:ABC</p>\n</blockquote>\n<h2 id=\"5、Set\"><a href=\"#5、Set\" class=\"headerlink\" title=\"5、Set\"></a>5、Set</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;(Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;));\nStream&lt;String&gt; stream5 &#x3D; set.stream();\nSystem.out.println(&quot;stream5:&quot; + stream5.collect(joining()));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<blockquote>\n<p>stream5:ABC</p>\n</blockquote>\n<h2 id=\"6、Map\"><a href=\"#6、Map\" class=\"headerlink\" title=\"6、Map\"></a>6、Map</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();\nmap.put(&quot;1&quot;, &quot;A&quot;);\nmap.put(&quot;2&quot;, &quot;B&quot;);\nmap.put(&quot;3&quot;, &quot;C&quot;);\nStream&lt;String&gt; stream6 &#x3D; map.values().stream();\nSystem.out.println(&quot;stream6:&quot; + stream6.collect(joining()));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<blockquote>\n<p>stream6:ABC</p>\n</blockquote>\n<h2 id=\"7、Stream-iterate\"><a href=\"#7、Stream-iterate\" class=\"headerlink\" title=\"7、Stream.iterate\"></a>7、Stream.iterate</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">Stream&lt;String&gt; stream7 &#x3D; Stream.iterate(&quot;A&quot;, e -&gt; String.valueOf((char) (e.charAt(0) + 1))).limit(3);\nSystem.out.println(&quot;stream7:&quot; + stream7.collect(joining()));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<blockquote>\n<p>stream7:ABC</p>\n</blockquote>\n<h2 id=\"8、Pattern\"><a href=\"#8、Pattern\" class=\"headerlink\" title=\"8、Pattern\"></a>8、Pattern</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">String value &#x3D; &quot;A B C&quot;;\nStream&lt;String&gt; stream8 &#x3D; Pattern.compile(&quot;\\\\W&quot;).splitAsStream(value);\nSystem.out.println(&quot;stream8:&quot; + stream8.collect(joining()));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<blockquote>\n<p>stream8:ABC</p>\n</blockquote>\n<h2 id=\"9、Files-lines\"><a href=\"#9、Files-lines\" class=\"headerlink\" title=\"9、Files.lines\"></a>9、Files.lines</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">try &#123;\n    Stream&lt;String&gt; stream9 &#x3D; Files.lines(Paths.get(&quot;d:&#x2F;data.txt&quot;));\n    System.out.println(&quot;stream9:&quot; + stream9.collect(joining()));\n&#125; catch (IOException e) &#123;\n    e.printStackTrace();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>data.txt文件内容如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">A\nB\nC<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<blockquote>\n<p>stream9:ABC</p>\n</blockquote>\n<h2 id=\"10、Stream-generate\"><a href=\"#10、Stream-generate\" class=\"headerlink\" title=\"10、Stream.generate\"></a>10、Stream.generate</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">Stream&lt;String&gt; stream10 &#x3D; Stream.generate(() -&gt; &quot;A&quot;).limit(3);\nSystem.out.println(&quot;stream10:&quot; + stream10.collect(joining()));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<blockquote>\n<p>stream10:AAA</p>\n</blockquote>\n<p>好了，这是栈长整理的 10 种创建 Stream 的方式，是不是很骚？如果你还知道其他的骚操作，可以留言告诉大家，让大家记住你的头像和ID。</p>\n","excerpt":"","more":"<p><img src=\"http://img.javastack.cn/20190613135450.png\"><br><img src=\"http://img.javastack.cn/20190613135537.png\"></p>\n<p>今天来分享下在 Java 8 中创建 Stream 的 10 种方式，我就整理了 10 种，其实还有更多，仅供大家参考学习下。</p>\n<h2 id=\"1、Stream-of-可变参数\"><a href=\"#1、Stream-of-可变参数\" class=\"headerlink\" title=\"1、Stream.of 可变参数\"></a>1、Stream.of 可变参数</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">Stream&lt;String&gt; stream1 &#x3D; Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);\nSystem.out.println(&quot;stream1:&quot; + stream1.collect(joining()));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<blockquote>\n<p>stream1:ABC</p>\n</blockquote>\n<h2 id=\"2、Stream-of-数组\"><a href=\"#2、Stream-of-数组\" class=\"headerlink\" title=\"2、Stream.of 数组\"></a>2、Stream.of 数组</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">String[] values &#x3D; new String[]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;;\nStream&lt;String&gt; stream2 &#x3D; Stream.of(values);\nSystem.out.println(&quot;stream2:&quot; + stream2.collect(joining()));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<blockquote>\n<p>stream2:ABC</p>\n</blockquote>\n<p>看 Stream.of 源码，上面这两种方式其实就是第三种方式的包装版。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static&lt;T&gt; Stream&lt;T&gt; of(T... values) &#123;\n    return Arrays.stream(values);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>我们直接使用源码中的方式也是一样的。</p>\n<h2 id=\"3、Arrays-stream\"><a href=\"#3、Arrays-stream\" class=\"headerlink\" title=\"3、Arrays.stream\"></a>3、Arrays.stream</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">String[] values &#x3D; new String[]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;;\nStream&lt;String&gt; stream3 &#x3D; Arrays.stream(values);\nSystem.out.println(&quot;stream3:&quot; + stream3.collect(joining()));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<blockquote>\n<p>stream3:ABC</p>\n</blockquote>\n<h2 id=\"4、List\"><a href=\"#4、List\" class=\"headerlink\" title=\"4、List\"></a>4、List</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;String&gt; list &#x3D; Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);\nStream&lt;String&gt; stream4 &#x3D; list.stream();\nSystem.out.println(&quot;stream4:&quot; + stream4.collect(joining()));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<blockquote>\n<p>stream4:ABC</p>\n</blockquote>\n<h2 id=\"5、Set\"><a href=\"#5、Set\" class=\"headerlink\" title=\"5、Set\"></a>5、Set</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;(Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;));\nStream&lt;String&gt; stream5 &#x3D; set.stream();\nSystem.out.println(&quot;stream5:&quot; + stream5.collect(joining()));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<blockquote>\n<p>stream5:ABC</p>\n</blockquote>\n<h2 id=\"6、Map\"><a href=\"#6、Map\" class=\"headerlink\" title=\"6、Map\"></a>6、Map</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();\nmap.put(&quot;1&quot;, &quot;A&quot;);\nmap.put(&quot;2&quot;, &quot;B&quot;);\nmap.put(&quot;3&quot;, &quot;C&quot;);\nStream&lt;String&gt; stream6 &#x3D; map.values().stream();\nSystem.out.println(&quot;stream6:&quot; + stream6.collect(joining()));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<blockquote>\n<p>stream6:ABC</p>\n</blockquote>\n<h2 id=\"7、Stream-iterate\"><a href=\"#7、Stream-iterate\" class=\"headerlink\" title=\"7、Stream.iterate\"></a>7、Stream.iterate</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">Stream&lt;String&gt; stream7 &#x3D; Stream.iterate(&quot;A&quot;, e -&gt; String.valueOf((char) (e.charAt(0) + 1))).limit(3);\nSystem.out.println(&quot;stream7:&quot; + stream7.collect(joining()));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<blockquote>\n<p>stream7:ABC</p>\n</blockquote>\n<h2 id=\"8、Pattern\"><a href=\"#8、Pattern\" class=\"headerlink\" title=\"8、Pattern\"></a>8、Pattern</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">String value &#x3D; &quot;A B C&quot;;\nStream&lt;String&gt; stream8 &#x3D; Pattern.compile(&quot;\\\\W&quot;).splitAsStream(value);\nSystem.out.println(&quot;stream8:&quot; + stream8.collect(joining()));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<blockquote>\n<p>stream8:ABC</p>\n</blockquote>\n<h2 id=\"9、Files-lines\"><a href=\"#9、Files-lines\" class=\"headerlink\" title=\"9、Files.lines\"></a>9、Files.lines</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">try &#123;\n    Stream&lt;String&gt; stream9 &#x3D; Files.lines(Paths.get(&quot;d:&#x2F;data.txt&quot;));\n    System.out.println(&quot;stream9:&quot; + stream9.collect(joining()));\n&#125; catch (IOException e) &#123;\n    e.printStackTrace();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>data.txt文件内容如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">A\nB\nC<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<blockquote>\n<p>stream9:ABC</p>\n</blockquote>\n<h2 id=\"10、Stream-generate\"><a href=\"#10、Stream-generate\" class=\"headerlink\" title=\"10、Stream.generate\"></a>10、Stream.generate</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">Stream&lt;String&gt; stream10 &#x3D; Stream.generate(() -&gt; &quot;A&quot;).limit(3);\nSystem.out.println(&quot;stream10:&quot; + stream10.collect(joining()));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>程序输出：</p>\n<blockquote>\n<p>stream10:AAA</p>\n</blockquote>\n<p>好了，这是栈长整理的 10 种创建 Stream 的方式，是不是很骚？如果你还知道其他的骚操作，可以留言告诉大家，让大家记住你的头像和ID。</p>\n"},{"title":"Java 8 新特性之 Stream 流（七）流与迭代器，流系列大结局！","date":"2025-10-15T03:36:33.000Z","_content":"\n恭喜你们，马上就要学完Java8 Stream流的一整系列了，其实我相信Stream流对很多使用Java的同学来说，都是一个知识盲点，因为这个原因，我才这么细致地讲解Stream流的各个知识点，通过这一整个系列，我相信只要认真看了的同学，都已掌握的差不多了，就差实战了。\n\n其实我在工作过程中，Stream流对我的帮助真的挺大的，所以，我想和大家分享一下，于是这系列的文章就出来了。\n\n在本系列文章发布的时候，有很多同学反映，Stream流的调试和forEach()的调试都不是特别友好，那本篇给出一个折中的调试方法，虽然不能完美解决调试的问题，但是基本上已经能解决绝大部分的调试问题了，没错，就是迭代器了，当然迭代器除了能辅助调试以外，他最重要的还是遍历功能。\n\n这篇文章除了介绍传统的迭代器外，还会介绍Java8中新增的Spliterator，因为在并行流的场合，Spliterator相当的好用。\n\n#### 我们先简单介绍一下传统的迭代器\n\n迭代器是实现了Iterator接口的对象，并且Iterator接口允许遍历，获取或者移除元素。\n\n```\npublic interface Iterator<E> {\n  Iterator<T> iterator();\n  E next();\n  default void remove() {\n        throw new UnsupportedOperationException(\"remove\");\n  }\n  default void forEachRemaining(Consumer<? super E> action) {\n        Objects.requireNonNull(action);\n        while (hasNext())\n            action.accept(next());\n  }\n\n}\n```\n\n使用Iterator的一般步骤：\n\n* (1)通过iterator()方法，获取指向集合或流开头的迭代器。\n\n* (2)建立一个hasNext()方法调用循环，只要hasNext()返回true,就继续迭代。\n\n* (3)在循环中，通过调用next()方法获取每个元素。\n\n```\nprivate static void learnIterator() {\n    List<String> lists = Arrays.asList(\"A\", \"B\", \"C\", \"D\");\n\n    Iterator<String> iterator = lists.stream().iterator();\n\n    while (iterator.hasNext()) {\n        System.out.println(iterator.next());\n    }\n}\n```\n\n但是如果我们不修改集合的情况下，使用forEach()其实更加便利的，其实两种方式本质上面是一样的，在你编译之后，forEach()会转换成迭代器的方式进行操作了。有了迭代器，相信调试就得方便起来了，即使不能直接调试，也可以通过迭代器，反推之前，可能发生了什么。\n\n值得注意的一点是：Java8给基本类型的流提供了额外的迭代器：PrimitiveIterator.OfInt,PrimitiveIterator.OfDouble,PrimitiveIterator.OfLong,PrimitiveIterator,但这些接口都是来扩展自Iterator接口的，所以使用上面也是相同的。\n\n#### Spliterator\n\nSpliterator是Java8新增的一种迭代器，这种迭代器由`Spliterator`接口定义，Spliterator也有普通的遍历元素功能，这一点与刚才说的迭代器类似的，但是，但是Spliterator方法和使用迭代器的方法是不同的。\n\n另外，它提供的功能要比Iterator多。最终要的一点，Spliterator支持并行迭代。\n\n```\npublic interface Spliterator<T> {\n    boolean tryAdvance(Consumer<? super T> action);\n    int characteristics();\n    long estimateSize();\n   Spliterator<T> trySplit();\n   default void forEachRemaining(Consumer<? super T> action) {\n        do { } while (tryAdvance(action));\n   }\n}\n```\n\n将Spliterator用于基本迭代任务是非常简单的，只需要调用tryAdvance()方法，直至其返回false.如果要为序列中的每个元素应用相同的动作，那么forEachRemaining()提供了一种更加高效的替代方法。\n\n对于这两个方法，在每次迭代中将发生的动作都由`Consumer`对象定义的操作来决定，`Consumer`也是一个函数式接口，估计大家已经知道怎么分析了，这里就不带大家分析了，他的动作是指定了在迭代中下一个元素上执行的操作。下面来一个简单的例子：\n\n```\nprivate static void learnIterator() {\n    List<String> lists = Arrays.asList(\"A\", \"B\", \"C\", \"D\");\n\n    Spliterator<String> spliterator = lists.stream().spliterator();\n\n    while (spliterator.tryAdvance(System.out::println));\n}\n```\n\n使用forEachRemaining()方法改进这个例子：\n\n```\nprivate static void learnIterator() {\n    List<String> lists = Arrays.asList(\"A\", \"B\", \"C\", \"D\");\n    lists.stream().spliterator().forEachRemaining(System.out::println);\n}\n```\n\n注意，使用这个方法时，不需要提供一个循环来一次处理一个元素，而是将各个元素作为一个整体来对待，这是Spliterator的又一个优势。\n\nSpliterator的另一个值得注意的方法是trySplit()，它将被迭代的元素划分成了两部分，返回其中一部分的新Spliterator,另一部分则通过原来的Spliterator访问。下面再给一个简单的例子\n\n```\nprivate static void learnIterator() {\n    List<String> lists = Arrays.asList(\"A\", \"B\", \"C\", \"D\");\n\n    Spliterator<String> spliterator = lists.stream().spliterator();\n\n    Spliterator<String> stringSpliterator = spliterator.trySplit();\n\n    if (stringSpliterator != null) stringSpliterator.forEachRemaining(System.out::println);\n\n    System.out.println(\"------------------\");\n\n    spliterator.forEachRemaining(System.out::println);\n}\n```\n\n打印的结果：\n\n```\nA\nB\n------------------\nC\nD\n```\n\n这里只是给大家提供了这种方式而已，例子本身没有什么含义，但是当你对大数据集执行并行处理时，拆分可能是极有帮助的了。但更多情况下，要对流执行并行操作时，使用其他某个Stream方法更好，而不必手动处理Spliterator的这些细节，Spliterator最适合的场景是，给定的所有方法都不能满足你的要求时，才考虑。\n\n#### 最后来一个总结\n\n到这里，Java8 Stream流的知识，基本上已经介绍完了，缩减操作，并行流，映射，还有收集是Stream流的核心内容，但是要想掌握好这些内容，第二篇的基本知识你是跑不掉的，因此我的建议还是老老实实，从第一篇开始认真看，看完这7篇文章，你基本已经非常系统地掌握Java8的Stream流知识了。\n\n大家也不要忘记`Collectors`类，里面提供给我们的方法，基本上能处理各种各样的收集元素问题了，如果你从第一篇文章开始看，一直看到这里了，那你以后尽量多使用Stream流来处理集合吧，只是学会这些知识是没有用的，要多在你们的项目中运用他们，这样才能更加好地理解，如果大家在使有的过程中遇到什么样的问题，欢迎来这里面留言，我看到了，一定第一时间和大家一起探索解决的方法。\n\n","source":"_posts/新特性/Java8/Stream/Java 8 新特性之 Stream 流（七）流与迭代器，流系列大结局！.md","raw":"---\ntitle: Java 8 新特性之 Stream 流（七）流与迭代器，流系列大结局！\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n\n恭喜你们，马上就要学完Java8 Stream流的一整系列了，其实我相信Stream流对很多使用Java的同学来说，都是一个知识盲点，因为这个原因，我才这么细致地讲解Stream流的各个知识点，通过这一整个系列，我相信只要认真看了的同学，都已掌握的差不多了，就差实战了。\n\n其实我在工作过程中，Stream流对我的帮助真的挺大的，所以，我想和大家分享一下，于是这系列的文章就出来了。\n\n在本系列文章发布的时候，有很多同学反映，Stream流的调试和forEach()的调试都不是特别友好，那本篇给出一个折中的调试方法，虽然不能完美解决调试的问题，但是基本上已经能解决绝大部分的调试问题了，没错，就是迭代器了，当然迭代器除了能辅助调试以外，他最重要的还是遍历功能。\n\n这篇文章除了介绍传统的迭代器外，还会介绍Java8中新增的Spliterator，因为在并行流的场合，Spliterator相当的好用。\n\n#### 我们先简单介绍一下传统的迭代器\n\n迭代器是实现了Iterator接口的对象，并且Iterator接口允许遍历，获取或者移除元素。\n\n```\npublic interface Iterator<E> {\n  Iterator<T> iterator();\n  E next();\n  default void remove() {\n        throw new UnsupportedOperationException(\"remove\");\n  }\n  default void forEachRemaining(Consumer<? super E> action) {\n        Objects.requireNonNull(action);\n        while (hasNext())\n            action.accept(next());\n  }\n\n}\n```\n\n使用Iterator的一般步骤：\n\n* (1)通过iterator()方法，获取指向集合或流开头的迭代器。\n\n* (2)建立一个hasNext()方法调用循环，只要hasNext()返回true,就继续迭代。\n\n* (3)在循环中，通过调用next()方法获取每个元素。\n\n```\nprivate static void learnIterator() {\n    List<String> lists = Arrays.asList(\"A\", \"B\", \"C\", \"D\");\n\n    Iterator<String> iterator = lists.stream().iterator();\n\n    while (iterator.hasNext()) {\n        System.out.println(iterator.next());\n    }\n}\n```\n\n但是如果我们不修改集合的情况下，使用forEach()其实更加便利的，其实两种方式本质上面是一样的，在你编译之后，forEach()会转换成迭代器的方式进行操作了。有了迭代器，相信调试就得方便起来了，即使不能直接调试，也可以通过迭代器，反推之前，可能发生了什么。\n\n值得注意的一点是：Java8给基本类型的流提供了额外的迭代器：PrimitiveIterator.OfInt,PrimitiveIterator.OfDouble,PrimitiveIterator.OfLong,PrimitiveIterator,但这些接口都是来扩展自Iterator接口的，所以使用上面也是相同的。\n\n#### Spliterator\n\nSpliterator是Java8新增的一种迭代器，这种迭代器由`Spliterator`接口定义，Spliterator也有普通的遍历元素功能，这一点与刚才说的迭代器类似的，但是，但是Spliterator方法和使用迭代器的方法是不同的。\n\n另外，它提供的功能要比Iterator多。最终要的一点，Spliterator支持并行迭代。\n\n```\npublic interface Spliterator<T> {\n    boolean tryAdvance(Consumer<? super T> action);\n    int characteristics();\n    long estimateSize();\n   Spliterator<T> trySplit();\n   default void forEachRemaining(Consumer<? super T> action) {\n        do { } while (tryAdvance(action));\n   }\n}\n```\n\n将Spliterator用于基本迭代任务是非常简单的，只需要调用tryAdvance()方法，直至其返回false.如果要为序列中的每个元素应用相同的动作，那么forEachRemaining()提供了一种更加高效的替代方法。\n\n对于这两个方法，在每次迭代中将发生的动作都由`Consumer`对象定义的操作来决定，`Consumer`也是一个函数式接口，估计大家已经知道怎么分析了，这里就不带大家分析了，他的动作是指定了在迭代中下一个元素上执行的操作。下面来一个简单的例子：\n\n```\nprivate static void learnIterator() {\n    List<String> lists = Arrays.asList(\"A\", \"B\", \"C\", \"D\");\n\n    Spliterator<String> spliterator = lists.stream().spliterator();\n\n    while (spliterator.tryAdvance(System.out::println));\n}\n```\n\n使用forEachRemaining()方法改进这个例子：\n\n```\nprivate static void learnIterator() {\n    List<String> lists = Arrays.asList(\"A\", \"B\", \"C\", \"D\");\n    lists.stream().spliterator().forEachRemaining(System.out::println);\n}\n```\n\n注意，使用这个方法时，不需要提供一个循环来一次处理一个元素，而是将各个元素作为一个整体来对待，这是Spliterator的又一个优势。\n\nSpliterator的另一个值得注意的方法是trySplit()，它将被迭代的元素划分成了两部分，返回其中一部分的新Spliterator,另一部分则通过原来的Spliterator访问。下面再给一个简单的例子\n\n```\nprivate static void learnIterator() {\n    List<String> lists = Arrays.asList(\"A\", \"B\", \"C\", \"D\");\n\n    Spliterator<String> spliterator = lists.stream().spliterator();\n\n    Spliterator<String> stringSpliterator = spliterator.trySplit();\n\n    if (stringSpliterator != null) stringSpliterator.forEachRemaining(System.out::println);\n\n    System.out.println(\"------------------\");\n\n    spliterator.forEachRemaining(System.out::println);\n}\n```\n\n打印的结果：\n\n```\nA\nB\n------------------\nC\nD\n```\n\n这里只是给大家提供了这种方式而已，例子本身没有什么含义，但是当你对大数据集执行并行处理时，拆分可能是极有帮助的了。但更多情况下，要对流执行并行操作时，使用其他某个Stream方法更好，而不必手动处理Spliterator的这些细节，Spliterator最适合的场景是，给定的所有方法都不能满足你的要求时，才考虑。\n\n#### 最后来一个总结\n\n到这里，Java8 Stream流的知识，基本上已经介绍完了，缩减操作，并行流，映射，还有收集是Stream流的核心内容，但是要想掌握好这些内容，第二篇的基本知识你是跑不掉的，因此我的建议还是老老实实，从第一篇开始认真看，看完这7篇文章，你基本已经非常系统地掌握Java8的Stream流知识了。\n\n大家也不要忘记`Collectors`类，里面提供给我们的方法，基本上能处理各种各样的收集元素问题了，如果你从第一篇文章开始看，一直看到这里了，那你以后尽量多使用Stream流来处理集合吧，只是学会这些知识是没有用的，要多在你们的项目中运用他们，这样才能更加好地理解，如果大家在使有的过程中遇到什么样的问题，欢迎来这里面留言，我看到了，一定第一时间和大家一起探索解决的方法。\n\n","slug":"新特性/Java8/Stream/Java 8 新特性之 Stream 流（七）流与迭代器，流系列大结局！","published":1,"updated":"2025-10-15T07:20:51.465Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu0779006iqkd45sit7qro","content":"<p>恭喜你们，马上就要学完Java8 Stream流的一整系列了，其实我相信Stream流对很多使用Java的同学来说，都是一个知识盲点，因为这个原因，我才这么细致地讲解Stream流的各个知识点，通过这一整个系列，我相信只要认真看了的同学，都已掌握的差不多了，就差实战了。</p>\n<p>其实我在工作过程中，Stream流对我的帮助真的挺大的，所以，我想和大家分享一下，于是这系列的文章就出来了。</p>\n<p>在本系列文章发布的时候，有很多同学反映，Stream流的调试和forEach()的调试都不是特别友好，那本篇给出一个折中的调试方法，虽然不能完美解决调试的问题，但是基本上已经能解决绝大部分的调试问题了，没错，就是迭代器了，当然迭代器除了能辅助调试以外，他最重要的还是遍历功能。</p>\n<p>这篇文章除了介绍传统的迭代器外，还会介绍Java8中新增的Spliterator，因为在并行流的场合，Spliterator相当的好用。</p>\n<h4 id=\"我们先简单介绍一下传统的迭代器\"><a href=\"#我们先简单介绍一下传统的迭代器\" class=\"headerlink\" title=\"我们先简单介绍一下传统的迭代器\"></a>我们先简单介绍一下传统的迭代器</h4><p>迭代器是实现了Iterator接口的对象，并且Iterator接口允许遍历，获取或者移除元素。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface Iterator&lt;E&gt; &#123;\n  Iterator&lt;T&gt; iterator();\n  E next();\n  default void remove() &#123;\n        throw new UnsupportedOperationException(&quot;remove&quot;);\n  &#125;\n  default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;\n        Objects.requireNonNull(action);\n        while (hasNext())\n            action.accept(next());\n  &#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用Iterator的一般步骤：</p>\n<ul>\n<li><p>(1)通过iterator()方法，获取指向集合或流开头的迭代器。</p>\n</li>\n<li><p>(2)建立一个hasNext()方法调用循环，只要hasNext()返回true,就继续迭代。</p>\n</li>\n<li><p>(3)在循环中，通过调用next()方法获取每个元素。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void learnIterator() &#123;\n    List&lt;String&gt; lists &#x3D; Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;);\n\n    Iterator&lt;String&gt; iterator &#x3D; lists.stream().iterator();\n\n    while (iterator.hasNext()) &#123;\n        System.out.println(iterator.next());\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>但是如果我们不修改集合的情况下，使用forEach()其实更加便利的，其实两种方式本质上面是一样的，在你编译之后，forEach()会转换成迭代器的方式进行操作了。有了迭代器，相信调试就得方便起来了，即使不能直接调试，也可以通过迭代器，反推之前，可能发生了什么。</p>\n<p>值得注意的一点是：Java8给基本类型的流提供了额外的迭代器：PrimitiveIterator.OfInt,PrimitiveIterator.OfDouble,PrimitiveIterator.OfLong,PrimitiveIterator,但这些接口都是来扩展自Iterator接口的，所以使用上面也是相同的。</p>\n<h4 id=\"Spliterator\"><a href=\"#Spliterator\" class=\"headerlink\" title=\"Spliterator\"></a>Spliterator</h4><p>Spliterator是Java8新增的一种迭代器，这种迭代器由<code>Spliterator</code>接口定义，Spliterator也有普通的遍历元素功能，这一点与刚才说的迭代器类似的，但是，但是Spliterator方法和使用迭代器的方法是不同的。</p>\n<p>另外，它提供的功能要比Iterator多。最终要的一点，Spliterator支持并行迭代。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface Spliterator&lt;T&gt; &#123;\n    boolean tryAdvance(Consumer&lt;? super T&gt; action);\n    int characteristics();\n    long estimateSize();\n   Spliterator&lt;T&gt; trySplit();\n   default void forEachRemaining(Consumer&lt;? super T&gt; action) &#123;\n        do &#123; &#125; while (tryAdvance(action));\n   &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>将Spliterator用于基本迭代任务是非常简单的，只需要调用tryAdvance()方法，直至其返回false.如果要为序列中的每个元素应用相同的动作，那么forEachRemaining()提供了一种更加高效的替代方法。</p>\n<p>对于这两个方法，在每次迭代中将发生的动作都由<code>Consumer</code>对象定义的操作来决定，<code>Consumer</code>也是一个函数式接口，估计大家已经知道怎么分析了，这里就不带大家分析了，他的动作是指定了在迭代中下一个元素上执行的操作。下面来一个简单的例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void learnIterator() &#123;\n    List&lt;String&gt; lists &#x3D; Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;);\n\n    Spliterator&lt;String&gt; spliterator &#x3D; lists.stream().spliterator();\n\n    while (spliterator.tryAdvance(System.out::println));\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用forEachRemaining()方法改进这个例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void learnIterator() &#123;\n    List&lt;String&gt; lists &#x3D; Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;);\n    lists.stream().spliterator().forEachRemaining(System.out::println);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>注意，使用这个方法时，不需要提供一个循环来一次处理一个元素，而是将各个元素作为一个整体来对待，这是Spliterator的又一个优势。</p>\n<p>Spliterator的另一个值得注意的方法是trySplit()，它将被迭代的元素划分成了两部分，返回其中一部分的新Spliterator,另一部分则通过原来的Spliterator访问。下面再给一个简单的例子</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void learnIterator() &#123;\n    List&lt;String&gt; lists &#x3D; Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;);\n\n    Spliterator&lt;String&gt; spliterator &#x3D; lists.stream().spliterator();\n\n    Spliterator&lt;String&gt; stringSpliterator &#x3D; spliterator.trySplit();\n\n    if (stringSpliterator !&#x3D; null) stringSpliterator.forEachRemaining(System.out::println);\n\n    System.out.println(&quot;------------------&quot;);\n\n    spliterator.forEachRemaining(System.out::println);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>打印的结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">A\nB\n------------------\nC\nD<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里只是给大家提供了这种方式而已，例子本身没有什么含义，但是当你对大数据集执行并行处理时，拆分可能是极有帮助的了。但更多情况下，要对流执行并行操作时，使用其他某个Stream方法更好，而不必手动处理Spliterator的这些细节，Spliterator最适合的场景是，给定的所有方法都不能满足你的要求时，才考虑。</p>\n<h4 id=\"最后来一个总结\"><a href=\"#最后来一个总结\" class=\"headerlink\" title=\"最后来一个总结\"></a>最后来一个总结</h4><p>到这里，Java8 Stream流的知识，基本上已经介绍完了，缩减操作，并行流，映射，还有收集是Stream流的核心内容，但是要想掌握好这些内容，第二篇的基本知识你是跑不掉的，因此我的建议还是老老实实，从第一篇开始认真看，看完这7篇文章，你基本已经非常系统地掌握Java8的Stream流知识了。</p>\n<p>大家也不要忘记<code>Collectors</code>类，里面提供给我们的方法，基本上能处理各种各样的收集元素问题了，如果你从第一篇文章开始看，一直看到这里了，那你以后尽量多使用Stream流来处理集合吧，只是学会这些知识是没有用的，要多在你们的项目中运用他们，这样才能更加好地理解，如果大家在使有的过程中遇到什么样的问题，欢迎来这里面留言，我看到了，一定第一时间和大家一起探索解决的方法。</p>\n","excerpt":"","more":"<p>恭喜你们，马上就要学完Java8 Stream流的一整系列了，其实我相信Stream流对很多使用Java的同学来说，都是一个知识盲点，因为这个原因，我才这么细致地讲解Stream流的各个知识点，通过这一整个系列，我相信只要认真看了的同学，都已掌握的差不多了，就差实战了。</p>\n<p>其实我在工作过程中，Stream流对我的帮助真的挺大的，所以，我想和大家分享一下，于是这系列的文章就出来了。</p>\n<p>在本系列文章发布的时候，有很多同学反映，Stream流的调试和forEach()的调试都不是特别友好，那本篇给出一个折中的调试方法，虽然不能完美解决调试的问题，但是基本上已经能解决绝大部分的调试问题了，没错，就是迭代器了，当然迭代器除了能辅助调试以外，他最重要的还是遍历功能。</p>\n<p>这篇文章除了介绍传统的迭代器外，还会介绍Java8中新增的Spliterator，因为在并行流的场合，Spliterator相当的好用。</p>\n<h4 id=\"我们先简单介绍一下传统的迭代器\"><a href=\"#我们先简单介绍一下传统的迭代器\" class=\"headerlink\" title=\"我们先简单介绍一下传统的迭代器\"></a>我们先简单介绍一下传统的迭代器</h4><p>迭代器是实现了Iterator接口的对象，并且Iterator接口允许遍历，获取或者移除元素。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface Iterator&lt;E&gt; &#123;\n  Iterator&lt;T&gt; iterator();\n  E next();\n  default void remove() &#123;\n        throw new UnsupportedOperationException(&quot;remove&quot;);\n  &#125;\n  default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;\n        Objects.requireNonNull(action);\n        while (hasNext())\n            action.accept(next());\n  &#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用Iterator的一般步骤：</p>\n<ul>\n<li><p>(1)通过iterator()方法，获取指向集合或流开头的迭代器。</p>\n</li>\n<li><p>(2)建立一个hasNext()方法调用循环，只要hasNext()返回true,就继续迭代。</p>\n</li>\n<li><p>(3)在循环中，通过调用next()方法获取每个元素。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void learnIterator() &#123;\n    List&lt;String&gt; lists &#x3D; Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;);\n\n    Iterator&lt;String&gt; iterator &#x3D; lists.stream().iterator();\n\n    while (iterator.hasNext()) &#123;\n        System.out.println(iterator.next());\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>但是如果我们不修改集合的情况下，使用forEach()其实更加便利的，其实两种方式本质上面是一样的，在你编译之后，forEach()会转换成迭代器的方式进行操作了。有了迭代器，相信调试就得方便起来了，即使不能直接调试，也可以通过迭代器，反推之前，可能发生了什么。</p>\n<p>值得注意的一点是：Java8给基本类型的流提供了额外的迭代器：PrimitiveIterator.OfInt,PrimitiveIterator.OfDouble,PrimitiveIterator.OfLong,PrimitiveIterator,但这些接口都是来扩展自Iterator接口的，所以使用上面也是相同的。</p>\n<h4 id=\"Spliterator\"><a href=\"#Spliterator\" class=\"headerlink\" title=\"Spliterator\"></a>Spliterator</h4><p>Spliterator是Java8新增的一种迭代器，这种迭代器由<code>Spliterator</code>接口定义，Spliterator也有普通的遍历元素功能，这一点与刚才说的迭代器类似的，但是，但是Spliterator方法和使用迭代器的方法是不同的。</p>\n<p>另外，它提供的功能要比Iterator多。最终要的一点，Spliterator支持并行迭代。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface Spliterator&lt;T&gt; &#123;\n    boolean tryAdvance(Consumer&lt;? super T&gt; action);\n    int characteristics();\n    long estimateSize();\n   Spliterator&lt;T&gt; trySplit();\n   default void forEachRemaining(Consumer&lt;? super T&gt; action) &#123;\n        do &#123; &#125; while (tryAdvance(action));\n   &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>将Spliterator用于基本迭代任务是非常简单的，只需要调用tryAdvance()方法，直至其返回false.如果要为序列中的每个元素应用相同的动作，那么forEachRemaining()提供了一种更加高效的替代方法。</p>\n<p>对于这两个方法，在每次迭代中将发生的动作都由<code>Consumer</code>对象定义的操作来决定，<code>Consumer</code>也是一个函数式接口，估计大家已经知道怎么分析了，这里就不带大家分析了，他的动作是指定了在迭代中下一个元素上执行的操作。下面来一个简单的例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void learnIterator() &#123;\n    List&lt;String&gt; lists &#x3D; Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;);\n\n    Spliterator&lt;String&gt; spliterator &#x3D; lists.stream().spliterator();\n\n    while (spliterator.tryAdvance(System.out::println));\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用forEachRemaining()方法改进这个例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void learnIterator() &#123;\n    List&lt;String&gt; lists &#x3D; Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;);\n    lists.stream().spliterator().forEachRemaining(System.out::println);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>注意，使用这个方法时，不需要提供一个循环来一次处理一个元素，而是将各个元素作为一个整体来对待，这是Spliterator的又一个优势。</p>\n<p>Spliterator的另一个值得注意的方法是trySplit()，它将被迭代的元素划分成了两部分，返回其中一部分的新Spliterator,另一部分则通过原来的Spliterator访问。下面再给一个简单的例子</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void learnIterator() &#123;\n    List&lt;String&gt; lists &#x3D; Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;);\n\n    Spliterator&lt;String&gt; spliterator &#x3D; lists.stream().spliterator();\n\n    Spliterator&lt;String&gt; stringSpliterator &#x3D; spliterator.trySplit();\n\n    if (stringSpliterator !&#x3D; null) stringSpliterator.forEachRemaining(System.out::println);\n\n    System.out.println(&quot;------------------&quot;);\n\n    spliterator.forEachRemaining(System.out::println);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>打印的结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">A\nB\n------------------\nC\nD<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里只是给大家提供了这种方式而已，例子本身没有什么含义，但是当你对大数据集执行并行处理时，拆分可能是极有帮助的了。但更多情况下，要对流执行并行操作时，使用其他某个Stream方法更好，而不必手动处理Spliterator的这些细节，Spliterator最适合的场景是，给定的所有方法都不能满足你的要求时，才考虑。</p>\n<h4 id=\"最后来一个总结\"><a href=\"#最后来一个总结\" class=\"headerlink\" title=\"最后来一个总结\"></a>最后来一个总结</h4><p>到这里，Java8 Stream流的知识，基本上已经介绍完了，缩减操作，并行流，映射，还有收集是Stream流的核心内容，但是要想掌握好这些内容，第二篇的基本知识你是跑不掉的，因此我的建议还是老老实实，从第一篇开始认真看，看完这7篇文章，你基本已经非常系统地掌握Java8的Stream流知识了。</p>\n<p>大家也不要忘记<code>Collectors</code>类，里面提供给我们的方法，基本上能处理各种各样的收集元素问题了，如果你从第一篇文章开始看，一直看到这里了，那你以后尽量多使用Stream流来处理集合吧，只是学会这些知识是没有用的，要多在你们的项目中运用他们，这样才能更加好地理解，如果大家在使有的过程中遇到什么样的问题，欢迎来这里面留言，我看到了，一定第一时间和大家一起探索解决的方法。</p>\n"},{"title":"Java 8 新特性之 Stream 流（一）基础体验","date":"2025-10-15T03:36:33.000Z","_content":"#### 什么是流API? 它能做一些什么?\n\n我们应该知道(绝对知道~)API是一个程序向使用者提供的一些方法，通过这些方法就能实现某些功能。所以对于流API来说，重点是怎么理解\"流\"这个概念，所谓的流:就是数据的渠道，所以，流代表的是一个对象的序列它和Java I/O类里使用的\"流\"不同。虽然在概念上与java.util.stream中定义的流是类似的，但它们是不同的，流API中的流是描述某个流类型的对象。\n\n流API中的流操作的数据源，是数组或者是集合。它本身是不存储数据的，只是移动数据，在移动过程中可能会对数据进行过滤，排序或者其它操作，但是，一般情况下(绝大数情况下)，流操作本身不会修改数据源，比如，对流排序不会修改数据源的顺序。相反，它会创建一个新的流，其中包含排序后的结果。\n\n#### 从一个简单的例子，体验流API的强大与优雅\n  \n这个简单的Demo，主要是对一个由1-6乱序组成的List对应的流进行操作，然后通过这个流，就可以获取到列表里面最大最小值、排序、过滤某些元素等等的操作。并且这此操作不会改变原List里面的数据。Demo里面需要注意的地方就是流API里面的\"终端操作\"和\"中间操作\"的区别:其实也很简单，终端操作会消费流，一个被消费过的流是不能被再次利用的，但我们在实际应用的时候，并不会受到太大的影响(Ps:如果你们能动手实践一下我相信你体验更好，强烈推荐！)\n\n```\npublic class Main {\n\n\n    public static void main(String[] args) { \n        learnStream();\n    }\n\n    private static void learnStream() {\n        //首先，创建一个1-6乱序的List\n        List<Integer> lists = new ArrayList<>();\n        lists.add(4);\n        lists.add(3);\n        lists.add(6);\n        lists.add(1);\n        lists.add(5);\n        lists.add(2);\n\n        //看看List里面的数据是什么样子的先\n        System.out.print(\"List里面的数据:\");\n        for (Integer elem : lists) System.out.print(elem + \" \");// 4 3 6 1 5 2\n\n        System.out.println();\n\n        //最小值\n        System.out.print(\"List中最小的值为:\");\n        Stream<Integer> stream = lists.stream();\n        Optional<Integer> min = stream.min(Integer::compareTo);\n        if (min.isPresent()) {\n            System.out.println(min.get());//1\n        }\n\n\n        //最大值\n        System.out.print(\"List中最大的值为:\");\n        lists.stream().max(Integer::compareTo).ifPresent(System.out::println);//6\n\n        //排序\n        System.out.print(\"将List流进行排序:\");\n        Stream<Integer> sorted = lists.stream().sorted();\n        sorted.forEach(elem -> System.out.print(elem + \" \"));// 1 2 3 4 5 6\n\n        System.out.println();\n\n        //过滤\n        System.out.print(\"过滤List流，只剩下那些大于3的元素:\");\n        lists.stream()\n                .filter(elem -> elem > 3)\n                .forEach(elem -> System.out.print(elem + \" \"));// 4 5 6\n\n        System.out.println();\n\n        //过滤\n        System.out.println(\"过滤List流，只剩下那些大于0并且小于4的元素:\\n=====begin=====\");\n        lists.stream()\n                .filter(elem -> elem > 0)\n                .filter(elem -> elem < 4)\n                .sorted(Integer::compareTo)\n                .forEach(System.out::println);// 1 2 3\n\n        System.out.println(\"=====end=====\");\n        //经过了前面的这么多流操作，我们再来看看List里面的值有没有发生什么改变\n        System.out.print(\"原List里面的数据:\");\n        for (Integer elem : lists) System.out.print(elem + \" \");// 4 3 6 1 5 2\n    }\n}\n```\n\n如果刚才的Demo你认真读了，我相信你心里面多多少少都会产生一点点涟漪，没错，流API结合lambda表达式，就是这么优美!下面我详细介绍一下整个Demo，让大家更加清淅:\n\n### 最小值\n\n```\n //最小值\nSystem.out.print(\"List中最小的值为:\");\nStream<Integer> stream = lists.stream();\nOptional<Integer> min = stream.min(Integer::compareTo);\nif (min.isPresent()) {\n     System.out.println(min.get());//1\n}\n```\n首先通过stream()方法获取List对应的流，如果你对Java8的集合框架有一定的了解，你应该知道stream()是由Collection接口提供的。然后就可以通过min()获取流中的最小值了，当然这个流中的最小值肯定也是List里面的最小值。min()方法接收一个Comparator类型的参数，这个比较器是用于比较流中的两个元素的。我们这里把Integer的compareTo()的引用传递给了min()。它返回的类型是Optional，Optional可谓是NullPointException的大杀器啊，感兴趣的同学，了解一下。然后判断最小值存不存在，如果存在，就通过Optional的get()读取出来。很简单有木有!\n\n#### 最大值\n\n```\n//最大值\nSystem.out.print(\"List中最大的值为:\");\nlists.stream().max(Integer::compareTo).ifPresent(System.out::println);//6\n```\n语法糖爽YY有木有，不过需要注意的一点，因为min()是一个终端操作，所以这个流是不可以再用了，因此我们需要通过stream()重新生成一个流，(但这其实并不影响我们的实际生产的:①方法功能单一原则②还有其它很多很强大的方法组合能让你实现各种功能啊.)ifPresent其实和上面的最小值的if判断是一定要，如果存在最大值，我们就打印一下，这里只不过用了一些函数式写法而已。\n\n#### 排序和遍历\n\n```\n //排序\nSystem.out.print(\"将List流进行排序:\");\nStream<Integer> sorted = lists.stream().sorted();\nsorted.forEach(elem -> System.out.print(elem + \" \"));// 1 2 3 4 5 6\n```\n通过上面的讲解，相信这个已经难不了你了，sorted()方法是用于排序的，它的一个重载方法可以接收一个Comparator类型的参数，让你自定义你的排序规则。forEach方法就遍历。\n\n#### 过滤\n\n```\n//过滤\nSystem.out.println(\"过滤List流，只剩下那些大于0并且小于4的元素:\\n=====begin=====\");\nlists.stream()\n          .filter(elem -> elem > 0)\n          .filter(elem -> elem < 4)\n          .sorted(Integer::compareTo)\n          .forEach(System.out::println);// 1 2 3\n\nSystem.out.println(\"=====end=====\");\n```\nfilter()是基于一个谓词过滤流，它返回一个只包含满足谓词的元素的新流。它的参数形式是Predicate<? super T>是在java.util.function包下的泛型函数式接口。并且filter是一个中间操作，而且还可以同时存在多个filter。这里的两个过滤器，我们都传递了lambda表达式。\n\n#### 小结一下\n\n其实基本的流API使用就是这么简单，结合lambda表达式后，一切都变得特别清淅，这个简单的Demo展示了一些基础的功能，它或许就扩展了你操作数组或者集合框架的思路，让你操作集合和数组，变得更加的容易，简单和高效。当然流API的的功能肯定不止这一点点，我会陆陆续续完善整个系列，大家跟着我的步伐，就这一次，踏踏实实学好流式API，走向人生巅峰，迎娶白富美！\n","source":"_posts/新特性/Java8/Stream/Java 8 新特性之 Stream 流（一）基础体验.md","raw":"---\ntitle: Java 8 新特性之 Stream 流（一）基础体验\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n#### 什么是流API? 它能做一些什么?\n\n我们应该知道(绝对知道~)API是一个程序向使用者提供的一些方法，通过这些方法就能实现某些功能。所以对于流API来说，重点是怎么理解\"流\"这个概念，所谓的流:就是数据的渠道，所以，流代表的是一个对象的序列它和Java I/O类里使用的\"流\"不同。虽然在概念上与java.util.stream中定义的流是类似的，但它们是不同的，流API中的流是描述某个流类型的对象。\n\n流API中的流操作的数据源，是数组或者是集合。它本身是不存储数据的，只是移动数据，在移动过程中可能会对数据进行过滤，排序或者其它操作，但是，一般情况下(绝大数情况下)，流操作本身不会修改数据源，比如，对流排序不会修改数据源的顺序。相反，它会创建一个新的流，其中包含排序后的结果。\n\n#### 从一个简单的例子，体验流API的强大与优雅\n  \n这个简单的Demo，主要是对一个由1-6乱序组成的List对应的流进行操作，然后通过这个流，就可以获取到列表里面最大最小值、排序、过滤某些元素等等的操作。并且这此操作不会改变原List里面的数据。Demo里面需要注意的地方就是流API里面的\"终端操作\"和\"中间操作\"的区别:其实也很简单，终端操作会消费流，一个被消费过的流是不能被再次利用的，但我们在实际应用的时候，并不会受到太大的影响(Ps:如果你们能动手实践一下我相信你体验更好，强烈推荐！)\n\n```\npublic class Main {\n\n\n    public static void main(String[] args) { \n        learnStream();\n    }\n\n    private static void learnStream() {\n        //首先，创建一个1-6乱序的List\n        List<Integer> lists = new ArrayList<>();\n        lists.add(4);\n        lists.add(3);\n        lists.add(6);\n        lists.add(1);\n        lists.add(5);\n        lists.add(2);\n\n        //看看List里面的数据是什么样子的先\n        System.out.print(\"List里面的数据:\");\n        for (Integer elem : lists) System.out.print(elem + \" \");// 4 3 6 1 5 2\n\n        System.out.println();\n\n        //最小值\n        System.out.print(\"List中最小的值为:\");\n        Stream<Integer> stream = lists.stream();\n        Optional<Integer> min = stream.min(Integer::compareTo);\n        if (min.isPresent()) {\n            System.out.println(min.get());//1\n        }\n\n\n        //最大值\n        System.out.print(\"List中最大的值为:\");\n        lists.stream().max(Integer::compareTo).ifPresent(System.out::println);//6\n\n        //排序\n        System.out.print(\"将List流进行排序:\");\n        Stream<Integer> sorted = lists.stream().sorted();\n        sorted.forEach(elem -> System.out.print(elem + \" \"));// 1 2 3 4 5 6\n\n        System.out.println();\n\n        //过滤\n        System.out.print(\"过滤List流，只剩下那些大于3的元素:\");\n        lists.stream()\n                .filter(elem -> elem > 3)\n                .forEach(elem -> System.out.print(elem + \" \"));// 4 5 6\n\n        System.out.println();\n\n        //过滤\n        System.out.println(\"过滤List流，只剩下那些大于0并且小于4的元素:\\n=====begin=====\");\n        lists.stream()\n                .filter(elem -> elem > 0)\n                .filter(elem -> elem < 4)\n                .sorted(Integer::compareTo)\n                .forEach(System.out::println);// 1 2 3\n\n        System.out.println(\"=====end=====\");\n        //经过了前面的这么多流操作，我们再来看看List里面的值有没有发生什么改变\n        System.out.print(\"原List里面的数据:\");\n        for (Integer elem : lists) System.out.print(elem + \" \");// 4 3 6 1 5 2\n    }\n}\n```\n\n如果刚才的Demo你认真读了，我相信你心里面多多少少都会产生一点点涟漪，没错，流API结合lambda表达式，就是这么优美!下面我详细介绍一下整个Demo，让大家更加清淅:\n\n### 最小值\n\n```\n //最小值\nSystem.out.print(\"List中最小的值为:\");\nStream<Integer> stream = lists.stream();\nOptional<Integer> min = stream.min(Integer::compareTo);\nif (min.isPresent()) {\n     System.out.println(min.get());//1\n}\n```\n首先通过stream()方法获取List对应的流，如果你对Java8的集合框架有一定的了解，你应该知道stream()是由Collection接口提供的。然后就可以通过min()获取流中的最小值了，当然这个流中的最小值肯定也是List里面的最小值。min()方法接收一个Comparator类型的参数，这个比较器是用于比较流中的两个元素的。我们这里把Integer的compareTo()的引用传递给了min()。它返回的类型是Optional，Optional可谓是NullPointException的大杀器啊，感兴趣的同学，了解一下。然后判断最小值存不存在，如果存在，就通过Optional的get()读取出来。很简单有木有!\n\n#### 最大值\n\n```\n//最大值\nSystem.out.print(\"List中最大的值为:\");\nlists.stream().max(Integer::compareTo).ifPresent(System.out::println);//6\n```\n语法糖爽YY有木有，不过需要注意的一点，因为min()是一个终端操作，所以这个流是不可以再用了，因此我们需要通过stream()重新生成一个流，(但这其实并不影响我们的实际生产的:①方法功能单一原则②还有其它很多很强大的方法组合能让你实现各种功能啊.)ifPresent其实和上面的最小值的if判断是一定要，如果存在最大值，我们就打印一下，这里只不过用了一些函数式写法而已。\n\n#### 排序和遍历\n\n```\n //排序\nSystem.out.print(\"将List流进行排序:\");\nStream<Integer> sorted = lists.stream().sorted();\nsorted.forEach(elem -> System.out.print(elem + \" \"));// 1 2 3 4 5 6\n```\n通过上面的讲解，相信这个已经难不了你了，sorted()方法是用于排序的，它的一个重载方法可以接收一个Comparator类型的参数，让你自定义你的排序规则。forEach方法就遍历。\n\n#### 过滤\n\n```\n//过滤\nSystem.out.println(\"过滤List流，只剩下那些大于0并且小于4的元素:\\n=====begin=====\");\nlists.stream()\n          .filter(elem -> elem > 0)\n          .filter(elem -> elem < 4)\n          .sorted(Integer::compareTo)\n          .forEach(System.out::println);// 1 2 3\n\nSystem.out.println(\"=====end=====\");\n```\nfilter()是基于一个谓词过滤流，它返回一个只包含满足谓词的元素的新流。它的参数形式是Predicate<? super T>是在java.util.function包下的泛型函数式接口。并且filter是一个中间操作，而且还可以同时存在多个filter。这里的两个过滤器，我们都传递了lambda表达式。\n\n#### 小结一下\n\n其实基本的流API使用就是这么简单，结合lambda表达式后，一切都变得特别清淅，这个简单的Demo展示了一些基础的功能，它或许就扩展了你操作数组或者集合框架的思路，让你操作集合和数组，变得更加的容易，简单和高效。当然流API的的功能肯定不止这一点点，我会陆陆续续完善整个系列，大家跟着我的步伐，就这一次，踏踏实实学好流式API，走向人生巅峰，迎娶白富美！\n","slug":"新特性/Java8/Stream/Java 8 新特性之 Stream 流（一）基础体验","published":1,"updated":"2025-10-15T07:20:51.422Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu0779006lqkd4faqhax6o","content":"<h4 id=\"什么是流API-它能做一些什么\"><a href=\"#什么是流API-它能做一些什么\" class=\"headerlink\" title=\"什么是流API? 它能做一些什么?\"></a>什么是流API? 它能做一些什么?</h4><p>我们应该知道(绝对知道~)API是一个程序向使用者提供的一些方法，通过这些方法就能实现某些功能。所以对于流API来说，重点是怎么理解”流”这个概念，所谓的流:就是数据的渠道，所以，流代表的是一个对象的序列它和Java I&#x2F;O类里使用的”流”不同。虽然在概念上与java.util.stream中定义的流是类似的，但它们是不同的，流API中的流是描述某个流类型的对象。</p>\n<p>流API中的流操作的数据源，是数组或者是集合。它本身是不存储数据的，只是移动数据，在移动过程中可能会对数据进行过滤，排序或者其它操作，但是，一般情况下(绝大数情况下)，流操作本身不会修改数据源，比如，对流排序不会修改数据源的顺序。相反，它会创建一个新的流，其中包含排序后的结果。</p>\n<h4 id=\"从一个简单的例子，体验流API的强大与优雅\"><a href=\"#从一个简单的例子，体验流API的强大与优雅\" class=\"headerlink\" title=\"从一个简单的例子，体验流API的强大与优雅\"></a>从一个简单的例子，体验流API的强大与优雅</h4><p>这个简单的Demo，主要是对一个由1-6乱序组成的List对应的流进行操作，然后通过这个流，就可以获取到列表里面最大最小值、排序、过滤某些元素等等的操作。并且这此操作不会改变原List里面的数据。Demo里面需要注意的地方就是流API里面的”终端操作”和”中间操作”的区别:其实也很简单，终端操作会消费流，一个被消费过的流是不能被再次利用的，但我们在实际应用的时候，并不会受到太大的影响(Ps:如果你们能动手实践一下我相信你体验更好，强烈推荐！)</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Main &#123;\n\n\n    public static void main(String[] args) &#123; \n        learnStream();\n    &#125;\n\n    private static void learnStream() &#123;\n        &#x2F;&#x2F;首先，创建一个1-6乱序的List\n        List&lt;Integer&gt; lists &#x3D; new ArrayList&lt;&gt;();\n        lists.add(4);\n        lists.add(3);\n        lists.add(6);\n        lists.add(1);\n        lists.add(5);\n        lists.add(2);\n\n        &#x2F;&#x2F;看看List里面的数据是什么样子的先\n        System.out.print(&quot;List里面的数据:&quot;);\n        for (Integer elem : lists) System.out.print(elem + &quot; &quot;);&#x2F;&#x2F; 4 3 6 1 5 2\n\n        System.out.println();\n\n        &#x2F;&#x2F;最小值\n        System.out.print(&quot;List中最小的值为:&quot;);\n        Stream&lt;Integer&gt; stream &#x3D; lists.stream();\n        Optional&lt;Integer&gt; min &#x3D; stream.min(Integer::compareTo);\n        if (min.isPresent()) &#123;\n            System.out.println(min.get());&#x2F;&#x2F;1\n        &#125;\n\n\n        &#x2F;&#x2F;最大值\n        System.out.print(&quot;List中最大的值为:&quot;);\n        lists.stream().max(Integer::compareTo).ifPresent(System.out::println);&#x2F;&#x2F;6\n\n        &#x2F;&#x2F;排序\n        System.out.print(&quot;将List流进行排序:&quot;);\n        Stream&lt;Integer&gt; sorted &#x3D; lists.stream().sorted();\n        sorted.forEach(elem -&gt; System.out.print(elem + &quot; &quot;));&#x2F;&#x2F; 1 2 3 4 5 6\n\n        System.out.println();\n\n        &#x2F;&#x2F;过滤\n        System.out.print(&quot;过滤List流，只剩下那些大于3的元素:&quot;);\n        lists.stream()\n                .filter(elem -&gt; elem &gt; 3)\n                .forEach(elem -&gt; System.out.print(elem + &quot; &quot;));&#x2F;&#x2F; 4 5 6\n\n        System.out.println();\n\n        &#x2F;&#x2F;过滤\n        System.out.println(&quot;过滤List流，只剩下那些大于0并且小于4的元素:\\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        lists.stream()\n                .filter(elem -&gt; elem &gt; 0)\n                .filter(elem -&gt; elem &lt; 4)\n                .sorted(Integer::compareTo)\n                .forEach(System.out::println);&#x2F;&#x2F; 1 2 3\n\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        &#x2F;&#x2F;经过了前面的这么多流操作，我们再来看看List里面的值有没有发生什么改变\n        System.out.print(&quot;原List里面的数据:&quot;);\n        for (Integer elem : lists) System.out.print(elem + &quot; &quot;);&#x2F;&#x2F; 4 3 6 1 5 2\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果刚才的Demo你认真读了，我相信你心里面多多少少都会产生一点点涟漪，没错，流API结合lambda表达式，就是这么优美!下面我详细介绍一下整个Demo，让大家更加清淅:</p>\n<h3 id=\"最小值\"><a href=\"#最小值\" class=\"headerlink\" title=\"最小值\"></a>最小值</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\"> &#x2F;&#x2F;最小值\nSystem.out.print(&quot;List中最小的值为:&quot;);\nStream&lt;Integer&gt; stream &#x3D; lists.stream();\nOptional&lt;Integer&gt; min &#x3D; stream.min(Integer::compareTo);\nif (min.isPresent()) &#123;\n     System.out.println(min.get());&#x2F;&#x2F;1\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>首先通过stream()方法获取List对应的流，如果你对Java8的集合框架有一定的了解，你应该知道stream()是由Collection接口提供的。然后就可以通过min()获取流中的最小值了，当然这个流中的最小值肯定也是List里面的最小值。min()方法接收一个Comparator类型的参数，这个比较器是用于比较流中的两个元素的。我们这里把Integer的compareTo()的引用传递给了min()。它返回的类型是Optional，Optional可谓是NullPointException的大杀器啊，感兴趣的同学，了解一下。然后判断最小值存不存在，如果存在，就通过Optional的get()读取出来。很简单有木有!</p>\n<h4 id=\"最大值\"><a href=\"#最大值\" class=\"headerlink\" title=\"最大值\"></a>最大值</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;最大值\nSystem.out.print(&quot;List中最大的值为:&quot;);\nlists.stream().max(Integer::compareTo).ifPresent(System.out::println);&#x2F;&#x2F;6<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>语法糖爽YY有木有，不过需要注意的一点，因为min()是一个终端操作，所以这个流是不可以再用了，因此我们需要通过stream()重新生成一个流，(但这其实并不影响我们的实际生产的:①方法功能单一原则②还有其它很多很强大的方法组合能让你实现各种功能啊.)ifPresent其实和上面的最小值的if判断是一定要，如果存在最大值，我们就打印一下，这里只不过用了一些函数式写法而已。</p>\n<h4 id=\"排序和遍历\"><a href=\"#排序和遍历\" class=\"headerlink\" title=\"排序和遍历\"></a>排序和遍历</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\"> &#x2F;&#x2F;排序\nSystem.out.print(&quot;将List流进行排序:&quot;);\nStream&lt;Integer&gt; sorted &#x3D; lists.stream().sorted();\nsorted.forEach(elem -&gt; System.out.print(elem + &quot; &quot;));&#x2F;&#x2F; 1 2 3 4 5 6<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面的讲解，相信这个已经难不了你了，sorted()方法是用于排序的，它的一个重载方法可以接收一个Comparator类型的参数，让你自定义你的排序规则。forEach方法就遍历。</p>\n<h4 id=\"过滤\"><a href=\"#过滤\" class=\"headerlink\" title=\"过滤\"></a>过滤</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;过滤\nSystem.out.println(&quot;过滤List流，只剩下那些大于0并且小于4的元素:\\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\nlists.stream()\n          .filter(elem -&gt; elem &gt; 0)\n          .filter(elem -&gt; elem &lt; 4)\n          .sorted(Integer::compareTo)\n          .forEach(System.out::println);&#x2F;&#x2F; 1 2 3\n\nSystem.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>filter()是基于一个谓词过滤流，它返回一个只包含满足谓词的元素的新流。它的参数形式是Predicate&lt;? super T&gt;是在java.util.function包下的泛型函数式接口。并且filter是一个中间操作，而且还可以同时存在多个filter。这里的两个过滤器，我们都传递了lambda表达式。</p>\n<h4 id=\"小结一下\"><a href=\"#小结一下\" class=\"headerlink\" title=\"小结一下\"></a>小结一下</h4><p>其实基本的流API使用就是这么简单，结合lambda表达式后，一切都变得特别清淅，这个简单的Demo展示了一些基础的功能，它或许就扩展了你操作数组或者集合框架的思路，让你操作集合和数组，变得更加的容易，简单和高效。当然流API的的功能肯定不止这一点点，我会陆陆续续完善整个系列，大家跟着我的步伐，就这一次，踏踏实实学好流式API，走向人生巅峰，迎娶白富美！</p>\n","excerpt":"","more":"<h4 id=\"什么是流API-它能做一些什么\"><a href=\"#什么是流API-它能做一些什么\" class=\"headerlink\" title=\"什么是流API? 它能做一些什么?\"></a>什么是流API? 它能做一些什么?</h4><p>我们应该知道(绝对知道~)API是一个程序向使用者提供的一些方法，通过这些方法就能实现某些功能。所以对于流API来说，重点是怎么理解”流”这个概念，所谓的流:就是数据的渠道，所以，流代表的是一个对象的序列它和Java I&#x2F;O类里使用的”流”不同。虽然在概念上与java.util.stream中定义的流是类似的，但它们是不同的，流API中的流是描述某个流类型的对象。</p>\n<p>流API中的流操作的数据源，是数组或者是集合。它本身是不存储数据的，只是移动数据，在移动过程中可能会对数据进行过滤，排序或者其它操作，但是，一般情况下(绝大数情况下)，流操作本身不会修改数据源，比如，对流排序不会修改数据源的顺序。相反，它会创建一个新的流，其中包含排序后的结果。</p>\n<h4 id=\"从一个简单的例子，体验流API的强大与优雅\"><a href=\"#从一个简单的例子，体验流API的强大与优雅\" class=\"headerlink\" title=\"从一个简单的例子，体验流API的强大与优雅\"></a>从一个简单的例子，体验流API的强大与优雅</h4><p>这个简单的Demo，主要是对一个由1-6乱序组成的List对应的流进行操作，然后通过这个流，就可以获取到列表里面最大最小值、排序、过滤某些元素等等的操作。并且这此操作不会改变原List里面的数据。Demo里面需要注意的地方就是流API里面的”终端操作”和”中间操作”的区别:其实也很简单，终端操作会消费流，一个被消费过的流是不能被再次利用的，但我们在实际应用的时候，并不会受到太大的影响(Ps:如果你们能动手实践一下我相信你体验更好，强烈推荐！)</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Main &#123;\n\n\n    public static void main(String[] args) &#123; \n        learnStream();\n    &#125;\n\n    private static void learnStream() &#123;\n        &#x2F;&#x2F;首先，创建一个1-6乱序的List\n        List&lt;Integer&gt; lists &#x3D; new ArrayList&lt;&gt;();\n        lists.add(4);\n        lists.add(3);\n        lists.add(6);\n        lists.add(1);\n        lists.add(5);\n        lists.add(2);\n\n        &#x2F;&#x2F;看看List里面的数据是什么样子的先\n        System.out.print(&quot;List里面的数据:&quot;);\n        for (Integer elem : lists) System.out.print(elem + &quot; &quot;);&#x2F;&#x2F; 4 3 6 1 5 2\n\n        System.out.println();\n\n        &#x2F;&#x2F;最小值\n        System.out.print(&quot;List中最小的值为:&quot;);\n        Stream&lt;Integer&gt; stream &#x3D; lists.stream();\n        Optional&lt;Integer&gt; min &#x3D; stream.min(Integer::compareTo);\n        if (min.isPresent()) &#123;\n            System.out.println(min.get());&#x2F;&#x2F;1\n        &#125;\n\n\n        &#x2F;&#x2F;最大值\n        System.out.print(&quot;List中最大的值为:&quot;);\n        lists.stream().max(Integer::compareTo).ifPresent(System.out::println);&#x2F;&#x2F;6\n\n        &#x2F;&#x2F;排序\n        System.out.print(&quot;将List流进行排序:&quot;);\n        Stream&lt;Integer&gt; sorted &#x3D; lists.stream().sorted();\n        sorted.forEach(elem -&gt; System.out.print(elem + &quot; &quot;));&#x2F;&#x2F; 1 2 3 4 5 6\n\n        System.out.println();\n\n        &#x2F;&#x2F;过滤\n        System.out.print(&quot;过滤List流，只剩下那些大于3的元素:&quot;);\n        lists.stream()\n                .filter(elem -&gt; elem &gt; 3)\n                .forEach(elem -&gt; System.out.print(elem + &quot; &quot;));&#x2F;&#x2F; 4 5 6\n\n        System.out.println();\n\n        &#x2F;&#x2F;过滤\n        System.out.println(&quot;过滤List流，只剩下那些大于0并且小于4的元素:\\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        lists.stream()\n                .filter(elem -&gt; elem &gt; 0)\n                .filter(elem -&gt; elem &lt; 4)\n                .sorted(Integer::compareTo)\n                .forEach(System.out::println);&#x2F;&#x2F; 1 2 3\n\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        &#x2F;&#x2F;经过了前面的这么多流操作，我们再来看看List里面的值有没有发生什么改变\n        System.out.print(&quot;原List里面的数据:&quot;);\n        for (Integer elem : lists) System.out.print(elem + &quot; &quot;);&#x2F;&#x2F; 4 3 6 1 5 2\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果刚才的Demo你认真读了，我相信你心里面多多少少都会产生一点点涟漪，没错，流API结合lambda表达式，就是这么优美!下面我详细介绍一下整个Demo，让大家更加清淅:</p>\n<h3 id=\"最小值\"><a href=\"#最小值\" class=\"headerlink\" title=\"最小值\"></a>最小值</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\"> &#x2F;&#x2F;最小值\nSystem.out.print(&quot;List中最小的值为:&quot;);\nStream&lt;Integer&gt; stream &#x3D; lists.stream();\nOptional&lt;Integer&gt; min &#x3D; stream.min(Integer::compareTo);\nif (min.isPresent()) &#123;\n     System.out.println(min.get());&#x2F;&#x2F;1\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>首先通过stream()方法获取List对应的流，如果你对Java8的集合框架有一定的了解，你应该知道stream()是由Collection接口提供的。然后就可以通过min()获取流中的最小值了，当然这个流中的最小值肯定也是List里面的最小值。min()方法接收一个Comparator类型的参数，这个比较器是用于比较流中的两个元素的。我们这里把Integer的compareTo()的引用传递给了min()。它返回的类型是Optional，Optional可谓是NullPointException的大杀器啊，感兴趣的同学，了解一下。然后判断最小值存不存在，如果存在，就通过Optional的get()读取出来。很简单有木有!</p>\n<h4 id=\"最大值\"><a href=\"#最大值\" class=\"headerlink\" title=\"最大值\"></a>最大值</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;最大值\nSystem.out.print(&quot;List中最大的值为:&quot;);\nlists.stream().max(Integer::compareTo).ifPresent(System.out::println);&#x2F;&#x2F;6<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>语法糖爽YY有木有，不过需要注意的一点，因为min()是一个终端操作，所以这个流是不可以再用了，因此我们需要通过stream()重新生成一个流，(但这其实并不影响我们的实际生产的:①方法功能单一原则②还有其它很多很强大的方法组合能让你实现各种功能啊.)ifPresent其实和上面的最小值的if判断是一定要，如果存在最大值，我们就打印一下，这里只不过用了一些函数式写法而已。</p>\n<h4 id=\"排序和遍历\"><a href=\"#排序和遍历\" class=\"headerlink\" title=\"排序和遍历\"></a>排序和遍历</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\"> &#x2F;&#x2F;排序\nSystem.out.print(&quot;将List流进行排序:&quot;);\nStream&lt;Integer&gt; sorted &#x3D; lists.stream().sorted();\nsorted.forEach(elem -&gt; System.out.print(elem + &quot; &quot;));&#x2F;&#x2F; 1 2 3 4 5 6<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过上面的讲解，相信这个已经难不了你了，sorted()方法是用于排序的，它的一个重载方法可以接收一个Comparator类型的参数，让你自定义你的排序规则。forEach方法就遍历。</p>\n<h4 id=\"过滤\"><a href=\"#过滤\" class=\"headerlink\" title=\"过滤\"></a>过滤</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;过滤\nSystem.out.println(&quot;过滤List流，只剩下那些大于0并且小于4的元素:\\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\nlists.stream()\n          .filter(elem -&gt; elem &gt; 0)\n          .filter(elem -&gt; elem &lt; 4)\n          .sorted(Integer::compareTo)\n          .forEach(System.out::println);&#x2F;&#x2F; 1 2 3\n\nSystem.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>filter()是基于一个谓词过滤流，它返回一个只包含满足谓词的元素的新流。它的参数形式是Predicate&lt;? super T&gt;是在java.util.function包下的泛型函数式接口。并且filter是一个中间操作，而且还可以同时存在多个filter。这里的两个过滤器，我们都传递了lambda表达式。</p>\n<h4 id=\"小结一下\"><a href=\"#小结一下\" class=\"headerlink\" title=\"小结一下\"></a>小结一下</h4><p>其实基本的流API使用就是这么简单，结合lambda表达式后，一切都变得特别清淅，这个简单的Demo展示了一些基础的功能，它或许就扩展了你操作数组或者集合框架的思路，让你操作集合和数组，变得更加的容易，简单和高效。当然流API的的功能肯定不止这一点点，我会陆陆续续完善整个系列，大家跟着我的步伐，就这一次，踏踏实实学好流式API，走向人生巅峰，迎娶白富美！</p>\n"},{"title":"Java 8 新特性之 Stream 流（三）缩减操作","date":"2025-10-15T03:36:33.000Z","_content":"\n和前面两篇文章一起服用，效果会更佳。通过对流API的基础体验Demo和关键知识点的讲解，相信大家对流API都有一定的认识了，但是流API强大的功能，可不仅仅像前面两篇文章中说的那样简单，大家应该注意到，在第二篇中，我对Stream接口进行介绍的时候，并没有把他的全部方法都进行了解析说明。没错，从这一篇开始，那些还没有讲解的方法，很可能就开始变成我们的主角了，大家从题目上面应该知道了，本期我们要讲的是流API的缩减操作。\n\n#### 何为缩减操作？\n\n我们先考虑一下min()和max()，这两个方法我们在第一篇和第二篇中均有提到，其中min()是返回流中的最小值，而max()返回流中最大值，前提是他们存在。他们之间的特点是什么？①都返回了一个值②由一可知，他们是终端操作。如果我们用流API的术语来形容前面这两种特性的结合体的话，它们代表了缩减操作。因为每个缩减操作都把一个流缩减为一个值，好比最大值，最小值。当然流API，把min()和max()，count()这些操作称为特例缩减。即然说到了特例，肯定就有泛化这种概念了，他就是reduce()方法了，其实第二篇当中，他已经出现过了，只是当时我没有去强调他。\n```\npublic interface Stream<T> extends BaseStream<T, Stream<T>> {\n//、、、忽略其他无关紧要的元素\nT reduce(T identity, BinaryOperator<T> accumulator);\nOptional<T> reduce(BinaryOperator<T> accumulator);\n<U> U reduce(U identity,\n          BiFunction<U, ? super T, U> accumulator,\n          BinaryOperator<U> combiner);\n｝\n``` \nStream接口定义了三个版本的reduce()，我们先使用前面两个,\n```\nT reduce(T identity, BinaryOperator<T> accumulator);//1\nOptional<T> reduce(BinaryOperator<T> accumulator);//2\n```\n第一个版本返回的是一个T类型的对象，T代表的是流中的元素类型！第二个版本是返回一个Optional类型对象。对于这两种形式，accumulator是一个操作两个值并得到结果的函数。在第一个版本当中，identity是这样一个值，对于涉及identity和流中任意的累积操作，得到的结果就是元素自身，没有任何改变。比如，如果是加法，他就是0，如果是乘法他就是1。\n\n其中的accumulator是一个BinaryOperator<T>的类型，他是java.util.function包中声明的函数式接口，它扩展了BiFunction函数式接口.\n\n```\n@FunctionalInterface\npublic interface BinaryOperator<T> extends BiFunction<T,T,T> {\n}\n\n@FunctionalInterface\npublic interface BiFunction<T, U, R> {\n   R apply(T t, U u);//notice\n}\n```\n\nBiFunction接口中的apply()方法的原型在*`//notice`*。其中R指定了结果的类型，T，U分别是第一参数的类型和第二个参数的类型，因此apply()对他的两个操作数(t,u)应用到同一个函数上，并返回结果，而对BinaryOperator<T>来说，他在扩展 BiFunction时，指定了所有的类型参数都是相同的T，因此对于BinaryOperator<T>函数式接口的apply来说，他也就变成了  T apply(T t, T u),此外，还有一个需要注意的地方是，在应用reduce()时，apply()的第一个参数t,包含的是一个结果，u包含的是下一个元素。在第一次调用时，将取决于使用reduce()的版本，t可能是单位值，或者是前一个元素。\n\n#### 缩减操作的三个约束\n\n* **无状态**\n* **不干预**\n* **关联性**\n\n无状态，这里可不是LOL的那个无状态，毕竟他退役了。相信读过第二篇文章的同学已经很容易理解了，简单来说无状态就是每个元素都被单独地处理，他和流中的其它元素是没有任何依赖关系的。不干预是指操作数不会改变数据源。最后，操作必须具有关联性，这里的关联性是指标准的数学含义，即，给定一个关联运算符，在一系列操作中使用该运算符，先处理哪一对操作数是无关紧要的。比如，(1 * 2) * 3  <===> 1 * (2 * 3)。`其中关联性，在并行流中，是至关重要的。`下面我用一个简单的例子带着大家实战一下泛化缩减操作reduce()的使用。\n\n```\npublic class Main {\n\n    public static void main(String[] args) {\n        learnStream();\n    }\n\n\n    private static void learnStream() {\n        List<Integer> lists = new ArrayList<>();\n        lists.add(1);\n        lists.add(2);\n        lists.add(3);\n        lists.add(4);\n        lists.add(5);\n        lists.add(6);\n\n        Optional<Integer> sum = lists.stream().reduce((a, b) -> a + b);\n        if (sum.isPresent()) System.out.println(\"list的总和为:\" + sum.get());//21\n        //<====> lists.stream().reduce((a, b) -> a + b).ifPresent(System.out::println);\n\n        Integer sum2 = lists.stream().reduce(0, (a, b) -> a + b);//21\n        System.out.println(\"list的总和为:\" + sum2);\n\n        Optional<Integer> product = lists.stream().reduce((a, b) -> a * b);\n        if (product.isPresent()) System.out.println(\"list的积为:\" + product.get());//720\n\n        Integer product2 = lists.stream().reduce(1, (a, b) -> a * b);\n        System.out.println(\"list的积为:\" + product2);//720\n    }\n}\n```\n\n这个Demo主要是计算了一个list里面的总和，积的操作，大家可以和传统的算总和，积的方法进行对照，比一比衡量一下就有自己的答案了。但是如果你以为流API仅此而已，那你就错了。越是后面的东西，就越装B，我在刚知道他们的时候，反正是被吓了一跳的，但这些都是后话了，现在我们来详解一下Demo,并给出扩展的方向：我们这个例子主要是用了lambda表达式对list进行了求和，求积，对于第一个版本为说，求和的时候，identity的值为0，求积的时候它的值为1，强烈建议你们自己感受一下identity的变化对整个结果的变化产生什么 的影响，改变一下identity的值，再运行一下，你就有结果了，另一个扩展点是：\n\n```\n Integer product3 = lists.stream().reduce(1, (a, b) -> {\n            if (b % 2 == 0) return a * b; else return a;//这里你可以为所欲为!\n });\n System.out.println(\"list的偶数的积为:\" + product3);//48\n```\n#### 小结一下\n\n对于流的缩减操作来说,主要要知道,他只返回一个值,并且它是一个终端操作,然后还有的就是要知道缩减操作的三个约束了,其实最重要的就是无状态性和关联性了.这一小节要说的,也就这么多了,应该很容易就把他收到自己的技能树上面了。\n","source":"_posts/新特性/Java8/Stream/Java 8 新特性之 Stream 流（三）缩减操作.md","raw":"---\ntitle: Java 8 新特性之 Stream 流（三）缩减操作\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n\n和前面两篇文章一起服用，效果会更佳。通过对流API的基础体验Demo和关键知识点的讲解，相信大家对流API都有一定的认识了，但是流API强大的功能，可不仅仅像前面两篇文章中说的那样简单，大家应该注意到，在第二篇中，我对Stream接口进行介绍的时候，并没有把他的全部方法都进行了解析说明。没错，从这一篇开始，那些还没有讲解的方法，很可能就开始变成我们的主角了，大家从题目上面应该知道了，本期我们要讲的是流API的缩减操作。\n\n#### 何为缩减操作？\n\n我们先考虑一下min()和max()，这两个方法我们在第一篇和第二篇中均有提到，其中min()是返回流中的最小值，而max()返回流中最大值，前提是他们存在。他们之间的特点是什么？①都返回了一个值②由一可知，他们是终端操作。如果我们用流API的术语来形容前面这两种特性的结合体的话，它们代表了缩减操作。因为每个缩减操作都把一个流缩减为一个值，好比最大值，最小值。当然流API，把min()和max()，count()这些操作称为特例缩减。即然说到了特例，肯定就有泛化这种概念了，他就是reduce()方法了，其实第二篇当中，他已经出现过了，只是当时我没有去强调他。\n```\npublic interface Stream<T> extends BaseStream<T, Stream<T>> {\n//、、、忽略其他无关紧要的元素\nT reduce(T identity, BinaryOperator<T> accumulator);\nOptional<T> reduce(BinaryOperator<T> accumulator);\n<U> U reduce(U identity,\n          BiFunction<U, ? super T, U> accumulator,\n          BinaryOperator<U> combiner);\n｝\n``` \nStream接口定义了三个版本的reduce()，我们先使用前面两个,\n```\nT reduce(T identity, BinaryOperator<T> accumulator);//1\nOptional<T> reduce(BinaryOperator<T> accumulator);//2\n```\n第一个版本返回的是一个T类型的对象，T代表的是流中的元素类型！第二个版本是返回一个Optional类型对象。对于这两种形式，accumulator是一个操作两个值并得到结果的函数。在第一个版本当中，identity是这样一个值，对于涉及identity和流中任意的累积操作，得到的结果就是元素自身，没有任何改变。比如，如果是加法，他就是0，如果是乘法他就是1。\n\n其中的accumulator是一个BinaryOperator<T>的类型，他是java.util.function包中声明的函数式接口，它扩展了BiFunction函数式接口.\n\n```\n@FunctionalInterface\npublic interface BinaryOperator<T> extends BiFunction<T,T,T> {\n}\n\n@FunctionalInterface\npublic interface BiFunction<T, U, R> {\n   R apply(T t, U u);//notice\n}\n```\n\nBiFunction接口中的apply()方法的原型在*`//notice`*。其中R指定了结果的类型，T，U分别是第一参数的类型和第二个参数的类型，因此apply()对他的两个操作数(t,u)应用到同一个函数上，并返回结果，而对BinaryOperator<T>来说，他在扩展 BiFunction时，指定了所有的类型参数都是相同的T，因此对于BinaryOperator<T>函数式接口的apply来说，他也就变成了  T apply(T t, T u),此外，还有一个需要注意的地方是，在应用reduce()时，apply()的第一个参数t,包含的是一个结果，u包含的是下一个元素。在第一次调用时，将取决于使用reduce()的版本，t可能是单位值，或者是前一个元素。\n\n#### 缩减操作的三个约束\n\n* **无状态**\n* **不干预**\n* **关联性**\n\n无状态，这里可不是LOL的那个无状态，毕竟他退役了。相信读过第二篇文章的同学已经很容易理解了，简单来说无状态就是每个元素都被单独地处理，他和流中的其它元素是没有任何依赖关系的。不干预是指操作数不会改变数据源。最后，操作必须具有关联性，这里的关联性是指标准的数学含义，即，给定一个关联运算符，在一系列操作中使用该运算符，先处理哪一对操作数是无关紧要的。比如，(1 * 2) * 3  <===> 1 * (2 * 3)。`其中关联性，在并行流中，是至关重要的。`下面我用一个简单的例子带着大家实战一下泛化缩减操作reduce()的使用。\n\n```\npublic class Main {\n\n    public static void main(String[] args) {\n        learnStream();\n    }\n\n\n    private static void learnStream() {\n        List<Integer> lists = new ArrayList<>();\n        lists.add(1);\n        lists.add(2);\n        lists.add(3);\n        lists.add(4);\n        lists.add(5);\n        lists.add(6);\n\n        Optional<Integer> sum = lists.stream().reduce((a, b) -> a + b);\n        if (sum.isPresent()) System.out.println(\"list的总和为:\" + sum.get());//21\n        //<====> lists.stream().reduce((a, b) -> a + b).ifPresent(System.out::println);\n\n        Integer sum2 = lists.stream().reduce(0, (a, b) -> a + b);//21\n        System.out.println(\"list的总和为:\" + sum2);\n\n        Optional<Integer> product = lists.stream().reduce((a, b) -> a * b);\n        if (product.isPresent()) System.out.println(\"list的积为:\" + product.get());//720\n\n        Integer product2 = lists.stream().reduce(1, (a, b) -> a * b);\n        System.out.println(\"list的积为:\" + product2);//720\n    }\n}\n```\n\n这个Demo主要是计算了一个list里面的总和，积的操作，大家可以和传统的算总和，积的方法进行对照，比一比衡量一下就有自己的答案了。但是如果你以为流API仅此而已，那你就错了。越是后面的东西，就越装B，我在刚知道他们的时候，反正是被吓了一跳的，但这些都是后话了，现在我们来详解一下Demo,并给出扩展的方向：我们这个例子主要是用了lambda表达式对list进行了求和，求积，对于第一个版本为说，求和的时候，identity的值为0，求积的时候它的值为1，强烈建议你们自己感受一下identity的变化对整个结果的变化产生什么 的影响，改变一下identity的值，再运行一下，你就有结果了，另一个扩展点是：\n\n```\n Integer product3 = lists.stream().reduce(1, (a, b) -> {\n            if (b % 2 == 0) return a * b; else return a;//这里你可以为所欲为!\n });\n System.out.println(\"list的偶数的积为:\" + product3);//48\n```\n#### 小结一下\n\n对于流的缩减操作来说,主要要知道,他只返回一个值,并且它是一个终端操作,然后还有的就是要知道缩减操作的三个约束了,其实最重要的就是无状态性和关联性了.这一小节要说的,也就这么多了,应该很容易就把他收到自己的技能树上面了。\n","slug":"新特性/Java8/Stream/Java 8 新特性之 Stream 流（三）缩减操作","published":1,"updated":"2025-10-15T07:20:51.402Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu0779006oqkd418tq5mpd","content":"<p>和前面两篇文章一起服用，效果会更佳。通过对流API的基础体验Demo和关键知识点的讲解，相信大家对流API都有一定的认识了，但是流API强大的功能，可不仅仅像前面两篇文章中说的那样简单，大家应该注意到，在第二篇中，我对Stream接口进行介绍的时候，并没有把他的全部方法都进行了解析说明。没错，从这一篇开始，那些还没有讲解的方法，很可能就开始变成我们的主角了，大家从题目上面应该知道了，本期我们要讲的是流API的缩减操作。</p>\n<h4 id=\"何为缩减操作？\"><a href=\"#何为缩减操作？\" class=\"headerlink\" title=\"何为缩减操作？\"></a>何为缩减操作？</h4><p>我们先考虑一下min()和max()，这两个方法我们在第一篇和第二篇中均有提到，其中min()是返回流中的最小值，而max()返回流中最大值，前提是他们存在。他们之间的特点是什么？①都返回了一个值②由一可知，他们是终端操作。如果我们用流API的术语来形容前面这两种特性的结合体的话，它们代表了缩减操作。因为每个缩减操作都把一个流缩减为一个值，好比最大值，最小值。当然流API，把min()和max()，count()这些操作称为特例缩减。即然说到了特例，肯定就有泛化这种概念了，他就是reduce()方法了，其实第二篇当中，他已经出现过了，只是当时我没有去强调他。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;\n&#x2F;&#x2F;、、、忽略其他无关紧要的元素\nT reduce(T identity, BinaryOperator&lt;T&gt; accumulator);\nOptional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);\n&lt;U&gt; U reduce(U identity,\n          BiFunction&lt;U, ? super T, U&gt; accumulator,\n          BinaryOperator&lt;U&gt; combiner);\n｝<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>Stream接口定义了三个版本的reduce()，我们先使用前面两个,</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);&#x2F;&#x2F;1\nOptional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);&#x2F;&#x2F;2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>第一个版本返回的是一个T类型的对象，T代表的是流中的元素类型！第二个版本是返回一个Optional类型对象。对于这两种形式，accumulator是一个操作两个值并得到结果的函数。在第一个版本当中，identity是这样一个值，对于涉及identity和流中任意的累积操作，得到的结果就是元素自身，没有任何改变。比如，如果是加法，他就是0，如果是乘法他就是1。</p>\n<p>其中的accumulator是一个BinaryOperator<T>的类型，他是java.util.function包中声明的函数式接口，它扩展了BiFunction函数式接口.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@FunctionalInterface\npublic interface BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; &#123;\n&#125;\n\n@FunctionalInterface\npublic interface BiFunction&lt;T, U, R&gt; &#123;\n   R apply(T t, U u);&#x2F;&#x2F;notice\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>BiFunction接口中的apply()方法的原型在*<code>//notice</code>*。其中R指定了结果的类型，T，U分别是第一参数的类型和第二个参数的类型，因此apply()对他的两个操作数(t,u)应用到同一个函数上，并返回结果，而对BinaryOperator<T>来说，他在扩展 BiFunction时，指定了所有的类型参数都是相同的T，因此对于BinaryOperator<T>函数式接口的apply来说，他也就变成了  T apply(T t, T u),此外，还有一个需要注意的地方是，在应用reduce()时，apply()的第一个参数t,包含的是一个结果，u包含的是下一个元素。在第一次调用时，将取决于使用reduce()的版本，t可能是单位值，或者是前一个元素。</p>\n<h4 id=\"缩减操作的三个约束\"><a href=\"#缩减操作的三个约束\" class=\"headerlink\" title=\"缩减操作的三个约束\"></a>缩减操作的三个约束</h4><ul>\n<li><strong>无状态</strong></li>\n<li><strong>不干预</strong></li>\n<li><strong>关联性</strong></li>\n</ul>\n<p>无状态，这里可不是LOL的那个无状态，毕竟他退役了。相信读过第二篇文章的同学已经很容易理解了，简单来说无状态就是每个元素都被单独地处理，他和流中的其它元素是没有任何依赖关系的。不干预是指操作数不会改变数据源。最后，操作必须具有关联性，这里的关联性是指标准的数学含义，即，给定一个关联运算符，在一系列操作中使用该运算符，先处理哪一对操作数是无关紧要的。比如，(1 * 2) * 3  &lt;&#x3D;&#x3D;&#x3D;&gt; 1 * (2 * 3)。<code>其中关联性，在并行流中，是至关重要的。</code>下面我用一个简单的例子带着大家实战一下泛化缩减操作reduce()的使用。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Main &#123;\n\n    public static void main(String[] args) &#123;\n        learnStream();\n    &#125;\n\n\n    private static void learnStream() &#123;\n        List&lt;Integer&gt; lists &#x3D; new ArrayList&lt;&gt;();\n        lists.add(1);\n        lists.add(2);\n        lists.add(3);\n        lists.add(4);\n        lists.add(5);\n        lists.add(6);\n\n        Optional&lt;Integer&gt; sum &#x3D; lists.stream().reduce((a, b) -&gt; a + b);\n        if (sum.isPresent()) System.out.println(&quot;list的总和为:&quot; + sum.get());&#x2F;&#x2F;21\n        &#x2F;&#x2F;&lt;&#x3D;&#x3D;&#x3D;&#x3D;&gt; lists.stream().reduce((a, b) -&gt; a + b).ifPresent(System.out::println);\n\n        Integer sum2 &#x3D; lists.stream().reduce(0, (a, b) -&gt; a + b);&#x2F;&#x2F;21\n        System.out.println(&quot;list的总和为:&quot; + sum2);\n\n        Optional&lt;Integer&gt; product &#x3D; lists.stream().reduce((a, b) -&gt; a * b);\n        if (product.isPresent()) System.out.println(&quot;list的积为:&quot; + product.get());&#x2F;&#x2F;720\n\n        Integer product2 &#x3D; lists.stream().reduce(1, (a, b) -&gt; a * b);\n        System.out.println(&quot;list的积为:&quot; + product2);&#x2F;&#x2F;720\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个Demo主要是计算了一个list里面的总和，积的操作，大家可以和传统的算总和，积的方法进行对照，比一比衡量一下就有自己的答案了。但是如果你以为流API仅此而已，那你就错了。越是后面的东西，就越装B，我在刚知道他们的时候，反正是被吓了一跳的，但这些都是后话了，现在我们来详解一下Demo,并给出扩展的方向：我们这个例子主要是用了lambda表达式对list进行了求和，求积，对于第一个版本为说，求和的时候，identity的值为0，求积的时候它的值为1，强烈建议你们自己感受一下identity的变化对整个结果的变化产生什么 的影响，改变一下identity的值，再运行一下，你就有结果了，另一个扩展点是：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Integer product3 &#x3D; lists.stream().reduce(1, (a, b) -&gt; &#123;\n           if (b % 2 &#x3D;&#x3D; 0) return a * b; else return a;&#x2F;&#x2F;这里你可以为所欲为!\n&#125;);\nSystem.out.println(&quot;list的偶数的积为:&quot; + product3);&#x2F;&#x2F;48<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"小结一下\"><a href=\"#小结一下\" class=\"headerlink\" title=\"小结一下\"></a>小结一下</h4><p>对于流的缩减操作来说,主要要知道,他只返回一个值,并且它是一个终端操作,然后还有的就是要知道缩减操作的三个约束了,其实最重要的就是无状态性和关联性了.这一小节要说的,也就这么多了,应该很容易就把他收到自己的技能树上面了。</p>\n","excerpt":"","more":"<p>和前面两篇文章一起服用，效果会更佳。通过对流API的基础体验Demo和关键知识点的讲解，相信大家对流API都有一定的认识了，但是流API强大的功能，可不仅仅像前面两篇文章中说的那样简单，大家应该注意到，在第二篇中，我对Stream接口进行介绍的时候，并没有把他的全部方法都进行了解析说明。没错，从这一篇开始，那些还没有讲解的方法，很可能就开始变成我们的主角了，大家从题目上面应该知道了，本期我们要讲的是流API的缩减操作。</p>\n<h4 id=\"何为缩减操作？\"><a href=\"#何为缩减操作？\" class=\"headerlink\" title=\"何为缩减操作？\"></a>何为缩减操作？</h4><p>我们先考虑一下min()和max()，这两个方法我们在第一篇和第二篇中均有提到，其中min()是返回流中的最小值，而max()返回流中最大值，前提是他们存在。他们之间的特点是什么？①都返回了一个值②由一可知，他们是终端操作。如果我们用流API的术语来形容前面这两种特性的结合体的话，它们代表了缩减操作。因为每个缩减操作都把一个流缩减为一个值，好比最大值，最小值。当然流API，把min()和max()，count()这些操作称为特例缩减。即然说到了特例，肯定就有泛化这种概念了，他就是reduce()方法了，其实第二篇当中，他已经出现过了，只是当时我没有去强调他。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;\n&#x2F;&#x2F;、、、忽略其他无关紧要的元素\nT reduce(T identity, BinaryOperator&lt;T&gt; accumulator);\nOptional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);\n&lt;U&gt; U reduce(U identity,\n          BiFunction&lt;U, ? super T, U&gt; accumulator,\n          BinaryOperator&lt;U&gt; combiner);\n｝<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>Stream接口定义了三个版本的reduce()，我们先使用前面两个,</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);&#x2F;&#x2F;1\nOptional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);&#x2F;&#x2F;2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>第一个版本返回的是一个T类型的对象，T代表的是流中的元素类型！第二个版本是返回一个Optional类型对象。对于这两种形式，accumulator是一个操作两个值并得到结果的函数。在第一个版本当中，identity是这样一个值，对于涉及identity和流中任意的累积操作，得到的结果就是元素自身，没有任何改变。比如，如果是加法，他就是0，如果是乘法他就是1。</p>\n<p>其中的accumulator是一个BinaryOperator<T>的类型，他是java.util.function包中声明的函数式接口，它扩展了BiFunction函数式接口.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@FunctionalInterface\npublic interface BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; &#123;\n&#125;\n\n@FunctionalInterface\npublic interface BiFunction&lt;T, U, R&gt; &#123;\n   R apply(T t, U u);&#x2F;&#x2F;notice\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>BiFunction接口中的apply()方法的原型在*<code>//notice</code>*。其中R指定了结果的类型，T，U分别是第一参数的类型和第二个参数的类型，因此apply()对他的两个操作数(t,u)应用到同一个函数上，并返回结果，而对BinaryOperator<T>来说，他在扩展 BiFunction时，指定了所有的类型参数都是相同的T，因此对于BinaryOperator<T>函数式接口的apply来说，他也就变成了  T apply(T t, T u),此外，还有一个需要注意的地方是，在应用reduce()时，apply()的第一个参数t,包含的是一个结果，u包含的是下一个元素。在第一次调用时，将取决于使用reduce()的版本，t可能是单位值，或者是前一个元素。</p>\n<h4 id=\"缩减操作的三个约束\"><a href=\"#缩减操作的三个约束\" class=\"headerlink\" title=\"缩减操作的三个约束\"></a>缩减操作的三个约束</h4><ul>\n<li><strong>无状态</strong></li>\n<li><strong>不干预</strong></li>\n<li><strong>关联性</strong></li>\n</ul>\n<p>无状态，这里可不是LOL的那个无状态，毕竟他退役了。相信读过第二篇文章的同学已经很容易理解了，简单来说无状态就是每个元素都被单独地处理，他和流中的其它元素是没有任何依赖关系的。不干预是指操作数不会改变数据源。最后，操作必须具有关联性，这里的关联性是指标准的数学含义，即，给定一个关联运算符，在一系列操作中使用该运算符，先处理哪一对操作数是无关紧要的。比如，(1 * 2) * 3  &lt;&#x3D;&#x3D;&#x3D;&gt; 1 * (2 * 3)。<code>其中关联性，在并行流中，是至关重要的。</code>下面我用一个简单的例子带着大家实战一下泛化缩减操作reduce()的使用。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Main &#123;\n\n    public static void main(String[] args) &#123;\n        learnStream();\n    &#125;\n\n\n    private static void learnStream() &#123;\n        List&lt;Integer&gt; lists &#x3D; new ArrayList&lt;&gt;();\n        lists.add(1);\n        lists.add(2);\n        lists.add(3);\n        lists.add(4);\n        lists.add(5);\n        lists.add(6);\n\n        Optional&lt;Integer&gt; sum &#x3D; lists.stream().reduce((a, b) -&gt; a + b);\n        if (sum.isPresent()) System.out.println(&quot;list的总和为:&quot; + sum.get());&#x2F;&#x2F;21\n        &#x2F;&#x2F;&lt;&#x3D;&#x3D;&#x3D;&#x3D;&gt; lists.stream().reduce((a, b) -&gt; a + b).ifPresent(System.out::println);\n\n        Integer sum2 &#x3D; lists.stream().reduce(0, (a, b) -&gt; a + b);&#x2F;&#x2F;21\n        System.out.println(&quot;list的总和为:&quot; + sum2);\n\n        Optional&lt;Integer&gt; product &#x3D; lists.stream().reduce((a, b) -&gt; a * b);\n        if (product.isPresent()) System.out.println(&quot;list的积为:&quot; + product.get());&#x2F;&#x2F;720\n\n        Integer product2 &#x3D; lists.stream().reduce(1, (a, b) -&gt; a * b);\n        System.out.println(&quot;list的积为:&quot; + product2);&#x2F;&#x2F;720\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个Demo主要是计算了一个list里面的总和，积的操作，大家可以和传统的算总和，积的方法进行对照，比一比衡量一下就有自己的答案了。但是如果你以为流API仅此而已，那你就错了。越是后面的东西，就越装B，我在刚知道他们的时候，反正是被吓了一跳的，但这些都是后话了，现在我们来详解一下Demo,并给出扩展的方向：我们这个例子主要是用了lambda表达式对list进行了求和，求积，对于第一个版本为说，求和的时候，identity的值为0，求积的时候它的值为1，强烈建议你们自己感受一下identity的变化对整个结果的变化产生什么 的影响，改变一下identity的值，再运行一下，你就有结果了，另一个扩展点是：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Integer product3 &#x3D; lists.stream().reduce(1, (a, b) -&gt; &#123;\n           if (b % 2 &#x3D;&#x3D; 0) return a * b; else return a;&#x2F;&#x2F;这里你可以为所欲为!\n&#125;);\nSystem.out.println(&quot;list的偶数的积为:&quot; + product3);&#x2F;&#x2F;48<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"小结一下\"><a href=\"#小结一下\" class=\"headerlink\" title=\"小结一下\"></a>小结一下</h4><p>对于流的缩减操作来说,主要要知道,他只返回一个值,并且它是一个终端操作,然后还有的就是要知道缩减操作的三个约束了,其实最重要的就是无状态性和关联性了.这一小节要说的,也就这么多了,应该很容易就把他收到自己的技能树上面了。</p>\n"},{"title":"Java 8 新特性之 Stream 流（二）关键知识点","date":"2025-10-15T03:36:33.000Z","_content":"\n我们的第一篇文章，主要是通过一个Demo，让大家体验了一下使用流API的那种酣畅淋漓的感觉。如果你没有实践，我还是再次呼吁你动手敲一敲，自己实实在跑一遍上一篇的Demo。相信你的感受和理解也会随之加深的。继续探索流API的高级功能之前，我们先从接口级别全面了解一下流API，这个对于我们来说是至关重要的。接下来，我给大家准备了一张流API关键知识点的UML图。但是大家只需要花一两分钟，整理看一下就可以了，不需要记住，先有个印象，后面我给大家讲解一些关键的方法:\n\n#### 流API UML\n\n![流API UML](https://upload-images.jianshu.io/upload_images/1640787-129cbee787eef3b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我先整体介绍一下:流API定义的几个接口，都是在java.util.stream包中的.其中上图中的BaseStream接口是最基础的接口，它提供了所有流都可以使用的基本功能:\n\n```\npublic interface BaseStream<T, S extends BaseStream<T, S>> extends AutoCloseable {\n//....先忽略这些具体的细节\n}\n```\n\n由这个接口的定义我们得知，BaseStream是一个泛型接口,它有两个类型参数T和S， 其中T指定了流中的元素的类型,并且由<S extends BaseStream<T, S>>可以知道S必须为BaseStream或BaseStream子类(换句话说,就是S必须是扩展自BaseStream的)。BaseStream继承了AutoCloseable接口。这个接口主要是简化了关闭资源的操作。但是像平时我们操作的集合或数组，基本上都不会出现关闭流的情况。\n\n```\n//由BaseStream接口派生出的流接口包括IntStream ，LongStream，DoubleStream ，Stream<T>\npublic interface IntStream extends BaseStream<Integer, IntStream> {\n}\npublic interface LongStream extends BaseStream<Long, LongStream> {\n}\npublic interface DoubleStream extends BaseStream<Double, DoubleStream> {\n}\n\n//这是最具代表性的接口\npublic interface Stream<T> extends BaseStream<T, Stream<T>> {\n//....先忽略这些具体的细节\n}\n```\n\n由于Stream接口是最具代表性的，所以我们就选择它来讲解，其实在我们学完Stream接口，其它的三个接口，在使用上基本是一致的了，我们上一篇的Demo基本上也是使用Stream接口来做的练习。我们回想一下:在上一个Demo中我们通过集合框架的stream()方法，就能返回一个流了，它的返回类型就是Stream<T>，比如我们Stream<Integer>，由此得知，Stream接口里的类型参数T就是流中的元素的类型。木有错，就是这样滴。到这里，整个系列你们已经全部学会了，下课。\n\n![](https://upload-images.jianshu.io/upload_images/1640787-cac539e2ac3e760f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n战斗才刚刚开始！\n\n![](https://upload-images.jianshu.io/upload_images/1640787-65d8e79c87d2ec76.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n现在是时候开始记忆一些知识了.\n\n#### BaseStream详解:\n\n```\npublic interface BaseStream<T, S extends BaseStream<T, S>> extends AutoCloseable {\n     Iterator<T> iterator();//line2\n     Spliterator<T> spliterator();//line3\n     boolean isParallel();//line4\n     S sequential();//line5\n     S parallel();//line6\n     S unordered();//line7\n     S onClose(Runnable closeHandler);//line8\n     @Override\n     void close();//line10\n}\n```\n\n* **Iterator<T> iterator();**  *`//line2`*\n获得流的迭代器，并返回对该迭代器的引用(终端操作)\n* **Spliterator<T> spliterator();** *`//line3`*\n获取流的spliterator，并返回其引用(终端操作)\n* **boolean isParallel();** *`//line4`*\n如果调用流是一个并行流，则返回true;如果调用流是一个顺序流，则返回false。\n* **S sequential();** *`//line5`*\n基于调用流，返回一个顺序流。如果调用流已经是顺序流了，就返回该流。(中间操作)\n* **S parallel();** *`//line6`*\n基于调用流，返回一个并行流。如果调用流已经是并行流了，就返回该流。(中间操作)\n* **S unordered();** *`//line7`*\n基于调用流，返回一个无序流。如果调用流已经是无序流了，就返回该流。(中间操作)\n* **S onClose(Runnable closeHandler);** *`//line8`*\n返回一个新流，closeHandler指定了该流的关闭处理程序，当关闭该流时，将调用这个处理程序。(中间操作)\n* **void close();** *`//line10`*\n从AutoCloseable继承来的，调用注册关闭处理程序，关闭调用流(很少会被使用到)\n\n#### \"终端操作\"&\"中间操作\"\n\n细心的同学应该注意到了，BaseStream接口里面的很多方法都在最后标识了(终端操作)和(中间操作)，它们之间的区别是非常重要的。\n* **终端操作**   会消费流，这种操作会产生一个结果的，比如上面的 iterator()和 spliterator()，以及上一篇中提到的min()和max()，或者是执行某一种操作，比如上一篇的forEach()，如果一个流被消费过了，那它就不能被重用的。\n\n* **中间操作**   中间操作会产生另一个流。因此中间操作可以用来创建执行一系列动作的管道。一个特别需要注意的点是:中间操作不是立即发生的。相反，当在中间操作创建的新流上执行完终端操作后，中间操作指定的操作才会发生。所以中间操作是延迟发生的，中间操作的延迟行为主要是让流API能够更加高效地执行。\n\n#### \"中间操作\"的状态\n\n流的中间操作，可以为分`无状态操作`和`有状态操作`两种，在无状态操作中，在处理流中的元素时，会对当前的元素进行单独处理。比如:谓词过滤操作，因为每个元素都是被单独进行处理的，所有它和流中的其它元素无关，因此被称为无状态操作;而在有状态操作中，某个元素的处理可能依赖于其他元素。比如查找最小值，最大值，和排序，因为他们都依赖于其他的元素。因此为称为有状态操作。`当需要进行并行处理流时，有状态的操作和无状态的区别是非常重要的，因为有状态操作可能需要几次处理才能完成，后面的文章我将会给大家详细地讲，现在只需要正常学习下去就可以了`\n\n另外，指出一点，如果大家了解泛型的话，应该知道，泛型的类型参数只能是引用类型，因此Stream操作的对象只能是引用类型的，不能用于基本类型。当然官方早已考虑到这一点了，前面你们看到的IntStream，LongStream，DoubleStream就是官方给我们提供的处理基本类型的流了。此处是不是应该给他们掌声！\n\n#### Stream详解\n\n在有了前面的那些知识作铺垫之后，学Stream接口应该会顺风顺水了。还是先看看Stream的详情先:\n\n```\npublic interface Stream<T> extends BaseStream<T, Stream<T>> {\n    Stream<T> filter(Predicate<? super T> predicate);//line2\n    <R> Stream<R> map(Function<? super T, ? extends R> mapper);//line3\n    IntStream mapToInt(ToIntFunction<? super T> mapper);//line4\n    LongStream mapToLong(ToLongFunction<? super T> mapper);\n    DoubleStream mapToDouble(ToDoubleFunction<? super T> mapper);\n    <R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);\n    IntStream flatMapToInt(Function<? super T, ? extends IntStream> mapper);\n    LongStream flatMapToLong(Function<? super T, ? extends LongStream> mapper);\n    DoubleStream flatMapToDouble(Function<? super T, ? extends DoubleStream> mapper);\n    Stream<T> distinct();\n    Stream<T> sorted();//line12\n    Stream<T> sorted(Comparator<? super T> comparator);//line13\n    Stream<T> peek(Consumer<? super T> action);\n    Stream<T> limit(long maxSize);\n    Stream<T> skip(long n);\n    void forEach(Consumer<? super T> action);//line17\n    void forEachOrdered(Consumer<? super T> action);//line18\n    Object[] toArray();\n    <A> A[] toArray(IntFunction<A[]> generator);\n    T reduce(T identity, BinaryOperator<T> accumulator);\n    Optional<T> reduce(BinaryOperator<T> accumulator);\n    <U> U reduce(U identity,\n                 BiFunction<U, ? super T, U> accumulator,\n                 BinaryOperator<U> combiner);\n    <R> R collect(Supplier<R> supplier,\n                  BiConsumer<R, ? super T> accumulator,\n                  BiConsumer<R, R> combiner);\n    <R, A> R collect(Collector<? super T, A, R> collector);\n    Optional<T> min(Comparator<? super T> comparator);//line30\n    Optional<T> max(Comparator<? super T> comparator);//line31\n    long count();\n    boolean anyMatch(Predicate<? super T> predicate);\n    boolean allMatch(Predicate<? super T> predicate);\n    boolean noneMatch(Predicate<? super T> predicate);\n    Optional<T> findFirst();\n    Optional<T> findAny();\n\n    // Static factories\n\n    public static<T> Builder<T> builder() {\n        return new Streams.StreamBuilderImpl<>();\n    }\n\n\n    public static<T> Stream<T> empty() {\n        return StreamSupport.stream(Spliterators.<T>emptySpliterator(), false);\n    }\n\n\n    public static<T> Stream<T> of(T t) {\n        return StreamSupport.stream(new Streams.StreamBuilderImpl<>(t), false);\n    }\n\n\n    @SafeVarargs\n    @SuppressWarnings(\"varargs\") // Creating a stream from an array is safe\n    public static<T> Stream<T> of(T... values) {\n        return Arrays.stream(values);\n    }\n\n\n    public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f) {\n        Objects.requireNonNull(f);\n        final Iterator<T> iterator = new Iterator<T>() {\n            @SuppressWarnings(\"unchecked\")\n            T t = (T) Streams.NONE;\n\n            @Override\n            public boolean hasNext() {\n                return true;\n            }\n\n            @Override\n            public T next() {\n                return t = (t == Streams.NONE) ? seed : f.apply(t);\n            }\n        };\n        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(\n                iterator,\n                Spliterator.ORDERED | Spliterator.IMMUTABLE), false);\n    }\n\n\n    public static<T> Stream<T> generate(Supplier<T> s) {\n        Objects.requireNonNull(s);\n        return StreamSupport.stream(\n                new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef<>(Long.MAX_VALUE, s), false);\n    }\n\n\n    public static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b) {\n        Objects.requireNonNull(a);\n        Objects.requireNonNull(b);\n\n        @SuppressWarnings(\"unchecked\")\n        Spliterator<T> split = new Streams.ConcatSpliterator.OfRef<>(\n                (Spliterator<T>) a.spliterator(), (Spliterator<T>) b.spliterator());\n        Stream<T> stream = StreamSupport.stream(split, a.isParallel() || b.isParallel());\n        return stream.onClose(Streams.composedClose(a, b));\n    }\n}\n```\n\n* **Stream<T> filter(Predicate<? super T> predicate);**  *`//line2`*\n产生一个新流，其中包含调用流中满足predicate指定的谓词元素(中间操作)\n* **<R> Stream<R> map(Function<? super T, ? extends R> mapper);**  *`//line3`*\n产生一个新流，对调用流中的元素应用mapper，新流中包含这些元素。(中间操作)\n* **IntStream mapToInt(ToIntFunction<? super T> mapper);** *`//line4`*\n对调用流中元素应用mapper，产生包含这些元素的一个新IntStream流。(中间操作)\n* **Stream<T> sorted();** *`//line12`*\n* **Stream<T> sorted(Comparator<? super T> comparator);** *`//line13`*`\n产生一个自然顺序排序或者指定排序条件的新流(中间操作)\n* **void forEach(Consumer<? super T> action);**  *`//line17`*\n* **void forEachOrdered(Consumer<? super T> action);** *`//line18`*\n遍历了流中的元素(终端操作)\n* **Optional<T> min(Comparator<? super T> comparator)**  *`//line30`*\n* **Optional<T> max(Comparator<? super T> comparator);** *`//line31`*\n获得流中最大最小值，比较器可以由自己定义，也可以使用JDK提供的(终端操作)\n\n#### 小结一下\n\n这一篇主要是介绍了流API的一些关键方法，和一些关键的概念，虽然稍微枯燥了一点，但是，不能否认，全面地学习流API，会让你对流API的认识会更加的深刻，所以如果时间允许，请再认真读读这一篇文章吧，当然，也可以在实践中慢慢认识它们，但是，对于这些基本概念的知识，你越早掌握，对你的益处是更加大的。到此为止，流API的基础知识已经学完了，后面的几篇文章我们就要开始更加深入地理解和运用他们实现一起强有力的功能了！\n","source":"_posts/新特性/Java8/Stream/Java 8 新特性之 Stream 流（二）关键知识点.md","raw":"---\ntitle: Java 8 新特性之 Stream 流（二）关键知识点\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n\n我们的第一篇文章，主要是通过一个Demo，让大家体验了一下使用流API的那种酣畅淋漓的感觉。如果你没有实践，我还是再次呼吁你动手敲一敲，自己实实在跑一遍上一篇的Demo。相信你的感受和理解也会随之加深的。继续探索流API的高级功能之前，我们先从接口级别全面了解一下流API，这个对于我们来说是至关重要的。接下来，我给大家准备了一张流API关键知识点的UML图。但是大家只需要花一两分钟，整理看一下就可以了，不需要记住，先有个印象，后面我给大家讲解一些关键的方法:\n\n#### 流API UML\n\n![流API UML](https://upload-images.jianshu.io/upload_images/1640787-129cbee787eef3b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我先整体介绍一下:流API定义的几个接口，都是在java.util.stream包中的.其中上图中的BaseStream接口是最基础的接口，它提供了所有流都可以使用的基本功能:\n\n```\npublic interface BaseStream<T, S extends BaseStream<T, S>> extends AutoCloseable {\n//....先忽略这些具体的细节\n}\n```\n\n由这个接口的定义我们得知，BaseStream是一个泛型接口,它有两个类型参数T和S， 其中T指定了流中的元素的类型,并且由<S extends BaseStream<T, S>>可以知道S必须为BaseStream或BaseStream子类(换句话说,就是S必须是扩展自BaseStream的)。BaseStream继承了AutoCloseable接口。这个接口主要是简化了关闭资源的操作。但是像平时我们操作的集合或数组，基本上都不会出现关闭流的情况。\n\n```\n//由BaseStream接口派生出的流接口包括IntStream ，LongStream，DoubleStream ，Stream<T>\npublic interface IntStream extends BaseStream<Integer, IntStream> {\n}\npublic interface LongStream extends BaseStream<Long, LongStream> {\n}\npublic interface DoubleStream extends BaseStream<Double, DoubleStream> {\n}\n\n//这是最具代表性的接口\npublic interface Stream<T> extends BaseStream<T, Stream<T>> {\n//....先忽略这些具体的细节\n}\n```\n\n由于Stream接口是最具代表性的，所以我们就选择它来讲解，其实在我们学完Stream接口，其它的三个接口，在使用上基本是一致的了，我们上一篇的Demo基本上也是使用Stream接口来做的练习。我们回想一下:在上一个Demo中我们通过集合框架的stream()方法，就能返回一个流了，它的返回类型就是Stream<T>，比如我们Stream<Integer>，由此得知，Stream接口里的类型参数T就是流中的元素的类型。木有错，就是这样滴。到这里，整个系列你们已经全部学会了，下课。\n\n![](https://upload-images.jianshu.io/upload_images/1640787-cac539e2ac3e760f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n战斗才刚刚开始！\n\n![](https://upload-images.jianshu.io/upload_images/1640787-65d8e79c87d2ec76.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n现在是时候开始记忆一些知识了.\n\n#### BaseStream详解:\n\n```\npublic interface BaseStream<T, S extends BaseStream<T, S>> extends AutoCloseable {\n     Iterator<T> iterator();//line2\n     Spliterator<T> spliterator();//line3\n     boolean isParallel();//line4\n     S sequential();//line5\n     S parallel();//line6\n     S unordered();//line7\n     S onClose(Runnable closeHandler);//line8\n     @Override\n     void close();//line10\n}\n```\n\n* **Iterator<T> iterator();**  *`//line2`*\n获得流的迭代器，并返回对该迭代器的引用(终端操作)\n* **Spliterator<T> spliterator();** *`//line3`*\n获取流的spliterator，并返回其引用(终端操作)\n* **boolean isParallel();** *`//line4`*\n如果调用流是一个并行流，则返回true;如果调用流是一个顺序流，则返回false。\n* **S sequential();** *`//line5`*\n基于调用流，返回一个顺序流。如果调用流已经是顺序流了，就返回该流。(中间操作)\n* **S parallel();** *`//line6`*\n基于调用流，返回一个并行流。如果调用流已经是并行流了，就返回该流。(中间操作)\n* **S unordered();** *`//line7`*\n基于调用流，返回一个无序流。如果调用流已经是无序流了，就返回该流。(中间操作)\n* **S onClose(Runnable closeHandler);** *`//line8`*\n返回一个新流，closeHandler指定了该流的关闭处理程序，当关闭该流时，将调用这个处理程序。(中间操作)\n* **void close();** *`//line10`*\n从AutoCloseable继承来的，调用注册关闭处理程序，关闭调用流(很少会被使用到)\n\n#### \"终端操作\"&\"中间操作\"\n\n细心的同学应该注意到了，BaseStream接口里面的很多方法都在最后标识了(终端操作)和(中间操作)，它们之间的区别是非常重要的。\n* **终端操作**   会消费流，这种操作会产生一个结果的，比如上面的 iterator()和 spliterator()，以及上一篇中提到的min()和max()，或者是执行某一种操作，比如上一篇的forEach()，如果一个流被消费过了，那它就不能被重用的。\n\n* **中间操作**   中间操作会产生另一个流。因此中间操作可以用来创建执行一系列动作的管道。一个特别需要注意的点是:中间操作不是立即发生的。相反，当在中间操作创建的新流上执行完终端操作后，中间操作指定的操作才会发生。所以中间操作是延迟发生的，中间操作的延迟行为主要是让流API能够更加高效地执行。\n\n#### \"中间操作\"的状态\n\n流的中间操作，可以为分`无状态操作`和`有状态操作`两种，在无状态操作中，在处理流中的元素时，会对当前的元素进行单独处理。比如:谓词过滤操作，因为每个元素都是被单独进行处理的，所有它和流中的其它元素无关，因此被称为无状态操作;而在有状态操作中，某个元素的处理可能依赖于其他元素。比如查找最小值，最大值，和排序，因为他们都依赖于其他的元素。因此为称为有状态操作。`当需要进行并行处理流时，有状态的操作和无状态的区别是非常重要的，因为有状态操作可能需要几次处理才能完成，后面的文章我将会给大家详细地讲，现在只需要正常学习下去就可以了`\n\n另外，指出一点，如果大家了解泛型的话，应该知道，泛型的类型参数只能是引用类型，因此Stream操作的对象只能是引用类型的，不能用于基本类型。当然官方早已考虑到这一点了，前面你们看到的IntStream，LongStream，DoubleStream就是官方给我们提供的处理基本类型的流了。此处是不是应该给他们掌声！\n\n#### Stream详解\n\n在有了前面的那些知识作铺垫之后，学Stream接口应该会顺风顺水了。还是先看看Stream的详情先:\n\n```\npublic interface Stream<T> extends BaseStream<T, Stream<T>> {\n    Stream<T> filter(Predicate<? super T> predicate);//line2\n    <R> Stream<R> map(Function<? super T, ? extends R> mapper);//line3\n    IntStream mapToInt(ToIntFunction<? super T> mapper);//line4\n    LongStream mapToLong(ToLongFunction<? super T> mapper);\n    DoubleStream mapToDouble(ToDoubleFunction<? super T> mapper);\n    <R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);\n    IntStream flatMapToInt(Function<? super T, ? extends IntStream> mapper);\n    LongStream flatMapToLong(Function<? super T, ? extends LongStream> mapper);\n    DoubleStream flatMapToDouble(Function<? super T, ? extends DoubleStream> mapper);\n    Stream<T> distinct();\n    Stream<T> sorted();//line12\n    Stream<T> sorted(Comparator<? super T> comparator);//line13\n    Stream<T> peek(Consumer<? super T> action);\n    Stream<T> limit(long maxSize);\n    Stream<T> skip(long n);\n    void forEach(Consumer<? super T> action);//line17\n    void forEachOrdered(Consumer<? super T> action);//line18\n    Object[] toArray();\n    <A> A[] toArray(IntFunction<A[]> generator);\n    T reduce(T identity, BinaryOperator<T> accumulator);\n    Optional<T> reduce(BinaryOperator<T> accumulator);\n    <U> U reduce(U identity,\n                 BiFunction<U, ? super T, U> accumulator,\n                 BinaryOperator<U> combiner);\n    <R> R collect(Supplier<R> supplier,\n                  BiConsumer<R, ? super T> accumulator,\n                  BiConsumer<R, R> combiner);\n    <R, A> R collect(Collector<? super T, A, R> collector);\n    Optional<T> min(Comparator<? super T> comparator);//line30\n    Optional<T> max(Comparator<? super T> comparator);//line31\n    long count();\n    boolean anyMatch(Predicate<? super T> predicate);\n    boolean allMatch(Predicate<? super T> predicate);\n    boolean noneMatch(Predicate<? super T> predicate);\n    Optional<T> findFirst();\n    Optional<T> findAny();\n\n    // Static factories\n\n    public static<T> Builder<T> builder() {\n        return new Streams.StreamBuilderImpl<>();\n    }\n\n\n    public static<T> Stream<T> empty() {\n        return StreamSupport.stream(Spliterators.<T>emptySpliterator(), false);\n    }\n\n\n    public static<T> Stream<T> of(T t) {\n        return StreamSupport.stream(new Streams.StreamBuilderImpl<>(t), false);\n    }\n\n\n    @SafeVarargs\n    @SuppressWarnings(\"varargs\") // Creating a stream from an array is safe\n    public static<T> Stream<T> of(T... values) {\n        return Arrays.stream(values);\n    }\n\n\n    public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f) {\n        Objects.requireNonNull(f);\n        final Iterator<T> iterator = new Iterator<T>() {\n            @SuppressWarnings(\"unchecked\")\n            T t = (T) Streams.NONE;\n\n            @Override\n            public boolean hasNext() {\n                return true;\n            }\n\n            @Override\n            public T next() {\n                return t = (t == Streams.NONE) ? seed : f.apply(t);\n            }\n        };\n        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(\n                iterator,\n                Spliterator.ORDERED | Spliterator.IMMUTABLE), false);\n    }\n\n\n    public static<T> Stream<T> generate(Supplier<T> s) {\n        Objects.requireNonNull(s);\n        return StreamSupport.stream(\n                new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef<>(Long.MAX_VALUE, s), false);\n    }\n\n\n    public static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b) {\n        Objects.requireNonNull(a);\n        Objects.requireNonNull(b);\n\n        @SuppressWarnings(\"unchecked\")\n        Spliterator<T> split = new Streams.ConcatSpliterator.OfRef<>(\n                (Spliterator<T>) a.spliterator(), (Spliterator<T>) b.spliterator());\n        Stream<T> stream = StreamSupport.stream(split, a.isParallel() || b.isParallel());\n        return stream.onClose(Streams.composedClose(a, b));\n    }\n}\n```\n\n* **Stream<T> filter(Predicate<? super T> predicate);**  *`//line2`*\n产生一个新流，其中包含调用流中满足predicate指定的谓词元素(中间操作)\n* **<R> Stream<R> map(Function<? super T, ? extends R> mapper);**  *`//line3`*\n产生一个新流，对调用流中的元素应用mapper，新流中包含这些元素。(中间操作)\n* **IntStream mapToInt(ToIntFunction<? super T> mapper);** *`//line4`*\n对调用流中元素应用mapper，产生包含这些元素的一个新IntStream流。(中间操作)\n* **Stream<T> sorted();** *`//line12`*\n* **Stream<T> sorted(Comparator<? super T> comparator);** *`//line13`*`\n产生一个自然顺序排序或者指定排序条件的新流(中间操作)\n* **void forEach(Consumer<? super T> action);**  *`//line17`*\n* **void forEachOrdered(Consumer<? super T> action);** *`//line18`*\n遍历了流中的元素(终端操作)\n* **Optional<T> min(Comparator<? super T> comparator)**  *`//line30`*\n* **Optional<T> max(Comparator<? super T> comparator);** *`//line31`*\n获得流中最大最小值，比较器可以由自己定义，也可以使用JDK提供的(终端操作)\n\n#### 小结一下\n\n这一篇主要是介绍了流API的一些关键方法，和一些关键的概念，虽然稍微枯燥了一点，但是，不能否认，全面地学习流API，会让你对流API的认识会更加的深刻，所以如果时间允许，请再认真读读这一篇文章吧，当然，也可以在实践中慢慢认识它们，但是，对于这些基本概念的知识，你越早掌握，对你的益处是更加大的。到此为止，流API的基础知识已经学完了，后面的几篇文章我们就要开始更加深入地理解和运用他们实现一起强有力的功能了！\n","slug":"新特性/Java8/Stream/Java 8 新特性之 Stream 流（二）关键知识点","published":1,"updated":"2025-10-15T07:20:51.443Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu077a006rqkd4flbfd9t1","content":"<p>我们的第一篇文章，主要是通过一个Demo，让大家体验了一下使用流API的那种酣畅淋漓的感觉。如果你没有实践，我还是再次呼吁你动手敲一敲，自己实实在跑一遍上一篇的Demo。相信你的感受和理解也会随之加深的。继续探索流API的高级功能之前，我们先从接口级别全面了解一下流API，这个对于我们来说是至关重要的。接下来，我给大家准备了一张流API关键知识点的UML图。但是大家只需要花一两分钟，整理看一下就可以了，不需要记住，先有个印象，后面我给大家讲解一些关键的方法:</p>\n<h4 id=\"流API-UML\"><a href=\"#流API-UML\" class=\"headerlink\" title=\"流API UML\"></a>流API UML</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/1640787-129cbee787eef3b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"流API UML\"></p>\n<p>我先整体介绍一下:流API定义的几个接口，都是在java.util.stream包中的.其中上图中的BaseStream接口是最基础的接口，它提供了所有流都可以使用的基本功能:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface BaseStream&lt;T, S extends BaseStream&lt;T, S&gt;&gt; extends AutoCloseable &#123;\n&#x2F;&#x2F;....先忽略这些具体的细节\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>由这个接口的定义我们得知，BaseStream是一个泛型接口,它有两个类型参数T和S， 其中T指定了流中的元素的类型,并且由&lt;S extends BaseStream&lt;T, S&gt;&gt;可以知道S必须为BaseStream或BaseStream子类(换句话说,就是S必须是扩展自BaseStream的)。BaseStream继承了AutoCloseable接口。这个接口主要是简化了关闭资源的操作。但是像平时我们操作的集合或数组，基本上都不会出现关闭流的情况。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;由BaseStream接口派生出的流接口包括IntStream ，LongStream，DoubleStream ，Stream&lt;T&gt;\npublic interface IntStream extends BaseStream&lt;Integer, IntStream&gt; &#123;\n&#125;\npublic interface LongStream extends BaseStream&lt;Long, LongStream&gt; &#123;\n&#125;\npublic interface DoubleStream extends BaseStream&lt;Double, DoubleStream&gt; &#123;\n&#125;\n\n&#x2F;&#x2F;这是最具代表性的接口\npublic interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;\n&#x2F;&#x2F;....先忽略这些具体的细节\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>由于Stream接口是最具代表性的，所以我们就选择它来讲解，其实在我们学完Stream接口，其它的三个接口，在使用上基本是一致的了，我们上一篇的Demo基本上也是使用Stream接口来做的练习。我们回想一下:在上一个Demo中我们通过集合框架的stream()方法，就能返回一个流了，它的返回类型就是Stream<T>，比如我们Stream<Integer>，由此得知，Stream接口里的类型参数T就是流中的元素的类型。木有错，就是这样滴。到这里，整个系列你们已经全部学会了，下课。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1640787-cac539e2ac3e760f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>战斗才刚刚开始！</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1640787-65d8e79c87d2ec76.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>现在是时候开始记忆一些知识了.</p>\n<h4 id=\"BaseStream详解\"><a href=\"#BaseStream详解\" class=\"headerlink\" title=\"BaseStream详解:\"></a>BaseStream详解:</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface BaseStream&lt;T, S extends BaseStream&lt;T, S&gt;&gt; extends AutoCloseable &#123;\n     Iterator&lt;T&gt; iterator();&#x2F;&#x2F;line2\n     Spliterator&lt;T&gt; spliterator();&#x2F;&#x2F;line3\n     boolean isParallel();&#x2F;&#x2F;line4\n     S sequential();&#x2F;&#x2F;line5\n     S parallel();&#x2F;&#x2F;line6\n     S unordered();&#x2F;&#x2F;line7\n     S onClose(Runnable closeHandler);&#x2F;&#x2F;line8\n     @Override\n     void close();&#x2F;&#x2F;line10\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><strong>Iterator<T> iterator();</strong>  <em><code>//line2</code></em><br>获得流的迭代器，并返回对该迭代器的引用(终端操作)</li>\n<li><strong>Spliterator<T> spliterator();</strong> <em><code>//line3</code></em><br>获取流的spliterator，并返回其引用(终端操作)</li>\n<li><strong>boolean isParallel();</strong> <em><code>//line4</code></em><br>如果调用流是一个并行流，则返回true;如果调用流是一个顺序流，则返回false。</li>\n<li><strong>S sequential();</strong> <em><code>//line5</code></em><br>基于调用流，返回一个顺序流。如果调用流已经是顺序流了，就返回该流。(中间操作)</li>\n<li><strong>S parallel();</strong> <em><code>//line6</code></em><br>基于调用流，返回一个并行流。如果调用流已经是并行流了，就返回该流。(中间操作)</li>\n<li><strong>S unordered();</strong> <em><code>//line7</code></em><br>基于调用流，返回一个无序流。如果调用流已经是无序流了，就返回该流。(中间操作)</li>\n<li><strong>S onClose(Runnable closeHandler);</strong> <em><code>//line8</code></em><br>返回一个新流，closeHandler指定了该流的关闭处理程序，当关闭该流时，将调用这个处理程序。(中间操作)</li>\n<li><strong>void close();</strong> <em><code>//line10</code></em><br>从AutoCloseable继承来的，调用注册关闭处理程序，关闭调用流(很少会被使用到)</li>\n</ul>\n<h4 id=\"“终端操作”-”中间操作”\"><a href=\"#“终端操作”-”中间操作”\" class=\"headerlink\" title=\"“终端操作”&amp;”中间操作”\"></a>“终端操作”&amp;”中间操作”</h4><p>细心的同学应该注意到了，BaseStream接口里面的很多方法都在最后标识了(终端操作)和(中间操作)，它们之间的区别是非常重要的。</p>\n<ul>\n<li><p><strong>终端操作</strong>   会消费流，这种操作会产生一个结果的，比如上面的 iterator()和 spliterator()，以及上一篇中提到的min()和max()，或者是执行某一种操作，比如上一篇的forEach()，如果一个流被消费过了，那它就不能被重用的。</p>\n</li>\n<li><p><strong>中间操作</strong>   中间操作会产生另一个流。因此中间操作可以用来创建执行一系列动作的管道。一个特别需要注意的点是:中间操作不是立即发生的。相反，当在中间操作创建的新流上执行完终端操作后，中间操作指定的操作才会发生。所以中间操作是延迟发生的，中间操作的延迟行为主要是让流API能够更加高效地执行。</p>\n</li>\n</ul>\n<h4 id=\"“中间操作”的状态\"><a href=\"#“中间操作”的状态\" class=\"headerlink\" title=\"“中间操作”的状态\"></a>“中间操作”的状态</h4><p>流的中间操作，可以为分<code>无状态操作</code>和<code>有状态操作</code>两种，在无状态操作中，在处理流中的元素时，会对当前的元素进行单独处理。比如:谓词过滤操作，因为每个元素都是被单独进行处理的，所有它和流中的其它元素无关，因此被称为无状态操作;而在有状态操作中，某个元素的处理可能依赖于其他元素。比如查找最小值，最大值，和排序，因为他们都依赖于其他的元素。因此为称为有状态操作。<code>当需要进行并行处理流时，有状态的操作和无状态的区别是非常重要的，因为有状态操作可能需要几次处理才能完成，后面的文章我将会给大家详细地讲，现在只需要正常学习下去就可以了</code></p>\n<p>另外，指出一点，如果大家了解泛型的话，应该知道，泛型的类型参数只能是引用类型，因此Stream操作的对象只能是引用类型的，不能用于基本类型。当然官方早已考虑到这一点了，前面你们看到的IntStream，LongStream，DoubleStream就是官方给我们提供的处理基本类型的流了。此处是不是应该给他们掌声！</p>\n<h4 id=\"Stream详解\"><a href=\"#Stream详解\" class=\"headerlink\" title=\"Stream详解\"></a>Stream详解</h4><p>在有了前面的那些知识作铺垫之后，学Stream接口应该会顺风顺水了。还是先看看Stream的详情先:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;\n    Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);&#x2F;&#x2F;line2\n    &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);&#x2F;&#x2F;line3\n    IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper);&#x2F;&#x2F;line4\n    LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper);\n    DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper);\n    &lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper);\n    IntStream flatMapToInt(Function&lt;? super T, ? extends IntStream&gt; mapper);\n    LongStream flatMapToLong(Function&lt;? super T, ? extends LongStream&gt; mapper);\n    DoubleStream flatMapToDouble(Function&lt;? super T, ? extends DoubleStream&gt; mapper);\n    Stream&lt;T&gt; distinct();\n    Stream&lt;T&gt; sorted();&#x2F;&#x2F;line12\n    Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator);&#x2F;&#x2F;line13\n    Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action);\n    Stream&lt;T&gt; limit(long maxSize);\n    Stream&lt;T&gt; skip(long n);\n    void forEach(Consumer&lt;? super T&gt; action);&#x2F;&#x2F;line17\n    void forEachOrdered(Consumer&lt;? super T&gt; action);&#x2F;&#x2F;line18\n    Object[] toArray();\n    &lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);\n    T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);\n    Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);\n    &lt;U&gt; U reduce(U identity,\n                 BiFunction&lt;U, ? super T, U&gt; accumulator,\n                 BinaryOperator&lt;U&gt; combiner);\n    &lt;R&gt; R collect(Supplier&lt;R&gt; supplier,\n                  BiConsumer&lt;R, ? super T&gt; accumulator,\n                  BiConsumer&lt;R, R&gt; combiner);\n    &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);\n    Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator);&#x2F;&#x2F;line30\n    Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator);&#x2F;&#x2F;line31\n    long count();\n    boolean anyMatch(Predicate&lt;? super T&gt; predicate);\n    boolean allMatch(Predicate&lt;? super T&gt; predicate);\n    boolean noneMatch(Predicate&lt;? super T&gt; predicate);\n    Optional&lt;T&gt; findFirst();\n    Optional&lt;T&gt; findAny();\n\n    &#x2F;&#x2F; Static factories\n\n    public static&lt;T&gt; Builder&lt;T&gt; builder() &#123;\n        return new Streams.StreamBuilderImpl&lt;&gt;();\n    &#125;\n\n\n    public static&lt;T&gt; Stream&lt;T&gt; empty() &#123;\n        return StreamSupport.stream(Spliterators.&lt;T&gt;emptySpliterator(), false);\n    &#125;\n\n\n    public static&lt;T&gt; Stream&lt;T&gt; of(T t) &#123;\n        return StreamSupport.stream(new Streams.StreamBuilderImpl&lt;&gt;(t), false);\n    &#125;\n\n\n    @SafeVarargs\n    @SuppressWarnings(&quot;varargs&quot;) &#x2F;&#x2F; Creating a stream from an array is safe\n    public static&lt;T&gt; Stream&lt;T&gt; of(T... values) &#123;\n        return Arrays.stream(values);\n    &#125;\n\n\n    public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) &#123;\n        Objects.requireNonNull(f);\n        final Iterator&lt;T&gt; iterator &#x3D; new Iterator&lt;T&gt;() &#123;\n            @SuppressWarnings(&quot;unchecked&quot;)\n            T t &#x3D; (T) Streams.NONE;\n\n            @Override\n            public boolean hasNext() &#123;\n                return true;\n            &#125;\n\n            @Override\n            public T next() &#123;\n                return t &#x3D; (t &#x3D;&#x3D; Streams.NONE) ? seed : f.apply(t);\n            &#125;\n        &#125;;\n        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(\n                iterator,\n                Spliterator.ORDERED | Spliterator.IMMUTABLE), false);\n    &#125;\n\n\n    public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s) &#123;\n        Objects.requireNonNull(s);\n        return StreamSupport.stream(\n                new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef&lt;&gt;(Long.MAX_VALUE, s), false);\n    &#125;\n\n\n    public static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) &#123;\n        Objects.requireNonNull(a);\n        Objects.requireNonNull(b);\n\n        @SuppressWarnings(&quot;unchecked&quot;)\n        Spliterator&lt;T&gt; split &#x3D; new Streams.ConcatSpliterator.OfRef&lt;&gt;(\n                (Spliterator&lt;T&gt;) a.spliterator(), (Spliterator&lt;T&gt;) b.spliterator());\n        Stream&lt;T&gt; stream &#x3D; StreamSupport.stream(split, a.isParallel() || b.isParallel());\n        return stream.onClose(Streams.composedClose(a, b));\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><strong>Stream<T> filter(Predicate&lt;? super T&gt; predicate);</strong>  <em><code>//line2</code></em><br>产生一个新流，其中包含调用流中满足predicate指定的谓词元素(中间操作)</li>\n<li><strong><R> Stream<R> map(Function&lt;? super T, ? extends R&gt; mapper);</strong>  <em><code>//line3</code></em><br>产生一个新流，对调用流中的元素应用mapper，新流中包含这些元素。(中间操作)</li>\n<li><strong>IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper);</strong> <em><code>//line4</code></em><br>对调用流中元素应用mapper，产生包含这些元素的一个新IntStream流。(中间操作)</li>\n<li><strong>Stream<T> sorted();</strong> <em><code>//line12</code></em></li>\n<li><strong>Stream<T> sorted(Comparator&lt;? super T&gt; comparator);</strong> <em><code>//line13</code></em>&#96;<br>产生一个自然顺序排序或者指定排序条件的新流(中间操作)</li>\n<li><strong>void forEach(Consumer&lt;? super T&gt; action);</strong>  <em><code>//line17</code></em></li>\n<li><strong>void forEachOrdered(Consumer&lt;? super T&gt; action);</strong> <em><code>//line18</code></em><br>遍历了流中的元素(终端操作)</li>\n<li><strong>Optional<T> min(Comparator&lt;? super T&gt; comparator)</strong>  <em><code>//line30</code></em></li>\n<li><strong>Optional<T> max(Comparator&lt;? super T&gt; comparator);</strong> <em><code>//line31</code></em><br>获得流中最大最小值，比较器可以由自己定义，也可以使用JDK提供的(终端操作)</li>\n</ul>\n<h4 id=\"小结一下\"><a href=\"#小结一下\" class=\"headerlink\" title=\"小结一下\"></a>小结一下</h4><p>这一篇主要是介绍了流API的一些关键方法，和一些关键的概念，虽然稍微枯燥了一点，但是，不能否认，全面地学习流API，会让你对流API的认识会更加的深刻，所以如果时间允许，请再认真读读这一篇文章吧，当然，也可以在实践中慢慢认识它们，但是，对于这些基本概念的知识，你越早掌握，对你的益处是更加大的。到此为止，流API的基础知识已经学完了，后面的几篇文章我们就要开始更加深入地理解和运用他们实现一起强有力的功能了！</p>\n","excerpt":"","more":"<p>我们的第一篇文章，主要是通过一个Demo，让大家体验了一下使用流API的那种酣畅淋漓的感觉。如果你没有实践，我还是再次呼吁你动手敲一敲，自己实实在跑一遍上一篇的Demo。相信你的感受和理解也会随之加深的。继续探索流API的高级功能之前，我们先从接口级别全面了解一下流API，这个对于我们来说是至关重要的。接下来，我给大家准备了一张流API关键知识点的UML图。但是大家只需要花一两分钟，整理看一下就可以了，不需要记住，先有个印象，后面我给大家讲解一些关键的方法:</p>\n<h4 id=\"流API-UML\"><a href=\"#流API-UML\" class=\"headerlink\" title=\"流API UML\"></a>流API UML</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/1640787-129cbee787eef3b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"流API UML\"></p>\n<p>我先整体介绍一下:流API定义的几个接口，都是在java.util.stream包中的.其中上图中的BaseStream接口是最基础的接口，它提供了所有流都可以使用的基本功能:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface BaseStream&lt;T, S extends BaseStream&lt;T, S&gt;&gt; extends AutoCloseable &#123;\n&#x2F;&#x2F;....先忽略这些具体的细节\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>由这个接口的定义我们得知，BaseStream是一个泛型接口,它有两个类型参数T和S， 其中T指定了流中的元素的类型,并且由&lt;S extends BaseStream&lt;T, S&gt;&gt;可以知道S必须为BaseStream或BaseStream子类(换句话说,就是S必须是扩展自BaseStream的)。BaseStream继承了AutoCloseable接口。这个接口主要是简化了关闭资源的操作。但是像平时我们操作的集合或数组，基本上都不会出现关闭流的情况。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;由BaseStream接口派生出的流接口包括IntStream ，LongStream，DoubleStream ，Stream&lt;T&gt;\npublic interface IntStream extends BaseStream&lt;Integer, IntStream&gt; &#123;\n&#125;\npublic interface LongStream extends BaseStream&lt;Long, LongStream&gt; &#123;\n&#125;\npublic interface DoubleStream extends BaseStream&lt;Double, DoubleStream&gt; &#123;\n&#125;\n\n&#x2F;&#x2F;这是最具代表性的接口\npublic interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;\n&#x2F;&#x2F;....先忽略这些具体的细节\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>由于Stream接口是最具代表性的，所以我们就选择它来讲解，其实在我们学完Stream接口，其它的三个接口，在使用上基本是一致的了，我们上一篇的Demo基本上也是使用Stream接口来做的练习。我们回想一下:在上一个Demo中我们通过集合框架的stream()方法，就能返回一个流了，它的返回类型就是Stream<T>，比如我们Stream<Integer>，由此得知，Stream接口里的类型参数T就是流中的元素的类型。木有错，就是这样滴。到这里，整个系列你们已经全部学会了，下课。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1640787-cac539e2ac3e760f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>战斗才刚刚开始！</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1640787-65d8e79c87d2ec76.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>现在是时候开始记忆一些知识了.</p>\n<h4 id=\"BaseStream详解\"><a href=\"#BaseStream详解\" class=\"headerlink\" title=\"BaseStream详解:\"></a>BaseStream详解:</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface BaseStream&lt;T, S extends BaseStream&lt;T, S&gt;&gt; extends AutoCloseable &#123;\n     Iterator&lt;T&gt; iterator();&#x2F;&#x2F;line2\n     Spliterator&lt;T&gt; spliterator();&#x2F;&#x2F;line3\n     boolean isParallel();&#x2F;&#x2F;line4\n     S sequential();&#x2F;&#x2F;line5\n     S parallel();&#x2F;&#x2F;line6\n     S unordered();&#x2F;&#x2F;line7\n     S onClose(Runnable closeHandler);&#x2F;&#x2F;line8\n     @Override\n     void close();&#x2F;&#x2F;line10\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><strong>Iterator<T> iterator();</strong>  <em><code>//line2</code></em><br>获得流的迭代器，并返回对该迭代器的引用(终端操作)</li>\n<li><strong>Spliterator<T> spliterator();</strong> <em><code>//line3</code></em><br>获取流的spliterator，并返回其引用(终端操作)</li>\n<li><strong>boolean isParallel();</strong> <em><code>//line4</code></em><br>如果调用流是一个并行流，则返回true;如果调用流是一个顺序流，则返回false。</li>\n<li><strong>S sequential();</strong> <em><code>//line5</code></em><br>基于调用流，返回一个顺序流。如果调用流已经是顺序流了，就返回该流。(中间操作)</li>\n<li><strong>S parallel();</strong> <em><code>//line6</code></em><br>基于调用流，返回一个并行流。如果调用流已经是并行流了，就返回该流。(中间操作)</li>\n<li><strong>S unordered();</strong> <em><code>//line7</code></em><br>基于调用流，返回一个无序流。如果调用流已经是无序流了，就返回该流。(中间操作)</li>\n<li><strong>S onClose(Runnable closeHandler);</strong> <em><code>//line8</code></em><br>返回一个新流，closeHandler指定了该流的关闭处理程序，当关闭该流时，将调用这个处理程序。(中间操作)</li>\n<li><strong>void close();</strong> <em><code>//line10</code></em><br>从AutoCloseable继承来的，调用注册关闭处理程序，关闭调用流(很少会被使用到)</li>\n</ul>\n<h4 id=\"“终端操作”-”中间操作”\"><a href=\"#“终端操作”-”中间操作”\" class=\"headerlink\" title=\"“终端操作”&amp;”中间操作”\"></a>“终端操作”&amp;”中间操作”</h4><p>细心的同学应该注意到了，BaseStream接口里面的很多方法都在最后标识了(终端操作)和(中间操作)，它们之间的区别是非常重要的。</p>\n<ul>\n<li><p><strong>终端操作</strong>   会消费流，这种操作会产生一个结果的，比如上面的 iterator()和 spliterator()，以及上一篇中提到的min()和max()，或者是执行某一种操作，比如上一篇的forEach()，如果一个流被消费过了，那它就不能被重用的。</p>\n</li>\n<li><p><strong>中间操作</strong>   中间操作会产生另一个流。因此中间操作可以用来创建执行一系列动作的管道。一个特别需要注意的点是:中间操作不是立即发生的。相反，当在中间操作创建的新流上执行完终端操作后，中间操作指定的操作才会发生。所以中间操作是延迟发生的，中间操作的延迟行为主要是让流API能够更加高效地执行。</p>\n</li>\n</ul>\n<h4 id=\"“中间操作”的状态\"><a href=\"#“中间操作”的状态\" class=\"headerlink\" title=\"“中间操作”的状态\"></a>“中间操作”的状态</h4><p>流的中间操作，可以为分<code>无状态操作</code>和<code>有状态操作</code>两种，在无状态操作中，在处理流中的元素时，会对当前的元素进行单独处理。比如:谓词过滤操作，因为每个元素都是被单独进行处理的，所有它和流中的其它元素无关，因此被称为无状态操作;而在有状态操作中，某个元素的处理可能依赖于其他元素。比如查找最小值，最大值，和排序，因为他们都依赖于其他的元素。因此为称为有状态操作。<code>当需要进行并行处理流时，有状态的操作和无状态的区别是非常重要的，因为有状态操作可能需要几次处理才能完成，后面的文章我将会给大家详细地讲，现在只需要正常学习下去就可以了</code></p>\n<p>另外，指出一点，如果大家了解泛型的话，应该知道，泛型的类型参数只能是引用类型，因此Stream操作的对象只能是引用类型的，不能用于基本类型。当然官方早已考虑到这一点了，前面你们看到的IntStream，LongStream，DoubleStream就是官方给我们提供的处理基本类型的流了。此处是不是应该给他们掌声！</p>\n<h4 id=\"Stream详解\"><a href=\"#Stream详解\" class=\"headerlink\" title=\"Stream详解\"></a>Stream详解</h4><p>在有了前面的那些知识作铺垫之后，学Stream接口应该会顺风顺水了。还是先看看Stream的详情先:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;\n    Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);&#x2F;&#x2F;line2\n    &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);&#x2F;&#x2F;line3\n    IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper);&#x2F;&#x2F;line4\n    LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper);\n    DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper);\n    &lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper);\n    IntStream flatMapToInt(Function&lt;? super T, ? extends IntStream&gt; mapper);\n    LongStream flatMapToLong(Function&lt;? super T, ? extends LongStream&gt; mapper);\n    DoubleStream flatMapToDouble(Function&lt;? super T, ? extends DoubleStream&gt; mapper);\n    Stream&lt;T&gt; distinct();\n    Stream&lt;T&gt; sorted();&#x2F;&#x2F;line12\n    Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator);&#x2F;&#x2F;line13\n    Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action);\n    Stream&lt;T&gt; limit(long maxSize);\n    Stream&lt;T&gt; skip(long n);\n    void forEach(Consumer&lt;? super T&gt; action);&#x2F;&#x2F;line17\n    void forEachOrdered(Consumer&lt;? super T&gt; action);&#x2F;&#x2F;line18\n    Object[] toArray();\n    &lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);\n    T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);\n    Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);\n    &lt;U&gt; U reduce(U identity,\n                 BiFunction&lt;U, ? super T, U&gt; accumulator,\n                 BinaryOperator&lt;U&gt; combiner);\n    &lt;R&gt; R collect(Supplier&lt;R&gt; supplier,\n                  BiConsumer&lt;R, ? super T&gt; accumulator,\n                  BiConsumer&lt;R, R&gt; combiner);\n    &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);\n    Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator);&#x2F;&#x2F;line30\n    Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator);&#x2F;&#x2F;line31\n    long count();\n    boolean anyMatch(Predicate&lt;? super T&gt; predicate);\n    boolean allMatch(Predicate&lt;? super T&gt; predicate);\n    boolean noneMatch(Predicate&lt;? super T&gt; predicate);\n    Optional&lt;T&gt; findFirst();\n    Optional&lt;T&gt; findAny();\n\n    &#x2F;&#x2F; Static factories\n\n    public static&lt;T&gt; Builder&lt;T&gt; builder() &#123;\n        return new Streams.StreamBuilderImpl&lt;&gt;();\n    &#125;\n\n\n    public static&lt;T&gt; Stream&lt;T&gt; empty() &#123;\n        return StreamSupport.stream(Spliterators.&lt;T&gt;emptySpliterator(), false);\n    &#125;\n\n\n    public static&lt;T&gt; Stream&lt;T&gt; of(T t) &#123;\n        return StreamSupport.stream(new Streams.StreamBuilderImpl&lt;&gt;(t), false);\n    &#125;\n\n\n    @SafeVarargs\n    @SuppressWarnings(&quot;varargs&quot;) &#x2F;&#x2F; Creating a stream from an array is safe\n    public static&lt;T&gt; Stream&lt;T&gt; of(T... values) &#123;\n        return Arrays.stream(values);\n    &#125;\n\n\n    public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) &#123;\n        Objects.requireNonNull(f);\n        final Iterator&lt;T&gt; iterator &#x3D; new Iterator&lt;T&gt;() &#123;\n            @SuppressWarnings(&quot;unchecked&quot;)\n            T t &#x3D; (T) Streams.NONE;\n\n            @Override\n            public boolean hasNext() &#123;\n                return true;\n            &#125;\n\n            @Override\n            public T next() &#123;\n                return t &#x3D; (t &#x3D;&#x3D; Streams.NONE) ? seed : f.apply(t);\n            &#125;\n        &#125;;\n        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(\n                iterator,\n                Spliterator.ORDERED | Spliterator.IMMUTABLE), false);\n    &#125;\n\n\n    public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s) &#123;\n        Objects.requireNonNull(s);\n        return StreamSupport.stream(\n                new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef&lt;&gt;(Long.MAX_VALUE, s), false);\n    &#125;\n\n\n    public static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) &#123;\n        Objects.requireNonNull(a);\n        Objects.requireNonNull(b);\n\n        @SuppressWarnings(&quot;unchecked&quot;)\n        Spliterator&lt;T&gt; split &#x3D; new Streams.ConcatSpliterator.OfRef&lt;&gt;(\n                (Spliterator&lt;T&gt;) a.spliterator(), (Spliterator&lt;T&gt;) b.spliterator());\n        Stream&lt;T&gt; stream &#x3D; StreamSupport.stream(split, a.isParallel() || b.isParallel());\n        return stream.onClose(Streams.composedClose(a, b));\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><strong>Stream<T> filter(Predicate&lt;? super T&gt; predicate);</strong>  <em><code>//line2</code></em><br>产生一个新流，其中包含调用流中满足predicate指定的谓词元素(中间操作)</li>\n<li><strong><R> Stream<R> map(Function&lt;? super T, ? extends R&gt; mapper);</strong>  <em><code>//line3</code></em><br>产生一个新流，对调用流中的元素应用mapper，新流中包含这些元素。(中间操作)</li>\n<li><strong>IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper);</strong> <em><code>//line4</code></em><br>对调用流中元素应用mapper，产生包含这些元素的一个新IntStream流。(中间操作)</li>\n<li><strong>Stream<T> sorted();</strong> <em><code>//line12</code></em></li>\n<li><strong>Stream<T> sorted(Comparator&lt;? super T&gt; comparator);</strong> <em><code>//line13</code></em>&#96;<br>产生一个自然顺序排序或者指定排序条件的新流(中间操作)</li>\n<li><strong>void forEach(Consumer&lt;? super T&gt; action);</strong>  <em><code>//line17</code></em></li>\n<li><strong>void forEachOrdered(Consumer&lt;? super T&gt; action);</strong> <em><code>//line18</code></em><br>遍历了流中的元素(终端操作)</li>\n<li><strong>Optional<T> min(Comparator&lt;? super T&gt; comparator)</strong>  <em><code>//line30</code></em></li>\n<li><strong>Optional<T> max(Comparator&lt;? super T&gt; comparator);</strong> <em><code>//line31</code></em><br>获得流中最大最小值，比较器可以由自己定义，也可以使用JDK提供的(终端操作)</li>\n</ul>\n<h4 id=\"小结一下\"><a href=\"#小结一下\" class=\"headerlink\" title=\"小结一下\"></a>小结一下</h4><p>这一篇主要是介绍了流API的一些关键方法，和一些关键的概念，虽然稍微枯燥了一点，但是，不能否认，全面地学习流API，会让你对流API的认识会更加的深刻，所以如果时间允许，请再认真读读这一篇文章吧，当然，也可以在实践中慢慢认识它们，但是，对于这些基本概念的知识，你越早掌握，对你的益处是更加大的。到此为止，流API的基础知识已经学完了，后面的几篇文章我们就要开始更加深入地理解和运用他们实现一起强有力的功能了！</p>\n"},{"title":"Java 8 新特性之 Stream 流（六）收集","date":"2025-10-15T03:36:33.000Z","_content":"\n我们前面的五篇文章基本都是在说将一个集合转成一个流，然后对流进行操作，其实这种操作是最多的，但有时候我们也是需要从流中收集起一些元素，并以集合的方式返回，我们把这种反向操作称为收集。\n\n流API也给我们提供了相应的方法。\n\n#### 如何在流中使用收集功能？\n\n我们先看一看流API给我们提供的方法：\n\n```\npublic interface Stream<T> extends BaseStream<T, Stream<T>> {\n//...忽略那些不重要的东西\n<R> R collect(Supplier<R> supplier,\n                  BiConsumer<R, ? super T> accumulator,\n                  BiConsumer<R, R> combiner);\n<R, A> R collect(Collector<? super T, A, R> collector);\n｝\n```\n\n流API中给我们提供了两种，我给大家分析一下\n\n**<R, A> R collect(Collector<? super T, A, R> collector);**\n\n其中R指定结果的类型，T指定了调用流的元素类型。内部积累的类型由A指定。collectorFunc是一个收集器，指定收集过程如何执行，collect()方法是一个终端方法。\n\n虽然我们基本上很少会用到自定义的collectorFunc,但是了为扩展大家的知识面，我们还是简单地聊一聊Collector，Because it's my style! \n\n`Collector`接口位于`java.util.stream`包中的声明，它的容颜是这样的：\n\n```\npackage java.util.stream;\npublic interface Collector<T, A, R> {\n      Supplier<A> supplier();\n      BiConsumer<A, T> accumulator();\n      BinaryOperator<A> combiner();\n      Function<A, R> finisher();\n}\n```\n\n其中T、A、R的含义和上面是一样的`其中R指定结果的类型，T指定了调用流的元素类型。内部积累的类型由A指定`。\n\n但是这一篇我们不实现他们，因为JDK已经给我们提供了很强大的方法了，他们位于`java.util.stream`下面的`Collectors`类，我们本篇也主要是使用`Collectors`来实现收集的功能。\n\n`Collectors`类是一个最终类，里面提供了大量的静态的收集器方法，借助他，我们基本可以实现各种复杂的功能了。\n\n我们来看一下toList和toSet方法:\n\n```\npublic static <T>  Collector<T, ?, List<T>> toList()\npublic static <T> Collector<T, ?, Set<T>> toSet()\n```\n\n其中`Collectors#toList()`返回的收集器可以把流中元素收集到一个List中，`Collectors#toSet()`返回的收集器可以把流中的元素收集到一个Set中。比如：如果你想把元素收集到List中，你可以这样用，`steam.collect(Collectors.toList)`。\n\n接下来，我们把我们的王者荣耀团队经济例子修改一下，把明星玩家和当前获得的金币数收集到一个List里面，把出场的英雄收集到一个Set里面：\n\n```\n#玩家使用的英雄以及当前获得的金币数\npublic class HeroPlayerGold {\n    /** 使用的英雄名字 */\n    private String hero;\n    /** 玩家的ID */\n    private String player;\n    /** 获得的金币数 */\n    private int gold;\n\n\n    public HeroPlayerGold(String hero, String player, int gold) {\n        this.hero = hero;\n        this.player = player;\n        this.gold = gold;\n    }\n\n    @Override\n    public String toString() {\n        return \"HeroPlayerGold{\" +\n                \"hero='\" + hero + '\\'' +\n                \", player='\" + player + '\\'' +\n                \", gold=\" + gold +\n                '}';\n    }\n//省略get/set\n}\n\n#出场的英雄\npublic class Hero {\n    /** 使用的英雄名字 */\n    private String hero;\n\n    public Hero(String hero) {\n        this.hero = hero;\n    }\n\n    @Override\n    public String toString() {\n        return \"Hero{\" +\n                \"hero='\" + hero + '\\'' +\n                '}';\n    }\n//省略get/set\n}\n\n#测试类\npublic class Main {\n    public static void main(String[] args) {\n        learnCollect();\n    }\n\n    private static void learnCollect() {\n        List<HeroPlayerGold> lists = new ArrayList<>();\n        lists.add(new HeroPlayerGold(\"盖伦\", \"RNG-Letme\", 100));\n        lists.add(new HeroPlayerGold(\"诸葛亮\", \"RNG-Xiaohu\", 300));\n        lists.add(new HeroPlayerGold(\"露娜\", \"RNG-MLXG\", 300));\n        lists.add(new HeroPlayerGold(\"狄仁杰\", \"RNG-UZI\", 500));\n        lists.add(new HeroPlayerGold(\"牛头\", \"RNG-Ming\", 500));\n\n        List<PlayerGold> playerGolds = lists.stream()\n                .map(plary -> new PlayerGold(plary.getPlayer(), plary.getGold()))\n                .collect(Collectors.toList());\n        System.out.println(\"============PlayerGold begin==============\");\n        playerGolds.forEach(System.out::println);\n        System.out.println(\"============PlayerGold end================\\n\");\n\n\n\n        Set<Hero> heroes = lists.stream().map(player -> new Hero(player.getHero())).collect(Collectors.toSet());\n        System.out.println(\"============Hero begin==============\");\n        heroes.forEach(System.out::println);\n        System.out.println(\"============Hero end================\");\n    }\n}\n```\n\n输出的日志：\n\n```\n============PlayerGold begin==============\nPlayerGold{player='RNG-Letme', gold=100}\nPlayerGold{player='RNG-Xiaohu', gold=300}\nPlayerGold{player='RNG-MLXG', gold=300}\nPlayerGold{player='RNG-UZI', gold=500}\nPlayerGold{player='RNG-Ming', gold=500}\n============PlayerGold end================\n\n============Hero begin==============\nHero{hero='露娜'}\nHero{hero='牛头'}\nHero{hero='盖伦'}\nHero{hero='狄仁杰'}\nHero{hero='诸葛亮'}\n============Hero end================\n```\n\n看到这里，大家有感受到流API的威力了吗？提示一下，封装一个工具类，然后结合一FastJson这种东西一起使用！是真的好用啊！其实将数据从集合移到流中，或者将数据从流移回集合的能力，是流API给我们提供的一个强大特性，因为这允许通过流来操作集合，然后把流重新打包成集合。此外，条件合适的时候，让流操作并行发生，提高效率。\n\n接下来我们分析第二个方法，\n\n```\n <R> R collect(Supplier<R> supplier,\n                  BiConsumer<R, ? super T> accumulator,\n                  BiConsumer<R, R> combiner);\n```\n\n我们第二个版本的收集方法，主要是可以在收集的过程中，给予更多的控制。其中supplier指定如何创建用于保存结果的对象，比如，要使用ArrayList作为结果的集合，需要指定它的构造函数，accumulator函数是将一个元素添加到结果中，而combiner函数合并两个部分的结果。\n\n大家应该发现了吧，他的工作方式和我们第三篇介绍缩减操作时的reduce方法是很像的。它们都必须是无状态和不干预的，并且必须有关联性，三个约束条件缺一不可。\n\n`Supplier`也是`java.util.function`包中的一个函数式接口:\n\n```\n@FunctionalInterface\npublic interface Supplier<T> {\n    T get();\n}\n```\n\n只有一个get()，并且是没有参数的，在collect()方法返回一个R类型的对象，并且get()方法返回一个指向集合的引用。\n\n而accumulator,combiner的类型是`BiConsumer`，他们也是`java.util.function`包中的一个函数式接口:\n\n```\n@FunctionalInterface\npublic interface BiConsumer<T, U> {\n    void accept(T t, U u);\n}\n```\n\n其中t,u执行某种类型的操作，对于accumulator来说，t指定了目标集合，u指定了要添加到该集合的元素。对于combiner来说，t和u指定的是两个要被合并的集合。\n\n我们把前面的例子改变一下，然后也详细地说一下，在没有用lambda和使用lambda之后的区别：\n\n这个是没有使用lambda前的：\n\n```\nprivate static void learnCollect() {\n        List<HeroPlayerGold> lists = new ArrayList<>();\n        lists.add(new HeroPlayerGold(\"盖伦\", \"RNG-Letme\", 100));\n        lists.add(new HeroPlayerGold(\"诸葛亮\", \"RNG-Xiaohu\", 300));\n        lists.add(new HeroPlayerGold(\"露娜\", \"RNG-MLXG\", 300));\n        lists.add(new HeroPlayerGold(\"狄仁杰\", \"RNG-UZI\", 500));\n        lists.add(new HeroPlayerGold(\"牛头\", \"RNG-Ming\", 500));\n\n\n        lists.stream().collect(new Supplier<HashSet<HeroPlayerGold>>() {\n                                   @Override\n                                   public HashSet<HeroPlayerGold> get() {\n                                       return new HashSet<>();\n                                   }\n                               },//第一个参数\n                new BiConsumer<HashSet<HeroPlayerGold>, HeroPlayerGold>() {\n                    @Override\n                    public void accept(HashSet<HeroPlayerGold> heroPlayerGolds, HeroPlayerGold heroPlayerGold) {\n                        heroPlayerGolds.add(heroPlayerGold);\n                    }\n                },//第二个参数\n                new BiConsumer<HashSet<HeroPlayerGold>, HashSet<HeroPlayerGold>>() {\n                    @Override\n                    public void accept(HashSet<HeroPlayerGold> heroPlayerGolds, HashSet<HeroPlayerGold> heroPlayerGolds2) {\n                        heroPlayerGolds.addAll(heroPlayerGolds2);\n                    }\n                }//第三个参数\n        ).forEach(System.out::println);\n    }\n```\n\n在没有使用lambda前，虽然看起来的让人眼花缭乱的，但不得不说，他其实能帮助我们实现非常强大的功能，我们自定义的收集过程，全部都可以交给这个家伙，我们用lambda整理一下：\n\n```\nprivate static void learnCollect() {\n        List<HeroPlayerGold> lists = new ArrayList<>();\n        lists.add(new HeroPlayerGold(\"盖伦\", \"RNG-Letme\", 100));\n        lists.add(new HeroPlayerGold(\"诸葛亮\", \"RNG-Xiaohu\", 300));\n        lists.add(new HeroPlayerGold(\"露娜\", \"RNG-MLXG\", 300));\n        lists.add(new HeroPlayerGold(\"狄仁杰\", \"RNG-UZI\", 500));\n        lists.add(new HeroPlayerGold(\"牛头\", \"RNG-Ming\", 500));\n\n\n        lists.stream().collect(() -> new HashSet<>(),\n                                (set,elem)->set.add(elem),\n                                (setA,setB)->setA.addAll(setB)\n        ).forEach(System.out::println);\n        \n}\n```\n\n大家以为到这里就结束了吗？其实还可以使用方法引用和构造函数引用来简化：\n\n```\nprivate static void learnCollect() {\n        List<HeroPlayerGold> lists = new ArrayList<>();\n        lists.add(new HeroPlayerGold(\"盖伦\", \"RNG-Letme\", 100));\n        lists.add(new HeroPlayerGold(\"诸葛亮\", \"RNG-Xiaohu\", 300));\n        lists.add(new HeroPlayerGold(\"露娜\", \"RNG-MLXG\", 300));\n        lists.add(new HeroPlayerGold(\"狄仁杰\", \"RNG-UZI\", 500));\n        lists.add(new HeroPlayerGold(\"牛头\", \"RNG-Ming\", 500));\n\n\n        lists.stream().collect(HashSet::new,\n                               HashSet::add,\n                               HashSet::addAll\n        ).forEach(System.out::println);\n}\n```\n\n#### 小结一下\n\n本篇带大家入门了Stream的收集操作，但是有了些这入门操作，我相信，你在我的演变过程中已经发现了扩展点了，不管是supplier，accumulator还是combiner，都可以在里面放一些特别的操作进去，从而满足你们的各种要求。\n\n另外一个点，大家一定不要忘记了Collectors这个最终类，里面已经提供了很多很强大的静态方法，如果你们遇到一些特别的需求，首先要想到的应该是Collectors，如果里面的方法都不能实现你的要求，再考虑通过第二个版本的collect()方法实现你的自定义收集过程吧。\n\n\n\n\n\n","source":"_posts/新特性/Java8/Stream/Java 8 新特性之 Stream 流（六）收集.md","raw":"---\ntitle: Java 8 新特性之 Stream 流（六）收集\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n\n我们前面的五篇文章基本都是在说将一个集合转成一个流，然后对流进行操作，其实这种操作是最多的，但有时候我们也是需要从流中收集起一些元素，并以集合的方式返回，我们把这种反向操作称为收集。\n\n流API也给我们提供了相应的方法。\n\n#### 如何在流中使用收集功能？\n\n我们先看一看流API给我们提供的方法：\n\n```\npublic interface Stream<T> extends BaseStream<T, Stream<T>> {\n//...忽略那些不重要的东西\n<R> R collect(Supplier<R> supplier,\n                  BiConsumer<R, ? super T> accumulator,\n                  BiConsumer<R, R> combiner);\n<R, A> R collect(Collector<? super T, A, R> collector);\n｝\n```\n\n流API中给我们提供了两种，我给大家分析一下\n\n**<R, A> R collect(Collector<? super T, A, R> collector);**\n\n其中R指定结果的类型，T指定了调用流的元素类型。内部积累的类型由A指定。collectorFunc是一个收集器，指定收集过程如何执行，collect()方法是一个终端方法。\n\n虽然我们基本上很少会用到自定义的collectorFunc,但是了为扩展大家的知识面，我们还是简单地聊一聊Collector，Because it's my style! \n\n`Collector`接口位于`java.util.stream`包中的声明，它的容颜是这样的：\n\n```\npackage java.util.stream;\npublic interface Collector<T, A, R> {\n      Supplier<A> supplier();\n      BiConsumer<A, T> accumulator();\n      BinaryOperator<A> combiner();\n      Function<A, R> finisher();\n}\n```\n\n其中T、A、R的含义和上面是一样的`其中R指定结果的类型，T指定了调用流的元素类型。内部积累的类型由A指定`。\n\n但是这一篇我们不实现他们，因为JDK已经给我们提供了很强大的方法了，他们位于`java.util.stream`下面的`Collectors`类，我们本篇也主要是使用`Collectors`来实现收集的功能。\n\n`Collectors`类是一个最终类，里面提供了大量的静态的收集器方法，借助他，我们基本可以实现各种复杂的功能了。\n\n我们来看一下toList和toSet方法:\n\n```\npublic static <T>  Collector<T, ?, List<T>> toList()\npublic static <T> Collector<T, ?, Set<T>> toSet()\n```\n\n其中`Collectors#toList()`返回的收集器可以把流中元素收集到一个List中，`Collectors#toSet()`返回的收集器可以把流中的元素收集到一个Set中。比如：如果你想把元素收集到List中，你可以这样用，`steam.collect(Collectors.toList)`。\n\n接下来，我们把我们的王者荣耀团队经济例子修改一下，把明星玩家和当前获得的金币数收集到一个List里面，把出场的英雄收集到一个Set里面：\n\n```\n#玩家使用的英雄以及当前获得的金币数\npublic class HeroPlayerGold {\n    /** 使用的英雄名字 */\n    private String hero;\n    /** 玩家的ID */\n    private String player;\n    /** 获得的金币数 */\n    private int gold;\n\n\n    public HeroPlayerGold(String hero, String player, int gold) {\n        this.hero = hero;\n        this.player = player;\n        this.gold = gold;\n    }\n\n    @Override\n    public String toString() {\n        return \"HeroPlayerGold{\" +\n                \"hero='\" + hero + '\\'' +\n                \", player='\" + player + '\\'' +\n                \", gold=\" + gold +\n                '}';\n    }\n//省略get/set\n}\n\n#出场的英雄\npublic class Hero {\n    /** 使用的英雄名字 */\n    private String hero;\n\n    public Hero(String hero) {\n        this.hero = hero;\n    }\n\n    @Override\n    public String toString() {\n        return \"Hero{\" +\n                \"hero='\" + hero + '\\'' +\n                '}';\n    }\n//省略get/set\n}\n\n#测试类\npublic class Main {\n    public static void main(String[] args) {\n        learnCollect();\n    }\n\n    private static void learnCollect() {\n        List<HeroPlayerGold> lists = new ArrayList<>();\n        lists.add(new HeroPlayerGold(\"盖伦\", \"RNG-Letme\", 100));\n        lists.add(new HeroPlayerGold(\"诸葛亮\", \"RNG-Xiaohu\", 300));\n        lists.add(new HeroPlayerGold(\"露娜\", \"RNG-MLXG\", 300));\n        lists.add(new HeroPlayerGold(\"狄仁杰\", \"RNG-UZI\", 500));\n        lists.add(new HeroPlayerGold(\"牛头\", \"RNG-Ming\", 500));\n\n        List<PlayerGold> playerGolds = lists.stream()\n                .map(plary -> new PlayerGold(plary.getPlayer(), plary.getGold()))\n                .collect(Collectors.toList());\n        System.out.println(\"============PlayerGold begin==============\");\n        playerGolds.forEach(System.out::println);\n        System.out.println(\"============PlayerGold end================\\n\");\n\n\n\n        Set<Hero> heroes = lists.stream().map(player -> new Hero(player.getHero())).collect(Collectors.toSet());\n        System.out.println(\"============Hero begin==============\");\n        heroes.forEach(System.out::println);\n        System.out.println(\"============Hero end================\");\n    }\n}\n```\n\n输出的日志：\n\n```\n============PlayerGold begin==============\nPlayerGold{player='RNG-Letme', gold=100}\nPlayerGold{player='RNG-Xiaohu', gold=300}\nPlayerGold{player='RNG-MLXG', gold=300}\nPlayerGold{player='RNG-UZI', gold=500}\nPlayerGold{player='RNG-Ming', gold=500}\n============PlayerGold end================\n\n============Hero begin==============\nHero{hero='露娜'}\nHero{hero='牛头'}\nHero{hero='盖伦'}\nHero{hero='狄仁杰'}\nHero{hero='诸葛亮'}\n============Hero end================\n```\n\n看到这里，大家有感受到流API的威力了吗？提示一下，封装一个工具类，然后结合一FastJson这种东西一起使用！是真的好用啊！其实将数据从集合移到流中，或者将数据从流移回集合的能力，是流API给我们提供的一个强大特性，因为这允许通过流来操作集合，然后把流重新打包成集合。此外，条件合适的时候，让流操作并行发生，提高效率。\n\n接下来我们分析第二个方法，\n\n```\n <R> R collect(Supplier<R> supplier,\n                  BiConsumer<R, ? super T> accumulator,\n                  BiConsumer<R, R> combiner);\n```\n\n我们第二个版本的收集方法，主要是可以在收集的过程中，给予更多的控制。其中supplier指定如何创建用于保存结果的对象，比如，要使用ArrayList作为结果的集合，需要指定它的构造函数，accumulator函数是将一个元素添加到结果中，而combiner函数合并两个部分的结果。\n\n大家应该发现了吧，他的工作方式和我们第三篇介绍缩减操作时的reduce方法是很像的。它们都必须是无状态和不干预的，并且必须有关联性，三个约束条件缺一不可。\n\n`Supplier`也是`java.util.function`包中的一个函数式接口:\n\n```\n@FunctionalInterface\npublic interface Supplier<T> {\n    T get();\n}\n```\n\n只有一个get()，并且是没有参数的，在collect()方法返回一个R类型的对象，并且get()方法返回一个指向集合的引用。\n\n而accumulator,combiner的类型是`BiConsumer`，他们也是`java.util.function`包中的一个函数式接口:\n\n```\n@FunctionalInterface\npublic interface BiConsumer<T, U> {\n    void accept(T t, U u);\n}\n```\n\n其中t,u执行某种类型的操作，对于accumulator来说，t指定了目标集合，u指定了要添加到该集合的元素。对于combiner来说，t和u指定的是两个要被合并的集合。\n\n我们把前面的例子改变一下，然后也详细地说一下，在没有用lambda和使用lambda之后的区别：\n\n这个是没有使用lambda前的：\n\n```\nprivate static void learnCollect() {\n        List<HeroPlayerGold> lists = new ArrayList<>();\n        lists.add(new HeroPlayerGold(\"盖伦\", \"RNG-Letme\", 100));\n        lists.add(new HeroPlayerGold(\"诸葛亮\", \"RNG-Xiaohu\", 300));\n        lists.add(new HeroPlayerGold(\"露娜\", \"RNG-MLXG\", 300));\n        lists.add(new HeroPlayerGold(\"狄仁杰\", \"RNG-UZI\", 500));\n        lists.add(new HeroPlayerGold(\"牛头\", \"RNG-Ming\", 500));\n\n\n        lists.stream().collect(new Supplier<HashSet<HeroPlayerGold>>() {\n                                   @Override\n                                   public HashSet<HeroPlayerGold> get() {\n                                       return new HashSet<>();\n                                   }\n                               },//第一个参数\n                new BiConsumer<HashSet<HeroPlayerGold>, HeroPlayerGold>() {\n                    @Override\n                    public void accept(HashSet<HeroPlayerGold> heroPlayerGolds, HeroPlayerGold heroPlayerGold) {\n                        heroPlayerGolds.add(heroPlayerGold);\n                    }\n                },//第二个参数\n                new BiConsumer<HashSet<HeroPlayerGold>, HashSet<HeroPlayerGold>>() {\n                    @Override\n                    public void accept(HashSet<HeroPlayerGold> heroPlayerGolds, HashSet<HeroPlayerGold> heroPlayerGolds2) {\n                        heroPlayerGolds.addAll(heroPlayerGolds2);\n                    }\n                }//第三个参数\n        ).forEach(System.out::println);\n    }\n```\n\n在没有使用lambda前，虽然看起来的让人眼花缭乱的，但不得不说，他其实能帮助我们实现非常强大的功能，我们自定义的收集过程，全部都可以交给这个家伙，我们用lambda整理一下：\n\n```\nprivate static void learnCollect() {\n        List<HeroPlayerGold> lists = new ArrayList<>();\n        lists.add(new HeroPlayerGold(\"盖伦\", \"RNG-Letme\", 100));\n        lists.add(new HeroPlayerGold(\"诸葛亮\", \"RNG-Xiaohu\", 300));\n        lists.add(new HeroPlayerGold(\"露娜\", \"RNG-MLXG\", 300));\n        lists.add(new HeroPlayerGold(\"狄仁杰\", \"RNG-UZI\", 500));\n        lists.add(new HeroPlayerGold(\"牛头\", \"RNG-Ming\", 500));\n\n\n        lists.stream().collect(() -> new HashSet<>(),\n                                (set,elem)->set.add(elem),\n                                (setA,setB)->setA.addAll(setB)\n        ).forEach(System.out::println);\n        \n}\n```\n\n大家以为到这里就结束了吗？其实还可以使用方法引用和构造函数引用来简化：\n\n```\nprivate static void learnCollect() {\n        List<HeroPlayerGold> lists = new ArrayList<>();\n        lists.add(new HeroPlayerGold(\"盖伦\", \"RNG-Letme\", 100));\n        lists.add(new HeroPlayerGold(\"诸葛亮\", \"RNG-Xiaohu\", 300));\n        lists.add(new HeroPlayerGold(\"露娜\", \"RNG-MLXG\", 300));\n        lists.add(new HeroPlayerGold(\"狄仁杰\", \"RNG-UZI\", 500));\n        lists.add(new HeroPlayerGold(\"牛头\", \"RNG-Ming\", 500));\n\n\n        lists.stream().collect(HashSet::new,\n                               HashSet::add,\n                               HashSet::addAll\n        ).forEach(System.out::println);\n}\n```\n\n#### 小结一下\n\n本篇带大家入门了Stream的收集操作，但是有了些这入门操作，我相信，你在我的演变过程中已经发现了扩展点了，不管是supplier，accumulator还是combiner，都可以在里面放一些特别的操作进去，从而满足你们的各种要求。\n\n另外一个点，大家一定不要忘记了Collectors这个最终类，里面已经提供了很多很强大的静态方法，如果你们遇到一些特别的需求，首先要想到的应该是Collectors，如果里面的方法都不能实现你的要求，再考虑通过第二个版本的collect()方法实现你的自定义收集过程吧。\n\n\n\n\n\n","slug":"新特性/Java8/Stream/Java 8 新特性之 Stream 流（六）收集","published":1,"updated":"2025-10-15T07:20:51.417Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu077a006uqkd4e06sgza9","content":"<p>我们前面的五篇文章基本都是在说将一个集合转成一个流，然后对流进行操作，其实这种操作是最多的，但有时候我们也是需要从流中收集起一些元素，并以集合的方式返回，我们把这种反向操作称为收集。</p>\n<p>流API也给我们提供了相应的方法。</p>\n<h4 id=\"如何在流中使用收集功能？\"><a href=\"#如何在流中使用收集功能？\" class=\"headerlink\" title=\"如何在流中使用收集功能？\"></a>如何在流中使用收集功能？</h4><p>我们先看一看流API给我们提供的方法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;\n&#x2F;&#x2F;...忽略那些不重要的东西\n&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,\n                  BiConsumer&lt;R, ? super T&gt; accumulator,\n                  BiConsumer&lt;R, R&gt; combiner);\n&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);\n｝<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>流API中给我们提供了两种，我给大家分析一下</p>\n<p><strong>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);</strong></p>\n<p>其中R指定结果的类型，T指定了调用流的元素类型。内部积累的类型由A指定。collectorFunc是一个收集器，指定收集过程如何执行，collect()方法是一个终端方法。</p>\n<p>虽然我们基本上很少会用到自定义的collectorFunc,但是了为扩展大家的知识面，我们还是简单地聊一聊Collector，Because it’s my style! </p>\n<p><code>Collector</code>接口位于<code>java.util.stream</code>包中的声明，它的容颜是这样的：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package java.util.stream;\npublic interface Collector&lt;T, A, R&gt; &#123;\n      Supplier&lt;A&gt; supplier();\n      BiConsumer&lt;A, T&gt; accumulator();\n      BinaryOperator&lt;A&gt; combiner();\n      Function&lt;A, R&gt; finisher();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中T、A、R的含义和上面是一样的<code>其中R指定结果的类型，T指定了调用流的元素类型。内部积累的类型由A指定</code>。</p>\n<p>但是这一篇我们不实现他们，因为JDK已经给我们提供了很强大的方法了，他们位于<code>java.util.stream</code>下面的<code>Collectors</code>类，我们本篇也主要是使用<code>Collectors</code>来实现收集的功能。</p>\n<p><code>Collectors</code>类是一个最终类，里面提供了大量的静态的收集器方法，借助他，我们基本可以实现各种复杂的功能了。</p>\n<p>我们来看一下toList和toSet方法:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static &lt;T&gt;  Collector&lt;T, ?, List&lt;T&gt;&gt; toList()\npublic static &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>其中<code>Collectors#toList()</code>返回的收集器可以把流中元素收集到一个List中，<code>Collectors#toSet()</code>返回的收集器可以把流中的元素收集到一个Set中。比如：如果你想把元素收集到List中，你可以这样用，<code>steam.collect(Collectors.toList)</code>。</p>\n<p>接下来，我们把我们的王者荣耀团队经济例子修改一下，把明星玩家和当前获得的金币数收集到一个List里面，把出场的英雄收集到一个Set里面：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#玩家使用的英雄以及当前获得的金币数\npublic class HeroPlayerGold &#123;\n    &#x2F;** 使用的英雄名字 *&#x2F;\n    private String hero;\n    &#x2F;** 玩家的ID *&#x2F;\n    private String player;\n    &#x2F;** 获得的金币数 *&#x2F;\n    private int gold;\n\n\n    public HeroPlayerGold(String hero, String player, int gold) &#123;\n        this.hero &#x3D; hero;\n        this.player &#x3D; player;\n        this.gold &#x3D; gold;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;HeroPlayerGold&#123;&quot; +\n                &quot;hero&#x3D;&#39;&quot; + hero + &#39;\\&#39;&#39; +\n                &quot;, player&#x3D;&#39;&quot; + player + &#39;\\&#39;&#39; +\n                &quot;, gold&#x3D;&quot; + gold +\n                &#39;&#125;&#39;;\n    &#125;\n&#x2F;&#x2F;省略get&#x2F;set\n&#125;\n\n#出场的英雄\npublic class Hero &#123;\n    &#x2F;** 使用的英雄名字 *&#x2F;\n    private String hero;\n\n    public Hero(String hero) &#123;\n        this.hero &#x3D; hero;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Hero&#123;&quot; +\n                &quot;hero&#x3D;&#39;&quot; + hero + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#x2F;&#x2F;省略get&#x2F;set\n&#125;\n\n#测试类\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        learnCollect();\n    &#125;\n\n    private static void learnCollect() &#123;\n        List&lt;HeroPlayerGold&gt; lists &#x3D; new ArrayList&lt;&gt;();\n        lists.add(new HeroPlayerGold(&quot;盖伦&quot;, &quot;RNG-Letme&quot;, 100));\n        lists.add(new HeroPlayerGold(&quot;诸葛亮&quot;, &quot;RNG-Xiaohu&quot;, 300));\n        lists.add(new HeroPlayerGold(&quot;露娜&quot;, &quot;RNG-MLXG&quot;, 300));\n        lists.add(new HeroPlayerGold(&quot;狄仁杰&quot;, &quot;RNG-UZI&quot;, 500));\n        lists.add(new HeroPlayerGold(&quot;牛头&quot;, &quot;RNG-Ming&quot;, 500));\n\n        List&lt;PlayerGold&gt; playerGolds &#x3D; lists.stream()\n                .map(plary -&gt; new PlayerGold(plary.getPlayer(), plary.getGold()))\n                .collect(Collectors.toList());\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;PlayerGold begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        playerGolds.forEach(System.out::println);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;PlayerGold end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\\n&quot;);\n\n\n\n        Set&lt;Hero&gt; heroes &#x3D; lists.stream().map(player -&gt; new Hero(player.getHero())).collect(Collectors.toSet());\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Hero begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        heroes.forEach(System.out::println);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Hero end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出的日志：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;PlayerGold begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nPlayerGold&#123;player&#x3D;&#39;RNG-Letme&#39;, gold&#x3D;100&#125;\nPlayerGold&#123;player&#x3D;&#39;RNG-Xiaohu&#39;, gold&#x3D;300&#125;\nPlayerGold&#123;player&#x3D;&#39;RNG-MLXG&#39;, gold&#x3D;300&#125;\nPlayerGold&#123;player&#x3D;&#39;RNG-UZI&#39;, gold&#x3D;500&#125;\nPlayerGold&#123;player&#x3D;&#39;RNG-Ming&#39;, gold&#x3D;500&#125;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;PlayerGold end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Hero begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nHero&#123;hero&#x3D;&#39;露娜&#39;&#125;\nHero&#123;hero&#x3D;&#39;牛头&#39;&#125;\nHero&#123;hero&#x3D;&#39;盖伦&#39;&#125;\nHero&#123;hero&#x3D;&#39;狄仁杰&#39;&#125;\nHero&#123;hero&#x3D;&#39;诸葛亮&#39;&#125;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Hero end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>看到这里，大家有感受到流API的威力了吗？提示一下，封装一个工具类，然后结合一FastJson这种东西一起使用！是真的好用啊！其实将数据从集合移到流中，或者将数据从流移回集合的能力，是流API给我们提供的一个强大特性，因为这允许通过流来操作集合，然后把流重新打包成集合。此外，条件合适的时候，让流操作并行发生，提高效率。</p>\n<p>接下来我们分析第二个方法，</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,\n                 BiConsumer&lt;R, ? super T&gt; accumulator,\n                 BiConsumer&lt;R, R&gt; combiner);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>我们第二个版本的收集方法，主要是可以在收集的过程中，给予更多的控制。其中supplier指定如何创建用于保存结果的对象，比如，要使用ArrayList作为结果的集合，需要指定它的构造函数，accumulator函数是将一个元素添加到结果中，而combiner函数合并两个部分的结果。</p>\n<p>大家应该发现了吧，他的工作方式和我们第三篇介绍缩减操作时的reduce方法是很像的。它们都必须是无状态和不干预的，并且必须有关联性，三个约束条件缺一不可。</p>\n<p><code>Supplier</code>也是<code>java.util.function</code>包中的一个函数式接口:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@FunctionalInterface\npublic interface Supplier&lt;T&gt; &#123;\n    T get();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>只有一个get()，并且是没有参数的，在collect()方法返回一个R类型的对象，并且get()方法返回一个指向集合的引用。</p>\n<p>而accumulator,combiner的类型是<code>BiConsumer</code>，他们也是<code>java.util.function</code>包中的一个函数式接口:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@FunctionalInterface\npublic interface BiConsumer&lt;T, U&gt; &#123;\n    void accept(T t, U u);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中t,u执行某种类型的操作，对于accumulator来说，t指定了目标集合，u指定了要添加到该集合的元素。对于combiner来说，t和u指定的是两个要被合并的集合。</p>\n<p>我们把前面的例子改变一下，然后也详细地说一下，在没有用lambda和使用lambda之后的区别：</p>\n<p>这个是没有使用lambda前的：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void learnCollect() &#123;\n        List&lt;HeroPlayerGold&gt; lists &#x3D; new ArrayList&lt;&gt;();\n        lists.add(new HeroPlayerGold(&quot;盖伦&quot;, &quot;RNG-Letme&quot;, 100));\n        lists.add(new HeroPlayerGold(&quot;诸葛亮&quot;, &quot;RNG-Xiaohu&quot;, 300));\n        lists.add(new HeroPlayerGold(&quot;露娜&quot;, &quot;RNG-MLXG&quot;, 300));\n        lists.add(new HeroPlayerGold(&quot;狄仁杰&quot;, &quot;RNG-UZI&quot;, 500));\n        lists.add(new HeroPlayerGold(&quot;牛头&quot;, &quot;RNG-Ming&quot;, 500));\n\n\n        lists.stream().collect(new Supplier&lt;HashSet&lt;HeroPlayerGold&gt;&gt;() &#123;\n                                   @Override\n                                   public HashSet&lt;HeroPlayerGold&gt; get() &#123;\n                                       return new HashSet&lt;&gt;();\n                                   &#125;\n                               &#125;,&#x2F;&#x2F;第一个参数\n                new BiConsumer&lt;HashSet&lt;HeroPlayerGold&gt;, HeroPlayerGold&gt;() &#123;\n                    @Override\n                    public void accept(HashSet&lt;HeroPlayerGold&gt; heroPlayerGolds, HeroPlayerGold heroPlayerGold) &#123;\n                        heroPlayerGolds.add(heroPlayerGold);\n                    &#125;\n                &#125;,&#x2F;&#x2F;第二个参数\n                new BiConsumer&lt;HashSet&lt;HeroPlayerGold&gt;, HashSet&lt;HeroPlayerGold&gt;&gt;() &#123;\n                    @Override\n                    public void accept(HashSet&lt;HeroPlayerGold&gt; heroPlayerGolds, HashSet&lt;HeroPlayerGold&gt; heroPlayerGolds2) &#123;\n                        heroPlayerGolds.addAll(heroPlayerGolds2);\n                    &#125;\n                &#125;&#x2F;&#x2F;第三个参数\n        ).forEach(System.out::println);\n    &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在没有使用lambda前，虽然看起来的让人眼花缭乱的，但不得不说，他其实能帮助我们实现非常强大的功能，我们自定义的收集过程，全部都可以交给这个家伙，我们用lambda整理一下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void learnCollect() &#123;\n        List&lt;HeroPlayerGold&gt; lists &#x3D; new ArrayList&lt;&gt;();\n        lists.add(new HeroPlayerGold(&quot;盖伦&quot;, &quot;RNG-Letme&quot;, 100));\n        lists.add(new HeroPlayerGold(&quot;诸葛亮&quot;, &quot;RNG-Xiaohu&quot;, 300));\n        lists.add(new HeroPlayerGold(&quot;露娜&quot;, &quot;RNG-MLXG&quot;, 300));\n        lists.add(new HeroPlayerGold(&quot;狄仁杰&quot;, &quot;RNG-UZI&quot;, 500));\n        lists.add(new HeroPlayerGold(&quot;牛头&quot;, &quot;RNG-Ming&quot;, 500));\n\n\n        lists.stream().collect(() -&gt; new HashSet&lt;&gt;(),\n                                (set,elem)-&gt;set.add(elem),\n                                (setA,setB)-&gt;setA.addAll(setB)\n        ).forEach(System.out::println);\n        \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>大家以为到这里就结束了吗？其实还可以使用方法引用和构造函数引用来简化：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void learnCollect() &#123;\n        List&lt;HeroPlayerGold&gt; lists &#x3D; new ArrayList&lt;&gt;();\n        lists.add(new HeroPlayerGold(&quot;盖伦&quot;, &quot;RNG-Letme&quot;, 100));\n        lists.add(new HeroPlayerGold(&quot;诸葛亮&quot;, &quot;RNG-Xiaohu&quot;, 300));\n        lists.add(new HeroPlayerGold(&quot;露娜&quot;, &quot;RNG-MLXG&quot;, 300));\n        lists.add(new HeroPlayerGold(&quot;狄仁杰&quot;, &quot;RNG-UZI&quot;, 500));\n        lists.add(new HeroPlayerGold(&quot;牛头&quot;, &quot;RNG-Ming&quot;, 500));\n\n\n        lists.stream().collect(HashSet::new,\n                               HashSet::add,\n                               HashSet::addAll\n        ).forEach(System.out::println);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"小结一下\"><a href=\"#小结一下\" class=\"headerlink\" title=\"小结一下\"></a>小结一下</h4><p>本篇带大家入门了Stream的收集操作，但是有了些这入门操作，我相信，你在我的演变过程中已经发现了扩展点了，不管是supplier，accumulator还是combiner，都可以在里面放一些特别的操作进去，从而满足你们的各种要求。</p>\n<p>另外一个点，大家一定不要忘记了Collectors这个最终类，里面已经提供了很多很强大的静态方法，如果你们遇到一些特别的需求，首先要想到的应该是Collectors，如果里面的方法都不能实现你的要求，再考虑通过第二个版本的collect()方法实现你的自定义收集过程吧。</p>\n","excerpt":"","more":"<p>我们前面的五篇文章基本都是在说将一个集合转成一个流，然后对流进行操作，其实这种操作是最多的，但有时候我们也是需要从流中收集起一些元素，并以集合的方式返回，我们把这种反向操作称为收集。</p>\n<p>流API也给我们提供了相应的方法。</p>\n<h4 id=\"如何在流中使用收集功能？\"><a href=\"#如何在流中使用收集功能？\" class=\"headerlink\" title=\"如何在流中使用收集功能？\"></a>如何在流中使用收集功能？</h4><p>我们先看一看流API给我们提供的方法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;\n&#x2F;&#x2F;...忽略那些不重要的东西\n&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,\n                  BiConsumer&lt;R, ? super T&gt; accumulator,\n                  BiConsumer&lt;R, R&gt; combiner);\n&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);\n｝<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>流API中给我们提供了两种，我给大家分析一下</p>\n<p><strong>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);</strong></p>\n<p>其中R指定结果的类型，T指定了调用流的元素类型。内部积累的类型由A指定。collectorFunc是一个收集器，指定收集过程如何执行，collect()方法是一个终端方法。</p>\n<p>虽然我们基本上很少会用到自定义的collectorFunc,但是了为扩展大家的知识面，我们还是简单地聊一聊Collector，Because it’s my style! </p>\n<p><code>Collector</code>接口位于<code>java.util.stream</code>包中的声明，它的容颜是这样的：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package java.util.stream;\npublic interface Collector&lt;T, A, R&gt; &#123;\n      Supplier&lt;A&gt; supplier();\n      BiConsumer&lt;A, T&gt; accumulator();\n      BinaryOperator&lt;A&gt; combiner();\n      Function&lt;A, R&gt; finisher();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中T、A、R的含义和上面是一样的<code>其中R指定结果的类型，T指定了调用流的元素类型。内部积累的类型由A指定</code>。</p>\n<p>但是这一篇我们不实现他们，因为JDK已经给我们提供了很强大的方法了，他们位于<code>java.util.stream</code>下面的<code>Collectors</code>类，我们本篇也主要是使用<code>Collectors</code>来实现收集的功能。</p>\n<p><code>Collectors</code>类是一个最终类，里面提供了大量的静态的收集器方法，借助他，我们基本可以实现各种复杂的功能了。</p>\n<p>我们来看一下toList和toSet方法:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public static &lt;T&gt;  Collector&lt;T, ?, List&lt;T&gt;&gt; toList()\npublic static &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>其中<code>Collectors#toList()</code>返回的收集器可以把流中元素收集到一个List中，<code>Collectors#toSet()</code>返回的收集器可以把流中的元素收集到一个Set中。比如：如果你想把元素收集到List中，你可以这样用，<code>steam.collect(Collectors.toList)</code>。</p>\n<p>接下来，我们把我们的王者荣耀团队经济例子修改一下，把明星玩家和当前获得的金币数收集到一个List里面，把出场的英雄收集到一个Set里面：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#玩家使用的英雄以及当前获得的金币数\npublic class HeroPlayerGold &#123;\n    &#x2F;** 使用的英雄名字 *&#x2F;\n    private String hero;\n    &#x2F;** 玩家的ID *&#x2F;\n    private String player;\n    &#x2F;** 获得的金币数 *&#x2F;\n    private int gold;\n\n\n    public HeroPlayerGold(String hero, String player, int gold) &#123;\n        this.hero &#x3D; hero;\n        this.player &#x3D; player;\n        this.gold &#x3D; gold;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;HeroPlayerGold&#123;&quot; +\n                &quot;hero&#x3D;&#39;&quot; + hero + &#39;\\&#39;&#39; +\n                &quot;, player&#x3D;&#39;&quot; + player + &#39;\\&#39;&#39; +\n                &quot;, gold&#x3D;&quot; + gold +\n                &#39;&#125;&#39;;\n    &#125;\n&#x2F;&#x2F;省略get&#x2F;set\n&#125;\n\n#出场的英雄\npublic class Hero &#123;\n    &#x2F;** 使用的英雄名字 *&#x2F;\n    private String hero;\n\n    public Hero(String hero) &#123;\n        this.hero &#x3D; hero;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Hero&#123;&quot; +\n                &quot;hero&#x3D;&#39;&quot; + hero + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#x2F;&#x2F;省略get&#x2F;set\n&#125;\n\n#测试类\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        learnCollect();\n    &#125;\n\n    private static void learnCollect() &#123;\n        List&lt;HeroPlayerGold&gt; lists &#x3D; new ArrayList&lt;&gt;();\n        lists.add(new HeroPlayerGold(&quot;盖伦&quot;, &quot;RNG-Letme&quot;, 100));\n        lists.add(new HeroPlayerGold(&quot;诸葛亮&quot;, &quot;RNG-Xiaohu&quot;, 300));\n        lists.add(new HeroPlayerGold(&quot;露娜&quot;, &quot;RNG-MLXG&quot;, 300));\n        lists.add(new HeroPlayerGold(&quot;狄仁杰&quot;, &quot;RNG-UZI&quot;, 500));\n        lists.add(new HeroPlayerGold(&quot;牛头&quot;, &quot;RNG-Ming&quot;, 500));\n\n        List&lt;PlayerGold&gt; playerGolds &#x3D; lists.stream()\n                .map(plary -&gt; new PlayerGold(plary.getPlayer(), plary.getGold()))\n                .collect(Collectors.toList());\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;PlayerGold begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        playerGolds.forEach(System.out::println);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;PlayerGold end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\\n&quot;);\n\n\n\n        Set&lt;Hero&gt; heroes &#x3D; lists.stream().map(player -&gt; new Hero(player.getHero())).collect(Collectors.toSet());\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Hero begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        heroes.forEach(System.out::println);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Hero end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出的日志：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;PlayerGold begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nPlayerGold&#123;player&#x3D;&#39;RNG-Letme&#39;, gold&#x3D;100&#125;\nPlayerGold&#123;player&#x3D;&#39;RNG-Xiaohu&#39;, gold&#x3D;300&#125;\nPlayerGold&#123;player&#x3D;&#39;RNG-MLXG&#39;, gold&#x3D;300&#125;\nPlayerGold&#123;player&#x3D;&#39;RNG-UZI&#39;, gold&#x3D;500&#125;\nPlayerGold&#123;player&#x3D;&#39;RNG-Ming&#39;, gold&#x3D;500&#125;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;PlayerGold end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Hero begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nHero&#123;hero&#x3D;&#39;露娜&#39;&#125;\nHero&#123;hero&#x3D;&#39;牛头&#39;&#125;\nHero&#123;hero&#x3D;&#39;盖伦&#39;&#125;\nHero&#123;hero&#x3D;&#39;狄仁杰&#39;&#125;\nHero&#123;hero&#x3D;&#39;诸葛亮&#39;&#125;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Hero end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>看到这里，大家有感受到流API的威力了吗？提示一下，封装一个工具类，然后结合一FastJson这种东西一起使用！是真的好用啊！其实将数据从集合移到流中，或者将数据从流移回集合的能力，是流API给我们提供的一个强大特性，因为这允许通过流来操作集合，然后把流重新打包成集合。此外，条件合适的时候，让流操作并行发生，提高效率。</p>\n<p>接下来我们分析第二个方法，</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,\n                 BiConsumer&lt;R, ? super T&gt; accumulator,\n                 BiConsumer&lt;R, R&gt; combiner);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>我们第二个版本的收集方法，主要是可以在收集的过程中，给予更多的控制。其中supplier指定如何创建用于保存结果的对象，比如，要使用ArrayList作为结果的集合，需要指定它的构造函数，accumulator函数是将一个元素添加到结果中，而combiner函数合并两个部分的结果。</p>\n<p>大家应该发现了吧，他的工作方式和我们第三篇介绍缩减操作时的reduce方法是很像的。它们都必须是无状态和不干预的，并且必须有关联性，三个约束条件缺一不可。</p>\n<p><code>Supplier</code>也是<code>java.util.function</code>包中的一个函数式接口:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@FunctionalInterface\npublic interface Supplier&lt;T&gt; &#123;\n    T get();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>只有一个get()，并且是没有参数的，在collect()方法返回一个R类型的对象，并且get()方法返回一个指向集合的引用。</p>\n<p>而accumulator,combiner的类型是<code>BiConsumer</code>，他们也是<code>java.util.function</code>包中的一个函数式接口:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@FunctionalInterface\npublic interface BiConsumer&lt;T, U&gt; &#123;\n    void accept(T t, U u);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中t,u执行某种类型的操作，对于accumulator来说，t指定了目标集合，u指定了要添加到该集合的元素。对于combiner来说，t和u指定的是两个要被合并的集合。</p>\n<p>我们把前面的例子改变一下，然后也详细地说一下，在没有用lambda和使用lambda之后的区别：</p>\n<p>这个是没有使用lambda前的：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void learnCollect() &#123;\n        List&lt;HeroPlayerGold&gt; lists &#x3D; new ArrayList&lt;&gt;();\n        lists.add(new HeroPlayerGold(&quot;盖伦&quot;, &quot;RNG-Letme&quot;, 100));\n        lists.add(new HeroPlayerGold(&quot;诸葛亮&quot;, &quot;RNG-Xiaohu&quot;, 300));\n        lists.add(new HeroPlayerGold(&quot;露娜&quot;, &quot;RNG-MLXG&quot;, 300));\n        lists.add(new HeroPlayerGold(&quot;狄仁杰&quot;, &quot;RNG-UZI&quot;, 500));\n        lists.add(new HeroPlayerGold(&quot;牛头&quot;, &quot;RNG-Ming&quot;, 500));\n\n\n        lists.stream().collect(new Supplier&lt;HashSet&lt;HeroPlayerGold&gt;&gt;() &#123;\n                                   @Override\n                                   public HashSet&lt;HeroPlayerGold&gt; get() &#123;\n                                       return new HashSet&lt;&gt;();\n                                   &#125;\n                               &#125;,&#x2F;&#x2F;第一个参数\n                new BiConsumer&lt;HashSet&lt;HeroPlayerGold&gt;, HeroPlayerGold&gt;() &#123;\n                    @Override\n                    public void accept(HashSet&lt;HeroPlayerGold&gt; heroPlayerGolds, HeroPlayerGold heroPlayerGold) &#123;\n                        heroPlayerGolds.add(heroPlayerGold);\n                    &#125;\n                &#125;,&#x2F;&#x2F;第二个参数\n                new BiConsumer&lt;HashSet&lt;HeroPlayerGold&gt;, HashSet&lt;HeroPlayerGold&gt;&gt;() &#123;\n                    @Override\n                    public void accept(HashSet&lt;HeroPlayerGold&gt; heroPlayerGolds, HashSet&lt;HeroPlayerGold&gt; heroPlayerGolds2) &#123;\n                        heroPlayerGolds.addAll(heroPlayerGolds2);\n                    &#125;\n                &#125;&#x2F;&#x2F;第三个参数\n        ).forEach(System.out::println);\n    &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在没有使用lambda前，虽然看起来的让人眼花缭乱的，但不得不说，他其实能帮助我们实现非常强大的功能，我们自定义的收集过程，全部都可以交给这个家伙，我们用lambda整理一下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void learnCollect() &#123;\n        List&lt;HeroPlayerGold&gt; lists &#x3D; new ArrayList&lt;&gt;();\n        lists.add(new HeroPlayerGold(&quot;盖伦&quot;, &quot;RNG-Letme&quot;, 100));\n        lists.add(new HeroPlayerGold(&quot;诸葛亮&quot;, &quot;RNG-Xiaohu&quot;, 300));\n        lists.add(new HeroPlayerGold(&quot;露娜&quot;, &quot;RNG-MLXG&quot;, 300));\n        lists.add(new HeroPlayerGold(&quot;狄仁杰&quot;, &quot;RNG-UZI&quot;, 500));\n        lists.add(new HeroPlayerGold(&quot;牛头&quot;, &quot;RNG-Ming&quot;, 500));\n\n\n        lists.stream().collect(() -&gt; new HashSet&lt;&gt;(),\n                                (set,elem)-&gt;set.add(elem),\n                                (setA,setB)-&gt;setA.addAll(setB)\n        ).forEach(System.out::println);\n        \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>大家以为到这里就结束了吗？其实还可以使用方法引用和构造函数引用来简化：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void learnCollect() &#123;\n        List&lt;HeroPlayerGold&gt; lists &#x3D; new ArrayList&lt;&gt;();\n        lists.add(new HeroPlayerGold(&quot;盖伦&quot;, &quot;RNG-Letme&quot;, 100));\n        lists.add(new HeroPlayerGold(&quot;诸葛亮&quot;, &quot;RNG-Xiaohu&quot;, 300));\n        lists.add(new HeroPlayerGold(&quot;露娜&quot;, &quot;RNG-MLXG&quot;, 300));\n        lists.add(new HeroPlayerGold(&quot;狄仁杰&quot;, &quot;RNG-UZI&quot;, 500));\n        lists.add(new HeroPlayerGold(&quot;牛头&quot;, &quot;RNG-Ming&quot;, 500));\n\n\n        lists.stream().collect(HashSet::new,\n                               HashSet::add,\n                               HashSet::addAll\n        ).forEach(System.out::println);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"小结一下\"><a href=\"#小结一下\" class=\"headerlink\" title=\"小结一下\"></a>小结一下</h4><p>本篇带大家入门了Stream的收集操作，但是有了些这入门操作，我相信，你在我的演变过程中已经发现了扩展点了，不管是supplier，accumulator还是combiner，都可以在里面放一些特别的操作进去，从而满足你们的各种要求。</p>\n<p>另外一个点，大家一定不要忘记了Collectors这个最终类，里面已经提供了很多很强大的静态方法，如果你们遇到一些特别的需求，首先要想到的应该是Collectors，如果里面的方法都不能实现你的要求，再考虑通过第二个版本的collect()方法实现你的自定义收集过程吧。</p>\n"},{"title":"Java 8 新特性之 Stream 流（五）映射","date":"2025-10-15T03:36:33.000Z","_content":"\n经过了前面四篇文章的学习，相信大家对Stream流已经是相当的熟悉了，同时也掌握了一些高级功能了，如果你之前有阅读过集合框架的基石`Collection`接口，是不是在经过前面的学习，以前看不懂的东西，突然之间就恍然大悟了呢？\n\n今天我们的主角是Stream流里面的映射。由于之前，映射并没有再我们的Demo，例子中出现过，所以对大家来说可能会稍微有一点点陌生的，但通过这一篇文章，我相信能解决你的疑问。\n\n在正式开始之前，我和大家继续说说流API操作，不知道大家有没有注意到，其实我们所有的流API操作都是针对流中的元素进行的，并且都是基于同一流里面的，大家有没有这样的疑问，怎么样把一个流的元素弄到另一个流里面呢？怎么把流中的一些满足条件的元素放到一个新流里面呢？\n\n通过这一节，你将会掌握解决刚才问题的本领。另外再提一点，如果流操作只有中间操作，没有终端操作，那么这些中间操作是不会执行的，换句话说，只有终端操作才能触发中间操作的运行。\n\n#### 我们为什么需要映射？\n\n因为在很多时候，将一个流的元素映射到另一个流对我们是非常有帮助的。比如有一个包含有名字，手机号码和钱的数据库构成的流，可能你只想要映射钱这个字段到另一个流，这时候可能之前学到的知识就还不能解决，于是映射就站了出来了。\n\n另外，如果你希望对流中的元素应用一些转换，然后把转换的元素映射到一个新流里面，这时候也可以用映射。\n\n我们先来看看流API库给我们提供了什么样的支持\n\n```\npublic interface Stream<T> extends BaseStream<T, Stream<T>> {\n    <R> Stream<R> map(Function<? super T, ? extends R> mapper);//line2\n    IntStream mapToInt(ToIntFunction<? super T> mapper);//line3\n    LongStream mapToLong(ToLongFunction<? super T> mapper);//line4\n    DoubleStream mapToDouble(ToDoubleFunction<? super T> mapper);//line5\n    <R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);//line6\n    IntStream flatMapToInt(Function<? super T, ? extends IntStream> mapper);//line7\n    LongStream flatMapToLong(Function<? super T, ? extends LongStream> mapper);//line8\n    DoubleStream flatMapToDouble(Function<? super T, ? extends DoubleStream> mapper);//line9\n}\n```\n\n我和大家分析一个最具有一般性的映射方法map()，相信大家就能举一反三了，map()定义如下，\n\n **<R> Stream<R> map(Function<? super T, ? extends R> mapper);**\n\n其中，R指定新流的元素类型，T指定调用流的元素类型，mapper是完成映射的Function实例，被称为映射函数，映射函数必须是无状态和不干预的（大家对这二个约束条件应该很熟悉了吧）。因为map()方法会返回一个新流，因此它是一个中间操作。\n\n`Function`是 `java.util.function`包中声明的一个函数式接口，声明如下：\n\n```\n@FunctionalInterface\npublic interface Function<T, R> {\n     R apply(T t);\n}\n```\n在map()的使有过程中，T是调用流的元素类型，R是映射的结果类型。其中,apply(T t)中的t是对被映射对象的引用，被返回映射结果。下面我们将上一篇中的例子进行变形，用映射来完成他:\n\n`假设List里面有三个Integer类型的元素分别为1，2，3。现在的需求是分别让List里面的每个元素都放大两倍后，再求积。这个需求的正确答案应该是48;`\n\n```\nprivate static void learnMap() {\n     List<Integer> lists = new ArrayList<>();\n        lists.add(1);\n        lists.add(2);\n        lists.add(3);\n     //使用并行流来处理\n     Integer product = lists.parallelStream().reduce(1, (a, b) -> a *  (b * 2),\n                                                        (a, b) -> a * b);\n     System.out.println(\"product:\" + product);//48\n\n     //使用映射来处理 \n     //Integer productMap = lists.parallelStream().map((a) -> a * 2).reduce(1, (a, b) -> a * b);\n     Stream<Integer> productNewMapStream = lists.parallelStream().map((a) -> a * 2);\n     Integer productMap = productNewMapStream.reduce(1, (a, b) -> a * b);\n     System.out.println(\"productMap:\" + productMap);//48\n}\n```\n\n与使用并行流不同，在使用映射处理的时候，元素扩大2倍发生时机不一样了，使用并行流元素扩大是在缩减的过程当中的，而使用映射处理时，元素扩大是发生在映射过程中的。因此映射过程完程之后，不需要reduce()提供合并器了。\n\n上面的这个例子还是简单了一点，下面再举一个例子,王者荣耀团队经济计算：\n\n```\n#玩家使用的英雄以及当前获得的金币数\npublic class HeroPlayerGold {\n    /** 使用的英雄名字 */\n    private String hero;\n    /** 玩家的ID */\n    private String player;\n    /** 获得的金币数 */\n    private int gold;\n\n    public HeroPlayerGold(String hero, String player, int gold) {\n        this.hero = hero;\n        this.player = player;\n        this.gold = gold;\n    }\n  //省略get/set/toString\n}\n\n#玩家获得的金币数\npublic class Gold {\n    /** 获得的金币数 */\n    private int gold;\n\n    public Gold(int gold) {\n        this.gold = gold;\n    }\n //省略get/set/toString\n｝\n\n#测试类\npublic class Main {\n    public static void main(String[] args) {\n        learnMap2th();\n    }\n\n    private static void learnMap2th() {\n        List<HeroPlayerGold> lists = new ArrayList<>();\n        lists.add(new HeroPlayerGold(\"盖伦\", \"RNG-Letme\", 100));\n        lists.add(new HeroPlayerGold(\"诸葛亮\", \"RNG-Xiaohu\", 300));\n        lists.add(new HeroPlayerGold(\"露娜\", \"RNG-MLXG\", 300));\n        lists.add(new HeroPlayerGold(\"狄仁杰\", \"RNG-UZI\", 500));\n        lists.add(new HeroPlayerGold(\"牛头\", \"RNG-Ming\", 500));\n\n        //计算团队经济\n        int teamMoney = lists.stream()\n                .map(player -> new Gold(player.getGold()))//note1\n                .mapToInt(Gold::getGold)\n                .reduce(0, (a, b) -> a + b);\n        System.out.println(\"团队经济：\" + teamMoney);//1700\n\n\n        //计算团队经济2\n        double teamMoney2 = lists.stream()\n                .mapToDouble(HeroPlayerGold::getGold)\n                .reduce(0, (a, b) -> a + b);\n        System.out.println(\"团队经济：\" + teamMoney2);//1700.0\n    }\n}\n\n```\n\n代码应该不难理解，通过代码，大家应该知道我们假设的场景了。我们的RNG去参加王者荣耀比赛了，像这种团队游戏，观众在经济方面关注更多的可能是团队经济，而不是个人经济。\n\n在我们`HeroPlayerGold`类里面存有明星玩家，使用的英雄，和这局比赛某个玩家当前获得的金币数，我们另有一个专们管理金币的`Gold`类，我们第一种计算团队经济的方式，使把`HeroPlayerGold`里面的`gold`字段转换到`Gold`里面了<sup> `//note1` </sup>,这里产生的新流只包含了原始流中选定的`gold`字段，因为我们的原始流中包含了`hero`、`player`、`gold`,三个字段，我们只选取了`gold`字段（因为我们只关心这个字段），所以其它的两个字段被丢弃了。然后从新流取出`Gold`里面的`gold`字段并把他转成一个`IntStream`，然后我们就要以通过缩减操作完成我们的团队经济计算了。\n\n第一种方式，大家需要好好理解，理解了，我相信你们的项目中，很多很多地方可以用得上了，再也不需要动不动就查数据库了，怎样效率高怎样来，只是一种建议。第二种只是快速计算团队经济而已，没什么值得讲的。\n\n接下来讲一下他的扩展方向：大家还记得我在第二篇中介绍中间操作概念的时候吗？`中间操作会产生另一个流。因此中间操作可以用来创建执行一系列动作的管道。`我们可以把多个中间操作放到管道中，所以我们很容易就创建出很强大的组合操作了，发挥你的想象，打出你们的组合拳;\n\n我现在举一个例子：比如现在相统计团队里面两个C位的经济占了多少，代码看起来可能就是这样了：\n```\n private static void learnMap2th() {\n        List<HeroPlayerGold> lists = new ArrayList<>();\n        lists.add(new HeroPlayerGold(\"盖伦\", \"RNG-Letme\", 100));\n        lists.add(new HeroPlayerGold(\"诸葛亮\", \"RNG-Xiaohu\", 300));\n        lists.add(new HeroPlayerGold(\"露娜\", \"RNG-MLXG\", 300));\n        lists.add(new HeroPlayerGold(\"狄仁杰\", \"RNG-UZI\", 500));\n        lists.add(new HeroPlayerGold(\"牛头\", \"RNG-Ming\", 500));\n        \n        //计算两个C位的经济和\n        lists.stream()\n                .filter(player-> \"RNG-Xiaohu\".equals(player.getPlayer()) || \"RNG-UZI\".equals(player.getPlayer()))\n                .map(player->new Gold(player.getGold()))\n                .mapToInt(Gold::getGold)\n                .reduce((a,b)->a+b)\n                .ifPresent(System.out::println);//800\n    }\n```\n\n大家有没有感觉，这种操作怎么带有点数据库的风格啊？其实在创建数据库查询的时候，这种过滤操作十分常见，如果你经常在你的项目中使用流API，这几个条件算什么?等你们把流API用熟了之后，你们完全可以通过这种链式操作创建出非常复杂的查询，合并和选择的操作。\n\n通过前面的例子，我们已经把`map()`，`mapToInt()`，`mapToLong()`，`mapToDouble`都讲了。那么剩下的就是flatMap()方法了。本来想让大家自行去理解这个方法的，因为怕这篇文章写得太长了。但是后面想想，还是我来给大家分析一下吧。\n\n**<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);**\n\n通过前面的学习我们知道`mapper`是一个映射函数，它和map()方法也一样也会返回一个新流，我们把返回的新流称为映射流。**我们提供的映射函数会处理原始流中的每一个元素，而映射流中包含了所有经过我们映射函数处理后产生的新元素。** 加粗部份需要重点理解。\n\n我们来看一下源码对flatMap()的注释:\n\n> The  flatMap() operation has the effect of applying a one-to-many  transformation to the elements of the stream, and then flattening the resulting elements into a new stream.\n\n大意就是：**flatMap()操作能把原始流中的元素进行一对多的转换，并且将新生成的元素全都合并到它返回的流里面。**根据我们所学的知识，他的这种一对多的转换功能肯定就是映射函数提供的，这一点没有疑问吧！然后源码的注释上面还提供了一个例子，通过注释加例子，我相信大家都能非常清楚地理解flatMap()了。\n\n```\n    /* <p>If {@code orders} is a stream of purchase orders, and each purchase\n     * order contains a collection of line items, then the following produces a\n     * stream containing all the line items in all the orders:\n     * <pre>{@code\n     *     orders.flatMap(order -> order.getLineItems().stream())...\n     * }</pre>\n     */\n```\n\n**如果orders是一批采购订单对应的流，并且每一个采购订单都包含一系列的采购项，那么`orders.flatMap(order -> order.getLineItems().stream())...`生成的新流将包含这一批采购订单中所有采购项。** \n\n我们用伪代码来就更加清晰了`Stream<Orders<OrderItem>>`====>Stream<OrderItem>。大家能理解了吗？还没理解？再来一个例子：\n\n```\n private static void learnFlatMap() {\n        //(广州  深圳  上海  北京)的全拼的一些组合,下面我们就把每一个城市都划分一下\n        List<String> citys = Arrays.asList(\"GuangZhou ShangHai\", \"GuangZhou ShenZhen\",\n                \"ShangHai ShenZhen\", \"BeiJing ShangHai\", \"GuangZhou BeiJing\", \"ShenZhen BeiJing\");\n\n        //这里打印的数组对应的地址\n        citys.stream().map(mCitys -> Arrays.stream(mCitys.split(\" \"))).forEach(System.out::println);//note1\n\n        System.out.println();\n\n        //流里面的元素还是一个数组\n        citys.stream()\n                .map(mCities -> Arrays.stream(mCities.split(\" \")))//流里面的每个元素还是数组\n                .forEach(cities ->cities.forEach(city-> System.out.print(city+\" \")));//note2\n\n        System.out.println();\n        System.out.println();\n\n        //直接一个flatMap()就把数组合并到映射流里面了\n        citys.stream().flatMap(mCities->Arrays.stream(mCities.split(\" \"))).forEach(System.out::println);//note3\n\n        System.out.println();\n\n        //使用distinct()方法去重！\n        citys.stream().flatMap(mCities->Arrays.stream(mCities.split(\" \"))).distinct().forEach(System.out::println);//note4\n\n    }\n```\n\n其中<sup> `//note1` </sup>处是无法打印元素的，使用map()打印元素的方式在<sup> `//note2` </sup>，原因也在注释中交待了，但是使用了flatMap()方法后，直接就可以打印了<sup> `//note3` </sup>，到这里，应该就能理解**如果orders是一批采购订单对应的流，并且每一个采购订单都包含一系列的采购项，那么`orders.flatMap(order -> order.getLineItems().stream())...`生成的新流将包含这一批采购订单中所有采购项。** 了吧。最后<sup> `//note4` </sup>是一个去重的方法，大家运行一遍吧。\n\n#### 小结一下\n\n通过这一篇文章，相信大家对流API中的映射已经不再陌生了，其实最需要注意的一个点是,map()和flatMap()的区别，我也一步步地带着大家理解和应用了。其实在流API这一块中，大家单单掌握概念是没什么用的，一定要去实战了，一个项目里面，集合框架这种东西用得还是特别多的，用到集合框架的大部份情况，其实都可以考虑一下用Stream流去操作一下，不仅增加效率，还可以增加业务流程的清晰度。\n","source":"_posts/新特性/Java8/Stream/Java 8 新特性之 Stream 流（五）映射.md","raw":"---\ntitle: Java 8 新特性之 Stream 流（五）映射\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n\n经过了前面四篇文章的学习，相信大家对Stream流已经是相当的熟悉了，同时也掌握了一些高级功能了，如果你之前有阅读过集合框架的基石`Collection`接口，是不是在经过前面的学习，以前看不懂的东西，突然之间就恍然大悟了呢？\n\n今天我们的主角是Stream流里面的映射。由于之前，映射并没有再我们的Demo，例子中出现过，所以对大家来说可能会稍微有一点点陌生的，但通过这一篇文章，我相信能解决你的疑问。\n\n在正式开始之前，我和大家继续说说流API操作，不知道大家有没有注意到，其实我们所有的流API操作都是针对流中的元素进行的，并且都是基于同一流里面的，大家有没有这样的疑问，怎么样把一个流的元素弄到另一个流里面呢？怎么把流中的一些满足条件的元素放到一个新流里面呢？\n\n通过这一节，你将会掌握解决刚才问题的本领。另外再提一点，如果流操作只有中间操作，没有终端操作，那么这些中间操作是不会执行的，换句话说，只有终端操作才能触发中间操作的运行。\n\n#### 我们为什么需要映射？\n\n因为在很多时候，将一个流的元素映射到另一个流对我们是非常有帮助的。比如有一个包含有名字，手机号码和钱的数据库构成的流，可能你只想要映射钱这个字段到另一个流，这时候可能之前学到的知识就还不能解决，于是映射就站了出来了。\n\n另外，如果你希望对流中的元素应用一些转换，然后把转换的元素映射到一个新流里面，这时候也可以用映射。\n\n我们先来看看流API库给我们提供了什么样的支持\n\n```\npublic interface Stream<T> extends BaseStream<T, Stream<T>> {\n    <R> Stream<R> map(Function<? super T, ? extends R> mapper);//line2\n    IntStream mapToInt(ToIntFunction<? super T> mapper);//line3\n    LongStream mapToLong(ToLongFunction<? super T> mapper);//line4\n    DoubleStream mapToDouble(ToDoubleFunction<? super T> mapper);//line5\n    <R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);//line6\n    IntStream flatMapToInt(Function<? super T, ? extends IntStream> mapper);//line7\n    LongStream flatMapToLong(Function<? super T, ? extends LongStream> mapper);//line8\n    DoubleStream flatMapToDouble(Function<? super T, ? extends DoubleStream> mapper);//line9\n}\n```\n\n我和大家分析一个最具有一般性的映射方法map()，相信大家就能举一反三了，map()定义如下，\n\n **<R> Stream<R> map(Function<? super T, ? extends R> mapper);**\n\n其中，R指定新流的元素类型，T指定调用流的元素类型，mapper是完成映射的Function实例，被称为映射函数，映射函数必须是无状态和不干预的（大家对这二个约束条件应该很熟悉了吧）。因为map()方法会返回一个新流，因此它是一个中间操作。\n\n`Function`是 `java.util.function`包中声明的一个函数式接口，声明如下：\n\n```\n@FunctionalInterface\npublic interface Function<T, R> {\n     R apply(T t);\n}\n```\n在map()的使有过程中，T是调用流的元素类型，R是映射的结果类型。其中,apply(T t)中的t是对被映射对象的引用，被返回映射结果。下面我们将上一篇中的例子进行变形，用映射来完成他:\n\n`假设List里面有三个Integer类型的元素分别为1，2，3。现在的需求是分别让List里面的每个元素都放大两倍后，再求积。这个需求的正确答案应该是48;`\n\n```\nprivate static void learnMap() {\n     List<Integer> lists = new ArrayList<>();\n        lists.add(1);\n        lists.add(2);\n        lists.add(3);\n     //使用并行流来处理\n     Integer product = lists.parallelStream().reduce(1, (a, b) -> a *  (b * 2),\n                                                        (a, b) -> a * b);\n     System.out.println(\"product:\" + product);//48\n\n     //使用映射来处理 \n     //Integer productMap = lists.parallelStream().map((a) -> a * 2).reduce(1, (a, b) -> a * b);\n     Stream<Integer> productNewMapStream = lists.parallelStream().map((a) -> a * 2);\n     Integer productMap = productNewMapStream.reduce(1, (a, b) -> a * b);\n     System.out.println(\"productMap:\" + productMap);//48\n}\n```\n\n与使用并行流不同，在使用映射处理的时候，元素扩大2倍发生时机不一样了，使用并行流元素扩大是在缩减的过程当中的，而使用映射处理时，元素扩大是发生在映射过程中的。因此映射过程完程之后，不需要reduce()提供合并器了。\n\n上面的这个例子还是简单了一点，下面再举一个例子,王者荣耀团队经济计算：\n\n```\n#玩家使用的英雄以及当前获得的金币数\npublic class HeroPlayerGold {\n    /** 使用的英雄名字 */\n    private String hero;\n    /** 玩家的ID */\n    private String player;\n    /** 获得的金币数 */\n    private int gold;\n\n    public HeroPlayerGold(String hero, String player, int gold) {\n        this.hero = hero;\n        this.player = player;\n        this.gold = gold;\n    }\n  //省略get/set/toString\n}\n\n#玩家获得的金币数\npublic class Gold {\n    /** 获得的金币数 */\n    private int gold;\n\n    public Gold(int gold) {\n        this.gold = gold;\n    }\n //省略get/set/toString\n｝\n\n#测试类\npublic class Main {\n    public static void main(String[] args) {\n        learnMap2th();\n    }\n\n    private static void learnMap2th() {\n        List<HeroPlayerGold> lists = new ArrayList<>();\n        lists.add(new HeroPlayerGold(\"盖伦\", \"RNG-Letme\", 100));\n        lists.add(new HeroPlayerGold(\"诸葛亮\", \"RNG-Xiaohu\", 300));\n        lists.add(new HeroPlayerGold(\"露娜\", \"RNG-MLXG\", 300));\n        lists.add(new HeroPlayerGold(\"狄仁杰\", \"RNG-UZI\", 500));\n        lists.add(new HeroPlayerGold(\"牛头\", \"RNG-Ming\", 500));\n\n        //计算团队经济\n        int teamMoney = lists.stream()\n                .map(player -> new Gold(player.getGold()))//note1\n                .mapToInt(Gold::getGold)\n                .reduce(0, (a, b) -> a + b);\n        System.out.println(\"团队经济：\" + teamMoney);//1700\n\n\n        //计算团队经济2\n        double teamMoney2 = lists.stream()\n                .mapToDouble(HeroPlayerGold::getGold)\n                .reduce(0, (a, b) -> a + b);\n        System.out.println(\"团队经济：\" + teamMoney2);//1700.0\n    }\n}\n\n```\n\n代码应该不难理解，通过代码，大家应该知道我们假设的场景了。我们的RNG去参加王者荣耀比赛了，像这种团队游戏，观众在经济方面关注更多的可能是团队经济，而不是个人经济。\n\n在我们`HeroPlayerGold`类里面存有明星玩家，使用的英雄，和这局比赛某个玩家当前获得的金币数，我们另有一个专们管理金币的`Gold`类，我们第一种计算团队经济的方式，使把`HeroPlayerGold`里面的`gold`字段转换到`Gold`里面了<sup> `//note1` </sup>,这里产生的新流只包含了原始流中选定的`gold`字段，因为我们的原始流中包含了`hero`、`player`、`gold`,三个字段，我们只选取了`gold`字段（因为我们只关心这个字段），所以其它的两个字段被丢弃了。然后从新流取出`Gold`里面的`gold`字段并把他转成一个`IntStream`，然后我们就要以通过缩减操作完成我们的团队经济计算了。\n\n第一种方式，大家需要好好理解，理解了，我相信你们的项目中，很多很多地方可以用得上了，再也不需要动不动就查数据库了，怎样效率高怎样来，只是一种建议。第二种只是快速计算团队经济而已，没什么值得讲的。\n\n接下来讲一下他的扩展方向：大家还记得我在第二篇中介绍中间操作概念的时候吗？`中间操作会产生另一个流。因此中间操作可以用来创建执行一系列动作的管道。`我们可以把多个中间操作放到管道中，所以我们很容易就创建出很强大的组合操作了，发挥你的想象，打出你们的组合拳;\n\n我现在举一个例子：比如现在相统计团队里面两个C位的经济占了多少，代码看起来可能就是这样了：\n```\n private static void learnMap2th() {\n        List<HeroPlayerGold> lists = new ArrayList<>();\n        lists.add(new HeroPlayerGold(\"盖伦\", \"RNG-Letme\", 100));\n        lists.add(new HeroPlayerGold(\"诸葛亮\", \"RNG-Xiaohu\", 300));\n        lists.add(new HeroPlayerGold(\"露娜\", \"RNG-MLXG\", 300));\n        lists.add(new HeroPlayerGold(\"狄仁杰\", \"RNG-UZI\", 500));\n        lists.add(new HeroPlayerGold(\"牛头\", \"RNG-Ming\", 500));\n        \n        //计算两个C位的经济和\n        lists.stream()\n                .filter(player-> \"RNG-Xiaohu\".equals(player.getPlayer()) || \"RNG-UZI\".equals(player.getPlayer()))\n                .map(player->new Gold(player.getGold()))\n                .mapToInt(Gold::getGold)\n                .reduce((a,b)->a+b)\n                .ifPresent(System.out::println);//800\n    }\n```\n\n大家有没有感觉，这种操作怎么带有点数据库的风格啊？其实在创建数据库查询的时候，这种过滤操作十分常见，如果你经常在你的项目中使用流API，这几个条件算什么?等你们把流API用熟了之后，你们完全可以通过这种链式操作创建出非常复杂的查询，合并和选择的操作。\n\n通过前面的例子，我们已经把`map()`，`mapToInt()`，`mapToLong()`，`mapToDouble`都讲了。那么剩下的就是flatMap()方法了。本来想让大家自行去理解这个方法的，因为怕这篇文章写得太长了。但是后面想想，还是我来给大家分析一下吧。\n\n**<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);**\n\n通过前面的学习我们知道`mapper`是一个映射函数，它和map()方法也一样也会返回一个新流，我们把返回的新流称为映射流。**我们提供的映射函数会处理原始流中的每一个元素，而映射流中包含了所有经过我们映射函数处理后产生的新元素。** 加粗部份需要重点理解。\n\n我们来看一下源码对flatMap()的注释:\n\n> The  flatMap() operation has the effect of applying a one-to-many  transformation to the elements of the stream, and then flattening the resulting elements into a new stream.\n\n大意就是：**flatMap()操作能把原始流中的元素进行一对多的转换，并且将新生成的元素全都合并到它返回的流里面。**根据我们所学的知识，他的这种一对多的转换功能肯定就是映射函数提供的，这一点没有疑问吧！然后源码的注释上面还提供了一个例子，通过注释加例子，我相信大家都能非常清楚地理解flatMap()了。\n\n```\n    /* <p>If {@code orders} is a stream of purchase orders, and each purchase\n     * order contains a collection of line items, then the following produces a\n     * stream containing all the line items in all the orders:\n     * <pre>{@code\n     *     orders.flatMap(order -> order.getLineItems().stream())...\n     * }</pre>\n     */\n```\n\n**如果orders是一批采购订单对应的流，并且每一个采购订单都包含一系列的采购项，那么`orders.flatMap(order -> order.getLineItems().stream())...`生成的新流将包含这一批采购订单中所有采购项。** \n\n我们用伪代码来就更加清晰了`Stream<Orders<OrderItem>>`====>Stream<OrderItem>。大家能理解了吗？还没理解？再来一个例子：\n\n```\n private static void learnFlatMap() {\n        //(广州  深圳  上海  北京)的全拼的一些组合,下面我们就把每一个城市都划分一下\n        List<String> citys = Arrays.asList(\"GuangZhou ShangHai\", \"GuangZhou ShenZhen\",\n                \"ShangHai ShenZhen\", \"BeiJing ShangHai\", \"GuangZhou BeiJing\", \"ShenZhen BeiJing\");\n\n        //这里打印的数组对应的地址\n        citys.stream().map(mCitys -> Arrays.stream(mCitys.split(\" \"))).forEach(System.out::println);//note1\n\n        System.out.println();\n\n        //流里面的元素还是一个数组\n        citys.stream()\n                .map(mCities -> Arrays.stream(mCities.split(\" \")))//流里面的每个元素还是数组\n                .forEach(cities ->cities.forEach(city-> System.out.print(city+\" \")));//note2\n\n        System.out.println();\n        System.out.println();\n\n        //直接一个flatMap()就把数组合并到映射流里面了\n        citys.stream().flatMap(mCities->Arrays.stream(mCities.split(\" \"))).forEach(System.out::println);//note3\n\n        System.out.println();\n\n        //使用distinct()方法去重！\n        citys.stream().flatMap(mCities->Arrays.stream(mCities.split(\" \"))).distinct().forEach(System.out::println);//note4\n\n    }\n```\n\n其中<sup> `//note1` </sup>处是无法打印元素的，使用map()打印元素的方式在<sup> `//note2` </sup>，原因也在注释中交待了，但是使用了flatMap()方法后，直接就可以打印了<sup> `//note3` </sup>，到这里，应该就能理解**如果orders是一批采购订单对应的流，并且每一个采购订单都包含一系列的采购项，那么`orders.flatMap(order -> order.getLineItems().stream())...`生成的新流将包含这一批采购订单中所有采购项。** 了吧。最后<sup> `//note4` </sup>是一个去重的方法，大家运行一遍吧。\n\n#### 小结一下\n\n通过这一篇文章，相信大家对流API中的映射已经不再陌生了，其实最需要注意的一个点是,map()和flatMap()的区别，我也一步步地带着大家理解和应用了。其实在流API这一块中，大家单单掌握概念是没什么用的，一定要去实战了，一个项目里面，集合框架这种东西用得还是特别多的，用到集合框架的大部份情况，其实都可以考虑一下用Stream流去操作一下，不仅增加效率，还可以增加业务流程的清晰度。\n","slug":"新特性/Java8/Stream/Java 8 新特性之 Stream 流（五）映射","published":1,"updated":"2025-10-15T07:20:51.385Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu077a006xqkd4ep8vcgtq","content":"<p>经过了前面四篇文章的学习，相信大家对Stream流已经是相当的熟悉了，同时也掌握了一些高级功能了，如果你之前有阅读过集合框架的基石<code>Collection</code>接口，是不是在经过前面的学习，以前看不懂的东西，突然之间就恍然大悟了呢？</p>\n<p>今天我们的主角是Stream流里面的映射。由于之前，映射并没有再我们的Demo，例子中出现过，所以对大家来说可能会稍微有一点点陌生的，但通过这一篇文章，我相信能解决你的疑问。</p>\n<p>在正式开始之前，我和大家继续说说流API操作，不知道大家有没有注意到，其实我们所有的流API操作都是针对流中的元素进行的，并且都是基于同一流里面的，大家有没有这样的疑问，怎么样把一个流的元素弄到另一个流里面呢？怎么把流中的一些满足条件的元素放到一个新流里面呢？</p>\n<p>通过这一节，你将会掌握解决刚才问题的本领。另外再提一点，如果流操作只有中间操作，没有终端操作，那么这些中间操作是不会执行的，换句话说，只有终端操作才能触发中间操作的运行。</p>\n<h4 id=\"我们为什么需要映射？\"><a href=\"#我们为什么需要映射？\" class=\"headerlink\" title=\"我们为什么需要映射？\"></a>我们为什么需要映射？</h4><p>因为在很多时候，将一个流的元素映射到另一个流对我们是非常有帮助的。比如有一个包含有名字，手机号码和钱的数据库构成的流，可能你只想要映射钱这个字段到另一个流，这时候可能之前学到的知识就还不能解决，于是映射就站了出来了。</p>\n<p>另外，如果你希望对流中的元素应用一些转换，然后把转换的元素映射到一个新流里面，这时候也可以用映射。</p>\n<p>我们先来看看流API库给我们提供了什么样的支持</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;\n    &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);&#x2F;&#x2F;line2\n    IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper);&#x2F;&#x2F;line3\n    LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper);&#x2F;&#x2F;line4\n    DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper);&#x2F;&#x2F;line5\n    &lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper);&#x2F;&#x2F;line6\n    IntStream flatMapToInt(Function&lt;? super T, ? extends IntStream&gt; mapper);&#x2F;&#x2F;line7\n    LongStream flatMapToLong(Function&lt;? super T, ? extends LongStream&gt; mapper);&#x2F;&#x2F;line8\n    DoubleStream flatMapToDouble(Function&lt;? super T, ? extends DoubleStream&gt; mapper);&#x2F;&#x2F;line9\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我和大家分析一个最具有一般性的映射方法map()，相信大家就能举一反三了，map()定义如下，</p>\n<p> <strong><R> Stream<R> map(Function&lt;? super T, ? extends R&gt; mapper);</strong></p>\n<p>其中，R指定新流的元素类型，T指定调用流的元素类型，mapper是完成映射的Function实例，被称为映射函数，映射函数必须是无状态和不干预的（大家对这二个约束条件应该很熟悉了吧）。因为map()方法会返回一个新流，因此它是一个中间操作。</p>\n<p><code>Function</code>是 <code>java.util.function</code>包中声明的一个函数式接口，声明如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@FunctionalInterface\npublic interface Function&lt;T, R&gt; &#123;\n     R apply(T t);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在map()的使有过程中，T是调用流的元素类型，R是映射的结果类型。其中,apply(T t)中的t是对被映射对象的引用，被返回映射结果。下面我们将上一篇中的例子进行变形，用映射来完成他:</p>\n<p><code>假设List里面有三个Integer类型的元素分别为1，2，3。现在的需求是分别让List里面的每个元素都放大两倍后，再求积。这个需求的正确答案应该是48;</code></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void learnMap() &#123;\n     List&lt;Integer&gt; lists &#x3D; new ArrayList&lt;&gt;();\n        lists.add(1);\n        lists.add(2);\n        lists.add(3);\n     &#x2F;&#x2F;使用并行流来处理\n     Integer product &#x3D; lists.parallelStream().reduce(1, (a, b) -&gt; a *  (b * 2),\n                                                        (a, b) -&gt; a * b);\n     System.out.println(&quot;product:&quot; + product);&#x2F;&#x2F;48\n\n     &#x2F;&#x2F;使用映射来处理 \n     &#x2F;&#x2F;Integer productMap &#x3D; lists.parallelStream().map((a) -&gt; a * 2).reduce(1, (a, b) -&gt; a * b);\n     Stream&lt;Integer&gt; productNewMapStream &#x3D; lists.parallelStream().map((a) -&gt; a * 2);\n     Integer productMap &#x3D; productNewMapStream.reduce(1, (a, b) -&gt; a * b);\n     System.out.println(&quot;productMap:&quot; + productMap);&#x2F;&#x2F;48\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>与使用并行流不同，在使用映射处理的时候，元素扩大2倍发生时机不一样了，使用并行流元素扩大是在缩减的过程当中的，而使用映射处理时，元素扩大是发生在映射过程中的。因此映射过程完程之后，不需要reduce()提供合并器了。</p>\n<p>上面的这个例子还是简单了一点，下面再举一个例子,王者荣耀团队经济计算：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#玩家使用的英雄以及当前获得的金币数\npublic class HeroPlayerGold &#123;\n    &#x2F;** 使用的英雄名字 *&#x2F;\n    private String hero;\n    &#x2F;** 玩家的ID *&#x2F;\n    private String player;\n    &#x2F;** 获得的金币数 *&#x2F;\n    private int gold;\n\n    public HeroPlayerGold(String hero, String player, int gold) &#123;\n        this.hero &#x3D; hero;\n        this.player &#x3D; player;\n        this.gold &#x3D; gold;\n    &#125;\n  &#x2F;&#x2F;省略get&#x2F;set&#x2F;toString\n&#125;\n\n#玩家获得的金币数\npublic class Gold &#123;\n    &#x2F;** 获得的金币数 *&#x2F;\n    private int gold;\n\n    public Gold(int gold) &#123;\n        this.gold &#x3D; gold;\n    &#125;\n &#x2F;&#x2F;省略get&#x2F;set&#x2F;toString\n｝\n\n#测试类\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        learnMap2th();\n    &#125;\n\n    private static void learnMap2th() &#123;\n        List&lt;HeroPlayerGold&gt; lists &#x3D; new ArrayList&lt;&gt;();\n        lists.add(new HeroPlayerGold(&quot;盖伦&quot;, &quot;RNG-Letme&quot;, 100));\n        lists.add(new HeroPlayerGold(&quot;诸葛亮&quot;, &quot;RNG-Xiaohu&quot;, 300));\n        lists.add(new HeroPlayerGold(&quot;露娜&quot;, &quot;RNG-MLXG&quot;, 300));\n        lists.add(new HeroPlayerGold(&quot;狄仁杰&quot;, &quot;RNG-UZI&quot;, 500));\n        lists.add(new HeroPlayerGold(&quot;牛头&quot;, &quot;RNG-Ming&quot;, 500));\n\n        &#x2F;&#x2F;计算团队经济\n        int teamMoney &#x3D; lists.stream()\n                .map(player -&gt; new Gold(player.getGold()))&#x2F;&#x2F;note1\n                .mapToInt(Gold::getGold)\n                .reduce(0, (a, b) -&gt; a + b);\n        System.out.println(&quot;团队经济：&quot; + teamMoney);&#x2F;&#x2F;1700\n\n\n        &#x2F;&#x2F;计算团队经济2\n        double teamMoney2 &#x3D; lists.stream()\n                .mapToDouble(HeroPlayerGold::getGold)\n                .reduce(0, (a, b) -&gt; a + b);\n        System.out.println(&quot;团队经济：&quot; + teamMoney2);&#x2F;&#x2F;1700.0\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>代码应该不难理解，通过代码，大家应该知道我们假设的场景了。我们的RNG去参加王者荣耀比赛了，像这种团队游戏，观众在经济方面关注更多的可能是团队经济，而不是个人经济。</p>\n<p>在我们<code>HeroPlayerGold</code>类里面存有明星玩家，使用的英雄，和这局比赛某个玩家当前获得的金币数，我们另有一个专们管理金币的<code>Gold</code>类，我们第一种计算团队经济的方式，使把<code>HeroPlayerGold</code>里面的<code>gold</code>字段转换到<code>Gold</code>里面了<sup> <code>//note1</code> </sup>,这里产生的新流只包含了原始流中选定的<code>gold</code>字段，因为我们的原始流中包含了<code>hero</code>、<code>player</code>、<code>gold</code>,三个字段，我们只选取了<code>gold</code>字段（因为我们只关心这个字段），所以其它的两个字段被丢弃了。然后从新流取出<code>Gold</code>里面的<code>gold</code>字段并把他转成一个<code>IntStream</code>，然后我们就要以通过缩减操作完成我们的团队经济计算了。</p>\n<p>第一种方式，大家需要好好理解，理解了，我相信你们的项目中，很多很多地方可以用得上了，再也不需要动不动就查数据库了，怎样效率高怎样来，只是一种建议。第二种只是快速计算团队经济而已，没什么值得讲的。</p>\n<p>接下来讲一下他的扩展方向：大家还记得我在第二篇中介绍中间操作概念的时候吗？<code>中间操作会产生另一个流。因此中间操作可以用来创建执行一系列动作的管道。</code>我们可以把多个中间操作放到管道中，所以我们很容易就创建出很强大的组合操作了，发挥你的想象，打出你们的组合拳;</p>\n<p>我现在举一个例子：比如现在相统计团队里面两个C位的经济占了多少，代码看起来可能就是这样了：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void learnMap2th() &#123;\n       List&lt;HeroPlayerGold&gt; lists &#x3D; new ArrayList&lt;&gt;();\n       lists.add(new HeroPlayerGold(&quot;盖伦&quot;, &quot;RNG-Letme&quot;, 100));\n       lists.add(new HeroPlayerGold(&quot;诸葛亮&quot;, &quot;RNG-Xiaohu&quot;, 300));\n       lists.add(new HeroPlayerGold(&quot;露娜&quot;, &quot;RNG-MLXG&quot;, 300));\n       lists.add(new HeroPlayerGold(&quot;狄仁杰&quot;, &quot;RNG-UZI&quot;, 500));\n       lists.add(new HeroPlayerGold(&quot;牛头&quot;, &quot;RNG-Ming&quot;, 500));\n       \n       &#x2F;&#x2F;计算两个C位的经济和\n       lists.stream()\n               .filter(player-&gt; &quot;RNG-Xiaohu&quot;.equals(player.getPlayer()) || &quot;RNG-UZI&quot;.equals(player.getPlayer()))\n               .map(player-&gt;new Gold(player.getGold()))\n               .mapToInt(Gold::getGold)\n               .reduce((a,b)-&gt;a+b)\n               .ifPresent(System.out::println);&#x2F;&#x2F;800\n   &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>大家有没有感觉，这种操作怎么带有点数据库的风格啊？其实在创建数据库查询的时候，这种过滤操作十分常见，如果你经常在你的项目中使用流API，这几个条件算什么?等你们把流API用熟了之后，你们完全可以通过这种链式操作创建出非常复杂的查询，合并和选择的操作。</p>\n<p>通过前面的例子，我们已经把<code>map()</code>，<code>mapToInt()</code>，<code>mapToLong()</code>，<code>mapToDouble</code>都讲了。那么剩下的就是flatMap()方法了。本来想让大家自行去理解这个方法的，因为怕这篇文章写得太长了。但是后面想想，还是我来给大家分析一下吧。</p>\n<p><strong><R> Stream<R> flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper);</strong></p>\n<p>通过前面的学习我们知道<code>mapper</code>是一个映射函数，它和map()方法也一样也会返回一个新流，我们把返回的新流称为映射流。<strong>我们提供的映射函数会处理原始流中的每一个元素，而映射流中包含了所有经过我们映射函数处理后产生的新元素。</strong> 加粗部份需要重点理解。</p>\n<p>我们来看一下源码对flatMap()的注释:</p>\n<blockquote>\n<p>The  flatMap() operation has the effect of applying a one-to-many  transformation to the elements of the stream, and then flattening the resulting elements into a new stream.</p>\n</blockquote>\n<p>大意就是：<strong>flatMap()操作能把原始流中的元素进行一对多的转换，并且将新生成的元素全都合并到它返回的流里面。</strong>根据我们所学的知识，他的这种一对多的转换功能肯定就是映射函数提供的，这一点没有疑问吧！然后源码的注释上面还提供了一个例子，通过注释加例子，我相信大家都能非常清楚地理解flatMap()了。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;* &lt;p&gt;If &#123;@code orders&#125; is a stream of purchase orders, and each purchase\n * order contains a collection of line items, then the following produces a\n * stream containing all the line items in all the orders:\n * &lt;pre&gt;&#123;@code\n *     orders.flatMap(order -&gt; order.getLineItems().stream())...\n * &#125;&lt;&#x2F;pre&gt;\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>如果orders是一批采购订单对应的流，并且每一个采购订单都包含一系列的采购项，那么<code>orders.flatMap(order -&gt; order.getLineItems().stream())...</code>生成的新流将包含这一批采购订单中所有采购项。</strong> </p>\n<p>我们用伪代码来就更加清晰了<code>Stream&lt;Orders&lt;OrderItem&gt;&gt;</code>&#x3D;&#x3D;&#x3D;&#x3D;&gt;Stream<OrderItem>。大家能理解了吗？还没理解？再来一个例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void learnFlatMap() &#123;\n       &#x2F;&#x2F;(广州  深圳  上海  北京)的全拼的一些组合,下面我们就把每一个城市都划分一下\n       List&lt;String&gt; citys &#x3D; Arrays.asList(&quot;GuangZhou ShangHai&quot;, &quot;GuangZhou ShenZhen&quot;,\n               &quot;ShangHai ShenZhen&quot;, &quot;BeiJing ShangHai&quot;, &quot;GuangZhou BeiJing&quot;, &quot;ShenZhen BeiJing&quot;);\n\n       &#x2F;&#x2F;这里打印的数组对应的地址\n       citys.stream().map(mCitys -&gt; Arrays.stream(mCitys.split(&quot; &quot;))).forEach(System.out::println);&#x2F;&#x2F;note1\n\n       System.out.println();\n\n       &#x2F;&#x2F;流里面的元素还是一个数组\n       citys.stream()\n               .map(mCities -&gt; Arrays.stream(mCities.split(&quot; &quot;)))&#x2F;&#x2F;流里面的每个元素还是数组\n               .forEach(cities -&gt;cities.forEach(city-&gt; System.out.print(city+&quot; &quot;)));&#x2F;&#x2F;note2\n\n       System.out.println();\n       System.out.println();\n\n       &#x2F;&#x2F;直接一个flatMap()就把数组合并到映射流里面了\n       citys.stream().flatMap(mCities-&gt;Arrays.stream(mCities.split(&quot; &quot;))).forEach(System.out::println);&#x2F;&#x2F;note3\n\n       System.out.println();\n\n       &#x2F;&#x2F;使用distinct()方法去重！\n       citys.stream().flatMap(mCities-&gt;Arrays.stream(mCities.split(&quot; &quot;))).distinct().forEach(System.out::println);&#x2F;&#x2F;note4\n\n   &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中<sup> <code>//note1</code> </sup>处是无法打印元素的，使用map()打印元素的方式在<sup> <code>//note2</code> </sup>，原因也在注释中交待了，但是使用了flatMap()方法后，直接就可以打印了<sup> <code>//note3</code> </sup>，到这里，应该就能理解<strong>如果orders是一批采购订单对应的流，并且每一个采购订单都包含一系列的采购项，那么<code>orders.flatMap(order -&gt; order.getLineItems().stream())...</code>生成的新流将包含这一批采购订单中所有采购项。</strong> 了吧。最后<sup> <code>//note4</code> </sup>是一个去重的方法，大家运行一遍吧。</p>\n<h4 id=\"小结一下\"><a href=\"#小结一下\" class=\"headerlink\" title=\"小结一下\"></a>小结一下</h4><p>通过这一篇文章，相信大家对流API中的映射已经不再陌生了，其实最需要注意的一个点是,map()和flatMap()的区别，我也一步步地带着大家理解和应用了。其实在流API这一块中，大家单单掌握概念是没什么用的，一定要去实战了，一个项目里面，集合框架这种东西用得还是特别多的，用到集合框架的大部份情况，其实都可以考虑一下用Stream流去操作一下，不仅增加效率，还可以增加业务流程的清晰度。</p>\n","excerpt":"","more":"<p>经过了前面四篇文章的学习，相信大家对Stream流已经是相当的熟悉了，同时也掌握了一些高级功能了，如果你之前有阅读过集合框架的基石<code>Collection</code>接口，是不是在经过前面的学习，以前看不懂的东西，突然之间就恍然大悟了呢？</p>\n<p>今天我们的主角是Stream流里面的映射。由于之前，映射并没有再我们的Demo，例子中出现过，所以对大家来说可能会稍微有一点点陌生的，但通过这一篇文章，我相信能解决你的疑问。</p>\n<p>在正式开始之前，我和大家继续说说流API操作，不知道大家有没有注意到，其实我们所有的流API操作都是针对流中的元素进行的，并且都是基于同一流里面的，大家有没有这样的疑问，怎么样把一个流的元素弄到另一个流里面呢？怎么把流中的一些满足条件的元素放到一个新流里面呢？</p>\n<p>通过这一节，你将会掌握解决刚才问题的本领。另外再提一点，如果流操作只有中间操作，没有终端操作，那么这些中间操作是不会执行的，换句话说，只有终端操作才能触发中间操作的运行。</p>\n<h4 id=\"我们为什么需要映射？\"><a href=\"#我们为什么需要映射？\" class=\"headerlink\" title=\"我们为什么需要映射？\"></a>我们为什么需要映射？</h4><p>因为在很多时候，将一个流的元素映射到另一个流对我们是非常有帮助的。比如有一个包含有名字，手机号码和钱的数据库构成的流，可能你只想要映射钱这个字段到另一个流，这时候可能之前学到的知识就还不能解决，于是映射就站了出来了。</p>\n<p>另外，如果你希望对流中的元素应用一些转换，然后把转换的元素映射到一个新流里面，这时候也可以用映射。</p>\n<p>我们先来看看流API库给我们提供了什么样的支持</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;\n    &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);&#x2F;&#x2F;line2\n    IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper);&#x2F;&#x2F;line3\n    LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper);&#x2F;&#x2F;line4\n    DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper);&#x2F;&#x2F;line5\n    &lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper);&#x2F;&#x2F;line6\n    IntStream flatMapToInt(Function&lt;? super T, ? extends IntStream&gt; mapper);&#x2F;&#x2F;line7\n    LongStream flatMapToLong(Function&lt;? super T, ? extends LongStream&gt; mapper);&#x2F;&#x2F;line8\n    DoubleStream flatMapToDouble(Function&lt;? super T, ? extends DoubleStream&gt; mapper);&#x2F;&#x2F;line9\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我和大家分析一个最具有一般性的映射方法map()，相信大家就能举一反三了，map()定义如下，</p>\n<p> <strong><R> Stream<R> map(Function&lt;? super T, ? extends R&gt; mapper);</strong></p>\n<p>其中，R指定新流的元素类型，T指定调用流的元素类型，mapper是完成映射的Function实例，被称为映射函数，映射函数必须是无状态和不干预的（大家对这二个约束条件应该很熟悉了吧）。因为map()方法会返回一个新流，因此它是一个中间操作。</p>\n<p><code>Function</code>是 <code>java.util.function</code>包中声明的一个函数式接口，声明如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@FunctionalInterface\npublic interface Function&lt;T, R&gt; &#123;\n     R apply(T t);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在map()的使有过程中，T是调用流的元素类型，R是映射的结果类型。其中,apply(T t)中的t是对被映射对象的引用，被返回映射结果。下面我们将上一篇中的例子进行变形，用映射来完成他:</p>\n<p><code>假设List里面有三个Integer类型的元素分别为1，2，3。现在的需求是分别让List里面的每个元素都放大两倍后，再求积。这个需求的正确答案应该是48;</code></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void learnMap() &#123;\n     List&lt;Integer&gt; lists &#x3D; new ArrayList&lt;&gt;();\n        lists.add(1);\n        lists.add(2);\n        lists.add(3);\n     &#x2F;&#x2F;使用并行流来处理\n     Integer product &#x3D; lists.parallelStream().reduce(1, (a, b) -&gt; a *  (b * 2),\n                                                        (a, b) -&gt; a * b);\n     System.out.println(&quot;product:&quot; + product);&#x2F;&#x2F;48\n\n     &#x2F;&#x2F;使用映射来处理 \n     &#x2F;&#x2F;Integer productMap &#x3D; lists.parallelStream().map((a) -&gt; a * 2).reduce(1, (a, b) -&gt; a * b);\n     Stream&lt;Integer&gt; productNewMapStream &#x3D; lists.parallelStream().map((a) -&gt; a * 2);\n     Integer productMap &#x3D; productNewMapStream.reduce(1, (a, b) -&gt; a * b);\n     System.out.println(&quot;productMap:&quot; + productMap);&#x2F;&#x2F;48\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>与使用并行流不同，在使用映射处理的时候，元素扩大2倍发生时机不一样了，使用并行流元素扩大是在缩减的过程当中的，而使用映射处理时，元素扩大是发生在映射过程中的。因此映射过程完程之后，不需要reduce()提供合并器了。</p>\n<p>上面的这个例子还是简单了一点，下面再举一个例子,王者荣耀团队经济计算：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#玩家使用的英雄以及当前获得的金币数\npublic class HeroPlayerGold &#123;\n    &#x2F;** 使用的英雄名字 *&#x2F;\n    private String hero;\n    &#x2F;** 玩家的ID *&#x2F;\n    private String player;\n    &#x2F;** 获得的金币数 *&#x2F;\n    private int gold;\n\n    public HeroPlayerGold(String hero, String player, int gold) &#123;\n        this.hero &#x3D; hero;\n        this.player &#x3D; player;\n        this.gold &#x3D; gold;\n    &#125;\n  &#x2F;&#x2F;省略get&#x2F;set&#x2F;toString\n&#125;\n\n#玩家获得的金币数\npublic class Gold &#123;\n    &#x2F;** 获得的金币数 *&#x2F;\n    private int gold;\n\n    public Gold(int gold) &#123;\n        this.gold &#x3D; gold;\n    &#125;\n &#x2F;&#x2F;省略get&#x2F;set&#x2F;toString\n｝\n\n#测试类\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        learnMap2th();\n    &#125;\n\n    private static void learnMap2th() &#123;\n        List&lt;HeroPlayerGold&gt; lists &#x3D; new ArrayList&lt;&gt;();\n        lists.add(new HeroPlayerGold(&quot;盖伦&quot;, &quot;RNG-Letme&quot;, 100));\n        lists.add(new HeroPlayerGold(&quot;诸葛亮&quot;, &quot;RNG-Xiaohu&quot;, 300));\n        lists.add(new HeroPlayerGold(&quot;露娜&quot;, &quot;RNG-MLXG&quot;, 300));\n        lists.add(new HeroPlayerGold(&quot;狄仁杰&quot;, &quot;RNG-UZI&quot;, 500));\n        lists.add(new HeroPlayerGold(&quot;牛头&quot;, &quot;RNG-Ming&quot;, 500));\n\n        &#x2F;&#x2F;计算团队经济\n        int teamMoney &#x3D; lists.stream()\n                .map(player -&gt; new Gold(player.getGold()))&#x2F;&#x2F;note1\n                .mapToInt(Gold::getGold)\n                .reduce(0, (a, b) -&gt; a + b);\n        System.out.println(&quot;团队经济：&quot; + teamMoney);&#x2F;&#x2F;1700\n\n\n        &#x2F;&#x2F;计算团队经济2\n        double teamMoney2 &#x3D; lists.stream()\n                .mapToDouble(HeroPlayerGold::getGold)\n                .reduce(0, (a, b) -&gt; a + b);\n        System.out.println(&quot;团队经济：&quot; + teamMoney2);&#x2F;&#x2F;1700.0\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>代码应该不难理解，通过代码，大家应该知道我们假设的场景了。我们的RNG去参加王者荣耀比赛了，像这种团队游戏，观众在经济方面关注更多的可能是团队经济，而不是个人经济。</p>\n<p>在我们<code>HeroPlayerGold</code>类里面存有明星玩家，使用的英雄，和这局比赛某个玩家当前获得的金币数，我们另有一个专们管理金币的<code>Gold</code>类，我们第一种计算团队经济的方式，使把<code>HeroPlayerGold</code>里面的<code>gold</code>字段转换到<code>Gold</code>里面了<sup> <code>//note1</code> </sup>,这里产生的新流只包含了原始流中选定的<code>gold</code>字段，因为我们的原始流中包含了<code>hero</code>、<code>player</code>、<code>gold</code>,三个字段，我们只选取了<code>gold</code>字段（因为我们只关心这个字段），所以其它的两个字段被丢弃了。然后从新流取出<code>Gold</code>里面的<code>gold</code>字段并把他转成一个<code>IntStream</code>，然后我们就要以通过缩减操作完成我们的团队经济计算了。</p>\n<p>第一种方式，大家需要好好理解，理解了，我相信你们的项目中，很多很多地方可以用得上了，再也不需要动不动就查数据库了，怎样效率高怎样来，只是一种建议。第二种只是快速计算团队经济而已，没什么值得讲的。</p>\n<p>接下来讲一下他的扩展方向：大家还记得我在第二篇中介绍中间操作概念的时候吗？<code>中间操作会产生另一个流。因此中间操作可以用来创建执行一系列动作的管道。</code>我们可以把多个中间操作放到管道中，所以我们很容易就创建出很强大的组合操作了，发挥你的想象，打出你们的组合拳;</p>\n<p>我现在举一个例子：比如现在相统计团队里面两个C位的经济占了多少，代码看起来可能就是这样了：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void learnMap2th() &#123;\n       List&lt;HeroPlayerGold&gt; lists &#x3D; new ArrayList&lt;&gt;();\n       lists.add(new HeroPlayerGold(&quot;盖伦&quot;, &quot;RNG-Letme&quot;, 100));\n       lists.add(new HeroPlayerGold(&quot;诸葛亮&quot;, &quot;RNG-Xiaohu&quot;, 300));\n       lists.add(new HeroPlayerGold(&quot;露娜&quot;, &quot;RNG-MLXG&quot;, 300));\n       lists.add(new HeroPlayerGold(&quot;狄仁杰&quot;, &quot;RNG-UZI&quot;, 500));\n       lists.add(new HeroPlayerGold(&quot;牛头&quot;, &quot;RNG-Ming&quot;, 500));\n       \n       &#x2F;&#x2F;计算两个C位的经济和\n       lists.stream()\n               .filter(player-&gt; &quot;RNG-Xiaohu&quot;.equals(player.getPlayer()) || &quot;RNG-UZI&quot;.equals(player.getPlayer()))\n               .map(player-&gt;new Gold(player.getGold()))\n               .mapToInt(Gold::getGold)\n               .reduce((a,b)-&gt;a+b)\n               .ifPresent(System.out::println);&#x2F;&#x2F;800\n   &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>大家有没有感觉，这种操作怎么带有点数据库的风格啊？其实在创建数据库查询的时候，这种过滤操作十分常见，如果你经常在你的项目中使用流API，这几个条件算什么?等你们把流API用熟了之后，你们完全可以通过这种链式操作创建出非常复杂的查询，合并和选择的操作。</p>\n<p>通过前面的例子，我们已经把<code>map()</code>，<code>mapToInt()</code>，<code>mapToLong()</code>，<code>mapToDouble</code>都讲了。那么剩下的就是flatMap()方法了。本来想让大家自行去理解这个方法的，因为怕这篇文章写得太长了。但是后面想想，还是我来给大家分析一下吧。</p>\n<p><strong><R> Stream<R> flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper);</strong></p>\n<p>通过前面的学习我们知道<code>mapper</code>是一个映射函数，它和map()方法也一样也会返回一个新流，我们把返回的新流称为映射流。<strong>我们提供的映射函数会处理原始流中的每一个元素，而映射流中包含了所有经过我们映射函数处理后产生的新元素。</strong> 加粗部份需要重点理解。</p>\n<p>我们来看一下源码对flatMap()的注释:</p>\n<blockquote>\n<p>The  flatMap() operation has the effect of applying a one-to-many  transformation to the elements of the stream, and then flattening the resulting elements into a new stream.</p>\n</blockquote>\n<p>大意就是：<strong>flatMap()操作能把原始流中的元素进行一对多的转换，并且将新生成的元素全都合并到它返回的流里面。</strong>根据我们所学的知识，他的这种一对多的转换功能肯定就是映射函数提供的，这一点没有疑问吧！然后源码的注释上面还提供了一个例子，通过注释加例子，我相信大家都能非常清楚地理解flatMap()了。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;* &lt;p&gt;If &#123;@code orders&#125; is a stream of purchase orders, and each purchase\n * order contains a collection of line items, then the following produces a\n * stream containing all the line items in all the orders:\n * &lt;pre&gt;&#123;@code\n *     orders.flatMap(order -&gt; order.getLineItems().stream())...\n * &#125;&lt;&#x2F;pre&gt;\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>如果orders是一批采购订单对应的流，并且每一个采购订单都包含一系列的采购项，那么<code>orders.flatMap(order -&gt; order.getLineItems().stream())...</code>生成的新流将包含这一批采购订单中所有采购项。</strong> </p>\n<p>我们用伪代码来就更加清晰了<code>Stream&lt;Orders&lt;OrderItem&gt;&gt;</code>&#x3D;&#x3D;&#x3D;&#x3D;&gt;Stream<OrderItem>。大家能理解了吗？还没理解？再来一个例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void learnFlatMap() &#123;\n       &#x2F;&#x2F;(广州  深圳  上海  北京)的全拼的一些组合,下面我们就把每一个城市都划分一下\n       List&lt;String&gt; citys &#x3D; Arrays.asList(&quot;GuangZhou ShangHai&quot;, &quot;GuangZhou ShenZhen&quot;,\n               &quot;ShangHai ShenZhen&quot;, &quot;BeiJing ShangHai&quot;, &quot;GuangZhou BeiJing&quot;, &quot;ShenZhen BeiJing&quot;);\n\n       &#x2F;&#x2F;这里打印的数组对应的地址\n       citys.stream().map(mCitys -&gt; Arrays.stream(mCitys.split(&quot; &quot;))).forEach(System.out::println);&#x2F;&#x2F;note1\n\n       System.out.println();\n\n       &#x2F;&#x2F;流里面的元素还是一个数组\n       citys.stream()\n               .map(mCities -&gt; Arrays.stream(mCities.split(&quot; &quot;)))&#x2F;&#x2F;流里面的每个元素还是数组\n               .forEach(cities -&gt;cities.forEach(city-&gt; System.out.print(city+&quot; &quot;)));&#x2F;&#x2F;note2\n\n       System.out.println();\n       System.out.println();\n\n       &#x2F;&#x2F;直接一个flatMap()就把数组合并到映射流里面了\n       citys.stream().flatMap(mCities-&gt;Arrays.stream(mCities.split(&quot; &quot;))).forEach(System.out::println);&#x2F;&#x2F;note3\n\n       System.out.println();\n\n       &#x2F;&#x2F;使用distinct()方法去重！\n       citys.stream().flatMap(mCities-&gt;Arrays.stream(mCities.split(&quot; &quot;))).distinct().forEach(System.out::println);&#x2F;&#x2F;note4\n\n   &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中<sup> <code>//note1</code> </sup>处是无法打印元素的，使用map()打印元素的方式在<sup> <code>//note2</code> </sup>，原因也在注释中交待了，但是使用了flatMap()方法后，直接就可以打印了<sup> <code>//note3</code> </sup>，到这里，应该就能理解<strong>如果orders是一批采购订单对应的流，并且每一个采购订单都包含一系列的采购项，那么<code>orders.flatMap(order -&gt; order.getLineItems().stream())...</code>生成的新流将包含这一批采购订单中所有采购项。</strong> 了吧。最后<sup> <code>//note4</code> </sup>是一个去重的方法，大家运行一遍吧。</p>\n<h4 id=\"小结一下\"><a href=\"#小结一下\" class=\"headerlink\" title=\"小结一下\"></a>小结一下</h4><p>通过这一篇文章，相信大家对流API中的映射已经不再陌生了，其实最需要注意的一个点是,map()和flatMap()的区别，我也一步步地带着大家理解和应用了。其实在流API这一块中，大家单单掌握概念是没什么用的，一定要去实战了，一个项目里面，集合框架这种东西用得还是特别多的，用到集合框架的大部份情况，其实都可以考虑一下用Stream流去操作一下，不仅增加效率，还可以增加业务流程的清晰度。</p>\n"},{"title":"Java 8 新特性之 Stream 流（四）并行流","date":"2025-10-15T03:36:33.000Z","_content":"\n随着对流API认识的慢慢深入，本章我们要讨论的知识点是流API里面的并行流了。\n\n在开始讨论并行流之前，我先引发一下大家的思考，就你看到这篇文章的时间，你们是不是经常听到，Intel i7 CPU什么8核16线程，什么Android手机8核4GB这种消息，既然我们是处于一个多核处理器的时代，你们有没有想过并行地操作数组和集合框架，从而高速地执行我们对数组或者集合的一些操作呢？\n\n或许你有想过这个问题，但是因为并行编程比较复杂，所以这些想法还停留在你的脑海当中，又或者你已经在路上了，反正你们就是最棒的（我他妈都这么夸你们了，就不能点个喜欢？）。\n\n不管如何，在你看到这一篇文章的时候，我将带你走向并行地操作数组或者集合，当然是使用我们的并行流知识啦。\n\n#### 并行流\n\n并行编程可谓是十分复杂并且很容易出错的，这估计就是我们绝大部分人的拦脚石。刚好Stream流库给我们解决了这个问题，在流API库里面提供了轻松可靠的并行操作。要想并行处理流相当简单，只需要使用一个并行流就可以了。\n\n如第二篇文章中提到的那样，我们获取一个并行流是非常简单的，只需要对流调用一下parallel()就可以获取到一个并行流了（什么你居然不知道？那么多人看了我的文章，估计你要被他们甩开几条街了，赶紧回去看吧。），第二种方式就更加简单了，我们可以使用Collection接口提供给我们parallelStream(),也是可以获取到一个并行流的。\n\n当然，并行操作肯定是需要环境支持的，你搞了一台一核一线程的小霸王，来跑我的高大上并行流，我也只能慢慢来了。如果你不是小霸王，那我们可以开始这节课的实战了，先拿上一篇的例子来改一下先，如果你不认真观察，你都找不出他们的不同之处：\n\n```\npublic class Main {\n\n    public static void main(String[] args) {\n        learnStream();\n    }\n\n\n\n    private static void learnStream() {\n        List<Integer> lists = new ArrayList<>();\n        lists.add(1);\n        lists.add(2);\n        lists.add(3);\n        lists.add(4);\n        lists.add(5);\n        lists.add(6);\n\n        Optional<Integer> sum = lists.parallelStream().reduce((a, b) -> a + b);//这里把stream()换成了parallelStream（）\n        if (sum.isPresent()) System.out.println(\"list的总和为:\" + sum.get());//21\n        //<====> lists.stream().reduce((a, b) -> a + b).ifPresent(System.out::println);\n\n        Integer sum2 = lists.stream().reduce(0, (a, b) -> a + b);//21\n        System.out.println(\"list的总和为:\" + sum2);\n\n        Optional<Integer> product = lists.stream().reduce((a, b) -> a * b);\n        if (product.isPresent()) System.out.println(\"list的积为:\" + product.get());//720\n\n        Integer product2 = lists.parallelStream().reduce(1, (a, b) -> a * b);//这里把stream()换成了parallelStream（）\n        System.out.println(\"list的积为:\" + product2);//720\n    }\n}\n```\n\n得到结果和上一篇文章的一模一样。但是因为乘法和加法操作是可以发生在不同的线程里面的，因此这两个例子，在数据源足够大的时候，他们的运行的时间，差别相当地大了啊。\n\n一般来说，应用到并行流的任何操作都必须是符合缩减操作的三个约束条件，无状态，不干预，关联性！因为这三大约束确保在并行流上执行操作的结果和在顺序流上执行的结果是相同的。\n\n我们在上一篇讲缩减操作的时候，提到了三个reduce(),但是我们只讲了两个，我就不和你们皮了，直接开讲剩下的那一个，在并行流里面，你们会发现这个版本的reduce()才是真爱啊！\n\n```\npublic interface Stream<T> extends BaseStream<T, Stream<T>> {\n//、、、忽略其他无关紧要的元素\n<U> U reduce(U identity,\n          BiFunction<U, ? super T, U> accumulator,\n          BinaryOperator<U> combiner);\n｝\n```\n\n在reduce()的这个版本当中，accumulator被称为累加器，combiner被称为合成器，combiner定义的函数将accumulator提到的两个值合并起来，因此，我们可以把上面的那个例子改成：\n\n```\n    private static void reduce3th() {\n        List<Integer> lists = new ArrayList<>();\n        lists.add(1);\n        lists.add(2);\n        lists.add(3);\n        lists.add(4);\n        lists.add(5);\n        lists.add(6);\n\n        Integer product2 = lists.parallelStream().reduce(1, (a, b) -> a * b,\n                                                            (a, b) -> a * b);\n        System.out.println(\"list的积为:\" + product2);//720\n    }\n```\n\n他们得到的结果还是一样的。\n\n你们可能以为accumulator和combiner执行的操作是相同的，但其实他们是可以不同的，下面的例子，你们要认真看了：假设List里面有三个Integer类型的元素分别为1，2，3。\n\n现在的需求是分别让List里面的每个元素都放大两倍后，再求积。这个需求的正确答案应该是48;\n\n```\n    private static void reduce3th() {\n        List<Integer> lists = new ArrayList<>();\n        lists.add(1);\n        lists.add(2);\n        lists.add(3);\n\n        Integer product = lists.parallelStream().reduce(1, (a, b) -> a *  (b * 2),\n                                                           (a, b) -> a * b);\n        System.out.println(\"product:\" + product);//48\n    }\n```\n\n累加器部分是将两个元素分别放大两倍后，再相乘,合并器，是将两个部分相乘！如果能理解这里，恭喜你，你的技能有相当大的长进了！估计Stream流你就可以无往而不利了。\n\n如果你还不能理解，就应该继续往下看了，跟着我的步伐慢慢走：\n\n```\n    累加器部分（水平向右）\n        accumulator\n-----------------------------›\nthread-1:   1 * 1 * 2   =   2    |    合并器方向（竖直向下）\nthread-2:   1 * 2 * 2   =   4    |         combiner\nthread-3:   1 * 3 * 2   =   6    |   因此最终的答案是2  *  4  *  6  =   48（没毛病）\n                                 ˇ\n注：水平方向最前面的1就是identity的值\n```\n\n此时，accumulator和combiner执行的操作是不是一定不能相同了。理解这些，对于理解并行流是非常重要的。\n\n如果此时的combiner还是和accumulator相同，那么结果是什么样的呢：请看：\n\n```\n    private static void reduce3th() {\n        List<Integer> lists = new ArrayList<>();\n        lists.add(1);\n        lists.add(2);\n        lists.add(3);\n\n        Integer product = lists.parallelStream().reduce(1, (a, b) -> a *  (b * 2),\n                                                           (a, b) -> a * b * 2 );\n        System.out.println(\"product:\" + product);//192\n    }\n```\n\n192这个答案是怎么来的？\n\n```\n    累加器部分（水平向右）\n        accumulator\n-----------------------------›\nthread-1:   1 * 1 * 2   =   2          |    合并器方向（竖直向下）\nthread-2:   1 * 2 * 2   =   4  *  2    |         combiner\nthread-3:   1 * 3 * 2   =   6  *  2    |   因此最终的答案是2  *  （ 4  *  2 ） *  （6  *  2）  =   192（没毛病）\n                                       ˇ\n注：水平方向最前面的1就是identity的值\n```\n\n#### 顺序流&并行流&无序流之间的切换操作\n\n对于这三种流的切换，在BaseStream接口中提供了相应的方法，如果你还没有记住，回头再看一下第二篇文章吧。\n\n关于使用并行流的时候，还有一个点需要记住：如果集合中或者数组中的元素是有序的，那么对应的流也是有序的。但是在使用并行流时，有时候流是无序的就能获得性能上的提升。因为如果流是无序的，那么流的每个部分都可以被单独的操作，而不需要与其他部分协调，从而提升性能。（又是无状态，说好的退休了呢）。所以当流操作的顺序不重要的时候，可以通过BaseStream接口提供的unordered()方法把流转换成一个无序流之后，再进行各种操作。\n\n另外一点:forEach()方法不一定会保留并行流的顺序，如果在对并行流的每个元素执行操作时，也希望保留顺序，那么可以使用forEachOrdered()方法，它的用法和forEach()是一样的。因为在发布第一篇文章的时候，大家对forEach的反应比较大，很多人其实对forEach都有想法：比如调试难，等等。借这个机会，我谈一谈我对for&forEach的看法。\n\n我们在访问一个数组元素的时候，最快的方式肯定是通过索引去访问的吧，而for循环遍历的时候就是通过下标进行的，所以效率那是相当的高，但是当我们的数据结构不是数组的时候，比如是链表的时候，可想而知，for循环的效率是有多低，但是forEach底层采用的是迭代器的方式，他对数据结构是没有要求的，不管上层的数据结构是什么，他都能保证高效地执行！\n\n因此我的最终答案:如果数据结构是ArrayList这种数据结构，那你可以采用for,但是你的数据结构如果是LinkList那你千万别再用for,应该果断采用forEach,因为数据一多起来的，for此时的效率低得可怜，说不定你的机器就瘫痪了。这也是优化的一个小技巧吧，希望能帮助大家。\n\n#### 小结一下\n\n并行流学会了，你的功力，真的就增长了。效率再也不是问题了，基本上关于并行流的方方面面，这篇文章都已经说提到了，但是Stream在JDK中的变化还是挺快的，我一旦发现有什么改动，会最快地更新这篇文章。下一篇我们继续探索新知识点。\n","source":"_posts/新特性/Java8/Stream/Java 8 新特性之 Stream 流（四）并行流.md","raw":"---\ntitle: Java 8 新特性之 Stream 流（四）并行流\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n\n随着对流API认识的慢慢深入，本章我们要讨论的知识点是流API里面的并行流了。\n\n在开始讨论并行流之前，我先引发一下大家的思考，就你看到这篇文章的时间，你们是不是经常听到，Intel i7 CPU什么8核16线程，什么Android手机8核4GB这种消息，既然我们是处于一个多核处理器的时代，你们有没有想过并行地操作数组和集合框架，从而高速地执行我们对数组或者集合的一些操作呢？\n\n或许你有想过这个问题，但是因为并行编程比较复杂，所以这些想法还停留在你的脑海当中，又或者你已经在路上了，反正你们就是最棒的（我他妈都这么夸你们了，就不能点个喜欢？）。\n\n不管如何，在你看到这一篇文章的时候，我将带你走向并行地操作数组或者集合，当然是使用我们的并行流知识啦。\n\n#### 并行流\n\n并行编程可谓是十分复杂并且很容易出错的，这估计就是我们绝大部分人的拦脚石。刚好Stream流库给我们解决了这个问题，在流API库里面提供了轻松可靠的并行操作。要想并行处理流相当简单，只需要使用一个并行流就可以了。\n\n如第二篇文章中提到的那样，我们获取一个并行流是非常简单的，只需要对流调用一下parallel()就可以获取到一个并行流了（什么你居然不知道？那么多人看了我的文章，估计你要被他们甩开几条街了，赶紧回去看吧。），第二种方式就更加简单了，我们可以使用Collection接口提供给我们parallelStream(),也是可以获取到一个并行流的。\n\n当然，并行操作肯定是需要环境支持的，你搞了一台一核一线程的小霸王，来跑我的高大上并行流，我也只能慢慢来了。如果你不是小霸王，那我们可以开始这节课的实战了，先拿上一篇的例子来改一下先，如果你不认真观察，你都找不出他们的不同之处：\n\n```\npublic class Main {\n\n    public static void main(String[] args) {\n        learnStream();\n    }\n\n\n\n    private static void learnStream() {\n        List<Integer> lists = new ArrayList<>();\n        lists.add(1);\n        lists.add(2);\n        lists.add(3);\n        lists.add(4);\n        lists.add(5);\n        lists.add(6);\n\n        Optional<Integer> sum = lists.parallelStream().reduce((a, b) -> a + b);//这里把stream()换成了parallelStream（）\n        if (sum.isPresent()) System.out.println(\"list的总和为:\" + sum.get());//21\n        //<====> lists.stream().reduce((a, b) -> a + b).ifPresent(System.out::println);\n\n        Integer sum2 = lists.stream().reduce(0, (a, b) -> a + b);//21\n        System.out.println(\"list的总和为:\" + sum2);\n\n        Optional<Integer> product = lists.stream().reduce((a, b) -> a * b);\n        if (product.isPresent()) System.out.println(\"list的积为:\" + product.get());//720\n\n        Integer product2 = lists.parallelStream().reduce(1, (a, b) -> a * b);//这里把stream()换成了parallelStream（）\n        System.out.println(\"list的积为:\" + product2);//720\n    }\n}\n```\n\n得到结果和上一篇文章的一模一样。但是因为乘法和加法操作是可以发生在不同的线程里面的，因此这两个例子，在数据源足够大的时候，他们的运行的时间，差别相当地大了啊。\n\n一般来说，应用到并行流的任何操作都必须是符合缩减操作的三个约束条件，无状态，不干预，关联性！因为这三大约束确保在并行流上执行操作的结果和在顺序流上执行的结果是相同的。\n\n我们在上一篇讲缩减操作的时候，提到了三个reduce(),但是我们只讲了两个，我就不和你们皮了，直接开讲剩下的那一个，在并行流里面，你们会发现这个版本的reduce()才是真爱啊！\n\n```\npublic interface Stream<T> extends BaseStream<T, Stream<T>> {\n//、、、忽略其他无关紧要的元素\n<U> U reduce(U identity,\n          BiFunction<U, ? super T, U> accumulator,\n          BinaryOperator<U> combiner);\n｝\n```\n\n在reduce()的这个版本当中，accumulator被称为累加器，combiner被称为合成器，combiner定义的函数将accumulator提到的两个值合并起来，因此，我们可以把上面的那个例子改成：\n\n```\n    private static void reduce3th() {\n        List<Integer> lists = new ArrayList<>();\n        lists.add(1);\n        lists.add(2);\n        lists.add(3);\n        lists.add(4);\n        lists.add(5);\n        lists.add(6);\n\n        Integer product2 = lists.parallelStream().reduce(1, (a, b) -> a * b,\n                                                            (a, b) -> a * b);\n        System.out.println(\"list的积为:\" + product2);//720\n    }\n```\n\n他们得到的结果还是一样的。\n\n你们可能以为accumulator和combiner执行的操作是相同的，但其实他们是可以不同的，下面的例子，你们要认真看了：假设List里面有三个Integer类型的元素分别为1，2，3。\n\n现在的需求是分别让List里面的每个元素都放大两倍后，再求积。这个需求的正确答案应该是48;\n\n```\n    private static void reduce3th() {\n        List<Integer> lists = new ArrayList<>();\n        lists.add(1);\n        lists.add(2);\n        lists.add(3);\n\n        Integer product = lists.parallelStream().reduce(1, (a, b) -> a *  (b * 2),\n                                                           (a, b) -> a * b);\n        System.out.println(\"product:\" + product);//48\n    }\n```\n\n累加器部分是将两个元素分别放大两倍后，再相乘,合并器，是将两个部分相乘！如果能理解这里，恭喜你，你的技能有相当大的长进了！估计Stream流你就可以无往而不利了。\n\n如果你还不能理解，就应该继续往下看了，跟着我的步伐慢慢走：\n\n```\n    累加器部分（水平向右）\n        accumulator\n-----------------------------›\nthread-1:   1 * 1 * 2   =   2    |    合并器方向（竖直向下）\nthread-2:   1 * 2 * 2   =   4    |         combiner\nthread-3:   1 * 3 * 2   =   6    |   因此最终的答案是2  *  4  *  6  =   48（没毛病）\n                                 ˇ\n注：水平方向最前面的1就是identity的值\n```\n\n此时，accumulator和combiner执行的操作是不是一定不能相同了。理解这些，对于理解并行流是非常重要的。\n\n如果此时的combiner还是和accumulator相同，那么结果是什么样的呢：请看：\n\n```\n    private static void reduce3th() {\n        List<Integer> lists = new ArrayList<>();\n        lists.add(1);\n        lists.add(2);\n        lists.add(3);\n\n        Integer product = lists.parallelStream().reduce(1, (a, b) -> a *  (b * 2),\n                                                           (a, b) -> a * b * 2 );\n        System.out.println(\"product:\" + product);//192\n    }\n```\n\n192这个答案是怎么来的？\n\n```\n    累加器部分（水平向右）\n        accumulator\n-----------------------------›\nthread-1:   1 * 1 * 2   =   2          |    合并器方向（竖直向下）\nthread-2:   1 * 2 * 2   =   4  *  2    |         combiner\nthread-3:   1 * 3 * 2   =   6  *  2    |   因此最终的答案是2  *  （ 4  *  2 ） *  （6  *  2）  =   192（没毛病）\n                                       ˇ\n注：水平方向最前面的1就是identity的值\n```\n\n#### 顺序流&并行流&无序流之间的切换操作\n\n对于这三种流的切换，在BaseStream接口中提供了相应的方法，如果你还没有记住，回头再看一下第二篇文章吧。\n\n关于使用并行流的时候，还有一个点需要记住：如果集合中或者数组中的元素是有序的，那么对应的流也是有序的。但是在使用并行流时，有时候流是无序的就能获得性能上的提升。因为如果流是无序的，那么流的每个部分都可以被单独的操作，而不需要与其他部分协调，从而提升性能。（又是无状态，说好的退休了呢）。所以当流操作的顺序不重要的时候，可以通过BaseStream接口提供的unordered()方法把流转换成一个无序流之后，再进行各种操作。\n\n另外一点:forEach()方法不一定会保留并行流的顺序，如果在对并行流的每个元素执行操作时，也希望保留顺序，那么可以使用forEachOrdered()方法，它的用法和forEach()是一样的。因为在发布第一篇文章的时候，大家对forEach的反应比较大，很多人其实对forEach都有想法：比如调试难，等等。借这个机会，我谈一谈我对for&forEach的看法。\n\n我们在访问一个数组元素的时候，最快的方式肯定是通过索引去访问的吧，而for循环遍历的时候就是通过下标进行的，所以效率那是相当的高，但是当我们的数据结构不是数组的时候，比如是链表的时候，可想而知，for循环的效率是有多低，但是forEach底层采用的是迭代器的方式，他对数据结构是没有要求的，不管上层的数据结构是什么，他都能保证高效地执行！\n\n因此我的最终答案:如果数据结构是ArrayList这种数据结构，那你可以采用for,但是你的数据结构如果是LinkList那你千万别再用for,应该果断采用forEach,因为数据一多起来的，for此时的效率低得可怜，说不定你的机器就瘫痪了。这也是优化的一个小技巧吧，希望能帮助大家。\n\n#### 小结一下\n\n并行流学会了，你的功力，真的就增长了。效率再也不是问题了，基本上关于并行流的方方面面，这篇文章都已经说提到了，但是Stream在JDK中的变化还是挺快的，我一旦发现有什么改动，会最快地更新这篇文章。下一篇我们继续探索新知识点。\n","slug":"新特性/Java8/Stream/Java 8 新特性之 Stream 流（四）并行流","published":1,"updated":"2025-10-15T07:20:51.506Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu077b007dqkd42ibebwb4","content":"<p>随着对流API认识的慢慢深入，本章我们要讨论的知识点是流API里面的并行流了。</p>\n<p>在开始讨论并行流之前，我先引发一下大家的思考，就你看到这篇文章的时间，你们是不是经常听到，Intel i7 CPU什么8核16线程，什么Android手机8核4GB这种消息，既然我们是处于一个多核处理器的时代，你们有没有想过并行地操作数组和集合框架，从而高速地执行我们对数组或者集合的一些操作呢？</p>\n<p>或许你有想过这个问题，但是因为并行编程比较复杂，所以这些想法还停留在你的脑海当中，又或者你已经在路上了，反正你们就是最棒的（我他妈都这么夸你们了，就不能点个喜欢？）。</p>\n<p>不管如何，在你看到这一篇文章的时候，我将带你走向并行地操作数组或者集合，当然是使用我们的并行流知识啦。</p>\n<h4 id=\"并行流\"><a href=\"#并行流\" class=\"headerlink\" title=\"并行流\"></a>并行流</h4><p>并行编程可谓是十分复杂并且很容易出错的，这估计就是我们绝大部分人的拦脚石。刚好Stream流库给我们解决了这个问题，在流API库里面提供了轻松可靠的并行操作。要想并行处理流相当简单，只需要使用一个并行流就可以了。</p>\n<p>如第二篇文章中提到的那样，我们获取一个并行流是非常简单的，只需要对流调用一下parallel()就可以获取到一个并行流了（什么你居然不知道？那么多人看了我的文章，估计你要被他们甩开几条街了，赶紧回去看吧。），第二种方式就更加简单了，我们可以使用Collection接口提供给我们parallelStream(),也是可以获取到一个并行流的。</p>\n<p>当然，并行操作肯定是需要环境支持的，你搞了一台一核一线程的小霸王，来跑我的高大上并行流，我也只能慢慢来了。如果你不是小霸王，那我们可以开始这节课的实战了，先拿上一篇的例子来改一下先，如果你不认真观察，你都找不出他们的不同之处：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Main &#123;\n\n    public static void main(String[] args) &#123;\n        learnStream();\n    &#125;\n\n\n\n    private static void learnStream() &#123;\n        List&lt;Integer&gt; lists &#x3D; new ArrayList&lt;&gt;();\n        lists.add(1);\n        lists.add(2);\n        lists.add(3);\n        lists.add(4);\n        lists.add(5);\n        lists.add(6);\n\n        Optional&lt;Integer&gt; sum &#x3D; lists.parallelStream().reduce((a, b) -&gt; a + b);&#x2F;&#x2F;这里把stream()换成了parallelStream（）\n        if (sum.isPresent()) System.out.println(&quot;list的总和为:&quot; + sum.get());&#x2F;&#x2F;21\n        &#x2F;&#x2F;&lt;&#x3D;&#x3D;&#x3D;&#x3D;&gt; lists.stream().reduce((a, b) -&gt; a + b).ifPresent(System.out::println);\n\n        Integer sum2 &#x3D; lists.stream().reduce(0, (a, b) -&gt; a + b);&#x2F;&#x2F;21\n        System.out.println(&quot;list的总和为:&quot; + sum2);\n\n        Optional&lt;Integer&gt; product &#x3D; lists.stream().reduce((a, b) -&gt; a * b);\n        if (product.isPresent()) System.out.println(&quot;list的积为:&quot; + product.get());&#x2F;&#x2F;720\n\n        Integer product2 &#x3D; lists.parallelStream().reduce(1, (a, b) -&gt; a * b);&#x2F;&#x2F;这里把stream()换成了parallelStream（）\n        System.out.println(&quot;list的积为:&quot; + product2);&#x2F;&#x2F;720\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>得到结果和上一篇文章的一模一样。但是因为乘法和加法操作是可以发生在不同的线程里面的，因此这两个例子，在数据源足够大的时候，他们的运行的时间，差别相当地大了啊。</p>\n<p>一般来说，应用到并行流的任何操作都必须是符合缩减操作的三个约束条件，无状态，不干预，关联性！因为这三大约束确保在并行流上执行操作的结果和在顺序流上执行的结果是相同的。</p>\n<p>我们在上一篇讲缩减操作的时候，提到了三个reduce(),但是我们只讲了两个，我就不和你们皮了，直接开讲剩下的那一个，在并行流里面，你们会发现这个版本的reduce()才是真爱啊！</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;\n&#x2F;&#x2F;、、、忽略其他无关紧要的元素\n&lt;U&gt; U reduce(U identity,\n          BiFunction&lt;U, ? super T, U&gt; accumulator,\n          BinaryOperator&lt;U&gt; combiner);\n｝<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在reduce()的这个版本当中，accumulator被称为累加器，combiner被称为合成器，combiner定义的函数将accumulator提到的两个值合并起来，因此，我们可以把上面的那个例子改成：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void reduce3th() &#123;\n    List&lt;Integer&gt; lists &#x3D; new ArrayList&lt;&gt;();\n    lists.add(1);\n    lists.add(2);\n    lists.add(3);\n    lists.add(4);\n    lists.add(5);\n    lists.add(6);\n\n    Integer product2 &#x3D; lists.parallelStream().reduce(1, (a, b) -&gt; a * b,\n                                                        (a, b) -&gt; a * b);\n    System.out.println(&quot;list的积为:&quot; + product2);&#x2F;&#x2F;720\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>他们得到的结果还是一样的。</p>\n<p>你们可能以为accumulator和combiner执行的操作是相同的，但其实他们是可以不同的，下面的例子，你们要认真看了：假设List里面有三个Integer类型的元素分别为1，2，3。</p>\n<p>现在的需求是分别让List里面的每个元素都放大两倍后，再求积。这个需求的正确答案应该是48;</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void reduce3th() &#123;\n    List&lt;Integer&gt; lists &#x3D; new ArrayList&lt;&gt;();\n    lists.add(1);\n    lists.add(2);\n    lists.add(3);\n\n    Integer product &#x3D; lists.parallelStream().reduce(1, (a, b) -&gt; a *  (b * 2),\n                                                       (a, b) -&gt; a * b);\n    System.out.println(&quot;product:&quot; + product);&#x2F;&#x2F;48\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>累加器部分是将两个元素分别放大两倍后，再相乘,合并器，是将两个部分相乘！如果能理解这里，恭喜你，你的技能有相当大的长进了！估计Stream流你就可以无往而不利了。</p>\n<p>如果你还不能理解，就应该继续往下看了，跟着我的步伐慢慢走：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">    累加器部分（水平向右）\n        accumulator\n-----------------------------›\nthread-1:   1 * 1 * 2   &#x3D;   2    |    合并器方向（竖直向下）\nthread-2:   1 * 2 * 2   &#x3D;   4    |         combiner\nthread-3:   1 * 3 * 2   &#x3D;   6    |   因此最终的答案是2  *  4  *  6  &#x3D;   48（没毛病）\n                                 ˇ\n注：水平方向最前面的1就是identity的值<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>此时，accumulator和combiner执行的操作是不是一定不能相同了。理解这些，对于理解并行流是非常重要的。</p>\n<p>如果此时的combiner还是和accumulator相同，那么结果是什么样的呢：请看：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void reduce3th() &#123;\n    List&lt;Integer&gt; lists &#x3D; new ArrayList&lt;&gt;();\n    lists.add(1);\n    lists.add(2);\n    lists.add(3);\n\n    Integer product &#x3D; lists.parallelStream().reduce(1, (a, b) -&gt; a *  (b * 2),\n                                                       (a, b) -&gt; a * b * 2 );\n    System.out.println(&quot;product:&quot; + product);&#x2F;&#x2F;192\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>192这个答案是怎么来的？</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">    累加器部分（水平向右）\n        accumulator\n-----------------------------›\nthread-1:   1 * 1 * 2   &#x3D;   2          |    合并器方向（竖直向下）\nthread-2:   1 * 2 * 2   &#x3D;   4  *  2    |         combiner\nthread-3:   1 * 3 * 2   &#x3D;   6  *  2    |   因此最终的答案是2  *  （ 4  *  2 ） *  （6  *  2）  &#x3D;   192（没毛病）\n                                       ˇ\n注：水平方向最前面的1就是identity的值<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"顺序流-并行流-无序流之间的切换操作\"><a href=\"#顺序流-并行流-无序流之间的切换操作\" class=\"headerlink\" title=\"顺序流&amp;并行流&amp;无序流之间的切换操作\"></a>顺序流&amp;并行流&amp;无序流之间的切换操作</h4><p>对于这三种流的切换，在BaseStream接口中提供了相应的方法，如果你还没有记住，回头再看一下第二篇文章吧。</p>\n<p>关于使用并行流的时候，还有一个点需要记住：如果集合中或者数组中的元素是有序的，那么对应的流也是有序的。但是在使用并行流时，有时候流是无序的就能获得性能上的提升。因为如果流是无序的，那么流的每个部分都可以被单独的操作，而不需要与其他部分协调，从而提升性能。（又是无状态，说好的退休了呢）。所以当流操作的顺序不重要的时候，可以通过BaseStream接口提供的unordered()方法把流转换成一个无序流之后，再进行各种操作。</p>\n<p>另外一点:forEach()方法不一定会保留并行流的顺序，如果在对并行流的每个元素执行操作时，也希望保留顺序，那么可以使用forEachOrdered()方法，它的用法和forEach()是一样的。因为在发布第一篇文章的时候，大家对forEach的反应比较大，很多人其实对forEach都有想法：比如调试难，等等。借这个机会，我谈一谈我对for&amp;forEach的看法。</p>\n<p>我们在访问一个数组元素的时候，最快的方式肯定是通过索引去访问的吧，而for循环遍历的时候就是通过下标进行的，所以效率那是相当的高，但是当我们的数据结构不是数组的时候，比如是链表的时候，可想而知，for循环的效率是有多低，但是forEach底层采用的是迭代器的方式，他对数据结构是没有要求的，不管上层的数据结构是什么，他都能保证高效地执行！</p>\n<p>因此我的最终答案:如果数据结构是ArrayList这种数据结构，那你可以采用for,但是你的数据结构如果是LinkList那你千万别再用for,应该果断采用forEach,因为数据一多起来的，for此时的效率低得可怜，说不定你的机器就瘫痪了。这也是优化的一个小技巧吧，希望能帮助大家。</p>\n<h4 id=\"小结一下\"><a href=\"#小结一下\" class=\"headerlink\" title=\"小结一下\"></a>小结一下</h4><p>并行流学会了，你的功力，真的就增长了。效率再也不是问题了，基本上关于并行流的方方面面，这篇文章都已经说提到了，但是Stream在JDK中的变化还是挺快的，我一旦发现有什么改动，会最快地更新这篇文章。下一篇我们继续探索新知识点。</p>\n","excerpt":"","more":"<p>随着对流API认识的慢慢深入，本章我们要讨论的知识点是流API里面的并行流了。</p>\n<p>在开始讨论并行流之前，我先引发一下大家的思考，就你看到这篇文章的时间，你们是不是经常听到，Intel i7 CPU什么8核16线程，什么Android手机8核4GB这种消息，既然我们是处于一个多核处理器的时代，你们有没有想过并行地操作数组和集合框架，从而高速地执行我们对数组或者集合的一些操作呢？</p>\n<p>或许你有想过这个问题，但是因为并行编程比较复杂，所以这些想法还停留在你的脑海当中，又或者你已经在路上了，反正你们就是最棒的（我他妈都这么夸你们了，就不能点个喜欢？）。</p>\n<p>不管如何，在你看到这一篇文章的时候，我将带你走向并行地操作数组或者集合，当然是使用我们的并行流知识啦。</p>\n<h4 id=\"并行流\"><a href=\"#并行流\" class=\"headerlink\" title=\"并行流\"></a>并行流</h4><p>并行编程可谓是十分复杂并且很容易出错的，这估计就是我们绝大部分人的拦脚石。刚好Stream流库给我们解决了这个问题，在流API库里面提供了轻松可靠的并行操作。要想并行处理流相当简单，只需要使用一个并行流就可以了。</p>\n<p>如第二篇文章中提到的那样，我们获取一个并行流是非常简单的，只需要对流调用一下parallel()就可以获取到一个并行流了（什么你居然不知道？那么多人看了我的文章，估计你要被他们甩开几条街了，赶紧回去看吧。），第二种方式就更加简单了，我们可以使用Collection接口提供给我们parallelStream(),也是可以获取到一个并行流的。</p>\n<p>当然，并行操作肯定是需要环境支持的，你搞了一台一核一线程的小霸王，来跑我的高大上并行流，我也只能慢慢来了。如果你不是小霸王，那我们可以开始这节课的实战了，先拿上一篇的例子来改一下先，如果你不认真观察，你都找不出他们的不同之处：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Main &#123;\n\n    public static void main(String[] args) &#123;\n        learnStream();\n    &#125;\n\n\n\n    private static void learnStream() &#123;\n        List&lt;Integer&gt; lists &#x3D; new ArrayList&lt;&gt;();\n        lists.add(1);\n        lists.add(2);\n        lists.add(3);\n        lists.add(4);\n        lists.add(5);\n        lists.add(6);\n\n        Optional&lt;Integer&gt; sum &#x3D; lists.parallelStream().reduce((a, b) -&gt; a + b);&#x2F;&#x2F;这里把stream()换成了parallelStream（）\n        if (sum.isPresent()) System.out.println(&quot;list的总和为:&quot; + sum.get());&#x2F;&#x2F;21\n        &#x2F;&#x2F;&lt;&#x3D;&#x3D;&#x3D;&#x3D;&gt; lists.stream().reduce((a, b) -&gt; a + b).ifPresent(System.out::println);\n\n        Integer sum2 &#x3D; lists.stream().reduce(0, (a, b) -&gt; a + b);&#x2F;&#x2F;21\n        System.out.println(&quot;list的总和为:&quot; + sum2);\n\n        Optional&lt;Integer&gt; product &#x3D; lists.stream().reduce((a, b) -&gt; a * b);\n        if (product.isPresent()) System.out.println(&quot;list的积为:&quot; + product.get());&#x2F;&#x2F;720\n\n        Integer product2 &#x3D; lists.parallelStream().reduce(1, (a, b) -&gt; a * b);&#x2F;&#x2F;这里把stream()换成了parallelStream（）\n        System.out.println(&quot;list的积为:&quot; + product2);&#x2F;&#x2F;720\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>得到结果和上一篇文章的一模一样。但是因为乘法和加法操作是可以发生在不同的线程里面的，因此这两个例子，在数据源足够大的时候，他们的运行的时间，差别相当地大了啊。</p>\n<p>一般来说，应用到并行流的任何操作都必须是符合缩减操作的三个约束条件，无状态，不干预，关联性！因为这三大约束确保在并行流上执行操作的结果和在顺序流上执行的结果是相同的。</p>\n<p>我们在上一篇讲缩减操作的时候，提到了三个reduce(),但是我们只讲了两个，我就不和你们皮了，直接开讲剩下的那一个，在并行流里面，你们会发现这个版本的reduce()才是真爱啊！</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;\n&#x2F;&#x2F;、、、忽略其他无关紧要的元素\n&lt;U&gt; U reduce(U identity,\n          BiFunction&lt;U, ? super T, U&gt; accumulator,\n          BinaryOperator&lt;U&gt; combiner);\n｝<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在reduce()的这个版本当中，accumulator被称为累加器，combiner被称为合成器，combiner定义的函数将accumulator提到的两个值合并起来，因此，我们可以把上面的那个例子改成：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void reduce3th() &#123;\n    List&lt;Integer&gt; lists &#x3D; new ArrayList&lt;&gt;();\n    lists.add(1);\n    lists.add(2);\n    lists.add(3);\n    lists.add(4);\n    lists.add(5);\n    lists.add(6);\n\n    Integer product2 &#x3D; lists.parallelStream().reduce(1, (a, b) -&gt; a * b,\n                                                        (a, b) -&gt; a * b);\n    System.out.println(&quot;list的积为:&quot; + product2);&#x2F;&#x2F;720\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>他们得到的结果还是一样的。</p>\n<p>你们可能以为accumulator和combiner执行的操作是相同的，但其实他们是可以不同的，下面的例子，你们要认真看了：假设List里面有三个Integer类型的元素分别为1，2，3。</p>\n<p>现在的需求是分别让List里面的每个元素都放大两倍后，再求积。这个需求的正确答案应该是48;</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void reduce3th() &#123;\n    List&lt;Integer&gt; lists &#x3D; new ArrayList&lt;&gt;();\n    lists.add(1);\n    lists.add(2);\n    lists.add(3);\n\n    Integer product &#x3D; lists.parallelStream().reduce(1, (a, b) -&gt; a *  (b * 2),\n                                                       (a, b) -&gt; a * b);\n    System.out.println(&quot;product:&quot; + product);&#x2F;&#x2F;48\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>累加器部分是将两个元素分别放大两倍后，再相乘,合并器，是将两个部分相乘！如果能理解这里，恭喜你，你的技能有相当大的长进了！估计Stream流你就可以无往而不利了。</p>\n<p>如果你还不能理解，就应该继续往下看了，跟着我的步伐慢慢走：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">    累加器部分（水平向右）\n        accumulator\n-----------------------------›\nthread-1:   1 * 1 * 2   &#x3D;   2    |    合并器方向（竖直向下）\nthread-2:   1 * 2 * 2   &#x3D;   4    |         combiner\nthread-3:   1 * 3 * 2   &#x3D;   6    |   因此最终的答案是2  *  4  *  6  &#x3D;   48（没毛病）\n                                 ˇ\n注：水平方向最前面的1就是identity的值<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>此时，accumulator和combiner执行的操作是不是一定不能相同了。理解这些，对于理解并行流是非常重要的。</p>\n<p>如果此时的combiner还是和accumulator相同，那么结果是什么样的呢：请看：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private static void reduce3th() &#123;\n    List&lt;Integer&gt; lists &#x3D; new ArrayList&lt;&gt;();\n    lists.add(1);\n    lists.add(2);\n    lists.add(3);\n\n    Integer product &#x3D; lists.parallelStream().reduce(1, (a, b) -&gt; a *  (b * 2),\n                                                       (a, b) -&gt; a * b * 2 );\n    System.out.println(&quot;product:&quot; + product);&#x2F;&#x2F;192\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>192这个答案是怎么来的？</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">    累加器部分（水平向右）\n        accumulator\n-----------------------------›\nthread-1:   1 * 1 * 2   &#x3D;   2          |    合并器方向（竖直向下）\nthread-2:   1 * 2 * 2   &#x3D;   4  *  2    |         combiner\nthread-3:   1 * 3 * 2   &#x3D;   6  *  2    |   因此最终的答案是2  *  （ 4  *  2 ） *  （6  *  2）  &#x3D;   192（没毛病）\n                                       ˇ\n注：水平方向最前面的1就是identity的值<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"顺序流-并行流-无序流之间的切换操作\"><a href=\"#顺序流-并行流-无序流之间的切换操作\" class=\"headerlink\" title=\"顺序流&amp;并行流&amp;无序流之间的切换操作\"></a>顺序流&amp;并行流&amp;无序流之间的切换操作</h4><p>对于这三种流的切换，在BaseStream接口中提供了相应的方法，如果你还没有记住，回头再看一下第二篇文章吧。</p>\n<p>关于使用并行流的时候，还有一个点需要记住：如果集合中或者数组中的元素是有序的，那么对应的流也是有序的。但是在使用并行流时，有时候流是无序的就能获得性能上的提升。因为如果流是无序的，那么流的每个部分都可以被单独的操作，而不需要与其他部分协调，从而提升性能。（又是无状态，说好的退休了呢）。所以当流操作的顺序不重要的时候，可以通过BaseStream接口提供的unordered()方法把流转换成一个无序流之后，再进行各种操作。</p>\n<p>另外一点:forEach()方法不一定会保留并行流的顺序，如果在对并行流的每个元素执行操作时，也希望保留顺序，那么可以使用forEachOrdered()方法，它的用法和forEach()是一样的。因为在发布第一篇文章的时候，大家对forEach的反应比较大，很多人其实对forEach都有想法：比如调试难，等等。借这个机会，我谈一谈我对for&amp;forEach的看法。</p>\n<p>我们在访问一个数组元素的时候，最快的方式肯定是通过索引去访问的吧，而for循环遍历的时候就是通过下标进行的，所以效率那是相当的高，但是当我们的数据结构不是数组的时候，比如是链表的时候，可想而知，for循环的效率是有多低，但是forEach底层采用的是迭代器的方式，他对数据结构是没有要求的，不管上层的数据结构是什么，他都能保证高效地执行！</p>\n<p>因此我的最终答案:如果数据结构是ArrayList这种数据结构，那你可以采用for,但是你的数据结构如果是LinkList那你千万别再用for,应该果断采用forEach,因为数据一多起来的，for此时的效率低得可怜，说不定你的机器就瘫痪了。这也是优化的一个小技巧吧，希望能帮助大家。</p>\n<h4 id=\"小结一下\"><a href=\"#小结一下\" class=\"headerlink\" title=\"小结一下\"></a>小结一下</h4><p>并行流学会了，你的功力，真的就增长了。效率再也不是问题了，基本上关于并行流的方方面面，这篇文章都已经说提到了，但是Stream在JDK中的变化还是挺快的，我一旦发现有什么改动，会最快地更新这篇文章。下一篇我们继续探索新知识点。</p>\n"},{"title":"Java 8 新特性之Stream流","date":"2025-10-15T03:36:33.000Z","_content":"\n## 是什么是Stream流\n\n`java.util.stream.Stream`\n\nStream流和传统的IO流，它们都叫流，却是两个完全不一样的概念和东西。\n\n流可以简单的说是处理数据集合的东西，可以申明式流式API来处理集合，而不是写一个逻辑实现。\n\n## 流分类\n\n流分为顺序流及并行流，顺序流即每个指令按顺序执行，并行流即集合里面的操作并行执行。\n\n```\nList<Integer> numbers = Arrays.asList(1, 2, 3);\n\n//　顺序流\nnumbers.stream().forEach(n -> System.out.print(n));\n\n//并行流\nnumbers.parallelStream().forEach(n -> System.out.print(n));\n```\n\n以上例子，顺序流总是输出`123`，而并行流则每次结果都不一定，并行流使用了ForkJoinPool分而治之，所以明白了ForkJoinPool原理的同学就知道并行流的真面目了。\n\n## 创建流\n\n1、调用集合的stream()方法或者parallelStream()方法。\n\n2、Stream.of()方法，有针对int,long的专用流IntStream，LongStream。\n\n## 使用流\n\n以下举了流的一些常用的用法。\n\n```\npublic class StreamTest {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"过滤－找出年纪大于18岁的人\");\n\t\tList<User> list = initList();\n\t\tlist.stream().filter((User user) -> user.getAge() > 18).collect(Collectors.toList())\n\t\t\t\t.forEach(System.out::println);\n\t\tSystem.out.println();\n\n\t\tSystem.out.println(\"最大值－找出最大年纪的人\");\n\t\tlist = initList();\n\t\tOptional<User> max = list.stream().max((u1, u2) -> u1.getAge() - u2.getAge());\n\t\tSystem.out.println(max.get());\n\t\tSystem.out.println();\n\n\t\tSystem.out.println(\"映射-规纳－求所有人的年纪总和\");\n\t\tlist = initList();\n\t\tOptional<Integer> reduce = list.stream().map(User::getAge).reduce(Integer::sum);\n\t\tSystem.out.println(reduce.get());\n\t\tSystem.out.println();\n\n\t\tSystem.out.println(\"分组－按年纪分组\");\n\t\tlist = initList();\n\t\tMap<Integer, List<User>> userMap = list.stream()\n\t\t\t\t.collect(Collectors.groupingBy(User::getAge));\n\t\tMapUtils.verbosePrint(System.out, null, userMap);\n\t\tSystem.out.println();\n\n\t\tSystem.out.println(\"创建－去重－统计\");\n\t\tStream<User> userStream = Stream\n\t\t\t\t.of(new User(\"u1\", 1), new User(\"u2\", 21), new User(\"u2\", 21));\n\t\tSystem.out.println(userStream.distinct().count());\n\t\tSystem.out.println();\n\n\t}\n\n\tpublic static List<User> initList() {\n\t\tList<User> list = new ArrayList<>();\n\t\tlist.add(new User(\"oaby\", 23));\n\t\tlist.add(new User(\"tom\", 11));\n\t\tlist.add(new User(\"john\", 16));\n\t\tlist.add(new User(\"jennis\", 26));\n\t\tlist.add(new User(\"tin\", 26));\n\t\tlist.add(new User(\"army\", 26));\n\t\tlist.add(new User(\"mack\", 19));\n\t\tlist.add(new User(\"jobs\", 65));\n\t\tlist.add(new User(\"jordan\", 23));\n\t\treturn list;\n\t}\n\n}\n```\n\n输出结果：\n\n\n```\n过滤－找出年纪大于18岁的人\nUser [username=oaby, age=23]\nUser [username=jennis, age=26]\nUser [username=tin, age=26]\nUser [username=army, age=26]\nUser [username=mack, age=19]\nUser [username=jobs, age=65]\nUser [username=jordan, age=23]\n\n最大值－找出最大年纪的人\nUser [username=jobs, age=65]\n\n映射-规纳－求所有人的年纪总和\n235\n\n分组－按年纪分组\n{\n    16 = [User [username=john, age=16]]\n    65 = [User [username=jobs, age=65]]\n    19 = [User [username=mack, age=19]]\n    23 = [User [username=oaby, age=23], User [username=jordan, age=23]]\n    26 = [User [username=jennis, age=26], User [username=tin, age=26], User [username=army, age=26]]\n    11 = [User [username=tom, age=11]]\n}\n\n创建－去重－统计\n2\n```\n\n可以看出流操作数据集合很强大吧，但需要注意的是流只能执行一次，再次使用需要重要打开。\n\n更多的玩法可以自己去研究吧。\n\n\n","source":"_posts/新特性/Java8/Stream/Java 8 新特性之Stream流.md","raw":"---\ntitle: Java 8 新特性之Stream流\ndate: 2025-10-15 11:36:33\ncategory: 后端\ntags: 新特性\n---\n\n## 是什么是Stream流\n\n`java.util.stream.Stream`\n\nStream流和传统的IO流，它们都叫流，却是两个完全不一样的概念和东西。\n\n流可以简单的说是处理数据集合的东西，可以申明式流式API来处理集合，而不是写一个逻辑实现。\n\n## 流分类\n\n流分为顺序流及并行流，顺序流即每个指令按顺序执行，并行流即集合里面的操作并行执行。\n\n```\nList<Integer> numbers = Arrays.asList(1, 2, 3);\n\n//　顺序流\nnumbers.stream().forEach(n -> System.out.print(n));\n\n//并行流\nnumbers.parallelStream().forEach(n -> System.out.print(n));\n```\n\n以上例子，顺序流总是输出`123`，而并行流则每次结果都不一定，并行流使用了ForkJoinPool分而治之，所以明白了ForkJoinPool原理的同学就知道并行流的真面目了。\n\n## 创建流\n\n1、调用集合的stream()方法或者parallelStream()方法。\n\n2、Stream.of()方法，有针对int,long的专用流IntStream，LongStream。\n\n## 使用流\n\n以下举了流的一些常用的用法。\n\n```\npublic class StreamTest {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"过滤－找出年纪大于18岁的人\");\n\t\tList<User> list = initList();\n\t\tlist.stream().filter((User user) -> user.getAge() > 18).collect(Collectors.toList())\n\t\t\t\t.forEach(System.out::println);\n\t\tSystem.out.println();\n\n\t\tSystem.out.println(\"最大值－找出最大年纪的人\");\n\t\tlist = initList();\n\t\tOptional<User> max = list.stream().max((u1, u2) -> u1.getAge() - u2.getAge());\n\t\tSystem.out.println(max.get());\n\t\tSystem.out.println();\n\n\t\tSystem.out.println(\"映射-规纳－求所有人的年纪总和\");\n\t\tlist = initList();\n\t\tOptional<Integer> reduce = list.stream().map(User::getAge).reduce(Integer::sum);\n\t\tSystem.out.println(reduce.get());\n\t\tSystem.out.println();\n\n\t\tSystem.out.println(\"分组－按年纪分组\");\n\t\tlist = initList();\n\t\tMap<Integer, List<User>> userMap = list.stream()\n\t\t\t\t.collect(Collectors.groupingBy(User::getAge));\n\t\tMapUtils.verbosePrint(System.out, null, userMap);\n\t\tSystem.out.println();\n\n\t\tSystem.out.println(\"创建－去重－统计\");\n\t\tStream<User> userStream = Stream\n\t\t\t\t.of(new User(\"u1\", 1), new User(\"u2\", 21), new User(\"u2\", 21));\n\t\tSystem.out.println(userStream.distinct().count());\n\t\tSystem.out.println();\n\n\t}\n\n\tpublic static List<User> initList() {\n\t\tList<User> list = new ArrayList<>();\n\t\tlist.add(new User(\"oaby\", 23));\n\t\tlist.add(new User(\"tom\", 11));\n\t\tlist.add(new User(\"john\", 16));\n\t\tlist.add(new User(\"jennis\", 26));\n\t\tlist.add(new User(\"tin\", 26));\n\t\tlist.add(new User(\"army\", 26));\n\t\tlist.add(new User(\"mack\", 19));\n\t\tlist.add(new User(\"jobs\", 65));\n\t\tlist.add(new User(\"jordan\", 23));\n\t\treturn list;\n\t}\n\n}\n```\n\n输出结果：\n\n\n```\n过滤－找出年纪大于18岁的人\nUser [username=oaby, age=23]\nUser [username=jennis, age=26]\nUser [username=tin, age=26]\nUser [username=army, age=26]\nUser [username=mack, age=19]\nUser [username=jobs, age=65]\nUser [username=jordan, age=23]\n\n最大值－找出最大年纪的人\nUser [username=jobs, age=65]\n\n映射-规纳－求所有人的年纪总和\n235\n\n分组－按年纪分组\n{\n    16 = [User [username=john, age=16]]\n    65 = [User [username=jobs, age=65]]\n    19 = [User [username=mack, age=19]]\n    23 = [User [username=oaby, age=23], User [username=jordan, age=23]]\n    26 = [User [username=jennis, age=26], User [username=tin, age=26], User [username=army, age=26]]\n    11 = [User [username=tom, age=11]]\n}\n\n创建－去重－统计\n2\n```\n\n可以看出流操作数据集合很强大吧，但需要注意的是流只能执行一次，再次使用需要重要打开。\n\n更多的玩法可以自己去研究吧。\n\n\n","slug":"新特性/Java8/Stream/Java 8 新特性之Stream流","published":1,"updated":"2025-10-15T07:20:51.439Z","comments":1,"layout":"post","photos":[],"_id":"cmgsu077c007eqkd40oz0fsvq","content":"<h2 id=\"是什么是Stream流\"><a href=\"#是什么是Stream流\" class=\"headerlink\" title=\"是什么是Stream流\"></a>是什么是Stream流</h2><p><code>java.util.stream.Stream</code></p>\n<p>Stream流和传统的IO流，它们都叫流，却是两个完全不一样的概念和东西。</p>\n<p>流可以简单的说是处理数据集合的东西，可以申明式流式API来处理集合，而不是写一个逻辑实现。</p>\n<h2 id=\"流分类\"><a href=\"#流分类\" class=\"headerlink\" title=\"流分类\"></a>流分类</h2><p>流分为顺序流及并行流，顺序流即每个指令按顺序执行，并行流即集合里面的操作并行执行。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3);\n\n&#x2F;&#x2F;　顺序流\nnumbers.stream().forEach(n -&gt; System.out.print(n));\n\n&#x2F;&#x2F;并行流\nnumbers.parallelStream().forEach(n -&gt; System.out.print(n));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上例子，顺序流总是输出<code>123</code>，而并行流则每次结果都不一定，并行流使用了ForkJoinPool分而治之，所以明白了ForkJoinPool原理的同学就知道并行流的真面目了。</p>\n<h2 id=\"创建流\"><a href=\"#创建流\" class=\"headerlink\" title=\"创建流\"></a>创建流</h2><p>1、调用集合的stream()方法或者parallelStream()方法。</p>\n<p>2、Stream.of()方法，有针对int,long的专用流IntStream，LongStream。</p>\n<h2 id=\"使用流\"><a href=\"#使用流\" class=\"headerlink\" title=\"使用流\"></a>使用流</h2><p>以下举了流的一些常用的用法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class StreamTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tSystem.out.println(&quot;过滤－找出年纪大于18岁的人&quot;);\n\t\tList&lt;User&gt; list &#x3D; initList();\n\t\tlist.stream().filter((User user) -&gt; user.getAge() &gt; 18).collect(Collectors.toList())\n\t\t\t\t.forEach(System.out::println);\n\t\tSystem.out.println();\n\n\t\tSystem.out.println(&quot;最大值－找出最大年纪的人&quot;);\n\t\tlist &#x3D; initList();\n\t\tOptional&lt;User&gt; max &#x3D; list.stream().max((u1, u2) -&gt; u1.getAge() - u2.getAge());\n\t\tSystem.out.println(max.get());\n\t\tSystem.out.println();\n\n\t\tSystem.out.println(&quot;映射-规纳－求所有人的年纪总和&quot;);\n\t\tlist &#x3D; initList();\n\t\tOptional&lt;Integer&gt; reduce &#x3D; list.stream().map(User::getAge).reduce(Integer::sum);\n\t\tSystem.out.println(reduce.get());\n\t\tSystem.out.println();\n\n\t\tSystem.out.println(&quot;分组－按年纪分组&quot;);\n\t\tlist &#x3D; initList();\n\t\tMap&lt;Integer, List&lt;User&gt;&gt; userMap &#x3D; list.stream()\n\t\t\t\t.collect(Collectors.groupingBy(User::getAge));\n\t\tMapUtils.verbosePrint(System.out, null, userMap);\n\t\tSystem.out.println();\n\n\t\tSystem.out.println(&quot;创建－去重－统计&quot;);\n\t\tStream&lt;User&gt; userStream &#x3D; Stream\n\t\t\t\t.of(new User(&quot;u1&quot;, 1), new User(&quot;u2&quot;, 21), new User(&quot;u2&quot;, 21));\n\t\tSystem.out.println(userStream.distinct().count());\n\t\tSystem.out.println();\n\n\t&#125;\n\n\tpublic static List&lt;User&gt; initList() &#123;\n\t\tList&lt;User&gt; list &#x3D; new ArrayList&lt;&gt;();\n\t\tlist.add(new User(&quot;oaby&quot;, 23));\n\t\tlist.add(new User(&quot;tom&quot;, 11));\n\t\tlist.add(new User(&quot;john&quot;, 16));\n\t\tlist.add(new User(&quot;jennis&quot;, 26));\n\t\tlist.add(new User(&quot;tin&quot;, 26));\n\t\tlist.add(new User(&quot;army&quot;, 26));\n\t\tlist.add(new User(&quot;mack&quot;, 19));\n\t\tlist.add(new User(&quot;jobs&quot;, 65));\n\t\tlist.add(new User(&quot;jordan&quot;, 23));\n\t\treturn list;\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">过滤－找出年纪大于18岁的人\nUser [username&#x3D;oaby, age&#x3D;23]\nUser [username&#x3D;jennis, age&#x3D;26]\nUser [username&#x3D;tin, age&#x3D;26]\nUser [username&#x3D;army, age&#x3D;26]\nUser [username&#x3D;mack, age&#x3D;19]\nUser [username&#x3D;jobs, age&#x3D;65]\nUser [username&#x3D;jordan, age&#x3D;23]\n\n最大值－找出最大年纪的人\nUser [username&#x3D;jobs, age&#x3D;65]\n\n映射-规纳－求所有人的年纪总和\n235\n\n分组－按年纪分组\n&#123;\n    16 &#x3D; [User [username&#x3D;john, age&#x3D;16]]\n    65 &#x3D; [User [username&#x3D;jobs, age&#x3D;65]]\n    19 &#x3D; [User [username&#x3D;mack, age&#x3D;19]]\n    23 &#x3D; [User [username&#x3D;oaby, age&#x3D;23], User [username&#x3D;jordan, age&#x3D;23]]\n    26 &#x3D; [User [username&#x3D;jennis, age&#x3D;26], User [username&#x3D;tin, age&#x3D;26], User [username&#x3D;army, age&#x3D;26]]\n    11 &#x3D; [User [username&#x3D;tom, age&#x3D;11]]\n&#125;\n\n创建－去重－统计\n2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出流操作数据集合很强大吧，但需要注意的是流只能执行一次，再次使用需要重要打开。</p>\n<p>更多的玩法可以自己去研究吧。</p>\n","excerpt":"","more":"<h2 id=\"是什么是Stream流\"><a href=\"#是什么是Stream流\" class=\"headerlink\" title=\"是什么是Stream流\"></a>是什么是Stream流</h2><p><code>java.util.stream.Stream</code></p>\n<p>Stream流和传统的IO流，它们都叫流，却是两个完全不一样的概念和东西。</p>\n<p>流可以简单的说是处理数据集合的东西，可以申明式流式API来处理集合，而不是写一个逻辑实现。</p>\n<h2 id=\"流分类\"><a href=\"#流分类\" class=\"headerlink\" title=\"流分类\"></a>流分类</h2><p>流分为顺序流及并行流，顺序流即每个指令按顺序执行，并行流即集合里面的操作并行执行。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3);\n\n&#x2F;&#x2F;　顺序流\nnumbers.stream().forEach(n -&gt; System.out.print(n));\n\n&#x2F;&#x2F;并行流\nnumbers.parallelStream().forEach(n -&gt; System.out.print(n));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上例子，顺序流总是输出<code>123</code>，而并行流则每次结果都不一定，并行流使用了ForkJoinPool分而治之，所以明白了ForkJoinPool原理的同学就知道并行流的真面目了。</p>\n<h2 id=\"创建流\"><a href=\"#创建流\" class=\"headerlink\" title=\"创建流\"></a>创建流</h2><p>1、调用集合的stream()方法或者parallelStream()方法。</p>\n<p>2、Stream.of()方法，有针对int,long的专用流IntStream，LongStream。</p>\n<h2 id=\"使用流\"><a href=\"#使用流\" class=\"headerlink\" title=\"使用流\"></a>使用流</h2><p>以下举了流的一些常用的用法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class StreamTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tSystem.out.println(&quot;过滤－找出年纪大于18岁的人&quot;);\n\t\tList&lt;User&gt; list &#x3D; initList();\n\t\tlist.stream().filter((User user) -&gt; user.getAge() &gt; 18).collect(Collectors.toList())\n\t\t\t\t.forEach(System.out::println);\n\t\tSystem.out.println();\n\n\t\tSystem.out.println(&quot;最大值－找出最大年纪的人&quot;);\n\t\tlist &#x3D; initList();\n\t\tOptional&lt;User&gt; max &#x3D; list.stream().max((u1, u2) -&gt; u1.getAge() - u2.getAge());\n\t\tSystem.out.println(max.get());\n\t\tSystem.out.println();\n\n\t\tSystem.out.println(&quot;映射-规纳－求所有人的年纪总和&quot;);\n\t\tlist &#x3D; initList();\n\t\tOptional&lt;Integer&gt; reduce &#x3D; list.stream().map(User::getAge).reduce(Integer::sum);\n\t\tSystem.out.println(reduce.get());\n\t\tSystem.out.println();\n\n\t\tSystem.out.println(&quot;分组－按年纪分组&quot;);\n\t\tlist &#x3D; initList();\n\t\tMap&lt;Integer, List&lt;User&gt;&gt; userMap &#x3D; list.stream()\n\t\t\t\t.collect(Collectors.groupingBy(User::getAge));\n\t\tMapUtils.verbosePrint(System.out, null, userMap);\n\t\tSystem.out.println();\n\n\t\tSystem.out.println(&quot;创建－去重－统计&quot;);\n\t\tStream&lt;User&gt; userStream &#x3D; Stream\n\t\t\t\t.of(new User(&quot;u1&quot;, 1), new User(&quot;u2&quot;, 21), new User(&quot;u2&quot;, 21));\n\t\tSystem.out.println(userStream.distinct().count());\n\t\tSystem.out.println();\n\n\t&#125;\n\n\tpublic static List&lt;User&gt; initList() &#123;\n\t\tList&lt;User&gt; list &#x3D; new ArrayList&lt;&gt;();\n\t\tlist.add(new User(&quot;oaby&quot;, 23));\n\t\tlist.add(new User(&quot;tom&quot;, 11));\n\t\tlist.add(new User(&quot;john&quot;, 16));\n\t\tlist.add(new User(&quot;jennis&quot;, 26));\n\t\tlist.add(new User(&quot;tin&quot;, 26));\n\t\tlist.add(new User(&quot;army&quot;, 26));\n\t\tlist.add(new User(&quot;mack&quot;, 19));\n\t\tlist.add(new User(&quot;jobs&quot;, 65));\n\t\tlist.add(new User(&quot;jordan&quot;, 23));\n\t\treturn list;\n\t&#125;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>输出结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">过滤－找出年纪大于18岁的人\nUser [username&#x3D;oaby, age&#x3D;23]\nUser [username&#x3D;jennis, age&#x3D;26]\nUser [username&#x3D;tin, age&#x3D;26]\nUser [username&#x3D;army, age&#x3D;26]\nUser [username&#x3D;mack, age&#x3D;19]\nUser [username&#x3D;jobs, age&#x3D;65]\nUser [username&#x3D;jordan, age&#x3D;23]\n\n最大值－找出最大年纪的人\nUser [username&#x3D;jobs, age&#x3D;65]\n\n映射-规纳－求所有人的年纪总和\n235\n\n分组－按年纪分组\n&#123;\n    16 &#x3D; [User [username&#x3D;john, age&#x3D;16]]\n    65 &#x3D; [User [username&#x3D;jobs, age&#x3D;65]]\n    19 &#x3D; [User [username&#x3D;mack, age&#x3D;19]]\n    23 &#x3D; [User [username&#x3D;oaby, age&#x3D;23], User [username&#x3D;jordan, age&#x3D;23]]\n    26 &#x3D; [User [username&#x3D;jennis, age&#x3D;26], User [username&#x3D;tin, age&#x3D;26], User [username&#x3D;army, age&#x3D;26]]\n    11 &#x3D; [User [username&#x3D;tom, age&#x3D;11]]\n&#125;\n\n创建－去重－统计\n2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出流操作数据集合很强大吧，但需要注意的是流只能执行一次，再次使用需要重要打开。</p>\n<p>更多的玩法可以自己去研究吧。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmgsu07650001qkd4cw89bbnf","category_id":"cmgsu07690004qkd484knc1h0","_id":"cmgsu076d000fqkd4cey74bm6"},{"post_id":"cmgsu076c000dqkd47jvjh55h","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076f000lqkd47upqbjp3"},{"post_id":"cmgsu07680003qkd42iuygj9v","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076g000pqkd464rd3mng"},{"post_id":"cmgsu076d000eqkd4glyl48p9","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076g000sqkd4fuw6471l"},{"post_id":"cmgsu076e000iqkd4d2ck5ag5","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076h000xqkd40r37eyiv"},{"post_id":"cmgsu076a0007qkd413e6bn54","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076h0010qkd4fekqbg4u"},{"post_id":"cmgsu076f000kqkd40a0y7rel","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076i0014qkd4a5h347am"},{"post_id":"cmgsu076f000oqkd4cxjcdawn","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076i0017qkd4a8kggmvz"},{"post_id":"cmgsu076b0008qkd4ht4ig6e4","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076j001bqkd490oy0q10"},{"post_id":"cmgsu076g000rqkd4fvzra77j","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076j001eqkd48tnr33kk"},{"post_id":"cmgsu076g000wqkd417w28zfm","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076k001iqkd43ffe2xxx"},{"post_id":"cmgsu076c0009qkd4260v5ajm","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076k001lqkd47q4h2doh"},{"post_id":"cmgsu076h000zqkd4b9042yxp","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076l001pqkd4hol9emt6"},{"post_id":"cmgsu076h0013qkd42sjh4ej0","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076l001sqkd4a5aq6nb2"},{"post_id":"cmgsu076i0016qkd498g4cosa","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076m001wqkd4dlqwal1u"},{"post_id":"cmgsu076j001aqkd4f4878bo7","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076m001zqkd46j334scs"},{"post_id":"cmgsu076j001dqkd4d422aq8t","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076m0022qkd45wxdav9a"},{"post_id":"cmgsu076j001hqkd423ox8ra0","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076n0026qkd4batp13gn"},{"post_id":"cmgsu076k001kqkd44fgl9hlq","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076n0029qkd47187fcjq"},{"post_id":"cmgsu076k001oqkd47hvn1fd4","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076o002dqkd43iabf7s9"},{"post_id":"cmgsu076l001rqkd4e7k6bofk","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076o002gqkd4fs2m782f"},{"post_id":"cmgsu076l001vqkd4706abfkz","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076o002jqkd4heq1a5gf"},{"post_id":"cmgsu076m001yqkd4b6j17olg","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076q002mqkd4dlv6g8bs"},{"post_id":"cmgsu076m0021qkd431iqcc5g","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076q002pqkd43zdi7zur"},{"post_id":"cmgsu076n0025qkd40r4ecb2t","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076r002sqkd4h398givp"},{"post_id":"cmgsu076n0028qkd42e5y8lqn","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076r002vqkd48qk86rvy"},{"post_id":"cmgsu076n002cqkd48rqshy9n","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076s002yqkd44nqd3z8z"},{"post_id":"cmgsu076o002fqkd4blhv0iwh","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076s0031qkd47mavckjd"},{"post_id":"cmgsu076o002iqkd4296q7rb9","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076s0034qkd46j4c5cl0"},{"post_id":"cmgsu076p002lqkd437gr0xfm","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076t0037qkd46xj404by"},{"post_id":"cmgsu076q002oqkd411tz6n5b","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076t003aqkd442gq9895"},{"post_id":"cmgsu076r002rqkd42p0o7veo","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076t003eqkd4fyhr0tm7"},{"post_id":"cmgsu076r002uqkd4gvoxcw3r","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076u003hqkd4agkddda1"},{"post_id":"cmgsu076r002xqkd40why35oe","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076u003lqkd49fa16fp1"},{"post_id":"cmgsu076s0030qkd4f7mb7dqg","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076v003oqkd4fx89disu"},{"post_id":"cmgsu076s0033qkd4ddwdap0i","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076v003sqkd4gwc97w27"},{"post_id":"cmgsu076s0036qkd4h11xeyed","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076v003vqkd44hgvh0o8"},{"post_id":"cmgsu076t0039qkd43yqc2emq","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076w003yqkd4cqtd8vny"},{"post_id":"cmgsu076t003dqkd4alg39ec5","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076w0041qkd44w3gaatg"},{"post_id":"cmgsu076t003gqkd4fn3f1uhe","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076w0044qkd457aj0xzx"},{"post_id":"cmgsu076u003jqkd49t6tc10h","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076x0047qkd4flgn1uxe"},{"post_id":"cmgsu076u003nqkd48kavh4lg","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076x004aqkd4anox7m60"},{"post_id":"cmgsu076v003qqkd4cndjac5l","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076x004dqkd46e5ucogx"},{"post_id":"cmgsu076v003uqkd49gus83ml","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076y004gqkd4fpo56aog"},{"post_id":"cmgsu076v003xqkd4ajswdron","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076y004jqkd43xn61v02"},{"post_id":"cmgsu076w0040qkd45oqzaqxy","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076z004mqkd4bdqoev18"},{"post_id":"cmgsu076w0043qkd420r86rm2","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076z004pqkd4az4gdmf2"},{"post_id":"cmgsu076w0046qkd42f033a2v","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu076z004sqkd4bymne9lm"},{"post_id":"cmgsu076x0049qkd4954efqqm","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu0770004vqkd4hae67esa"},{"post_id":"cmgsu076x004cqkd4ez50c4c3","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu0771004zqkd4esb8d7io"},{"post_id":"cmgsu076y004fqkd4aol40svf","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu07710052qkd40c7f9yal"},{"post_id":"cmgsu076y004iqkd415ts7h45","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu07720056qkd41we912l5"},{"post_id":"cmgsu076y004lqkd494h1csj8","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu07730059qkd44lfx5xwt"},{"post_id":"cmgsu076z004oqkd4c1mr7a2v","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu0774005dqkd45dosg84y"},{"post_id":"cmgsu076z004rqkd4fpic9h04","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu0774005gqkd41mgx5dyd"},{"post_id":"cmgsu0770004uqkd4eb9b9k23","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu0775005jqkd45n1w4uw1"},{"post_id":"cmgsu0770004yqkd4gdt57lbu","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu0775005mqkd4ao1iejd2"},{"post_id":"cmgsu07710051qkd4az5ndksw","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu0775005pqkd4ah347qxk"},{"post_id":"cmgsu07710054qkd46z658v2m","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu0776005sqkd4hecq0pm6"},{"post_id":"cmgsu07720058qkd43z0c8xvf","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu0776005vqkd4cndk4qke"},{"post_id":"cmgsu0773005bqkd4boqfh6mo","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu0776005yqkd4aoqa6q1e"},{"post_id":"cmgsu0774005fqkd4eze9657b","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu07770061qkd433r74x4d"},{"post_id":"cmgsu0775005iqkd44ykeei73","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu07770064qkd46a5k42t3"},{"post_id":"cmgsu0775005lqkd4g5wg2nkh","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu07770067qkd4cxx725al"},{"post_id":"cmgsu0775005oqkd47g96fnmy","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu0778006aqkd43il8dpjq"},{"post_id":"cmgsu0776005rqkd4aqhv9mgk","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu0778006dqkd42udbahku"},{"post_id":"cmgsu0776005uqkd4b4172lae","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu0778006gqkd4bul14vj6"},{"post_id":"cmgsu0776005xqkd415qc4dkv","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu0779006jqkd4alkz9s5d"},{"post_id":"cmgsu07770060qkd42y7u2124","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu0779006mqkd4htfr3ord"},{"post_id":"cmgsu07770063qkd4ef5d5z3h","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu077a006pqkd4bnho8gun"},{"post_id":"cmgsu07770066qkd4giprgphe","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu077a006sqkd42vdwd1ug"},{"post_id":"cmgsu07770069qkd4ga92fel1","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu077a006vqkd4h6he8ied"},{"post_id":"cmgsu0778006cqkd47kih04u2","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu077b006yqkd4bp0nbq5e"},{"post_id":"cmgsu0778006fqkd4ae9z6hs8","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu077b0070qkd478ygbv1l"},{"post_id":"cmgsu0779006iqkd45sit7qro","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu077b0072qkd4fd2s61fh"},{"post_id":"cmgsu0779006lqkd4faqhax6o","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu077b0074qkd4fcas1jwh"},{"post_id":"cmgsu0779006oqkd418tq5mpd","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu077b0076qkd46m4p4vx0"},{"post_id":"cmgsu077a006rqkd4flbfd9t1","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu077b0078qkd41nai7pq8"},{"post_id":"cmgsu077a006uqkd4e06sgza9","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu077b007aqkd48v2r48xo"},{"post_id":"cmgsu077a006xqkd4ep8vcgtq","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu077b007cqkd43ez15kzu"},{"post_id":"cmgsu077b007dqkd42ibebwb4","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu077c007hqkd4ad7500vu"},{"post_id":"cmgsu077c007eqkd40oz0fsvq","category_id":"cmgsu076c000aqkd4csl5d6aa","_id":"cmgsu077c007iqkd43ntydyre"}],"PostTag":[{"post_id":"cmgsu07650001qkd4cw89bbnf","tag_id":"cmgsu076a0005qkd4hhyq8a6n","_id":"cmgsu076c000cqkd490oe7gin"},{"post_id":"cmgsu07680003qkd42iuygj9v","tag_id":"cmgsu076c000bqkd42e9qgyrj","_id":"cmgsu076e000jqkd458ebezo7"},{"post_id":"cmgsu076a0007qkd413e6bn54","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu076g000qqkd46ece7vtw"},{"post_id":"cmgsu076f000oqkd4cxjcdawn","tag_id":"cmgsu076f000nqkd4buey5n84","_id":"cmgsu076g000uqkd48hv2agot"},{"post_id":"cmgsu076b0008qkd4ht4ig6e4","tag_id":"cmgsu076f000nqkd4buey5n84","_id":"cmgsu076h000yqkd4ha2b71jb"},{"post_id":"cmgsu076g000rqkd4fvzra77j","tag_id":"cmgsu076f000nqkd4buey5n84","_id":"cmgsu076h0011qkd49ie52piw"},{"post_id":"cmgsu076g000wqkd417w28zfm","tag_id":"cmgsu076f000nqkd4buey5n84","_id":"cmgsu076i0015qkd42u2pf0ue"},{"post_id":"cmgsu076c0009qkd4260v5ajm","tag_id":"cmgsu076f000nqkd4buey5n84","_id":"cmgsu076i0018qkd412bf649u"},{"post_id":"cmgsu076h000zqkd4b9042yxp","tag_id":"cmgsu076f000nqkd4buey5n84","_id":"cmgsu076j001cqkd422tf9fd0"},{"post_id":"cmgsu076h0013qkd42sjh4ej0","tag_id":"cmgsu076f000nqkd4buey5n84","_id":"cmgsu076j001fqkd45s4ibnh8"},{"post_id":"cmgsu076c000dqkd47jvjh55h","tag_id":"cmgsu076f000nqkd4buey5n84","_id":"cmgsu076k001jqkd48vad10me"},{"post_id":"cmgsu076i0016qkd498g4cosa","tag_id":"cmgsu076f000nqkd4buey5n84","_id":"cmgsu076k001mqkd45oaca90y"},{"post_id":"cmgsu076j001aqkd4f4878bo7","tag_id":"cmgsu076f000nqkd4buey5n84","_id":"cmgsu076l001qqkd4e3zsckxt"},{"post_id":"cmgsu076d000eqkd4glyl48p9","tag_id":"cmgsu076f000nqkd4buey5n84","_id":"cmgsu076l001tqkd463zd7xmi"},{"post_id":"cmgsu076j001dqkd4d422aq8t","tag_id":"cmgsu076f000nqkd4buey5n84","_id":"cmgsu076m001xqkd49oxbe9ma"},{"post_id":"cmgsu076j001hqkd423ox8ra0","tag_id":"cmgsu076f000nqkd4buey5n84","_id":"cmgsu076m0020qkd4club09kd"},{"post_id":"cmgsu076e000iqkd4d2ck5ag5","tag_id":"cmgsu076f000nqkd4buey5n84","_id":"cmgsu076n0024qkd4bce762ux"},{"post_id":"cmgsu076k001kqkd44fgl9hlq","tag_id":"cmgsu076f000nqkd4buey5n84","_id":"cmgsu076n0027qkd460vd76xf"},{"post_id":"cmgsu076f000kqkd40a0y7rel","tag_id":"cmgsu076f000nqkd4buey5n84","_id":"cmgsu076n002bqkd407dq7von"},{"post_id":"cmgsu076m001yqkd4b6j17olg","tag_id":"cmgsu076l001uqkd4h1bfembx","_id":"cmgsu076o002eqkd49a9kf4cp"},{"post_id":"cmgsu076k001oqkd47hvn1fd4","tag_id":"cmgsu076l001uqkd4h1bfembx","_id":"cmgsu076o002hqkd46i25846r"},{"post_id":"cmgsu076m0021qkd431iqcc5g","tag_id":"cmgsu076l001uqkd4h1bfembx","_id":"cmgsu076p002kqkd4bj9t5b5w"},{"post_id":"cmgsu076n0025qkd40r4ecb2t","tag_id":"cmgsu076l001uqkd4h1bfembx","_id":"cmgsu076q002nqkd49d0802di"},{"post_id":"cmgsu076l001rqkd4e7k6bofk","tag_id":"cmgsu076l001uqkd4h1bfembx","_id":"cmgsu076r002qqkd4g3u6gnpf"},{"post_id":"cmgsu076n0028qkd42e5y8lqn","tag_id":"cmgsu076l001uqkd4h1bfembx","_id":"cmgsu076r002tqkd47zel83qt"},{"post_id":"cmgsu076n002cqkd48rqshy9n","tag_id":"cmgsu076l001uqkd4h1bfembx","_id":"cmgsu076r002wqkd421yodrbx"},{"post_id":"cmgsu076l001vqkd4706abfkz","tag_id":"cmgsu076l001uqkd4h1bfembx","_id":"cmgsu076s002zqkd484k66tdf"},{"post_id":"cmgsu076o002fqkd4blhv0iwh","tag_id":"cmgsu076l001uqkd4h1bfembx","_id":"cmgsu076s0032qkd4d85e2imo"},{"post_id":"cmgsu076o002iqkd4296q7rb9","tag_id":"cmgsu076l001uqkd4h1bfembx","_id":"cmgsu076s0035qkd4h1and37f"},{"post_id":"cmgsu076p002lqkd437gr0xfm","tag_id":"cmgsu076l001uqkd4h1bfembx","_id":"cmgsu076t0038qkd455h72eaz"},{"post_id":"cmgsu076q002oqkd411tz6n5b","tag_id":"cmgsu076l001uqkd4h1bfembx","_id":"cmgsu076t003cqkd41kt2h88s"},{"post_id":"cmgsu076r002rqkd42p0o7veo","tag_id":"cmgsu076l001uqkd4h1bfembx","_id":"cmgsu076t003fqkd44bhv8ze5"},{"post_id":"cmgsu076r002uqkd4gvoxcw3r","tag_id":"cmgsu076l001uqkd4h1bfembx","_id":"cmgsu076u003iqkd48hf097if"},{"post_id":"cmgsu076r002xqkd40why35oe","tag_id":"cmgsu076l001uqkd4h1bfembx","_id":"cmgsu076u003mqkd416rz258j"},{"post_id":"cmgsu076s0030qkd4f7mb7dqg","tag_id":"cmgsu076l001uqkd4h1bfembx","_id":"cmgsu076v003pqkd46ela1psx"},{"post_id":"cmgsu076s0033qkd4ddwdap0i","tag_id":"cmgsu076l001uqkd4h1bfembx","_id":"cmgsu076v003tqkd45yctaox0"},{"post_id":"cmgsu076s0036qkd4h11xeyed","tag_id":"cmgsu076t003bqkd46465c4ax","_id":"cmgsu076v003wqkd4hmqbd1h1"},{"post_id":"cmgsu076u003jqkd49t6tc10h","tag_id":"cmgsu076t003bqkd46465c4ax","_id":"cmgsu076w003zqkd4gtmc7bph"},{"post_id":"cmgsu076u003nqkd48kavh4lg","tag_id":"cmgsu076t003bqkd46465c4ax","_id":"cmgsu076w0042qkd48vk0e4l4"},{"post_id":"cmgsu076t0039qkd43yqc2emq","tag_id":"cmgsu076t003bqkd46465c4ax","_id":"cmgsu076w0045qkd4dx7v4sxv"},{"post_id":"cmgsu076v003qqkd4cndjac5l","tag_id":"cmgsu076t003bqkd46465c4ax","_id":"cmgsu076x0048qkd4b36bcrdg"},{"post_id":"cmgsu076v003uqkd49gus83ml","tag_id":"cmgsu076t003bqkd46465c4ax","_id":"cmgsu076x004bqkd441qnev5q"},{"post_id":"cmgsu076t003dqkd4alg39ec5","tag_id":"cmgsu076t003bqkd46465c4ax","_id":"cmgsu076x004eqkd48hgv2fn2"},{"post_id":"cmgsu076v003xqkd4ajswdron","tag_id":"cmgsu076t003bqkd46465c4ax","_id":"cmgsu076y004hqkd4gcrj2okf"},{"post_id":"cmgsu076w0040qkd45oqzaqxy","tag_id":"cmgsu076t003bqkd46465c4ax","_id":"cmgsu076y004kqkd41cf5ao13"},{"post_id":"cmgsu076w0043qkd420r86rm2","tag_id":"cmgsu076t003bqkd46465c4ax","_id":"cmgsu076z004nqkd4605q4kkl"},{"post_id":"cmgsu076w0046qkd42f033a2v","tag_id":"cmgsu076t003bqkd46465c4ax","_id":"cmgsu076z004qqkd43v9a497n"},{"post_id":"cmgsu076x0049qkd4954efqqm","tag_id":"cmgsu076t003bqkd46465c4ax","_id":"cmgsu0770004tqkd49hy60if8"},{"post_id":"cmgsu076x004cqkd4ez50c4c3","tag_id":"cmgsu076t003bqkd46465c4ax","_id":"cmgsu0770004xqkd42wivfd6z"},{"post_id":"cmgsu076y004fqkd4aol40svf","tag_id":"cmgsu076t003bqkd46465c4ax","_id":"cmgsu07710050qkd43bu2c46u"},{"post_id":"cmgsu076y004iqkd415ts7h45","tag_id":"cmgsu076t003bqkd46465c4ax","_id":"cmgsu07710053qkd4guskcx81"},{"post_id":"cmgsu076y004lqkd494h1csj8","tag_id":"cmgsu076t003bqkd46465c4ax","_id":"cmgsu07720057qkd4cy7m4xlz"},{"post_id":"cmgsu076z004oqkd4c1mr7a2v","tag_id":"cmgsu076t003bqkd46465c4ax","_id":"cmgsu0773005aqkd43w3vgrfc"},{"post_id":"cmgsu07710051qkd4az5ndksw","tag_id":"cmgsu0770004wqkd4guqbamtk","_id":"cmgsu0774005eqkd4cffk9vfs"},{"post_id":"cmgsu076z004rqkd4fpic9h04","tag_id":"cmgsu0770004wqkd4guqbamtk","_id":"cmgsu0775005hqkd4a752fe2l"},{"post_id":"cmgsu07710054qkd46z658v2m","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu0775005kqkd42xph3jt8"},{"post_id":"cmgsu07720058qkd43z0c8xvf","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu0775005nqkd45uys6uc0"},{"post_id":"cmgsu0770004uqkd4eb9b9k23","tag_id":"cmgsu0770004wqkd4guqbamtk","_id":"cmgsu0776005qqkd47pgl4us5"},{"post_id":"cmgsu0773005bqkd4boqfh6mo","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu0776005tqkd42x1c1l7z"},{"post_id":"cmgsu0774005fqkd4eze9657b","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu0776005wqkd4gpl1gbk2"},{"post_id":"cmgsu0770004yqkd4gdt57lbu","tag_id":"cmgsu0770004wqkd4guqbamtk","_id":"cmgsu0776005zqkd42o7m7aal"},{"post_id":"cmgsu0775005iqkd44ykeei73","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu07770062qkd4hxsz4wwy"},{"post_id":"cmgsu0775005lqkd4g5wg2nkh","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu07770065qkd40l4o17dy"},{"post_id":"cmgsu0775005oqkd47g96fnmy","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu07770068qkd4byad81o3"},{"post_id":"cmgsu0776005rqkd4aqhv9mgk","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu0778006bqkd4hoz73sfm"},{"post_id":"cmgsu0776005uqkd4b4172lae","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu0778006eqkd49ts8dqrv"},{"post_id":"cmgsu0776005xqkd415qc4dkv","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu0779006hqkd491m619rc"},{"post_id":"cmgsu07770060qkd42y7u2124","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu0779006kqkd40qdk7cgm"},{"post_id":"cmgsu07770063qkd4ef5d5z3h","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu0779006nqkd4bx3q8vim"},{"post_id":"cmgsu07770066qkd4giprgphe","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu077a006qqkd4c5rk1f0y"},{"post_id":"cmgsu07770069qkd4ga92fel1","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu077a006tqkd420dyafet"},{"post_id":"cmgsu0778006cqkd47kih04u2","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu077a006wqkd49b5b9h3l"},{"post_id":"cmgsu0778006fqkd4ae9z6hs8","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu077b006zqkd4cha0b44x"},{"post_id":"cmgsu0779006iqkd45sit7qro","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu077b0071qkd47ha7a1mb"},{"post_id":"cmgsu0779006lqkd4faqhax6o","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu077b0073qkd41ay17rqt"},{"post_id":"cmgsu0779006oqkd418tq5mpd","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu077b0075qkd43h5bdg8v"},{"post_id":"cmgsu077a006rqkd4flbfd9t1","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu077b0077qkd4357faucs"},{"post_id":"cmgsu077a006uqkd4e06sgza9","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu077b0079qkd4gwz6afm1"},{"post_id":"cmgsu077a006xqkd4ep8vcgtq","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu077b007bqkd4cg76crpo"},{"post_id":"cmgsu077b007dqkd42ibebwb4","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu077c007fqkd44aii2z8w"},{"post_id":"cmgsu077c007eqkd40oz0fsvq","tag_id":"cmgsu076d000hqkd44iz37joo","_id":"cmgsu077c007gqkd49ijh4vs7"}],"Tag":[{"name":"文章","_id":"cmgsu076a0005qkd4hhyq8a6n"},{"name":"JVM","_id":"cmgsu076c000bqkd42e9qgyrj"},{"name":"新特性","_id":"cmgsu076d000hqkd44iz37joo"},{"name":"进阶","_id":"cmgsu076f000nqkd4buey5n84"},{"name":"多线程","_id":"cmgsu076l001uqkd4h1bfembx"},{"name":"基础","_id":"cmgsu076t003bqkd46465c4ax"},{"name":"集合","_id":"cmgsu0770004wqkd4guqbamtk"}]}}