<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-集合/HashMap, ConcurrentHashMap 原理及源码" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/15/%E9%9B%86%E5%90%88/HashMap,%20ConcurrentHashMap%20%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81/" class="article-date">
  <time class="dt-published" datetime="2025-10-15T03:36:33.000Z" itemprop="datePublished">2025-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/15/%E9%9B%86%E5%90%88/HashMap,%20ConcurrentHashMap%20%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81/">HashMap, ConcurrentHashMap 原理及源码</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>网上关于 HashMap 和 ConcurrentHashMap 的文章确实不少，不过缺斤少两的文章比较多，所以才想自己也写一篇，把细节说清楚说透，尤其像 Java8 中的 ConcurrentHashMap，大部分文章都说不清楚。终归是希望能降低大家学习的成本，不希望大家到处找各种不是很靠谱的文章，看完一篇又一篇，可是还是模模糊糊。</p>
<p><strong>阅读建议：</strong> 四节基本上可以进行独立阅读，建议初学者可按照以下顺序进行阅读，可适当降低阅读门槛。</p>
<blockquote>
<p>Java7 HashMap -&gt; Java7 ConcurrentHashMap -&gt; Java8 HashMap -&gt; Java8 ConcurrentHashMap </p>
</blockquote>
<p><strong>阅读前提：</strong> 本文分析的是源码，所以至少读者要熟悉它们的接口使用，同时，对于并发，读者至少要知道 CAS、ReentrantLock、UNSAFE 操作这几个基本的知识，文中不会对这些知识进行介绍。Java8 用到了红黑树，不过本文不会进行展开，感兴趣的读者请自行查找相关资料。</p>
<h2 id="Java7-HashMap"><a href="#Java7-HashMap" class="headerlink" title="Java7 HashMap"></a>Java7 HashMap</h2><p>HashMap 是最简单的，一来我们非常熟悉，二来就是它不支持并发操作，所以源码也非常简单。</p>
<p>首先，我们用下面这张图来介绍 HashMap 的结构。</p>
<p><img src="http://qianniu.javastack.cn/18-12-4/65827660.jpg"></p>
<p>这个仅仅是示意图，因为没有考虑到数组要扩容的情况，具体的后面再说。</p>
<p>大方向上，HashMap 里面是一个<strong>数组</strong>，然后数组中每个元素是一个<strong>单向链表</strong>。</p>
<p>上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。</p>
<p>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</p>
<p>loadFactor：负载因子，默认为 0.75。</p>
<p>threshold：扩容的阈值，等于 capacity * loadFactor</p>
<h4 id="put-过程分析"><a href="#put-过程分析" class="headerlink" title="put 过程分析"></a>put 过程分析</h4><p>还是比较简单的，跟着代码走一遍吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    // 当插入第一个元素的时候，需要先初始化数组大小</span><br><span class="line">    if (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果 key 为 null，感兴趣的可以往里看，最终会将这个 entry 放到 table[0] 中</span><br><span class="line">    if (key == null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    // 1. 求 key 的 hash 值</span><br><span class="line">    int hash = hash(key);</span><br><span class="line">    // 2. 找到对应的数组下标</span><br><span class="line">    int i = indexFor(hash, table.length);</span><br><span class="line">    // 3. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在，</span><br><span class="line">    //    如果有，直接覆盖，put 方法返回旧值就结束了</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    modCount++;</span><br><span class="line">    // 4. 不存在重复的 key，将此 entry 添加到链表中，细节后面说</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h6><p>在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void inflateTable(int toSize) &#123;</span><br><span class="line">    // 保证数组大小一定是 2 的 n 次方。</span><br><span class="line">    // 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32</span><br><span class="line">    int capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">    // 计算扩容阈值：capacity * loadFactor</span><br><span class="line">    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">    // 算是初始化数组吧</span><br><span class="line">    table = new Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity); //ignore</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个将数组大小保持为 2 的 n 次方的做法，Java7 和 Java8 的 HashMap 和 ConcurrentHashMap 都有相应的要求，只不过实现的代码稍微有些不同，后面再看到的时候就知道了。</p>
<h6 id="计算具体数组位置"><a href="#计算具体数组位置" class="headerlink" title="计算具体数组位置"></a>计算具体数组位置</h6><p>这个简单，我们自己也能 YY 一个：使用 key 的 hash 值对数组长度进行取模就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static int indexFor(int hash, int length) &#123;</span><br><span class="line">    // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span><br><span class="line">    return hash &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。</p>
<h6 id="添加节点到链表中"><a href="#添加节点到链表中" class="headerlink" title="添加节点到链表中"></a>添加节点到链表中</h6><p>找到数组下标后，会先进行 key 判重，如果没有重复，就准备将新值放入到链表的表头。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    // 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容</span><br><span class="line">    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</span><br><span class="line">        // 扩容，后面会介绍一下</span><br><span class="line">        resize(2 * table.length);</span><br><span class="line">        // 扩容以后，重新计算 hash 值</span><br><span class="line">        hash = (null != key) ? hash(key) : 0;</span><br><span class="line">        // 重新计算扩容后的新的下标</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    // 往下看</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这个很简单，其实就是将新值放到链表的表头，然后 size++</span><br><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。</p>
<h6 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h6><p>前面我们看到，在插入新值的时候，如果当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    int oldCapacity = oldTable.length;</span><br><span class="line">    if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 新的数组</span><br><span class="line">    Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">    // 将原来数组中的值迁移到新的更大的数组中</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</p>
<p>由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。代码比较简单，这里就不展开了。</p>
<h4 id="get-过程分析"><a href="#get-过程分析" class="headerlink" title="get 过程分析"></a>get 过程分析</h4><p>相对于 put 过程，get 过程是非常简单的。</p>
<ol>
<li>根据 key 计算 hash 值。</li>
<li>找到相应的数组下标：hash &amp; (length – 1)。</li>
<li>遍历该数组位置处的链表，直到找到相等(&#x3D;&#x3D;或equals)的 key。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    // 之前说过，key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了</span><br><span class="line">    if (key == null)</span><br><span class="line">        return getForNullKey();</span><br><span class="line">    // </span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"> </span><br><span class="line">    return null == entry ? null : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getEntry(key):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">    if (size == 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    int hash = (key == null) ? 0 : hash(key);</span><br><span class="line">    // 确定数组下标，然后从头开始遍历链表，直到找到为止</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != null;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return e;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java7-ConcurrentHashMap"><a href="#Java7-ConcurrentHashMap" class="headerlink" title="Java7 ConcurrentHashMap"></a>Java7 ConcurrentHashMap</h2><p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。</p>
<p>整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为<strong>分段锁</strong>。注意，行文中，我很多地方用了 <strong>“槽”</strong> 来代表一个 segment。</p>
<p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。推荐阅读：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0CI9od4DIxRrmOGFJw0SuQ">史上最全 Java 多线程面试题及答案</a>。</p>
<p><img src="http://qianniu.javastack.cn/18-12-4/75121838.jpg"></p>
<p><strong>concurrencyLevel：</strong> 并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</p>
<p>再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。推荐阅读：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/5Y5_6qn2g6kIVmQia_0R6g">几种线程安全的Map解析</a>。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>initialCapacity：初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。</p>
<p>loadFactor：负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                         float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    // Find power-of-two sizes best matching arguments</span><br><span class="line">    int sshift = 0;</span><br><span class="line">    int ssize = 1;</span><br><span class="line">    // 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方</span><br><span class="line">    while (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4</span><br><span class="line">    // 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值</span><br><span class="line">    this.segmentShift = 32 - sshift;</span><br><span class="line">    this.segmentMask = ssize - 1;</span><br><span class="line"> </span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"> </span><br><span class="line">    // initialCapacity 是设置整个 map 初始的大小，</span><br><span class="line">    // 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小</span><br><span class="line">    // 如 initialCapacity 为 64，那么每个 Segment 或称之为&quot;槽&quot;可以分到 4 个</span><br><span class="line">    int c = initialCapacity / ssize;</span><br><span class="line">    if (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    // 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，</span><br><span class="line">    // 插入一个元素不至于扩容，插入第二个的时候才会扩容</span><br><span class="line">    int cap = MIN_SEGMENT_TABLE_CAPACITY; </span><br><span class="line">    while (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= 1;</span><br><span class="line"> </span><br><span class="line">    // 创建 Segment 数组，</span><br><span class="line">    // 并创建数组的第一个元素 segment[0]</span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];</span><br><span class="line">    // 往数组写入 segment[0]</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]</span><br><span class="line">    this.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化完成，我们得到了一个 Segment 数组。</p>
<p>我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后：</p>
<ul>
<li>Segment 数组长度为 16，不可以扩容</li>
<li>Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容</li>
<li>这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍</li>
<li>当前 segmentShift 的值为 32 – 4 &#x3D; 28，segmentMask 为 16 – 1 &#x3D; 15，姑且把它们简单翻译为移位数和掩码，这两个值马上就会用到。</li>
</ul>
<h4 id="put-过程分析-1"><a href="#put-过程分析-1" class="headerlink" title="put 过程分析"></a>put 过程分析</h4><p>我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    if (value == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    // 1. 计算 key 的 hash 值</span><br><span class="line">    int hash = hash(key);</span><br><span class="line">    // 2. 根据 hash 值找到 Segment 数组中的位置 j</span><br><span class="line">    //    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下低 4 位，</span><br><span class="line">    //    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的最后 4 位，也就是槽的数组下标</span><br><span class="line">    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    // 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，</span><br><span class="line">    // ensureSegment(j) 对 segment[j] 进行初始化</span><br><span class="line">    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck</span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment</span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    // 3. 插入新值到 槽 s 中</span><br><span class="line">    return s.put(key, hash, value, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。</p>
<p>Segment 内部是由 <strong>数组+链表</strong> 组成的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    // 在往该 segment 写入前，需要先获取该 segment 的独占锁</span><br><span class="line">    //    先看主流程，后面还会具体介绍这部分内容</span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? null :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 这个是 segment 内部的数组</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        // 再利用 hash 值，求应该放置的数组下标</span><br><span class="line">        int index = (tab.length - 1) &amp; hash;</span><br><span class="line">        // first 是数组该位置处的链表的表头</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line"> </span><br><span class="line">        // 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            if (e != null) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                if ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    if (!onlyIfAbsent) &#123;</span><br><span class="line">                        // 覆盖旧值</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // 继续顺着链表走</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                // node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。</span><br><span class="line">                // 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。</span><br><span class="line">                if (node != null)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                else</span><br><span class="line">                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line"> </span><br><span class="line">                int c = count + 1;</span><br><span class="line">                // 如果超过了该 segment 的阈值，这个 segment 需要扩容</span><br><span class="line">                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node); // 扩容后面也会具体分析</span><br><span class="line">                else</span><br><span class="line">                    // 没有达到阈值，将 node 放到数组 tab 的 index 位置，</span><br><span class="line">                    // 其实就是将新的节点设置成原链表的表头</span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = null;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 解锁</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。</p>
<p>到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。</p>
<h6 id="初始化槽-ensureSegment"><a href="#初始化槽-ensureSegment" class="headerlink" title="初始化槽: ensureSegment"></a>初始化槽: ensureSegment</h6><p>ConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。</p>
<p>这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private Segment&lt;K,V&gt; ensureSegment(int k) &#123;</span><br><span class="line">    final Segment&lt;K,V&gt;[] ss = this.segments;</span><br><span class="line">    long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset</span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) &#123;</span><br><span class="line">        // 这里看到为什么之前要初始化 segment[0] 了，</span><br><span class="line">        // 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]</span><br><span class="line">        // 为什么要用“当前”，因为 segment[0] 可能早就扩容过了</span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[0];</span><br><span class="line">        int cap = proto.table.length;</span><br><span class="line">        float lf = proto.loadFactor;</span><br><span class="line">        int threshold = (int)(cap * lf);</span><br><span class="line"> </span><br><span class="line">        // 初始化 segment[k] 内部的数组</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap];</span><br><span class="line">        if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">            == null) &#123; // 再次检查一遍该槽是否被其他线程初始化了。</span><br><span class="line"> </span><br><span class="line">            Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            // 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出</span><br><span class="line">            while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == null) &#123;</span><br><span class="line">                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。</p>
<blockquote>
<p>如果当前线程 CAS 失败，这里的 while 循环是为了将 seg 赋值返回。</p>
</blockquote>
<h6 id="获取写入锁-scanAndLockForPut"><a href="#获取写入锁-scanAndLockForPut" class="headerlink" title="获取写入锁: scanAndLockForPut"></a>获取写入锁: scanAndLockForPut</h6><p>前面我们看到，在往某个 segment 中 put 的时候，首先会调用 node &#x3D; tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。</p>
<p>下面我们来具体分析这个方法中是怎么控制加锁的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = null;</span><br><span class="line">    int retries = -1; // negative while locating node</span><br><span class="line"> </span><br><span class="line">    // 循环获取锁</span><br><span class="line">    while (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; // to recheck first below</span><br><span class="line">        if (retries &lt; 0) &#123;</span><br><span class="line">            if (e == null) &#123;</span><br><span class="line">                if (node == null) // speculatively create node</span><br><span class="line">                    // 进到这里说明数组该位置的链表是空的，没有任何元素</span><br><span class="line">                    // 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置</span><br><span class="line">                    node = new HashEntry&lt;K,V&gt;(hash, key, value, null);</span><br><span class="line">                retries = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (key.equals(e.key))</span><br><span class="line">                retries = 0;</span><br><span class="line">            else</span><br><span class="line">                // 顺着链表往下走</span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 重试次数如果超过 MAX_SCAN_RETRIES（单核1多核64），那么不抢了，进入到阻塞队列等待锁</span><br><span class="line">        //    lock() 是阻塞方法，直到获取锁后返回</span><br><span class="line">        else if (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((retries &amp; 1) == 0 &amp;&amp;</span><br><span class="line">                 // 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头</span><br><span class="line">                 //     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法</span><br><span class="line">                 (f = entryForHash(this, hash)) != first) &#123;</span><br><span class="line">            e = first = f; // re-traverse if entry changed</span><br><span class="line">            retries = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。</p>
<p>这个方法就是看似复杂，但是其实就是做了一件事，那就是<strong>获取该 segment 的独占锁</strong>，如果需要的话顺便实例化了一下 node。</p>
<h6 id="扩容-rehash"><a href="#扩容-rehash" class="headerlink" title="扩容: rehash"></a>扩容: rehash</h6><p>重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry[] 进行扩容，扩容后，容量为原来的 2 倍。</p>
<p>首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。</p>
<p>该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。</span><br><span class="line">private void rehash(HashEntry&lt;K,V&gt; node) &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    int oldCapacity = oldTable.length;</span><br><span class="line">    // 2 倍</span><br><span class="line">    int newCapacity = oldCapacity &lt;&lt; 1;</span><br><span class="line">    threshold = (int)(newCapacity * loadFactor);</span><br><span class="line">    // 创建新数组</span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];</span><br><span class="line">    // 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’</span><br><span class="line">    int sizeMask = newCapacity - 1;</span><br><span class="line"> </span><br><span class="line">    // 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置</span><br><span class="line">    for (int i = 0; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        // e 是链表的第一个元素</span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            // 计算应该放置在新数组中的位置，</span><br><span class="line">            // 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19</span><br><span class="line">            int idx = e.hash &amp; sizeMask;</span><br><span class="line">            if (next == null)   // 该位置处只有一个元素，那比较好办</span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            else &#123; // Reuse consecutive sequence at same slot</span><br><span class="line">                // e 是链表表头</span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                // idx 是当前链表的头结点 e 的新位置</span><br><span class="line">                int lastIdx = idx;</span><br><span class="line"> </span><br><span class="line">                // 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的</span><br><span class="line">                for (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != null;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    int k = last.hash &amp; sizeMask;</span><br><span class="line">                    if (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置</span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                // 下面的操作是处理 lastRun 之前的节点，</span><br><span class="line">                //    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中</span><br><span class="line">                for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    int h = p.hash;</span><br><span class="line">                    int k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部</span><br><span class="line">    int nodeIndex = node.hash &amp; sizeMask; // add the new node</span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢？</p>
<p>仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。</p>
<p>我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。<strong>不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1&#x2F;6 的节点需要克隆。</strong></p>
<h4 id="get-过程分析-1"><a href="#get-过程分析-1" class="headerlink" title="get 过程分析"></a>get 过程分析</h4><p>相对于 put 来说，get 真的不要太简单。</p>
<ol>
<li>计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”</li>
<li>槽中也是一个数组，根据 hash 找到数组中具体的位置</li>
<li>到这里是链表了，顺着链表进行查找即可</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead</span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    // 1. hash 值</span><br><span class="line">    int h = hash(key);</span><br><span class="line">    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    // 2. 根据 hash 找到对应的 segment</span><br><span class="line">    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;</span><br><span class="line">        (tab = s.table) != null) &#123;</span><br><span class="line">        // 3. 找到segment 内部数组相应位置的链表，遍历</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != null; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                return e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="并发问题分析"><a href="#并发问题分析" class="headerlink" title="并发问题分析"></a>并发问题分析</h4><p>现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。</p>
<p>添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。推荐阅读：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Q5F604CUM_0x2co9mvADxw">30 个 Java 集合面试问题及答案</a>。</p>
<ul>
<li><strong>put 操作的线程安全性</strong></li>
</ul>
<ol>
<li>初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。</li>
<li>添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。</li>
<li>扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。</li>
</ol>
<ul>
<li><strong>remove 操作的线程安全性</strong></li>
</ul>
<p>remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。</p>
<p>get 操作需要遍历链表，但是 remove 操作会”破坏”链表。</p>
<p>如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。</p>
<p>如果 remove 先破坏了一个节点，分两种情况考虑。</p>
<p>1、如果此节点是头结点，那么需要将头结点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。</p>
<p>2、如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。推荐阅读：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0CI9od4DIxRrmOGFJw0SuQ">史上最全 Java 多线程面试题及答案</a>。</p>
<h2 id="Java8-HashMap"><a href="#Java8-HashMap" class="headerlink" title="Java8 HashMap"></a>Java8 HashMap</h2><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 <strong>数组+链表+红黑树</strong> 组成。</p>
<p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 **O(n)**。</p>
<p>为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p>
<p>来一张图简单示意一下吧：</p>
<p><img src="http://qianniu.javastack.cn/18-12-4/75398751.jpg"></p>
<blockquote>
<p>注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。</p>
</blockquote>
<p>下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。</p>
<p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 <strong>Node</strong>，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 <strong>TreeNode</strong>。</p>
<p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。推荐阅读：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Q5F604CUM_0x2co9mvADxw">30 个 Java 集合面试问题及答案</a>。</p>
<h4 id="put-过程分析-2"><a href="#put-过程分析-2" class="headerlink" title="put 过程分析"></a>put 过程分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span><br><span class="line">// 第四个参数 evict 我们这里不关心</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    // 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度</span><br><span class="line">    // 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    // 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line"> </span><br><span class="line">    else &#123;// 数组该位置有数据</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        // 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        // 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            // 到这里，说明数组该位置上是一个链表</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                // 插入到链表的最后面(Java7 是插入到链表的最前面)</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    // TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 9 个</span><br><span class="line">                    // 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // 如果在该链表中找到了&quot;相等&quot;的 key(== 或 equals)</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    // 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // e!=null 说明存在旧值的key与要插入的key&quot;相等&quot;</span><br><span class="line">        // 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    // 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。</p>
<h6 id="数组扩容-1"><a href="#数组扩容-1" class="headerlink" title="数组扩容"></a>数组扩容</h6><p>resize() 方法用于<strong>初始化数组或数组扩容</strong>，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123; // 对应数组扩容</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        // 将数组大小扩大一倍</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            // 将阈值扩大一倍</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) // 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123;// 对应使用 new HashMap() 初始化后，第一次 put 的时候</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"> </span><br><span class="line">    // 用新的数组大小初始化新的数组</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab; // 如果是初始化数组，到这里就结束了，返回 newTab 即可</span><br><span class="line"> </span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        // 开始遍历原数组，进行数据迁移。</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                // 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                // 如果是红黑树，具体我们就不展开了</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; </span><br><span class="line">                    // 这块是处理链表的情况，</span><br><span class="line">                    // 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span><br><span class="line">                    // loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        // 第一条链表</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        // 第二条链表的新的位置是 j + oldCap，这个很好理解</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="get-过程分析-2"><a href="#get-过程分析-2" class="headerlink" title="get 过程分析"></a>get 过程分析</h4><p>相对于 put 来说，get 真的太简单了。</p>
<ol>
<li>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</li>
<li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</li>
<li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</li>
<li>遍历链表，直到找到相等(&#x3D;&#x3D;或equals)的 key.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        // 判断第一个节点是不是就是需要的</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">            // 判断是否是红黑树</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"> </span><br><span class="line">            // 链表遍历</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java8-ConcurrentHashMap"><a href="#Java8-ConcurrentHashMap" class="headerlink" title="Java8 ConcurrentHashMap"></a>Java8 ConcurrentHashMap</h2><p>Java7 中实现的 ConcurrentHashMap 说实话还是比较复杂的，Java8 对 ConcurrentHashMap 进行了比较大的改动。建议读者可以参考 Java8 中 HashMap 相对于 Java7 HashMap 的改动，对于 ConcurrentHashMap，Java8 也引入了红黑树。</p>
<p>说实话，Java8 ConcurrentHashMap 源码真心不简单，最难的在于扩容，数据迁移操作不容易看懂。</p>
<p>我们先用一个示意图来描述下其结构：</p>
<p><img src="http://qianniu.javastack.cn/18-12-4/335817.jpg"></p>
<p>结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。推荐阅读：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/5Y5_6qn2g6kIVmQia_0R6g">几种线程安全的Map解析</a>。</p>
<h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 这构造函数里，什么都不干</span><br><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">&#125;</span><br><span class="line">public ConcurrentHashMap(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));</span><br><span class="line">    this.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl &#x3D; 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。</p>
<p>sizeCtl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。</p>
<p>如果你爱折腾，也可以看下另一个有三个参数的构造方法，这里我就不说了，大部分时候，我们会使用无参构造函数进行实例化，我们也按照这个思路来进行源码分析吧。</p>
<h4 id="put-过程分析-3"><a href="#put-过程分析-3" class="headerlink" title="put 过程分析"></a>put 过程分析</h4><p>仔细地一行一行代码看下去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(key, value, false);</span><br><span class="line">&#125;</span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">    // 得到 hash 值</span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line">    // 用于记录相应链表的长度</span><br><span class="line">    int binCount = 0;</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        // 如果数组&quot;空&quot;，进行数组初始化</span><br><span class="line">        if (tab == null || (n = tab.length) == 0)</span><br><span class="line">            // 初始化数组，后面会详细介绍</span><br><span class="line">            tab = initTable();</span><br><span class="line"> </span><br><span class="line">        // 找该 hash 值对应的数组下标，得到第一个节点 f</span><br><span class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">            // 如果数组该位置为空，</span><br><span class="line">            //    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了</span><br><span class="line">            //          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了</span><br><span class="line">            if (casTabAt(tab, i, null,</span><br><span class="line">                         new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                break;                   // no lock when adding to empty bin</span><br><span class="line">        &#125;</span><br><span class="line">        // hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            // 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"> </span><br><span class="line">        else &#123; // 到这里就是说，f 是该位置的头结点，而且不为空</span><br><span class="line"> </span><br><span class="line">            V oldVal = null;</span><br><span class="line">            // 获取数组该位置的头结点的监视器锁</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    if (fh &gt;= 0) &#123; // 头结点的 hash 值大于 0，说明是链表</span><br><span class="line">                        // 用于累加，记录链表的长度</span><br><span class="line">                        binCount = 1;</span><br><span class="line">                        // 遍历链表</span><br><span class="line">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            // 如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了</span><br><span class="line">                            if (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            // 到了链表的最末端，将这个新值放到链表的最后面</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            if ((e = e.next) == null) &#123;</span><br><span class="line">                                pred.next = new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (f instanceof TreeBin) &#123; // 红黑树</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = 2;</span><br><span class="line">                        // 调用红黑树的插值方法插入新节点</span><br><span class="line">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != null) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            if (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // binCount != 0 说明上面在做链表操作</span><br><span class="line">            if (binCount != 0) &#123;</span><br><span class="line">                // 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8</span><br><span class="line">                if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    // 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，</span><br><span class="line">                    // 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span><br><span class="line">                    //    具体源码我们就不看了，扩容部分后面说</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                if (oldVal != null)</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // </span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put 的主流程看完了，但是至少留下了几个问题，第一个是初始化，第二个是扩容，第三个是帮助数据迁移，这些我们都会在后面进行一一介绍。</p>
<h6 id="初始化数组：initTable"><a href="#初始化数组：initTable" class="headerlink" title="初始化数组：initTable"></a>初始化数组：initTable</h6><p>这个比较简单，主要就是初始化一个合适大小的数组，然后会设置 sizeCtl。</p>
<p>初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">    while ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">        // 初始化的&quot;功劳&quot;被其他线程&quot;抢去&quot;了</span><br><span class="line">        if ((sc = sizeCtl) &lt; 0)</span><br><span class="line">            Thread.yield(); // lost initialization race; just spin</span><br><span class="line">        // CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁</span><br><span class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">                    // DEFAULT_CAPACITY 默认初始容量是 16</span><br><span class="line">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    // 初始化数组，长度为 16 或初始化时提供的长度</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                    // 将这个数组赋值给 table，table 是 volatile 的</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    // 如果 n 为 16 的话，那么这里 sc = 12</span><br><span class="line">                    // 其实就是 0.75 * n</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 设置 sizeCtl 为 sc，我们就当是 12 吧</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="链表转红黑树-treeifyBin"><a href="#链表转红黑树-treeifyBin" class="headerlink" title="链表转红黑树: treeifyBin"></a>链表转红黑树: treeifyBin</h6><p>前面我们在 put 源码分析也说过，treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;</span><br><span class="line">    Node&lt;K,V&gt; b; int n, sc;</span><br><span class="line">    if (tab != null) &#123;</span><br><span class="line">        // MIN_TREEIFY_CAPACITY 为 64</span><br><span class="line">        // 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容</span><br><span class="line">        if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            // 后面我们再详细分析这个方法</span><br><span class="line">            tryPresize(n &lt;&lt; 1);</span><br><span class="line">        // b 是头结点</span><br><span class="line">        else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123;</span><br><span class="line">            // 加锁</span><br><span class="line">            synchronized (b) &#123;</span><br><span class="line"> </span><br><span class="line">                if (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    // 下面就是遍历链表，建立一颗红黑树</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">                    for (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              null, null);</span><br><span class="line">                        if ((p.prev = tl) == null)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        else</span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 将红黑树设置到数组相应位置中</span><br><span class="line">                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="扩容：tryPresize"><a href="#扩容：tryPresize" class="headerlink" title="扩容：tryPresize"></a>扩容：tryPresize</h4><p>如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。</p>
<p>这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。</p>
<p>这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了</span><br><span class="line">private final void tryPresize(int size) &#123;</span><br><span class="line">    // c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。</span><br><span class="line">    int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);</span><br><span class="line">    int sc;</span><br><span class="line">    while ((sc = sizeCtl) &gt;= 0) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; int n;</span><br><span class="line"> </span><br><span class="line">        // 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码</span><br><span class="line">        if (tab == null || (n = tab.length) == 0) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (table == tab) &#123;</span><br><span class="line">                        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; 2); // 0.75 * n</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            break;</span><br><span class="line">        else if (tab == table) &#123;</span><br><span class="line">            // 我没看懂 rs 的真正含义是什么，不过也关系不大</span><br><span class="line">            int rs = resizeStamp(n);</span><br><span class="line"> </span><br><span class="line">            if (sc &lt; 0) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</span><br><span class="line">                    transferIndex &lt;= 0)</span><br><span class="line">                    break;</span><br><span class="line">                // 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法</span><br><span class="line">                //    此时 nextTab 不为 null</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            // 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span><br><span class="line">            //     我是没看懂这个值真正的意义是什么？不过可以计算出来的是，结果是一个比较大的负数</span><br><span class="line">            //  调用 transfer 方法，此时 nextTab 参数为 null</span><br><span class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                transfer(tab, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。</p>
<p>所以，可能的操作就是执行 **1 次 transfer(tab, null) + 多次 transfer(tab, nt)**，这里怎么结束循环的需要看完 transfer 源码才清楚。推荐阅读：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Q5F604CUM_0x2co9mvADxw">30 个 Java 集合面试问题及答案</a>。</p>
<h6 id="数据迁移：transfer"><a href="#数据迁移：transfer" class="headerlink" title="数据迁移：transfer"></a>数据迁移：transfer</h6><p>下面这个方法很点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。</p>
<p>虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。</p>
<p>此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。</p>
<p>阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 stride，简单理解就是步长，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。</p>
<p>第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后从后往前的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">    int n = tab.length, stride;</span><br><span class="line"> </span><br><span class="line">    // stride 在单核下直接等于 n，多核模式下为 (n&gt;&gt;&gt;3)/NCPU，最小值是 16</span><br><span class="line">    // stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，</span><br><span class="line">    //   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务</span><br><span class="line">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; // subdivide range</span><br><span class="line"> </span><br><span class="line">    // 如果 nextTab 为 null，先进行一次初始化</span><br><span class="line">    //    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null</span><br><span class="line">    //       之后参与迁移的线程调用此方法时，nextTab 不会为 null</span><br><span class="line">    if (nextTab == null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 容量翻倍</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; catch (Throwable ex) &#123;      // try to cope with OOME</span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // nextTable 是 ConcurrentHashMap 中的属性</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        // transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    int nextn = nextTab.length;</span><br><span class="line"> </span><br><span class="line">    // ForwardingNode 翻译过来就是正在被迁移的 Node</span><br><span class="line">    // 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED</span><br><span class="line">    // 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，</span><br><span class="line">    //    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了</span><br><span class="line">    //    所以它其实相当于是一个标志。</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    // advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了</span><br><span class="line">    boolean advance = true;</span><br><span class="line">    boolean finishing = false; // to ensure sweep before committing nextTab</span><br><span class="line"> </span><br><span class="line">    /*</span><br><span class="line">     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line"> </span><br><span class="line">    // i 是位置索引，bound 是边界，注意是从后往前</span><br><span class="line">    for (int i = 0, bound = 0;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int fh;</span><br><span class="line"> </span><br><span class="line">        // 下面这个 while 真的是不好理解</span><br><span class="line">        // advance 为 true 表示可以进行下一个位置的迁移了</span><br><span class="line">        //   简单理解结局：i 指向了 transferIndex，bound 指向了 transferIndex-stride</span><br><span class="line">        while (advance) &#123;</span><br><span class="line">            int nextIndex, nextBound;</span><br><span class="line">            if (--i &gt;= bound || finishing)</span><br><span class="line">                advance = false;</span><br><span class="line"> </span><br><span class="line">            // 将 transferIndex 值赋给 nextIndex</span><br><span class="line">            // 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了</span><br><span class="line">            else if ((nextIndex = transferIndex) &lt;= 0) &#123;</span><br><span class="line">                i = -1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (U.compareAndSwapInt</span><br><span class="line">                     (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : 0))) &#123;</span><br><span class="line">                // 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - 1;</span><br><span class="line">                advance = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            int sc;</span><br><span class="line">            if (finishing) &#123;</span><br><span class="line">                // 所有的迁移操作已经完成</span><br><span class="line">                nextTable = null;</span><br><span class="line">                // 将新的 nextTab 赋值给 table 属性，完成迁移</span><br><span class="line">                table = nextTab;</span><br><span class="line">                // 重新计算 sizeCtl：n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍</span><br><span class="line">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            // 之前我们说过，sizeCtl 在迁移前会设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</span><br><span class="line">            // 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，</span><br><span class="line">            // 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</span><br><span class="line">                // 任务结束，方法退出</span><br><span class="line">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    return;</span><br><span class="line"> </span><br><span class="line">                // 到这里，说明 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，</span><br><span class="line">                // 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing)&#123;&#125; 分支了</span><br><span class="line">                finishing = advance = true;</span><br><span class="line">                i = n; // recheck before commit</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“</span><br><span class="line">        else if ((f = tabAt(tab, i)) == null)</span><br><span class="line">            advance = casTabAt(tab, i, null, fwd);</span><br><span class="line">        // 该位置处是一个 ForwardingNode，代表该位置已经迁移过了</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = true; // already processed</span><br><span class="line">        else &#123;</span><br><span class="line">            // 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    // 头结点的 hash 大于 0，说明是链表的 Node 节点</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        // 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，</span><br><span class="line">                        // 需要将链表一分为二，</span><br><span class="line">                        //   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的</span><br><span class="line">                        //   lastRun 之前的节点需要进行克隆，然后分到两个链表中</span><br><span class="line">                        int runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</span><br><span class="line">                            int b = p.hash &amp; n;</span><br><span class="line">                            if (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (runBit == 0) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            int ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            if ((ph &amp; n) == 0)</span><br><span class="line">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            else</span><br><span class="line">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 其中的一个链表放在新数组的位置 i</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        // 另一个链表放在新数组的位置 i+n</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        // 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span><br><span class="line">                        //    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        // advance 设置为 true，代表该位置已经迁移完毕</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        // 红黑树的迁移</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = null, loTail = null;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;</span><br><span class="line">                        int lc = 0, hc = 0;</span><br><span class="line">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;</span><br><span class="line">                            int h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, null, null);</span><br><span class="line">                            if ((h &amp; n) == 0) &#123;</span><br><span class="line">                                if ((p.prev = loTail) == null)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if ((p.prev = hiTail) == null)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 如果一分为二后，节点数少于 8，那么将红黑树转换回链表</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line"> </span><br><span class="line">                        // 将 ln 放置在新数组的位置 i</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        // 将 hn 放置在新数组的位置 i+n</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        // 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span><br><span class="line">                        //    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        // advance 设置为 true，代表该位置已经迁移完毕</span><br><span class="line">                        advance = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。</p>
<p>这个时候，再回去仔细看 tryPresize 方法可能就会更加清晰一些了。</p>
<h4 id="get-过程分析-3"><a href="#get-过程分析-3" class="headerlink" title="get 过程分析"></a>get 过程分析</h4><p>get 方法从来都是最简单的，这里也不例外：</p>
<p>1.计算 hash 值</p>
<p>2.根据 hash 值找到数组对应位置: (n – 1) &amp; h</p>
<p>3.根据该位置处结点性质进行相应查找</p>
<ul>
<li>如果该位置为 null，那么直接返回 null 就可以了</li>
<li>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</li>
<li>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法</li>
<li>如果以上 3 条都不满足，那就是链表，进行遍历比对即可。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">    int h = spread(key.hashCode());</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</span><br><span class="line">        // 判断头结点是否就是我们需要的节点</span><br><span class="line">        if ((eh = e.hash) == h) &#123;</span><br><span class="line">            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span><br><span class="line">        else if (eh &lt; 0)</span><br><span class="line">            // 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span><br><span class="line">            return (p = e.find(h, key)) != null ? p.val : null;</span><br><span class="line"> </span><br><span class="line">        // 遍历链表</span><br><span class="line">        while ((e = e.next) != null) &#123;</span><br><span class="line">            if (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，ForwardingNode.find(int h, Object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了，所以限于篇幅这里也不展开说了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实也不是很难嘛，虽然没有像之前的 AQS 和线程池一样一行一行源码进行分析，但还是把所有初学者可能会糊涂的地方都进行了深入的介绍，只要是稍微有点基础的读者，应该是很容易就能看懂 HashMap 和 ConcurrentHashMap 源码了。</p>
<p>看源码不算是目的吧，深入地了解 Doug Lea 的设计思路，我觉得还挺有趣的，大师就是大师，代码写得真的是好啊。</p>
<p>我发现很多人都以为我写博客主要是源码分析，说真的，我对于源码分析没有那么大热情，主要都是为了用源码说事罢了，可能之后的文章还是会有比较多的源码分析成分，大家该怎么看就怎么看吧。</p>
<p>不要脸地自以为本文的质量还是挺高的，信息量比较大，如果你觉得有写得不好的地方，或者说看完本文你还是没看懂它们，那么请提出来~~~</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/15/%E9%9B%86%E5%90%88/HashMap,%20ConcurrentHashMap%20%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81/" data-id="cmgrfxxdb003c30d4caq08vvk" data-title="HashMap, ConcurrentHashMap 原理及源码" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9B%86%E5%90%88/" rel="tag">集合</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-新特性/Java10/Java 10 局部变量类型推断介绍及实战" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java10/Java%2010%20%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9E%E6%88%98/" class="article-date">
  <time class="dt-published" datetime="2025-10-15T03:36:33.000Z" itemprop="datePublished">2025-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java10/Java%2010%20%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9E%E6%88%98/">Java 10 局部变量类型推断介绍及实战</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>现在 Java 9 被遗弃了直接升级到了 Java 10，之前也发过 Java 10 新特性的文章，现在是开始实战 Java 10 的时候了。</p>
<p>今天要实战的是 Java 10 中最重要的特性：局部变量类型推断，大家都知道是 <code>var</code> 关键字，但具体怎么使用，及要注意什么要点呢？</p>
<p>我们通过几个例子来讲解局部变量类型推断这个新特性！</p>
<h3 id="什么是局部变量类型推断"><a href="#什么是局部变量类型推断" class="headerlink" title="什么是局部变量类型推断"></a>什么是局部变量类型推断</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var javastack = &quot;javastack&quot;;</span><br><span class="line">System.out.println(javastack);</span><br></pre></td></tr></table></figure>

<p>大家看出来了，局部变量类型推断就是左边的类型直接使用 <code>var</code> 定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型，如上面的 <code>String</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var javastack = &quot;javastack&quot;;</span><br></pre></td></tr></table></figure>

<p>就等于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String javastack = &quot;javastack&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="局部变量类型推断使用示例"><a href="#局部变量类型推断使用示例" class="headerlink" title="局部变量类型推断使用示例"></a>局部变量类型推断使用示例</h3><p>既然叫局部变量类型推断，以只能用在局部变量中，下面给出更多使用示例。</p>
<p><strong>1、字面量定义局部变量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static void testVar() &#123;</span><br><span class="line">	var javastack = &quot;javastack&quot;;</span><br><span class="line">	System.out.println(javastack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、接收方法返回值定义局部变量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static void testMethod() &#123;</span><br><span class="line">	var javastack = getJavastack();</span><br><span class="line">	System.out.println(javastack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String getJavastack() &#123;</span><br><span class="line">	return &quot;javastack&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、循环中定义局部变量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static void testLoop() &#123;</span><br><span class="line">	for (var i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">		for (var m = 10; m &lt; 15; m++) &#123;</span><br><span class="line">			System.out.println(i + m);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4、泛型结合局部变量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static void testGeneric() &#123;</span><br><span class="line">	// 表达式1</span><br><span class="line">	List&lt;String&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">	list1.add(&quot;javastack&quot;);</span><br><span class="line"></span><br><span class="line">	// 表达式2</span><br><span class="line">	var list2 = new ArrayList&lt;&gt;();</span><br><span class="line">	list2.add(2018);</span><br><span class="line"></span><br><span class="line">	// 表达式3</span><br><span class="line">	var list3 = new ArrayList&lt;String&gt;();</span><br><span class="line">	list3.add(&quot;javastack&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表达式1后面 <code>&lt;&gt;</code> 里面 jdk 1.7+开始是不用带具体类型的，在接口中指明就行了。</p>
<p>表达式2中如果使用 <code>var</code> 的话，<code>&lt;&gt;</code> 里面默认会是 <code>Object</code> 的，所以可以添加任意类型。</p>
<p>表达式3中在 <code>&lt;&gt;</code> 强制使用了 String 来指定泛型。</p>
<h3 id="局部变量类型推断不能用在以下场景"><a href="#局部变量类型推断不能用在以下场景" class="headerlink" title="局部变量类型推断不能用在以下场景"></a>局部变量类型推断不能用在以下场景</h3><p><strong>1、类成员变量类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 编译报错</span><br><span class="line">private var javastack = &quot;Java技术&quot;;</span><br></pre></td></tr></table></figure>

<p><strong>2、方法返回类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 编译报错</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static var getJavastack()&#123;</span><br><span class="line"> 	return &quot;Java技术&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、Lambda 表达式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void testLambda() &#123;</span><br><span class="line">	Runnable runnable = () -&gt; System.out.println(&quot;javastack&quot;);</span><br><span class="line"></span><br><span class="line">	// 编译报错</span><br><span class="line">	// var runnable = () -&gt; System.out.println(&quot;javastack&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上 3 种场景是肯定不能使用 <code>var</code> 的，其他场合有待验证。</p>
<h3 id="局部变量类型推断优缺点"><a href="#局部变量类型推断优缺点" class="headerlink" title="局部变量类型推断优缺点"></a>局部变量类型推断优缺点</h3><p><strong>优点：简化代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList list1 = new CopyOnWriteArrayList();</span><br><span class="line">ConcurrentModificationException cme1 = new ConcurrentModificationException();</span><br><span class="line">DefaultServiceUnavailableRetryStrategy strategy1 = new</span><br><span class="line">		DefaultServiceUnavailableRetryStrategy();</span><br><span class="line"></span><br><span class="line">var list2 = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">var cme2 = new ConcurrentModificationException();</span><br><span class="line">var strategy2 = new DefaultServiceUnavailableRetryStrategy();</span><br></pre></td></tr></table></figure>

<p>从以上代码可以看出，很长的定义类型会显得代码很冗长，使用 var 大大简化了代码编写，同时类型统一显得代码很对齐。</p>
<p><strong>缺点：掩盖类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var token = new JsonParserDelegate(parser).currentToken();</span><br></pre></td></tr></table></figure>

<p>看以上代码，不进去看返回结果类型，谁知道返回的类型是什么？所以这种情况最好别使用 <code>var</code>，而使用具体的抽象类、接口或者实例类型。</p>
<h3 id="var关键字原理"><a href="#var关键字原理" class="headerlink" title="var关键字原理"></a>var关键字原理</h3><p>var其实就是 Java 10 增加的一种语法糖而已，在编译期间会自动推断实际类型，其编译后的字节码和实际类型一致，如以下例子所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static void testByteCode() &#123;</span><br><span class="line">	String javastack1 = &quot;javastack&quot;;</span><br><span class="line">	var javastack2 = &quot;javastack&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译成字节码后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static testByteCode()V</span><br><span class="line">L0</span><br><span class="line">LINENUMBER 22 L0</span><br><span class="line">LDC &quot;javastack&quot;</span><br><span class="line">ASTORE 0</span><br><span class="line">L1</span><br><span class="line">LINENUMBER 23 L1</span><br><span class="line">LDC &quot;javastack&quot;</span><br><span class="line">ASTORE 1</span><br><span class="line">L2</span><br><span class="line">LINENUMBER 24 L2</span><br><span class="line">RETURN</span><br><span class="line">L3</span><br><span class="line">LOCALVARIABLE javastack1 Ljava/lang/String; L1 L3 0</span><br><span class="line">LOCALVARIABLE javastack2 Ljava/lang/String; L2 L3 1</span><br><span class="line">MAXSTACK = 1</span><br><span class="line">MAXLOCALS = 2</span><br></pre></td></tr></table></figure>

<p>可以看出 <code>javastack1</code> 和 <code>javastack2</code> 都是虚拟机所认识的的本地变量类型：<code>java.lang.String</code>，虚拟机并不认识 var,  所以 <code>var</code> 并不神奇。</p>
<p>OK，本次 Java 10 局部变量类型推断实战文章就到这里了，后续带来更多的 Java 10 的实战方面的文章。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java10/Java%2010%20%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9E%E6%88%98/" data-id="cmgrfxxdb003e30d4hpycf9g9" data-title="Java 10 局部变量类型推断介绍及实战" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%B0%E7%89%B9%E6%80%A7/" rel="tag">新特性</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-新特性/Java10/Java 10 的 10 个新特性，将彻底改变你写代码的方式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java10/Java%2010%20%E7%9A%84%2010%20%E4%B8%AA%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%8C%E5%B0%86%E5%BD%BB%E5%BA%95%E6%94%B9%E5%8F%98%E4%BD%A0%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2025-10-15T03:36:33.000Z" itemprop="datePublished">2025-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java10/Java%2010%20%E7%9A%84%2010%20%E4%B8%AA%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%8C%E5%B0%86%E5%BD%BB%E5%BA%95%E6%94%B9%E5%8F%98%E4%BD%A0%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E5%BC%8F/">Java 10 的 10 个新特性，将彻底改变你写代码的方式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="http://img.javastack.cn/18-3-8/94675270.jpg" alt="image"></p>
<p>Java 9才发布几个月，很多玩意都没整明白，现在Java 10又快要来了。。</p>
<p>这时候我真尼玛想说：线上用的JDK 7 甚至JDK 6，JDK 8 还没用熟，JDK 9 才发布不久不知道啥玩意，JDK 10……</p>
<p>刚学Java的同学是不是感觉一脸蒙逼？！！！</p>
<p>就连我这个老司机也同样感觉如此！</p>
<p>Java 更新越来越快，我们做技术的也要跟上步伐，不然总会慢别人一拍，这新东西从国外到国内应用一般要好几年的时间，如果我们提前了解并应用这些新技术对自己不是坏事。</p>
<h3 id="Java-10的新特性"><a href="#Java-10的新特性" class="headerlink" title="Java 10的新特性"></a>Java 10的新特性</h3><p>说了这么多，看Java 10都会有哪些特性来改变我们写代码的方式呢？！</p>
<h4 id="1-局部变量类型推断"><a href="#1-局部变量类型推断" class="headerlink" title="1.局部变量类型推断"></a>1.局部变量类型推断</h4><p>局部变量类型推断可以说是Java 10中最值得注意的特性，这是Java语言开发人员为了简化Java应用程序的编写而采取的又一步，如下图所示。</p>
<p><img src="http://img.javastack.cn/18-3-8/56770623.jpg" alt="image"></p>
<p>这个新功能将为Java增加一些语法糖 - 简化它并改善开发者体验。新的语法将减少与编写Java相关的冗长度，同时保持对静态类型安全性的承诺。</p>
<p>局部变量类型推断将引入”var”关键字，也就是你可以随意定义变量而不必指定变量的类型，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List &lt;String&gt; list = new ArrayList &lt;String&gt;（）; </span><br><span class="line">Stream &lt;String&gt; stream = getStream（）;</span><br></pre></td></tr></table></figure>

<p>将被下面这个新语法所取代：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var list = new ArrayList &lt;String&gt;（）; </span><br><span class="line">var stream = getStream（）;</span><br></pre></td></tr></table></figure>

<p>看完是不是有点JS的即视感？？？越来越像JS了吗？！虽然类型推断在Java中不是一个新概念，但在局部变量中确是很大的一个改进。</p>
<p>说到类型推断，从JDK 5引进泛型，到JDK 7的”&lt;&gt;”操作符允许不绑定类型而初始化List，再到JDK 8的Lambda表达式，再到现在JDK 10的局部变量类型推断，Java类型推断正大刀阔斧的向前发展。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 该运算符允许在没有绑定ArrayList &lt;&gt;的类型的情况下初始化列表</span><br><span class="line">List &lt;String&gt; list = new LinkedList &lt;&gt;（）;</span><br></pre></td></tr></table></figure>

<p><strong>局部变量类型推荐仅限于如下使用场景：</strong></p>
<ul>
<li>局部变量初始化</li>
<li>for循环内部索引变量</li>
<li>传统的for循环声明变量</li>
</ul>
<p><strong>Java官方表示，它不能用于以下几个地方：</strong></p>
<ul>
<li>方法参数</li>
<li>构造函数参数</li>
<li>方法返回类型</li>
<li>字段</li>
<li>捕获表达式（或任何其他类型的变量声明）</li>
</ul>
<h4 id="2-GC改进和其他内务管理"><a href="#2-GC改进和其他内务管理" class="headerlink" title="2.GC改进和其他内务管理"></a>2.GC改进和其他内务管理</h4><p>JDK 10中有2个JEP专门用于改进当前的垃圾收集元素。</p>
<p>第一个垃圾收集器接口是（JEP 304），它将引入一个纯净的垃圾收集器接口，以帮助改进不同垃圾收集器的源代码隔离。</p>
<p>预定用于Java 10的第二个JEP是针对G1的并行完全GC（JEP 307），其重点在于通过完全GC并行来改善G1最坏情况的等待时间。G1是Java 9中的默认GC，并且此JEP的目标是使G1平行。</p>
<h4 id="3-线程本地握手（JEP-312）"><a href="#3-线程本地握手（JEP-312）" class="headerlink" title="3.线程本地握手（JEP 312）"></a>3.线程本地握手（JEP 312）</h4><p>JDK 10将引入一种在线程上执行回调的新方法，因此这将会很方便能停止单个线程而不是停止全部线程或者一个都不停。</p>
<h4 id="4-备用内存设备上的堆分配（JEP-316）"><a href="#4-备用内存设备上的堆分配（JEP-316）" class="headerlink" title="4.备用内存设备上的堆分配（JEP 316）"></a>4.备用内存设备上的堆分配（JEP 316）</h4><p>允许HotSpot VM在备用内存设备上分配Java对象堆内存，该内存设备将由用户指定。</p>
<h4 id="5-其他Unicode语言-标记扩展（JEP-314）"><a href="#5-其他Unicode语言-标记扩展（JEP-314）" class="headerlink" title="5.其他Unicode语言 - 标记扩展（JEP 314）"></a>5.其他Unicode语言 - 标记扩展（JEP 314）</h4><p>目标是增强java.util.Locale及其相关的API，以便实现语言标记语法的其他Unicode扩展（BCP 47）。</p>
<h4 id="6-基于Java的实验性JIT编译器（JEP-317）"><a href="#6-基于Java的实验性JIT编译器（JEP-317）" class="headerlink" title="6.基于Java的实验性JIT编译器（JEP 317）"></a>6.基于Java的实验性JIT编译器（JEP 317）</h4><p>Oracle希望将其Java JIT编译器Graal用作Linux &#x2F; x64平台上的实验性JIT编译器。</p>
<h4 id="7-根证书（JEP-319）"><a href="#7-根证书（JEP-319）" class="headerlink" title="7.根证书（JEP 319）"></a>7.根证书（JEP 319）</h4><p>这个的目标是在Oracle的Java SE中开源根证书。</p>
<h4 id="8-根证书认证程序（CA）"><a href="#8-根证书认证程序（CA）" class="headerlink" title="8.根证书认证程序（CA）"></a>8.根证书认证程序（CA）</h4><p>这将使OpenJDK对开发人员更具吸引力，它还旨在减少OpenJDK和Oracle JDK构建之间的差异。</p>
<h4 id="9-将JDK生态整合到单个存储库中（JEP-296）"><a href="#9-将JDK生态整合到单个存储库中（JEP-296）" class="headerlink" title="9.将JDK生态整合到单个存储库中（JEP 296）"></a>9.将JDK生态整合到单个存储库中（JEP 296）</h4><p>此JEP的主要目标是执行一些内存管理，并将JDK生态的众多存储库组合到一个存储库中。</p>
<h4 id="10-删除Native-Header生成工具（javah）（JEP-313）"><a href="#10-删除Native-Header生成工具（javah）（JEP-313）" class="headerlink" title="10.删除Native-Header生成工具（javah）（JEP 313）"></a>10.删除Native-Header生成工具（javah）（JEP 313）</h4><p>从JDK中移除了javah工具，这个很简单并且很重要。</p>
<h3 id="尝鲜"><a href="#尝鲜" class="headerlink" title="尝鲜"></a>尝鲜</h3><p>就像所有其他JDK版本一样，Oracle已经发布了一个Java 10初始候选版本，Java开发者可以下载此版本用来测试新功能。如果你对Java 10抱有期待想提早尝试，那么现在就开始吧！</p>
<blockquote>
<p>尝鲜地址：<a target="_blank" rel="noopener" href="http://openjdk.java.net/projects/jdk/10/">http://openjdk.java.net/projects/jdk/10/</a></p>
</blockquote>
<h4 id="最后的感悟"><a href="#最后的感悟" class="headerlink" title="最后的感悟"></a>最后的感悟</h4><p>对于第一点新特性来说确实是一个大的跨越，其他特性或多或少都能带给开发者福音。但最终Java 10会是什么样，或许还会增加更多实用性的新功能或者优化，我们还得期待！</p>
<p>现在要做的就是，赶紧熟悉JDK 8，现在已经是很多互联网企业标配了。如果还在使用JDK4-7，那真的是要OUT了。。</p>
<p>在不久的将来，Java 10将彻底改变你写代码的方式！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java10/Java%2010%20%E7%9A%84%2010%20%E4%B8%AA%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%8C%E5%B0%86%E5%BD%BB%E5%BA%95%E6%94%B9%E5%8F%98%E4%BD%A0%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E5%BC%8F/" data-id="cmgrfxxdc003h30d4fo4u65yf" data-title="Java 10 的 10 个新特性，将彻底改变你写代码的方式" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%B0%E7%89%B9%E6%80%A7/" rel="tag">新特性</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-新特性/Java11/Java 11 已发布，String 还能这样玩" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java11/Java%2011%20%E5%B7%B2%E5%8F%91%E5%B8%83%EF%BC%8CString%20%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9/" class="article-date">
  <time class="dt-published" datetime="2025-10-15T03:36:33.000Z" itemprop="datePublished">2025-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java11/Java%2011%20%E5%B7%B2%E5%8F%91%E5%B8%83%EF%BC%8CString%20%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9/">Java 11 已发布，String 还能这样玩</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在文章《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/SXEqAmfbmK4NklihukbE-Q">Java 11 正式发布，这 8 个逆天新特性教你写出更牛逼的代码</a>》中，我有介绍到 Java 11 的八个新特性，其中关于 String 加强部分，我觉得有点意思，这里单独再拉出来讲。</p>
<p><strong>Java 11 增加了一系列的字符串处理方法，如以下所示。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 判断字符串是否为空白</span><br><span class="line">&quot; &quot;.isBlank();                // true</span><br><span class="line"></span><br><span class="line">// 去除首尾空格</span><br><span class="line">&quot; Javastack &quot;.strip();          // &quot;Javastack&quot;</span><br><span class="line"></span><br><span class="line">// 去除尾部空格 </span><br><span class="line">&quot; Javastack &quot;.stripTrailing();  // &quot; Javastack&quot;</span><br><span class="line"></span><br><span class="line">// 去除首部空格 </span><br><span class="line">&quot; Javastack &quot;.stripLeading();   // &quot;Javastack &quot;</span><br><span class="line"></span><br><span class="line">// 复制字符串</span><br><span class="line">&quot;Java&quot;.repeat(3);             // &quot;JavaJavaJava&quot;</span><br><span class="line"></span><br><span class="line">// 行数统计</span><br><span class="line">&quot;A\nB\nC&quot;.lines().count();    // 3</span><br></pre></td></tr></table></figure>

<p>最有意思的是 <code>repeat</code> 和 <code>lines</code> 方法了，来看下还能怎么玩！</p>
<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h4><p>repeat 方法的作用就是重复一个字符串 N 遍，可以用来代替工具类：<code>org.apache.commons.lang3.StringUtils#repeat(java.lang.String, int)</code>，来看下 <code>repeat</code> 的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public String repeat(int count) &#123;</span><br><span class="line">    if (count &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;count is negative: &quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line">    if (count == 1) &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    final int len = value.length;</span><br><span class="line">    if (len == 0 || count == 0) &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (len == 1) &#123;</span><br><span class="line">        final byte[] single = new byte[count];</span><br><span class="line">        Arrays.fill(single, value[0]);</span><br><span class="line">        return new String(single, coder);</span><br><span class="line">    &#125;</span><br><span class="line">    if (Integer.MAX_VALUE / count &lt; len) &#123;</span><br><span class="line">        throw new OutOfMemoryError(&quot;Repeating &quot; + len + &quot; bytes String &quot; + count +</span><br><span class="line">                &quot; times will produce a String exceeding maximum size.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    final int limit = len * count;</span><br><span class="line">    final byte[] multiple = new byte[limit];</span><br><span class="line">    System.arraycopy(value, 0, multiple, 0, len);</span><br><span class="line">    int copied = len;</span><br><span class="line">    for (; copied &lt; limit - copied; copied &lt;&lt;= 1) &#123;</span><br><span class="line">        System.arraycopy(multiple, 0, multiple, copied, copied);</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(multiple, 0, multiple, copied, limit - copied);</span><br><span class="line">    return new String(multiple, coder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看下更多的用法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Java&quot;;</span><br><span class="line"></span><br><span class="line">// 小于0：java.lang.IllegalArgumentException</span><br><span class="line">System.out.println(str.repeat(-2));</span><br><span class="line"></span><br><span class="line">// 等于0：空白串（&quot;&quot;）</span><br><span class="line">System.out.println(str.repeat(0));</span><br><span class="line"></span><br><span class="line">// JavaJavaJava</span><br><span class="line">System.out.println(str.repeat(3));</span><br><span class="line"></span><br><span class="line">// java.lang.OutOfMemoryError</span><br><span class="line">System.out.println(str.repeat(Integer.MAX_VALUE));</span><br></pre></td></tr></table></figure>

<p>所以说 repeat 并不是可以无限增长的，有使用限制的，达到一定量就会报内存溢出异常。</p>
<h4 id="lines"><a href="#lines" class="headerlink" title="lines"></a>lines</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Stream&lt;String&gt; lines() &#123;</span><br><span class="line">    return isLatin1() ? StringLatin1.lines(value)</span><br><span class="line">                      : StringUTF16.lines(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lines 方法返回一个字符串 Stream, 可以识别 <code>\n</code> 和 <code>\r</code> 换行符换行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 4</span><br><span class="line">System.out.println(&quot;A\nB\nC\rD&quot;.lines().count());</span><br></pre></td></tr></table></figure>

<p>是不是很好？在将来肯定有武之地！如批量读取文件内容到一个 Stream 中，就能很好的识别行结束符了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java11/Java%2011%20%E5%B7%B2%E5%8F%91%E5%B8%83%EF%BC%8CString%20%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9/" data-id="cmgrfxxdc003j30d4f1163bv7" data-title="Java 11 已发布，String 还能这样玩" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%B0%E7%89%B9%E6%80%A7/" rel="tag">新特性</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-新特性/Java11/Java 11 正式发布，这 8 个新特性教你写出更牛逼的代码" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java11/Java%2011%20%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%EF%BC%8C%E8%BF%99%208%20%E4%B8%AA%E6%96%B0%E7%89%B9%E6%80%A7%E6%95%99%E4%BD%A0%E5%86%99%E5%87%BA%E6%9B%B4%E7%89%9B%E9%80%BC%E7%9A%84%E4%BB%A3%E7%A0%81/" class="article-date">
  <time class="dt-published" datetime="2025-10-15T03:36:33.000Z" itemprop="datePublished">2025-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java11/Java%2011%20%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%EF%BC%8C%E8%BF%99%208%20%E4%B8%AA%E6%96%B0%E7%89%B9%E6%80%A7%E6%95%99%E4%BD%A0%E5%86%99%E5%87%BA%E6%9B%B4%E7%89%9B%E9%80%BC%E7%9A%84%E4%BB%A3%E7%A0%81/">Java 11 正式发布，这 8 个新特性教你写出更牛逼的代码</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>美国时间 09 月 25 日，Oralce 正式发布了 Java 11，这是据 Java 8 以后支持的首个长期版本。</p>
<p>为什么说是长期版本，看下面的官方发布的支持路线图表。</p>
<p><img src="http://qianniu.javastack.cn/18-9-26/91229065.jpg"></p>
<p>可以看出 Java 8 扩展支持到 2025 年，而 Java 11 扩展支持到 2026 年。</p>
<p>现在大部分都在用 Java 8，Java 9 和 10 目前很少有人在用，至少我没有发现有公司在生产环境应用的，那就是找死。</p>
<p>现在 Java 11 长期支持，也已经包含了 9 和 10 的全部功能，9 和 10 自然就活到头了。。</p>
<p>那么我们来看下 从 Java 9 - 11 都有哪些重要的新特性呢？</p>
<h4 id="1、本地变量类型推断"><a href="#1、本地变量类型推断" class="headerlink" title="1、本地变量类型推断"></a>1、本地变量类型推断</h4><p>这个博主已经写过一篇文章，详细的介绍了 Java 10 带来的这个新特性。</p>
<p>什么是局部变量类型推断？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var javastack = &quot;javastack&quot;;</span><br><span class="line">System.out.println(javastack);</span><br></pre></td></tr></table></figure>

<p>大家看出来了，局部变量类型推断就是左边的类型直接使用 <code>var</code> 定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型，如上面的 <code>String</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var javastack = &quot;javastack&quot;;</span><br></pre></td></tr></table></figure>

<p>就等于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String javastack = &quot;javastack&quot;;</span><br></pre></td></tr></table></figure>

<p>更多使用详情请参考这篇文章《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/4zUtQPUn5LYw43IRLm0Dwg">Java 10 实战第 1 篇：局部变量类型推断</a>》，这里不再重复了。</p>
<h4 id="2、字符串加强"><a href="#2、字符串加强" class="headerlink" title="2、字符串加强"></a>2、字符串加强</h4><p>Java 11 增加了一系列的字符串处理方法，如以下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 判断字符串是否为空白</span><br><span class="line">&quot; &quot;.isBlank();                // true</span><br><span class="line"></span><br><span class="line">// 去除首尾空格</span><br><span class="line">&quot; Javastack &quot;.strip();          // &quot;Javastack&quot;</span><br><span class="line"></span><br><span class="line">// 去除尾部空格 </span><br><span class="line">&quot; Javastack &quot;.stripTrailing();  // &quot; Javastack&quot;</span><br><span class="line"></span><br><span class="line">// 去除首部空格 </span><br><span class="line">&quot; Javastack &quot;.stripLeading();   // &quot;Javastack &quot;</span><br><span class="line"></span><br><span class="line">// 复制字符串</span><br><span class="line">&quot;Java&quot;.repeat(3);             // &quot;JavaJavaJava&quot;</span><br><span class="line"></span><br><span class="line">// 行数统计</span><br><span class="line">&quot;A\nB\nC&quot;.lines().count();    // 3</span><br></pre></td></tr></table></figure>

<h4 id="3、集合加强"><a href="#3、集合加强" class="headerlink" title="3、集合加强"></a>3、集合加强</h4><p>自 Java 9 开始，Jdk 里面为集合（List&#x2F; Set&#x2F; Map）都添加了 <code>of</code> 和 <code>copyOf</code> 方法，它们两个都用来创建不可变的集合，来看下它们的使用和区别。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var list = List.of(&quot;Java&quot;, &quot;Python&quot;, &quot;C&quot;);</span><br><span class="line">var copy = List.copyOf(list);</span><br><span class="line">System.out.println(list == copy);   // true</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var list = new ArrayList&lt;String&gt;();</span><br><span class="line">var copy = List.copyOf(list);</span><br><span class="line">System.out.println(list == copy);   // false</span><br></pre></td></tr></table></figure>

<p>示例1和2代码差不多，为什么一个为true,一个为false?</p>
<p>来看下它们的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static &lt;E&gt; List&lt;E&gt; of(E... elements) &#123;</span><br><span class="line">    switch (elements.length) &#123; // implicit null check of elements</span><br><span class="line">        case 0:</span><br><span class="line">            return ImmutableCollections.emptyList();</span><br><span class="line">        case 1:</span><br><span class="line">            return new ImmutableCollections.List12&lt;&gt;(elements[0]);</span><br><span class="line">        case 2:</span><br><span class="line">            return new ImmutableCollections.List12&lt;&gt;(elements[0], elements[1]);</span><br><span class="line">        default:</span><br><span class="line">            return new ImmutableCollections.ListN&lt;&gt;(elements);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static &lt;E&gt; List&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) &#123;</span><br><span class="line">    return ImmutableCollections.listCopy(coll);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static &lt;E&gt; List&lt;E&gt; listCopy(Collection&lt;? extends E&gt; coll) &#123;</span><br><span class="line">    if (coll instanceof AbstractImmutableList &amp;&amp; coll.getClass() != SubList.class) &#123;</span><br><span class="line">        return (List&lt;E&gt;)coll;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return (List&lt;E&gt;)List.of(coll.toArray());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 <code>copyOf</code> 方法会先判断来源集合是不是 <code>AbstractImmutableList</code> 类型的，如果是，就直接返回，如果不是，则调用 <code>of</code> 创建一个新的集合。</p>
<p>示例2因为用的 new 创建的集合，不属于不可变 <code>AbstractImmutableList</code> 类的子类，所以 <code>copyOf</code> 方法又创建了一个新的实例，所以为false.</p>
<blockquote>
<p>注意：使用 of 和 copyOf 创建的集合为不可变集合，不能进行添加、删除、替换、排序等操作，不然会报 <code>java.lang.UnsupportedOperationException</code> 异常。</p>
</blockquote>
<p>上面演示了 List 的 of 和 copyOf 方法，Set 和 Map 接口都有。</p>
<h4 id="4、Stream-加强"><a href="#4、Stream-加强" class="headerlink" title="4、Stream 加强"></a>4、Stream 加强</h4><p>Stream 是 Java 8 中的新特性，Java 9 开始对 Stream 增加了以下 4 个新方法。</p>
<ol>
<li>增加单个参数构造方法，可为null</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.ofNullable(null).count(); // 0</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>增加 takeWhile 和 dropWhile 方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(1, 2, 3, 2, 1)</span><br><span class="line">    .takeWhile(n -&gt; n &lt; 3)</span><br><span class="line">    .collect(Collectors.toList());  // [1, 2]</span><br></pre></td></tr></table></figure>

<p>从开始计算，当 n &lt; 3 时就截止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(1, 2, 3, 2, 1)</span><br><span class="line">    .dropWhile(n -&gt; n &lt; 3)</span><br><span class="line">    .collect(Collectors.toList());  // [3, 2, 1]</span><br></pre></td></tr></table></figure>

<p>这个和上面的相反，一旦 n &lt; 3 不成立就开始计算。</p>
<p>3）iterate重载</p>
<p>这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。</p>
<p>如果你对 JDK 8 中的 Stream 还不熟悉，可以看之前分享的这一系列教程。</p>
<h4 id="5、Optional-加强"><a href="#5、Optional-加强" class="headerlink" title="5、Optional 加强"></a>5、Optional 加强</h4><p>Opthonal 也增加了几个非常酷的方法，现在可以很方便的将一个 Optional 转换成一个 Stream, 或者当一个空 Optional 时给它一个替代的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional.of(&quot;javastack&quot;).orElseThrow();     // javastack</span><br><span class="line">Optional.of(&quot;javastack&quot;).stream().count();  // 1</span><br><span class="line">Optional.ofNullable(null)</span><br><span class="line">    .or(() -&gt; Optional.of(&quot;javastack&quot;))</span><br><span class="line">    .get();   // javastack</span><br></pre></td></tr></table></figure>

<h4 id="6、InputStream-加强"><a href="#6、InputStream-加强" class="headerlink" title="6、InputStream 加强"></a>6、InputStream 加强</h4><p>InputStream 终于有了一个非常有用的方法：transferTo，可以用来将数据直接传输到 OutputStream，这是在处理原始数据流时非常常见的一种用法，如下示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">var inputStream = classLoader.getResourceAsStream(&quot;javastack.txt&quot;);</span><br><span class="line">var javastack = File.createTempFile(&quot;javastack2&quot;, &quot;txt&quot;);</span><br><span class="line">try (var outputStream = new FileOutputStream(javastack)) &#123;</span><br><span class="line">    inputStream.transferTo(outputStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7、HTTP-Client-API"><a href="#7、HTTP-Client-API" class="headerlink" title="7、HTTP Client API"></a>7、HTTP Client API</h4><p>这是 Java 9 开始引入的一个处理 HTTP 请求的的孵化 HTTP Client  API，该 API 支持同步和异步，而在 Java 11 中已经为正式可用状态，你可以在 <code>java.net</code> 包中找到这个 API。</p>
<p>来看一下 HTTP Client 的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var request = HttpRequest.newBuilder()</span><br><span class="line">    .uri(URI.create(&quot;https://javastack.cn&quot;))</span><br><span class="line">    .GET()</span><br><span class="line">    .build();</span><br><span class="line">var client = HttpClient.newHttpClient();</span><br><span class="line"></span><br><span class="line">// 同步</span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">System.out.println(response.body());</span><br><span class="line"></span><br><span class="line">// 异步</span><br><span class="line">client.sendAsync(request, HttpResponse.BodyHandlers.ofString())</span><br><span class="line">    .thenApply(HttpResponse::body)</span><br><span class="line">    .thenAccept(System.out::println);</span><br></pre></td></tr></table></figure>

<p>上面的 <code>.GET()</code> 可以省略，默认请求方式为 Get！</p>
<p>更多使用示例可以看这个 API，后续有机会再做演示。</p>
<p>现在 Java 自带了这个 HTTP Client API，我们以后还有必要用 Apache 的 HttpClient 工具包吗？</p>
<h4 id="8、化繁为简，一个命令编译运行源代码"><a href="#8、化繁为简，一个命令编译运行源代码" class="headerlink" title="8、化繁为简，一个命令编译运行源代码"></a>8、化繁为简，一个命令编译运行源代码</h4><p>看下面的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 编译</span><br><span class="line">javac Javastack.java</span><br><span class="line"></span><br><span class="line">// 运行</span><br><span class="line">java Javastack</span><br></pre></td></tr></table></figure>

<p>在我们的认知里面，要运行一个 Java 源代码必须先编译，再运行，两步执行动作。而在未来的 Java 11 版本中，通过一个 <code>java</code> 命令就直接搞定了，如以下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Javastack.java</span><br></pre></td></tr></table></figure>

<h4 id="更多新特性"><a href="#更多新特性" class="headerlink" title="更多新特性"></a>更多新特性</h4><ul>
<li>Flow API for reactive programming</li>
<li>Java Module System</li>
<li>Application Class Data Sharing</li>
<li>Dynamic Class-File Constants</li>
<li>Java REPL (JShell)</li>
<li>Flight Recorder</li>
<li>Unicode 10</li>
<li>G1: Full Parallel Garbage Collector</li>
<li>ZGC: Scalable Low-Latency Garbage Collector</li>
<li>Epsilon: No-Op Garbage Collector</li>
<li>Deprecate the Nashorn JavaScript Engine</li>
<li>…</li>
</ul>
<h4 id="历史新特性文章"><a href="#历史新特性文章" class="headerlink" title="历史新特性文章"></a>历史新特性文章</h4><ul>
<li>Java 11 要来了，编译运行一个命令搞定</li>
<li>JDK 11 发布计划来了，已确定 3个 新特性</li>
<li>Java 10 实战第 1 篇：局部变量类型推断</li>
<li>JDK 5 ~ 10 新特性倾情整理</li>
<li>JDK 10 的 10 个新特性</li>
<li>JDK 10 最重要的 5 个新特性</li>
<li>JDK 9 的 9 个新特性</li>
<li>JDK 9 新特性实战：简化流关闭新姿势</li>
<li>JDK 8 的排序大法</li>
<li>JDK 8 新特性之 Lambda 表达式</li>
<li>JDK 8 新特性之函数式接口</li>
<li>JDK 8 新特性之方法引用</li>
<li>JDK 8 新特性之接口默认方法与静态方法</li>
<li>JDK 8 新特性之 Optional</li>
<li>JDK 8 新特性之重复注解</li>
<li>JDK 8 新特性之 Stream 流</li>
<li>JDK 8 新特性之 Stream 流（一）基础体验</li>
<li>JDK 8 新特性之 Stream 流（二）关键知识点</li>
<li>JDK 8 新特性之 Stream 流（三）缩减操作</li>
<li>JDK 8 新特性之 Stream 流（四）并行流</li>
<li>JDK 8 新特性之 Stream 流（五）映射</li>
<li>JDK 8 新特性之 Stream 流（六）收集缩</li>
<li>JDK 8 新特性之 Stream 流（七）流与迭代器</li>
<li>JDK 8 新特性之扩展篇</li>
</ul>
<h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>现在许多人还在使用 Java 8 或者 7，不过 8 在 2019 年初就会结束免费更新。现在 11 是长期支持版本，正是学习和上手 11 的好时机，写这篇文章希望能对你有所启发。</p>
<p>如果你喜欢的我的文章，对你有帮助，点赞转发支持一下吧~</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java11/Java%2011%20%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%EF%BC%8C%E8%BF%99%208%20%E4%B8%AA%E6%96%B0%E7%89%B9%E6%80%A7%E6%95%99%E4%BD%A0%E5%86%99%E5%87%BA%E6%9B%B4%E7%89%9B%E9%80%BC%E7%9A%84%E4%BB%A3%E7%A0%81/" data-id="cmgrfxxdd003m30d4awii4a0l" data-title="Java 11 正式发布，这 8 个新特性教你写出更牛逼的代码" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%B0%E7%89%B9%E6%80%A7/" rel="tag">新特性</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-新特性/Java12/Java 12 骚操作， String居然还能这样玩" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java12/Java%2012%20%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%8C%20String%E5%B1%85%E7%84%B6%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9/" class="article-date">
  <time class="dt-published" datetime="2025-10-15T03:36:33.000Z" itemprop="datePublished">2025-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java12/Java%2012%20%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%8C%20String%E5%B1%85%E7%84%B6%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9/">Java 12 骚操作， String居然还能这样玩</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Java 13 都快要来了，12必须跟栈长学起！</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Gg6KKz7vhDRpzeMR8CG4DA">Java 13 即将发布，新特性必须抢先看！</a></p>
<p>Java 12 已经发布数月了：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/IXOoSTq6qi4ZH63gCaKa3A">Java 12 正式发布，8大新特性！</a>，今天我再来分享下在 Java 12 中关于 String 的三个骚操作，绝逼有用。</p>
<p>更多关于 Java 的资讯、干货教程、以及好消息，请关注，第一时间推送。</p>
<p>坐稳了，准备起飞！</p>
<h2 id="1、transform"><a href="#1、transform" class="headerlink" title="1、transform"></a>1、transform</h2><p>transform：即字符串转换，来看下 transform 的实现源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;R&gt; R transform(Function&lt;? super String, ? extends R&gt; f) &#123;</span><br><span class="line">    return f.apply(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入一个函数式接口 Function，接受一个值，返回一个值，参考：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/nC3f17zZlXC08XNJWA-FBw">Java 8 新特性之函数式接口</a>。</p>
<p>废话少说，直接上手就是干：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static void testTransform() &#123;</span><br><span class="line">    System.out.println(&quot;======test java 12 transform======&quot;);</span><br><span class="line">    List&lt;String&gt; list1 = List.of(&quot;Java&quot;, &quot; Python&quot;, &quot; C++ &quot;);</span><br><span class="line">    List&lt;String&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    list1.forEach(element -&gt;</span><br><span class="line">            list2.add(element.transform(String::strip)</span><br><span class="line">                    .transform(String::toUpperCase)</span><br><span class="line">                    .transform((e) -&gt; &quot;Hi,&quot; + e))</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    list2.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">======test java 12 transform======</span><br><span class="line">Hi,JAVA</span><br><span class="line">Hi,PYTHON</span><br><span class="line">Hi,C++</span><br></pre></td></tr></table></figure>

<p>示例是对一个字符串连续转换了三遍，代码很简单，大家都能领会的。</p>
<h2 id="2、indent"><a href="#2、indent" class="headerlink" title="2、indent"></a>2、indent</h2><p>直接看示例吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static void testIndent() &#123;</span><br><span class="line">    System.out.println(&quot;======test java 12 indent======&quot;);</span><br><span class="line">    String result = &quot;Java\n Python\nC++&quot;.indent(3);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">======test java 12 indent======</span><br><span class="line">   Java</span><br><span class="line">    Python</span><br><span class="line">   C++</span><br></pre></td></tr></table></figure>

<p>换行符 \n 后前缩进 N 个空格，为 0 或负数不缩进。</p>
<p>以下是 indent 的核心源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private String indent(int n, boolean removeBlanks) &#123;</span><br><span class="line">    Stream&lt;String&gt; stream = removeBlanks ? lines(Integer.MAX_VALUE, Integer.MAX_VALUE)</span><br><span class="line">                                         : lines();</span><br><span class="line">    if (n &gt; 0) &#123;</span><br><span class="line">        final String spaces = &quot; &quot;.repeat(n);</span><br><span class="line">        stream = stream.map(s -&gt; spaces + s);</span><br><span class="line">    &#125; else if (n == Integer.MIN_VALUE) &#123;</span><br><span class="line">        stream = stream.map(s -&gt; s.stripLeading());</span><br><span class="line">    &#125; else if (n &lt; 0) &#123;</span><br><span class="line">        stream = stream.map(s -&gt; s.substring(Math.min(-n, s.indexOfNonWhitespace())));</span><br><span class="line">    &#125;</span><br><span class="line">    return stream.collect(Collectors.joining(&quot;\n&quot;, &quot;&quot;, &quot;\n&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是调用了 lines() 方法来创建一个 Stream，然后再往前拼接指定数量的空格。</p>
<p>参考：《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/OZKvkG5OhMXf4lTklZQzGQ">Java 11 已发布，String 还能这样玩！</a>》这篇文章对 lines() 的介绍。</p>
<h2 id="3、describeConstable"><a href="#3、describeConstable" class="headerlink" title="3、describeConstable"></a>3、describeConstable</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void testDescribeConstable() &#123;</span><br><span class="line">    System.out.println(&quot;======test java 12 describeConstable======&quot;);</span><br><span class="line">    String name = &quot;Java技术&quot;;</span><br><span class="line">    Optional&lt;String&gt; optional = name.describeConstable();</span><br><span class="line">    System.out.println(optional.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">======test java 12 describeConstable======</span><br><span class="line">Java技术</span><br></pre></td></tr></table></figure>

<p>Java 12, String 实现了 Constable 接口：</p>
<blockquote>
<p>java.lang.constant.Constable</p>
</blockquote>
<p>这个接口就有一个方法，源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Constable &#123;</span><br><span class="line"></span><br><span class="line">    Optional&lt;? extends ConstantDesc&gt; describeConstable();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 12 String 的实现源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Optional&lt;String&gt; describeConstable() &#123;</span><br><span class="line">    return Optional.of(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，其实就是调用 Optional.of 方法返回一个 Optional 类型，Optional不懂的可以参考这篇文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/uXw4eTZqLfj871FlciPh6Q">Java 8 新特性之 Optional</a>。</p>
<p>好了，今天的分享就到这，收藏转发一下吧，多学习了解，日后必定有用！</p>
<p>历史 Java 新特性干货分享：</p>
<p><img src="http://img.javastack.cn/20190613135450.png"><br><img src="http://img.javastack.cn/20190613135537.png"></p>
<p>Java 12 新特性继续更新中……</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java12/Java%2012%20%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%8C%20String%E5%B1%85%E7%84%B6%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9/" data-id="cmgrfxxdd003o30d4fd9cczcu" data-title="Java 12 骚操作， String居然还能这样玩" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%B0%E7%89%B9%E6%80%A7/" rel="tag">新特性</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-新特性/Java12/Java 12 骚操作， switch居然还能这样玩！" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java12/Java%2012%20%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%8C%20switch%E5%B1%85%E7%84%B6%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9%EF%BC%81/" class="article-date">
  <time class="dt-published" datetime="2025-10-15T03:36:33.000Z" itemprop="datePublished">2025-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java12/Java%2012%20%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%8C%20switch%E5%B1%85%E7%84%B6%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9%EF%BC%81/">Java 12 骚操作， switch居然还能这样玩！</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Java 13 都快要来了，12必须跟栈长学起！</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Gg6KKz7vhDRpzeMR8CG4DA">Java 13 即将发布，新特性必须抢先看！</a></p>
<p><strong>那么在 Java 12 中可以怎样玩 switch?</strong></p>
<p>先来定义一个枚举类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Status &#123;</span><br><span class="line">    OPEN, INIT, PROCESS, PENDING, CLOSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 12 之前是这样用的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static void testSwitch1(Status status) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    switch (status) &#123;</span><br><span class="line">        case OPEN:</span><br><span class="line">            result = 1;</span><br><span class="line">            break;</span><br><span class="line">        case PROCESS:</span><br><span class="line">            result = 2;</span><br><span class="line">            break;</span><br><span class="line">        case PENDING:</span><br><span class="line">            result = 2;</span><br><span class="line">            break;</span><br><span class="line">        case CLOSE:</span><br><span class="line">            result = 3;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            throw new RuntimeException(&quot;状态不正确&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;result is &quot; + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 12 后可以这样用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static void testSwitch2(Status status) &#123;</span><br><span class="line">    var result = switch (status) &#123;</span><br><span class="line">        case OPEN -&gt; 1;</span><br><span class="line">        case PROCESS, PENDING -&gt; 2;</span><br><span class="line">        case CLOSE -&gt; 3;</span><br><span class="line">        default -&gt; throw new RuntimeException(&quot;状态不正确&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(&quot;result is &quot; + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码看了都懂吧，是不是很骚？</p>
<p>Java 12 switch 有以下几点特色：</p>
<ul>
<li>箭头语法 -&gt;，类似 Java 8 中的 Lambda 表达式；</li>
<li>可以直接返回值给一个变量，并且可以不用 break 关键字；</li>
<li>case 条件，多个可以写在一行，用逗号分开；</li>
<li>可以省略 break 关键字；</li>
</ul>
<p>当然你也可以使用 break 关键字，后面跟值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static void testSwitch3(Status status) &#123;</span><br><span class="line">    var result = switch (status) &#123;</span><br><span class="line">        case OPEN -&gt; &#123;</span><br><span class="line">            break 1;</span><br><span class="line">        &#125;</span><br><span class="line">        case PROCESS, PENDING -&gt; &#123;</span><br><span class="line">            break 2;</span><br><span class="line">        &#125;</span><br><span class="line">        case CLOSE -&gt; &#123;</span><br><span class="line">            break 3;</span><br><span class="line">        &#125;</span><br><span class="line">        default -&gt; &#123;</span><br><span class="line">            break 5;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(&quot;result is &quot; + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不推荐用这种，在编译器也会显示灰色，并提示你更改。</p>
<p>最后，这个新特性是 Java 12 预览版中的特性：<code>JEP 325: Switch Expressions (Preview)</code>，要使用这个新特性，请切换至 Java 12 预览版。</p>
<blockquote>
<p>参考 <a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/325">https://openjdk.java.net/jeps/325</a></p>
</blockquote>
<p>好了，今天的分享就到这，收藏转发一下吧，多学习了解，日后必定有用！</p>
<p>历史 Java 新特性干货分享：</p>
<p><img src="http://img.javastack.cn/20190613135450.png"><br><img src="http://img.javastack.cn/20190613135537.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java12/Java%2012%20%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%8C%20switch%E5%B1%85%E7%84%B6%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9%EF%BC%81/" data-id="cmgrfxxdd003q30d41zt092x2" data-title="Java 12 骚操作， switch居然还能这样玩！" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%B0%E7%89%B9%E6%80%A7/" rel="tag">新特性</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-新特性/Java12/Java 12 骚操作， 文件比对居然还能这样玩！" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java12/Java%2012%20%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%8C%20%E6%96%87%E4%BB%B6%E6%AF%94%E5%AF%B9%E5%B1%85%E7%84%B6%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9%EF%BC%81/" class="article-date">
  <time class="dt-published" datetime="2025-10-15T03:36:33.000Z" itemprop="datePublished">2025-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java12/Java%2012%20%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%8C%20%E6%96%87%E4%BB%B6%E6%AF%94%E5%AF%B9%E5%B1%85%E7%84%B6%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9%EF%BC%81/">Java 12 骚操作， 文件比对居然还能这样玩！</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Java 13 都快要来了，12必须跟栈长学起！</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Gg6KKz7vhDRpzeMR8CG4DA">Java 13 即将发布，新特性必须抢先看！</a></p>
<p>之前分享了一些 Java 12 的骚操作，今天继续，今天要分享的是 Java 12 中的文件比对骚操作。</p>
<p><strong>我们或多或少会遇到这样的需求：怎么比对两个文件中的内容一样？</strong></p>
<p>你会把两个文件中的内容拉出来一个个字符对比，然后提交一大堆不怎么优雅的代码？</p>
<p>这样你就太 OUT 了！</p>
<p>在 Java 12 中，仅需要 1 行代码即可搞定！</p>
<p>来看示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    Path dir = Paths.get(&quot;d:/&quot;);</span><br><span class="line"></span><br><span class="line">    Path path1 = dir.resolve(&quot;javastack1.txt&quot;);</span><br><span class="line"></span><br><span class="line">    Path path2 = dir.resolve(&quot;javastack2.txt&quot;);</span><br><span class="line"></span><br><span class="line">    long result = Files.mismatch(path1, path2);</span><br><span class="line"></span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Files.mismatch 一行搞定！</strong></p>
<p>javastack1 和 javastack2 的内容都是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.javastack.cn</span><br></pre></td></tr></table></figure>

<p>这时候输出结果：-1。</p>
<p>现在把 javastack2 的内容改成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.javastack.cn</span><br></pre></td></tr></table></figure>

<p>这时候输出结果：0。</p>
<p>再把 javastack2 的内容改成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.javastack.cn/</span><br></pre></td></tr></table></figure>

<p>这时候输出结果：16。</p>
<p><strong>Files.mismatch</strong></p>
<p>Files.mismatch方法源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static long mismatch(Path path, Path path2) throws IOException &#123;</span><br><span class="line">    if (isSameFile(path, path2)) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    byte[] buffer1 = new byte[BUFFER_SIZE];</span><br><span class="line">    byte[] buffer2 = new byte[BUFFER_SIZE];</span><br><span class="line">    try (InputStream in1 = Files.newInputStream(path);</span><br><span class="line">         InputStream in2 = Files.newInputStream(path2);) &#123;</span><br><span class="line">        long totalRead = 0;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            int nRead1 = in1.readNBytes(buffer1, 0, BUFFER_SIZE);</span><br><span class="line">            int nRead2 = in2.readNBytes(buffer2, 0, BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">            int i = Arrays.mismatch(buffer1, 0, nRead1, buffer2, 0, nRead2);</span><br><span class="line">            if (i &gt; -1) &#123;</span><br><span class="line">                return totalRead + i;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nRead1 &lt; BUFFER_SIZE) &#123;</span><br><span class="line">                // we&#x27;ve reached the end of the files, but found no mismatch</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            totalRead += nRead1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回-1：同一文件，或者两个文件内容一样</li>
<li>返回其他数字：文件内容对比差异的位置，从0开始</li>
</ul>
<p><strong>所以，只要返回 -1，说明文件内容相同。</strong></p>
<p>好了，今天的分享就到这，记住了，别说我没告诉你。。</p>
<p>收藏转发一下吧，多学习了解，日后必定有用！</p>
<p>历史 Java 新特性干货分享：</p>
<p><img src="http://img.javastack.cn/20190613135450.png"><br><img src="http://img.javastack.cn/20190613135537.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java12/Java%2012%20%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%8C%20%E6%96%87%E4%BB%B6%E6%AF%94%E5%AF%B9%E5%B1%85%E7%84%B6%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9%EF%BC%81/" data-id="cmgrfxxde003s30d4gff7enpu" data-title="Java 12 骚操作， 文件比对居然还能这样玩！" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%B0%E7%89%B9%E6%80%A7/" rel="tag">新特性</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-新特性/Java9/Java9 简化流关闭新姿势" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java9/Java9%20%E7%AE%80%E5%8C%96%E6%B5%81%E5%85%B3%E9%97%AD%E6%96%B0%E5%A7%BF%E5%8A%BF/" class="article-date">
  <time class="dt-published" datetime="2025-10-15T03:36:33.000Z" itemprop="datePublished">2025-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java9/Java9%20%E7%AE%80%E5%8C%96%E6%B5%81%E5%85%B3%E9%97%AD%E6%96%B0%E5%A7%BF%E5%8A%BF/">Java9 简化流关闭新姿势</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="http://img.javastack.cn/18-2-27/87594869.jpg"></p>
<p>做Java开发的都知道，每个资源的打开都需要对应的关闭操作，不然就会使资源一直占用而造成资源浪费，从而降低系统性能。</p>
<p>关于资源的关闭操作，从JDK7-JDK9有了不少的提升及简化。</p>
<h4 id="JDK6"><a href="#JDK6" class="headerlink" title="JDK6"></a>JDK6</h4><p>在JDK6及之前，每个资源都需要我们手动写代码关闭，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = null;</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">try &#123;</span><br><span class="line">	fis = new FileInputStream(new File(&quot;E:\\Java技术.txt&quot;));</span><br><span class="line">	while (fis.read(buffer) &gt; 0) &#123;</span><br><span class="line">		System.out.println(new String(buffer));</span><br><span class="line">	&#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">	if (fis != null) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			fis.close();</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>资源打开使用完后，必须在finally块中进行手动关闭！我们有的同事，做一个查询功能点，打开了连接查询完后没有手动关闭，最后造成连接池超出最大连接数而使系统功能堵塞。</p>
<h4 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h4><p>JDK7发布后，添加了新特性：try-with-resources语句。所有需要关闭的资源只要实现了<code>java.lang.AutoCloseable</code>（java.io.Closeable就实现了这个接口）接口就在会程序结束后自动关闭。</p>
<p>如上面的读取文件的流程序用JDK7来写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">try (FileInputStream fis = new FileInputStream(new File(&quot;E:\\Java技术.txt&quot;))) &#123;</span><br><span class="line">	while (fis.read(buffer) &gt; 0) &#123;</span><br><span class="line">		System.out.println(new String(buffer));</span><br><span class="line">	&#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的资源在<code>try()</code>里面定义，并去掉了finally模块。</p>
<p>下面我们来写一个自定义的流来看看是否自动关闭了。</p>
<p><strong>定义一个自定义输入输出流</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class MyInputStream implements AutoCloseable &#123;</span><br><span class="line"></span><br><span class="line">	void read(String content) &#123;</span><br><span class="line">		System.out.println(&quot;read content &quot; + content);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void close() throws Exception &#123;</span><br><span class="line">		System.out.println(&quot;input stream is closed.&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyOutputStream implements AutoCloseable &#123;</span><br><span class="line"></span><br><span class="line">	void write(String content) &#123;</span><br><span class="line">		System.out.println(&quot;write content &quot; + content);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void close() throws Exception &#123;</span><br><span class="line">		System.out.println(&quot;out stream is closed.&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单个资源自动关闭</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try (MyInputStream mis = new MyInputStream()) &#123;</span><br><span class="line">	mis.read(&quot;7_2&quot;);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>read content 7_2<br>input stream is closed.</p>
</blockquote>
<p><strong>多个资源自动关闭</strong></p>
<p><code>try()</code>里面可以定义多个资源，它们的关闭顺序是最后在<code>try()</code>定义的资源先关闭。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try (MyInputStream mis = new MyInputStream(); MyOutputStream mos = new MyOutputStream()) &#123;</span><br><span class="line">	mis.read(&quot;7_3&quot;);</span><br><span class="line">	mos.write(&quot;7_3&quot;);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>read content 7_3<br>write content 7_3<br>out stream is closed.<br>input stream is closed.</p>
</blockquote>
<h4 id="JDK9"><a href="#JDK9" class="headerlink" title="JDK9"></a>JDK9</h4><p>JDK9发布后，又简化了try-with-resources语句的用法。</p>
<p><code>try()</code>里面可以是一个变量，但必须是final的或者等同final才行。如下面的mis，mos定义成局部变量可以不用final，局部变量可以等同于final，但定义成成员变量就必须是用final修饰的，不然会编译错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyInputStream mis = new MyInputStream();</span><br><span class="line">MyOutputStream mos = new MyOutputStream();</span><br><span class="line">try (mis; mos) &#123;</span><br><span class="line">	mis.read(&quot;1.9&quot;);</span><br><span class="line">	mos.write(&quot;1.9&quot;);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>read content 1.9<br>write content 1.9<br>out stream is closed.<br>input stream is closed.</p>
</blockquote>
<p>再来看个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Connection dbCon = DriverManager.getConnection(&quot;url&quot;, &quot;user&quot;, &quot;password&quot;);</span><br><span class="line">try (dbCon; ResultSet rs = dbCon.createStatement().executeQuery(&quot;select * from emp&quot;)) &#123;</span><br><span class="line">    while (rs.next()) &#123;</span><br><span class="line">        System.out.println(&quot;In loadDataFromDB() =====&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + rs.getString(1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">    System.out.println(&quot;Exception occurs while reading the data from DB -&gt;&quot; + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dbCon和rs都能被自动关闭。</p>
<p>JKD9虽然简化了，但感觉还是没有什么质的变化，实际用途我们可能不希望关心资源的关闭，或者在方法结束之后如果是局部变量它就能自动关闭。或许是我站的高度不够，官方有其他的考量，但JDK9的这一点变化还是非常有用的。</p>
<p>更多JDK9的新功能实战陆续更新，如果觉得有用，分享到朋友圈给更多的人吧！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java9/Java9%20%E7%AE%80%E5%8C%96%E6%B5%81%E5%85%B3%E9%97%AD%E6%96%B0%E5%A7%BF%E5%8A%BF/" data-id="cmgrfxxde003u30d435frc4y1" data-title="Java9 简化流关闭新姿势" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%B0%E7%89%B9%E6%80%A7/" rel="tag">新特性</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-新特性/Java8/Java8 之新特性扩展篇" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Java8%20%E4%B9%8B%E6%96%B0%E7%89%B9%E6%80%A7%E6%89%A9%E5%B1%95%E7%AF%87/" class="article-date">
  <time class="dt-published" datetime="2025-10-15T03:36:33.000Z" itemprop="datePublished">2025-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Java8%20%E4%B9%8B%E6%96%B0%E7%89%B9%E6%80%A7%E6%89%A9%E5%B1%95%E7%AF%87/">Java8 之新特性扩展篇</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>之前分篇章讲了一些JKD8中添加的新特性，还有一些新特性这里也一并讲下。</p>
<h2 id="BASE64"><a href="#BASE64" class="headerlink" title="BASE64"></a>BASE64</h2><p>base64编码解码已经被加入到了jdk8中了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.charset.StandardCharsets;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">public class Base64Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String text = &quot;hello javastack&quot;;</span><br><span class="line"></span><br><span class="line">		String encoded = Base64.getEncoder().encodeToString(text.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">		System.out.println(encoded);</span><br><span class="line"></span><br><span class="line">		String decoded = new String(Base64.getDecoder().decode(encoded), StandardCharsets.UTF_8);</span><br><span class="line">		System.out.println(decoded);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Date-Time-API-JSR-310"><a href="#Date-Time-API-JSR-310" class="headerlink" title="Date&#x2F;Time API(JSR 310)"></a>Date&#x2F;Time API(JSR 310)</h2><p>新的时间、日期。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Clock clock = Clock.systemUTC();</span><br><span class="line">System.out.println(clock.instant());</span><br><span class="line">System.out.println(clock.millis());</span><br></pre></td></tr></table></figure>


<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2017-09-06T07:26:18.541Z</span><br><span class="line">1504682778593</span><br></pre></td></tr></table></figure>

<p>可以代替<code>System.currentTimeMillis()</code>方法。</p>
<p>另外，可以看下LocalDate、LocalTime、LocalDateTime、Duration的用法。</p>
<h2 id="Nashorn-JavaScript引擎"><a href="#Nashorn-JavaScript引擎" class="headerlink" title="Nashorn JavaScript引擎"></a>Nashorn JavaScript引擎</h2><p>可以运行js代码的引擎。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ScriptEngineManager manager = new ScriptEngineManager();</span><br><span class="line">ScriptEngine engine = manager.getEngineByName(&quot;JavaScript&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(engine.getClass().getName());</span><br><span class="line">System.out.println(&quot;Result:&quot; + engine.eval(&quot;function f() &#123; return 10; &#125;; f() * 24;&quot;));</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jdk.nashorn.api.scripting.NashornScriptEngine</span><br><span class="line">Result:240.0</span><br></pre></td></tr></table></figure>

<h2 id="JVM内存取消永久代"><a href="#JVM内存取消永久代" class="headerlink" title="JVM内存取消永久代"></a>JVM内存取消永久代</h2><p>JDK8使用了Metaspace（JEP 122）替换永久代（PermGen space）。参数使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize。</p>
<p>还有一些别的新特性，个人觉得某些新特性用处不是很大。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Java8%20%E4%B9%8B%E6%96%B0%E7%89%B9%E6%80%A7%E6%89%A9%E5%B1%95%E7%AF%87/" data-id="cmgrfxxde003w30d448ie8wd3" data-title="Java8 之新特性扩展篇" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%B0%E7%89%B9%E6%80%A7/" rel="tag">新特性</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%89%B9%E6%80%A7/" rel="tag">新特性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E9%98%B6/" rel="tag">进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E5%90%88/" rel="tag">集合</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 18px;">基础</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 16px;">多线程</a> <a href="/tags/%E6%96%B0%E7%89%B9%E6%80%A7/" style="font-size: 20px;">新特性</a> <a href="/tags/%E8%BF%9B%E9%98%B6/" style="font-size: 14px;">进阶</a> <a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 12px;">集合</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/10/">October 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java%205%20~%2010%20%E6%96%B0%E7%89%B9%E6%80%A7%E5%80%BE%E6%83%85%E6%95%B4%E7%90%86%EF%BC%81/">Java 5 ~ 10 新特性倾情整理！</a>
          </li>
        
          <li>
            <a href="/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E4%B8%AD%E7%9A%84%206%20%E9%A2%97%E8%AF%AD%E6%B3%95%E7%B3%96/">Java 中的 6 颗语法糖</a>
          </li>
        
          <li>
            <a href="/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E4%B8%AD%E7%9A%84%20String%20%E7%9C%9F%E7%9A%84%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%90%97%EF%BC%9F/">Java 中的 String 真的是不可变吗？</a>
          </li>
        
          <li>
            <a href="/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E4%B8%AD%E7%9A%84%E4%BC%AA%E5%85%B1%E4%BA%AB%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">Java 中的伪共享详解及解决方案</a>
          </li>
        
          <li>
            <a href="/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E4%B8%AD%E7%9A%84%E5%AE%8F%E5%8F%98%E9%87%8F%EF%BC%8C%E5%AE%8F%E6%9B%BF%E6%8D%A2%E8%AF%A6%E8%A7%A3%E3%80%82/">Java 中的宏变量，宏替换详解。</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>