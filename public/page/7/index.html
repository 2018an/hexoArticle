<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-基础/字符串拼接 + 和 concat 的区别" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/14/%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%20+%20%E5%92%8C%20concat%20%E7%9A%84%E5%8C%BA%E5%88%AB/" class="article-date">
  <time class="dt-published" datetime="2025-10-14T06:42:34.000Z" itemprop="datePublished">2025-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/14/%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%20+%20%E5%92%8C%20concat%20%E7%9A%84%E5%8C%BA%E5%88%AB/">字符串拼接 + 和 concat 的区别</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>+和concat都可以用来拼接字符串，但在使用上有什么区别呢，先来看看这个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	// example1</span><br><span class="line">	String str1 = &quot;s1&quot;;</span><br><span class="line">	System.out.println(str1 + 100);//s1100</span><br><span class="line">	System.out.println(100 + str1);//100s1</span><br><span class="line"></span><br><span class="line">	String str2 = &quot;s2&quot;;</span><br><span class="line">	str2 = str2.concat(&quot;a&quot;).concat(&quot;bc&quot;);</span><br><span class="line">	System.out.println(str2);//s2abc</span><br><span class="line"></span><br><span class="line">	// example2</span><br><span class="line">	String str3 = &quot;s3&quot;;</span><br><span class="line">	System.out.println(str3 + null);//s3null</span><br><span class="line">	System.out.println(null + str3);//nulls3</span><br><span class="line"></span><br><span class="line">	String str4 = null;</span><br><span class="line">	System.out.println(str4.concat(&quot;a&quot;));//NullPointerException</span><br><span class="line">	System.out.println(&quot;a&quot;.concat(str4));//NullPointerException</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>concat源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public String concat(String str) &#123;</span><br><span class="line">    int otherLen = str.length();</span><br><span class="line">    if (otherLen == 0) &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    int len = value.length;</span><br><span class="line">    char buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    return new String(buf, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下生成的字节码：</p>
<h4 id="所以可以得出以下结论："><a href="#所以可以得出以下结论：" class="headerlink" title="所以可以得出以下结论："></a>所以可以得出以下结论：</h4><ol>
<li><p>+可以是字符串或者数字及其他基本类型数据，而concat只能接收字符串。</p>
</li>
<li><p>+左右可以为null，concat为会空指针。</p>
</li>
<li><p>如果拼接空字符串，concat会稍快，在速度上两者可以忽略不计，如果拼接更多字符串建议用StringBuilder。</p>
</li>
<li><p>从字节码来看+号编译后就是使用了StringBuiler来拼接，所以一行+++的语句就会创建一个StringBuilder，多条+++语句就会创建多个，所以为什么建议用StringBuilder的原因。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/14/%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%20+%20%E5%92%8C%20concat%20%E7%9A%84%E5%8C%BA%E5%88%AB/" data-id="cmgrfxxcx000w30d4gu5xckj7" data-title="字符串拼接 + 和 concat 的区别" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-基础/深入浅出 Java 中的包装类" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/14/%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Java%20%E4%B8%AD%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB/" class="article-date">
  <time class="dt-published" datetime="2025-10-14T06:42:34.000Z" itemprop="datePublished">2025-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/14/%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Java%20%E4%B8%AD%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB/">深入浅出 Java 中的包装类</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="http://img.javastack.cn/18-6-5/61544442.jpg"></p>
<h4 id="什么是包装类型"><a href="#什么是包装类型" class="headerlink" title="什么是包装类型"></a>什么是包装类型</h4><p>Java 设计当初就提供了 8 种 基本数据类型及对应的 8 种包装数据类型。我们知道 Java 是一种面向对象编程的高级语言，所以包装类型正是为了解决基本数据类型无法面向对象编程所提供的。</p>
<p><strong>下面是基本数据类型与对应的包装类型。</strong></p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类型</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<p><strong>下面是包装类型的继承结构图。</strong></p>
<p><img src="http://img.javastack.cn/18-6-5/80489463.jpg"></p>
<p>从以上图表可以对基本类型和包装类型有一个全面的了解。</p>
<h4 id="包装类应用场景"><a href="#包装类应用场景" class="headerlink" title="包装类应用场景"></a>包装类应用场景</h4><p><strong>1、集合类泛型只能是包装类；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 编译报错</span><br><span class="line">List&lt;int&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 正常</span><br><span class="line">List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>2、成员变量不能有默认值；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private int status;</span><br></pre></td></tr></table></figure>

<p>基本数据类型的成员变量都有默认值，如以上代码 status 默认值为 0，如果定义中 0 代表失败，那样就会有问题，这样只能使用包装类 Integer，它的默认值为 null,所以就不会有默认值影响。</p>
<p><strong>3、方法参数允许定义空值；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static void test1(int status)&#123;</span><br><span class="line">	System.out.println(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看以上代码，方法参数定义的是基本数据类型 int，所以必须得传一个数字过来，不能传 null，很多场合我们希望是能传递 null 的，所以这种场合用包装类比较合适。</p>
<p>还有更多应用场景就不一一例举了，欢迎留言共同探讨包装类的更多的应用场景。</p>
<h4 id="自动装箱、拆箱"><a href="#自动装箱、拆箱" class="headerlink" title="自动装箱、拆箱"></a>自动装箱、拆箱</h4><p>Java 5 增加了自动装箱、拆箱机制，提供基本数据类型和包装类型的相互转换操作。</p>
<p><strong>自动装箱</strong></p>
<p>自动装箱即自动将基本数据类型转换成包装类型，在 Java 5 之前，要将基本数据类型转换成包装类型只能这样做，看下面的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = new Integer(8);</span><br><span class="line"></span><br><span class="line">Integer i2 = Integer.valueOf(8);</span><br><span class="line"></span><br><span class="line">// 自动装箱</span><br><span class="line">Integer i3 = 8;</span><br></pre></td></tr></table></figure>

<p>以上 3 种都可以进行转换，但在 Java 5 之前第 3 种方法是编译失败的，第 3 种方法也正是现在的自动装箱功能。另外，第一种构造器方法也不推荐使用了，已经标为废弃了。</p>
<p>其实自动装箱的原理就是调用包装类的 valueOf 方法，如第 2 个方法中的 Integer.valueOf 方法。</p>
<p><strong>自动拆箱</strong></p>
<p>自动拆箱即自动将包装类型转换成基本数据类型，与自动装箱相反，有装就有拆，很好理解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 自动拆箱</span><br><span class="line">int i4 = i3;</span><br><span class="line"></span><br><span class="line">int i5 = i3.intValue();</span><br></pre></td></tr></table></figure>

<p>继续上面的例子，把 i3 赋值给 i4 就是实现的自动拆箱功能，自动装箱的原理就是调用包装类的 xxValue 方法，如 i5 中的 Integer 的 intValue 方法。</p>
<p>自动装箱、拆箱不只是体现在以上的例子，在方法接收参数、对象设置参数时都能自动装箱拆箱。</p>
<p><strong>需要注意的是，关于 Integer，-128 ~ 127 会有缓存，对比这个范围的值的对象是一个坑，这个在阿里巴巴规范中也有提及。</strong> 详细请参考《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/PnVkrMzYeOiepPKjl4MKVA">IntegerCache的妙用和陷阱</a>》这篇文章。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/14/%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Java%20%E4%B8%AD%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB/" data-id="cmgrfxxcx000y30d4er180veu" data-title="深入浅出 Java 中的包装类" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-基础/通用唯一标识码 UUID 的介绍及使用。" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/14/%E5%9F%BA%E7%A1%80/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%A0%81%20UUID%20%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E3%80%82/" class="article-date">
  <time class="dt-published" datetime="2025-10-14T06:42:34.000Z" itemprop="datePublished">2025-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/14/%E5%9F%BA%E7%A1%80/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%A0%81%20UUID%20%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E3%80%82/">通用唯一标识码 UUID 的介绍及使用。</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="什么是UUID？"><a href="#什么是UUID？" class="headerlink" title="什么是UUID？"></a>什么是UUID？</h4><p>UUID全称：Universally Unique Identifier，即通用唯一识别码。</p>
<p>UUID是由一组32位数的16进制数字所构成，是故UUID理论上的总数为16^32 &#x3D; 2^128，约等于3.4 x 10^38。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。</p>
<p>UUID的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的32个字符，如：550e8400-e29b-41d4-a716-446655440000。</p>
<h4 id="UUID的作用"><a href="#UUID的作用" class="headerlink" title="UUID的作用"></a>UUID的作用</h4><p>UUID的是让分布式系统中的所有元素都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。如此一来，每个人都可以创建不与其它人冲突的UUID。在这样的情况下，就不需考虑数据库创建时的名称重复问题。目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID），而其他重要的应用，则有Linux ext2&#x2F;ext3文件系统、LUKS加密分区、GNOME、KDE、Mac OS X等等。</p>
<h4 id="UUID的组成"><a href="#UUID的组成" class="headerlink" title="UUID的组成"></a>UUID的组成</h4><p>UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。</p>
<p><strong>UUID由以下几部分的组合：</strong></p>
<ul>
<li><p>当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。</p>
</li>
<li><p>时钟序列。</p>
</li>
<li><p>全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。</p>
</li>
</ul>
<p>UUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。</p>
<h4 id="UUID的生成"><a href="#UUID的生成" class="headerlink" title="UUID的生成"></a>UUID的生成</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">	System.out.println(UUID.randomUUID());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>批量生成UUID网站：<a target="_blank" rel="noopener" href="http://www.uuid.online/">http://www.uuid.online/</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/14/%E5%9F%BA%E7%A1%80/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%A0%81%20UUID%20%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E3%80%82/" data-id="cmgrfxxcy001030d41dtwe8ls" data-title="通用唯一标识码 UUID 的介绍及使用。" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-多线程/Java虚拟机对锁优化所做的努力" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E9%94%81%E4%BC%98%E5%8C%96%E6%89%80%E5%81%9A%E7%9A%84%E5%8A%AA%E5%8A%9B/" class="article-date">
  <time class="dt-published" datetime="2025-10-14T06:42:34.000Z" itemprop="datePublished">2025-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E9%94%81%E4%BC%98%E5%8C%96%E6%89%80%E5%81%9A%E7%9A%84%E5%8A%AA%E5%8A%9B/">Java虚拟机对锁优化所做的努力</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="http://img.javastack.cn/18-6-10/54034705.jpg"></p>
<p>作为一款公用平台，JDK 本身也为并发程序的性能绞尽脑汁，在 JDK 内部也想尽一切办法提供并发时的系统吞吐量。这里，我将向大家简单介绍几种 JDK 内部的 “锁” 优化策略。</p>
<h3 id="1、-锁偏向"><a href="#1、-锁偏向" class="headerlink" title="1、 锁偏向"></a>1、 锁偏向</h3><p>锁偏向是一种针对加锁操作的优化手段。</p>
<p>如果一个线程获得了锁，那么锁就进入偏向模式。当这个线程再次请求锁时，无须再做任何同步操作。这样就节省了大量有关锁申请的操作，从而提高了程序性能。因此，对于几乎没有锁竞争的场合，偏向锁有比较红啊的优化效果，因为连续多次极有可能是同一个线程请求相同的锁。而对于锁竞争比较激烈的场合，其效果不佳。因为在竞争激烈的场合，最有可能的情况是每次都是不同的线程来请求相同的锁。</p>
<h3 id="2、-轻量级锁"><a href="#2、-轻量级锁" class="headerlink" title="2、 轻量级锁"></a>2、 轻量级锁</h3><p>如果偏向锁失败，即上一个请求的锁的线程和这个线程不是同一个。偏向锁失败意味者不能避免做同步操作。此时，虚拟机并不会立即挂起线程。他会使用一种成为轻量级锁的优化手段。 轻量级锁的操作也很方便，它只是简单地将对象头部作为指针，指向蚩尤锁的线程堆栈的内部，来判断一个线程是否持有对象锁。 如果线程获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁失败，则表示其他线程抢先争夺了锁，那么当前线程的锁请求就会膨胀为重量级锁。</p>
<h3 id="3、-自选锁"><a href="#3、-自选锁" class="headerlink" title="3、 自选锁"></a>3、 自选锁</h3><p>锁膨胀后，虚拟机为了避免线程真实地在操作系统层面挂起，虚拟机还会在做最后的努力–自选锁。由于当前线程暂时无法获得锁，但是什么时候可以获得锁是一个未知数。也许在CPU几个时钟周期后，就可以得到锁。如果这样，简单粗暴的挂起线程可能是一种得不偿失的操作，因此系统会进行一次赌注：它会假设在不久的将来，线程可以得到这把锁。因此虚拟机让当前线程做个空循环，在经过若干次循环后，如果可以得到锁，那么就顺利进入临界区。如果还不能得到锁，才会真实地将线程在操作系统层面挂起。</p>
<h3 id="4、-锁消除"><a href="#4、-锁消除" class="headerlink" title="4、 锁消除"></a>4、 锁消除</h3><p>锁消除是一种更彻底的锁优化。Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。通过锁消除，可以节省毫无意义的请求锁时间。</p>
<p>下面这种这种情况，我们使用vector， 而vector内部使用了synchronize请求锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String []  createStrings()&#123;</span><br><span class="line">    Vector&lt;String&gt;  v= new Vector&lt;String&gt;();</span><br><span class="line">    for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">        v.add(Integer.toString(i));</span><br><span class="line">    &#125;</span><br><span class="line">    return v.toArray(new String[]&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于V只在函数 createStrnigs 中使用，因此它只是一个单纯的局部变量。局部变量是在线程栈上分配的，属于线程私有额数据，因此不可能被其他线程访问。所以，在这种情况下，Vector内部所有加锁同步都是没有必要的。如果虚拟机检测到这种情况，就会将这些无用的锁操作去除。</p>
<p>锁消除涉及的一项关键技术为逃逸分析。所谓逃逸分析就是观察某一个变量是否会逃出某一个作用域。在本例中，变量v显然没有逃出createString 函数之外。以此为基础，虚拟机才可以大胆的将v内部的加锁操作去除。如果createStrings 返回的不是String数组，而是v本身，那么就认为变量v逃逸出了当前函数，也就是说v有可能被其他线程访问。如是这样，虚拟机就不能消除v中的锁操作。</p>
<p>逃逸分析必须在 -server 模式下进行，可以使用 -XX:DoEscapeAnalysis 参数打开逃逸分析，使用 -XX:+EliminateLocks 参数可以打开锁消除。</p>
<p>本文摘自《Java高并发程序设计》一书。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E9%94%81%E4%BC%98%E5%8C%96%E6%89%80%E5%81%9A%E7%9A%84%E5%8A%AA%E5%8A%9B/" data-id="cmgrfxxcz001930d4bvnm9kvj" data-title="Java虚拟机对锁优化所做的努力" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-多线程/Synchronized 与 ReentrantLock 的区别！" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Synchronized%20%E4%B8%8E%20ReentrantLock%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%81/" class="article-date">
  <time class="dt-published" datetime="2025-10-14T06:42:34.000Z" itemprop="datePublished">2025-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Synchronized%20%E4%B8%8E%20ReentrantLock%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%81/">Synchronized 与 ReentrantLock 的区别！</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>可重入性：</strong></p>
<p>从名字上理解，ReenTrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程没进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
<p><strong>锁的实现：</strong></p>
<p>Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。</p>
<p><strong>性能的区别：</strong></p>
<p>在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。</p>
<p><strong>功能区别：</strong></p>
<p>便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。</p>
<p>锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized</p>
<p><strong>ReenTrantLock独有的能力：</strong></p>
<p>1.ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</p>
<p>2.ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</p>
<p>3.ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。</p>
<p><strong>ReenTrantLock实现的原理：</strong></p>
<p>在网上看到相关的源码分析，本来这块应该是本文的核心，但是感觉比较复杂就不一一详解了，简单来说，ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。</p>
<p><strong>什么情况下使用ReenTrantLock：</strong></p>
<p>答案是，如果你需要实现ReenTrantLock的三个独有功能时。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Synchronized%20%E4%B8%8E%20ReentrantLock%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%81/" data-id="cmgrfxxcz001b30d4cgc8ep6f" data-title="Synchronized 与 ReentrantLock 的区别！" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-多线程/Synchronized 有几种用法？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Synchronized%20%E6%9C%89%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2025-10-14T06:42:34.000Z" itemprop="datePublished">2025-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Synchronized%20%E6%9C%89%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95%EF%BC%9F/">Synchronized 有几种用法？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>我们都知道 Synchronized 是线程安全同步用的，大部分程序可能只会用到同步方法上面。其实 Synchronized 可以用到更多的场合，栈长列举了以下几个用法。</p>
<h2 id="1、同步普通方法"><a href="#1、同步普通方法" class="headerlink" title="1、同步普通方法"></a><strong>1、同步普通方法</strong></h2><p>这个也是我们用得最多的，只要涉及线程安全，上来就给方法来个同步锁。这种方法使用虽然最简单，但是只能作用在单例上面，如果不是单例，同步方法锁将失效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用在普通方法</span><br><span class="line"> */</span><br><span class="line">private synchronized void synchronizedMethod() &#123;</span><br><span class="line">	System.out.println(&quot;synchronizedMethod&quot;);</span><br><span class="line">	try &#123;</span><br><span class="line">		Thread.sleep(2000);</span><br><span class="line">	&#125; catch (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，同一个实例只有一个线程能获取锁进入这个方法。</p>
<h2 id="2、同步静态方法"><a href="#2、同步静态方法" class="headerlink" title="2、同步静态方法"></a>2、同步静态方法</h2><p>同步静态方法，不管你有多少个类实例，同时只有一个线程能获取锁进入这个方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用在静态方法</span><br><span class="line"> */</span><br><span class="line">private synchronized static void synchronizedStaticMethod() &#123;</span><br><span class="line">	System.out.println(&quot;synchronizedStaticMethod&quot;);</span><br><span class="line">	try &#123;</span><br><span class="line">		Thread.sleep(2000);</span><br><span class="line">	&#125; catch (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步静态方法是类级别的锁，一旦任何一个线程进入这个方法，其他所有线程将无法访问这个类的任何同步类锁的方法。</p>
<h2 id="3、同步类"><a href="#3、同步类" class="headerlink" title="3、同步类"></a>3、同步类</h2><p>下面提供了两种同步类的方法，锁住效果和同步静态方法一样，都是类级别的锁，同时只有一个线程能访问带有同步类锁的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用在类</span><br><span class="line"> */</span><br><span class="line">private void synchronizedClass() &#123;</span><br><span class="line">	synchronized (TestSynchronized.class) &#123;</span><br><span class="line">		System.out.println(&quot;synchronizedClass&quot;);</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(2000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 用在类</span><br><span class="line"> */</span><br><span class="line">private void synchronizedGetClass() &#123;</span><br><span class="line">	synchronized (this.getClass()) &#123;</span><br><span class="line">		System.out.println(&quot;synchronizedGetClass&quot;);</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(2000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的两种用法是同步块的用法，这里表示只有获取到这个类锁才能进入这个代码块。</p>
<h2 id="4、同步this实例"><a href="#4、同步this实例" class="headerlink" title="4、同步this实例"></a>4、同步this实例</h2><p>这也是同步块的用法，表示锁住整个当前对象实例，只有获取到这个实例的锁才能进入这个方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用在this</span><br><span class="line"> */</span><br><span class="line">private void synchronizedThis() &#123;</span><br><span class="line">	synchronized (this) &#123;</span><br><span class="line">		System.out.println(&quot;synchronizedThis&quot;);</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(2000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法和同步普通方法锁一样，都是锁住整个当前实例。</p>
<h2 id="5、同步对象实例"><a href="#5、同步对象实例" class="headerlink" title="5、同步对象实例"></a>5、同步对象实例</h2><p>这也是同步块的用法，和上面的锁住当前实例一样，这里表示锁住整个 LOCK 对象实例，只有获取到这个 LOCK 实例的锁才能进入这个方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用在对象</span><br><span class="line"> */</span><br><span class="line">private void synchronizedInstance() &#123;</span><br><span class="line">	synchronized (LOCK) &#123;</span><br><span class="line">		System.out.println(&quot;synchronizedInstance&quot;);</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(2000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，类锁与实例锁不相互阻塞，但相同的类锁，相同的当前实例锁，相同的对象锁会相互阻塞。</p>
<p>关于 Synchronized 的几种用法栈长就介绍到这里了，如果你还知道其他的用法，欢迎留言。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Synchronized%20%E6%9C%89%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95%EF%BC%9F/" data-id="cmgrfxxd0001e30d4gvy85ysk" data-title="Synchronized 有几种用法？" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-多线程/sleep( )和wait( )的这5个区别，你知道几个？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/sleep(%20)%E5%92%8Cwait(%20)%E7%9A%84%E8%BF%995%E4%B8%AA%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%87%A0%E4%B8%AA%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2025-10-14T06:42:34.000Z" itemprop="datePublished">2025-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/sleep(%20)%E5%92%8Cwait(%20)%E7%9A%84%E8%BF%995%E4%B8%AA%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%87%A0%E4%B8%AA%EF%BC%9F/">sleep( )和wait( )的这5个区别，你知道几个？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>sleep(休眠) 和 wait(等待) 方法是 Java 多线程中常用的两个方法，它们有什么区别及一些该注意的地方有哪些呢？下面给大家一一分解。</p>
<p>在之前的文章《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/at8NynjnYvqkFw61kn3Apg">Java多线程神器：join使用及原理</a>》介绍了，它其实用的是 wait 实现的线程等待。</p>
<h4 id="区别1：使用限制"><a href="#区别1：使用限制" class="headerlink" title="区别1：使用限制"></a>区别1：使用限制</h4><p>使用 sleep 方法可以让让当前线程休眠，时间一到当前线程继续往下执行，在任何地方都能使用，但需要捕获 InterruptedException 异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	Thread.sleep(3000L);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而使用 wait 方法则必须放在 synchronized 块里面，同样需要捕获 InterruptedException 异常，并且需要获取对象的锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">synchronized (lock)&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而且 wait 还需要额外的方法 notify&#x2F; notifyAll 进行唤醒，它们同样需要放在 synchronized 块里面，且获取对象的锁。。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">synchronized (lock) &#123;</span><br><span class="line">    // 随机唤醒</span><br><span class="line">    lock.notify();</span><br><span class="line">    </span><br><span class="line">    // 唤醒全部</span><br><span class="line">    lock.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然也可以使用带时间的 wait(long millis) 方法，时间一到，无需其他线程唤醒，也会重新竞争获取对象的锁继续执行。</p>
<h4 id="区别2：使用场景"><a href="#区别2：使用场景" class="headerlink" title="区别2：使用场景"></a>区别2：使用场景</h4><p>sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。</p>
<h4 id="区别3：所属类"><a href="#区别3：所属类" class="headerlink" title="区别3：所属类"></a>区别3：所属类</h4><p>sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。</p>
<blockquote>
<p>java.lang.Thread#sleep</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static native void sleep(long millis) throws InterruptedException;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>java.lang.Object#wait</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final native void wait(long timeout) throws InterruptedException;</span><br></pre></td></tr></table></figure>

<p><strong>为什么要这样设计呢？</strong></p>
<p>因为 sleep 是让当前线程休眠，不涉及到对象类，也不需要获得对象的锁，所以是线程类的方法。wait 是让获得对象锁的线程实现等待，前提是要楚获得对象的锁，所以是类的方法。</p>
<h4 id="区别4：释放锁"><a href="#区别4：释放锁" class="headerlink" title="区别4：释放锁"></a>区别4：释放锁</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Object lock = new Object();</span><br><span class="line">synchronized (lock) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        lock.wait(3000L);</span><br><span class="line">        Thread.sleep(2000L);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码所示，wait 可以释放当前线程对 lock 对象锁的持有，而 sleep 则不会。</p>
<h4 id="区别5：线程切换"><a href="#区别5：线程切换" class="headerlink" title="区别5：线程切换"></a>区别5：线程切换</h4><p>sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。</p>
<p>@程序猿 你们还知道别的吗？欢迎留言！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/sleep(%20)%E5%92%8Cwait(%20)%E7%9A%84%E8%BF%995%E4%B8%AA%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%87%A0%E4%B8%AA%EF%BC%9F/" data-id="cmgrfxxd1001i30d41oy6cfjy" data-title="sleep( )和wait( )的这5个区别，你知道几个？" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-多线程/一文搞懂 Java 线程中断" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%20Java%20%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/" class="article-date">
  <time class="dt-published" datetime="2025-10-14T06:42:34.000Z" itemprop="datePublished">2025-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%20Java%20%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/">一文搞懂 Java 线程中断</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	Thread.sleep(3000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时线程被打断后，代码会继续运行或者抛出异常结束运行，这并不是我们需要的中断线程的作用。</p>
<h4 id="到底是什么是线程中断？"><a href="#到底是什么是线程中断？" class="headerlink" title="到底是什么是线程中断？"></a>到底是什么是线程中断？</h4><p>线程中断即线程运行过程中被其他线程给打断了，它与 stop 最大的区别是：stop 是由系统强制终止线程，而线程中断则是给目标线程发送一个中断信号，如果目标线程没有接收线程中断的信号并结束线程，线程则不会终止，具体是否退出或者执行其他逻辑由目标线程决定。</p>
<p>我们来看下线程中断最重要的 3 个方法，它们都是来自 Thread 类！</p>
<p><strong>1、java.lang.Thread#interrupt</strong></p>
<p>中断目标线程，给目标线程发一个中断信号，线程被打上中断标记。</p>
<p><strong>2、java.lang.Thread#isInterrupted()</strong></p>
<p>判断目标线程是否被中断，不会清除中断标记。</p>
<p><strong>3、java.lang.Thread#interrupted</strong></p>
<p>判断目标线程是否被中断，会清除中断标记。</p>
<h4 id="线程中断实战"><a href="#线程中断实战" class="headerlink" title="线程中断实战"></a>线程中断实战</h4><p>我们来实例演示下线程中断如何用！</p>
<p><strong>示例1（中断失败）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">private static void test1() &#123;</span><br><span class="line">	Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			Thread.yield();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	thread.start();</span><br><span class="line">	thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问示例1中的线程会被中断吗？答案：不会，因为虽然给线程发出了中断信号，但程序中并没有响应中断信号的逻辑，所以程序不会有任何反应。</p>
<p><strong>示例2：（中断成功）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">private static void test2() &#123;</span><br><span class="line">	Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			Thread.yield();</span><br><span class="line"></span><br><span class="line">			// 响应中断</span><br><span class="line">			if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">				System.out.println(&quot;Java技术线程被中断，程序退出。&quot;);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	thread.start();</span><br><span class="line">	thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们给示例2加上了响应中断的逻辑，程序接收到中断信号打印出信息后返回退出。</p>
<p><strong>示例3（中断失败）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">private static void test3() throws InterruptedException &#123;</span><br><span class="line">	Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			// 响应中断</span><br><span class="line">			if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">				System.out.println(&quot;Java技术线程被中断，程序退出。&quot;);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(3000);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				System.out.println(&quot;Java技术线程休眠被中断，程序退出。&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	thread.start();</span><br><span class="line">	Thread.sleep(2000);</span><br><span class="line">	thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例3 sleep() 方法被中断，并输出了 <code>Java技术线程休眠被中断，程序退出。</code> 程序继续运行……为什么呢？</p>
<p>来看 sleep 的源码：</p>
<p><img src="http://img.javastack.cn/18-6-1/1779530.jpg"></p>
<p>可以看出 sleep() 方法被中断后会清除中断标记，所以循环会继续运行。。</p>
<p><strong>示例4（中断成功）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">private static void test4() throws InterruptedException &#123;</span><br><span class="line">	Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			// 响应中断</span><br><span class="line">			if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">				System.out.println(&quot;Java技术线程被中断，程序退出。&quot;);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(3000);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				System.out.println(&quot;Java技术线程休眠被中断，程序退出。&quot;);</span><br><span class="line">				Thread.currentThread().interrupt();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	thread.start();</span><br><span class="line">	Thread.sleep(2000);</span><br><span class="line">	thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例4全部信息输出并正常退出，只是在 sleep() 方法被中断并清除标记后手动重新中断当前线程，然后程序接收中断信号返回退出。</p>
<p>通过以上 4 个中断示例，相信对 Java 线程中断的概念有了全面的了解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%20Java%20%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/" data-id="cmgrfxxd1001k30d4ep0mbesi" data-title="一文搞懂 Java 线程中断" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-多线程/出场率比较高的一道多线程安全面试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%87%BA%E5%9C%BA%E7%8E%87%E6%AF%94%E8%BE%83%E9%AB%98%E7%9A%84%E4%B8%80%E9%81%93%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2025-10-14T06:42:34.000Z" itemprop="datePublished">2025-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%87%BA%E5%9C%BA%E7%8E%87%E6%AF%94%E8%BE%83%E9%AB%98%E7%9A%84%E4%B8%80%E9%81%93%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98/">出场率比较高的一道多线程安全面试题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>工作一两年的应该都知道 ArrayList 是线程不安全的，要使用线程安全的就使用 Vector，这也是各种 Java 面试宝典里面所提及的，可能很多工作好几年的程序员都停留在这个知识面上。</p>
<p>先说说为什么 ArrayList 是线程不安全的吧，来看以下的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public class TestArrayList &#123;</span><br><span class="line"></span><br><span class="line">	private static List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">			testList();</span><br><span class="line">			list.clear();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void testList() throws InterruptedException &#123;</span><br><span class="line">		Runnable runnable = () -&gt; &#123;</span><br><span class="line">			for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">				list.add(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		Thread t1 = new Thread(runnable);</span><br><span class="line">		Thread t2 = new Thread(runnable);</span><br><span class="line">		Thread t3 = new Thread(runnable);</span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line"></span><br><span class="line">		t1.join();</span><br><span class="line">		t2.join();</span><br><span class="line">		t3.join();</span><br><span class="line"></span><br><span class="line">		System.out.println(list.size());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是它的输出结果，我们期望的结果应该都是：30000，然后并不是，这就是传说中的多线程并发问题了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;Thread-1&quot; java.lang.ArrayIndexOutOfBoundsException: 15786</span><br><span class="line">	at java.base/java.util.ArrayList.add(ArrayList.java:468)</span><br><span class="line">	at java.base/java.util.ArrayList.add(ArrayList.java:480)</span><br><span class="line">	at com.test.thread.TestArrayList.lambda$testList$0(TestArrayList.java:23)</span><br><span class="line">	at java.base/java.lang.Thread.run(Thread.java:844)</span><br><span class="line">20332</span><br><span class="line">16100</span><br><span class="line">14941</span><br><span class="line">23749</span><br><span class="line">15631</span><br><span class="line">22118</span><br><span class="line">27417</span><br><span class="line">30000</span><br><span class="line">28691</span><br><span class="line">27843</span><br></pre></td></tr></table></figure>

<h4 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h4><p>从以上结果可以总结出 ArrayList 在并发情况下会出现的几种现象。</p>
<p><strong>1、发生 ArrayIndexOutOfBoundsException 异常；</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void add(E e, Object[] elementData, int s) &#123;</span><br><span class="line">    if (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    size = s + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定位到异常所在源代码，毫无疑问，问题是出现在多线程并发访问下，由于没有同步锁的保护，造成了 ArrayList 扩容不一致的问题。</p>
<p><strong>2、程序正常运行，输出了少于实际容量的大小；</strong></p>
<p>这个也是多线程并发赋值时，对同一个数组索引位置进行了赋值，所以出现少于预期大小的情况。</p>
<p><strong>3、程序正常运行，输出了预期容量的大小；</strong></p>
<p>这是正常运行结果，未发生多线程安全问题，但这是不确定性的，不是每次都会达到正常预期的。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>既然这样，那么在高并发情况下，使用什么样的列表集合保护线程安全呢？回到文章最开始的地方，使用 Vector，还有别的吗？当然有，篇幅有限，请各位看官期待后续文章。</p>
<p>另外，像 HashMap, HashSet 等都有类似多线程安全问题，在多线程并发环境下避免使用这种集合。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%87%BA%E5%9C%BA%E7%8E%87%E6%AF%94%E8%BE%83%E9%AB%98%E7%9A%84%E4%B8%80%E9%81%93%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="cmgrfxxd1001n30d48371gmnu" data-title="出场率比较高的一道多线程安全面试题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-多线程/到底什么是重入锁，拜托，一次搞清楚！" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%8C%E6%8B%9C%E6%89%98%EF%BC%8C%E4%B8%80%E6%AC%A1%E6%90%9E%E6%B8%85%E6%A5%9A%EF%BC%81/" class="article-date">
  <time class="dt-published" datetime="2025-10-14T06:42:34.000Z" itemprop="datePublished">2025-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%8C%E6%8B%9C%E6%89%98%EF%BC%8C%E4%B8%80%E6%AC%A1%E6%90%9E%E6%B8%85%E6%A5%9A%EF%BC%81/">到底什么是重入锁，拜托，一次搞清楚！</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="什么是重入锁"><a href="#什么是重入锁" class="headerlink" title="什么是重入锁"></a>什么是重入锁</h4><blockquote>
<p>java.util.concurrent.locks.ReentrantLock</p>
</blockquote>
<p>这个是 JDK @since 1.5 添加的一种颗粒度更小的锁，它完全可以替代 synchronized 关键字来实现它的所有功能，而且 ReentrantLock 锁的灵活度要远远大于 synchronized 关键字。</p>
<p><img src="http://img.javastack.cn/ReentrantLock.png"></p>
<p>从类结构图看出，ReentrantLock 实现了 Lock 接口，ReentrantLock 只是 Lock 接口的一个实现而已。</p>
<blockquote>
<p>java.util.concurrent.locks.Lock</p>
</blockquote>
<p>它们都是 java.util.concurrent 包里面的内容（俗称 JUC、并发包），也都是 JDK 1.5 开始加入的。</p>
<h4 id="为什么叫重入锁呢？"><a href="#为什么叫重入锁呢？" class="headerlink" title="为什么叫重入锁呢？"></a>为什么叫重入锁呢？</h4><p>ReentrantLock，我们把它拆开来看就明了了。</p>
<p>Re-Entrant-Lock：即表示可重新反复进入的锁，但仅限于当前线程；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void m() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">      // ... method body</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      lock.unlock()</span><br><span class="line">      lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如示例代码所示，当前线程可以反复加锁，但也需要释放同样加锁次数的锁，即重入了多少次，就要释放多少次，不然也会导入锁不被释放。</p>
<p>试想一下，如果不设计成可重入锁，那自己如果反复给自己加锁，不是会把自己加死锁了吗？所以，到现在，重入锁的概念大概应该清楚了吧？</p>
<h4 id="重入锁最重要的几个方法"><a href="#重入锁最重要的几个方法" class="headerlink" title="重入锁最重要的几个方法"></a>重入锁最重要的几个方法</h4><p>这几个方法都是 Lock 接口中定义的：</p>
<p><img src="http://img.javastack.cn/Lock.png"></p>
<p><strong>1）lock()</strong></p>
<p>获取锁，有以下三种情况：</p>
<ul>
<li>锁空闲：直接获取锁并返回，同时设置锁持有者数量为：1；</li>
<li>当前线程持有锁：直接获取锁并返回，同时锁持有者数量递增1；</li>
<li>其他线程持有锁：当前线程会休眠等待，直至获取锁为止；</li>
</ul>
<p><strong>2）lockInterruptibly()</strong></p>
<p>获取锁，逻辑和 lock() 方法一样，但这个方法在获取锁过程中能响应中断。</p>
<p><strong>3）tryLock()</strong></p>
<p>从关键字字面理解，这是在尝试获取锁，获取成功返回：true，获取失败返回：false, 这个方法不会等待，有以下三种情况：</p>
<ul>
<li>锁空闲：直接获取锁并返回：true，同时设置锁持有者数量为：1；</li>
<li>当前线程持有锁：直接获取锁并返回：true，同时锁持有者数量递增1；</li>
<li>其他线程持有锁：获取锁失败，返回：false；</li>
</ul>
<p><strong>4）tryLock(long timeout, TimeUnit unit)</strong></p>
<p>逻辑和 tryLock() 差不多，只是这个方法是带时间的。</p>
<p><strong>5）unlock()</strong></p>
<p>释放锁，每次锁持有者数量递减 1，直到 0 为止。所以，现在知道为什么 lock 多少次，就要对应 unlock 多少次了吧。</p>
<p><strong>6）newCondition</strong></p>
<p>返回一个这个锁的 Condition 实例，可以实现 synchronized 关键字类似 wait&#x2F; notify 实现多线程通信的功能，不过这个比 wait&#x2F; notify 要更灵活，更强大！</p>
<h4 id="重入锁大概的用法"><a href="#重入锁大概的用法" class="headerlink" title="重入锁大概的用法"></a>重入锁大概的用法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class X &#123;</span><br><span class="line"></span><br><span class="line">  private final ReentrantLock lock = new ReentrantLock();</span><br><span class="line">  </span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  public void m() &#123;</span><br><span class="line">    lock.lock();  // block until condition holds</span><br><span class="line">    try &#123;</span><br><span class="line">      // ... method body</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>看见没有，加锁和释放锁都在方法里面进行，可以自由控制，比 synchronized 更灵活，更方便。但要注意的是，释放锁操作必须在 finally 里面，不然如果出现异常导致锁不能被正常释放，进而会卡死后续所有访问该锁的线程。</p>
<h4 id="synchronized-是重入锁吗？"><a href="#synchronized-是重入锁吗？" class="headerlink" title="synchronized 是重入锁吗？"></a>synchronized 是重入锁吗？</h4><p>那么问题来了，synchronized 是重入锁吗？</p>
<p>你可能会说不是，因为 ReentrantLock 既然是重入锁，根据推理，相反，那 synchronized 肯定就不是重入锁，那你就错了。</p>
<p>答案是：yes，为什么？看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void operation()&#123;</span><br><span class="line">    add();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void add()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>operation 方法调用了 add 方法，两个方法都是用 synchronized 修饰的，add()  方法可以成功获取当前线程 operation() 方法已经获取到的锁，说明 synchronized 就是可重入锁。</p>
<p>面试常问的Synchronized的几种用法推荐看下这篇文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9h6VjHAmLA3twD6Y-FqfwA">Synchronized 有几种用法？</a>。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%8C%E6%8B%9C%E6%89%98%EF%BC%8C%E4%B8%80%E6%AC%A1%E6%90%9E%E6%B8%85%E6%A5%9A%EF%BC%81/" data-id="cmgrfxxd2001p30d420ys5rlf" data-title="到底什么是重入锁，拜托，一次搞清楚！" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/8/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag">基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B0%E7%89%B9%E6%80%A7/" rel="tag">新特性</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E9%98%B6/" rel="tag">进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E5%90%88/" rel="tag">集合</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 18px;">基础</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 16px;">多线程</a> <a href="/tags/%E6%96%B0%E7%89%B9%E6%80%A7/" style="font-size: 20px;">新特性</a> <a href="/tags/%E8%BF%9B%E9%98%B6/" style="font-size: 14px;">进阶</a> <a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 12px;">集合</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/10/">October 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java%205%20~%2010%20%E6%96%B0%E7%89%B9%E6%80%A7%E5%80%BE%E6%83%85%E6%95%B4%E7%90%86%EF%BC%81/">Java 5 ~ 10 新特性倾情整理！</a>
          </li>
        
          <li>
            <a href="/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E4%B8%AD%E7%9A%84%206%20%E9%A2%97%E8%AF%AD%E6%B3%95%E7%B3%96/">Java 中的 6 颗语法糖</a>
          </li>
        
          <li>
            <a href="/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E4%B8%AD%E7%9A%84%20String%20%E7%9C%9F%E7%9A%84%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%90%97%EF%BC%9F/">Java 中的 String 真的是不可变吗？</a>
          </li>
        
          <li>
            <a href="/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E4%B8%AD%E7%9A%84%E4%BC%AA%E5%85%B1%E4%BA%AB%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">Java 中的伪共享详解及解决方案</a>
          </li>
        
          <li>
            <a href="/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E4%B8%AD%E7%9A%84%E5%AE%8F%E5%8F%98%E9%87%8F%EF%BC%8C%E5%AE%8F%E6%9B%BF%E6%8D%A2%E8%AF%A6%E8%A7%A3%E3%80%82/">Java 中的宏变量，宏替换详解。</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>