<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>HashMap, ConcurrentHashMap 原理及源码 | 只有那年胜过年年</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#FC5531"><meta name="description" content="网上关于 HashMap 和 ConcurrentHashMap 的文章确实不少，不过缺斤少两的文章比较多，所以才想自己也写一篇，把细节说清楚说透，尤其像 Java8 中的 ConcurrentHashMap，大部分文章都说不清楚。终归是希望能降低大家学习的成本，不希望大家到处找各种不是很靠谱的文章，看完一篇又一篇，可是还是模模糊糊。 阅读建议： 四节基本上可以进行独立阅读，建议初学者可按照以下顺">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap, ConcurrentHashMap 原理及源码">
<meta property="og:url" content="http://example.com/2025/10/15/%E9%9B%86%E5%90%88/HashMap,%20ConcurrentHashMap%20%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81/index.html">
<meta property="og:site_name" content="只有那年胜过年年">
<meta property="og:description" content="网上关于 HashMap 和 ConcurrentHashMap 的文章确实不少，不过缺斤少两的文章比较多，所以才想自己也写一篇，把细节说清楚说透，尤其像 Java8 中的 ConcurrentHashMap，大部分文章都说不清楚。终归是希望能降低大家学习的成本，不希望大家到处找各种不是很靠谱的文章，看完一篇又一篇，可是还是模模糊糊。 阅读建议： 四节基本上可以进行独立阅读，建议初学者可按照以下顺">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/logo.png">
<meta property="article:published_time" content="2025-10-15T03:36:33.000Z">
<meta property="article:modified_time" content="2025-10-15T07:21:29.773Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="集合">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/logo.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "HashMap, ConcurrentHashMap 原理及源码",
  "url": "http://example.com/2025/10/15/%E9%9B%86%E5%90%88/HashMap,%20ConcurrentHashMap%20%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81/",
  "image": "http://example.com/img/logo.png",
  "datePublished": "2025-10-15T03:36:33.000Z",
  "dateModified": "2025-10-15T07:21:29.773Z",
  "author": [
    {
      "@type": "Person",
      "name": "John Doe",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/10/15/%E9%9B%86%E5%90%88/HashMap,%20ConcurrentHashMap%20%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#FC5531')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#FC5531')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: John Doe","link":"链接: ","source":"来源: 只有那年胜过年年","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HashMap, ConcurrentHashMap 原理及源码',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">357</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/logo.png" alt="Logo"><span class="site-name">只有那年胜过年年</span></a><a class="nav-page-title" href="/"><span class="site-name">HashMap, ConcurrentHashMap 原理及源码</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">HashMap, ConcurrentHashMap 原理及源码</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-15T03:36:33.000Z" title="发表于 2025-10-15 11:36:33">2025-10-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-15T07:21:29.773Z" title="更新于 2025-10-15 15:21:29">2025-10-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><p>网上关于 HashMap 和 ConcurrentHashMap 的文章确实不少，不过缺斤少两的文章比较多，所以才想自己也写一篇，把细节说清楚说透，尤其像 Java8 中的 ConcurrentHashMap，大部分文章都说不清楚。终归是希望能降低大家学习的成本，不希望大家到处找各种不是很靠谱的文章，看完一篇又一篇，可是还是模模糊糊。</p>
<p><strong>阅读建议：</strong> 四节基本上可以进行独立阅读，建议初学者可按照以下顺序进行阅读，可适当降低阅读门槛。</p>
<blockquote>
<p>Java7 HashMap -&gt; Java7 ConcurrentHashMap -&gt; Java8 HashMap -&gt; Java8 ConcurrentHashMap </p>
</blockquote>
<p><strong>阅读前提：</strong> 本文分析的是源码，所以至少读者要熟悉它们的接口使用，同时，对于并发，读者至少要知道 CAS、ReentrantLock、UNSAFE 操作这几个基本的知识，文中不会对这些知识进行介绍。Java8 用到了红黑树，不过本文不会进行展开，感兴趣的读者请自行查找相关资料。</p>
<h2 id="Java7-HashMap"><a href="#Java7-HashMap" class="headerlink" title="Java7 HashMap"></a>Java7 HashMap</h2><p>HashMap 是最简单的，一来我们非常熟悉，二来就是它不支持并发操作，所以源码也非常简单。</p>
<p>首先，我们用下面这张图来介绍 HashMap 的结构。</p>
<p><img src="http://qianniu.javastack.cn/18-12-4/65827660.jpg"></p>
<p>这个仅仅是示意图，因为没有考虑到数组要扩容的情况，具体的后面再说。</p>
<p>大方向上，HashMap 里面是一个<strong>数组</strong>，然后数组中每个元素是一个<strong>单向链表</strong>。</p>
<p>上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。</p>
<p>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</p>
<p>loadFactor：负载因子，默认为 0.75。</p>
<p>threshold：扩容的阈值，等于 capacity * loadFactor</p>
<h4 id="put-过程分析"><a href="#put-过程分析" class="headerlink" title="put 过程分析"></a>put 过程分析</h4><p>还是比较简单的，跟着代码走一遍吧。</p>
<pre class="line-numbers language-none"><code class="language-none">public V put(K key, V value) &#123;
    &#x2F;&#x2F; 当插入第一个元素的时候，需要先初始化数组大小
    if (table &#x3D;&#x3D; EMPTY_TABLE) &#123;
        inflateTable(threshold);
    &#125;
    &#x2F;&#x2F; 如果 key 为 null，感兴趣的可以往里看，最终会将这个 entry 放到 table[0] 中
    if (key &#x3D;&#x3D; null)
        return putForNullKey(value);
    &#x2F;&#x2F; 1. 求 key 的 hash 值
    int hash &#x3D; hash(key);
    &#x2F;&#x2F; 2. 找到对应的数组下标
    int i &#x3D; indexFor(hash, table.length);
    &#x2F;&#x2F; 3. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在，
    &#x2F;&#x2F;    如果有，直接覆盖，put 方法返回旧值就结束了
    for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;
        Object k;
        if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))) &#123;
            V oldValue &#x3D; e.value;
            e.value &#x3D; value;
            e.recordAccess(this);
            return oldValue;
        &#125;
    &#125;
 
    modCount++;
    &#x2F;&#x2F; 4. 不存在重复的 key，将此 entry 添加到链表中，细节后面说
    addEntry(hash, key, value, i);
    return null;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h6 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h6><p>在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值。</p>
<pre class="line-numbers language-none"><code class="language-none">private void inflateTable(int toSize) &#123;
    &#x2F;&#x2F; 保证数组大小一定是 2 的 n 次方。
    &#x2F;&#x2F; 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32
    int capacity &#x3D; roundUpToPowerOf2(toSize);
    &#x2F;&#x2F; 计算扩容阈值：capacity * loadFactor
    threshold &#x3D; (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
    &#x2F;&#x2F; 算是初始化数组吧
    table &#x3D; new Entry[capacity];
    initHashSeedAsNeeded(capacity); &#x2F;&#x2F;ignore
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里有一个将数组大小保持为 2 的 n 次方的做法，Java7 和 Java8 的 HashMap 和 ConcurrentHashMap 都有相应的要求，只不过实现的代码稍微有些不同，后面再看到的时候就知道了。</p>
<h6 id="计算具体数组位置"><a href="#计算具体数组位置" class="headerlink" title="计算具体数组位置"></a>计算具体数组位置</h6><p>这个简单，我们自己也能 YY 一个：使用 key 的 hash 值对数组长度进行取模就可以了。</p>
<pre class="line-numbers language-none"><code class="language-none">static int indexFor(int hash, int length) &#123;
    &#x2F;&#x2F; assert Integer.bitCount(length) &#x3D;&#x3D; 1 : &quot;length must be a non-zero power of 2&quot;;
    return hash &amp; (length-1);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。</p>
<h6 id="添加节点到链表中"><a href="#添加节点到链表中" class="headerlink" title="添加节点到链表中"></a>添加节点到链表中</h6><p>找到数组下标后，会先进行 key 判重，如果没有重复，就准备将新值放入到链表的表头。</p>
<pre class="line-numbers language-none"><code class="language-none">void addEntry(int hash, K key, V value, int bucketIndex) &#123;
    &#x2F;&#x2F; 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容
    if ((size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[bucketIndex])) &#123;
        &#x2F;&#x2F; 扩容，后面会介绍一下
        resize(2 * table.length);
        &#x2F;&#x2F; 扩容以后，重新计算 hash 值
        hash &#x3D; (null !&#x3D; key) ? hash(key) : 0;
        &#x2F;&#x2F; 重新计算扩容后的新的下标
        bucketIndex &#x3D; indexFor(hash, table.length);
    &#125;
    &#x2F;&#x2F; 往下看
    createEntry(hash, key, value, bucketIndex);
&#125;

&#x2F;&#x2F; 这个很简单，其实就是将新值放到链表的表头，然后 size++
void createEntry(int hash, K key, V value, int bucketIndex) &#123;
    Entry&lt;K,V&gt; e &#x3D; table[bucketIndex];
    table[bucketIndex] &#x3D; new Entry&lt;&gt;(hash, key, value, e);
    size++;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。</p>
<h6 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h6><p>前面我们看到，在插入新值的时候，如果当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。</p>
<pre class="line-numbers language-none"><code class="language-none">void resize(int newCapacity) &#123;
    Entry[] oldTable &#x3D; table;
    int oldCapacity &#x3D; oldTable.length;
    if (oldCapacity &#x3D;&#x3D; MAXIMUM_CAPACITY) &#123;
        threshold &#x3D; Integer.MAX_VALUE;
        return;
    &#125;
    &#x2F;&#x2F; 新的数组
    Entry[] newTable &#x3D; new Entry[newCapacity];
    &#x2F;&#x2F; 将原来数组中的值迁移到新的更大的数组中
    transfer(newTable, initHashSeedAsNeeded(newCapacity));
    table &#x3D; newTable;
    threshold &#x3D; (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</p>
<p>由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。代码比较简单，这里就不展开了。</p>
<h4 id="get-过程分析"><a href="#get-过程分析" class="headerlink" title="get 过程分析"></a>get 过程分析</h4><p>相对于 put 过程，get 过程是非常简单的。</p>
<ol>
<li>根据 key 计算 hash 值。</li>
<li>找到相应的数组下标：hash &amp; (length – 1)。</li>
<li>遍历该数组位置处的链表，直到找到相等(&#x3D;&#x3D;或equals)的 key。</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">public V get(Object key) &#123;
    &#x2F;&#x2F; 之前说过，key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了
    if (key &#x3D;&#x3D; null)
        return getForNullKey();
    &#x2F;&#x2F; 
    Entry&lt;K,V&gt; entry &#x3D; getEntry(key);
 
    return null &#x3D;&#x3D; entry ? null : entry.getValue();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>getEntry(key):</p>
<pre class="line-numbers language-none"><code class="language-none">final Entry&lt;K,V&gt; getEntry(Object key) &#123;
    if (size &#x3D;&#x3D; 0) &#123;
        return null;
    &#125;
 
    int hash &#x3D; (key &#x3D;&#x3D; null) ? 0 : hash(key);
    &#x2F;&#x2F; 确定数组下标，然后从头开始遍历链表，直到找到为止
    for (Entry&lt;K,V&gt; e &#x3D; table[indexFor(hash, table.length)];
         e !&#x3D; null;
         e &#x3D; e.next) &#123;
        Object k;
        if (e.hash &#x3D;&#x3D; hash &amp;&amp;
            ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))
            return e;
    &#125;
    return null;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Java7-ConcurrentHashMap"><a href="#Java7-ConcurrentHashMap" class="headerlink" title="Java7 ConcurrentHashMap"></a>Java7 ConcurrentHashMap</h2><p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。</p>
<p>整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为<strong>分段锁</strong>。注意，行文中，我很多地方用了 <strong>“槽”</strong> 来代表一个 segment。</p>
<p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。推荐阅读：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0CI9od4DIxRrmOGFJw0SuQ">史上最全 Java 多线程面试题及答案</a>。</p>
<p><img src="http://qianniu.javastack.cn/18-12-4/75121838.jpg"></p>
<p><strong>concurrencyLevel：</strong> 并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</p>
<p>再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。推荐阅读：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/5Y5_6qn2g6kIVmQia_0R6g">几种线程安全的Map解析</a>。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>initialCapacity：初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。</p>
<p>loadFactor：负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。</p>
<pre class="line-numbers language-none"><code class="language-none">public ConcurrentHashMap(int initialCapacity,
                         float loadFactor, int concurrencyLevel) &#123;
    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0)
        throw new IllegalArgumentException();
    if (concurrencyLevel &gt; MAX_SEGMENTS)
        concurrencyLevel &#x3D; MAX_SEGMENTS;
    &#x2F;&#x2F; Find power-of-two sizes best matching arguments
    int sshift &#x3D; 0;
    int ssize &#x3D; 1;
    &#x2F;&#x2F; 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方
    while (ssize &lt; concurrencyLevel) &#123;
        ++sshift;
        ssize &lt;&lt;&#x3D; 1;
    &#125;
    &#x2F;&#x2F; 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4
    &#x2F;&#x2F; 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值
    this.segmentShift &#x3D; 32 - sshift;
    this.segmentMask &#x3D; ssize - 1;
 
    if (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity &#x3D; MAXIMUM_CAPACITY;
 
    &#x2F;&#x2F; initialCapacity 是设置整个 map 初始的大小，
    &#x2F;&#x2F; 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小
    &#x2F;&#x2F; 如 initialCapacity 为 64，那么每个 Segment 或称之为&quot;槽&quot;可以分到 4 个
    int c &#x3D; initialCapacity &#x2F; ssize;
    if (c * ssize &lt; initialCapacity)
        ++c;
    &#x2F;&#x2F; 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，
    &#x2F;&#x2F; 插入一个元素不至于扩容，插入第二个的时候才会扩容
    int cap &#x3D; MIN_SEGMENT_TABLE_CAPACITY; 
    while (cap &lt; c)
        cap &lt;&lt;&#x3D; 1;
 
    &#x2F;&#x2F; 创建 Segment 数组，
    &#x2F;&#x2F; 并创建数组的第一个元素 segment[0]
    Segment&lt;K,V&gt; s0 &#x3D;
        new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),
                         (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);
    Segment&lt;K,V&gt;[] ss &#x3D; (Segment&lt;K,V&gt;[])new Segment[ssize];
    &#x2F;&#x2F; 往数组写入 segment[0]
    UNSAFE.putOrderedObject(ss, SBASE, s0); &#x2F;&#x2F; ordered write of segments[0]
    this.segments &#x3D; ss;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>初始化完成，我们得到了一个 Segment 数组。</p>
<p>我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后：</p>
<ul>
<li>Segment 数组长度为 16，不可以扩容</li>
<li>Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容</li>
<li>这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍</li>
<li>当前 segmentShift 的值为 32 – 4 &#x3D; 28，segmentMask 为 16 – 1 &#x3D; 15，姑且把它们简单翻译为移位数和掩码，这两个值马上就会用到。</li>
</ul>
<h4 id="put-过程分析-1"><a href="#put-过程分析-1" class="headerlink" title="put 过程分析"></a>put 过程分析</h4><p>我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。</p>
<pre class="line-numbers language-none"><code class="language-none">public V put(K key, V value) &#123;
    Segment&lt;K,V&gt; s;
    if (value &#x3D;&#x3D; null)
        throw new NullPointerException();
    &#x2F;&#x2F; 1. 计算 key 的 hash 值
    int hash &#x3D; hash(key);
    &#x2F;&#x2F; 2. 根据 hash 值找到 Segment 数组中的位置 j
    &#x2F;&#x2F;    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下低 4 位，
    &#x2F;&#x2F;    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的最后 4 位，也就是槽的数组下标
    int j &#x3D; (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;
    &#x2F;&#x2F; 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，
    &#x2F;&#x2F; ensureSegment(j) 对 segment[j] 进行初始化
    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObject          &#x2F;&#x2F; nonvolatile; recheck
         (segments, (j &lt;&lt; SSHIFT) + SBASE)) &#x3D;&#x3D; null) &#x2F;&#x2F;  in ensureSegment
        s &#x3D; ensureSegment(j);
    &#x2F;&#x2F; 3. 插入新值到 槽 s 中
    return s.put(key, hash, value, false);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。</p>
<p>Segment 内部是由 <strong>数组+链表</strong> 组成的。</p>
<pre class="line-numbers language-none"><code class="language-none">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;
    &#x2F;&#x2F; 在往该 segment 写入前，需要先获取该 segment 的独占锁
    &#x2F;&#x2F;    先看主流程，后面还会具体介绍这部分内容
    HashEntry&lt;K,V&gt; node &#x3D; tryLock() ? null :
        scanAndLockForPut(key, hash, value);
    V oldValue;
    try &#123;
        &#x2F;&#x2F; 这个是 segment 内部的数组
        HashEntry&lt;K,V&gt;[] tab &#x3D; table;
        &#x2F;&#x2F; 再利用 hash 值，求应该放置的数组下标
        int index &#x3D; (tab.length - 1) &amp; hash;
        &#x2F;&#x2F; first 是数组该位置处的链表的表头
        HashEntry&lt;K,V&gt; first &#x3D; entryAt(tab, index);
 
        &#x2F;&#x2F; 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况
        for (HashEntry&lt;K,V&gt; e &#x3D; first;;) &#123;
            if (e !&#x3D; null) &#123;
                K k;
                if ((k &#x3D; e.key) &#x3D;&#x3D; key ||
                    (e.hash &#x3D;&#x3D; hash &amp;&amp; key.equals(k))) &#123;
                    oldValue &#x3D; e.value;
                    if (!onlyIfAbsent) &#123;
                        &#x2F;&#x2F; 覆盖旧值
                        e.value &#x3D; value;
                        ++modCount;
                    &#125;
                    break;
                &#125;
                &#x2F;&#x2F; 继续顺着链表走
                e &#x3D; e.next;
            &#125;
            else &#123;
                &#x2F;&#x2F; node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。
                &#x2F;&#x2F; 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。
                if (node !&#x3D; null)
                    node.setNext(first);
                else
                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, first);
 
                int c &#x3D; count + 1;
                &#x2F;&#x2F; 如果超过了该 segment 的阈值，这个 segment 需要扩容
                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)
                    rehash(node); &#x2F;&#x2F; 扩容后面也会具体分析
                else
                    &#x2F;&#x2F; 没有达到阈值，将 node 放到数组 tab 的 index 位置，
                    &#x2F;&#x2F; 其实就是将新的节点设置成原链表的表头
                    setEntryAt(tab, index, node);
                ++modCount;
                count &#x3D; c;
                oldValue &#x3D; null;
                break;
            &#125;
        &#125;
    &#125; finally &#123;
        &#x2F;&#x2F; 解锁
        unlock();
    &#125;
    return oldValue;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。</p>
<p>到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。</p>
<h6 id="初始化槽-ensureSegment"><a href="#初始化槽-ensureSegment" class="headerlink" title="初始化槽: ensureSegment"></a>初始化槽: ensureSegment</h6><p>ConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。</p>
<p>这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。</p>
<pre class="line-numbers language-none"><code class="language-none">private Segment&lt;K,V&gt; ensureSegment(int k) &#123;
    final Segment&lt;K,V&gt;[] ss &#x3D; this.segments;
    long u &#x3D; (k &lt;&lt; SSHIFT) + SBASE; &#x2F;&#x2F; raw offset
    Segment&lt;K,V&gt; seg;
    if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) &#x3D;&#x3D; null) &#123;
        &#x2F;&#x2F; 这里看到为什么之前要初始化 segment[0] 了，
        &#x2F;&#x2F; 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]
        &#x2F;&#x2F; 为什么要用“当前”，因为 segment[0] 可能早就扩容过了
        Segment&lt;K,V&gt; proto &#x3D; ss[0];
        int cap &#x3D; proto.table.length;
        float lf &#x3D; proto.loadFactor;
        int threshold &#x3D; (int)(cap * lf);
 
        &#x2F;&#x2F; 初始化 segment[k] 内部的数组
        HashEntry&lt;K,V&gt;[] tab &#x3D; (HashEntry&lt;K,V&gt;[])new HashEntry[cap];
        if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))
            &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 再次检查一遍该槽是否被其他线程初始化了。
 
            Segment&lt;K,V&gt; s &#x3D; new Segment&lt;K,V&gt;(lf, threshold, tab);
            &#x2F;&#x2F; 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出
            while ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))
                   &#x3D;&#x3D; null) &#123;
                if (UNSAFE.compareAndSwapObject(ss, u, null, seg &#x3D; s))
                    break;
            &#125;
        &#125;
    &#125;
    return seg;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>总的来说，ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。</p>
<blockquote>
<p>如果当前线程 CAS 失败，这里的 while 循环是为了将 seg 赋值返回。</p>
</blockquote>
<h6 id="获取写入锁-scanAndLockForPut"><a href="#获取写入锁-scanAndLockForPut" class="headerlink" title="获取写入锁: scanAndLockForPut"></a>获取写入锁: scanAndLockForPut</h6><p>前面我们看到，在往某个 segment 中 put 的时候，首先会调用 node &#x3D; tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。</p>
<p>下面我们来具体分析这个方法中是怎么控制加锁的。</p>
<pre class="line-numbers language-none"><code class="language-none">private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;
    HashEntry&lt;K,V&gt; first &#x3D; entryForHash(this, hash);
    HashEntry&lt;K,V&gt; e &#x3D; first;
    HashEntry&lt;K,V&gt; node &#x3D; null;
    int retries &#x3D; -1; &#x2F;&#x2F; negative while locating node
 
    &#x2F;&#x2F; 循环获取锁
    while (!tryLock()) &#123;
        HashEntry&lt;K,V&gt; f; &#x2F;&#x2F; to recheck first below
        if (retries &lt; 0) &#123;
            if (e &#x3D;&#x3D; null) &#123;
                if (node &#x3D;&#x3D; null) &#x2F;&#x2F; speculatively create node
                    &#x2F;&#x2F; 进到这里说明数组该位置的链表是空的，没有任何元素
                    &#x2F;&#x2F; 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置
                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, null);
                retries &#x3D; 0;
            &#125;
            else if (key.equals(e.key))
                retries &#x3D; 0;
            else
                &#x2F;&#x2F; 顺着链表往下走
                e &#x3D; e.next;
        &#125;
        &#x2F;&#x2F; 重试次数如果超过 MAX_SCAN_RETRIES（单核1多核64），那么不抢了，进入到阻塞队列等待锁
        &#x2F;&#x2F;    lock() 是阻塞方法，直到获取锁后返回
        else if (++retries &gt; MAX_SCAN_RETRIES) &#123;
            lock();
            break;
        &#125;
        else if ((retries &amp; 1) &#x3D;&#x3D; 0 &amp;&amp;
                 &#x2F;&#x2F; 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头
                 &#x2F;&#x2F;     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法
                 (f &#x3D; entryForHash(this, hash)) !&#x3D; first) &#123;
            e &#x3D; first &#x3D; f; &#x2F;&#x2F; re-traverse if entry changed
            retries &#x3D; -1;
        &#125;
    &#125;
    return node;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。</p>
<p>这个方法就是看似复杂，但是其实就是做了一件事，那就是<strong>获取该 segment 的独占锁</strong>，如果需要的话顺便实例化了一下 node。</p>
<h6 id="扩容-rehash"><a href="#扩容-rehash" class="headerlink" title="扩容: rehash"></a>扩容: rehash</h6><p>重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry[] 进行扩容，扩容后，容量为原来的 2 倍。</p>
<p>首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。</p>
<p>该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。
private void rehash(HashEntry&lt;K,V&gt; node) &#123;
    HashEntry&lt;K,V&gt;[] oldTable &#x3D; table;
    int oldCapacity &#x3D; oldTable.length;
    &#x2F;&#x2F; 2 倍
    int newCapacity &#x3D; oldCapacity &lt;&lt; 1;
    threshold &#x3D; (int)(newCapacity * loadFactor);
    &#x2F;&#x2F; 创建新数组
    HashEntry&lt;K,V&gt;[] newTable &#x3D;
        (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];
    &#x2F;&#x2F; 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’
    int sizeMask &#x3D; newCapacity - 1;
 
    &#x2F;&#x2F; 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置
    for (int i &#x3D; 0; i &lt; oldCapacity ; i++) &#123;
        &#x2F;&#x2F; e 是链表的第一个元素
        HashEntry&lt;K,V&gt; e &#x3D; oldTable[i];
        if (e !&#x3D; null) &#123;
            HashEntry&lt;K,V&gt; next &#x3D; e.next;
            &#x2F;&#x2F; 计算应该放置在新数组中的位置，
            &#x2F;&#x2F; 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 &#x3D; 19
            int idx &#x3D; e.hash &amp; sizeMask;
            if (next &#x3D;&#x3D; null)   &#x2F;&#x2F; 该位置处只有一个元素，那比较好办
                newTable[idx] &#x3D; e;
            else &#123; &#x2F;&#x2F; Reuse consecutive sequence at same slot
                &#x2F;&#x2F; e 是链表表头
                HashEntry&lt;K,V&gt; lastRun &#x3D; e;
                &#x2F;&#x2F; idx 是当前链表的头结点 e 的新位置
                int lastIdx &#x3D; idx;
 
                &#x2F;&#x2F; 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的
                for (HashEntry&lt;K,V&gt; last &#x3D; next;
                     last !&#x3D; null;
                     last &#x3D; last.next) &#123;
                    int k &#x3D; last.hash &amp; sizeMask;
                    if (k !&#x3D; lastIdx) &#123;
                        lastIdx &#x3D; k;
                        lastRun &#x3D; last;
                    &#125;
                &#125;
                &#x2F;&#x2F; 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置
                newTable[lastIdx] &#x3D; lastRun;
                &#x2F;&#x2F; 下面的操作是处理 lastRun 之前的节点，
                &#x2F;&#x2F;    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中
                for (HashEntry&lt;K,V&gt; p &#x3D; e; p !&#x3D; lastRun; p &#x3D; p.next) &#123;
                    V v &#x3D; p.value;
                    int h &#x3D; p.hash;
                    int k &#x3D; h &amp; sizeMask;
                    HashEntry&lt;K,V&gt; n &#x3D; newTable[k];
                    newTable[k] &#x3D; new HashEntry&lt;K,V&gt;(h, p.key, v, n);
                &#125;
            &#125;
        &#125;
    &#125;
    &#x2F;&#x2F; 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部
    int nodeIndex &#x3D; node.hash &amp; sizeMask; &#x2F;&#x2F; add the new node
    node.setNext(newTable[nodeIndex]);
    newTable[nodeIndex] &#x3D; node;
    table &#x3D; newTable;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢？</p>
<p>仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。</p>
<p>我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。<strong>不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1&#x2F;6 的节点需要克隆。</strong></p>
<h4 id="get-过程分析-1"><a href="#get-过程分析-1" class="headerlink" title="get 过程分析"></a>get 过程分析</h4><p>相对于 put 来说，get 真的不要太简单。</p>
<ol>
<li>计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”</li>
<li>槽中也是一个数组，根据 hash 找到数组中具体的位置</li>
<li>到这里是链表了，顺着链表进行查找即可</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">public V get(Object key) &#123;
    Segment&lt;K,V&gt; s; &#x2F;&#x2F; manually integrate access methods to reduce overhead
    HashEntry&lt;K,V&gt;[] tab;
    &#x2F;&#x2F; 1. hash 值
    int h &#x3D; hash(key);
    long u &#x3D; (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;
    &#x2F;&#x2F; 2. 根据 hash 找到对应的 segment
    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) !&#x3D; null &amp;&amp;
        (tab &#x3D; s.table) !&#x3D; null) &#123;
        &#x2F;&#x2F; 3. 找到segment 内部数组相应位置的链表，遍历
        for (HashEntry&lt;K,V&gt; e &#x3D; (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile
                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);
             e !&#x3D; null; e &#x3D; e.next) &#123;
            K k;
            if ((k &#x3D; e.key) &#x3D;&#x3D; key || (e.hash &#x3D;&#x3D; h &amp;&amp; key.equals(k)))
                return e.value;
        &#125;
    &#125;
    return null;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="并发问题分析"><a href="#并发问题分析" class="headerlink" title="并发问题分析"></a>并发问题分析</h4><p>现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。</p>
<p>添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。推荐阅读：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Q5F604CUM_0x2co9mvADxw">30 个 Java 集合面试问题及答案</a>。</p>
<ul>
<li><strong>put 操作的线程安全性</strong></li>
</ul>
<ol>
<li>初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。</li>
<li>添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。</li>
<li>扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。</li>
</ol>
<ul>
<li><strong>remove 操作的线程安全性</strong></li>
</ul>
<p>remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。</p>
<p>get 操作需要遍历链表，但是 remove 操作会”破坏”链表。</p>
<p>如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。</p>
<p>如果 remove 先破坏了一个节点，分两种情况考虑。</p>
<p>1、如果此节点是头结点，那么需要将头结点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。</p>
<p>2、如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。推荐阅读：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0CI9od4DIxRrmOGFJw0SuQ">史上最全 Java 多线程面试题及答案</a>。</p>
<h2 id="Java8-HashMap"><a href="#Java8-HashMap" class="headerlink" title="Java8 HashMap"></a>Java8 HashMap</h2><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 <strong>数组+链表+红黑树</strong> 组成。</p>
<p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 **O(n)**。</p>
<p>为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p>
<p>来一张图简单示意一下吧：</p>
<p><img src="http://qianniu.javastack.cn/18-12-4/75398751.jpg"></p>
<blockquote>
<p>注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。</p>
</blockquote>
<p>下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。</p>
<p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 <strong>Node</strong>，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 <strong>TreeNode</strong>。</p>
<p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。推荐阅读：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Q5F604CUM_0x2co9mvADxw">30 个 Java 集合面试问题及答案</a>。</p>
<h4 id="put-过程分析-2"><a href="#put-过程分析-2" class="headerlink" title="put 过程分析"></a>put 过程分析</h4><pre class="line-numbers language-none"><code class="language-none">public V put(K key, V value) &#123;
    return putVal(hash(key), key, value, false, true);
&#125;
 
&#x2F;&#x2F; 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作
&#x2F;&#x2F; 第四个参数 evict 我们这里不关心
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    &#x2F;&#x2F; 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度
    &#x2F;&#x2F; 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量
    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)
        n &#x3D; (tab &#x3D; resize()).length;
    &#x2F;&#x2F; 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了
    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)
        tab[i] &#x3D; newNode(hash, key, value, null);
 
    else &#123;&#x2F;&#x2F; 数组该位置有数据
        Node&lt;K,V&gt; e; K k;
        &#x2F;&#x2F; 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点
        if (p.hash &#x3D;&#x3D; hash &amp;&amp;
            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))
            e &#x3D; p;
        &#x2F;&#x2F; 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树
        else if (p instanceof TreeNode)
            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        else &#123;
            &#x2F;&#x2F; 到这里，说明数组该位置上是一个链表
            for (int binCount &#x3D; 0; ; ++binCount) &#123;
                &#x2F;&#x2F; 插入到链表的最后面(Java7 是插入到链表的最前面)
                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;
                    p.next &#x3D; newNode(hash, key, value, null);
                    &#x2F;&#x2F; TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 9 个
                    &#x2F;&#x2F; 会触发下面的 treeifyBin，也就是将链表转换为红黑树
                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                &#125;
                &#x2F;&#x2F; 如果在该链表中找到了&quot;相等&quot;的 key(&#x3D;&#x3D; 或 equals)
                if (e.hash &#x3D;&#x3D; hash &amp;&amp;
                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))
                    &#x2F;&#x2F; 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node
                    break;
                p &#x3D; e;
            &#125;
        &#125;
        &#x2F;&#x2F; e!&#x3D;null 说明存在旧值的key与要插入的key&quot;相等&quot;
        &#x2F;&#x2F; 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值
        if (e !&#x3D; null) &#123;
            V oldValue &#x3D; e.value;
            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)
                e.value &#x3D; value;
            afterNodeAccess(e);
            return oldValue;
        &#125;
    &#125;
    ++modCount;
    &#x2F;&#x2F; 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。</p>
<h6 id="数组扩容-1"><a href="#数组扩容-1" class="headerlink" title="数组扩容"></a>数组扩容</h6><p>resize() 方法用于<strong>初始化数组或数组扩容</strong>，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p>
<pre class="line-numbers language-none"><code class="language-none">final Node&lt;K,V&gt;[] resize() &#123;
    Node&lt;K,V&gt;[] oldTab &#x3D; table;
    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;
    int oldThr &#x3D; threshold;
    int newCap, newThr &#x3D; 0;
    if (oldCap &gt; 0) &#123; &#x2F;&#x2F; 对应数组扩容
        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;
            threshold &#x3D; Integer.MAX_VALUE;
            return oldTab;
        &#125;
        &#x2F;&#x2F; 将数组大小扩大一倍
        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)
            &#x2F;&#x2F; 将阈值扩大一倍
            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold
    &#125;
    else if (oldThr &gt; 0) &#x2F;&#x2F; 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候
        newCap &#x3D; oldThr;
    else &#123;&#x2F;&#x2F; 对应使用 new HashMap() 初始化后，第一次 put 的时候
        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;
        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    &#125;
 
    if (newThr &#x3D;&#x3D; 0) &#123;
        float ft &#x3D; (float)newCap * loadFactor;
        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    &#125;
    threshold &#x3D; newThr;
 
    &#x2F;&#x2F; 用新的数组大小初始化新的数组
    Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];
    table &#x3D; newTab; &#x2F;&#x2F; 如果是初始化数组，到这里就结束了，返回 newTab 即可
 
    if (oldTab !&#x3D; null) &#123;
        &#x2F;&#x2F; 开始遍历原数组，进行数据迁移。
        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;
            Node&lt;K,V&gt; e;
            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;
                oldTab[j] &#x3D; null;
                &#x2F;&#x2F; 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了
                if (e.next &#x3D;&#x3D; null)
                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;
                &#x2F;&#x2F; 如果是红黑树，具体我们就不展开了
                else if (e instanceof TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                else &#123; 
                    &#x2F;&#x2F; 这块是处理链表的情况，
                    &#x2F;&#x2F; 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序
                    &#x2F;&#x2F; loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的
                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;
                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;
                    Node&lt;K,V&gt; next;
                    do &#123;
                        next &#x3D; e.next;
                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;
                            if (loTail &#x3D;&#x3D; null)
                                loHead &#x3D; e;
                            else
                                loTail.next &#x3D; e;
                            loTail &#x3D; e;
                        &#125;
                        else &#123;
                            if (hiTail &#x3D;&#x3D; null)
                                hiHead &#x3D; e;
                            else
                                hiTail.next &#x3D; e;
                            hiTail &#x3D; e;
                        &#125;
                    &#125; while ((e &#x3D; next) !&#x3D; null);
                    if (loTail !&#x3D; null) &#123;
                        loTail.next &#x3D; null;
                        &#x2F;&#x2F; 第一条链表
                        newTab[j] &#x3D; loHead;
                    &#125;
                    if (hiTail !&#x3D; null) &#123;
                        hiTail.next &#x3D; null;
                        &#x2F;&#x2F; 第二条链表的新的位置是 j + oldCap，这个很好理解
                        newTab[j + oldCap] &#x3D; hiHead;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    return newTab;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="get-过程分析-2"><a href="#get-过程分析-2" class="headerlink" title="get 过程分析"></a>get 过程分析</h4><p>相对于 put 来说，get 真的太简单了。</p>
<ol>
<li>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</li>
<li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</li>
<li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</li>
<li>遍历链表，直到找到相等(&#x3D;&#x3D;或equals)的 key.</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">public V get(Object key) &#123;
    Node&lt;K,V&gt; e;
    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;
        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;
        &#x2F;&#x2F; 判断第一个节点是不是就是需要的
        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node
            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))
            return first;
        if ((e &#x3D; first.next) !&#x3D; null) &#123;
            &#x2F;&#x2F; 判断是否是红黑树
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
 
            &#x2F;&#x2F; 链表遍历
            do &#123;
                if (e.hash &#x3D;&#x3D; hash &amp;&amp;
                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))
                    return e;
            &#125; while ((e &#x3D; e.next) !&#x3D; null);
        &#125;
    &#125;
    return null;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Java8-ConcurrentHashMap"><a href="#Java8-ConcurrentHashMap" class="headerlink" title="Java8 ConcurrentHashMap"></a>Java8 ConcurrentHashMap</h2><p>Java7 中实现的 ConcurrentHashMap 说实话还是比较复杂的，Java8 对 ConcurrentHashMap 进行了比较大的改动。建议读者可以参考 Java8 中 HashMap 相对于 Java7 HashMap 的改动，对于 ConcurrentHashMap，Java8 也引入了红黑树。</p>
<p>说实话，Java8 ConcurrentHashMap 源码真心不简单，最难的在于扩容，数据迁移操作不容易看懂。</p>
<p>我们先用一个示意图来描述下其结构：</p>
<p><img src="http://qianniu.javastack.cn/18-12-4/335817.jpg"></p>
<p>结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。推荐阅读：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/5Y5_6qn2g6kIVmQia_0R6g">几种线程安全的Map解析</a>。</p>
<h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 这构造函数里，什么都不干
public ConcurrentHashMap() &#123;
&#125;
public ConcurrentHashMap(int initialCapacity) &#123;
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException();
    int cap &#x3D; ((initialCapacity &gt;&#x3D; (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?
               MAXIMUM_CAPACITY :
               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));
    this.sizeCtl &#x3D; cap;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl &#x3D; 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。</p>
<p>sizeCtl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。</p>
<p>如果你爱折腾，也可以看下另一个有三个参数的构造方法，这里我就不说了，大部分时候，我们会使用无参构造函数进行实例化，我们也按照这个思路来进行源码分析吧。</p>
<h4 id="put-过程分析-3"><a href="#put-过程分析-3" class="headerlink" title="put 过程分析"></a>put 过程分析</h4><p>仔细地一行一行代码看下去：</p>
<pre class="line-numbers language-none"><code class="language-none">public V put(K key, V value) &#123;
    return putVal(key, value, false);
&#125;
final V putVal(K key, V value, boolean onlyIfAbsent) &#123;
    if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();
    &#x2F;&#x2F; 得到 hash 值
    int hash &#x3D; spread(key.hashCode());
    &#x2F;&#x2F; 用于记录相应链表的长度
    int binCount &#x3D; 0;
    for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;
        Node&lt;K,V&gt; f; int n, i, fh;
        &#x2F;&#x2F; 如果数组&quot;空&quot;，进行数组初始化
        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)
            &#x2F;&#x2F; 初始化数组，后面会详细介绍
            tab &#x3D; initTable();
 
        &#x2F;&#x2F; 找该 hash 值对应的数组下标，得到第一个节点 f
        else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;
            &#x2F;&#x2F; 如果数组该位置为空，
            &#x2F;&#x2F;    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了
            &#x2F;&#x2F;          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了
            if (casTabAt(tab, i, null,
                         new Node&lt;K,V&gt;(hash, key, value, null)))
                break;                   &#x2F;&#x2F; no lock when adding to empty bin
        &#125;
        &#x2F;&#x2F; hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容
        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)
            &#x2F;&#x2F; 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了
            tab &#x3D; helpTransfer(tab, f);
 
        else &#123; &#x2F;&#x2F; 到这里就是说，f 是该位置的头结点，而且不为空
 
            V oldVal &#x3D; null;
            &#x2F;&#x2F; 获取数组该位置的头结点的监视器锁
            synchronized (f) &#123;
                if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;
                    if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 头结点的 hash 值大于 0，说明是链表
                        &#x2F;&#x2F; 用于累加，记录链表的长度
                        binCount &#x3D; 1;
                        &#x2F;&#x2F; 遍历链表
                        for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;
                            K ek;
                            &#x2F;&#x2F; 如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了
                            if (e.hash &#x3D;&#x3D; hash &amp;&amp;
                                ((ek &#x3D; e.key) &#x3D;&#x3D; key ||
                                 (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;
                                oldVal &#x3D; e.val;
                                if (!onlyIfAbsent)
                                    e.val &#x3D; value;
                                break;
                            &#125;
                            &#x2F;&#x2F; 到了链表的最末端，将这个新值放到链表的最后面
                            Node&lt;K,V&gt; pred &#x3D; e;
                            if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;
                                pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,
                                                          value, null);
                                break;
                            &#125;
                        &#125;
                    &#125;
                    else if (f instanceof TreeBin) &#123; &#x2F;&#x2F; 红黑树
                        Node&lt;K,V&gt; p;
                        binCount &#x3D; 2;
                        &#x2F;&#x2F; 调用红黑树的插值方法插入新节点
                        if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                       value)) !&#x3D; null) &#123;
                            oldVal &#x3D; p.val;
                            if (!onlyIfAbsent)
                                p.val &#x3D; value;
                        &#125;
                    &#125;
                &#125;
            &#125;
            &#x2F;&#x2F; binCount !&#x3D; 0 说明上面在做链表操作
            if (binCount !&#x3D; 0) &#123;
                &#x2F;&#x2F; 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8
                if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)
                    &#x2F;&#x2F; 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，
                    &#x2F;&#x2F; 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树
                    &#x2F;&#x2F;    具体源码我们就不看了，扩容部分后面说
                    treeifyBin(tab, i);
                if (oldVal !&#x3D; null)
                    return oldVal;
                break;
            &#125;
        &#125;
    &#125;
    &#x2F;&#x2F; 
    addCount(1L, binCount);
    return null;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>put 的主流程看完了，但是至少留下了几个问题，第一个是初始化，第二个是扩容，第三个是帮助数据迁移，这些我们都会在后面进行一一介绍。</p>
<h6 id="初始化数组：initTable"><a href="#初始化数组：initTable" class="headerlink" title="初始化数组：initTable"></a>初始化数组：initTable</h6><p>这个比较简单，主要就是初始化一个合适大小的数组，然后会设置 sizeCtl。</p>
<p>初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。</p>
<pre class="line-numbers language-none"><code class="language-none">private final Node&lt;K,V&gt;[] initTable() &#123;
    Node&lt;K,V&gt;[] tab; int sc;
    while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;
        &#x2F;&#x2F; 初始化的&quot;功劳&quot;被其他线程&quot;抢去&quot;了
        if ((sc &#x3D; sizeCtl) &lt; 0)
            Thread.yield(); &#x2F;&#x2F; lost initialization race; just spin
        &#x2F;&#x2F; CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;
            try &#123;
                if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;
                    &#x2F;&#x2F; DEFAULT_CAPACITY 默认初始容量是 16
                    int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;
                    &#x2F;&#x2F; 初始化数组，长度为 16 或初始化时提供的长度
                    Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];
                    &#x2F;&#x2F; 将这个数组赋值给 table，table 是 volatile 的
                    table &#x3D; tab &#x3D; nt;
                    &#x2F;&#x2F; 如果 n 为 16 的话，那么这里 sc &#x3D; 12
                    &#x2F;&#x2F; 其实就是 0.75 * n
                    sc &#x3D; n - (n &gt;&gt;&gt; 2);
                &#125;
            &#125; finally &#123;
                &#x2F;&#x2F; 设置 sizeCtl 为 sc，我们就当是 12 吧
                sizeCtl &#x3D; sc;
            &#125;
            break;
        &#125;
    &#125;
    return tab;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h6 id="链表转红黑树-treeifyBin"><a href="#链表转红黑树-treeifyBin" class="headerlink" title="链表转红黑树: treeifyBin"></a>链表转红黑树: treeifyBin</h6><p>前面我们在 put 源码分析也说过，treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。</p>
<pre class="line-numbers language-none"><code class="language-none">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;
    Node&lt;K,V&gt; b; int n, sc;
    if (tab !&#x3D; null) &#123;
        &#x2F;&#x2F; MIN_TREEIFY_CAPACITY 为 64
        &#x2F;&#x2F; 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容
        if ((n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)
            &#x2F;&#x2F; 后面我们再详细分析这个方法
            tryPresize(n &lt;&lt; 1);
        &#x2F;&#x2F; b 是头结点
        else if ((b &#x3D; tabAt(tab, index)) !&#x3D; null &amp;&amp; b.hash &gt;&#x3D; 0) &#123;
            &#x2F;&#x2F; 加锁
            synchronized (b) &#123;
 
                if (tabAt(tab, index) &#x3D;&#x3D; b) &#123;
                    &#x2F;&#x2F; 下面就是遍历链表，建立一颗红黑树
                    TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;
                    for (Node&lt;K,V&gt; e &#x3D; b; e !&#x3D; null; e &#x3D; e.next) &#123;
                        TreeNode&lt;K,V&gt; p &#x3D;
                            new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,
                                              null, null);
                        if ((p.prev &#x3D; tl) &#x3D;&#x3D; null)
                            hd &#x3D; p;
                        else
                            tl.next &#x3D; p;
                        tl &#x3D; p;
                    &#125;
                    &#x2F;&#x2F; 将红黑树设置到数组相应位置中
                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));
                &#125;
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h4 id="扩容：tryPresize"><a href="#扩容：tryPresize" class="headerlink" title="扩容：tryPresize"></a>扩容：tryPresize</h4><p>如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。</p>
<p>这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。</p>
<p>这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了
private final void tryPresize(int size) &#123;
    &#x2F;&#x2F; c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。
    int c &#x3D; (size &gt;&#x3D; (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :
        tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);
    int sc;
    while ((sc &#x3D; sizeCtl) &gt;&#x3D; 0) &#123;
        Node&lt;K,V&gt;[] tab &#x3D; table; int n;
 
        &#x2F;&#x2F; 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码
        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0) &#123;
            n &#x3D; (sc &gt; c) ? sc : c;
            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;
                try &#123;
                    if (table &#x3D;&#x3D; tab) &#123;
                        @SuppressWarnings(&quot;unchecked&quot;)
                        Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];
                        table &#x3D; nt;
                        sc &#x3D; n - (n &gt;&gt;&gt; 2); &#x2F;&#x2F; 0.75 * n
                    &#125;
                &#125; finally &#123;
                    sizeCtl &#x3D; sc;
                &#125;
            &#125;
        &#125;
        else if (c &lt;&#x3D; sc || n &gt;&#x3D; MAXIMUM_CAPACITY)
            break;
        else if (tab &#x3D;&#x3D; table) &#123;
            &#x2F;&#x2F; 我没看懂 rs 的真正含义是什么，不过也关系不大
            int rs &#x3D; resizeStamp(n);
 
            if (sc &lt; 0) &#123;
                Node&lt;K,V&gt;[] nt;
                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||
                    sc &#x3D;&#x3D; rs + MAX_RESIZERS || (nt &#x3D; nextTable) &#x3D;&#x3D; null ||
                    transferIndex &lt;&#x3D; 0)
                    break;
                &#x2F;&#x2F; 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法
                &#x2F;&#x2F;    此时 nextTab 不为 null
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                    transfer(tab, nt);
            &#125;
            &#x2F;&#x2F; 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)
            &#x2F;&#x2F;     我是没看懂这个值真正的意义是什么？不过可以计算出来的是，结果是一个比较大的负数
            &#x2F;&#x2F;  调用 transfer 方法，此时 nextTab 参数为 null
            else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))
                transfer(tab, null);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。</p>
<p>所以，可能的操作就是执行 **1 次 transfer(tab, null) + 多次 transfer(tab, nt)**，这里怎么结束循环的需要看完 transfer 源码才清楚。推荐阅读：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Q5F604CUM_0x2co9mvADxw">30 个 Java 集合面试问题及答案</a>。</p>
<h6 id="数据迁移：transfer"><a href="#数据迁移：transfer" class="headerlink" title="数据迁移：transfer"></a>数据迁移：transfer</h6><p>下面这个方法很点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。</p>
<p>虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。</p>
<p>此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。</p>
<p>阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 stride，简单理解就是步长，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。</p>
<p>第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后从后往前的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。</p>
<pre class="line-numbers language-none"><code class="language-none">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;
    int n &#x3D; tab.length, stride;
 
    &#x2F;&#x2F; stride 在单核下直接等于 n，多核模式下为 (n&gt;&gt;&gt;3)&#x2F;NCPU，最小值是 16
    &#x2F;&#x2F; stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，
    &#x2F;&#x2F;   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务
    if ((stride &#x3D; (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) &#x2F; NCPU : n) &lt; MIN_TRANSFER_STRIDE)
        stride &#x3D; MIN_TRANSFER_STRIDE; &#x2F;&#x2F; subdivide range
 
    &#x2F;&#x2F; 如果 nextTab 为 null，先进行一次初始化
    &#x2F;&#x2F;    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null
    &#x2F;&#x2F;       之后参与迁移的线程调用此方法时，nextTab 不会为 null
    if (nextTab &#x3D;&#x3D; null) &#123;
        try &#123;
            &#x2F;&#x2F; 容量翻倍
            Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];
            nextTab &#x3D; nt;
        &#125; catch (Throwable ex) &#123;      &#x2F;&#x2F; try to cope with OOME
            sizeCtl &#x3D; Integer.MAX_VALUE;
            return;
        &#125;
        &#x2F;&#x2F; nextTable 是 ConcurrentHashMap 中的属性
        nextTable &#x3D; nextTab;
        &#x2F;&#x2F; transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置
        transferIndex &#x3D; n;
    &#125;
 
    int nextn &#x3D; nextTab.length;
 
    &#x2F;&#x2F; ForwardingNode 翻译过来就是正在被迁移的 Node
    &#x2F;&#x2F; 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED
    &#x2F;&#x2F; 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，
    &#x2F;&#x2F;    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了
    &#x2F;&#x2F;    所以它其实相当于是一个标志。
    ForwardingNode&lt;K,V&gt; fwd &#x3D; new ForwardingNode&lt;K,V&gt;(nextTab);
 
 
    &#x2F;&#x2F; advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了
    boolean advance &#x3D; true;
    boolean finishing &#x3D; false; &#x2F;&#x2F; to ensure sweep before committing nextTab
 
    &#x2F;*
     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看
     * 
     *&#x2F;
 
    &#x2F;&#x2F; i 是位置索引，bound 是边界，注意是从后往前
    for (int i &#x3D; 0, bound &#x3D; 0;;) &#123;
        Node&lt;K,V&gt; f; int fh;
 
        &#x2F;&#x2F; 下面这个 while 真的是不好理解
        &#x2F;&#x2F; advance 为 true 表示可以进行下一个位置的迁移了
        &#x2F;&#x2F;   简单理解结局：i 指向了 transferIndex，bound 指向了 transferIndex-stride
        while (advance) &#123;
            int nextIndex, nextBound;
            if (--i &gt;&#x3D; bound || finishing)
                advance &#x3D; false;
 
            &#x2F;&#x2F; 将 transferIndex 值赋给 nextIndex
            &#x2F;&#x2F; 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了
            else if ((nextIndex &#x3D; transferIndex) &lt;&#x3D; 0) &#123;
                i &#x3D; -1;
                advance &#x3D; false;
            &#125;
            else if (U.compareAndSwapInt
                     (this, TRANSFERINDEX, nextIndex,
                      nextBound &#x3D; (nextIndex &gt; stride ?
                                   nextIndex - stride : 0))) &#123;
                &#x2F;&#x2F; 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前
                bound &#x3D; nextBound;
                i &#x3D; nextIndex - 1;
                advance &#x3D; false;
            &#125;
        &#125;
        if (i &lt; 0 || i &gt;&#x3D; n || i + n &gt;&#x3D; nextn) &#123;
            int sc;
            if (finishing) &#123;
                &#x2F;&#x2F; 所有的迁移操作已经完成
                nextTable &#x3D; null;
                &#x2F;&#x2F; 将新的 nextTab 赋值给 table 属性，完成迁移
                table &#x3D; nextTab;
                &#x2F;&#x2F; 重新计算 sizeCtl：n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍
                sizeCtl &#x3D; (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);
                return;
            &#125;
 
            &#x2F;&#x2F; 之前我们说过，sizeCtl 在迁移前会设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2
            &#x2F;&#x2F; 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，
            &#x2F;&#x2F; 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务
            if (U.compareAndSwapInt(this, SIZECTL, sc &#x3D; sizeCtl, sc - 1)) &#123;
                &#x2F;&#x2F; 任务结束，方法退出
                if ((sc - 2) !&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)
                    return;
 
                &#x2F;&#x2F; 到这里，说明 (sc - 2) &#x3D;&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，
                &#x2F;&#x2F; 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing)&#123;&#125; 分支了
                finishing &#x3D; advance &#x3D; true;
                i &#x3D; n; &#x2F;&#x2F; recheck before commit
            &#125;
        &#125;
        &#x2F;&#x2F; 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“
        else if ((f &#x3D; tabAt(tab, i)) &#x3D;&#x3D; null)
            advance &#x3D; casTabAt(tab, i, null, fwd);
        &#x2F;&#x2F; 该位置处是一个 ForwardingNode，代表该位置已经迁移过了
        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)
            advance &#x3D; true; &#x2F;&#x2F; already processed
        else &#123;
            &#x2F;&#x2F; 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作
            synchronized (f) &#123;
                if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;
                    Node&lt;K,V&gt; ln, hn;
                    &#x2F;&#x2F; 头结点的 hash 大于 0，说明是链表的 Node 节点
                    if (fh &gt;&#x3D; 0) &#123;
                        &#x2F;&#x2F; 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，
                        &#x2F;&#x2F; 需要将链表一分为二，
                        &#x2F;&#x2F;   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的
                        &#x2F;&#x2F;   lastRun 之前的节点需要进行克隆，然后分到两个链表中
                        int runBit &#x3D; fh &amp; n;
                        Node&lt;K,V&gt; lastRun &#x3D; f;
                        for (Node&lt;K,V&gt; p &#x3D; f.next; p !&#x3D; null; p &#x3D; p.next) &#123;
                            int b &#x3D; p.hash &amp; n;
                            if (b !&#x3D; runBit) &#123;
                                runBit &#x3D; b;
                                lastRun &#x3D; p;
                            &#125;
                        &#125;
                        if (runBit &#x3D;&#x3D; 0) &#123;
                            ln &#x3D; lastRun;
                            hn &#x3D; null;
                        &#125;
                        else &#123;
                            hn &#x3D; lastRun;
                            ln &#x3D; null;
                        &#125;
                        for (Node&lt;K,V&gt; p &#x3D; f; p !&#x3D; lastRun; p &#x3D; p.next) &#123;
                            int ph &#x3D; p.hash; K pk &#x3D; p.key; V pv &#x3D; p.val;
                            if ((ph &amp; n) &#x3D;&#x3D; 0)
                                ln &#x3D; new Node&lt;K,V&gt;(ph, pk, pv, ln);
                            else
                                hn &#x3D; new Node&lt;K,V&gt;(ph, pk, pv, hn);
                        &#125;
                        &#x2F;&#x2F; 其中的一个链表放在新数组的位置 i
                        setTabAt(nextTab, i, ln);
                        &#x2F;&#x2F; 另一个链表放在新数组的位置 i+n
                        setTabAt(nextTab, i + n, hn);
                        &#x2F;&#x2F; 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，
                        &#x2F;&#x2F;    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了
                        setTabAt(tab, i, fwd);
                        &#x2F;&#x2F; advance 设置为 true，代表该位置已经迁移完毕
                        advance &#x3D; true;
                    &#125;
                    else if (f instanceof TreeBin) &#123;
                        &#x2F;&#x2F; 红黑树的迁移
                        TreeBin&lt;K,V&gt; t &#x3D; (TreeBin&lt;K,V&gt;)f;
                        TreeNode&lt;K,V&gt; lo &#x3D; null, loTail &#x3D; null;
                        TreeNode&lt;K,V&gt; hi &#x3D; null, hiTail &#x3D; null;
                        int lc &#x3D; 0, hc &#x3D; 0;
                        for (Node&lt;K,V&gt; e &#x3D; t.first; e !&#x3D; null; e &#x3D; e.next) &#123;
                            int h &#x3D; e.hash;
                            TreeNode&lt;K,V&gt; p &#x3D; new TreeNode&lt;K,V&gt;
                                (h, e.key, e.val, null, null);
                            if ((h &amp; n) &#x3D;&#x3D; 0) &#123;
                                if ((p.prev &#x3D; loTail) &#x3D;&#x3D; null)
                                    lo &#x3D; p;
                                else
                                    loTail.next &#x3D; p;
                                loTail &#x3D; p;
                                ++lc;
                            &#125;
                            else &#123;
                                if ((p.prev &#x3D; hiTail) &#x3D;&#x3D; null)
                                    hi &#x3D; p;
                                else
                                    hiTail.next &#x3D; p;
                                hiTail &#x3D; p;
                                ++hc;
                            &#125;
                        &#125;
                        &#x2F;&#x2F; 如果一分为二后，节点数少于 8，那么将红黑树转换回链表
                        ln &#x3D; (lc &lt;&#x3D; UNTREEIFY_THRESHOLD) ? untreeify(lo) :
                            (hc !&#x3D; 0) ? new TreeBin&lt;K,V&gt;(lo) : t;
                        hn &#x3D; (hc &lt;&#x3D; UNTREEIFY_THRESHOLD) ? untreeify(hi) :
                            (lc !&#x3D; 0) ? new TreeBin&lt;K,V&gt;(hi) : t;
 
                        &#x2F;&#x2F; 将 ln 放置在新数组的位置 i
                        setTabAt(nextTab, i, ln);
                        &#x2F;&#x2F; 将 hn 放置在新数组的位置 i+n
                        setTabAt(nextTab, i + n, hn);
                        &#x2F;&#x2F; 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，
                        &#x2F;&#x2F;    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了
                        setTabAt(tab, i, fwd);
                        &#x2F;&#x2F; advance 设置为 true，代表该位置已经迁移完毕
                        advance &#x3D; true;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。</p>
<p>这个时候，再回去仔细看 tryPresize 方法可能就会更加清晰一些了。</p>
<h4 id="get-过程分析-3"><a href="#get-过程分析-3" class="headerlink" title="get 过程分析"></a>get 过程分析</h4><p>get 方法从来都是最简单的，这里也不例外：</p>
<p>1.计算 hash 值</p>
<p>2.根据 hash 值找到数组对应位置: (n – 1) &amp; h</p>
<p>3.根据该位置处结点性质进行相应查找</p>
<ul>
<li>如果该位置为 null，那么直接返回 null 就可以了</li>
<li>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</li>
<li>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法</li>
<li>如果以上 3 条都不满足，那就是链表，进行遍历比对即可。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">public V get(Object key) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;
    int h &#x3D; spread(key.hashCode());
    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;
        (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123;
        &#x2F;&#x2F; 判断头结点是否就是我们需要的节点
        if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123;
            if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek)))
                return e.val;
        &#125;
        &#x2F;&#x2F; 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树
        else if (eh &lt; 0)
            &#x2F;&#x2F; 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)
            return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;
 
        &#x2F;&#x2F; 遍历链表
        while ((e &#x3D; e.next) !&#x3D; null) &#123;
            if (e.hash &#x3D;&#x3D; h &amp;&amp;
                ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))
                return e.val;
        &#125;
    &#125;
    return null;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，ForwardingNode.find(int h, Object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了，所以限于篇幅这里也不展开说了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实也不是很难嘛，虽然没有像之前的 AQS 和线程池一样一行一行源码进行分析，但还是把所有初学者可能会糊涂的地方都进行了深入的介绍，只要是稍微有点基础的读者，应该是很容易就能看懂 HashMap 和 ConcurrentHashMap 源码了。</p>
<p>看源码不算是目的吧，深入地了解 Doug Lea 的设计思路，我觉得还挺有趣的，大师就是大师，代码写得真的是好啊。</p>
<p>我发现很多人都以为我写博客主要是源码分析，说真的，我对于源码分析没有那么大热情，主要都是为了用源码说事罢了，可能之后的文章还是会有比较多的源码分析成分，大家该怎么看就怎么看吧。</p>
<p>不要脸地自以为本文的质量还是挺高的，信息量比较大，如果你觉得有写得不好的地方，或者说看完本文你还是没看懂它们，那么请提出来~~~</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/10/15/%E9%9B%86%E5%90%88/HashMap,%20ConcurrentHashMap%20%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81/">http://example.com/2025/10/15/集合/HashMap, ConcurrentHashMap 原理及源码/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">只有那年胜过年年</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9B%86%E5%90%88/">集合</a></div><div class="post-share"><div class="social-share" data-image="/img/logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/10/15/%E9%9B%86%E5%90%88/Java%20%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96%20List%20%E9%9B%86%E5%90%88%E7%9A%84%206%20%E7%A7%8D%E6%96%B9%E5%BC%8F!/" title="Java 中初始化 List 集合的 6 种方式!"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Java 中初始化 List 集合的 6 种方式!</div></div><div class="info-2"><div class="info-item-1">List 是 Java 开发中经常会使用的集合，你们知道有哪些方式可以初始化一个 List 吗？这其中不缺乏一些坑，今天栈长我给大家一一普及一下。 1、常规方式List&lt;String&gt; languages &#x3D; new ArrayList&lt;&gt;(); languages.add(&quot;Java&quot;); languages.add(&quot;PHP&quot;); languages.add(&quot;Python&quot;); System.out.println(languages);  这种就是我们平常用的最多最平常的方式了，没什么好说的，后面缺失的泛型类型在 JDK 7 之后就可以不用写具体的类型了，改进后会自动推断类型。 2、Arrays 工具类List&lt;String&gt; jdks &#x3D; asList(&quot;JDK6&quot;, &quot;JDK8&quot;, &quot;JDK10&quot;); System.out.println(jdks);  注意，上面的 asList 是 Arra...</div></div></div></a><a class="pagination-related" href="/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E4%B8%AD%E7%9A%84%206%20%E9%A2%97%E8%AF%AD%E6%B3%95%E7%B3%96/" title="Java 中的 6 颗语法糖"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Java 中的 6 颗语法糖</div></div><div class="info-2"><div class="info-item-1">语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言本身功能来说没有什么影响，只是为了方便程序员的开发，提高开发效率。说白了，语法糖就是对现有语法的一个封装。 Java作为一种与平台无关的高级语言，当然也含有语法糖，这些语法糖并不被虚拟机所支持，在编译成字节码阶段就自动转换成简单常用语法。 一般来说Java中的语法糖主要有以下几种：   泛型与类型擦除  自动装箱与拆箱 变长参数 增强for循环  内部类 枚举类  泛型与类型擦除 Java语言并不是一开始就支持泛型的。在早期的JDK中，只能通过Object类是所有类型的父类和强制类型转换来实现泛型的功能。强制类型转换的缺点就是把编译期间的问题延迟到运行时，JVM并不能为我们提供编译期间的检查。 在JDK1.5中，Java语言引入了泛型机制。但是这种泛型机制是通过类型擦除来实现的，即Java中的泛型只在程序源代码中有效（源代码阶段提供类型检查），在编译后的字节码中自动用强制类型转换进行替代。也就是说，Java语言中的泛型机制其实就是一颗语法糖，相较与C++、C#相比，其泛型实现实在...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/10/15/%E9%9B%86%E5%90%88/HashMap%20%E5%92%8C%20Hashtable%20%E7%9A%84%206%20%E4%B8%AA%E5%8C%BA%E5%88%AB/" title="HashMap 和 Hashtable 的 6 个区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-10-15</div><div class="info-item-2">HashMap 和 Hashtable 的 6 个区别</div></div><div class="info-2"><div class="info-item-1">HashMap 和 Hashtable 是 Java 开发程序员必须要掌握的，也是在各种 Java 面试场合中必须会问到的。 但你对这两者的区别了解有多少呢？ 现在，栈长我给大家总结一下，或许有你不明朗的地方，在栈长的指点下都会拨开迷雾见晴天。 1、线程安全Hashtable 是线程安全的，HashMap 不是线程安全的。 为什么说 HashTable 是线程安全的？ 来看下 Hashtable 的源码，Hashtable 所有的元素操作都是 synchronized 修饰的，而 HashMap 并没有。 public synchronized V put(K key, V value); public synchronized V get(Object key); ...  2、性能优劣既然 Hashtable 是线程安全的，每个方法都要阻塞其他线程，所以 Hashtable 性能较差，HashMap 性能较好，使用更广。 如果要线程安全又要保证性能，建议使用 JUC 包下的 ConcurrentHashMap。 3、NULLHashtable 是不允许键或值为 null 的，...</div></div></div></a><a class="pagination-related" href="/2025/10/15/%E9%9B%86%E5%90%88/Hashtable%20%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AB%20HashTable%EF%BC%9F/" title="Hashtable 为什么不叫 HashTable？"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-10-15</div><div class="info-item-2">Hashtable 为什么不叫 HashTable？</div></div><div class="info-2"><div class="info-item-1"> 什么是驼峰命名规则，来看下面的关键字：  HashMap ArrayList ConcurrentHashMap  简单来说就是，标识符的每个单词首字母必须大写，看起来像是驼峰的形状。  当时就很好奇，Hashtable 为什么不是 HashTable 呢？作为一名初级的 Java 程序员都应该知道的基本的驼峰命名规则，为什么 JDK 代码里面还有这种不规范的命名呢？ 我想大家应该都比较好奇，我特意去查了下资料，没有查到官方的说法，不过在 stackoverflow 上看到了同样的这个问题。 原贴如下：  https://stackoverflow.com/questions/12506706/why-is-the-t-in-hash-tablehashtable-in-java-not-capitalized   最佳答案是：  Hashtable was created in Java v1. The consistent naming conventions for collections were established later, in Java2, when th...</div></div></div></a><a class="pagination-related" href="/2025/10/15/%E9%9B%86%E5%90%88/Java%20%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96%20List%20%E9%9B%86%E5%90%88%E7%9A%84%206%20%E7%A7%8D%E6%96%B9%E5%BC%8F!/" title="Java 中初始化 List 集合的 6 种方式!"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-10-15</div><div class="info-item-2">Java 中初始化 List 集合的 6 种方式!</div></div><div class="info-2"><div class="info-item-1">List 是 Java 开发中经常会使用的集合，你们知道有哪些方式可以初始化一个 List 吗？这其中不缺乏一些坑，今天栈长我给大家一一普及一下。 1、常规方式List&lt;String&gt; languages &#x3D; new ArrayList&lt;&gt;(); languages.add(&quot;Java&quot;); languages.add(&quot;PHP&quot;); languages.add(&quot;Python&quot;); System.out.println(languages);  这种就是我们平常用的最多最平常的方式了，没什么好说的，后面缺失的泛型类型在 JDK 7 之后就可以不用写具体的类型了，改进后会自动推断类型。 2、Arrays 工具类List&lt;String&gt; jdks &#x3D; asList(&quot;JDK6&quot;, &quot;JDK8&quot;, &quot;JDK10&quot;); System.out.println(jdks);  注意，上面的 asList 是 Arra...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java7-HashMap"><span class="toc-number">1.</span> <span class="toc-text">Java7 HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#put-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.1.</span> <span class="toc-text">put 过程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.1.</span> <span class="toc-text">数组初始化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%85%B7%E4%BD%93%E6%95%B0%E7%BB%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.1.2.</span> <span class="toc-text">计算具体数组位置</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E5%88%B0%E9%93%BE%E8%A1%A8%E4%B8%AD"><span class="toc-number">1.1.3.</span> <span class="toc-text">添加节点到链表中</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9"><span class="toc-number">1.1.4.</span> <span class="toc-text">数组扩容</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">get 过程分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java7-ConcurrentHashMap"><span class="toc-number">2.</span> <span class="toc-text">Java7 ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#put-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90-1"><span class="toc-number">2.2.</span> <span class="toc-text">put 过程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A7%BD-ensureSegment"><span class="toc-number">2.2.1.</span> <span class="toc-text">初始化槽: ensureSegment</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%86%99%E5%85%A5%E9%94%81-scanAndLockForPut"><span class="toc-number">2.2.2.</span> <span class="toc-text">获取写入锁: scanAndLockForPut</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9-rehash"><span class="toc-number">2.2.3.</span> <span class="toc-text">扩容: rehash</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90-1"><span class="toc-number">2.3.</span> <span class="toc-text">get 过程分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">2.4.</span> <span class="toc-text">并发问题分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java8-HashMap"><span class="toc-number">3.</span> <span class="toc-text">Java8 HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#put-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90-2"><span class="toc-number">3.1.</span> <span class="toc-text">put 过程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9-1"><span class="toc-number">3.1.1.</span> <span class="toc-text">数组扩容</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90-2"><span class="toc-number">3.2.</span> <span class="toc-text">get 过程分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java8-ConcurrentHashMap"><span class="toc-number">4.</span> <span class="toc-text">Java8 ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">4.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#put-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90-3"><span class="toc-number">4.2.</span> <span class="toc-text">put 过程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84%EF%BC%9AinitTable"><span class="toc-number">4.2.1.</span> <span class="toc-text">初始化数组：initTable</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91-treeifyBin"><span class="toc-number">4.2.2.</span> <span class="toc-text">链表转红黑树: treeifyBin</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%EF%BC%9AtryPresize"><span class="toc-number">4.3.</span> <span class="toc-text">扩容：tryPresize</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%EF%BC%9Atransfer"><span class="toc-number">4.3.1.</span> <span class="toc-text">数据迁移：transfer</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90-3"><span class="toc-number">4.4.</span> <span class="toc-text">get 过程分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: transparent;"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By John Doe</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://walinecomments-gxccu74d8-chens-projects-7c4f92c5.vercel.app',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>