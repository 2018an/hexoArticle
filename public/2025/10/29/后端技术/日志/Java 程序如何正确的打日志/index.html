<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 程序如何正确的打日志 | 只有那年胜过年年</title><meta name="author" content="2025"><meta name="copyright" content="2025"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#FC5531"><meta name="description" content="什么是日志简单的说，日志就是记录程序的运行轨迹，方便查找关键信息，也方便快速定位解决问题。 我们Java程序员在开发项目时都是依赖 Eclipse&#x2F; Idea 等开发工具的 Debug 调试功能来跟踪解决 Bug，在开发环境可以这么做，但项目发布到了测试、生产环境呢？你有可能会说可以使用远程调试，但实际并不能允许让你这么做。 所以，日志的作用就是在测试、生产环境没有 Debug 调试工具">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 程序如何正确的打日志">
<meta property="og:url" content="http://example.com/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%BF%97/Java%20%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%89%93%E6%97%A5%E5%BF%97/index.html">
<meta property="og:site_name" content="只有那年胜过年年">
<meta property="og:description" content="什么是日志简单的说，日志就是记录程序的运行轨迹，方便查找关键信息，也方便快速定位解决问题。 我们Java程序员在开发项目时都是依赖 Eclipse&#x2F; Idea 等开发工具的 Debug 调试功能来跟踪解决 Bug，在开发环境可以这么做，但项目发布到了测试、生产环境呢？你有可能会说可以使用远程调试，但实际并不能允许让你这么做。 所以，日志的作用就是在测试、生产环境没有 Debug 调试工具">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/logo.png">
<meta property="article:published_time" content="2025-10-29T09:30:25.000Z">
<meta property="article:modified_time" content="2025-10-31T03:07:09.007Z">
<meta property="article:author" content="2025">
<meta property="article:tag" content="日志">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/logo.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java 程序如何正确的打日志",
  "url": "http://example.com/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%BF%97/Java%20%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%89%93%E6%97%A5%E5%BF%97/",
  "image": "http://example.com/img/logo.png",
  "datePublished": "2025-10-29T09:30:25.000Z",
  "dateModified": "2025-10-31T03:07:09.007Z",
  "author": [
    {
      "@type": "Person",
      "name": 2025,
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%BF%97/Java%20%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%89%93%E6%97%A5%E5%BF%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#FC5531')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#FC5531')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: 2025","link":"链接: ","source":"来源: 只有那年胜过年年","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 程序如何正确的打日志',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">357</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/logo.png" alt="Logo"><span class="site-name">只有那年胜过年年</span></a><a class="nav-page-title" href="/"><span class="site-name">Java 程序如何正确的打日志</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java 程序如何正确的打日志</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-29T09:30:25.000Z" title="发表于 2025-10-29 17:30:25">2025-10-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-31T03:07:09.007Z" title="更新于 2025-10-31 11:07:09">2025-10-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h3 id="什么是日志"><a href="#什么是日志" class="headerlink" title="什么是日志"></a>什么是日志</h3><p>简单的说，日志就是记录程序的运行轨迹，方便查找关键信息，也方便快速定位解决问题。</p>
<p>我们Java程序员在开发项目时都是依赖 Eclipse&#x2F; Idea 等开发工具的 Debug 调试功能来跟踪解决 Bug，在开发环境可以这么做，但项目发布到了测试、生产环境呢？你有可能会说可以使用远程调试，但实际并不能允许让你这么做。</p>
<p>所以，日志的作用就是在测试、生产环境没有 Debug 调试工具时开发、测试人员定位问题的手段。日志打得好，就能根据日志的轨迹快速定位并解决线上问题，反之，日志输出不好不能定位到问题不说反而会影响系统的性能。</p>
<p>优秀的项目都是能根据日志定位问题的，而不是在线调试，或者半天找不到有用的日志而抓狂…</p>
<h3 id="常用日志框架"><a href="#常用日志框架" class="headerlink" title="常用日志框架"></a>常用日志框架</h3><p>log4j, Logging, commons-logging, slf4j, logback, 开发的同学对这几个日志相关的技术不陌生吧，为什么有这么多日志技术，它们都是什么区别和联系呢？相信大多数人搞不清楚它们的关系，下面我将一一介绍一下，以后大家再也不用傻傻分不清楚了。</p>
<ul>
<li><strong>Logging</strong></li>
</ul>
<p>如图所示，这是 Java 自带的日志工具类，在 JDK 1.5 开始就已经有了，在 <code>java.util.logging</code> 包下。</p>
<p><img src="http://img.javastack.cn/18-5-2/8748931.jpg"></p>
<p>更多关于 Java Logging 的介绍可以看官方文档。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/logging/overview.html">https://docs.oracle.com/javase/8/docs/technotes/guides/logging/overview.html</a></p>
</blockquote>
<ul>
<li><strong>Log4j</strong></li>
</ul>
<p>Log4j 是 Apache 的一个开源日志框架，也是市场占有率最多的一个框架。大多数没用过 Java Logging, 但没人敢说没用过 Log4j 吧，反正从我接触 Java 开始就是这种情况，做 Java 项目必有 Log4j 日志框架。</p>
<p>注意：log4j 在 2015&#x2F;08&#x2F;05 这一天被 Apache 宣布停止维护了，用户需要切换到 Log4j2上面去。</p>
<p>下面是官方宣布原文：</p>
<blockquote>
<p>On August 5, 2015 the Logging Services Project Management Committee announced that Log4j 1.x had reached end of life. For complete text of the announcement please see the Apache Blog. Users of Log4j 1 are recommended to upgrade to Apache Log4j 2.</p>
</blockquote>
<p>Log4j2 的官方地址：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://logging.apache.org/log4j/2.x/">https://logging.apache.org/log4j/2.x/</a></p>
</blockquote>
<ul>
<li><strong>commons-logging</strong></li>
</ul>
<p>上面介绍的 log4j 是一个具体的日志框架的实现，而 commons-logging 就是日志的门面接口，它也是 apache 最早提供的日志门面接口，用户可以根据喜好选择不同的日志实现框架，而不必改动日志定义，这就是日志门面的好处，符合面对接口抽象编程。</p>
<p>更多的详细说明可以参考官方说明：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://commons.apache.org/proper/commons-logging/">http://commons.apache.org/proper/commons-logging/</a></p>
</blockquote>
<ul>
<li><strong>Slf4j</strong></li>
</ul>
<p>全称：Simple Logging Facade for Java，即简单日志门面接口，和 Apache 的 commons-logging 是一样的概念，它们都不是具体的日志框架，你可以指定其他主流的日志实现框架。</p>
<p>Slf4j 的官方地址：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.slf4j.org/">https://www.slf4j.org/</a></p>
</blockquote>
<p>Slf4j 也是现在主流的日志门面框架，使用 Slf4j 可以很灵活的使用占位符进行参数占位，简化代码，拥有更好的可读性，这个后面会讲到。</p>
<ul>
<li><strong>Logback</strong></li>
</ul>
<p>Logback 是 <code>Slf4j </code> 的原生实现框架，同样也是出自 <code>Log4j</code> 一个人之手，但拥有比 <code>log4j</code> 更多的优点、特性和更做强的性能，现在基本都用来代替 <code>log4j</code> 成为主流。</p>
<p>Logback 的官方地址：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://logback.qos.ch/">https://logback.qos.ch/</a></p>
</blockquote>
<p><strong>为什么 Logback 会成为主流？</strong></p>
<p>无论从设计上还是实现上，Logback相对log4j而言有了相对多的改进。不过尽管难以一一细数，这里还是列举部分理由为什么选择logback而不是log4j。牢记logback与log4j在概念上面是很相似的，它们都是有同一群开发者建立。所以如果你已经对log4j很熟悉，你也可以很快上手logback。如果你喜欢使用log4j,你也许会迷上使用logback。</p>
<p><strong>更快的执行速度</strong></p>
<p>基于我们先前在log4j上的工作，logback 重写了内部的实现，在某些特定的场景上面，甚至可以比之前的速度快上10倍。在保证logback的组件更加快速的同时，同时所需的内存更加少。</p>
<p>更多请参考《从Log4j迁移到LogBack的理由 》：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://www.oschina.net/translate/reasons-to-prefer-logbak-over-log4j">http://www.oschina.net/translate/reasons-to-prefer-logbak-over-log4j</a></p>
</blockquote>
<h4 id="日志框架总结"><a href="#日志框架总结" class="headerlink" title="日志框架总结"></a>日志框架总结</h4><p>1、<code>commons-loggin</code>, <code>slf4j</code> 只是一种日志抽象门面，不是具体的日志框架。</p>
<p>2、<code>log4j</code>, <code>logback</code> 是具体的日志实现框架。</p>
<p>3、一般首选强烈推荐使用 <code>slf4j + logback</code>。当然也可以使用<code>slf4j + log4j</code>, <code>commons-logging + log4j</code> 这两种日志组合框架。</p>
<p><img src="http://img.javastack.cn/18-5-2/21444405.jpg"></p>
<p>从上图可以看出 <code>slf4j</code> 很强大吧，不但能和各种日志框架对接，还能和日志门面 <code>commons-logging</code> 进行融合。</p>
<h3 id="日志级别详解"><a href="#日志级别详解" class="headerlink" title="日志级别详解"></a>日志级别详解</h3><p>日志的输出都是分级别的，不同的设置不同的场合打印不同的日志。下面拿最普遍用的 <code>Log4j</code> 日志框架来做个日志级别的说明，这个也比较奇全，其他的日志框架也都大同小异。</p>
<p>Log4j 的级别类 <code>org.apache.log4j.Level</code> 里面定义了日志级别，日志输出优先级由高到底分别为以下8种。</p>
<p><img src="http://img.javastack.cn/18-2-27/44471775.jpg"></p>
<table>
<thead>
<tr>
<th>日志级别</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>OFF</td>
<td>关闭：最高级别，不输出日志。</td>
</tr>
<tr>
<td>FATAL</td>
<td>致命：输出非常严重的可能会导致应用程序终止的错误。</td>
</tr>
<tr>
<td>ERROR</td>
<td>错误：输出错误，但应用还能继续运行。</td>
</tr>
<tr>
<td>WARN</td>
<td>警告：输出可能潜在的危险状况。</td>
</tr>
<tr>
<td>INFO</td>
<td>信息：输出应用运行过程的详细信息。</td>
</tr>
<tr>
<td>DEBUG</td>
<td>调试：输出更细致的对调试应用有用的信息。</td>
</tr>
<tr>
<td>TRACE</td>
<td>跟踪：输出更细致的程序运行轨迹。</td>
</tr>
<tr>
<td>ALL</td>
<td>所有：输出所有级别信息。</td>
</tr>
</tbody></table>
<p>所以，日志优先级别标准顺序为：</p>
<blockquote>
<p>ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF</p>
</blockquote>
<p>如果日志设置为 <code>L</code> ,一个级别为 <code>P</code> 的输出日志只有当 <code>P &gt;= L</code> 时日志才会输出。</p>
<p>即如果日志级别L设置INFO，只有P的输出级别为INFO、WARN，后面的日志才会正常输出。</p>
<p>具体的输出关系可以参考下图：</p>
<p><img src="http://img.javastack.cn/18-2-27/77007337.jpg" alt="image"></p>
<p><strong>知道了日志级别，这还只是基础，如何了解打日志的规范，以及如何正确地打日志姿势呢？！</strong></p>
<p><img src="http://img.javastack.cn/18-2-27/42201304.jpg" alt="image"></p>
<h4 id="打日志的规范准则"><a href="#打日志的规范准则" class="headerlink" title="打日志的规范准则"></a>打日志的规范准则</h4><p>最开始也说过了，日志不能乱打，不然起不到日志本应该起到的作用不说，还会造成系统的负担。在BAT、华为一些大公司都是对日志规范有要求的，什么时候该打什么日志都是有规范的。</p>
<p>阿里去年发布的《Java开发手册》，里面有一章节就是关于日志规范的，让我们再来回顾下都有什么内容。</p>
<p><strong>下面是阿里的《Java开发手册》终极版日志规约篇。</strong></p>
<p><img src="http://img.javastack.cn/18-4-29/8351917.jpg"></p>
<p>阿里是一线互联网公司，所制定的日志规范也都符合我们的要求，很有参考意义，能把阿里这套日志规约普及也真很不错了。</p>
<h4 id="项目中该如何正确的打日志？"><a href="#项目中该如何正确的打日志？" class="headerlink" title="项目中该如何正确的打日志？"></a>项目中该如何正确的打日志？</h4><p><strong>1、正确的定义日志</strong></p>
<pre class="line-numbers language-none"><code class="language-none">private static final Logger LOG &#x3D; LoggerFactory.getLogger(this.getClass());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>通常一个类只有一个 LOG 对象，如果有父类可以将 LOG 定义在父类中。</p>
<p>日志变量类型定义为门面接口（如 slf4j 的 Logger），实现类可以是 <code>Log4j</code>、<code>Logback </code> 等日志实现框架，不要把实现类定义为变量类型，否则日志切换不方便，也不符合抽象编程思想。</p>
<p><strong>2、使用参数化形式<code>{}</code>占位，<code>[]</code> 进行参数隔离</strong></p>
<pre class="line-numbers language-none"><code class="language-none">LOG.debug(&quot;Save order with order no：[&#123;&#125;], and order amount：[&#123;&#125;]&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这种可读性好，这样一看就知道<code>[]</code>里面是输出的动态参数，<code>{}</code>用来占位类似绑定变量，而且只有真正准备打印的时候才会处理参数，方便定位问题。</p>
<p>如果日志框架不支持参数化形式，且日志输出时不支持该日志级别时会导致对象冗余创建，浪费内存，此时就需要使用 <code>isXXEnabled</code> 判断，如：</p>
<pre class="line-numbers language-none"><code class="language-none">if(LOG.isDebugEnabled())&#123;
    &#x2F;&#x2F; 如果日志不支持参数化形式，debug又没开启，那字符串拼接就是无用的代码拼接，影响系统性能
    logger.debug(&quot;Save order with order no：&quot; + orderNo + &quot;, and order amount：&quot; + orderAmount);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>至少 <code>debug</code> 级别是需要开启判断的，线上日志级别至少应该是 <code>info</code> 以上的。</p>
<p>这里推荐大家用 <code>SLF4J</code> 的门面接口，可以用参数化形式输出日志，<code>debug</code>  级别也不必用 <code>if</code> 判断，简化代码。</p>
<p><strong>3、输出不同级别的日志</strong></p>
<p>项目中最常用有日志级别是<code>ERROR</code>、<code>WARN</code>、<code>INFO</code>、<code>DEBUG</code>四种了，这四个都有怎样的应用场景呢。</p>
<ul>
<li><strong>ERROR（错误）</strong></li>
</ul>
<p>一般用来记录程序中发生的任何异常错误信息（Throwable），或者是记录业务逻辑出错。</p>
<ul>
<li><strong>WARN（警告）</strong></li>
</ul>
<p>一般用来记录一些用户输入参数错误、</p>
<ul>
<li><strong>INFO（信息）</strong></li>
</ul>
<p>这个也是平时用的最低的，也是默认的日志级别，用来记录程序运行中的一些有用的信息。如程序运行开始、结束、耗时、重要参数等信息，需要注意有选择性的有意义的输出，到时候自己找问题看一堆日志却找不到关键日志就没意义了。</p>
<ul>
<li><strong>DEBUG（调试）</strong></li>
</ul>
<p>这个级别一般记录一些运行中的中间参数信息，只允许在开发环境开启，选择性在测试环境开启。</p>
<h3 id="几个错误的打日志方式"><a href="#几个错误的打日志方式" class="headerlink" title="几个错误的打日志方式"></a>几个错误的打日志方式</h3><p><strong>1、不要使用 <code>System.out.print..</code></strong></p>
<p>输出日志的时候只能通过日志框架来输出日志，而不能使用<code>System.out.print..</code>来打印日志，这个只会打印到 <code>tomcat</code> 控制台，而不会记录到日志文件中，不方便管理日志，如果通过服务形式启动把日志丢弃了那更是找不到日志了。</p>
<p><strong>2、不要使用 <code>e.printStackTrace()</code></strong></p>
<p>首先来看看它的源码：</p>
<pre class="line-numbers language-none"><code class="language-none">public void printStackTrace() &#123;
    printStackTrace(System.err);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>它其实也是利用 <code>System.err</code> 输出到了 <code>tomcat</code> 控制台。</p>
<p><strong>3、不要抛出异常后又输出日志</strong></p>
<p>如捕获异常后又抛出了自定义业务异常，此时无需记录错误日志，由最终捕获方进行异常处理。不能又抛出异常，又打印错误日志，不然会造成重复输出日志。</p>
<pre class="line-numbers language-none"><code class="language-none">try &#123;
	&#x2F;&#x2F; ...
&#125; catch (Exception e) &#123;
    &#x2F;&#x2F; 错误
	LOG.error(&quot;xxx&quot;, e);
	throw new RuntimeException();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>4、不要使用具体的日志实现类</strong></p>
<pre class="line-numbers language-none"><code class="language-none">
InterfaceImpl interface &#x3D; new InterfaceImpl();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这段代码大家都看得懂吧？应该面向接口的对象编程，而不是面向实现，这也是软件设计模式的原则，正确的做法应该是。</p>
<pre class="line-numbers language-none"><code class="language-none">
Interface interface &#x3D; new InterfaceImpl();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>日志框架里面也是如此，上面也说了，日志有门面接口，有具体实现的实现框架，所以大家不要面向实现编程。</p>
<p><strong>5、没有输出全部错误信息</strong></p>
<p>看以下代码，这样不会记录详细的堆栈异常信息，只会记录错误基本描述信息，不利于排查问题。</p>
<pre class="line-numbers language-none"><code class="language-none">try &#123;
	&#x2F;&#x2F; ...
&#125; catch (Exception e) &#123;
    &#x2F;&#x2F; 错误
	LOG.error(&#39;XX 发生异常&#39;, e.getMessage());

    &#x2F;&#x2F; 正确
    LOG.error(&#39;XX 发生异常&#39;, e);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>6、不要使用错误的日志级别</strong></p>
<p>曾经在线上定位一个问题，同事自信地和我说：<code>明明输出了日志啊，为什么找不到...</code>，后来我去看了下他的代码，是这样的：</p>
<pre class="line-numbers language-none"><code class="language-none">try &#123;
	&#x2F;&#x2F; ...
&#125; catch (Exception e) &#123;
    &#x2F;&#x2F; 错误
	LOG.info(&quot;XX 发生异常...&quot;, e);
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>大家看出了什么问题吗？用 <code>info</code> 记录 <code>error</code> 日志，日志输出到了 <code>info</code> 日志文件中了，同事拼命地在 <code>error</code> 错误日志文件里面找怎么能找到呢？</p>
<p><strong>7、不要在千层循环中打印日志</strong></p>
<p>这个是什么意思，如果你的框架使用了性能不高的 <code>Log4j</code> 框架，那就不要在上千个 <code>for</code> 循环中打印日志，这样可能会拖垮你的应用程序，如果你的程序响应时间变慢，那要考虑是不是日志打印的过多了。</p>
<pre class="line-numbers language-none"><code class="language-none">for(int i&#x3D;0; i&lt;2000; i++)&#123;
    LOG.info(&quot;XX&quot;);
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>最好的办法是在循环中记录要点，在循环外面总结打印出来。</p>
<p><strong>8、禁止在线上环境开启 <code>debug</code></strong></p>
<p>这是最后一点，也是最重要的一点。</p>
<p>一是因为项目本身 <code>debug</code> 日志太多，二是各种框架中也大量使用 <code>debug</code> 的日志，线上开启 <code>debug</code> 不久就会打满磁盘，影响业务系统的正常运行。</p>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">2025</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%BF%97/Java%20%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%89%93%E6%97%A5%E5%BF%97/">http://example.com/2025/10/29/后端技术/日志/Java 程序如何正确的打日志/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">只有那年胜过年年</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%97%A5%E5%BF%97/">日志</a></div><div class="post-share"><div class="social-share" data-image="/img/logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%BF%97/Java%20%E6%AD%A3%E7%A1%AE%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9C%9F%E5%AE%9E%20IP%20%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/" title="Java 正确获取客户端真实 IP 方法整理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Java 正确获取客户端真实 IP 方法整理</div></div><div class="info-2"><div class="info-item-1"> 在JSP里，获取客户端的IP地址的方法是：request.getRemoteAddr()，这种方法在大部分情况下都是有效的。但是在通过了Apache，Squid等反向代理软件就不能获取到客户端的真实IP地址了。 如果使用了反向代理软件，将http://192.168.1.110:2046/的URL反向代理为http://www.abc.com/的URL时，用request.getRemoteAddr()方法获取的IP地址是：127.0.0.1或192.168.1.110，而并不是客户端的真实IP。 经过代理以后，由于在客户端和服务之间增加了中间层，因此服务器无法直接拿到客户端的IP，服务器端应用也无法直接通过转发请求的地址返回给客户端。但是在转发请求的HTTP头信息中，增加了X-FORWARDED-FOR信息。用以跟踪原有的客户端IP地址和原来客户端请求的服务器地址。 当我们访问http://www.abc.com/index.jsp/时，其实并不是我们浏览器真正访问到了服务器上的index.jsp文件，而是先由代理服务器去访问http://192.168.1.110：2046...</div></div></div></a><a class="pagination-related" href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%BF%97/%E5%9D%91%E7%88%B9%E7%9A%84%E6%97%A5%E5%BF%97%E6%97%A0%E6%B3%95%E6%8C%89%E5%A4%A9%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98%EF%BC%81/" title="坑爹的日志无法按天切割问题！"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">坑爹的日志无法按天切割问题！</div></div><div class="info-2"><div class="info-item-1">问题背景线上某个新管理型系统出现了日志无法按天切割生成日志文件的问题，所有的日志都在一个日志文件里面，只有每次重启的时候才会重新生成文件。 这个管理系统使用的是 Spring Boot + Logback 框架，查看了 Logback 的日志文件，发现了策略组合使用问题。 以下是有问题的日志配置代码。 &lt;appender name&#x3D;&quot;FILE&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;     &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;         &lt;level&gt;INFO&lt;&#x2F;level&gt;     &lt;&#x2F;filter&gt;          &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling....</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%BF%97/Java%20%E6%AD%A3%E7%A1%AE%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9C%9F%E5%AE%9E%20IP%20%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/" title="Java 正确获取客户端真实 IP 方法整理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-10-29</div><div class="info-item-2">Java 正确获取客户端真实 IP 方法整理</div></div><div class="info-2"><div class="info-item-1"> 在JSP里，获取客户端的IP地址的方法是：request.getRemoteAddr()，这种方法在大部分情况下都是有效的。但是在通过了Apache，Squid等反向代理软件就不能获取到客户端的真实IP地址了。 如果使用了反向代理软件，将http://192.168.1.110:2046/的URL反向代理为http://www.abc.com/的URL时，用request.getRemoteAddr()方法获取的IP地址是：127.0.0.1或192.168.1.110，而并不是客户端的真实IP。 经过代理以后，由于在客户端和服务之间增加了中间层，因此服务器无法直接拿到客户端的IP，服务器端应用也无法直接通过转发请求的地址返回给客户端。但是在转发请求的HTTP头信息中，增加了X-FORWARDED-FOR信息。用以跟踪原有的客户端IP地址和原来客户端请求的服务器地址。 当我们访问http://www.abc.com/index.jsp/时，其实并不是我们浏览器真正访问到了服务器上的index.jsp文件，而是先由代理服务器去访问http://192.168.1.110：2046...</div></div></div></a><a class="pagination-related" href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%BF%97/%E5%9D%91%E7%88%B9%E7%9A%84%E6%97%A5%E5%BF%97%E6%97%A0%E6%B3%95%E6%8C%89%E5%A4%A9%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98%EF%BC%81/" title="坑爹的日志无法按天切割问题！"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-10-31</div><div class="info-item-2">坑爹的日志无法按天切割问题！</div></div><div class="info-2"><div class="info-item-1">问题背景线上某个新管理型系统出现了日志无法按天切割生成日志文件的问题，所有的日志都在一个日志文件里面，只有每次重启的时候才会重新生成文件。 这个管理系统使用的是 Spring Boot + Logback 框架，查看了 Logback 的日志文件，发现了策略组合使用问题。 以下是有问题的日志配置代码。 &lt;appender name&#x3D;&quot;FILE&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;     &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;         &lt;level&gt;INFO&lt;&#x2F;level&gt;     &lt;&#x2F;filter&gt;          &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling....</div></div></div></a><a class="pagination-related" href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E7%9A%84%208%20%E7%A7%8D%E7%BA%A7%E5%88%AB%EF%BC%8C%E5%BE%88%E8%AF%A6%E7%BB%86/" title="日志打印的 8 种级别，很详细"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-10-29</div><div class="info-item-2">日志打印的 8 种级别，很详细</div></div><div class="info-2"><div class="info-item-1">日志的输出都是分级别的，不同的设置不同的场合打印不同的日志。下面拿最普遍用的Log4j日志框架来做个日志级别的说明，其他大同小异。 Log4j的级别类org.apache.log4j.Level里面定义了日志级别，日志输出优先级由高到底分别为以下8种。     日志级别 描述    OFF 关闭：最高级别，不打印日志。   FATAL 致命：指明非常严重的可能会导致应用终止执行错误事件。   ERROR 错误：指明错误事件，但应用可能还能继续运行。   WARN 警告：指明可能潜在的危险状况。   INFO 信息：指明描述信息，从粗粒度上描述了应用运行过程。   DEBUG 调试：指明细致的事件信息，对调试应用最有用。   TRACE 跟踪：指明程序运行轨迹，比DEBUG级别的粒度更细。   ALL 所有：所有日志级别，包括定制级别。   所以，日志优先级别标准顺序为：  ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF  如果日志设置为L,一个级别为P的输出日志只有当P &g...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A5%E5%BF%97"><span class="toc-number">1.</span> <span class="toc-text">什么是日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6"><span class="toc-number">2.</span> <span class="toc-text">常用日志框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.</span> <span class="toc-text">日志框架总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">日志级别详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E6%97%A5%E5%BF%97%E7%9A%84%E8%A7%84%E8%8C%83%E5%87%86%E5%88%99"><span class="toc-number">3.1.</span> <span class="toc-text">打日志的规范准则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%AF%A5%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%89%93%E6%97%A5%E5%BF%97%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">项目中该如何正确的打日志？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E6%89%93%E6%97%A5%E5%BF%97%E6%96%B9%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">几个错误的打日志方式</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: transparent;"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By 2025</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://walinecomments-gxccu74d8-chens-projects-7c4f92c5.vercel.app',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>