
<!DOCTYPE html>
<html>
<head>
    <title>只有那年胜过年年</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
    <link rel="manifest" href="/favicon/site.webmanifest">
    <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css">
    <link href="https://cdn.staticfile.org/twitter-bootstrap/5.1.1/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css">
    <script src="https://cdn.staticfile.org/twitter-bootstrap/5.1.1/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"></script>
    
<link rel="stylesheet" href="/css/prism.css">
 
    
<link rel="stylesheet" href="/css/markdown.css">
 
    
<script src="/js/prism.js"></script>

    
<link rel="stylesheet" href="/css/index.css">
 
    
<script src="/js/search.js"></script>


     
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            },
            svg: {
                fontCache: 'global'
            }
        };
        </script>
     

     
        <script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"> </script>
        
<script src="/js/fancybox.js"></script>

    

    <script type="text/javascript">

        var search_path = "/search.xml";
        if (search_path.length == 0) {
            search_path = "search.xml";
        }
        var path = search_path;
        searchFunc(path, 'local-search-input', 'local-search-result');
    </script>
<meta name="generator" content="Hexo 7.3.0"></head>
 
<body>
    <!-- 导航栏 -->
    <!-- 导航栏 -->
<nav class="navbar navbar-expand-md navbar-dark bg-dark mb-4 pt-2 pb-2">
    <div class="container">
        <!-- 标题 --> 
        <a class="navbar-brand navbar-expand-sm" href="/">
            <img class="nofancybox" src="/logo.png" style="width: 75px;"  alt="笑颜网">
        </a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse"
                aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <!-- 左边右边导航按钮 --> 
        <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav me-auto">
                <!-- 左右两侧的导航栏 -->

 
 

    <li class="nav-item">
        <a class="nav-link" href="/">
           <big> <i class="fa fa-home ps-1" ></i> 主页</big>
        </a>
    </li>

    <li class="nav-item">
        <a class="nav-link" href="/archives">
           <big> <i class="fa fa-archive ps-1" ></i> 归档</big>
        </a>
    </li>

    <li class="nav-item">
        <a class="nav-link" href="/about">
           <big> <i class="fa fa-user ps-1" ></i> 关于</big>
        </a>
    </li>
 
 
            </ul>

            
            <form class="">
                <div class="d-flex">
                    <button class="btn text-muted fa fa-search d-none d-md-block d-lg-block" disabled></button>
                    <input id="local-search-input" class="form-control me-2 pe-4" type="search"
                            placeholder="搜索 " aria-label="Search">
                </div>
                <div id="local-search-result" style="position:absolute; padding-top: 8px; max-height: 960px; width: 480px;overflow-y: scroll; z-index: 1050;"></div>
            </form>
            
            <ul class="navbar-nav">
                <!-- 左右两侧的导航栏 -->

 
 
            </ul>
        </div>
    </div>
</nav>


    <main class="container">
        
<div class="container-fluid markdown-section">
<div class="row pb-3">
    <div class="col-md-8 col-sm-12">
        <!-- 博客详情 -->
        <div class="">
            <p class="h2">
                <span class="post-title">
                    关于 Java 序列化你不知道的 5 件事
                </span>   
            </p>

            <div class="pb-3 pt-1 pe-3">
                <i class="fa fa-calendar p-1"></i>
                2025/10/14 14:42:34 
                
                    <i class="fa fa-folder-open p-1"> </i> 
                    <span class="tag-hover">
                        
                            <a href="/categories/%E5%90%8E%E7%AB%AF/ " class="link-dark text-decoration-none"> 
                                后端 
                            </a>
                         
                    </span>
                

                
                    <i class="fa fa-tag p-1"> </i>
                    <span class="tag-hover">
                        
                            <a href="/tags/%E5%9F%BA%E7%A1%80/" class="link-dark text-decoration-none"> 
                                基础 
                            </a>
                        
                    </span>
                
            </div>

            <div class="border-bottom pb-2">
                <h3 id="关于本系列"><a href="#关于本系列" class="headerlink" title="关于本系列"></a>关于本系列</h3><p>大约一年前，一个负责管理应用程序所有用户设置的开发人员，决定将用户设置存储在一个 Hashtable中，然后将这个 Hashtable 序列化到磁盘，以便持久化。当用户更改设置时，便重新将 Hashtable 写到磁盘。</p>
<p>这是一个优雅的、开放式的设置系统，但是，当团队决定从 Hashtable 迁移到 Java Collections 库中的HashMap 时，这个系统便面临崩溃。</p>
<p>Hashtable 和 HashMap 在磁盘上的格式是不相同、不兼容的。除非对每个持久化的用户设置运行某种类型的数据转换实用程序（极其庞大的任务），否则以后似乎只能一直用Hashtable 作为应用程序的存储格式。</p>
<p>团队感到陷入僵局，但这只是因为他们不知道关于 Java 序列化的一个重要事实：Java 序列化允许随着时间的推移而改变类型。当我向他们展示如何自动进行序列化替换后，他们终于按计划完成了向 HashMap 的转变。</p>
<p>本文是本系列的第一篇文章，这个系列专门揭示关于 Java 平台的一些有用的小知识 — 这些小知识不易理解，但对于解决 Java 编程挑战迟早有用。</p>
<p>将 Java 对象序列化 API 作为开端是一个不错的选择，因为它从一开始就存在于 JDK 1.1 中。本文介绍的关于序列化的 5 件事情将说服您重新审视那些标准 Java API。</p>
<h3 id="Java-序列化简介"><a href="#Java-序列化简介" class="headerlink" title="Java 序列化简介"></a>Java 序列化简介</h3><p>Java 对象序列化是 JDK 1.1 中引入的一组开创性特性之一，用于作为一种将 Java 对象的状态转换为字节数组，以便存储或传输的机制，以后，仍可以将字节数组转换回 Java 对象原有的状态。</p>
<p>实际上，序列化的思想是 “冻结” 对象状态，传输对象状态（写到磁盘、通过网络传输等等），然后 “解冻” 状态，重新获得可用的 Java 对象。所有这些事情的发生有点像是魔术，这要归功于 ObjectInputStream&#x2F;ObjectOutputStream 类、完全保真的元数据以及程序员愿意用Serializable 标识接口标记他们的类，从而 “参与” 这个过程。</p>
<p>清单 1 显示一个实现 Serializable 的 Person 类。</p>
<p><strong>清单 1. Serializable Person</strong></p>
<pre class="line-numbers language-none"><code class="language-none">package com.tedneward;

public class Person
    implements java.io.Serializable
&#123;
    public Person(String fn, String ln, int a)
    &#123;
        this.firstName &#x3D; fn; this.lastName &#x3D; ln; this.age &#x3D; a;
    &#125;

    public String getFirstName() &#123; return firstName; &#125;
    public String getLastName() &#123; return lastName; &#125;
    public int getAge() &#123; return age; &#125;
    public Person getSpouse() &#123; return spouse; &#125;

    public void setFirstName(String value) &#123; firstName &#x3D; value; &#125;
    public void setLastName(String value) &#123; lastName &#x3D; value; &#125;
    public void setAge(int value) &#123; age &#x3D; value; &#125;
    public void setSpouse(Person value) &#123; spouse &#x3D; value; &#125;

    public String toString()
    &#123;
        return &quot;[Person: firstName&#x3D;&quot; + firstName + 
            &quot; lastName&#x3D;&quot; + lastName +
            &quot; age&#x3D;&quot; + age +
            &quot; spouse&#x3D;&quot; + spouse.getFirstName() +
            &quot;]&quot;;
    &#125;    

    private String firstName;
    private String lastName;
    private int age;
    private Person spouse;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将 Person 序列化后，很容易将对象状态写到磁盘，然后重新读出它，下面的 JUnit 4 单元测试对此做了演示。</p>
<p><strong>清单 2. 对 Person 进行反序列化</strong></p>
<pre class="line-numbers language-none"><code class="language-none">public class SerTest
&#123;
    @Test public void serializeToDisk()
    &#123;
        try
        &#123;
            com.tedneward.Person ted &#x3D; new com.tedneward.Person(&quot;Ted&quot;, &quot;Neward&quot;, 39);
            com.tedneward.Person charl &#x3D; new com.tedneward.Person(&quot;Charlotte&quot;,
                &quot;Neward&quot;, 38);

            ted.setSpouse(charl); charl.setSpouse(ted);

            FileOutputStream fos &#x3D; new FileOutputStream(&quot;tempdata.ser&quot;);
            ObjectOutputStream oos &#x3D; new ObjectOutputStream(fos);
            oos.writeObject(ted);
            oos.close();
        &#125;
        catch (Exception ex)
        &#123;
            fail(&quot;Exception thrown during test: &quot; + ex.toString());
        &#125;

        try
        &#123;
            FileInputStream fis &#x3D; new FileInputStream(&quot;tempdata.ser&quot;);
            ObjectInputStream ois &#x3D; new ObjectInputStream(fis);
            com.tedneward.Person ted &#x3D; (com.tedneward.Person) ois.readObject();
            ois.close();

            assertEquals(ted.getFirstName(）， &quot;Ted&quot;);
            assertEquals(ted.getSpouse().getFirstName(）， &quot;Charlotte&quot;);

            &#x2F;&#x2F; Clean up the file
            new File(&quot;tempdata.ser&quot;).delete();
        &#125;
        catch (Exception ex)
        &#123;
            fail(&quot;Exception thrown during test: &quot; + ex.toString());
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>到现在为止，还没有看到什么新鲜的或令人兴奋的事情，但是这是一个很好的出发点。我们将使用 Person 来发现您可能不 知道的关于 Java 对象序列化 的 5 件事。</p>
<h4 id="1-序列化允许重构"><a href="#1-序列化允许重构" class="headerlink" title="1. 序列化允许重构"></a>1. 序列化允许重构</h4><p>序列化允许一定数量的类变种，甚至重构之后也是如此，ObjectInputStream 仍可以很好地将其读出来。<br>Java Object Serialization 规范可以自动管理的关键任务是：</p>
<ul>
<li><p>将新字段添加到类中</p>
</li>
<li><p>将字段从 static 改为非 static</p>
</li>
<li><p>将字段从 transient 改为非 transient</p>
</li>
</ul>
<p>取决于所需的向后兼容程度，转换字段形式（从非 static 转换为 static 或从非 transient 转换为 transient）或者删除字段需要额外的消息传递。</p>
<p><strong>重构序列化类</strong></p>
<p>既然已经知道序列化允许重构，我们来看看当把新字段添加到 Person 类中时，会发生什么事情。</p>
<p>如清单 3 所示，PersonV2 在原先 Person 类的基础上引入一个表示性别的新字段。</p>
<p><strong>清单 3. 将新字段添加到序列化的 Person 中</strong></p>
<pre class="line-numbers language-none"><code class="language-none">enum Gender
&#123;
    MALE, FEMALE
&#125;

public class Person
    implements java.io.Serializable
&#123;
    public Person(String fn, String ln, int a, Gender g)
    &#123;
        this.firstName &#x3D; fn; this.lastName &#x3D; ln; this.age &#x3D; a; this.gender &#x3D; g;
    &#125;

    public String getFirstName() &#123; return firstName; &#125;
    public String getLastName() &#123; return lastName; &#125;
    public Gender getGender() &#123; return gender; &#125;
    public int getAge() &#123; return age; &#125;
    public Person getSpouse() &#123; return spouse; &#125;

    public void setFirstName(String value) &#123; firstName &#x3D; value; &#125;
    public void setLastName(String value) &#123; lastName &#x3D; value; &#125;
    public void setGender(Gender value) &#123; gender &#x3D; value; &#125;
    public void setAge(int value) &#123; age &#x3D; value; &#125;
    public void setSpouse(Person value) &#123; spouse &#x3D; value; &#125;

    public String toString()
    &#123;
        return &quot;[Person: firstName&#x3D;&quot; + firstName + 
            &quot; lastName&#x3D;&quot; + lastName +
            &quot; gender&#x3D;&quot; + gender +
            &quot; age&#x3D;&quot; + age +
            &quot; spouse&#x3D;&quot; + spouse.getFirstName() +
            &quot;]&quot;;
    &#125;    

    private String firstName;
    private String lastName;
    private int age;
    private Person spouse;
    private Gender gender;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>序列化使用一个 hash，该 hash 是根据给定源文件中几乎所有东西 — 方法名称、字段名称、字段类型、访问修改方法等 — 计算出来的，序列化将该 hash 值与序列化流中的 hash 值相比较。</p>
<p>为了使 Java 运行时相信两种类型实际上是一样的，第二版和随后版本的 Person 必须与第一版有相同的序列化版本 hash（存储为 private static final serialVersionUID 字段）。</p>
<p>因此，我们需要 serialVersionUID 字段，它是通过对原始（或 V1）版本的 Person 类运行 JDK serialver命令计算出的。</p>
<p>一旦有了 Person 的 serialVersionUID，不仅可以从原始对象 Person 的序列化数据创建 PersonV2 对象（当出现新字段时，新字段被设为缺省值，最常见的是“null”），还可以反过来做：即从 PersonV2 的数据通过反序列化得到 Person，这毫不奇怪。</p>
<h4 id="2-序列化并不安全"><a href="#2-序列化并不安全" class="headerlink" title="2. 序列化并不安全"></a>2. 序列化并不安全</h4><p>让 Java 开发人员诧异并感到不快的是，序列化二进制格式完全编写在文档中，并且完全可逆。实际上，只需将二进制序列化流的内容转储到控制台，就足以看清类是什么样子，以及它包含什么内容。</p>
<p>这对于安全性有着不良影响。例如，当通过 RMI 进行远程方法调用时，通过连接发送的对象中的任何 private 字段几乎都是以明文的方式出现在套接字流中，这显然容易招致哪怕最简单的安全问题。</p>
<p>幸运的是，序列化允许 “hook” 序列化过程，并在序列化之前和反序列化之后保护（或模糊化）字段数据。可以通过在 Serializable 对象上提供一个 writeObject 方法来做到这一点。</p>
<p><strong>模糊化序列化数据</strong></p>
<p>假设 Person 类中的敏感数据是 age 字段。毕竟，女士忌谈年龄。 我们可以在序列化之前模糊化该数据，将数位循环左移一位，然后在反序列化之后复位。（您可以开发更安全的算法，当前这个算法只是作为一个例子。）</p>
<p>为了 “hook” 序列化过程，我们将在 Person 上实现一个 writeObject 方法；为了 “hook” 反序列化过程，我们将在同一个类上实现一个readObject 方法。重要的是这两个方法的细节要正确 — 如果访问修改方法、参数或名称不同于清单 4 中的内容，那么代码将不被察觉地失败，Person 的 age 将暴露。</p>
<p><strong>清单 4. 模糊化序列化数据</strong></p>
<pre class="line-numbers language-none"><code class="language-none">public class Person
    implements java.io.Serializable
&#123;
    public Person(String fn, String ln, int a)
    &#123;
        this.firstName &#x3D; fn; this.lastName &#x3D; ln; this.age &#x3D; a;
    &#125;

    public String getFirstName() &#123; return firstName; &#125;
    public String getLastName() &#123; return lastName; &#125;
    public int getAge() &#123; return age; &#125;
    public Person getSpouse() &#123; return spouse; &#125;

    public void setFirstName(String value) &#123; firstName &#x3D; value; &#125;
    public void setLastName(String value) &#123; lastName &#x3D; value; &#125;
    public void setAge(int value) &#123; age &#x3D; value; &#125;
    public void setSpouse(Person value) &#123; spouse &#x3D; value; &#125;

    private void writeObject(java.io.ObjectOutputStream stream)
        throws java.io.IOException
    &#123;
        &#x2F;&#x2F; &quot;Encrypt&quot;&#x2F;obscure the sensitive data
        age &#x3D; age &lt;&lt; 2;
        stream.defaultWriteObject();
    &#125;

    private void readObject(java.io.ObjectInputStream stream)
        throws java.io.IOException, ClassNotFoundException
    &#123;
        stream.defaultReadObject();

        &#x2F;&#x2F; &quot;Decrypt&quot;&#x2F;de-obscure the sensitive data
        age &#x3D; age &lt;&lt; 2;
    &#125;

    public String toString()
    &#123;
        return &quot;[Person: firstName&#x3D;&quot; + firstName + 
            &quot; lastName&#x3D;&quot; + lastName +
            &quot; age&#x3D;&quot; + age +
            &quot; spouse&#x3D;&quot; + (spouse!&#x3D;null ? spouse.getFirstName() : &quot;[null]&quot;) +
            &quot;]&quot;;
    &#125;      

    private String firstName;
    private String lastName;
    private int age;
    private Person spouse;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果需要查看被模糊化的数据，总是可以查看序列化数据流&#x2F;文件。而且，由于该格式被完全文档化，即使不能访问类本身，也仍可以读取序列化流中的内容。</p>
<h4 id="3-序列化的数据可以被签名和密封"><a href="#3-序列化的数据可以被签名和密封" class="headerlink" title="3. 序列化的数据可以被签名和密封"></a>3. 序列化的数据可以被签名和密封</h4><p>上一个技巧假设您想模糊化序列化数据，而不是对其加密或者确保它不被修改。当然，通过使用 writeObject 和 readObject 可以实现密码加密和签名管理，但其实还有更好的方式。</p>
<p>如果需要对整个对象进行加密和签名，最简单的是将它放在一个 javax.crypto.SealedObject 和&#x2F;或 java.security.SignedObject 包装器中。两者都是可序列化的，所以将对象包装在 SealedObject 中可以围绕原对象创建一种“包装盒”。必须有对称密钥才能解密，而且密钥必须单独管理。同样，也可以将 SignedObject 用于数据验证，并且对称密钥也必须单独管理。</p>
<p>结合使用这两种对象，便可以轻松地对序列化数据进行密封和签名，而不必强调关于数字签名验证或加密的细节。很简洁，是吧？</p>
<h4 id="4-序列化允许将代理放在流中"><a href="#4-序列化允许将代理放在流中" class="headerlink" title="4. 序列化允许将代理放在流中"></a>4. 序列化允许将代理放在流中</h4><p>很多情况下，类中包含一个核心数据元素，通过它可以派生或找到类中的其他字段。在此情况下，没有必要序列化整个对象。可以将字段标记为 transient，但是每当有方法访问一个字段时，类仍然必须显式地产生代码来检查它是否被初始化。</p>
<p>如果首要问题是序列化，那么最好指定一个 flyweight 或代理放在流中。为原始 Person 提供一个 writeReplace 方法，可以序列化不同类型的对象来代替它。类似地，如果反序列化期间发现一个 readResolve 方法，那么将调用该方法，将替代对象提供给调用者。</p>
<p><strong>打包和解包代理</strong></p>
<p>writeReplace 和 readResolve 方法使 Person 类可以将它的所有数据（或其中的核心数据）打包到一个 PersonProxy 中，将它放入到一个流中，然后在反序列化时再进行解包。</p>
<p><strong>清单 5. 你完整了我，我代替了你</strong></p>
<pre class="line-numbers language-none"><code class="language-none">class PersonProxy
    implements java.io.Serializable
&#123;
    public PersonProxy(Person orig)
    &#123;
        data &#x3D; orig.getFirstName() + &quot;,&quot; + orig.getLastName() + &quot;,&quot; + orig.getAge();
        if (orig.getSpouse() !&#x3D; null)
        &#123;
            Person spouse &#x3D; orig.getSpouse();
            data &#x3D; data + &quot;,&quot; + spouse.getFirstName() + &quot;,&quot; + spouse.getLastName() + &quot;,&quot;  
              + spouse.getAge();
        &#125;
    &#125;

    public String data;
    private Object readResolve()
        throws java.io.ObjectStreamException
    &#123;
        String[] pieces &#x3D; data.split(&quot;,&quot;);
        Person result &#x3D; new Person(pieces[0], pieces[1], Integer.parseInt(pieces[2]));
        if (pieces.length &gt; 3)
        &#123;
            result.setSpouse(new Person(pieces[3], pieces[4], Integer.parseInt
              (pieces[5])));
            result.getSpouse().setSpouse(result);
        &#125;
        return result;
    &#125;
&#125;

public class Person
    implements java.io.Serializable
&#123;
    public Person(String fn, String ln, int a)
    &#123;
        this.firstName &#x3D; fn; this.lastName &#x3D; ln; this.age &#x3D; a;
    &#125;

    public String getFirstName() &#123; return firstName; &#125;
    public String getLastName() &#123; return lastName; &#125;
    public int getAge() &#123; return age; &#125;
    public Person getSpouse() &#123; return spouse; &#125;

    private Object writeReplace()
        throws java.io.ObjectStreamException
    &#123;
        return new PersonProxy(this);
    &#125;

    public void setFirstName(String value) &#123; firstName &#x3D; value; &#125;
    public void setLastName(String value) &#123; lastName &#x3D; value; &#125;
    public void setAge(int value) &#123; age &#x3D; value; &#125;
    public void setSpouse(Person value) &#123; spouse &#x3D; value; &#125;   

    public String toString()
    &#123;
        return &quot;[Person: firstName&#x3D;&quot; + firstName + 
            &quot; lastName&#x3D;&quot; + lastName +
            &quot; age&#x3D;&quot; + age +
            &quot; spouse&#x3D;&quot; + spouse.getFirstName() +
            &quot;]&quot;;
    &#125;    

    private String firstName;
    private String lastName;
    private int age;
    private Person spouse;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意，PersonProxy 必须跟踪 Person 的所有数据。这通常意味着代理需要是 Person 的一个内部类，以便能访问 private 字段。有时候，代理还需要追踪其他对象引用并手动序列化它们，例如 Person 的 spouse。</p>
<p>这种技巧是少数几种不需要读&#x2F;写平衡的技巧之一。例如，一个类被重构成另一种类型后的版本可以提供一个 readResolve 方法，以便静默地将被序列化的对象转换成新类型。类似地，它可以采用 writeReplace 方法将旧类序列化成新版本。</p>
<h4 id="5-信任，但要验证"><a href="#5-信任，但要验证" class="headerlink" title="5. 信任，但要验证"></a>5. 信任，但要验证</h4><p>认为序列化流中的数据总是与最初写到流中的数据一致，这没有问题。但是，正如一位美国前总统所说的，“信任，但要验证”。<br>对于序列化的对象，这意味着验证字段，以确保在反序列化之后它们仍具有正确的值，“以防万一”。</p>
<p>为此，可以实现 ObjectInputValidation接口，并覆盖 validateObject() 方法。如果调用该方法时发现某处有错误，则抛出一个 InvalidObjectException。</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>Java 对象序列化比大多数 Java 开发人员想象的更灵活，这使我们有更多的机会解决棘手的情况。</p>
<p>幸运的是，像这样的编程妙招在 JVM 中随处可见。关键是要知道它们，在遇到难题的时候能用上它们。</p>
<p>来源：<a target="_blank" rel="noopener" href="http://www.topthink.com/topic/11361.html">www.topthink.com/topic/11361.html</a></p>
 
            </div>
        </div>
        
            <div class="mt-3">
                <!-- 前一页后一页 -->
<div class="previous-next-links">
     
    <div class="previous-design-link">
        <a href="/2025/10/14/%E5%9F%BA%E7%A1%80/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%90%9E%E6%87%82%20transient%20%E5%85%B3%E9%94%AE%E5%AD%97%E4%BA%86%E5%90%97%EF%BC%9F/">
            <i style="font-size:16px;" class="fa fa-arrow-left" aria-hidden="true"></i>
            你真的搞懂 transient 关键字了吗？
        </a>
    </div>
     

     
    <div class="next-design-link">
        <a href="/2025/10/14/%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8EJava%E5%BA%8F%E5%88%97%E5%8C%96%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E5%88%87/">
            关于Java序列化你应该知道的一切
            <i style="font-size:16px;" class="fa fa-arrow-right" aria-hidden="true"></i>
        </a>
    </div>
 
</div> 
             
            </div>
        

    </div>
    <div class="col-4 pe-0">
        <div class="d-none d-sm-none d-md-block sticky-top border-start">
             
    
        <div class="toc">
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%B3%BB%E5%88%97"><span class="toc-number">1.</span> <span class="toc-text">关于本系列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">Java 序列化简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F%E8%AF%AD"><span class="toc-number">3.</span> <span class="toc-text">结束语</span></a></li></ol> 
        </div>
    
 

        </div>
    </div>
</div>
</div>
 
    </main>

    <!-- 底部栏 -->
    <footer class="bg-dark pt-3 pb-0 mt-5 fixed-bottom" id="flex_bottom">
    <div class="container pb-3 pt-3 text-center">
        <p class="text-muted tag-hover">
            All Rights Reserved <i class="fa fa-copyright"></i> by2025  <br>
<!--             Powered by  -->
<!--              <a class="link-secondary text-decoration-none" target="_blank" rel="noopener" href="https://hexo.io"> -->
<!--                  Hexo.io -->
<!--             </a> &  <a class="link-secondary text-decoration-none" target="_blank" rel="noopener" href="https://github.com/smile-yan/hexo-theme-heyan"> -->
<!--                heyan -->
<!--             </a> -->
            <br>
<!--             <a class="link-secondary text-decoration-none" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/index"> -->
<!--                 <img src="/police.png" style="width: 18px; height: 18px; margin-top: -4px" class="nofancybox"> -->
<!--                   -->
<!--             </a> -->
        </p>
    </div>
</footer>

</body>

<script>
    // 检查页面内容高度是否小于窗口高度
    function checkContentHeight() {
        const contentHeight = document.body.scrollHeight;
        const windowHeight = window.innerHeight;

        if (contentHeight < windowHeight) {
            // 内容高度不足以填充整个窗口，固定底部导航栏
            document.getElementById('flex_bottom').classList.add('fixed-bottom');
        } else {
            // 内容高度足够多，不固定底部导航栏
            document.getElementById('flex_bottom').classList.remove('fixed-bottom');
        }
    }

    // 页面加载时和窗口大小变化时检查内容高度
    window.addEventListener('load', checkContentHeight);
    window.addEventListener('resize', checkContentHeight);
</script>
</html>