---
title: 实现自定义类加载器加载外部类文件
date: 2025-10-15 11:36:33
category: 后端
tags: 进阶
---

当需要加载不在classpath下的类文件时，可通过自定义ClassLoader实现。以下示例演示如何加载位于 c:/test/com/test/jdk/Key.class
的类。

目标类：

text
package com.test.jdk;
public class Key {
private String key = "111111";
}
自定义类加载器：

text
import org.apache.commons.io.IOUtils;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

public class LocalClassLoader extends ClassLoader {
private String path = "c:/test/";
@Override
protected Class<?> findClass(String name) throws ClassNotFoundException {
        Class<?> cls = findLoadedClass(name);
if (cls != null) return cls;
if (!name.endsWith(".Key")) return super.loadClass(name);
try {
InputStream is = new FileInputStream(path + name.replace(".", "/") + ".class");
byte[] bytes = IOUtils.toByteArray(is);
return defineClass(name, bytes, 0, bytes.length);
} catch (IOException e) { e.printStackTrace(); }
return super.loadClass(name);
}
}
使用自定义加载器加载类：

text
public static void main(String[] args) {
try {
LocalClassLoader lcl = new LocalClassLoader();
Class<?> cls = lcl.loadClass("com.test.jdk.Key");
Field field = cls.getDeclaredField("key");
field.setAccessible(true);
Object value = field.get(cls.newInstance());
System.out.println(value); // 输出：111111
} catch (Exception e) { e.printStackTrace(); }
}
使用URLClassLoader简化实现：
实际上，若只是加载指定路径下的类，可直接使用JDK内置的URLClassLoader：

text
public static void main(String[] args) {
try {
URLClassLoader ucl = new URLClassLoader(new URL[]{new URL("file:/c:/test/")});
Class<?> cls = ucl.loadClass("com.test.jdk.Key");
// 后续操作同上
} catch (Exception e) { e.printStackTrace(); }
}
后者无需重写findClass，更适合简单的外部类加载场景。